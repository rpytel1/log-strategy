2b7e22e20b09102367682253a09b7056491626e8fe40724cddb52a58858d5000
getSimulatedSessionExpirationPercent
public int getSimulatedSessionExpirationPercent()
{    return expirationPercent;}
5acffd8f8ccff1b4afda12e02b5c90d604a4c6ec0e32c04d54b3b45c54f4cc04
callWithRetry
public T callWithRetry(CuratorZookeeperClient client, Callable<T> proc) throws Exception
{    client.internalBlockUntilConnectedOrTimedOut();    T result = null;    RetryLoop retryLoop = client.newRetryLoop();    while (retryLoop.shouldContinue()) {        try {            result = proc.call();            retryLoop.markComplete();        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);            retryLoop.takeException(e);        }    }    return result;}
c6d3a1c6c2bf5d4cbf4b9c3a0f0d01c50064eaf0377b0c69ae38928ad1899f78
checkTimeouts
public CheckTimeoutsResult checkTimeouts(Callable<String> hasNewConnectionString, long connectionStartMs, int sessionTimeoutMs, int connectionTimeoutMs) throws Exception
{    if (hasNewConnectionString.call() != null) {        return CheckTimeoutsResult.NEW_CONNECTION_STRING;    }    return CheckTimeoutsResult.NOP;}
f0891f7aab88f7cc4a33be47483c9249645409f0730f2bb08db5362769b1e641
getZooKeeper
 ZooKeeper getZooKeeper() throws Exception
{    if (SessionFailRetryLoop.sessionForThreadHasFailed()) {        throw new SessionFailRetryLoop.SessionFailedException();    }    Exception exception = backgroundExceptions.poll();    if (exception != null) {        new EventTrace("background-exceptions", tracer.get()).commit();        throw exception;    }    boolean localIsConnected = isConnected.get();    if (!localIsConnected) {        checkTimeouts();    }    return zooKeeper.getZooKeeper();}
948edbe148994f96d54dcdf5b1390c3efec5c913cf45924e28f12c1995a49bff
isConnected
 boolean isConnected()
{    return isConnected.get();}
8f101449c86baab2969a87a3a7266faf85a5bd26417e524dafe0f5a4d9c5a9da
start
 void start() throws Exception
{    log.debug("Starting");    ensembleProvider.start();    reset();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    close(0);}
e3a02e79092e226484abb480d67692a361e620b6dd2681cfd102313773ca1b49
close
public void close(int waitForShutdownTimeoutMs) throws IOException
{    log.debug("Closing");    CloseableUtils.closeQuietly(ensembleProvider);    try {        zooKeeper.closeAndClear(waitForShutdownTimeoutMs);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new IOException(e);    } finally {        isConnected.set(false);    }}
13c74d3834e9622acbc365c22bbca129b9038de023a2ed38e1ecf44d00ca96fa
addParentWatcher
 void addParentWatcher(Watcher watcher)
{    parentWatchers.offer(watcher);}
e64109349f41ece712191392421ab97691b28b17e536b580f1a13ede76e00b0c
removeParentWatcher
 void removeParentWatcher(Watcher watcher)
{    parentWatchers.remove(watcher);}
bd10e61eb1635d310e15c23aa6debf9b2f031b2e5d29384139cb2247edccf7b5
getInstanceIndex
 long getInstanceIndex()
{    return instanceIndex.get();}
d73cef34b0732437103ffd16b6d2416b760176becb322ae78c1ccc00b22a5112
getLastNegotiatedSessionTimeoutMs
 int getLastNegotiatedSessionTimeoutMs()
{    return lastNegotiatedSessionTimeoutMs.get();}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (LOG_EVENTS) {        log.debug("ConnectState watcher: " + event);    }    if (event.getType() == Watcher.Event.EventType.None) {        boolean wasConnected = isConnected.get();        boolean newIsConnected = checkState(event.getState(), wasConnected);        if (newIsConnected != wasConnected) {            isConnected.set(newIsConnected);            connectionStartMs = System.currentTimeMillis();            if (newIsConnected) {                lastNegotiatedSessionTimeoutMs.set(zooKeeper.getNegotiatedSessionTimeoutMs());                log.debug("Negotiated session timeout: " + lastNegotiatedSessionTimeoutMs.get());            }        }    }    for (Watcher parentWatcher : parentWatchers) {        OperationTrace trace = new OperationTrace("connection-state-parent-process", tracer.get(), getSessionId());        parentWatcher.process(event);        trace.commit();    }}
43c9a2752672bedd281173a30447f2eaa350ce67f3188d390a1caaee5cf83e64
getEnsembleProvider
 EnsembleProvider getEnsembleProvider()
{    return ensembleProvider;}
2517ebf34084b7a8d5a4254a880e46dc0840ad55baf7d4fe2033917c48ab42d7
reset
 synchronized void reset() throws Exception
{    log.debug("reset");    instanceIndex.incrementAndGet();    isConnected.set(false);    connectionStartMs = System.currentTimeMillis();    zooKeeper.closeAndReset();        zooKeeper.getZooKeeper();}
f6e8501c759a6c0570a040e0412d5b7dbed14dace8bf38de9f313c08ce3be5aa
checkTimeouts
private synchronized void checkTimeouts() throws Exception
{    final AtomicReference<String> newConnectionString = new AtomicReference<>();    Callable<String> hasNewConnectionString = new Callable<String>() {        @Override        public String call() {            newConnectionString.set(zooKeeper.getNewConnectionString());            return newConnectionString.get();        }    };    int lastNegotiatedSessionTimeoutMs = getLastNegotiatedSessionTimeoutMs();    int useSessionTimeoutMs = (lastNegotiatedSessionTimeoutMs > 0) ? lastNegotiatedSessionTimeoutMs : sessionTimeoutMs;    ConnectionHandlingPolicy.CheckTimeoutsResult result = connectionHandlingPolicy.checkTimeouts(hasNewConnectionString, connectionStartMs, useSessionTimeoutMs, connectionTimeoutMs);    switch(result) {        default:        case NOP:            {                break;            }        case NEW_CONNECTION_STRING:            {                handleNewConnectionString(newConnectionString.get());                break;            }        case RESET_CONNECTION:            {                if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES)) {                    long elapsed = System.currentTimeMillis() - connectionStartMs;                    int maxTimeout = Math.max(useSessionTimeoutMs, connectionTimeoutMs);                    log.warn(String.format("Connection attempt unsuccessful after %d (greater than max timeout of %d). Resetting connection and trying again with a new connection.", elapsed, maxTimeout));                }                reset();                break;            }        case CONNECTION_TIMEOUT:            {                KeeperException.ConnectionLossException connectionLossException = new CuratorConnectionLossException();                if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES)) {                    long elapsed = System.currentTimeMillis() - connectionStartMs;                    log.error(String.format("Connection timed out for connection string (%s) and timeout (%d) / elapsed (%d)", zooKeeper.getConnectionString(), connectionTimeoutMs, elapsed), connectionLossException);                }                new EventTrace("connections-timed-out", tracer.get(), getSessionId()).commit();                throw connectionLossException;            }        case SESSION_TIMEOUT:            {                handleExpiredSession();                break;            }    }}
975ebaac2e3c57404facb7d01c211677e1a3ef19d7e33af4c2ceba7c63290829
call
public String call()
{    newConnectionString.set(zooKeeper.getNewConnectionString());    return newConnectionString.get();}
3e437e3ce389d9edd2c8010c82daa241c762e45e2cc1aaf3f8533dd221f3dcaf
getSessionId
public long getSessionId()
{    long sessionId = 0;    try {        ZooKeeper zk = zooKeeper.getZooKeeper();        if (zk != null) {            sessionId = zk.getSessionId();        }    } catch (Exception e) {        }    return sessionId;}
e78037b0e2a9ecd1ad6aa59878ee9d68c1b7584d4a0e71f24959e9fe5f07c4aa
checkState
private boolean checkState(Event.KeeperState state, boolean wasConnected)
{    boolean isConnected = wasConnected;    boolean checkNewConnectionString = true;    switch(state) {        default:        case Disconnected:            {                isConnected = false;                break;            }        case SyncConnected:        case ConnectedReadOnly:            {                isConnected = true;                break;            }        case AuthFailed:            {                isConnected = false;                log.error("Authentication failed");                break;            }        case Expired:            {                isConnected = false;                checkNewConnectionString = false;                handleExpiredSession();                break;            }        case SaslAuthenticated:            {                                break;            }    }        if (state != Event.KeeperState.Expired) {        new EventTrace(state.toString(), tracer.get(), getSessionId()).commit();    }    if (checkNewConnectionString) {        String newConnectionString = zooKeeper.getNewConnectionString();        if (newConnectionString != null) {            handleNewConnectionString(newConnectionString);        }    }    return isConnected;}
66da37fc21f48b6e61f8fb75b153e29e48fb9e185c1cb87b3d00d28a169e0988
handleNewConnectionString
private void handleNewConnectionString(String newConnectionString)
{    log.info("Connection string changed to: " + newConnectionString);    new EventTrace("connection-string-changed", tracer.get(), getSessionId()).commit();    try {        ZooKeeper zooKeeper = this.zooKeeper.getZooKeeper();        if (zooKeeper == null) {            log.warn("Could not update the connection string because getZooKeeper() returned null.");        } else {            if (ensembleProvider.updateServerListEnabled()) {                zooKeeper.updateServerList(newConnectionString);            } else {                reset();            }        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        queueBackgroundException(e);    }}
d1412c19f40f3dba4fc8a6e8d0a522a039ebdec845f6762251e8391220de22b9
handleExpiredSession
private void handleExpiredSession()
{    log.warn("Session expired event received");    new EventTrace("session-expired", tracer.get(), getSessionId()).commit();    try {        reset();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        queueBackgroundException(e);    }}
49703d0fc3bfb426dcf62cf97599f19a73053a67ed822ceeedaa8433bdacaeea
queueBackgroundException
private void queueBackgroundException(Exception e)
{    while (backgroundExceptions.size() >= MAX_BACKGROUND_EXCEPTIONS) {        backgroundExceptions.poll();    }    backgroundExceptions.offer(e);}
02afce1efea93ea0f6aefd9f6201282192ccdb3dd5be8fbae6e02ca73617f4fd
getZooKeeper
public ZooKeeper getZooKeeper() throws Exception
{    Preconditions.checkState(started.get(), "Client is not started");    return state.getZooKeeper();}
db2634fabf4b76fb0e592ca8a8de7c83103a59c8dee12505ba4dd2feb6830cc9
newRetryLoop
public RetryLoop newRetryLoop()
{    return new RetryLoop(retryPolicy.get(), tracer);}
752a0fdee1262a2b7a29ecaafe6731faec43345775ff9727bc57d4c7ca2f4b29
newSessionFailRetryLoop
public SessionFailRetryLoop newSessionFailRetryLoop(SessionFailRetryLoop.Mode mode)
{    return new SessionFailRetryLoop(this, mode);}
d281b583c7876c25d7ad9fa27ea2d785aca24efb5315460c0e085a5cb6230e07
isConnected
public boolean isConnected()
{    return state.isConnected();}
78789d8db07d1f58158494d620ecc39e53c3ddba3c7e8530c00743b5fd39ac82
blockUntilConnectedOrTimedOut
public boolean blockUntilConnectedOrTimedOut() throws InterruptedException
{    Preconditions.checkState(started.get(), "Client is not started");    log.debug("blockUntilConnectedOrTimedOut() start");    OperationTrace trace = startAdvancedTracer("blockUntilConnectedOrTimedOut");    internalBlockUntilConnectedOrTimedOut();    trace.commit();    boolean localIsConnected = state.isConnected();    log.debug("blockUntilConnectedOrTimedOut() end. isConnected: " + localIsConnected);    return localIsConnected;}
90ba0dddc593bd95e2a0c0c039c523b81bfb91f87814ebcb222c3914ca772ead
start
public void start() throws Exception
{    log.debug("Starting");    if (!started.compareAndSet(false, true)) {        throw new IllegalStateException("Already started");    }    state.start();}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    close(waitForShutdownTimeoutMs);}
1ff9a012f4451df9d2cbff647ac79886e8a87540f4e2a68a0055c271acad4ab0
close
public void close(int waitForShutdownTimeoutMs)
{    log.debug("Closing, waitForShutdownTimeoutMs {}", waitForShutdownTimeoutMs);    started.set(false);    try {        state.close(waitForShutdownTimeoutMs);    } catch (IOException e) {        ThreadUtils.checkInterrupted(e);        log.error("", e);    }}
580834149a6e0d4e8f5d570a934910d4c796830b251da052be855358538beb47
setRetryPolicy
public void setRetryPolicy(RetryPolicy policy)
{    Preconditions.checkNotNull(policy, "policy cannot be null");    retryPolicy.set(policy);}
f4763efc3fd5158c17c71ee05f7be150862d258ff23fec014d9a01ae7b1409b1
getRetryPolicy
public RetryPolicy getRetryPolicy()
{    return retryPolicy.get();}
6ef87944b6fcb59577da94ffafd333171cd450872358e517e19c56b90ff04070
startTracer
public TimeTrace startTracer(String name)
{    return new TimeTrace(name, tracer.get());}
f2a6d1df20e2a75a940c2968ee8ce7b19d943bb5bfeffa5412ac5ecd75023feb
startAdvancedTracer
public OperationTrace startAdvancedTracer(String name)
{    return new OperationTrace(name, tracer.get(), state.getSessionId());}
7dc054489d10d8a6c20a9c77d2de5db2d5b1b8d9c5cfb4df11c6d2004c2cd386
getTracerDriver
public TracerDriver getTracerDriver()
{    return tracer.get();}
a5a2de5fc05331d86e77c7ac8da7e23e332618d3a31265074f389bd468af4b18
setTracerDriver
public void setTracerDriver(TracerDriver tracer)
{    this.tracer.set(tracer);}
dfdb3439f7c15b279df700a6bebb0bf9a06e55ae4e86b6e76f0801a0ded54496
getCurrentConnectionString
public String getCurrentConnectionString()
{    return state.getEnsembleProvider().getConnectionString();}
e309d1355c8ade029bfe6bdec4e537e6e2d4e8a7ac7b91e9475a23db1906b9a6
getConnectionTimeoutMs
public int getConnectionTimeoutMs()
{    return connectionTimeoutMs;}
a3359ea33621bcbff53ac36ccd2e7a1a4668bd863e82766e82644a190cb43b89
reset
public void reset() throws Exception
{    state.reset();}
2dbcfff36699427b465fe371064559c29ca8cc2c1cca5bda59c04582063691a5
getInstanceIndex
public long getInstanceIndex()
{    return state.getInstanceIndex();}
e47c3253fee26a671fe47023aaf3a2d239cbeda641fa24a6e36ea0d5432f9826
getConnectionHandlingPolicy
public ConnectionHandlingPolicy getConnectionHandlingPolicy()
{    return connectionHandlingPolicy;}
ec09ab2b9ff7ec117a3ec02c7ef664a03f7e30b1d3c50e68c91dd92314f9d3b6
getLastNegotiatedSessionTimeoutMs
public int getLastNegotiatedSessionTimeoutMs()
{    return state.getLastNegotiatedSessionTimeoutMs();}
13c74d3834e9622acbc365c22bbca129b9038de023a2ed38e1ecf44d00ca96fa
addParentWatcher
 void addParentWatcher(Watcher watcher)
{    state.addParentWatcher(watcher);}
e64109349f41ece712191392421ab97691b28b17e536b580f1a13ede76e00b0c
removeParentWatcher
 void removeParentWatcher(Watcher watcher)
{    state.removeParentWatcher(watcher);}
80c4f7a98af134d37101a2e4c9f9d9742398f2eca8ef56c396c19a0fc0ea727a
internalBlockUntilConnectedOrTimedOut
public void internalBlockUntilConnectedOrTimedOut() throws InterruptedException
{    long waitTimeMs = connectionTimeoutMs;    while (!state.isConnected() && (waitTimeMs > 0)) {        final CountDownLatch latch = new CountDownLatch(1);        Watcher tempWatcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                latch.countDown();            }        };        state.addParentWatcher(tempWatcher);        long startTimeMs = System.currentTimeMillis();        long timeoutMs = Math.min(waitTimeMs, 1000);        try {            latch.await(timeoutMs, TimeUnit.MILLISECONDS);        } finally {            state.removeParentWatcher(tempWatcher);        }        long elapsed = Math.max(1, System.currentTimeMillis() - startTimeMs);        waitTimeMs -= elapsed;    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    latch.countDown();}
fc304c2543f3c068598f46ecebae16f4a4a44c4437b4d9f0751b1f477e1051e8
addTrace
public final void addTrace(String name, long time, TimeUnit unit)
{}
f0390d14b281d062c3490d3530374f237c847e323115051e384f2334c6951a20
addCount
public final void addCount(String name, int increment)
{}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return this.name;}
3e437e3ce389d9edd2c8010c82daa241c762e45e2cc1aaf3f8533dd221f3dcaf
getSessionId
public long getSessionId()
{    return this.sessionId;}
609962ed3c13286966d937afa9c301e49ddab59023e4f4c7704fb7ba9630b243
commit
public void commit()
{    if (this.driver instanceof AdvancedTracerDriver) {        ((AdvancedTracerDriver) this.driver).addEvent(this);    } else {        this.driver.addCount(this.name, 1);    }}
e90ba6cdd22c45ccedcd8256775df5bf8c12f57b844278014fa50729d87ac01e
setReturnCode
public OperationTrace setReturnCode(int returnCode)
{    this.returnCode = returnCode;    return this;}
a7126e045060d7f290a659dc35db2698441ea235004474e21695fbf4d42c4500
setRequestBytesLength
public OperationTrace setRequestBytesLength(long length)
{    this.requestBytesLength = length;    return this;}
5f081485956650e4fbab300a7221ff7d3b39a1b78b69d7b060a16e955f13a143
setRequestBytesLength
public OperationTrace setRequestBytesLength(String data)
{    if (data == null) {        return this;    }    try {        this.setRequestBytesLength(data.getBytes("UTF-8").length);    } catch (UnsupportedEncodingException e) {        }    return this;}
e50d11c1e5208649312b54fcb6ede10f76c691962bc95d72ce0888467fec96ea
setRequestBytesLength
public OperationTrace setRequestBytesLength(byte[] data)
{    if (data == null) {        return this;    }    return this.setRequestBytesLength(data.length);}
403343782cab690130fc90a9550a35219938827469c56c3423d54664ea2b6f3c
setResponseBytesLength
public OperationTrace setResponseBytesLength(long length)
{    this.responseBytesLength = length;    return this;}
37f42ec15ece27136a2781f283bce3415a24bb45779ab427c92cb0b92a9f9f3d
setResponseBytesLength
public OperationTrace setResponseBytesLength(byte[] data)
{    if (data == null) {        return this;    }    return this.setResponseBytesLength(data.length);}
158a909255061ee9e192d9aaeb72790a83341b38a9abb89c828b480bc0db0ee7
setPath
public OperationTrace setPath(String path)
{    this.path = path;    return this;}
11cb3ba0210f44e52b0a68ea4839eab8aead300a586140c5a229b3f7069fff42
setWithWatcher
public OperationTrace setWithWatcher(boolean withWatcher)
{    this.withWatcher = withWatcher;    return this;}
ba9280b610ba3e6a050fb8fbd5e9f2ced49c2d907d643822a831cddec5c1f357
setStat
public OperationTrace setStat(Stat stat)
{    this.stat = stat;    return this;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return this.name;}
903bfb83ab067dbf96f238a08d1469d95f320a1d2d454f072f1838a941bb3713
getReturnCode
public int getReturnCode()
{    return this.returnCode;}
c0e6dabdcf70cf862fcd3e9a0f45a0c985da6fe737e3c75e8fbb9cd9488441d6
getLatencyMs
public long getLatencyMs()
{    return this.latencyMs;}
a538c57375b148b4e628a077a8219c544f838bc882e3d7fd8458168a755d4730
getRequestBytesLength
public long getRequestBytesLength()
{    return this.requestBytesLength;}
5105333fdb01a2c6de4caae8880742b283af51f7179bcb789f0108bcaf1f45e9
getResponseBytesLength
public long getResponseBytesLength()
{    return this.responseBytesLength;}
3e437e3ce389d9edd2c8010c82daa241c762e45e2cc1aaf3f8533dd221f3dcaf
getSessionId
public long getSessionId()
{    return this.sessionId;}
58e7b527ecd5014eaf5f30fc9c50ba33e1f005f8ce9d24246253d62377788662
getPath
public String getPath()
{    return this.path;}
03f308466c155d181f659d0b9859390c05469500e2071540ece1d6323f7166b6
isWithWatcher
public boolean isWithWatcher()
{    return this.withWatcher;}
caeb2b7d846f9588cde9a2efecc0ed94309a4fcf52121d0b14624bbd6216398b
getStat
public Stat getStat()
{    return this.stat;}
609962ed3c13286966d937afa9c301e49ddab59023e4f4c7704fb7ba9630b243
commit
public void commit()
{    long elapsed = System.nanoTime() - startTimeNanos;    this.latencyMs = TimeUnit.MILLISECONDS.convert(elapsed, TimeUnit.NANOSECONDS);    if (this.driver instanceof AdvancedTracerDriver) {        ((AdvancedTracerDriver) this.driver).addTrace(this);    } else {        this.driver.addTrace(this.name, elapsed, TimeUnit.NANOSECONDS);    }}
531e6c422cd886c7f675cf80406c0cc18de7e35399deb20edbedc4453d22fdb3
getRaw
public String getRaw(String hostname, int port, String uriPath, String mimeType) throws Exception
{    URI uri = new URI(useSsl ? "https" : "http", null, hostname, port, uriPath, null, null);    HttpURLConnection connection = (HttpURLConnection) uri.toURL().openConnection();    connection.addRequestProperty("Accept", mimeType);    StringBuilder str = new StringBuilder();    InputStream in = new BufferedInputStream(connection.getInputStream());    try {        for (; ; ) {            int b = in.read();            if (b < 0) {                break;            }            str.append((char) (b & 0xff));        }    } finally {        CloseableUtils.closeQuietly(in);    }    return str.toString();}
46bbd96208ea8c8c68705f9dc325c313a3c85223d45425e7d34d17add1867a47
setExhibitors
public void setExhibitors(Exhibitors newExhibitors)
{    exhibitors.set(newExhibitors);    masterExhibitors.set(newExhibitors);}
6636348c4e2a078049a2669bd1664369dac766ef8302dce596b96664d52f44df
pollForInitialEnsemble
public void pollForInitialEnsemble() throws Exception
{    Preconditions.checkState(state.get() == State.LATENT, "Cannot be called after start()");    poll();}
90ba0dddc593bd95e2a0c0c039c523b81bfb91f87814ebcb222c3914ca772ead
start
public void start() throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    service.scheduleWithFixedDelay(new Runnable() {        @Override        public void run() {            poll();        }    }, pollingMs, pollingMs, TimeUnit.MILLISECONDS);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    poll();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    Preconditions.checkState(state.compareAndSet(State.STARTED, State.CLOSED), "Already closed or has not been started");    service.shutdownNow();}
3a15ca2ed8208cd07404b01c15089fa841a6e5aecf12a07cc9d92b33a3adb8ac
getConnectionString
public String getConnectionString()
{    return connectionString.get();}
8288ce4403dd68ee31bc3e4125518f3f79dd8811760a6c6877cce621be05ce5a
setConnectionString
public void setConnectionString(String connectionString)
{    log.info("setConnectionString received. Ignoring. " + connectionString);}
4d8f8c3644e8bcf9c25bb24a5c68147d454045b529f3acc5b3ab9f472ebbed35
updateServerListEnabled
public boolean updateServerListEnabled()
{    return false;}
6446e7a87ec1c28617111793ad5ceec1c7e3b024eaccd5576c7a11b692ab5bf2
poll
protected void poll()
{    Exhibitors localExhibitors = exhibitors.get();    Map<String, String> values = queryExhibitors(localExhibitors);    int count = getCountFromValues(values);    if (count == 0) {        log.warn("0 count returned from Exhibitors. Using backup connection values.");        values = useBackup(localExhibitors);        count = getCountFromValues(values);    }    if (count > 0) {        int port = Integer.parseInt(values.get(VALUE_PORT));        StringBuilder newConnectionString = new StringBuilder();        List<String> newHostnames = Lists.newArrayList();        for (int i = 0; i < count; ++i) {            if (newConnectionString.length() > 0) {                newConnectionString.append(",");            }            String server = values.get(VALUE_SERVER_PREFIX + i);            newConnectionString.append(server).append(":").append(port);            newHostnames.add(server);        }        String newConnectionStringValue = newConnectionString.toString();        if (!newConnectionStringValue.equals(connectionString.get())) {            log.info(String.format("Connection string has changed. Old value (%s), new value (%s)", connectionString.get(), newConnectionStringValue));        }        Exhibitors newExhibitors = new Exhibitors(newHostnames, localExhibitors.getRestPort(), new Exhibitors.BackupConnectionStringProvider() {            @Override            public String getBackupConnectionString() throws Exception {                                return masterExhibitors.get().getBackupConnectionString();            }        });        connectionString.set(newConnectionStringValue);        exhibitors.set(newExhibitors);    }}
9cb4ad22560740b8cbed6b541176305827ec20a5eff5bd35819a431668b9b0cc
getBackupConnectionString
public String getBackupConnectionString() throws Exception
{        return masterExhibitors.get().getBackupConnectionString();}
aaa5c012ebafe27b3b48a68e06ef795d4ed7c137ad55fb84536e89219523f3f0
getCountFromValues
private int getCountFromValues(Map<String, String> values)
{    try {        return Integer.parseInt(values.get(VALUE_COUNT));    } catch (NumberFormatException e) {        }    return 0;}
8ff0b122dff733c7bab187847db29013bacaa1eeb8af18a138618cdf94edabd2
useBackup
private Map<String, String> useBackup(Exhibitors localExhibitors)
{    Map<String, String> values = newValues();    try {        String backupConnectionString = localExhibitors.getBackupConnectionString();        int thePort = -1;        int count = 0;        for (String spec : backupConnectionString.split(",")) {            spec = spec.trim();            String[] parts = spec.split(":");            if (parts.length == 2) {                String hostname = parts[0];                int port = Integer.parseInt(parts[1]);                if (thePort < 0) {                    thePort = port;                } else if (port != thePort) {                    log.warn("Inconsistent port in connection component: " + spec);                }                values.put(VALUE_SERVER_PREFIX + count, hostname);                ++count;            } else {                log.warn("Bad backup connection component: " + spec);            }        }        values.put(VALUE_COUNT, Integer.toString(count));        values.put(VALUE_PORT, Integer.toString(thePort));    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        log.error("Couldn't get backup connection string", e);    }    return values;}
2099040fa523f71ca6dafd6bc6452d19bcccd77f205c0393baeaddcb844917f0
newValues
private Map<String, String> newValues()
{    Map<String, String> values = Maps.newHashMap();    values.put(VALUE_COUNT, "0");    return values;}
701cdd18d54d57b883fe7f300b25656d8b830ddda07ca4312894335675d78ed8
decodeExhibitorList
private static Map<String, String> decodeExhibitorList(String str) throws UnsupportedEncodingException
{    Map<String, String> values = Maps.newHashMap();    for (String spec : str.split("&")) {        String[] parts = spec.split("=");        if (parts.length == 2) {            values.put(parts[0], URLDecoder.decode(parts[1], "UTF-8"));        }    }    return values;}
a796e1eac33223ed4ab4874021980c6c8076febeb290a9fd7d356add9498180e
queryExhibitors
private Map<String, String> queryExhibitors(Exhibitors localExhibitors)
{    Map<String, String> values = newValues();    long start = System.currentTimeMillis();    int retries = 0;    boolean done = false;    while (!done) {        List<String> hostnames = Lists.newArrayList(localExhibitors.getHostnames());        if (hostnames.size() == 0) {            done = true;        } else {            String hostname = hostnames.get(random.nextInt(hostnames.size()));            try {                String encoded = restClient.getRaw(hostname, localExhibitors.getRestPort(), restUriPath, MIME_TYPE);                values.putAll(decodeExhibitorList(encoded));                done = true;            } catch (Throwable e) {                ThreadUtils.checkInterrupted(e);                if (retryPolicy.allowRetry(retries++, System.currentTimeMillis() - start, RetryLoop.getDefaultRetrySleeper())) {                    log.warn("Couldn't get servers from Exhibitor. Retrying.", e);                } else {                    log.error("Couldn't get servers from Exhibitor. Giving up.", e);                    done = true;                }            }        }    }    return values;}
7c5b73674e9ac82cca89d1d0ca6e68912bcf1b0bd3daf2eb2e86af13fe7f2c00
getHostnames
public Collection<String> getHostnames()
{    return hostnames;}
c6eb2c144821830f03dd83759831b583dc82755367aee464131301dc0e5b6298
getRestPort
public int getRestPort()
{    return restPort;}
9cb4ad22560740b8cbed6b541176305827ec20a5eff5bd35819a431668b9b0cc
getBackupConnectionString
public String getBackupConnectionString() throws Exception
{    return backupConnectionStringProvider.getBackupConnectionString();}
90ba0dddc593bd95e2a0c0c039c523b81bfb91f87814ebcb222c3914ca772ead
start
public void start() throws Exception
{}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{}
8288ce4403dd68ee31bc3e4125518f3f79dd8811760a6c6877cce621be05ce5a
setConnectionString
public void setConnectionString(String connectionString)
{    this.connectionString.set(connectionString);}
3a15ca2ed8208cd07404b01c15089fa841a6e5aecf12a07cc9d92b33a3adb8ac
getConnectionString
public String getConnectionString()
{    return connectionString.get();}
4d8f8c3644e8bcf9c25bb24a5c68147d454045b529f3acc5b3ab9f472ebbed35
updateServerListEnabled
public boolean updateServerListEnabled()
{    return updateServerListEnabled;}
f0891f7aab88f7cc4a33be47483c9249645409f0730f2bb08db5362769b1e641
getZooKeeper
 ZooKeeper getZooKeeper() throws Exception
{    return (helper != null) ? helper.getZooKeeper() : null;}
8d0d5fb36f6161350e4e7211f5862af4afd1043c6d6aa8259db63a7caa34f25c
getNegotiatedSessionTimeoutMs
 int getNegotiatedSessionTimeoutMs()
{    return (helper != null) ? helper.getNegotiatedSessionTimeoutMs() : 0;}
1b59d9eb111859fc64cee5c12ff457deb2a26c9bc3c61b99db4a4d70ea3f5771
getConnectionString
 String getConnectionString()
{    return (helper != null) ? helper.getConnectionString() : null;}
caf0c77efecf0b7bdcf1d943c731b58498ab019e7f98757b3d4276e7f7edb043
getNewConnectionString
 String getNewConnectionString()
{    String helperConnectionString = (helper != null) ? helper.getConnectionString() : null;    return ((helperConnectionString != null) && !ensembleProvider.getConnectionString().equals(helperConnectionString)) ? helperConnectionString : null;}
0a85218424cbaa39b2ff476f7cd5dfbbfdde0d12126495c1e045ce0b63be1e1f
closeAndClear
 void closeAndClear(int waitForShutdownTimeoutMs) throws Exception
{    internalClose(waitForShutdownTimeoutMs);    helper = null;}
20684b37359f64e9bdd01fb017cdda89fce15567a0db5164aa58587a142af430
closeAndReset
 void closeAndReset() throws Exception
{    internalClose(0);            helper = new Helper() {        private volatile ZooKeeper zooKeeperHandle = null;        private volatile String connectionString = null;        @Override        public ZooKeeper getZooKeeper() throws Exception {            synchronized (this) {                if (zooKeeperHandle == null) {                    connectionString = ensembleProvider.getConnectionString();                    zooKeeperHandle = zookeeperFactory.newZooKeeper(connectionString, sessionTimeout, watcher, canBeReadOnly);                }                helper = new Helper() {                    @Override                    public ZooKeeper getZooKeeper() throws Exception {                        return zooKeeperHandle;                    }                    @Override                    public String getConnectionString() {                        return connectionString;                    }                    @Override                    public int getNegotiatedSessionTimeoutMs() {                        return (zooKeeperHandle != null) ? zooKeeperHandle.getSessionTimeout() : 0;                    }                };                return zooKeeperHandle;            }        }        @Override        public String getConnectionString() {            return connectionString;        }        @Override        public int getNegotiatedSessionTimeoutMs() {            return (zooKeeperHandle != null) ? zooKeeperHandle.getSessionTimeout() : 0;        }    };}
02afce1efea93ea0f6aefd9f6201282192ccdb3dd5be8fbae6e02ca73617f4fd
getZooKeeper
public ZooKeeper getZooKeeper() throws Exception
{    synchronized (this) {        if (zooKeeperHandle == null) {            connectionString = ensembleProvider.getConnectionString();            zooKeeperHandle = zookeeperFactory.newZooKeeper(connectionString, sessionTimeout, watcher, canBeReadOnly);        }        helper = new Helper() {            @Override            public ZooKeeper getZooKeeper() throws Exception {                return zooKeeperHandle;            }            @Override            public String getConnectionString() {                return connectionString;            }            @Override            public int getNegotiatedSessionTimeoutMs() {                return (zooKeeperHandle != null) ? zooKeeperHandle.getSessionTimeout() : 0;            }        };        return zooKeeperHandle;    }}
02afce1efea93ea0f6aefd9f6201282192ccdb3dd5be8fbae6e02ca73617f4fd
getZooKeeper
public ZooKeeper getZooKeeper() throws Exception
{    return zooKeeperHandle;}
3a15ca2ed8208cd07404b01c15089fa841a6e5aecf12a07cc9d92b33a3adb8ac
getConnectionString
public String getConnectionString()
{    return connectionString;}
a89d6bdbd0029560c65433575b4d04b0ffc95a5f03fe3470eb041a29afd053c6
getNegotiatedSessionTimeoutMs
public int getNegotiatedSessionTimeoutMs()
{    return (zooKeeperHandle != null) ? zooKeeperHandle.getSessionTimeout() : 0;}
3a15ca2ed8208cd07404b01c15089fa841a6e5aecf12a07cc9d92b33a3adb8ac
getConnectionString
public String getConnectionString()
{    return connectionString;}
a89d6bdbd0029560c65433575b4d04b0ffc95a5f03fe3470eb041a29afd053c6
getNegotiatedSessionTimeoutMs
public int getNegotiatedSessionTimeoutMs()
{    return (zooKeeperHandle != null) ? zooKeeperHandle.getSessionTimeout() : 0;}
01150689d4d306f44c5777ae0d72f3d8c8d5ec4e75c142a92c92989fb1a476fa
internalClose
private void internalClose(int waitForShutdownTimeoutMs) throws Exception
{    try {        ZooKeeper zooKeeper = (helper != null) ? helper.getZooKeeper() : null;        if (zooKeeper != null) {            Watcher dummyWatcher = new Watcher() {                @Override                public void process(WatchedEvent event) {                }            };                        zooKeeper.register(dummyWatcher);            if (waitForShutdownTimeoutMs == 0) {                                zooKeeper.close();            } else {                zooKeeper.close(waitForShutdownTimeoutMs);            }        }    } catch (InterruptedException dummy) {        Thread.currentThread().interrupt();    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{}
65ee999b73c249dba89d1a42957ae63db5beae0c04b8c6503fc6b75669e29d75
getMaxSleepTimeMs
public int getMaxSleepTimeMs()
{    return maxSleepTimeMs;}
a728b4f1206e80eaa2c4bb36a7b1af90b4a46d64f62f56a45cc4ba295bfece04
getSleepTimeMs
protected long getSleepTimeMs(int retryCount, long elapsedTimeMs)
{    return Math.min(maxSleepTimeMs, super.getSleepTimeMs(retryCount, elapsedTimeMs));}
f31560582ad7d10cda5e82cc0e7915185ff983e742c60242e6d986ac096179ef
getBaseSleepTimeMs
public int getBaseSleepTimeMs()
{    return baseSleepTimeMs;}
a728b4f1206e80eaa2c4bb36a7b1af90b4a46d64f62f56a45cc4ba295bfece04
getSleepTimeMs
protected long getSleepTimeMs(int retryCount, long elapsedTimeMs)
{        long sleepMs = baseSleepTimeMs * Math.max(1, random.nextInt(1 << (retryCount + 1)));    if (sleepMs > maxSleepMs) {        log.warn(String.format("Sleep extension too large (%d). Pinning to %d", sleepMs, maxSleepMs));        sleepMs = maxSleepMs;    }    return sleepMs;}
25d0e3c482717f1a5d2f1b1bb8cc4d82a5b93d9874f28a2353375a623b8b83b0
validateMaxRetries
private static int validateMaxRetries(int maxRetries)
{    if (maxRetries > MAX_RETRIES_LIMIT) {        log.warn(String.format("maxRetries too large (%d). Pinning to %d", maxRetries, MAX_RETRIES_LIMIT));        maxRetries = MAX_RETRIES_LIMIT;    }    return maxRetries;}
4c63ebeaaff7bb355ad5a04b35052b1142def4893beee8762659de3e7ad378f5
allowRetry
public boolean allowRetry(int retryCount, long elapsedTimeMs, RetrySleeper sleeper)
{    try {        sleeper.sleepFor(retryIntervalMs, TimeUnit.MILLISECONDS);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();        log.warn("Error occurred while sleeping", e);        return false;    }    return true;}
a728b4f1206e80eaa2c4bb36a7b1af90b4a46d64f62f56a45cc4ba295bfece04
getSleepTimeMs
protected long getSleepTimeMs(int retryCount, long elapsedTimeMs)
{    return sleepMsBetweenRetries;}
4c63ebeaaff7bb355ad5a04b35052b1142def4893beee8762659de3e7ad378f5
allowRetry
public boolean allowRetry(int retryCount, long elapsedTimeMs, RetrySleeper sleeper)
{    return super.allowRetry(retryCount, elapsedTimeMs, sleeper) && (elapsedTimeMs < maxElapsedTimeMs);}
a728b4f1206e80eaa2c4bb36a7b1af90b4a46d64f62f56a45cc4ba295bfece04
getSleepTimeMs
protected long getSleepTimeMs(int retryCount, long elapsedTimeMs)
{    return sleepMsBetweenRetries;}
0540f186139eee60a0907084d9f1a814969075e2787f6596c30f2d6546736a04
getN
public int getN()
{    return n;}
4c63ebeaaff7bb355ad5a04b35052b1142def4893beee8762659de3e7ad378f5
allowRetry
public boolean allowRetry(int retryCount, long elapsedTimeMs, RetrySleeper sleeper)
{    if (retryCount < n) {        try {            sleeper.sleepFor(getSleepTimeMs(retryCount, elapsedTimeMs), TimeUnit.MILLISECONDS);        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            return false;        }        return true;    }    return false;}
5de58f59177c048d3f81181f0477ce1ef69d9762bb905ab72e907c2986f6a73f
sleepFor
public void sleepFor(long time, TimeUnit unit) throws InterruptedException
{    unit.sleep(time);}
e7e7404717bef8bd5f400adac9ce820ddaf77d64606f538410b6df207827e487
getDefaultRetrySleeper
public static RetrySleeper getDefaultRetrySleeper()
{    return sleeper;}
d699d09bcfd002fbeaf4b994883ecdce8d819d1edfd206f1d752e67c3d5238d9
callWithRetry
public static T callWithRetry(CuratorZookeeperClient client, Callable<T> proc) throws Exception
{    return client.getConnectionHandlingPolicy().callWithRetry(client, proc);}
ae3595b4ad39868e8cf9bc2b8822f1086317e52331bb840dda034e4b7881721f
shouldContinue
public boolean shouldContinue()
{    return !isDone;}
ed928623b759fa06b020cf8707b8ff6d4878881064f3e97147de501d62ffaeaf
markComplete
public void markComplete()
{    isDone = true;}
1e6e31476899727d334b2b24b9b76518b4a50d73e076bfce4bb174c664835a5d
shouldRetry
public static boolean shouldRetry(int rc)
{    return (rc == KeeperException.Code.CONNECTIONLOSS.intValue()) || (rc == KeeperException.Code.OPERATIONTIMEOUT.intValue()) || (rc == KeeperException.Code.SESSIONMOVED.intValue()) || (rc == KeeperException.Code.SESSIONEXPIRED.intValue()) ||     (rc == -13);}
98bf25a6c5332bf7877a99a41434b8fa30c8de591205def66ea2119d35b6384a
isRetryException
public static boolean isRetryException(Throwable exception)
{    if (exception instanceof KeeperException) {        KeeperException keeperException = (KeeperException) exception;        return shouldRetry(keeperException.code().intValue());    }    return false;}
dc50c7faa2789f50b0809a1d5f4b9ce9774c2505f54be519461f384184a56a1e
takeException
public void takeException(Exception exception) throws Exception
{    boolean rethrow = true;    if (isRetryException(exception)) {        if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES)) {            log.debug("Retry-able exception received", exception);        }        if (retryPolicy.allowRetry(retryCount++, System.currentTimeMillis() - startTimeMs, sleeper)) {            new EventTrace("retries-allowed", tracer.get()).commit();            if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES)) {                log.debug("Retrying operation");            }            rethrow = false;        } else {            new EventTrace("retries-disallowed", tracer.get()).commit();            if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES)) {                log.debug("Retry policy not allowing retry");            }        }    }    if (rethrow) {        throw exception;    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (event.getState() == Event.KeeperState.Expired) {        sessionHasFailed.set(true);        failedSessionThreads.add(ourThread);    }}
a5493d69bf99adbeb91fe3c8a0774168d4d60c9b8ee27da8d7050772a995e3a1
callWithRetry
public static T callWithRetry(CuratorZookeeperClient client, Mode mode, Callable<T> proc) throws Exception
{    T result = null;    SessionFailRetryLoop retryLoop = client.newSessionFailRetryLoop(mode);    retryLoop.start();    try {        while (retryLoop.shouldContinue()) {            try {                result = proc.call();            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                retryLoop.takeException(e);            }        }    } finally {        retryLoop.close();    }    return result;}
3e02b7803fe291b7bde400e4b243b851047fb6300230068629a2619fbafdaf0a
sessionForThreadHasFailed
 static boolean sessionForThreadHasFailed()
{    return failedSessionThreads.contains(Thread.currentThread());}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    Preconditions.checkState(Thread.currentThread().equals(ourThread), "Not in the correct thread");    client.addParentWatcher(watcher);}
ae3595b4ad39868e8cf9bc2b8822f1086317e52331bb840dda034e4b7881721f
shouldContinue
public boolean shouldContinue()
{    boolean localIsDone = isDone.getAndSet(true);    return !localIsDone;}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    Preconditions.checkState(Thread.currentThread().equals(ourThread), "Not in the correct thread");    failedSessionThreads.remove(ourThread);    client.removeParentWatcher(watcher);}
dc50c7faa2789f50b0809a1d5f4b9ce9774c2505f54be519461f384184a56a1e
takeException
public void takeException(Exception exception) throws Exception
{    Preconditions.checkState(Thread.currentThread().equals(ourThread), "Not in the correct thread");    boolean passUp = true;    if (sessionHasFailed.get()) {        switch(mode) {            case RETRY:                {                    sessionHasFailed.set(false);                    failedSessionThreads.remove(ourThread);                    if (exception instanceof SessionFailedException) {                        isDone.set(false);                        passUp = false;                    }                    break;                }            case FAIL:                {                    break;                }        }    }    if (passUp) {        retryLoop.takeException(exception);    }}
609962ed3c13286966d937afa9c301e49ddab59023e4f4c7704fb7ba9630b243
commit
public void commit()
{    long elapsed = System.nanoTime() - startTimeNanos;    driver.addTrace(name, elapsed, TimeUnit.NANOSECONDS);}
48530026505cdfe67d1c7fc290cc255e01f3598aca06b9847db640c1bbe0076d
cancel
public boolean cancel(boolean mayInterruptIfRunning)
{    futures.remove(scheduledFuture);    return scheduledFuture.cancel(mayInterruptIfRunning);}
1f8a60a8e7947244fd77c6226b688ce5cec6e83a6095e9c3a7f05fd821648396
isCancelled
public boolean isCancelled()
{    return scheduledFuture.isCancelled();}
7cf382bf6532528601afc0572ff7a4051fb2bd1cf2c9b7df66165750bb63dcd3
isDone
public boolean isDone()
{    return scheduledFuture.isDone();}
048ff44abe4c47667d2f8f79bf867b06d6458e8e96bca81da40a11399d197ee7
get
public Void get() throws InterruptedException, ExecutionException
{    return null;}
8d242bb8d5287d4fea424026257fc3a2c684d6913ae4f5735d748d0a28f37781
get
public Void get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException
{    return null;}
7e5b6dd7779098d8548e4d16c51362c2223450b38af385a958f8deba28c0f6ee
done
protected void done()
{    futures.remove(task);}
de15ce9b0ad9865c54a52f6c64043391e5b29feda58b57b6926cb3d5b0e7aeb8
isShutdown
public boolean isShutdown()
{    return !isOpen.get();}
1d656e5e7e60c760e39fe7ac722c9f7556cd2b6aa1869510426436d25c1b6250
size
 int size()
{    return futures.size();}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    isOpen.set(false);    Iterator<Future<?>> iterator = futures.iterator();    while (iterator.hasNext()) {        Future<?> future = iterator.next();        iterator.remove();        if (!future.isDone() && !future.isCancelled() && !future.cancel(true)) {            log.warn("Could not cancel " + future);        }    }    if (shutdownOnClose) {        executorService.shutdownNow();    }}
eb8b80b7eab22db5e903d9bcb558107e29a63d35cae0fc9f40ff2219558b2eeb
submit
public Future<V> submit(Callable<V> task)
{    Preconditions.checkState(isOpen.get(), "CloseableExecutorService is closed");    InternalFutureTask<V> futureTask = new InternalFutureTask<V>(new FutureTask<V>(task));    executorService.execute(futureTask);    return futureTask;}
c396ff386382681638e60c72135a572c6c403a789206b179996c80813af791ee
submit
public Future<?> submit(Runnable task)
{    Preconditions.checkState(isOpen.get(), "CloseableExecutorService is closed");    InternalFutureTask<Void> futureTask = new InternalFutureTask<Void>(new FutureTask<Void>(task, null));    executorService.execute(futureTask);    return futureTask;}
4540ace7ee88cb5c68459e429f8e075d13a332a0e42ff90986eed4a1d7f94941
schedule
public Future<?> schedule(Runnable task, long delay, TimeUnit unit)
{    Preconditions.checkState(isOpen.get(), "CloseableExecutorService is closed");    InternalFutureTask<Void> futureTask = new InternalFutureTask<Void>(new FutureTask<Void>(task, null));    scheduledExecutorService.schedule(futureTask, delay, unit);    return futureTask;}
eb41f6d273655c66319b9ecdd1dcef323130b280a87fb5e7dfed7d93206cf798
scheduleWithFixedDelay
public Future<?> scheduleWithFixedDelay(Runnable task, long initialDelay, long delay, TimeUnit unit)
{    Preconditions.checkState(isOpen.get(), "CloseableExecutorService is closed");    ScheduledFuture<?> scheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(task, initialDelay, delay, unit);    return new InternalScheduledFutureTask(scheduledFuture);}
c767cef8f12b33702ff58c7cf18fe4614aeec45597423b84df173216a2b53502
closeQuietly
public static void closeQuietly(Closeable closeable)
{    try {                Closeables.close(closeable, true);    } catch (IOException e) {                        log.error("IOException should not have been thrown.", e);    }}
e9c3caf379dc3b6867a9679539193c6c41da3f10e6c996d4e258fca7f548ec5c
isZK34
public static boolean isZK34()
{    return !hasZooKeeperAdmin;}
9e3a68747a71a9f98014384bf4184f1ceeb3982d68491fe2f902e187d2c5278c
injectSessionExpiration
public static void injectSessionExpiration(ZooKeeper zooKeeper)
{    if (isZK34() || (queueEventMethod == null)) {        InjectSessionExpiration.injectSessionExpiration(zooKeeper);    } else {        try {            WatchedEvent event = new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.Expired, null);            queueEventMethod.invoke(zooKeeper.getTestable(), event);        } catch (Exception e) {            logger.error("Could not call Testable.queueEvent()", e);        }    }}
2cc45f9488a3bc97f0fccb2be79c54fec8ce5b4a76dca15bdf2acb433a1d41f1
addTrace
public void addTrace(String name, long time, TimeUnit unit)
{    if (log.isTraceEnabled()) {        log.trace("Trace: " + name + " - " + TimeUnit.MILLISECONDS.convert(time, unit) + " ms");    }}
b5340961d5eb6ec0ad8d8e533073327cc7b0b964ffe6fdbe687620ed85bbc045
addCount
public void addCount(String name, int increment)
{    if (log.isTraceEnabled()) {        log.trace("Counter " + name + ": " + increment);    }}
f4d92d44b671cd2ac427f23e0663369999581e3a6fcae562b24eb91de6c19622
newZooKeeper
public ZooKeeper newZooKeeper(String connectString, int sessionTimeout, Watcher watcher, boolean canBeReadOnly) throws Exception
{    return new ZooKeeper(connectString, sessionTimeout, watcher, canBeReadOnly);}
4e4c07008c447fe6494ff4df0321995a51f3a01286d397ade1791fde0d86aaee
ensure
public void ensure(CuratorZookeeperClient client, String path, final boolean makeLastNode) throws Exception
{}
0369a5ba2e1aa4cf4b090b6e024a3f950c353f670f7e634063431bd37d9d76ab
ensure
public void ensure(CuratorZookeeperClient client) throws Exception
{    Helper localHelper = helper.get();    localHelper.ensure(client, path, makeLastNode);}
e104730008bf61268858f674794e85596d20b4acb07b764a460cf8898938b2f3
excludingLast
public EnsurePath excludingLast()
{    return new EnsurePath(path, helper, false, aclProvider);}
58e7b527ecd5014eaf5f30fc9c50ba33e1f005f8ce9d24246253d62377788662
getPath
public String getPath()
{    return this.path;}
6f13f1dbe38501548a88efdccd43e46b65741b594fc6938741e6bec259d0e2d3
asContainers
protected boolean asContainers()
{    return false;}
646bc476df51a13b38f96e90428e133c0a614b6c9185fe9393bf238ff8a91252
ensure
public synchronized void ensure(final CuratorZookeeperClient client, final String path, final boolean makeLastNode) throws Exception
{    if (!isSet) {        RetryLoop.callWithRetry(client, new Callable<Object>() {            @Override            public Object call() throws Exception {                ZKPaths.mkdirs(client.getZooKeeper(), path, makeLastNode, aclProvider, asContainers());                helper.set(doNothingHelper);                isSet = true;                return null;            }        });    }}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    ZKPaths.mkdirs(client.getZooKeeper(), path, makeLastNode, aclProvider, asContainers());    helper.set(doNothingHelper);    isSet = true;    return null;}
2787aadf393a2d6ad925d8563b1dc54419329c3fd5fd0e47cc03a5fd876f520a
propagate
public void propagate()
{    if (mainEx != null) {        Throwables.propagate(mainEx);    }}
963ab614f4b18dd32d204cb601628f3b8481cb6600c7c0ae4627688af7c27e49
add
public void add(Throwable e)
{    if (e instanceof InterruptedException) {        if (mainEx != null) {            e.addSuppressed(mainEx);        }        Thread.currentThread().interrupt();    }    if (mainEx == null) {        mainEx = e;    } else {        mainEx.addSuppressed(e);    }}
9e3a68747a71a9f98014384bf4184f1ceeb3982d68491fe2f902e187d2c5278c
injectSessionExpiration
public static void injectSessionExpiration(ZooKeeper zooKeeper)
{    try {        WatchedEvent event = new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.Expired, null);        ClientCnxn clientCnxn = (ClientCnxn) cnxnField.get(zooKeeper);        Object eventThread = eventThreadField.get(clientCnxn);        queueEventMethod.invoke(eventThread, event);        } catch (ReflectiveOperationException e) {        throw new RuntimeException("Could not inject session expiration using reflection", e);    }}
854b017516af4c3c782dfd021cfb44aaf5b991afd93eadbf46bde92aae74f3a7
validatePath
public static void validatePath(String path, boolean isSequential) throws IllegalArgumentException
{    validatePath(isSequential ? path + "1" : path);}
bca6cd0b3711617bb00c561d2f4daa0a25cf1df49ac9bb500ebf700a7e4a0bbd
validatePath
public static String validatePath(String path) throws IllegalArgumentException
{    if (path == null) {        throw new IllegalArgumentException("Path cannot be null");    }    if (path.length() == 0) {        throw new IllegalArgumentException("Path length must be > 0");    }    if (path.charAt(0) != '/') {        throw new IllegalArgumentException("Path must start with / character");    }    if (path.length() == 1) {                return path;    }    if (path.charAt(path.length() - 1) == '/') {        throw new IllegalArgumentException("Path must not end with / character");    }    String reason = null;    char lastc = '/';    char[] chars = path.toCharArray();    char c;    for (int i = 1; i < chars.length; lastc = chars[i], i++) {        c = chars[i];        if (c == 0) {            reason = "null character not allowed @" + i;            break;        } else if (c == '/' && lastc == '/') {            reason = "empty node name specified @" + i;            break;        } else if (c == '.' && lastc == '.') {            if (chars[i - 2] == '/' && ((i + 1 == chars.length) || chars[i + 1] == '/')) {                reason = "relative paths not allowed @" + i;                break;            }        } else if (c == '.') {            if (chars[i - 1] == '/' && ((i + 1 == chars.length) || chars[i + 1] == '/')) {                reason = "relative paths not allowed @" + i;                break;            }        } else if (c > '\u0000' && c < '\u001f' || c > '\u007f' && c < '\u009F' || c > '\ud800' && c < '\uf8ff' || c > '\ufff0' && c < '\uffff') {            reason = "invalid charater @" + i;            break;        }    }    if (reason != null) {        throw new IllegalArgumentException("Invalid path string \"" + path + "\" caused by " + reason);    }    return path;}
9663c4ef812a68a952b16a4addbac3c74360b1fcc04a8ec1860b55ce95bf848a
checkInterrupted
public static boolean checkInterrupted(Throwable e)
{    if (e instanceof InterruptedException) {        Thread.currentThread().interrupt();        return true;    }    return false;}
b9a7c671d26bf1fcb08dbbee4680a76495eb0203baefea9898e567e4d6b423fb
newSingleThreadExecutor
public static ExecutorService newSingleThreadExecutor(String processName)
{    return Executors.newSingleThreadExecutor(newThreadFactory(processName));}
48043a25759aaee2a918146989be45768ecacf1d3a4f9ac6d07a484e30c19f66
newFixedThreadPool
public static ExecutorService newFixedThreadPool(int qty, String processName)
{    return Executors.newFixedThreadPool(qty, newThreadFactory(processName));}
cd319b865408bbed8f4a2ebc07a54a619990b5ccf0604fe8d7036776f3ccc441
newSingleThreadScheduledExecutor
public static ScheduledExecutorService newSingleThreadScheduledExecutor(String processName)
{    return Executors.newSingleThreadScheduledExecutor(newThreadFactory(processName));}
25cbf0af3e427dd8c6a2dd6ecf88f878d539a9339256401ac17237832b32fa56
newFixedThreadScheduledPool
public static ScheduledExecutorService newFixedThreadScheduledPool(int qty, String processName)
{    return Executors.newScheduledThreadPool(qty, newThreadFactory(processName));}
4acf35cab52d0170d6f1f482bc167ac0c8488a609d98a4869273d186bb88c7f5
newThreadFactory
public static ThreadFactory newThreadFactory(String processName)
{    return newGenericThreadFactory("Curator-" + processName);}
a60a193f40e7910f6c6d154cd5515dc40b263c6e256ca3f86ab1ed45f6a17a55
newGenericThreadFactory
public static ThreadFactory newGenericThreadFactory(String processName)
{    Thread.UncaughtExceptionHandler uncaughtExceptionHandler = new Thread.UncaughtExceptionHandler() {        @Override        public void uncaughtException(Thread t, Throwable e) {            log.error("Unexpected exception in thread: " + t, e);            Throwables.propagate(e);        }    };    return new ThreadFactoryBuilder().setNameFormat(processName + "-%d").setDaemon(true).setUncaughtExceptionHandler(uncaughtExceptionHandler).build();}
f9e4832777f7af0982d696c7b64bd6626ebb43207fc112505ab6b4630a9e3d35
uncaughtException
public void uncaughtException(Thread t, Throwable e)
{    log.error("Unexpected exception in thread: " + t, e);    Throwables.propagate(e);}
fd6292535c1025cb316331c0f28c563c93d7b9d2302df8c4ffbb7671e08f112a
getProcessName
public static String getProcessName(Class<?> clazz)
{    if (clazz.isAnonymousClass()) {        return getProcessName(clazz.getEnclosingClass());    }    return clazz.getSimpleName();}
ab4a451d1a254c759ed5321721cdc01036256d9a3bd683f678a30c5a2a8b0b56
getContainerCreateMode
public static CreateMode getContainerCreateMode()
{    return CreateModeHolder.containerCreateMode;}
8117652dfff0beb1f7717f8e2067b9533b21bfa680590b399420306d0ca7c564
hasContainerSupport
public static boolean hasContainerSupport()
{    return getContainerCreateMode() != NON_CONTAINER_MODE;}
3fa729b92cf868be4499735aa43e42aa90915f90be77d94e90d3e4cc626d38b1
fixForNamespace
public static String fixForNamespace(String namespace, String path)
{    return fixForNamespace(namespace, path, false);}
5b45df40bbbe6602de5f9d4e0f2ca2960bc588369ea0438cc9808968789cb3aa
fixForNamespace
public static String fixForNamespace(String namespace, String path, boolean isSequential)
{        PathUtils.validatePath(path, isSequential);    if (namespace != null) {        return makePath(namespace, path);    }    return path;}
b9390008668408f5de9c924fc724bfefb4fd78c64fe8a15591f211fa5a2ed9b5
getNodeFromPath
public static String getNodeFromPath(String path)
{    PathUtils.validatePath(path);    int i = path.lastIndexOf(PATH_SEPARATOR_CHAR);    if (i < 0) {        return path;    }    if ((i + 1) >= path.length()) {        return "";    }    return path.substring(i + 1);}
58e7b527ecd5014eaf5f30fc9c50ba33e1f005f8ce9d24246253d62377788662
getPath
public String getPath()
{    return path;}
c45c963b20977e66de963809304a403efb204ec94388bfb51afd771aaacbe507
getNode
public String getNode()
{    return node;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    final int prime = 31;    int result = 1;    result = prime * result + node.hashCode();    result = prime * result + path.hashCode();    return result;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (obj == null) {        return false;    }    if (getClass() != obj.getClass()) {        return false;    }    PathAndNode other = (PathAndNode) obj;    if (!node.equals(other.node)) {        return false;    }    if (!path.equals(other.path)) {        return false;    }    return true;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "PathAndNode [path=" + path + ", node=" + node + "]";}
dceecfe485880a337478a38aaddd4c00c2f9a7b42c0ddff861da49c1898992cb
getPathAndNode
public static PathAndNode getPathAndNode(String path)
{    PathUtils.validatePath(path);    int i = path.lastIndexOf(PATH_SEPARATOR_CHAR);    if (i < 0) {        return new PathAndNode(path, "");    }    if ((i + 1) >= path.length()) {        return new PathAndNode(PATH_SEPARATOR, "");    }    String node = path.substring(i + 1);    String parentPath = (i > 0) ? path.substring(0, i) : PATH_SEPARATOR;    return new PathAndNode(parentPath, node);}
eceac05620a67b4e4d3c6d5b438737d4ab22e302d33b132b8e406800dd0ee7f9
extractSequentialSuffix
public static String extractSequentialSuffix(String path)
{    int length = path.length();    return length > SEQUENTIAL_SUFFIX_DIGITS ? path.substring(length - SEQUENTIAL_SUFFIX_DIGITS) : path;}
0dcb2130e12169b5259b5e4ec2b3f235466839aa036c8ecc44353ee2abcecdc5
split
public static List<String> split(String path)
{    PathUtils.validatePath(path);    return PATH_SPLITTER.splitToList(path);}
ae32a4f421d4912dacb33334df2cf8637d8dec2a25a15e4a6b927a59a9db44da
mkdirs
public static void mkdirs(ZooKeeper zookeeper, String path) throws InterruptedException, KeeperException
{    mkdirs(zookeeper, path, true, null, false);}
a551691fd2f7658839fb3e4fc40b79ac29927f6498df18e06173c70ef1012b3b
mkdirs
public static void mkdirs(ZooKeeper zookeeper, String path, boolean makeLastNode) throws InterruptedException, KeeperException
{    mkdirs(zookeeper, path, makeLastNode, null, false);}
aaaf238af5d1a1d0801c0d93f309bf745a6e3d23eec0c9167800221c0d1d0f5b
mkdirs
public static void mkdirs(ZooKeeper zookeeper, String path, boolean makeLastNode, InternalACLProvider aclProvider) throws InterruptedException, KeeperException
{    mkdirs(zookeeper, path, makeLastNode, aclProvider, false);}
a4e91259841febf4435db8253768566a5c4ac4068a105784fbf9148345890069
mkdirs
public static void mkdirs(ZooKeeper zookeeper, String path, boolean makeLastNode, InternalACLProvider aclProvider, boolean asContainers) throws InterruptedException, KeeperException
{    PathUtils.validatePath(path);        int pos = 1;    do {        pos = path.indexOf(PATH_SEPARATOR_CHAR, pos + 1);        if (pos == -1) {            if (makeLastNode) {                pos = path.length();            } else {                break;            }        }        String subPath = path.substring(0, pos);        if (zookeeper.exists(subPath, false) == null) {            try {                List<ACL> acl = null;                if (aclProvider != null) {                    acl = aclProvider.getAclForPath(subPath);                    if (acl == null) {                        acl = aclProvider.getDefaultAcl();                    }                }                if (acl == null) {                    acl = ZooDefs.Ids.OPEN_ACL_UNSAFE;                }                zookeeper.create(subPath, new byte[0], acl, getCreateMode(asContainers));            } catch (KeeperException.NodeExistsException e) {                        }        }    } while (pos < path.length());}
fd55da57c626ad9d77e42b347843677845df1df41a55f73615950e0b92861aed
deleteChildren
public static void deleteChildren(ZooKeeper zookeeper, String path, boolean deleteSelf) throws InterruptedException, KeeperException
{    PathUtils.validatePath(path);    List<String> children;    try {        children = zookeeper.getChildren(path, null);    } catch (KeeperException.NoNodeException e) {                return;    }    for (String child : children) {        String fullPath = makePath(path, child);        deleteChildren(zookeeper, fullPath, true);    }    if (deleteSelf) {        try {            zookeeper.delete(path, -1);        } catch (KeeperException.NotEmptyException e) {                        deleteChildren(zookeeper, path, true);        } catch (KeeperException.NoNodeException e) {                }    }}
d827651a8d818a6662d3e282d7bdb952c28ff612a45c09f4b758b923fbcd39ec
getSortedChildren
public static List<String> getSortedChildren(ZooKeeper zookeeper, String path) throws InterruptedException, KeeperException
{    List<String> children = zookeeper.getChildren(path, false);    List<String> sortedList = Lists.newArrayList(children);    Collections.sort(sortedList);    return sortedList;}
556c5087b5cb742b35393e05b9c1bf11813729f0bc104c89b7eeb9e8cc7e8dd1
makePath
public static String makePath(String parent, String child)
{        int maxPathLength = nullableStringLength(parent) + nullableStringLength(child) + 2;        StringBuilder path = new StringBuilder(maxPathLength);    joinPath(path, parent, child);    return path.toString();}
42456f888343e4f9e74ed6f664dee27b486990a3845b134966951a4fdd30463b
makePath
public static String makePath(String parent, String firstChild, String... restChildren)
{        int maxPathLength = nullableStringLength(parent) + nullableStringLength(firstChild) + 2;    if (restChildren != null) {        for (String child : restChildren) {                        maxPathLength += nullableStringLength(child) + 1;        }    }        StringBuilder path = new StringBuilder(maxPathLength);    joinPath(path, parent, firstChild);    if (restChildren == null) {        return path.toString();    } else {        for (String child : restChildren) {            joinPath(path, "", child);        }        return path.toString();    }}
db8761ce249b0c18217cde010400b65c452263e15a509f24c53dc651caf6b41b
nullableStringLength
private static int nullableStringLength(String s)
{    return s != null ? s.length() : 0;}
309e0a9e9480e088b001149c5f75d4443177f67913964743fd05ad1987416be7
joinPath
private static void joinPath(StringBuilder path, String parent, String child)
{        if ((parent != null) && (parent.length() > 0)) {        if (parent.charAt(0) != PATH_SEPARATOR_CHAR) {            path.append(PATH_SEPARATOR_CHAR);        }        if (parent.charAt(parent.length() - 1) == PATH_SEPARATOR_CHAR) {            path.append(parent, 0, parent.length() - 1);        } else {            path.append(parent);        }    }    if ((child == null) || (child.length() == 0) || (child.length() == 1 && child.charAt(0) == PATH_SEPARATOR_CHAR)) {                if (path.length() == 0) {            path.append(PATH_SEPARATOR_CHAR);        }        return;    }        path.append(PATH_SEPARATOR_CHAR);    int childAppendBeginIndex;    if (child.charAt(0) == PATH_SEPARATOR_CHAR) {        childAppendBeginIndex = 1;    } else {        childAppendBeginIndex = 0;    }    int childAppendEndIndex;    if (child.charAt(child.length() - 1) == PATH_SEPARATOR_CHAR) {        childAppendEndIndex = child.length() - 1;    } else {        childAppendEndIndex = child.length();    }        path.append(child, childAppendBeginIndex, childAppendEndIndex);}
207e31dc14f0c507b8c3e4ffa0f295cb30ff4e857c912e8ed64cb2068ce9445f
getCreateMode
private static CreateMode getCreateMode(boolean asContainers)
{    return asContainers ? getContainerCreateMode() : CreateMode.PERSISTENT;}
080c3bd9bd656f8129538cbd98492ff958c5dcb1c899bd0e92cfa59df1040df9
testFactory
public void testFactory() throws Exception
{    final ZooKeeper mockZookeeper = Mockito.mock(ZooKeeper.class);    ZookeeperFactory zookeeperFactory = new ZookeeperFactory() {        @Override        public ZooKeeper newZooKeeper(String connectString, int sessionTimeout, Watcher watcher, boolean canBeReadOnly) throws Exception {            return mockZookeeper;        }    };    CuratorZookeeperClient client = new CuratorZookeeperClient(zookeeperFactory, new FixedEnsembleProvider(server.getConnectString()), 10000, 10000, null, new RetryOneTime(1), false);    client.start();    Assert.assertEquals(client.getZooKeeper(), mockZookeeper);}
f4d92d44b671cd2ac427f23e0663369999581e3a6fcae562b24eb91de6c19622
newZooKeeper
public ZooKeeper newZooKeeper(String connectString, int sessionTimeout, Watcher watcher, boolean canBeReadOnly) throws Exception
{    return mockZookeeper;}
01970a97dff84dd86a2c53c29ce12e363d256bdfdb6f230111791b6341cadf3f
testExpiredSession
public void testExpiredSession() throws Exception
{        final Timing timing = new Timing();    final CountDownLatch latch = new CountDownLatch(1);    Watcher watcher = new Watcher() {        @Override        public void process(WatchedEvent event) {            if (event.getState() == Event.KeeperState.Expired) {                latch.countDown();            }        }    };    final CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), timing.session(), timing.connection(), watcher, new RetryOneTime(2));    client.start();    try {        final AtomicBoolean firstTime = new AtomicBoolean(true);        RetryLoop.callWithRetry(client, new Callable<Object>() {            @Override            public Object call() throws Exception {                if (firstTime.compareAndSet(true, false)) {                    try {                        client.getZooKeeper().create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                    } catch (KeeperException.NodeExistsException ignore) {                                        }                    Compatibility.injectSessionExpiration(client.getZooKeeper());                    Assert.assertTrue(timing.awaitLatch(latch));                }                ZooKeeper zooKeeper = client.getZooKeeper();                client.blockUntilConnectedOrTimedOut();                Assert.assertNotNull(zooKeeper.exists("/foo", false));                return null;            }        });    } finally {        client.close();    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (event.getState() == Event.KeeperState.Expired) {        latch.countDown();    }}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    if (firstTime.compareAndSet(true, false)) {        try {            client.getZooKeeper().create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        } catch (KeeperException.NodeExistsException ignore) {                }        Compatibility.injectSessionExpiration(client.getZooKeeper());        Assert.assertTrue(timing.awaitLatch(latch));    }    ZooKeeper zooKeeper = client.getZooKeeper();    client.blockUntilConnectedOrTimedOut();    Assert.assertNotNull(zooKeeper.exists("/foo", false));    return null;}
0cc4a12f42cd28b58d39fb6ee61a249d812639e40874f9b77ca97f66610d573f
testReconnect
public void testReconnect() throws Exception
{    CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), 10000, 10000, null, new RetryOneTime(1));    client.start();    try {        client.blockUntilConnectedOrTimedOut();        byte[] writtenData = { 1, 2, 3 };        client.getZooKeeper().create("/test", writtenData, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        Thread.sleep(1000);        server.stop();        Thread.sleep(1000);        server.restart();        Assert.assertTrue(client.blockUntilConnectedOrTimedOut());        byte[] readData = client.getZooKeeper().getData("/test", false, null);        Assert.assertEquals(readData, writtenData);    } finally {        client.close();    }}
7e6ef9a15f502c76aa39b9e99c40c2704757556d14668cef0634754950c971d9
testSimple
public void testSimple() throws Exception
{    CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), 10000, 10000, null, new RetryOneTime(1));    client.start();    try {        client.blockUntilConnectedOrTimedOut();        String path = client.getZooKeeper().create("/test", new byte[] { 1, 2, 3 }, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        Assert.assertEquals(path, "/test");    } finally {        client.close();    }}
1794219d8e69cfcd575a987d35609e2e5f2f0f99d0f1e3f9f036ec64d9d5f502
testBackgroundConnect
public void testBackgroundConnect() throws Exception
{    final int CONNECTION_TIMEOUT_MS = 4000;    CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), 10000, CONNECTION_TIMEOUT_MS, null, new RetryOneTime(1));    try {        Assert.assertFalse(client.isConnected());        client.start();        outer: do {            for (int i = 0; i < (CONNECTION_TIMEOUT_MS / 1000); ++i) {                if (client.isConnected()) {                    break outer;                }                Thread.sleep(CONNECTION_TIMEOUT_MS);            }            Assert.fail();        } while (false);    } finally {        client.close();    }}
9cb4ad22560740b8cbed6b541176305827ec20a5eff5bd35819a431668b9b0cc
getBackupConnectionString
public String getBackupConnectionString() throws Exception
{    return null;}
f37517c88643eeb12a0e20a8cdd6cd2140fa5ea1aa1801db281d626bad9b0048
testExhibitorFailures
public void testExhibitorFailures() throws Exception
{    final AtomicReference<String> backupConnectionString = new AtomicReference<String>("backup1:1");    final AtomicReference<String> connectionString = new AtomicReference<String>("count=1&port=2&server0=localhost");    Exhibitors exhibitors = new Exhibitors(Lists.newArrayList("foo", "bar"), 1000, new Exhibitors.BackupConnectionStringProvider() {        @Override        public String getBackupConnectionString() {            return backupConnectionString.get();        }    });    ExhibitorRestClient mockRestClient = new ExhibitorRestClient() {        @Override        public String getRaw(String hostname, int port, String uriPath, String mimeType) throws Exception {            String localConnectionString = connectionString.get();            if (localConnectionString == null) {                throw new IOException();            }            return localConnectionString;        }    };    final Semaphore semaphore = new Semaphore(0);    ExhibitorEnsembleProvider provider = new ExhibitorEnsembleProvider(exhibitors, mockRestClient, "/foo", 10, new RetryOneTime(1)) {        @Override        protected void poll() {            super.poll();            semaphore.release();        }    };    provider.pollForInitialEnsemble();    try {        provider.start();        Assert.assertEquals(provider.getConnectionString(), "localhost:2");        connectionString.set(null);        semaphore.drainPermits();                semaphore.acquire();        Assert.assertEquals(provider.getConnectionString(), "backup1:1");        backupConnectionString.set("backup2:2");        semaphore.drainPermits();                semaphore.acquire();        Assert.assertEquals(provider.getConnectionString(), "backup2:2");        connectionString.set("count=1&port=3&server0=localhost3");        semaphore.drainPermits();                semaphore.acquire();        Assert.assertEquals(provider.getConnectionString(), "localhost3:3");    } finally {        CloseableUtils.closeQuietly(provider);    }}
5833dd91494630948da3a2264cf5152b9c58d13443c41c9f59de0cf24018fd22
getBackupConnectionString
public String getBackupConnectionString()
{    return backupConnectionString.get();}
531e6c422cd886c7f675cf80406c0cc18de7e35399deb20edbedc4453d22fdb3
getRaw
public String getRaw(String hostname, int port, String uriPath, String mimeType) throws Exception
{    String localConnectionString = connectionString.get();    if (localConnectionString == null) {        throw new IOException();    }    return localConnectionString;}
6446e7a87ec1c28617111793ad5ceec1c7e3b024eaccd5576c7a11b692ab5bf2
poll
protected void poll()
{    super.poll();    semaphore.release();}
2ed86675393eac7c960f97b17b353b170d72cc2296c73b95c72c5ccb6ce3f6c1
testChanging
public void testChanging() throws Exception
{    TestingServer secondServer = new TestingServer();    try {        String mainConnectionString = "count=1&port=" + server.getPort() + "&server0=localhost";        String secondConnectionString = "count=1&port=" + secondServer.getPort() + "&server0=localhost";        final Semaphore semaphore = new Semaphore(0);        final AtomicReference<String> connectionString = new AtomicReference<String>(mainConnectionString);        Exhibitors exhibitors = new Exhibitors(Lists.newArrayList("foo", "bar"), 1000, dummyConnectionStringProvider);        ExhibitorRestClient mockRestClient = new ExhibitorRestClient() {            @Override            public String getRaw(String hostname, int port, String uriPath, String mimeType) throws Exception {                semaphore.release();                return connectionString.get();            }        };        ExhibitorEnsembleProvider provider = new ExhibitorEnsembleProvider(exhibitors, mockRestClient, "/foo", 10, new RetryOneTime(1));        provider.pollForInitialEnsemble();        Timing timing = new Timing().multiple(4);        final CuratorZookeeperClient client = new CuratorZookeeperClient(provider, timing.session(), timing.connection(), null, new RetryOneTime(2));        client.start();        try {            RetryLoop.callWithRetry(client, new Callable<Object>() {                @Override                public Object call() throws Exception {                    client.getZooKeeper().create("/test", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                    return null;                }            });            connectionString.set(secondConnectionString);            semaphore.drainPermits();            semaphore.acquire();                        server.stop();            Stat stat = RetryLoop.callWithRetry(client, new Callable<Stat>() {                @Override                public Stat call() throws Exception {                    return client.getZooKeeper().exists("/test", false);                }            });                        Assert.assertNull(stat);        } finally {            client.close();        }    } finally {        CloseableUtils.closeQuietly(secondServer);    }}
531e6c422cd886c7f675cf80406c0cc18de7e35399deb20edbedc4453d22fdb3
getRaw
public String getRaw(String hostname, int port, String uriPath, String mimeType) throws Exception
{    semaphore.release();    return connectionString.get();}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    client.getZooKeeper().create("/test", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    return null;}
b8e6c61d1ad0861ffb63b6e255cc9573670963d8e3c59317c9f9cc0da4742a26
call
public Stat call() throws Exception
{    return client.getZooKeeper().exists("/test", false);}
7e6ef9a15f502c76aa39b9e99c40c2704757556d14668cef0634754950c971d9
testSimple
public void testSimple() throws Exception
{    Exhibitors exhibitors = new Exhibitors(Lists.newArrayList("foo", "bar"), 1000, dummyConnectionStringProvider);    ExhibitorRestClient mockRestClient = new ExhibitorRestClient() {        @Override        public String getRaw(String hostname, int port, String uriPath, String mimeType) throws Exception {            return "count=1&port=" + server.getPort() + "&server0=localhost";        }    };    ExhibitorEnsembleProvider provider = new ExhibitorEnsembleProvider(exhibitors, mockRestClient, "/foo", 10, new RetryOneTime(1));    provider.pollForInitialEnsemble();    Timing timing = new Timing();    CuratorZookeeperClient client = new CuratorZookeeperClient(provider, timing.session(), timing.connection(), null, new ExponentialBackoffRetry(timing.milliseconds(), 3));    client.start();    try {        client.blockUntilConnectedOrTimedOut();        client.getZooKeeper().exists("/", false);    } catch (Exception e) {        Assert.fail("provider.getConnectionString(): " + provider.getConnectionString() + " server.getPort(): " + server.getPort(), e);    } finally {        client.close();    }}
531e6c422cd886c7f675cf80406c0cc18de7e35399deb20edbedc4453d22fdb3
getRaw
public String getRaw(String hostname, int port, String uriPath, String mimeType) throws Exception
{    return "count=1&port=" + server.getPort() + "&server0=localhost";}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    ZooKeeper client = mock(ZooKeeper.class, Mockito.RETURNS_MOCKS);    CuratorZookeeperClient curator = mock(CuratorZookeeperClient.class);    RetryPolicy retryPolicy = new RetryOneTime(1);    RetryLoop retryLoop = new RetryLoop(retryPolicy, null);    when(curator.getConnectionHandlingPolicy()).thenReturn(new StandardConnectionHandlingPolicy());    when(curator.getZooKeeper()).thenReturn(client);    when(curator.getRetryPolicy()).thenReturn(retryPolicy);    when(curator.newRetryLoop()).thenReturn(retryLoop);    Stat fakeStat = mock(Stat.class);    when(client.exists(Mockito.<String>any(), anyBoolean())).thenReturn(fakeStat);    EnsurePath ensurePath = new EnsurePath("/one/two/three");    ensurePath.ensure(curator);    verify(client, times(3)).exists(Mockito.<String>any(), anyBoolean());    ensurePath.ensure(curator);    verifyNoMoreInteractions(client);    ensurePath.ensure(curator);    verifyNoMoreInteractions(client);}
9a457089d3c0aa7e392d47714920a87bc7bbdbafca19e6cb15457a777de93ed0
testSimultaneous
public void testSimultaneous() throws Exception
{    ZooKeeper client = mock(ZooKeeper.class, Mockito.RETURNS_MOCKS);    RetryPolicy retryPolicy = new RetryOneTime(1);    RetryLoop retryLoop = new RetryLoop(retryPolicy, null);    final CuratorZookeeperClient curator = mock(CuratorZookeeperClient.class);    when(curator.getConnectionHandlingPolicy()).thenReturn(new StandardConnectionHandlingPolicy());    when(curator.getZooKeeper()).thenReturn(client);    when(curator.getRetryPolicy()).thenReturn(retryPolicy);    when(curator.newRetryLoop()).thenReturn(retryLoop);    final Stat fakeStat = mock(Stat.class);    final CountDownLatch startedLatch = new CountDownLatch(2);    final CountDownLatch finishedLatch = new CountDownLatch(2);    final Semaphore semaphore = new Semaphore(0);    when(client.exists(Mockito.<String>any(), anyBoolean())).thenAnswer(new Answer<Stat>() {        @Override        public Stat answer(InvocationOnMock invocation) throws Throwable {            semaphore.acquire();            return fakeStat;        }    });    final EnsurePath ensurePath = new EnsurePath("/one/two/three");    ExecutorService service = Executors.newCachedThreadPool();    for (int i = 0; i < 2; ++i) {        service.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                startedLatch.countDown();                ensurePath.ensure(curator);                finishedLatch.countDown();                return null;            }        });    }    Assert.assertTrue(startedLatch.await(10, TimeUnit.SECONDS));    semaphore.release(3);    Assert.assertTrue(finishedLatch.await(10, TimeUnit.SECONDS));    verify(client, times(3)).exists(Mockito.<String>any(), anyBoolean());    ensurePath.ensure(curator);    verifyNoMoreInteractions(client);    ensurePath.ensure(curator);    verifyNoMoreInteractions(client);}
8b58fc82aaeb96dd57dee28ffbea7907fc44891a8c4731f6d3cdc05ec41245e4
answer
public Stat answer(InvocationOnMock invocation) throws Throwable
{    semaphore.acquire();    return fakeStat;}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    startedLatch.countDown();    ensurePath.ensure(curator);    finishedLatch.countDown();    return null;}
3dba7a9bd49379949001ddf29af27f8480a65684360d19101d76737711f9a50e
testExponentialBackoffRetryLimit
public void testExponentialBackoffRetryLimit()
{    RetrySleeper sleeper = new RetrySleeper() {        @Override        public void sleepFor(long time, TimeUnit unit) throws InterruptedException {            Assert.assertTrue(unit.toMillis(time) <= 100);        }    };    ExponentialBackoffRetry retry = new ExponentialBackoffRetry(1, Integer.MAX_VALUE, 100);    for (int i = 0; i >= 0; ++i) {        retry.allowRetry(i, 0, sleeper);    }}
5de58f59177c048d3f81181f0477ce1ef69d9762bb905ab72e907c2986f6a73f
sleepFor
public void sleepFor(long time, TimeUnit unit) throws InterruptedException
{    Assert.assertTrue(unit.toMillis(time) <= 100);}
b70f4dac3305b6d11f7c7600330ec5e8bd8b43db26293fcc36bd6034cedffa08
testRetryLoopWithFailure
public void testRetryLoopWithFailure() throws Exception
{    CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), 5000, 5000, null, new RetryOneTime(1));    client.start();    try {        int loopCount = 0;        RetryLoop retryLoop = client.newRetryLoop();        outer: while (retryLoop.shouldContinue()) {            ++loopCount;            switch(loopCount) {                case 1:                    {                        server.stop();                        break;                    }                case 2:                    {                        server.restart();                        break;                    }                case 3:                case 4:                    {                                                break;                    }                default:                    {                        Assert.fail();                        break outer;                    }            }            try {                client.blockUntilConnectedOrTimedOut();                client.getZooKeeper().create("/test", new byte[] { 1, 2, 3 }, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                retryLoop.markComplete();            } catch (Exception e) {                retryLoop.takeException(e);            }        }        Assert.assertTrue(loopCount >= 2);    } finally {        client.close();    }}
f4eb0333bc8d06b63728c037200d7560c39d592a703fdd1fbd8fd9771e4f559f
testRetryLoop
public void testRetryLoop() throws Exception
{    CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), 10000, 10000, null, new RetryOneTime(1));    client.start();    try {        int loopCount = 0;        RetryLoop retryLoop = client.newRetryLoop();        while (retryLoop.shouldContinue()) {            if (++loopCount > 2) {                Assert.fail();                break;            }            try {                client.getZooKeeper().create("/test", new byte[] { 1, 2, 3 }, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                retryLoop.markComplete();            } catch (Exception e) {                retryLoop.takeException(e);            }        }        Assert.assertTrue(loopCount > 0);    } finally {        client.close();    }}
a1fc49dd5c1f50d615f0cb11fd5d74740a01981c83a25d4ef476c11ccf7a0e19
testRetryForever
public void testRetryForever() throws Exception
{    int retryIntervalMs = 1;    RetrySleeper sleeper = Mockito.mock(RetrySleeper.class);    RetryForever retryForever = new RetryForever(retryIntervalMs);    for (int i = 0; i < 10; i++) {        boolean allowed = retryForever.allowRetry(i, 0, sleeper);        Assert.assertTrue(allowed);        Mockito.verify(sleeper, times(i + 1)).sleepFor(retryIntervalMs, TimeUnit.MILLISECONDS);    }}
6c9a0476a31b040692d695f58e540d0b4fe2c4da4d062b79b51ef589ad3ab77c
testRetry
public void testRetry() throws Exception
{    Timing timing = new Timing();    final CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), timing.session(), timing.connection(), null, new ExponentialBackoffRetry(100, 3));    SessionFailRetryLoop retryLoop = client.newSessionFailRetryLoop(SessionFailRetryLoop.Mode.RETRY);    retryLoop.start();    try {        client.start();        final AtomicBoolean secondWasDone = new AtomicBoolean(false);        final AtomicBoolean firstTime = new AtomicBoolean(true);        while (retryLoop.shouldContinue()) {            try {                RetryLoop.callWithRetry(client, new Callable<Void>() {                    @Override                    public Void call() throws Exception {                        if (firstTime.compareAndSet(true, false)) {                            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                            Compatibility.injectSessionExpiration(client.getZooKeeper());                            client.getZooKeeper();                            client.blockUntilConnectedOrTimedOut();                        }                        Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                        return null;                    }                });                RetryLoop.callWithRetry(client, new Callable<Void>() {                    @Override                    public Void call() throws Exception {                        Assert.assertFalse(firstTime.get());                        Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                        secondWasDone.set(true);                        return null;                    }                });            } catch (Exception e) {                retryLoop.takeException(e);            }        }        Assert.assertTrue(secondWasDone.get());    } finally {        retryLoop.close();        CloseableUtils.closeQuietly(client);    }}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    if (firstTime.compareAndSet(true, false)) {        Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));        Compatibility.injectSessionExpiration(client.getZooKeeper());        client.getZooKeeper();        client.blockUntilConnectedOrTimedOut();    }    Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));    return null;}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    Assert.assertFalse(firstTime.get());    Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));    secondWasDone.set(true);    return null;}
3f3915fc5c09d90bff732ca79c0b735e9b88edcabb927e5e950e6f152253b007
testRetryStatic
public void testRetryStatic() throws Exception
{    Timing timing = new Timing();    final CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), timing.session(), timing.connection(), null, new ExponentialBackoffRetry(100, 3));    SessionFailRetryLoop retryLoop = client.newSessionFailRetryLoop(SessionFailRetryLoop.Mode.RETRY);    retryLoop.start();    try {        client.start();        final AtomicBoolean secondWasDone = new AtomicBoolean(false);        final AtomicBoolean firstTime = new AtomicBoolean(true);        SessionFailRetryLoop.callWithRetry(client, SessionFailRetryLoop.Mode.RETRY, new Callable<Object>() {            @Override            public Object call() throws Exception {                RetryLoop.callWithRetry(client, new Callable<Void>() {                    @Override                    public Void call() throws Exception {                        if (firstTime.compareAndSet(true, false)) {                            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                            Compatibility.injectSessionExpiration(client.getZooKeeper());                            client.getZooKeeper();                            client.blockUntilConnectedOrTimedOut();                        }                        Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                        return null;                    }                });                RetryLoop.callWithRetry(client, new Callable<Void>() {                    @Override                    public Void call() throws Exception {                        Assert.assertFalse(firstTime.get());                        Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                        secondWasDone.set(true);                        return null;                    }                });                return null;            }        });        Assert.assertTrue(secondWasDone.get());    } finally {        retryLoop.close();        CloseableUtils.closeQuietly(client);    }}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    RetryLoop.callWithRetry(client, new Callable<Void>() {        @Override        public Void call() throws Exception {            if (firstTime.compareAndSet(true, false)) {                Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                Compatibility.injectSessionExpiration(client.getZooKeeper());                client.getZooKeeper();                client.blockUntilConnectedOrTimedOut();            }            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));            return null;        }    });    RetryLoop.callWithRetry(client, new Callable<Void>() {        @Override        public Void call() throws Exception {            Assert.assertFalse(firstTime.get());            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));            secondWasDone.set(true);            return null;        }    });    return null;}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    if (firstTime.compareAndSet(true, false)) {        Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));        Compatibility.injectSessionExpiration(client.getZooKeeper());        client.getZooKeeper();        client.blockUntilConnectedOrTimedOut();    }    Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));    return null;}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    Assert.assertFalse(firstTime.get());    Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));    secondWasDone.set(true);    return null;}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    final Timing timing = new Timing();    final CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), timing.session(), timing.connection(), null, new ExponentialBackoffRetry(100, 3));    SessionFailRetryLoop retryLoop = client.newSessionFailRetryLoop(SessionFailRetryLoop.Mode.FAIL);    retryLoop.start();    try {        client.start();        try {            while (retryLoop.shouldContinue()) {                try {                    RetryLoop.callWithRetry(client, new Callable<Void>() {                        @Override                        public Void call() throws Exception {                            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                            Compatibility.injectSessionExpiration(client.getZooKeeper());                            timing.sleepABit();                            client.getZooKeeper();                            client.blockUntilConnectedOrTimedOut();                            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                            return null;                        }                    });                } catch (Exception e) {                    retryLoop.takeException(e);                }            }            Assert.fail();        } catch (SessionFailRetryLoop.SessionFailedException dummy) {                }    } finally {        retryLoop.close();        CloseableUtils.closeQuietly(client);    }}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));    Compatibility.injectSessionExpiration(client.getZooKeeper());    timing.sleepABit();    client.getZooKeeper();    client.blockUntilConnectedOrTimedOut();    Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));    return null;}
15750b2fc910612443ae67e7cabfbbbc247cca857650570e473b78783a091f5a
testBasicStatic
public void testBasicStatic() throws Exception
{    Timing timing = new Timing();    final CuratorZookeeperClient client = new CuratorZookeeperClient(server.getConnectString(), timing.session(), timing.connection(), null, new ExponentialBackoffRetry(100, 3));    SessionFailRetryLoop retryLoop = client.newSessionFailRetryLoop(SessionFailRetryLoop.Mode.FAIL);    retryLoop.start();    try {        client.start();        try {            SessionFailRetryLoop.callWithRetry(client, SessionFailRetryLoop.Mode.FAIL, new Callable<Object>() {                @Override                public Object call() throws Exception {                    RetryLoop.callWithRetry(client, new Callable<Void>() {                        @Override                        public Void call() throws Exception {                            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                            Compatibility.injectSessionExpiration(client.getZooKeeper());                            client.getZooKeeper();                            client.blockUntilConnectedOrTimedOut();                            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));                            return null;                        }                    });                    return null;                }            });        } catch (SessionFailRetryLoop.SessionFailedException dummy) {                }    } finally {        retryLoop.close();        CloseableUtils.closeQuietly(client);    }}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    RetryLoop.callWithRetry(client, new Callable<Void>() {        @Override        public Void call() throws Exception {            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));            Compatibility.injectSessionExpiration(client.getZooKeeper());            client.getZooKeeper();            client.blockUntilConnectedOrTimedOut();            Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));            return null;        }    });    return null;}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));    Compatibility.injectSessionExpiration(client.getZooKeeper());    client.getZooKeeper();    client.blockUntilConnectedOrTimedOut();    Assert.assertNull(client.getZooKeeper().exists("/foo/bar", false));    return null;}
5ff0b8f7d2b080bcc6214fa5f91be74727145ea81cacb63a99c8d0f3106c089f
setup
public void setup()
{    executorService = Executors.newFixedThreadPool(QTY * 2);}
39e5ba029cc67f6f1d45c6d20f0df595ec16bc61da20d7680fcbbdae4fe7f95b
tearDown
public void tearDown()
{    executorService.shutdownNow();}
894aca6202293748101f2cc7843026d09eacb8e0ee226c94e121cc71938b639c
testBasicRunnable
public void testBasicRunnable() throws InterruptedException
{    try {        CloseableExecutorService service = new CloseableExecutorService(executorService);        CountDownLatch startLatch = new CountDownLatch(QTY);        CountDownLatch latch = new CountDownLatch(QTY);        for (int i = 0; i < QTY; ++i) {            submitRunnable(service, startLatch, latch);        }        Assert.assertTrue(startLatch.await(3, TimeUnit.SECONDS));        service.close();        Assert.assertTrue(latch.await(3, TimeUnit.SECONDS));    } catch (AssertionError e) {        throw e;    } catch (Throwable e) {        e.printStackTrace();    }}
12b052f7eed40cd78efb223b5134bb466eff0b487c243216ee44a82c4c4bcae8
testBasicCallable
public void testBasicCallable() throws InterruptedException
{    CloseableExecutorService service = new CloseableExecutorService(executorService);    final CountDownLatch startLatch = new CountDownLatch(QTY);    final CountDownLatch latch = new CountDownLatch(QTY);    for (int i = 0; i < QTY; ++i) {        service.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                try {                    startLatch.countDown();                    Thread.currentThread().join();                } catch (InterruptedException e) {                    Thread.currentThread().interrupt();                } finally {                    latch.countDown();                }                return null;            }        });    }    Assert.assertTrue(startLatch.await(3, TimeUnit.SECONDS));    service.close();    Assert.assertTrue(latch.await(3, TimeUnit.SECONDS));}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    try {        startLatch.countDown();        Thread.currentThread().join();    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    } finally {        latch.countDown();    }    return null;}
f9592da270ffc21ceda5f65790fd489a65276237c8b7358abdcf29a02e382daf
testListeningRunnable
public void testListeningRunnable() throws InterruptedException
{    CloseableExecutorService service = new CloseableExecutorService(executorService);    List<Future<?>> futures = Lists.newArrayList();    final CountDownLatch startLatch = new CountDownLatch(QTY);    for (int i = 0; i < QTY; ++i) {        Future<?> future = service.submit(new Runnable() {            @Override            public void run() {                try {                    startLatch.countDown();                    Thread.currentThread().join();                } catch (InterruptedException e) {                    Thread.currentThread().interrupt();                }            }        });        futures.add(future);    }    Assert.assertTrue(startLatch.await(3, TimeUnit.SECONDS));    for (Future<?> future : futures) {        future.cancel(true);    }    Assert.assertEquals(service.size(), 0);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        startLatch.countDown();        Thread.currentThread().join();    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }}
dad0fabe629ff1fc8e8601ad2df5da2f48bd40cc4a9a1ae76c7354a9e48e020e
testListeningCallable
public void testListeningCallable() throws InterruptedException
{    CloseableExecutorService service = new CloseableExecutorService(executorService);    final CountDownLatch startLatch = new CountDownLatch(QTY);    List<Future<?>> futures = Lists.newArrayList();    for (int i = 0; i < QTY; ++i) {        Future<?> future = service.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                try {                    startLatch.countDown();                    Thread.currentThread().join();                } catch (InterruptedException e) {                    Thread.currentThread().interrupt();                }                return null;            }        });        futures.add(future);    }    Assert.assertTrue(startLatch.await(3, TimeUnit.SECONDS));    for (Future<?> future : futures) {        future.cancel(true);    }    Assert.assertEquals(service.size(), 0);}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    try {        startLatch.countDown();        Thread.currentThread().join();    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }    return null;}
fd2a31c0946ef930ef55a9100a2950f594639713702bb106580db0114a1627ac
testPartialRunnable
public void testPartialRunnable() throws InterruptedException
{    final CountDownLatch outsideLatch = new CountDownLatch(1);    executorService.submit(new Runnable() {        @Override        public void run() {            try {                Thread.currentThread().join();            } catch (InterruptedException e) {                Thread.currentThread().interrupt();            } finally {                outsideLatch.countDown();            }        }    });    CloseableExecutorService service = new CloseableExecutorService(executorService);    CountDownLatch startLatch = new CountDownLatch(QTY);    CountDownLatch latch = new CountDownLatch(QTY);    for (int i = 0; i < QTY; ++i) {        submitRunnable(service, startLatch, latch);    }    while (service.size() < QTY) {        Thread.sleep(100);    }    Assert.assertTrue(startLatch.await(3, TimeUnit.SECONDS));    service.close();    Assert.assertTrue(latch.await(3, TimeUnit.SECONDS));    Assert.assertEquals(outsideLatch.getCount(), 1);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        Thread.currentThread().join();    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    } finally {        outsideLatch.countDown();    }}
404ccb20dc1a2dbeadbb7ab13c1cf6bcb786fed40dcfb0acf1459d8bb32c5e74
submitRunnable
private void submitRunnable(CloseableExecutorService service, final CountDownLatch startLatch, final CountDownLatch latch)
{    service.submit(new Runnable() {        @Override        public void run() {            try {                startLatch.countDown();                Thread.sleep(100000);            } catch (InterruptedException e) {                Thread.currentThread().interrupt();            } finally {                latch.countDown();            }        }    });}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        startLatch.countDown();        Thread.sleep(100000);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    } finally {        latch.countDown();    }}
5ff0b8f7d2b080bcc6214fa5f91be74727145ea81cacb63a99c8d0f3106c089f
setup
public void setup()
{    executorService = Executors.newScheduledThreadPool(QTY * 2);}
39e5ba029cc67f6f1d45c6d20f0df595ec16bc61da20d7680fcbbdae4fe7f95b
tearDown
public void tearDown()
{    executorService.shutdownNow();}
2ca0b4e55fe88b0abc3bf1fd34e3ec4ccca4addc96ca353aeaed24ce14863413
testCloseableScheduleWithFixedDelay
public void testCloseableScheduleWithFixedDelay() throws InterruptedException
{    CloseableScheduledExecutorService service = new CloseableScheduledExecutorService(executorService);    final CountDownLatch latch = new CountDownLatch(QTY);    service.scheduleWithFixedDelay(new Runnable() {        @Override        public void run() {            latch.countDown();        }    }, DELAY_MS, DELAY_MS, TimeUnit.MILLISECONDS);    Assert.assertTrue(latch.await((QTY * 2) * DELAY_MS, TimeUnit.MILLISECONDS));}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    latch.countDown();}
1cf4fa74d344edc0488428c82ff697e0005fc6f977ef9c2e79deed464ccae8bf
testCloseableScheduleWithFixedDelayAndAdditionalTasks
public void testCloseableScheduleWithFixedDelayAndAdditionalTasks() throws InterruptedException
{    final AtomicInteger outerCounter = new AtomicInteger(0);    Runnable command = new Runnable() {        @Override        public void run() {            outerCounter.incrementAndGet();        }    };    executorService.scheduleWithFixedDelay(command, DELAY_MS, DELAY_MS, TimeUnit.MILLISECONDS);    CloseableScheduledExecutorService service = new CloseableScheduledExecutorService(executorService);    final AtomicInteger innerCounter = new AtomicInteger(0);    service.scheduleWithFixedDelay(new Runnable() {        @Override        public void run() {            innerCounter.incrementAndGet();        }    }, DELAY_MS, DELAY_MS, TimeUnit.MILLISECONDS);    Thread.sleep(DELAY_MS * 4);    service.close();    Thread.sleep(DELAY_MS * 2);    int innerValue = innerCounter.get();    Assert.assertTrue(innerValue > 0);    int value = outerCounter.get();    Thread.sleep(DELAY_MS * 2);    int newValue = outerCounter.get();    Assert.assertTrue(newValue > value);    Assert.assertEquals(innerValue, innerCounter.get());    value = newValue;    Thread.sleep(DELAY_MS * 2);    newValue = outerCounter.get();    Assert.assertTrue(newValue > value);    Assert.assertEquals(innerValue, innerCounter.get());}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    outerCounter.incrementAndGet();}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    innerCounter.incrementAndGet();}
24ee6ee4240c0ab0ed6b50c55c9e3efafbb85ea88c1563396200b6d179d691d4
testMakePath
public void testMakePath()
{    Assert.assertEquals(ZKPaths.makePath(null, "/"), "/");    Assert.assertEquals(ZKPaths.makePath("", null), "/");    Assert.assertEquals(ZKPaths.makePath("/", null), "/");    Assert.assertEquals(ZKPaths.makePath(null, null), "/");    Assert.assertEquals(ZKPaths.makePath("/", "/"), "/");    Assert.assertEquals(ZKPaths.makePath("", "/"), "/");    Assert.assertEquals(ZKPaths.makePath("/", ""), "/");    Assert.assertEquals(ZKPaths.makePath("", ""), "/");    Assert.assertEquals(ZKPaths.makePath("foo", ""), "/foo");    Assert.assertEquals(ZKPaths.makePath("foo", "/"), "/foo");    Assert.assertEquals(ZKPaths.makePath("/foo", ""), "/foo");    Assert.assertEquals(ZKPaths.makePath("/foo", "/"), "/foo");    Assert.assertEquals(ZKPaths.makePath("foo", null), "/foo");    Assert.assertEquals(ZKPaths.makePath("foo", null), "/foo");    Assert.assertEquals(ZKPaths.makePath("/foo", null), "/foo");    Assert.assertEquals(ZKPaths.makePath("/foo", null), "/foo");    Assert.assertEquals(ZKPaths.makePath("", "bar"), "/bar");    Assert.assertEquals(ZKPaths.makePath("/", "bar"), "/bar");    Assert.assertEquals(ZKPaths.makePath("", "/bar"), "/bar");    Assert.assertEquals(ZKPaths.makePath("/", "/bar"), "/bar");    Assert.assertEquals(ZKPaths.makePath(null, "bar"), "/bar");    Assert.assertEquals(ZKPaths.makePath(null, "bar"), "/bar");    Assert.assertEquals(ZKPaths.makePath(null, "/bar"), "/bar");    Assert.assertEquals(ZKPaths.makePath(null, "/bar"), "/bar");    Assert.assertEquals(ZKPaths.makePath("foo", "bar"), "/foo/bar");    Assert.assertEquals(ZKPaths.makePath("/foo", "bar"), "/foo/bar");    Assert.assertEquals(ZKPaths.makePath("foo", "/bar"), "/foo/bar");    Assert.assertEquals(ZKPaths.makePath("/foo", "/bar"), "/foo/bar");    Assert.assertEquals(ZKPaths.makePath("/foo", "bar/"), "/foo/bar");    Assert.assertEquals(ZKPaths.makePath("/foo/", "/bar/"), "/foo/bar");    Assert.assertEquals(ZKPaths.makePath("foo", "bar", "baz"), "/foo/bar/baz");    Assert.assertEquals(ZKPaths.makePath("foo", "bar", "baz", "qux"), "/foo/bar/baz/qux");    Assert.assertEquals(ZKPaths.makePath("/foo", "/bar", "/baz"), "/foo/bar/baz");    Assert.assertEquals(ZKPaths.makePath("/foo/", "/bar/", "/baz/"), "/foo/bar/baz");    Assert.assertEquals(ZKPaths.makePath("foo", null, null), "/foo");    Assert.assertEquals(ZKPaths.makePath("foo", "bar", null), "/foo/bar");    Assert.assertEquals(ZKPaths.makePath("foo", null, "baz"), "/foo/baz");}
90d49973067e09046c2361e8cb8bd0e203bf010851942e47d8a368b642017e27
testSplit
public void testSplit()
{    Assert.assertEquals(ZKPaths.split("/"), Collections.emptyList());    Assert.assertEquals(ZKPaths.split("/test"), Collections.singletonList("test"));    Assert.assertEquals(ZKPaths.split("/test/one"), Arrays.asList("test", "one"));    Assert.assertEquals(ZKPaths.split("/test/one/two"), Arrays.asList("test", "one", "two"));}
2ebf7d565930eb94d3a02979b0a79b35902a5e39fa389f1f23de62b446887929
wrap
public static AsyncCuratorFramework wrap(CuratorFramework client)
{        return AsyncCuratorFramework.wrap(client);}
ca020966e713fea23795f79395409752e003e31273fe0c4fe6de7af54b7f80dc
create
public static void create(CuratorFramework client, String path, byte[] payload)
{        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.create().forPath(path, payload).whenComplete((name, exception) -> {        if (exception != null) {                        exception.printStackTrace();        } else {            System.out.println("Created node name is: " + name);        }    });}
2d48c8c36f0583f6e004d233fbf838ff33dab8a3a11ea5bd48a8d159be193c23
createThenWatch
public static void createThenWatch(CuratorFramework client, String path)
{        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);                        async.create().forPath(path).whenComplete((name, exception) -> {        if (exception != null) {                        exception.printStackTrace();        } else {            handleWatchedStage(async.watched().checkExists().forPath(path).event());        }    });}
1c4281c38dbfb0b05665be8cc2e99eae487f8db4d6444a5a2d86a511046bada5
createThenWatchSimple
public static void createThenWatchSimple(CuratorFramework client, String path)
{        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);            async.create().forPath(path).whenComplete((name, exception) -> {        if (exception != null) {                        exception.printStackTrace();        } else {                                    async.with(WatchMode.successOnly).watched().checkExists().forPath(path).event().thenAccept(event -> {                System.out.println(event.getType());                System.out.println(event);            });        }    });}
82dc86d18a60ee8952ecf760f078ad33d2914fdde1f1ce5de5d7e53e78164683
handleWatchedStage
private static void handleWatchedStage(CompletionStage<WatchedEvent> watchedStage)
{                watchedStage.thenAccept(event -> {        System.out.println(event.getType());        System.out.println(event);        });                watchedStage.exceptionally(exception -> {        AsyncEventException asyncEx = (AsyncEventException) exception;                asyncEx.printStackTrace();        handleWatchedStage(asyncEx.reset());        return null;    });}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    TestingServer server = new TestingServer();    CuratorFramework client = null;    PathChildrenCache cache = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(1000, 3));        client.start();                cache = new PathChildrenCache(client, PATH, true);        cache.start();        processCommands(client, cache);    } finally {        CloseableUtils.closeQuietly(cache);        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(server);    }}
7fc724f989c7c69a2ea1d75552c1d4ff2f51bc3749a3618704318d4ac7e8b01e
addListener
private static void addListener(PathChildrenCache cache)
{        PathChildrenCacheListener listener = new PathChildrenCacheListener() {        @Override        public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {            switch(event.getType()) {                case CHILD_ADDED:                    {                        System.out.println("Node added: " + ZKPaths.getNodeFromPath(event.getData().getPath()));                        break;                    }                case CHILD_UPDATED:                    {                        System.out.println("Node changed: " + ZKPaths.getNodeFromPath(event.getData().getPath()));                        break;                    }                case CHILD_REMOVED:                    {                        System.out.println("Node removed: " + ZKPaths.getNodeFromPath(event.getData().getPath()));                        break;                    }            }        }    };    cache.getListenable().addListener(listener);}
d6477cd5e4da923bd9799bbf8d4db46d7d153fc78458c819b2b186c1ddff908e
childEvent
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    switch(event.getType()) {        case CHILD_ADDED:            {                System.out.println("Node added: " + ZKPaths.getNodeFromPath(event.getData().getPath()));                break;            }        case CHILD_UPDATED:            {                System.out.println("Node changed: " + ZKPaths.getNodeFromPath(event.getData().getPath()));                break;            }        case CHILD_REMOVED:            {                System.out.println("Node removed: " + ZKPaths.getNodeFromPath(event.getData().getPath()));                break;            }    }}
c8bf5369bd09235a312745a569bfd3d19f57d686848c3ee93be2bdd519e3d803
processCommands
private static void processCommands(CuratorFramework client, PathChildrenCache cache) throws Exception
{        printHelp();    List<ExampleServer> servers = Lists.newArrayList();    try {        addListener(cache);        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));        boolean done = false;        while (!done) {            System.out.print("> ");            String line = in.readLine();            if (line == null) {                break;            }            String command = line.trim();            String[] parts = command.split("\\s");            if (parts.length == 0) {                continue;            }            String operation = parts[0];            String[] args = Arrays.copyOfRange(parts, 1, parts.length);            if (operation.equalsIgnoreCase("help") || operation.equalsIgnoreCase("?")) {                printHelp();            } else if (operation.equalsIgnoreCase("q") || operation.equalsIgnoreCase("quit")) {                done = true;            } else if (operation.equals("set")) {                setValue(client, command, args);            } else if (operation.equals("remove")) {                remove(client, command, args);            } else if (operation.equals("list")) {                list(cache);            }                        Thread.sleep(1000);        }    } finally {        for (ExampleServer server : servers) {            CloseableUtils.closeQuietly(server);        }    }}
e305d394a41787e304d530d2628fd21dde1793d3cad71363c76fa9b703fc7f49
list
private static void list(PathChildrenCache cache)
{    if (cache.getCurrentData().size() == 0) {        System.out.println("* empty *");    } else {        for (ChildData data : cache.getCurrentData()) {            System.out.println(data.getPath() + " = " + new String(data.getData()));        }    }}
e1b09078a34278a0a4e982b9ad0c6494049759cf19e389122bb5b756d3d82600
remove
private static void remove(CuratorFramework client, String command, String[] args) throws Exception
{    if (args.length != 1) {        System.err.println("syntax error (expected remove <path>): " + command);        return;    }    String name = args[0];    if (name.contains("/")) {        System.err.println("Invalid node name" + name);        return;    }    String path = ZKPaths.makePath(PATH, name);    try {        client.delete().forPath(path);    } catch (KeeperException.NoNodeException e) {        }}
07e349ea6952afdf88b80c9b5dd345df7bbdbc666a3248e1215eaafc4eb9d54e
setValue
private static void setValue(CuratorFramework client, String command, String[] args) throws Exception
{    if (args.length != 2) {        System.err.println("syntax error (expected set <path> <value>): " + command);        return;    }    String name = args[0];    if (name.contains("/")) {        System.err.println("Invalid node name" + name);        return;    }    String path = ZKPaths.makePath(PATH, name);    byte[] bytes = args[1].getBytes();    try {        client.setData().forPath(path, bytes);    } catch (KeeperException.NoNodeException e) {        client.create().creatingParentContainersIfNeeded().forPath(path, bytes);    }}
7058e2f45ea7958a4c9b30edffd4edec3afc2c382ac1536fdacddc601fbac237
printHelp
private static void printHelp()
{    System.out.println("An example of using PathChildrenCache. This example is driven by entering commands at the prompt:\n");    System.out.println("set <name> <value>: Adds or updates a node with the given name");    System.out.println("remove <name>: Deletes the node with the given name");    System.out.println("list: List the nodes/values in the cache");    System.out.println("quit: Quit the example");    System.out.println();}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    CuratorFramework client = CreateClientExamples.createSimple("127.0.0.1:2181");    client.getUnhandledErrorListenable().addListener((message, e) -> {        System.err.println("error=" + message);        e.printStackTrace();    });    client.getConnectionStateListenable().addListener((c, newState) -> {        System.out.println("state=" + newState);    });    client.start();    TreeCache cache = TreeCache.newBuilder(client, "/").setCacheData(false).build();    cache.getListenable().addListener((c, event) -> {        if (event.getData() != null) {            System.out.println("type=" + event.getType() + " path=" + event.getData().getPath());        } else {            System.out.println("type=" + event.getType());        }    });    cache.start();    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));    in.readLine();}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{        TestingServer server = new TestingServer();    CuratorFramework client = null;    ServiceDiscovery<InstanceDetails> serviceDiscovery = null;    Map<String, ServiceProvider<InstanceDetails>> providers = Maps.newHashMap();    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(1000, 3));        client.start();        JsonInstanceSerializer<InstanceDetails> serializer = new JsonInstanceSerializer<InstanceDetails>(InstanceDetails.class);        serviceDiscovery = ServiceDiscoveryBuilder.builder(InstanceDetails.class).client(client).basePath(PATH).serializer(serializer).build();        serviceDiscovery.start();        processCommands(serviceDiscovery, providers, client);    } finally {        for (ServiceProvider<InstanceDetails> cache : providers.values()) {            CloseableUtils.closeQuietly(cache);        }        CloseableUtils.closeQuietly(serviceDiscovery);        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(server);    }}
f0d41898f0c5ef9abac512ce714baede66ee7afc0bef68540e080e3d3f737315
processCommands
private static void processCommands(ServiceDiscovery<InstanceDetails> serviceDiscovery, Map<String, ServiceProvider<InstanceDetails>> providers, CuratorFramework client) throws Exception
{        printHelp();    List<ExampleServer> servers = Lists.newArrayList();    try {        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));        boolean done = false;        while (!done) {            System.out.print("> ");            String line = in.readLine();            if (line == null) {                break;            }            String command = line.trim();            String[] parts = command.split("\\s");            if (parts.length == 0) {                continue;            }            String operation = parts[0];            String[] args = Arrays.copyOfRange(parts, 1, parts.length);            if (operation.equalsIgnoreCase("help") || operation.equalsIgnoreCase("?")) {                printHelp();            } else if (operation.equalsIgnoreCase("q") || operation.equalsIgnoreCase("quit")) {                done = true;            } else if (operation.equals("add")) {                addInstance(args, client, command, servers);            } else if (operation.equals("delete")) {                deleteInstance(args, command, servers);            } else if (operation.equals("random")) {                listRandomInstance(args, serviceDiscovery, providers, command);            } else if (operation.equals("list")) {                listInstances(serviceDiscovery);            }        }    } finally {        for (ExampleServer server : servers) {            CloseableUtils.closeQuietly(server);        }    }}
1ea37ba2a67784c53c70e05ed266a5fc4f444aa16ed93e9687acebde5b049b6f
listRandomInstance
private static void listRandomInstance(String[] args, ServiceDiscovery<InstanceDetails> serviceDiscovery, Map<String, ServiceProvider<InstanceDetails>> providers, String command) throws Exception
{    if (args.length != 1) {        System.err.println("syntax error (expected random <name>): " + command);        return;    }    String serviceName = args[0];    ServiceProvider<InstanceDetails> provider = providers.get(serviceName);    if (provider == null) {        provider = serviceDiscovery.serviceProviderBuilder().serviceName(serviceName).providerStrategy(new RandomStrategy<InstanceDetails>()).build();        providers.put(serviceName, provider);        provider.start();                Thread.sleep(2500);    }    ServiceInstance<InstanceDetails> instance = provider.getInstance();    if (instance == null) {        System.err.println("No instances named: " + serviceName);    } else {        outputInstance(instance);    }}
5444c7bca30ce79cd5b4ac9341a4288362a1d42df896fbc23950c997e15a7b2d
listInstances
private static void listInstances(ServiceDiscovery<InstanceDetails> serviceDiscovery) throws Exception
{    try {        Collection<String> serviceNames = serviceDiscovery.queryForNames();        System.out.println(serviceNames.size() + " type(s)");        for (String serviceName : serviceNames) {            Collection<ServiceInstance<InstanceDetails>> instances = serviceDiscovery.queryForInstances(serviceName);            System.out.println(serviceName);            for (ServiceInstance<InstanceDetails> instance : instances) {                outputInstance(instance);            }        }    } finally {        CloseableUtils.closeQuietly(serviceDiscovery);    }}
1d7bc39082ca5cf8c48902983c15416ad64c73c00d27296b69a9f8df03ecc4db
outputInstance
private static void outputInstance(ServiceInstance<InstanceDetails> instance)
{    System.out.println("\t" + instance.getPayload().getDescription() + ": " + instance.buildUriSpec());}
e2d1a6726c7dc88562968b391de3d338c04a036086795e80a1ec80cb0a9969b2
deleteInstance
private static void deleteInstance(String[] args, String command, List<ExampleServer> servers)
{    if (args.length != 1) {        System.err.println("syntax error (expected delete <name>): " + command);        return;    }    final String serviceName = args[0];    ExampleServer server = Iterables.find(servers, new Predicate<ExampleServer>() {        @Override        public boolean apply(ExampleServer server) {            return server.getThisInstance().getName().endsWith(serviceName);        }    }, null);    if (server == null) {        System.err.println("No servers found named: " + serviceName);        return;    }    servers.remove(server);    CloseableUtils.closeQuietly(server);    System.out.println("Removed a random instance of: " + serviceName);}
7260b5682328a4b9fca73953cdabf3c4dbeed0c8d694b00e9971ae1fe5ee4dd5
apply
public boolean apply(ExampleServer server)
{    return server.getThisInstance().getName().endsWith(serviceName);}
e76420adccb9682be60df9d22ebbe0b582a813b2aa24bf76f378c246050edce2
addInstance
private static void addInstance(String[] args, CuratorFramework client, String command, List<ExampleServer> servers) throws Exception
{    if (args.length < 2) {        System.err.println("syntax error (expected add <name> <description>): " + command);        return;    }    StringBuilder description = new StringBuilder();    for (int i = 1; i < args.length; ++i) {        if (i > 1) {            description.append(' ');        }        description.append(args[i]);    }    String serviceName = args[0];    ExampleServer server = new ExampleServer(client, PATH, serviceName, description.toString());    servers.add(server);    server.start();    System.out.println(serviceName + " added");}
7058e2f45ea7958a4c9b30edffd4edec3afc2c382ac1536fdacddc601fbac237
printHelp
private static void printHelp()
{    System.out.println("An example of using the ServiceDiscovery APIs. This example is driven by entering commands at the prompt:\n");    System.out.println("add <name> <description>: Adds a mock service with the given name and description");    System.out.println("delete <name>: Deletes one of the mock services with the given name");    System.out.println("list: Lists all the currently registered services");    System.out.println("random <name>: Lists a random instance of the service with the given name");    System.out.println("quit: Quit the example");    System.out.println();}
a64fa8c8e61ff010733123b1177258d8da393117e33309a448d28c2011db8f7e
getThisInstance
public ServiceInstance<InstanceDetails> getThisInstance()
{    return thisInstance;}
90ba0dddc593bd95e2a0c0c039c523b81bfb91f87814ebcb222c3914ca772ead
start
public void start() throws Exception
{    serviceDiscovery.start();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    CloseableUtils.closeQuietly(serviceDiscovery);}
1a211ebf68b221c2c3c67d58559d636c48c482bac17440249777eb28f553a9ad
setDescription
public void setDescription(String description)
{    this.description = description;}
706203ef14181d53971fddf5ab6603fcf31442cdccb19cc5e237bca9faee9d63
getDescription
public String getDescription()
{    return description;}
2068cec077f969941f03f36c3a714a8056929e665a72387547ae460fa5db0b6b
createSimple
public static CuratorFramework createSimple(String connectionString)
{                ExponentialBackoffRetry retryPolicy = new ExponentialBackoffRetry(1000, 3);        return CuratorFrameworkFactory.newClient(connectionString, retryPolicy);}
eb3975ed71415e328be163935b31c9950890d8808873aaa1ad82a1f1693a0176
createWithOptions
public static CuratorFramework createWithOptions(String connectionString, RetryPolicy retryPolicy, int connectionTimeoutMs, int sessionTimeoutMs)
{        return CuratorFrameworkFactory.builder().connectString(connectionString).retryPolicy(retryPolicy).connectionTimeoutMs(connectionTimeoutMs).sessionTimeoutMs(sessionTimeoutMs).build();}
4231033a2d44518dcfa01949341bbbe6a50371b3a0e5d7a0f103f726de53faae
create
public static void create(CuratorFramework client, String path, byte[] payload) throws Exception
{        client.create().forPath(path, payload);}
596f80119c7678c090264b4ff17995343836bb39cd753e1f421382655c318bca
createEphemeral
public static void createEphemeral(CuratorFramework client, String path, byte[] payload) throws Exception
{        client.create().withMode(CreateMode.EPHEMERAL).forPath(path, payload);}
c454f7eb8b4a273e4d22802ffefb83611669c1894afc980e66b9a9b899a07140
createEphemeralSequential
public static String createEphemeralSequential(CuratorFramework client, String path, byte[] payload) throws Exception
{    /*            Protection Mode:            It turns out there is an edge case that exists when creating sequential-ephemeral nodes. The creation            can succeed on the server, but the server can crash before the created node name is returned to the            client. However, the ZK session is still valid so the ephemeral node is not deleted. Thus, there is no            way for the client to determine what node was created for them.            Even without sequential-ephemeral, however, the create can succeed on the sever but the client (for various            reasons) will not know it. Putting the create builder into protection mode works around this. The name of            the node that is created is prefixed with a GUID. If node creation fails the normal retry mechanism will            occur. On the retry, the parent path is first searched for a node that has the GUID in it. If that node is            found, it is assumed to be the lost node that was successfully created on the first try and is returned to            the caller.         */    return client.create().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path, payload);}
d1959f029c72908bca49bb7a4cae5d6780cd76c70c6d678324c5f38eba946bb9
setData
public static void setData(CuratorFramework client, String path, byte[] payload) throws Exception
{        client.setData().forPath(path, payload);}
e38d3bcf75e9fca2ab04131ecdc0582e9646d78b7470bb8b72fd1008fd4f43ad
setDataAsync
public static void setDataAsync(CuratorFramework client, String path, byte[] payload) throws Exception
{        CuratorListener listener = new CuratorListener() {        @Override        public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                }    };    client.getCuratorListenable().addListener(listener);            client.setData().inBackground().forPath(path, payload);}
e958fd31854b02620bcc0e47a47ca286f0584d1be38198248b0d2054a45a8cea
eventReceived
public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception
{}
b46d86ec45b712d851de245836815e74ceca8634641098ace9715b053d1518df
setDataAsyncWithCallback
public static void setDataAsyncWithCallback(CuratorFramework client, BackgroundCallback callback, String path, byte[] payload) throws Exception
{        client.setData().inBackground(callback).forPath(path, payload);}
2b54841ee70aa16274a16c857bccceef58a61c97f408b33eb1a5856079f83e2a
delete
public static void delete(CuratorFramework client, String path) throws Exception
{        client.delete().forPath(path);}
092ef5e846110e01340fb5c6911c9105f1271341a36db053160422405fad236b
guaranteedDelete
public static void guaranteedDelete(CuratorFramework client, String path) throws Exception
{        /*            Guaranteed Delete            Solves this edge case: deleting a node can fail due to connection issues. Further, if the node was            ephemeral, the node will not get auto-deleted as the session is still valid. This can wreak havoc            with lock implementations.            When guaranteed is set, Curator will record failed node deletions and attempt to delete them in the            background until successful. NOTE: you will still get an exception when the deletion fails. But, you            can be assured that as long as the CuratorFramework instance is open attempts will be made to delete            the node.         */    client.delete().guaranteed().forPath(path);}
649c7757e434c5a308f54ec8d5737ad77fb39ccb6d9535bcb725f80222a58608
watchedGetChildren
public static List<String> watchedGetChildren(CuratorFramework client, String path) throws Exception
{    /**     * Get children and set a watcher on the node. The watcher notification will come through the     * CuratorListener (see setDataAsync() above).     */    return client.getChildren().watched().forPath(path);}
bac0bdadb9f6a981d9025537fc825328e067ef1bea36cf5154a4013f9e2e944d
watchedGetChildren
public static List<String> watchedGetChildren(CuratorFramework client, String path, Watcher watcher) throws Exception
{    /**     * Get children and set the given watcher on the node.     */    return client.getChildren().usingWatcher(watcher).forPath(path);}
b5af4d7611130712a570009b2fba41986bf9346b62c08b507ae8795cd4ccc22b
transaction
public static Collection<CuratorTransactionResult> transaction(CuratorFramework client) throws Exception
{        CuratorOp createOp = client.transactionOp().create().forPath("/a/path", "some data".getBytes());    CuratorOp setDataOp = client.transactionOp().setData().forPath("/another/path", "other data".getBytes());    CuratorOp deleteOp = client.transactionOp().delete().forPath("/yet/another/path");    Collection<CuratorTransactionResult> results = client.transaction().forOperations(createOp, setDataOp, deleteOp);    for (CuratorTransactionResult result : results) {        System.out.println(result.getForPath() + " - " + result.getType());    }    return results;}
e5a14fc0f40f83e0c8774c3bcbdfa6c6fbf236404951b40500e2bd5e42f00077
start
public void start() throws IOException
{            leaderSelector.start();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    leaderSelector.close();}
572980c734fcdd22464cc98d1931013f84abfc71246389b062e7e113e357572e
takeLeadership
public void takeLeadership(CuratorFramework client) throws Exception
{        final int waitSeconds = (int) (5 * Math.random()) + 1;    System.out.println(name + " is now the leader. Waiting " + waitSeconds + " seconds...");    System.out.println(name + " has been leader " + leaderCount.getAndIncrement() + " time(s) before.");    try {        Thread.sleep(TimeUnit.SECONDS.toMillis(waitSeconds));    } catch (InterruptedException e) {        System.err.println(name + " was interrupted.");        Thread.currentThread().interrupt();    } finally {        System.out.println(name + " relinquishing leadership.\n");    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{        System.out.println("Create " + CLIENT_QTY + " clients, have each negotiate for leadership and then wait a random number of seconds before letting another leader election occur.");    System.out.println("Notice that leader election is fair: all clients will become leader and will do so the same number of times.");    List<CuratorFramework> clients = Lists.newArrayList();    List<ExampleClient> examples = Lists.newArrayList();    TestingServer server = new TestingServer();    try {        for (int i = 0; i < CLIENT_QTY; ++i) {            CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(1000, 3));            clients.add(client);            ExampleClient example = new ExampleClient(client, PATH, "Client #" + i);            examples.add(example);            client.start();            example.start();        }        System.out.println("Press enter/return to quit\n");        new BufferedReader(new InputStreamReader(System.in)).readLine();    } finally {        System.out.println("Shutting down...");        for (ExampleClient exampleClient : examples) {            CloseableUtils.closeQuietly(exampleClient);        }        for (CuratorFramework client : clients) {            CloseableUtils.closeQuietly(client);        }        CloseableUtils.closeQuietly(server);    }}
efbeace00232e71c0e4b619bfd7477b5494ac7741ac12906c3ee587ba4637ac6
doWork
public void doWork(long time, TimeUnit unit) throws Exception
{    if (!lock.acquire(time, unit)) {        throw new IllegalStateException(clientName + " could not acquire the lock");    }    try {        System.out.println(clientName + " has the lock");        resource.use();    } finally {        System.out.println(clientName + " releasing the lock");                lock.release();    }}
2a2993243a90d8135b4c0f5df7f6179fb4be88a1d30453ac7fd22e4df03ef9de
use
public void use() throws InterruptedException
{    if (!inUse.compareAndSet(false, true)) {        throw new IllegalStateException("Needs to be used by one client at a time");    }    try {        Thread.sleep((long) (3 * Math.random()));    } finally {        inUse.set(false);    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{            final FakeLimitedResource resource = new FakeLimitedResource();    ExecutorService service = Executors.newFixedThreadPool(QTY);    final TestingServer server = new TestingServer();    try {        for (int i = 0; i < QTY; ++i) {            final int index = i;            Callable<Void> task = new Callable<Void>() {                @Override                public Void call() throws Exception {                    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(1000, 3));                    try {                        client.start();                        ExampleClientThatLocks example = new ExampleClientThatLocks(client, PATH, resource, "Client " + index);                        for (int j = 0; j < REPETITIONS; ++j) {                            example.doWork(10, TimeUnit.SECONDS);                        }                    } catch (InterruptedException e) {                        Thread.currentThread().interrupt();                    } catch (Exception e) {                        e.printStackTrace();                                        } finally {                        CloseableUtils.closeQuietly(client);                    }                    return null;                }            };            service.submit(task);        }        service.shutdown();        service.awaitTermination(10, TimeUnit.MINUTES);    } finally {        CloseableUtils.closeQuietly(server);    }}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(1000, 3));    try {        client.start();        ExampleClientThatLocks example = new ExampleClientThatLocks(client, PATH, resource, "Client " + index);        for (int j = 0; j < REPETITIONS; ++j) {            example.doWork(10, TimeUnit.SECONDS);        }    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    } catch (Exception e) {        e.printStackTrace();        } finally {        CloseableUtils.closeQuietly(client);    }    return null;}
9c0244f39127c30553772737e7d7bbe3099afd1ee523d989bdb8369913bcb15f
getTypeId
public int getTypeId()
{    return typeId;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    ContainerType that = (ContainerType) o;    return typeId == that.typeId;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return typeId;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "ContainerType{" + "typeId=" + typeId + '}';}
dd45037edb4cb38e99318f9f535a5e914cc1a40ab8a11d206bec0d939b001d61
wrap
public static ModeledFramework<PersonModel> wrap(AsyncCuratorFramework client)
{    JacksonModelSerializer<PersonModel> serializer = JacksonModelSerializer.build(PersonModel.class);        ModelSpec<PersonModel> modelSpec = ModelSpec.builder(ZPath.parse("/example/path"), serializer).build();        return ModeledFramework.wrap(client, modelSpec);}
fbc46a4d608d8cd9d02f6a23355def0e57e5f9559594f1c2b47a3721bf598348
createOrUpdate
public static void createOrUpdate(ModeledFramework<PersonModel> modeled, PersonModel model)
{        ModeledFramework<PersonModel> atId = modeled.child(model.getId().getId());                atId.set(model);}
b6b4dea37e937c24724f5da8add9bc62e4c0d14b153c720047084f3bfc35d085
readPerson
public static void readPerson(ModeledFramework<PersonModel> modeled, String id, Consumer<PersonModel> receiver)
{        modeled.child(id).read().whenComplete((person, exception) -> {        if (exception != null) {                        exception.printStackTrace();        } else {            receiver.accept(person);        }    });}
76ca1242f7556978c198b123f08d306e5d78031afc7469b5684eef87dd67b3cc
createOrUpdate
public static void createOrUpdate(PersonModelSpec modelSpec, PersonModel model)
{        ModeledFramework<PersonModel> resolved = modelSpec.resolved(model.getContainerType(), model.getId());                resolved.set(model);}
0aa28d5bdeb1022b4c441a03a56d92bc14995e05f4f196133fb25f139381a9b2
readPerson
public static void readPerson(PersonModelSpec modelSpec, ContainerType containerType, PersonId id, Consumer<PersonModel> receiver)
{    ModeledFramework<PersonModel> resolved = modelSpec.resolved(containerType, id);        resolved.read().whenComplete((person, exception) -> {        if (exception != null) {                        exception.printStackTrace();        } else {            receiver.accept(person);        }    });}
09e8f13a9a603d31d64bb498b77d15572483824d843d0e82a570643192f62186
getId
public String getId()
{    return id;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    PersonId personId = (PersonId) o;    return id.equals(personId.id);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return id.hashCode();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "PersonId{" + "id='" + id + '\'' + '}';}
ab95467c91c53eb5aefcf999147f92ba28f0967a163ecd2dd653f9a0e2249c60
getId
public PersonId getId()
{    return id;}
d16034ba67a5fe1602b930e1fc015ae243ec3d22e1959d964da80007de3e4f84
getContainerType
public ContainerType getContainerType()
{    return containerType;}
8223619f9a48a7734c9a4c93ce2235de22a170c3460a0f79334223e6044061d3
getFirstName
public String getFirstName()
{    return firstName;}
2af394af8443aef69d5e1f7c628a00b49a5fb1d708eab1dd2a3a28ed60033c8c
getLastName
public String getLastName()
{    return lastName;}
91498b3411d692695c2e082303a572def4cc3c0654fd16134aa70866f88b4e0a
getAge
public int getAge()
{    return age;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    PersonModel that = (PersonModel) o;    if (age != that.age) {        return false;    }    if (!id.equals(that.id)) {        return false;    }    if (!containerType.equals(that.containerType)) {        return false;    }        if (!firstName.equals(that.firstName)) {        return false;    }    return lastName.equals(that.lastName);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = id.hashCode();    result = 31 * result + containerType.hashCode();    result = 31 * result + firstName.hashCode();    result = 31 * result + lastName.hashCode();    result = 31 * result + age;    return result;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "PersonModel{" + "id=" + id + ", containerType=" + containerType + ", firstName='" + firstName + '\'' + ", lastName='" + lastName + '\'' + ", age=" + age + '}';}
c8c162794f1cf28480c8c5b7d702cab8c9402af3f856be8e33dd5934735c6af7
resolved
public ModeledFramework<PersonModel> resolved(ContainerType containerType, PersonId personId)
{    ModelSpec<PersonModel> resolved = modelSpec.resolved(containerType.getTypeId(), personId.getId());    return ModeledFramework.wrap(client, resolved);}
aab7543db4fbdafb2d6f507f9b478fe608b636a0681258c099c162bf4ae1cff4
builder
private static ModelSpecBuilder<T> builder(Class<T> clazz)
{    return ModelSpec.builder(JacksonModelSerializer.build(clazz)).withTtl(    TimeUnit.MINUTES.toMillis(10)).withCreateMode(CreateMode.PERSISTENT_WITH_TTL);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "LocationAvailable{" + "name='" + name + '\'' + ", availableUntil=" + availableUntil + "} " + super.toString();}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
51d2e410cc19415ac5c603482cd35eaf52883b320ab6a511b6db9d0eb43c8e82
getPosition
public String getPosition()
{    return position;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "UserCreated{" + "name='" + name + '\'' + ", position='" + position + '\'' + "} " + super.toString();}
4be9cb147e99dde2b588d1ba41053546c573e7062e5285b3f5bcae5374b37a0e
getGroupName
public String getGroupName()
{    return groupName;}
6df6555f68d39768e223ec04511b3e80c37a296912e147a95680e6a0c17047c8
nodeName
public String nodeName()
{    return groupName;}
09e8f13a9a603d31d64bb498b77d15572483824d843d0e82a570643192f62186
getId
public String getId()
{    return id;}
7140a57213ae3d9aa9e0d255719f2602b8ea407e855907092b032d72aed31647
getType
public InstanceType getType()
{    return type;}
27236935fc56b50befbdcf980df4df93fc1cb38744897e3c4ee05c744e513e94
getHostname
public String getHostname()
{    return hostname;}
eedb587f68470407e820d49bf6bb9be573d78555382d32a0743e8fea8ced15d6
getPort
public int getPort()
{    return port;}
6df6555f68d39768e223ec04511b3e80c37a296912e147a95680e6a0c17047c8
nodeName
public String nodeName()
{    return id;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "Instance{" + "id='" + id + '\'' + ", type=" + type + ", hostname='" + hostname + '\'' + ", port=" + port + '}';}
09e8f13a9a603d31d64bb498b77d15572483824d843d0e82a570643192f62186
getId
public String getId()
{    return id;}
3677ee2d716057412e04a1f7bc0b3b41fce238eb9020826e80f32b2ecac1422a
getPriority
public Priority getPriority()
{    return priority;}
6df6555f68d39768e223ec04511b3e80c37a296912e147a95680e6a0c17047c8
nodeName
public String nodeName()
{    return id;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "Message{" + "id='" + id + '\'' + ", priority=" + priority + '}';}
128e6067c4d2dde6a9e938e98eaca48adca84eabf8c4ff3edde6a67e1a42f8a6
publishInstance
public void publishInstance(Instance instance)
{    ModeledFramework<Instance> resolvedClient = Clients.instanceClient.resolved(client, instance.getType());    resolvedClient.set(instance).exceptionally(e -> {        log.error("Could not publish instance: " + instance, e);        return null;    });}
cf7f1dd4572f3b7e7a6d24f1530ed8895a95ee730d2b1b282fe51a052a84d5aa
publishInstances
public void publishInstances(List<Instance> instances)
{    List<CuratorOp> operations = instances.stream().map(instance -> Clients.instanceClient.resolved(client, instance.getType()).createOp(instance)).collect(Collectors.toList());    client.transaction().forOperations(operations).exceptionally(e -> {        log.error("Could not publish instances: " + instances, e);        return null;    });}
c793112c58ed52700b704ff170228ea5b2480136c875c8bee9a2bbf637660dae
publishLocationAvailable
public void publishLocationAvailable(Group group, LocationAvailable locationAvailable)
{    publishMessage(Clients.locationAvailableClient, group, locationAvailable);}
e8b0d9ac59c5bb36d7698fbee4721cf1f23d4661cc8d6516e5aa3a1fcfbd4a14
publishUserCreated
public void publishUserCreated(Group group, UserCreated userCreated)
{    publishMessage(Clients.userCreatedClient, group, userCreated);}
c51b5edd7d3c6fd819ac0879970c560a2465b58ff223a8cf8da7fbeb27598f0a
publishLocationsAvailable
public void publishLocationsAvailable(Group group, List<LocationAvailable> locationsAvailable)
{    publishMessages(Clients.locationAvailableClient, group, locationsAvailable);}
8a5d0d677c0f5f8505391f043e8913d60f85b2459d41c4e7483e10ed64a8426a
publishUsersCreated
public void publishUsersCreated(Group group, List<UserCreated> usersCreated)
{    publishMessages(Clients.userCreatedClient, group, usersCreated);}
1f1915363d9efe430c951021f66379f72033ddbe47081a5af42e58327a2d5da6
publishMessage
private void publishMessage(TypedModeledFramework2<T, Group, Priority> typedClient, Group group, T message)
{    ModeledFramework<T> resolvedClient = typedClient.resolved(client, group, message.getPriority());    resolvedClient.set(message).exceptionally(e -> {        log.error("Could not publish message: " + message, e);        return null;    });}
fe6273eaf0fd88cc9b0df13971af92f7e045030295938cfb9b60f0e4b66fe02e
publishMessages
private void publishMessages(TypedModeledFramework2<T, Group, Priority> typedClient, Group group, List<T> messages)
{    List<CuratorOp> operations = messages.stream().map(message -> typedClient.resolved(client, group, message.getPriority()).createOp(message)).collect(Collectors.toList());    client.transaction().forOperations(operations).exceptionally(e -> {        log.error("Could not publish messages: " + messages, e);        return null;    });}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    try (SubPubTest subPubTest = new SubPubTest()) {        subPubTest.start();                TimeUnit.MINUTES.sleep(1);    } catch (Exception e) {        e.printStackTrace();    }}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    client.unwrap().start();    Publisher publisher = new Publisher(client);    Subscriber subscriber = new Subscriber(client);        instanceSubscribers.addAll(Arrays.stream(InstanceType.values()).map(subscriber::startInstanceSubscriber).collect(Collectors.toList()));        locationAvailableSubscribers.addAll(Arrays.stream(Priority.values()).flatMap(priority -> Arrays.stream(groups).map(group -> subscriber.startLocationAvailableSubscriber(group, priority))).collect(Collectors.toList()));        userCreatedSubscribers.addAll(Arrays.stream(Priority.values()).flatMap(priority -> Arrays.stream(groups).map(group -> subscriber.startUserCreatedSubscriber(group, priority))).collect(Collectors.toList()));        instanceSubscribers.forEach(s -> s.listenable().addListener(generalListener()));    locationAvailableSubscribers.forEach(s -> s.listenable().addListener(generalListener()));    userCreatedSubscribers.forEach(s -> s.listenable().addListener(generalListener()));        executorService.scheduleAtFixedRate(() -> publishSomething(publisher), 1, 1, TimeUnit.SECONDS);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    executorService.shutdownNow();    try {        executorService.awaitTermination(5, TimeUnit.SECONDS);    } catch (InterruptedException ignore) {        Thread.currentThread().interrupt();    }    userCreatedSubscribers.forEach(CachedModeledFramework::close);    locationAvailableSubscribers.forEach(CachedModeledFramework::close);    instanceSubscribers.forEach(CachedModeledFramework::close);    client.unwrap().close();    testingServer.close();}
d017e2c72862048f618d65a29adecd21a9d1c6d69b9646c1504356284fac7acb
publishSomething
private void publishSomething(Publisher publisher)
{        switch(ThreadLocalRandom.current().nextInt(6)) {        case 0:            {                Instance instance = new Instance(nextId(), random(InstanceType.values()), random(hostnames), random(ports));                System.out.println("Publishing 1 instance");                publisher.publishInstance(instance);                break;            }        case 1:            {                List<Instance> instances = IntStream.range(1, 10).mapToObj(__ -> new Instance(nextId(), random(InstanceType.values()), random(hostnames), random(ports))).collect(Collectors.toList());                System.out.println(String.format("Publishing %d instances", instances.size()));                publisher.publishInstances(instances);                break;            }        case 2:            {                LocationAvailable locationAvailable = new LocationAvailable(nextId(), random(Priority.values()), random(locations), random(durations));                System.out.println("Publishing 1 locationAvailable");                publisher.publishLocationAvailable(random(groups), locationAvailable);                break;            }        case 3:            {                List<LocationAvailable> locationsAvailable = IntStream.range(1, 10).mapToObj(__ -> new LocationAvailable(nextId(), random(Priority.values()), random(locations), random(durations))).collect(Collectors.toList());                System.out.println(String.format("Publishing %d locationsAvailable", locationsAvailable.size()));                publisher.publishLocationsAvailable(random(groups), locationsAvailable);                break;            }        case 4:            {                UserCreated userCreated = new UserCreated(nextId(), random(Priority.values()), random(locations), random(positions));                System.out.println("Publishing 1 userCreated");                publisher.publishUserCreated(random(groups), userCreated);                break;            }        case 5:            {                List<UserCreated> usersCreated = IntStream.range(1, 10).mapToObj(__ -> new UserCreated(nextId(), random(Priority.values()), random(locations), random(positions))).collect(Collectors.toList());                System.out.println(String.format("Publishing %d usersCreated", usersCreated.size()));                publisher.publishUsersCreated(random(groups), usersCreated);                break;            }    }}
c7a05f542d74521720b3092ba3ba96fc8fab8bb1c10e297ae3c018156cdcdc6b
generalListener
private ModeledCacheListener<T> generalListener()
{    return (type, path, stat, model) -> System.out.println(String.format("Subscribed %s @ %s", model.getClass().getSimpleName(), path));}
76a76a8279646aec320ed09062074ba10a42cc1c18f2c8c71d9fa7b9e06010dc
random
private final T random(T... tab)
{    int index = ThreadLocalRandom.current().nextInt(tab.length);    return tab[index];}
eb780b0851e32e223f071598044ec1424c7dd4430ef6bc1982bb20ed14d6d3a7
nextId
private String nextId()
{    return Long.toString(nextId.getAndIncrement());}
5cf162c75c2666da57e8ba3d1381ed1bdd3d1f98b75b72bf6efb03ec83a2b73c
startLocationAvailableSubscriber
public CachedModeledFramework<LocationAvailable> startLocationAvailableSubscriber(Group group, Priority priority)
{    return startSubscriber(Clients.locationAvailableClient, group, priority);}
e37fdb834936271179529d539ae11a44a5a6060afa95192a3bf226e90fdd8ee3
startUserCreatedSubscriber
public CachedModeledFramework<UserCreated> startUserCreatedSubscriber(Group group, Priority priority)
{    return startSubscriber(Clients.userCreatedClient, group, priority);}
0f4760ac74098b9774f38c54f37db4afc4c11c7c1c01a39cb763456652622dfc
startInstanceSubscriber
public CachedModeledFramework<Instance> startInstanceSubscriber(InstanceType instanceType)
{    CachedModeledFramework<Instance> resolved = Clients.instanceClient.resolved(client, instanceType).cached();    resolved.start();    return resolved;}
6578c88373b5393730b321b33180cb0ac21e5e71c0201acd0589b72f6b0c5f53
startSubscriber
private CachedModeledFramework<T> startSubscriber(TypedModeledFramework2<T, Group, Priority> typedClient, Group group, Priority priority)
{    CachedModeledFramework<T> resolved = typedClient.resolved(client, group, priority).cached();    resolved.start();    return resolved;}
87ba949222720ebb4d393808e259a0a4cc9b221f06560b292b61750301c6d0e6
ofTypeAndPath
public static Predicate<CuratorTransactionResult> ofTypeAndPath(final OperationType type, final String forPath)
{    return new Predicate<CuratorTransactionResult>() {        @Override        public boolean apply(CuratorTransactionResult result) {            return (result.getType() == type) && result.getForPath().equals(forPath);        }    };}
c6f303c6987cf3a29d60ca357c68b194ab8621707deb01b030f8e838e1d2c952
apply
public boolean apply(CuratorTransactionResult result)
{    return (result.getType() == type) && result.getForPath().equals(forPath);}
ea2bcdd55e364012ff7e42b31235f8f0fe37b92ee99234073cb43066a2f1925a
getType
public OperationType getType()
{    return type;}
36dde42ccdb3cfb8ff156e70793def81015949b04e5b39705e933977877a3dce
getForPath
public String getForPath()
{    return forPath;}
071a6622a3b9f7291567ea44c168dfbe89d0f4da1f1fd1bd19cc104018bfa8a2
getResultPath
public String getResultPath()
{    return resultPath;}
1bfcefe4889d1ed3c273feec6a070c83c2ac5510f6f3c95da7feb89400457c98
getResultStat
public Stat getResultStat()
{    return resultStat;}
8ed5059ebb17586026d06d15b9d51bdf70703031b6e74637210f2775d539d180
getError
public int getError()
{    return error;}
ea2bcdd55e364012ff7e42b31235f8f0fe37b92ee99234073cb43066a2f1925a
getType
public OperationType getType()
{    return type;}
36dde42ccdb3cfb8ff156e70793def81015949b04e5b39705e933977877a3dce
getForPath
public String getForPath()
{    return forPath;}
e061928b565977a057ff8a6d86fe57cbf8a9d77f4650b89ecccf6a3fad75b041
getScheme
public String getScheme()
{    return scheme;}
d7e6e58cbb799e1ec9ad06c8510ef53749b84fcc2ddbe738c33d6e2dbaa54dfa
getAuth
public byte[] getAuth()
{    return auth;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "AuthInfo{" + "scheme='" + scheme + '\'' + ", auth=" + Arrays.toString(auth) + '}';}
29b53c3200b505615a8170cf76797963cefa9e2b713e83dab8453903dd1d5a19
postSafeNotify
 CompletableFuture<Void> postSafeNotify(Object monitorHolder)
{    return runSafe(() -> {        synchronized (monitorHolder) {            monitorHolder.notifyAll();        }    });}
cf558fab344ef794057daaaf3d4721487c20c3f85d09e31f5c8f20f006d4a450
builder
public static Builder builder()
{    return new Builder();}
e144e8184532c4e88f3066ef33376bef3935fb54e1e6f254a0c1b3293bb2716b
newClient
public static CuratorFramework newClient(String connectString, RetryPolicy retryPolicy)
{    return newClient(connectString, DEFAULT_SESSION_TIMEOUT_MS, DEFAULT_CONNECTION_TIMEOUT_MS, retryPolicy);}
dcf945e523c74de0cd43f798a9a141cf6f76f12d3f2e7459b700c2925080c4c9
newClient
public static CuratorFramework newClient(String connectString, int sessionTimeoutMs, int connectionTimeoutMs, RetryPolicy retryPolicy)
{    return builder().connectString(connectString).sessionTimeoutMs(sessionTimeoutMs).connectionTimeoutMs(connectionTimeoutMs).retryPolicy(retryPolicy).build();}
62a1d364d649a36dc525a74cfc307a1fb83b356afd3f8bf74ab661827616dde4
getLocalAddress
public static byte[] getLocalAddress()
{    try {        return InetAddress.getLocalHost().getHostAddress().getBytes();    } catch (UnknownHostException ignore) {        }    return new byte[0];}
fbcad33f3341425e0c38af7fdc2c61eca338dcc87a6ea25c5533cf1ea0c5f7d5
build
public CuratorFramework build()
{    return new CuratorFrameworkImpl(this);}
6d927b9cf868d582c5b50d6e2564276b17927ff0d106829b40d27da1062024a1
buildTemp
public CuratorTempFramework buildTemp()
{    return buildTemp(DEFAULT_INACTIVE_THRESHOLD_MS, TimeUnit.MILLISECONDS);}
5f4a4b3fcccd94d91bf5d77fbc7061315c3b41c19b81bf42e5b3cab918d5fb07
buildTemp
public CuratorTempFramework buildTemp(long inactiveThreshold, TimeUnit unit)
{    return new CuratorTempFrameworkImpl(this, unit.toMillis(inactiveThreshold));}
7fc0de45e6686e20a60e8a8111a3c51c044ff2cd373381ea8b43ac698e2f6e65
authorization
public Builder authorization(String scheme, byte[] auth)
{    return authorization(ImmutableList.of(new AuthInfo(scheme, (auth != null) ? Arrays.copyOf(auth, auth.length) : null)));}
cf01fab9c7f19bb6255e6b2ebd8b980b75e69f66c8080f7d1b7df7a25b11499a
authorization
public Builder authorization(List<AuthInfo> authInfos)
{    this.authInfos = ImmutableList.copyOf(authInfos);    return this;}
9df178b25ea3cd4a70682797427fd67092fc5c750877260bad57c5848278e306
connectString
public Builder connectString(String connectString)
{    ensembleProvider = new FixedEnsembleProvider(connectString);    return this;}
673808c7639be65de22434f84bbc1e37874027d39fb02917594630030900b370
ensembleProvider
public Builder ensembleProvider(EnsembleProvider ensembleProvider)
{    this.ensembleProvider = ensembleProvider;    return this;}
398eca182d5d53ef145df9b0da469a2ad61455f9634a47eb9bfa0a669c04fab9
defaultData
public Builder defaultData(byte[] defaultData)
{    this.defaultData = (defaultData != null) ? Arrays.copyOf(defaultData, defaultData.length) : null;    return this;}
7fa5780f90cd95893a5ae3163f1ca624becf0bf34f8c22e3be96d66a5c7d4c16
namespace
public Builder namespace(String namespace)
{    this.namespace = namespace;    return this;}
1dc36ba109254bb57baf1edbc9be2ee71b76e54e69dbc58252cd466178fc0c9f
sessionTimeoutMs
public Builder sessionTimeoutMs(int sessionTimeoutMs)
{    this.sessionTimeoutMs = sessionTimeoutMs;    return this;}
9659a832258929c889089aaddd2cddca9f80516f968ff25d574c3d5e9a164468
connectionTimeoutMs
public Builder connectionTimeoutMs(int connectionTimeoutMs)
{    this.connectionTimeoutMs = connectionTimeoutMs;    return this;}
b539802ae1ca221e68b1e5aaade325fe82e2c48a10db22263097369f855fdf26
maxCloseWaitMs
public Builder maxCloseWaitMs(int maxCloseWaitMs)
{    this.maxCloseWaitMs = maxCloseWaitMs;    return this;}
ce99c018c019b591d285e82270a53f427c7e6fed9b3ed7811cd8f52236d01567
retryPolicy
public Builder retryPolicy(RetryPolicy retryPolicy)
{    this.retryPolicy = retryPolicy;    return this;}
537a1b22e89f7a7e3454807b30e52b45971de78814dbd226bd24513ef52fc8e6
threadFactory
public Builder threadFactory(ThreadFactory threadFactory)
{    this.threadFactory = threadFactory;    return this;}
0d56b3ee8e09e66945d1d7a5ad76ae977587a736ed8b48a78f25b1dfb6580c83
compressionProvider
public Builder compressionProvider(CompressionProvider compressionProvider)
{    this.compressionProvider = compressionProvider;    return this;}
33d3b2f9f7622adbd50242fb88b8029fbe8e41c0f85e36fe6216ad0d8748a1e4
zookeeperFactory
public Builder zookeeperFactory(ZookeeperFactory zookeeperFactory)
{    this.zookeeperFactory = zookeeperFactory;    return this;}
284423228e3482b10e46845cd02bf33da339fc689a5e29fc5f1365fa6730ef10
aclProvider
public Builder aclProvider(ACLProvider aclProvider)
{    this.aclProvider = aclProvider;    return this;}
c06488d7ae9bfe168588cbd25b2a40a16db54d9d0f154415ca17ad925e574f1f
canBeReadOnly
public Builder canBeReadOnly(boolean canBeReadOnly)
{    this.canBeReadOnly = canBeReadOnly;    return this;}
db2a5b267dd312faecaaa41491b997d4c52756ec91fe88f9bbf792c2a368c51a
dontUseContainerParents
public Builder dontUseContainerParents()
{    this.useContainerParentsIfAvailable = false;    return this;}
a0c4aefaf6d1b7a98bd6f4a5a9733cd02ed48669f2586698e8800331731631d6
connectionStateErrorPolicy
public Builder connectionStateErrorPolicy(ConnectionStateErrorPolicy connectionStateErrorPolicy)
{    this.connectionStateErrorPolicy = connectionStateErrorPolicy;    return this;}
537d52b688a0a53e71359612c71158250707610e8666db64ff393fa135472500
zk34CompatibilityMode
public Builder zk34CompatibilityMode(boolean mode)
{    this.zk34CompatibilityMode = mode;    return this;}
763e4cb752329773d70552dcb7f3a0cc753f20ed7b27a42251971c27e9a7590b
waitForShutdownTimeoutMs
public Builder waitForShutdownTimeoutMs(int waitForShutdownTimeoutMs)
{    this.waitForShutdownTimeoutMs = waitForShutdownTimeoutMs;    return this;}
67d9c48609edaa3068019cb7b227d919eba3faeee6092d7d284b6532f00c164e
connectionHandlingPolicy
public Builder connectionHandlingPolicy(ConnectionHandlingPolicy connectionHandlingPolicy)
{    this.connectionHandlingPolicy = connectionHandlingPolicy;    return this;}
246fc7aec9c367e8c6a8954cd777d09c7be4d0d285a0dd7cd61420c0bc92c38b
schemaSet
public Builder schemaSet(SchemaSet schemaSet)
{    this.schemaSet = schemaSet;    return this;}
855d0e62f1a4293f6eb618e5c44ac0ad7cab3ab4ca1a981ab132f693a1c277a0
runSafeService
public Builder runSafeService(Executor runSafeService)
{    this.runSafeService = runSafeService;    return this;}
67947e4bd362ba76fa861fa95d5c9896611cfec2f2b012736b4be5a6dcb8a934
connectionStateListenerManagerFactory
public Builder connectionStateListenerManagerFactory(ConnectionStateListenerManagerFactory connectionStateListenerManagerFactory)
{    this.connectionStateListenerManagerFactory = Objects.requireNonNull(connectionStateListenerManagerFactory, "connectionStateListenerManagerFactory cannot be null");    return this;}
030dd0367ddeaacff4f9ed150cf80074e56d863441d4c3f17f1a813083e42afd
getRunSafeService
public Executor getRunSafeService()
{    return runSafeService;}
fd52b24fe16644fa8f22fe2ef7ed8401406b3d0bad841ae4ed434d9f40491795
getAclProvider
public ACLProvider getAclProvider()
{    return aclProvider;}
954e8185902826e65c3ccc2c4d3f316a5462456495e0d6ef19e531f831d54d3b
getZookeeperFactory
public ZookeeperFactory getZookeeperFactory()
{    return zookeeperFactory;}
78ffb0103f7b759d129a93229330c8b06d3e413c020849dc1aeb2279f9a2b2fa
getCompressionProvider
public CompressionProvider getCompressionProvider()
{    return compressionProvider;}
5a3832a64a84635c0d4e4792331f9084edae9294dd8dfae4b75976fe8839e41a
getThreadFactory
public ThreadFactory getThreadFactory()
{    return threadFactory;}
eb76bc2714f6e802d215d55ade8268b79792b61a83ddcef1d43c0c93f1d80579
getEnsembleProvider
public EnsembleProvider getEnsembleProvider()
{    return ensembleProvider;}
501660dfc9f0e914e00946f8c5b6246088d07042d31bd059b23d2803330e9a61
getSessionTimeoutMs
public int getSessionTimeoutMs()
{    return sessionTimeoutMs;}
e309d1355c8ade029bfe6bdec4e537e6e2d4e8a7ac7b91e9475a23db1906b9a6
getConnectionTimeoutMs
public int getConnectionTimeoutMs()
{    return connectionTimeoutMs;}
c72c2f607d18a536e2f1fd60e0e9200d5d9174fa25fbef4f7d416f10f626f38e
getWaitForShutdownTimeoutMs
public int getWaitForShutdownTimeoutMs()
{    return waitForShutdownTimeoutMs;}
2c8bc7120e2b9bcf7ffe15ad09df873d83727079ee67bf1adea8d174f4d3f793
getMaxCloseWaitMs
public int getMaxCloseWaitMs()
{    return maxCloseWaitMs;}
f4763efc3fd5158c17c71ee05f7be150862d258ff23fec014d9a01ae7b1409b1
getRetryPolicy
public RetryPolicy getRetryPolicy()
{    return retryPolicy;}
4c9ff74e20a72d5f7b2e4ef2a83e03a78836fed625f24259c12254b95b6af94e
getNamespace
public String getNamespace()
{    return namespace;}
fe25ca1bdd6ddd01253fd4793de5b4577e0b16a6b59f87f3ee69a699713e4530
useContainerParentsIfAvailable
public boolean useContainerParentsIfAvailable()
{    return useContainerParentsIfAvailable;}
6b42ed1019980b76bdaecac04e63aee7a71697a5961366cb386370d08268b31d
getConnectionStateErrorPolicy
public ConnectionStateErrorPolicy getConnectionStateErrorPolicy()
{    return connectionStateErrorPolicy;}
e47c3253fee26a671fe47023aaf3a2d239cbeda641fa24a6e36ea0d5432f9826
getConnectionHandlingPolicy
public ConnectionHandlingPolicy getConnectionHandlingPolicy()
{    return connectionHandlingPolicy;}
e97a91b7614d4d12daa7be7e9aabf6873e83df9fe8dc16379fe972d04122df36
getSchemaSet
public SchemaSet getSchemaSet()
{    return schemaSet;}
f597645b92818d8273294393ecf6097b7eacc1f37b71279b3efef9c95b51cdd7
isZk34CompatibilityMode
public boolean isZk34CompatibilityMode()
{    return zk34CompatibilityMode;}
5343e3901ecabbdc9f92d73bbbe4a23999a57b25ee09a3b0e57d88e9627693b0
getAuthScheme
public String getAuthScheme()
{    int qty = (authInfos != null) ? authInfos.size() : 0;    switch(qty) {        case 0:            {                return null;            }        case 1:            {                return authInfos.get(0).scheme;            }        default:            {                throw new IllegalStateException("More than 1 auth has been added");            }    }}
f008edb72cbc8f5da3af8a22296c90c4b10205db46d9561901b19eb042d5f1b1
getAuthValue
public byte[] getAuthValue()
{    int qty = (authInfos != null) ? authInfos.size() : 0;    switch(qty) {        case 0:            {                return null;            }        case 1:            {                byte[] bytes = authInfos.get(0).getAuth();                return (bytes != null) ? Arrays.copyOf(bytes, bytes.length) : null;            }        default:            {                throw new IllegalStateException("More than 1 auth has been added");            }    }}
977c3c47d53007ebfef719258f7ef7aa458024aa5936103d08477cf58be6badd
getAuthInfos
public List<AuthInfo> getAuthInfos()
{    return authInfos;}
6e76a81d7a7d1a8e6530e481030b8fe292a7798aed1a9912e7575c89522a20fa
getDefaultData
public byte[] getDefaultData()
{    return defaultData;}
725c7aedcb21ed3428a763d15ec8e73540a91ad4d73f49744cfc9281b603532f
canBeReadOnly
public boolean canBeReadOnly()
{    return canBeReadOnly;}
c82933a5fb90ef9e528ce22f3d272d78d0d2a0d180b6760f14fdc33a8c5280e9
getConnectionStateListenerManagerFactory
public ConnectionStateListenerManagerFactory getConnectionStateListenerManagerFactory()
{    return connectionStateListenerManagerFactory;}
5d1afa6597ad60a811012a18d1077ed9f884e80a0e2fb738d265cc4381dde2fb
ensure
public void ensure() throws Exception
{    if (ensureNeeded.get()) {        internalEnsure();    }}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    ensureNeeded.set(true);}
51f8d0d10d809df470bdf458616b7682ca5b6c589240ee7430a2a5241496fedd
internalEnsure
private synchronized void internalEnsure() throws Exception
{    if (ensureNeeded.compareAndSet(true, false)) {        client.createContainers(path);    }}
cca9c68c35dabd3c4af7987447e9c021232825596bbc14ba0101e5e1c79fe0d4
getACLProviderForParents
 InternalACLProvider getACLProviderForParents()
{    return applyToParents ? this : aclProvider;}
b7b4e6741197b4f263926747ba653a7ce16c6791df12c70d36d48ff75d2d92d7
getAclList
 List<ACL> getAclList(String path)
{    if (aclList != null)        return aclList;    if (path != null) {        List<ACL> localAclList = aclProvider.getAclForPath(path);        if (localAclList != null) {            return localAclList;        }    }    return aclProvider.getDefaultAcl();}
608c4250279b9160905e4962b77bc1d258c8a726d186d1875dd0e18be5e9bcbb
getDefaultAcl
public List<ACL> getDefaultAcl()
{    return aclProvider.getDefaultAcl();}
948e924ac3cf12487fcf7f5ccc3b514ae7fc4b9d602a2962739b070d41126b34
getAclForPath
public List<ACL> getAclForPath(String path)
{    return getAclList(path);}
eeecbe79ea29b55cbff70bec505332e849f6c9aad1842b53a345da46cd24efd5
inBackground
 boolean inBackground()
{    return inBackground;}
de3d0345a88bdcea1eb11d641534fa2b3646d9d4ca97ccaf03dcfea9a9332b66
getContext
 Object getContext()
{    return context;}
3486c8d8fd8de4a400ec277893382f706da1a0624965af99c58b1d882cd6dc9a
getCallback
 BackgroundCallback getCallback()
{    return callback;}
f2e03977cddeef5a31d6770afb4f249091bf15f41835c1daf39e4ef9aff68564
checkError
 void checkError(Throwable e, Watching watching) throws Exception
{    if (e != null) {        if (errorListener != null) {            errorListener.unhandledError("n/a", e);        } else if (e instanceof Exception) {            throw (Exception) e;        } else {            Throwables.propagate(e);        }    }}
58d5b0fd227ce62ceea198df6a89cf71b6cfbf12a8764514ee3f2fbf7a7ba281
wrapCallback
private static BackgroundCallback wrapCallback(final CuratorFrameworkImpl client, final BackgroundCallback callback, final Executor executor)
{    return new BackgroundCallback() {        @Override        public void processResult(CuratorFramework dummy, final CuratorEvent event) throws Exception {            executor.execute(new Runnable() {                @Override                public void run() {                    try {                        callback.processResult(client, event);                    } catch (Exception e) {                        ThreadUtils.checkInterrupted(e);                        if (e instanceof KeeperException) {                            client.validateConnection(client.codeToState(((KeeperException) e).code()));                        }                        client.logError("Background operation result handling threw exception", e);                    }                }            });        }    };}
bbfd3fb1952404e2c96e46671cf638b4824f1bd2ec2e60d51f871de1a362253c
processResult
public void processResult(CuratorFramework dummy, final CuratorEvent event) throws Exception
{    executor.execute(new Runnable() {        @Override        public void run() {            try {                callback.processResult(client, event);            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                if (e instanceof KeeperException) {                    client.validateConnection(client.codeToState(((KeeperException) e).code()));                }                client.logError("Background operation result handling threw exception", e);            }        }    });}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        callback.processResult(client, event);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        if (e instanceof KeeperException) {            client.validateConnection(client.codeToState(((KeeperException) e).code()));        }        client.logError("Background operation result handling threw exception", e);    }}
772f79cf5c4af16a3e1cf67e610e3b66d770948915f9c0cca395686aa2e4f144
performBackgroundOperation
public void performBackgroundOperation(final OperationAndData<String> operationAndData) throws Exception
{    final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("BackgroundSyncImpl");    final String data = operationAndData.getData();    client.getZooKeeper().sync(data, new AsyncCallback.VoidCallback() {        @Override        public void processResult(int rc, String path, Object ctx) {            trace.setReturnCode(rc).setRequestBytesLength(data).commit();            CuratorEventImpl event = new CuratorEventImpl(client, CuratorEventType.SYNC, rc, path, null, ctx, null, null, null, null, null, null);            client.processBackgroundOperation(operationAndData, event);        }    }, context);}
1670bb3e4673da82391867e9228b38f3d7dfc7759993e3e7748dcea2c4b95bb2
processResult
public void processResult(int rc, String path, Object ctx)
{    trace.setReturnCode(rc).setRequestBytesLength(data).commit();    CuratorEventImpl event = new CuratorEventImpl(client, CuratorEventType.SYNC, rc, path, null, ctx, null, null, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
3e2b434503789492eee47872c779a70fe3e6982cfab37afdb6ef57d4cd941199
setSetDataIfExistsVersion
public void setSetDataIfExistsVersion(int version)
{    this.setDataIfExistsVersion = version;}
0dba84b6fdd8265e8a8981f996fb418f970f149bf6e17d7e5bd12144ce26a9a8
orSetData
public CreateBuilder2 orSetData()
{    return orSetData(-1);}
b95e65fd34ac6b5aee78649833f90590868c0082b91cfb6022f7abde19643fe3
orSetData
public CreateBuilder2 orSetData(int version)
{    setDataIfExists = true;    setDataIfExistsVersion = version;    return this;}
c79e7482977ba6d6f04afedad0a60e06f548525658b3083a233503cf1b703733
withTtl
public CreateBuilderMain withTtl(long ttl)
{    Preconditions.checkState(!client.isZk34CompatibilityMode(), "TTLs are not support when running in ZooKeeper 3.4 compatibility mode");    this.ttl = ttl;    return this;}
4bf3e0c9d68fcf0f0da3518c9cb8a5ba81cc19765eda4488963a1544efb057d8
asTransactionCreateBuilder
 TransactionCreateBuilder<T> asTransactionCreateBuilder(final T context, final CuratorMultiTransactionRecord transaction)
{    return new TransactionCreateBuilder<T>() {        @Override        public PathAndBytesable<T> withACL(List<ACL> aclList) {            return withACL(aclList, false);        }        @Override        public PathAndBytesable<T> withACL(List<ACL> aclList, boolean applyToParents) {            CreateBuilderImpl.this.withACL(aclList, applyToParents);            return this;        }        @Override        public TransactionCreateBuilder2<T> withTtl(long ttl) {            CreateBuilderImpl.this.withTtl(ttl);            return this;        }        @Override        public ACLPathAndBytesable<T> withMode(CreateMode mode) {            CreateBuilderImpl.this.withMode(mode);            return this;        }        @Override        public ACLCreateModePathAndBytesable<T> compressed() {            CreateBuilderImpl.this.compressed();            return this;        }        @Override        public T forPath(String path) throws Exception {            return forPath(path, client.getDefaultData());        }        @Override        public T forPath(String path, byte[] data) throws Exception {            if (compress) {                data = client.getCompressionProvider().compress(path, data);            }            String fixedPath = client.fixForNamespace(path);            if (client.isZk34CompatibilityMode()) {                transaction.add(Op.create(fixedPath, data, acling.getAclList(path), createMode), OperationType.CREATE, path);            } else {                transaction.add(Op.create(fixedPath, data, acling.getAclList(path), createMode, ttl), OperationType.CREATE, path);            }            return context;        }    };}
c36aa69fe5c20107c1b4ddac4b343280f7090ad5f52279e39a364324e1147e18
withACL
public PathAndBytesable<T> withACL(List<ACL> aclList)
{    return withACL(aclList, false);}
cb026f28ec55ec6e9c2535dea7d772118dc5f8500f36d78dff202c4e39c4ad94
withACL
public PathAndBytesable<T> withACL(List<ACL> aclList, boolean applyToParents)
{    CreateBuilderImpl.this.withACL(aclList, applyToParents);    return this;}
f93b563b3207267b109fa7e10e60f34d4479e3280df6ec1a7e661085d74c5532
withTtl
public TransactionCreateBuilder2<T> withTtl(long ttl)
{    CreateBuilderImpl.this.withTtl(ttl);    return this;}
702bb951b6dd36596374930163474165606921501dbdf54d38f9b052400f7ca6
withMode
public ACLPathAndBytesable<T> withMode(CreateMode mode)
{    CreateBuilderImpl.this.withMode(mode);    return this;}
593a719ca3b33b732d01517bb5c869126be09fa3aa70bef928ac93088b8f4c67
compressed
public ACLCreateModePathAndBytesable<T> compressed()
{    CreateBuilderImpl.this.compressed();    return this;}
f78f8317545828af6938dc071d4101bc858a8de7ddea11ca44fff56534af53dc
forPath
public T forPath(String path) throws Exception
{    return forPath(path, client.getDefaultData());}
f4933f0a03f2288d5503baa255999eb6c8a2c0ff401e979a5403e23e66878288
forPath
public T forPath(String path, byte[] data) throws Exception
{    if (compress) {        data = client.getCompressionProvider().compress(path, data);    }    String fixedPath = client.fixForNamespace(path);    if (client.isZk34CompatibilityMode()) {        transaction.add(Op.create(fixedPath, data, acling.getAclList(path), createMode), OperationType.CREATE, path);    } else {        transaction.add(Op.create(fixedPath, data, acling.getAclList(path), createMode, ttl), OperationType.CREATE, path);    }    return context;}
e6a6640a07fff57f79a8f2c3f52bb9785501b5c6fb3a508164c9957afe6e5753
compressed
public CreateBackgroundModeStatACLable compressed()
{    compress = true;    return new CreateBackgroundModeStatACLable() {        @Override        public CreateBackgroundModeACLable storingStatIn(Stat stat) {            storingStat = stat;            return asCreateBackgroundModeACLable();        }        @Override        public ACLCreateModePathAndBytesable<String> creatingParentsIfNeeded() {            createParentsIfNeeded = true;            return asACLCreateModePathAndBytesable();        }        @Override        public ACLCreateModePathAndBytesable<String> creatingParentContainersIfNeeded() {            setCreateParentsAsContainers();            return creatingParentsIfNeeded();        }        @Override        public ACLPathAndBytesable<String> withProtectedEphemeralSequential() {            return CreateBuilderImpl.this.withProtectedEphemeralSequential();        }        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList) {            return CreateBuilderImpl.this.withACL(aclList);        }        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            return CreateBuilderImpl.this.withACL(aclList, applyToParents);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context) {            return CreateBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground() {            return CreateBuilderImpl.this.inBackground();        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(Object context) {            return CreateBuilderImpl.this.inBackground(context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback) {            return CreateBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, executor);        }        @Override        public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode) {            return CreateBuilderImpl.this.withMode(mode);        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }    };}
08a6346778c5d3155c98c83a3d7c27928578803abef9444531ea3bd8818589f5
storingStatIn
public CreateBackgroundModeACLable storingStatIn(Stat stat)
{    storingStat = stat;    return asCreateBackgroundModeACLable();}
5952212996787b07ce45c52d01dc86b698ae2d249eab959bbc988b84639529c7
creatingParentsIfNeeded
public ACLCreateModePathAndBytesable<String> creatingParentsIfNeeded()
{    createParentsIfNeeded = true;    return asACLCreateModePathAndBytesable();}
2627a715dcaf9ec5953b1490ea037d52367a30f58106d2dd52426ff26ea4d192
creatingParentContainersIfNeeded
public ACLCreateModePathAndBytesable<String> creatingParentContainersIfNeeded()
{    setCreateParentsAsContainers();    return creatingParentsIfNeeded();}
dbcb46aecbeb12bcdc22a61b4bc9accb1e873f20ea426015c337e534df805851
withProtectedEphemeralSequential
public ACLPathAndBytesable<String> withProtectedEphemeralSequential()
{    return CreateBuilderImpl.this.withProtectedEphemeralSequential();}
a0c82b8db604784ac3fa6f0b9f20619522f768da584e58c4a77335dcb7cedffc
withACL
public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList)
{    return CreateBuilderImpl.this.withACL(aclList);}
05c5f7286713214323fb1f7c1d7b6bca8d2d51b5dc6d2fe44741a98070ff31cc
withACL
public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents)
{    return CreateBuilderImpl.this.withACL(aclList, applyToParents);}
4cf8d56c5dbd0d14ea8b2299f5cea6761b49ce1e3c6d09d7bebd6094688972e9
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context)
{    return CreateBuilderImpl.this.inBackground(callback, context);}
c5a9a25809a4c0688fee82328523513a806f42a16bfdaf0da608b17c7e765e3a
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, context, executor);}
a867bd5aa3890f16996a92b2adddb956f50541f5f9f2ffa4c82cea00a2e05fc2
inBackground
public ErrorListenerPathAndBytesable<String> inBackground()
{    return CreateBuilderImpl.this.inBackground();}
2a00312520d29dc1b21fe7e9b84f1577d7d37b986e6957576d67c536a8099832
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(Object context)
{    return CreateBuilderImpl.this.inBackground(context);}
00e4799927493b1963e0d077991c9136cc5d740c14dbc707549f48a632e6066f
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback)
{    return CreateBuilderImpl.this.inBackground(callback);}
a86398b2f7cdedcc8ef06980bb1e1c42719ccf533516b0207475e84c6cf682f7
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, executor);}
4061c419bd4373867b72ce3549e9b7cb4db4fc2e09ef0d2857a6c92629bbcdca
withMode
public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode)
{    return CreateBuilderImpl.this.withMode(mode);}
22506f11c706ceedd0e70aa2e1d18c7fb6104f72eacbab33a2529c722bb04fbd
forPath
public String forPath(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
a4fd7238bd04d3cafdfc9dc21a51e76bd75dc9c77ab7fd041f0ee08462fcba8f
forPath
public String forPath(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
b356416f1cb3434e11f9b3b80409f2a0a9466a3a5e25e861b20d9f1a3d73f43f
withACL
public ACLBackgroundPathAndBytesable<String> withACL(List<ACL> aclList)
{    return withACL(aclList, false);}
31fd7c35e05f4782a030c78f9d8853f72cdbb7abb2740cbcf65964dd8f4f8384
withACL
public ACLBackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents)
{    acling = new ACLing(client.getAclProvider(), aclList, applyToParents);    return new ACLBackgroundPathAndBytesable<String>() {        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList) {            return CreateBuilderImpl.this.withACL(aclList);        }        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            return CreateBuilderImpl.this.withACL(aclList, applyToParents);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground() {            return CreateBuilderImpl.this.inBackground();        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context) {            return CreateBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(Object context) {            return CreateBuilderImpl.this.inBackground(context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback) {            return CreateBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, executor);        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }    };}
a0c82b8db604784ac3fa6f0b9f20619522f768da584e58c4a77335dcb7cedffc
withACL
public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList)
{    return CreateBuilderImpl.this.withACL(aclList);}
05c5f7286713214323fb1f7c1d7b6bca8d2d51b5dc6d2fe44741a98070ff31cc
withACL
public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents)
{    return CreateBuilderImpl.this.withACL(aclList, applyToParents);}
a867bd5aa3890f16996a92b2adddb956f50541f5f9f2ffa4c82cea00a2e05fc2
inBackground
public ErrorListenerPathAndBytesable<String> inBackground()
{    return CreateBuilderImpl.this.inBackground();}
4cf8d56c5dbd0d14ea8b2299f5cea6761b49ce1e3c6d09d7bebd6094688972e9
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context)
{    return CreateBuilderImpl.this.inBackground(callback, context);}
c5a9a25809a4c0688fee82328523513a806f42a16bfdaf0da608b17c7e765e3a
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, context, executor);}
2a00312520d29dc1b21fe7e9b84f1577d7d37b986e6957576d67c536a8099832
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(Object context)
{    return CreateBuilderImpl.this.inBackground(context);}
00e4799927493b1963e0d077991c9136cc5d740c14dbc707549f48a632e6066f
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback)
{    return CreateBuilderImpl.this.inBackground(callback);}
a86398b2f7cdedcc8ef06980bb1e1c42719ccf533516b0207475e84c6cf682f7
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, executor);}
22506f11c706ceedd0e70aa2e1d18c7fb6104f72eacbab33a2529c722bb04fbd
forPath
public String forPath(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
a4fd7238bd04d3cafdfc9dc21a51e76bd75dc9c77ab7fd041f0ee08462fcba8f
forPath
public String forPath(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
5be7b249cc4352a5154188f6429082ef536e65c58b0295809b21e03243bc6b88
creatingParentContainersIfNeeded
public ProtectACLCreateModeStatPathAndBytesable<String> creatingParentContainersIfNeeded()
{    setCreateParentsAsContainers();    return creatingParentsIfNeeded();}
7c6fde709227dccaba261e18445537a707bbc500722fe982eaf9ce0b941dd9d7
setCreateParentsAsContainers
private void setCreateParentsAsContainers()
{    if (client.useContainerParentsIfAvailable()) {        createParentsAsContainers = true;    }}
77e1fd6514ed113745ae0f4fc409cdf7a0df0584be3f2f43cb0efadc1ca71799
creatingParentsIfNeeded
public ProtectACLCreateModeStatPathAndBytesable<String> creatingParentsIfNeeded()
{    createParentsIfNeeded = true;    return new ProtectACLCreateModeStatPathAndBytesable<String>() {        @Override        public ACLCreateModeBackgroundPathAndBytesable<String> withProtection() {            return CreateBuilderImpl.this.withProtection();        }        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList) {            return withACL(aclList, false);        }        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            return CreateBuilderImpl.this.withACL(aclList, applyToParents);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground() {            return CreateBuilderImpl.this.inBackground();        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(Object context) {            return CreateBuilderImpl.this.inBackground(context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback) {            return CreateBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context) {            return CreateBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, executor);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode) {            return CreateBuilderImpl.this.withMode(mode);        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }        @Override        public ACLBackgroundPathAndBytesable<String> storingStatIn(Stat stat) {            storingStat = stat;            return CreateBuilderImpl.this;        }    };}
f3c70b9e2372655468c3325089c4382d28d85e4364de62fac83dfbdb38e0756a
withProtection
public ACLCreateModeBackgroundPathAndBytesable<String> withProtection()
{    return CreateBuilderImpl.this.withProtection();}
a0c82b8db604784ac3fa6f0b9f20619522f768da584e58c4a77335dcb7cedffc
withACL
public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList)
{    return withACL(aclList, false);}
05c5f7286713214323fb1f7c1d7b6bca8d2d51b5dc6d2fe44741a98070ff31cc
withACL
public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents)
{    return CreateBuilderImpl.this.withACL(aclList, applyToParents);}
a867bd5aa3890f16996a92b2adddb956f50541f5f9f2ffa4c82cea00a2e05fc2
inBackground
public ErrorListenerPathAndBytesable<String> inBackground()
{    return CreateBuilderImpl.this.inBackground();}
2a00312520d29dc1b21fe7e9b84f1577d7d37b986e6957576d67c536a8099832
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(Object context)
{    return CreateBuilderImpl.this.inBackground(context);}
00e4799927493b1963e0d077991c9136cc5d740c14dbc707549f48a632e6066f
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback)
{    return CreateBuilderImpl.this.inBackground(callback);}
4cf8d56c5dbd0d14ea8b2299f5cea6761b49ce1e3c6d09d7bebd6094688972e9
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context)
{    return CreateBuilderImpl.this.inBackground(callback, context);}
a86398b2f7cdedcc8ef06980bb1e1c42719ccf533516b0207475e84c6cf682f7
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, executor);}
c5a9a25809a4c0688fee82328523513a806f42a16bfdaf0da608b17c7e765e3a
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, context, executor);}
4061c419bd4373867b72ce3549e9b7cb4db4fc2e09ef0d2857a6c92629bbcdca
withMode
public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode)
{    return CreateBuilderImpl.this.withMode(mode);}
22506f11c706ceedd0e70aa2e1d18c7fb6104f72eacbab33a2529c722bb04fbd
forPath
public String forPath(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
a4fd7238bd04d3cafdfc9dc21a51e76bd75dc9c77ab7fd041f0ee08462fcba8f
forPath
public String forPath(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
04465f89297c87a287c8659c0e6b9f71b4cbbdbc3e6cfb7693df1e5ef2c3687f
storingStatIn
public ACLBackgroundPathAndBytesable<String> storingStatIn(Stat stat)
{    storingStat = stat;    return CreateBuilderImpl.this;}
bd5645bc9d2e84c78b5338a0647f87ea4952674572ea4bcd3adb9b08fe2bea26
withProtection
public ACLCreateModeStatBackgroundPathAndBytesable<String> withProtection()
{    protectedMode.setProtectedMode();    return asACLCreateModeStatBackgroundPathAndBytesable();}
dbcb46aecbeb12bcdc22a61b4bc9accb1e873f20ea426015c337e534df805851
withProtectedEphemeralSequential
public ACLPathAndBytesable<String> withProtectedEphemeralSequential()
{    protectedMode.setProtectedMode();    createMode = CreateMode.EPHEMERAL_SEQUENTIAL;    return new ACLPathAndBytesable<String>() {        @Override        public PathAndBytesable<String> withACL(List<ACL> aclList) {            return CreateBuilderImpl.this.withACL(aclList);        }        @Override        public PathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            return CreateBuilderImpl.this.withACL(aclList, applyToParents);        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }    };}
63cf34712460cefe91b32c2a751313a5ca14c489c2e55e56e97dd195d7726d1c
withACL
public PathAndBytesable<String> withACL(List<ACL> aclList)
{    return CreateBuilderImpl.this.withACL(aclList);}
9eacb235a6c621f6b722ed97bd454f741de90b5ba1ea23ba75a88744fdd0512c
withACL
public PathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents)
{    return CreateBuilderImpl.this.withACL(aclList, applyToParents);}
22506f11c706ceedd0e70aa2e1d18c7fb6104f72eacbab33a2529c722bb04fbd
forPath
public String forPath(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
a4fd7238bd04d3cafdfc9dc21a51e76bd75dc9c77ab7fd041f0ee08462fcba8f
forPath
public String forPath(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
4061c419bd4373867b72ce3549e9b7cb4db4fc2e09ef0d2857a6c92629bbcdca
withMode
public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode)
{    createMode = mode;    return this;}
4cf8d56c5dbd0d14ea8b2299f5cea6761b49ce1e3c6d09d7bebd6094688972e9
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
c5a9a25809a4c0688fee82328523513a806f42a16bfdaf0da608b17c7e765e3a
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
00e4799927493b1963e0d077991c9136cc5d740c14dbc707549f48a632e6066f
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
a86398b2f7cdedcc8ef06980bb1e1c42719ccf533516b0207475e84c6cf682f7
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
a867bd5aa3890f16996a92b2adddb956f50541f5f9f2ffa4c82cea00a2e05fc2
inBackground
public ErrorListenerPathAndBytesable<String> inBackground()
{    backgrounding = new Backgrounding(true);    return this;}
2a00312520d29dc1b21fe7e9b84f1577d7d37b986e6957576d67c536a8099832
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
e5ac51966da2f5c0fb288f35263e689d78efbaec6df74aa30f8737117d92f77a
withUnhandledErrorListener
public PathAndBytesable<String> withUnhandledErrorListener(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
a4fd7238bd04d3cafdfc9dc21a51e76bd75dc9c77ab7fd041f0ee08462fcba8f
forPath
public String forPath(String path) throws Exception
{    return forPath(path, client.getDefaultData());}
9820fb424ccfa599c60efad07978a0c3057684ae5e31806b5b207c81afbb409f
forPath
public String forPath(final String givenPath, byte[] data) throws Exception
{    if (compress) {        data = client.getCompressionProvider().compress(givenPath, data);    }    final String adjustedPath = adjustPath(client.fixForNamespace(givenPath, createMode.isSequential()));    List<ACL> aclList = acling.getAclList(adjustedPath);    client.getSchemaSet().getSchema(givenPath).validateCreate(createMode, givenPath, data, aclList);    String returnPath = null;    if (backgrounding.inBackground()) {        pathInBackground(adjustedPath, data, givenPath);    } else {        String path = protectedPathInForeground(adjustedPath, data, aclList);        returnPath = client.unfixForNamespace(path);    }    return returnPath;}
a027c16e23953b18676dcbacef1f165424d6961fb2e65096bf04d7af9c2b8335
protectedPathInForeground
private String protectedPathInForeground(String adjustedPath, byte[] data, List<ACL> aclList) throws Exception
{    try {        return pathInForeground(adjustedPath, data, aclList);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        if ((e instanceof KeeperException.ConnectionLossException || !(e instanceof KeeperException)) && protectedMode.doProtected()) {            /*                 * CURATOR-45 + CURATOR-79: we don't know if the create operation was successful or not,                 * register the znode to be sure it is deleted later.                 */            new FindAndDeleteProtectedNodeInBackground(client, ZKPaths.getPathAndNode(adjustedPath).getPath(), protectedMode.protectedId()).execute();            /*                 * The current UUID is scheduled to be deleted, it is not safe to use it again.                 * If this builder is used again later create a new UUID                 */            protectedMode.resetProtectedId();        }        throw e;    }}
8282537fcedcf8bd947cd15b06cdcaafad9692a374332747ed39e569c9d265eb
performBackgroundOperation
public void performBackgroundOperation(final OperationAndData<PathAndBytes> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("CreateBuilderImpl-Background");        final byte[] data = operationAndData.getData().getData();        final CompatibleCreateCallback mainCallback = new CompatibleCreateCallback() {            @Override            public void processResult(int rc, String path, Object ctx, String name, Stat stat) {                trace.setReturnCode(rc).setRequestBytesLength(data).setPath(path).commit();                if ((stat != null) && (storingStat != null)) {                    DataTree.copyStat(stat, storingStat);                }                if ((rc == KeeperException.Code.NONODE.intValue()) && createParentsIfNeeded) {                    backgroundCreateParentsThenNode(client, operationAndData, operationAndData.getData().getPath(), backgrounding, acling.getACLProviderForParents(), createParentsAsContainers);                } else if ((rc == KeeperException.Code.NODEEXISTS.intValue()) && setDataIfExists) {                    backgroundSetData(client, operationAndData, operationAndData.getData().getPath(), backgrounding);                } else {                    sendBackgroundResponse(rc, path, ctx, name, stat, operationAndData);                }            }        };        if (client.isZk34CompatibilityMode()) {            AsyncCallback.StringCallback stringCallback = new AsyncCallback.StringCallback() {                @Override                public void processResult(int rc, String path, Object ctx, String name) {                    mainCallback.processResult(rc, path, ctx, name, null);                }            };            client.getZooKeeper().create(operationAndData.getData().getPath(), data, acling.getAclList(operationAndData.getData().getPath()), createMode, stringCallback, backgrounding.getContext());        } else {            CreateZK35.create(client.getZooKeeper(), operationAndData.getData().getPath(), data, acling.getAclList(operationAndData.getData().getPath()), createMode, mainCallback, backgrounding.getContext(), ttl);        }    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
97f9df91d456cebbaaad7cfbb0b68cb311bb45e521a178a7293efee09c214dcb
processResult
public void processResult(int rc, String path, Object ctx, String name, Stat stat)
{    trace.setReturnCode(rc).setRequestBytesLength(data).setPath(path).commit();    if ((stat != null) && (storingStat != null)) {        DataTree.copyStat(stat, storingStat);    }    if ((rc == KeeperException.Code.NONODE.intValue()) && createParentsIfNeeded) {        backgroundCreateParentsThenNode(client, operationAndData, operationAndData.getData().getPath(), backgrounding, acling.getACLProviderForParents(), createParentsAsContainers);    } else if ((rc == KeeperException.Code.NODEEXISTS.intValue()) && setDataIfExists) {        backgroundSetData(client, operationAndData, operationAndData.getData().getPath(), backgrounding);    } else {        sendBackgroundResponse(rc, path, ctx, name, stat, operationAndData);    }}
34e22b8ba6edaa8a6f82c228ae25e7567bbfe8b452f074dd5b1b0c84d63dbad1
processResult
public void processResult(int rc, String path, Object ctx, String name)
{    mainCallback.processResult(rc, path, ctx, name, null);}
121433779e93f59e40ff9573c8b370880c2c993ee5b0bcb4cfbc1740a7b3dc8c
storingStatIn
public CreateProtectACLCreateModePathAndBytesable<String> storingStatIn(Stat stat)
{    storingStat = stat;    return new CreateProtectACLCreateModePathAndBytesable<String>() {        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList) {            return CreateBuilderImpl.this.withACL(aclList);        }        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            return CreateBuilderImpl.this.withACL(aclList, applyToParents);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground() {            return CreateBuilderImpl.this.inBackground();        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(Object context) {            return CreateBuilderImpl.this.inBackground(context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback) {            return CreateBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context) {            return CreateBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, executor);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }        @Override        public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode) {            return CreateBuilderImpl.this.withMode(mode);        }        @Override        public ACLCreateModeBackgroundPathAndBytesable<String> withProtection() {            return CreateBuilderImpl.this.withProtection();        }        @Override        public ProtectACLCreateModePathAndBytesable<String> creatingParentsIfNeeded() {            return CreateBuilderImpl.this.creatingParentsIfNeeded();        }        @Override        public ProtectACLCreateModePathAndBytesable<String> creatingParentContainersIfNeeded() {            return CreateBuilderImpl.this.creatingParentContainersIfNeeded();        }    };}
a0c82b8db604784ac3fa6f0b9f20619522f768da584e58c4a77335dcb7cedffc
withACL
public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList)
{    return CreateBuilderImpl.this.withACL(aclList);}
05c5f7286713214323fb1f7c1d7b6bca8d2d51b5dc6d2fe44741a98070ff31cc
withACL
public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents)
{    return CreateBuilderImpl.this.withACL(aclList, applyToParents);}
a867bd5aa3890f16996a92b2adddb956f50541f5f9f2ffa4c82cea00a2e05fc2
inBackground
public ErrorListenerPathAndBytesable<String> inBackground()
{    return CreateBuilderImpl.this.inBackground();}
2a00312520d29dc1b21fe7e9b84f1577d7d37b986e6957576d67c536a8099832
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(Object context)
{    return CreateBuilderImpl.this.inBackground(context);}
00e4799927493b1963e0d077991c9136cc5d740c14dbc707549f48a632e6066f
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback)
{    return CreateBuilderImpl.this.inBackground(callback);}
4cf8d56c5dbd0d14ea8b2299f5cea6761b49ce1e3c6d09d7bebd6094688972e9
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context)
{    return CreateBuilderImpl.this.inBackground(callback, context);}
a86398b2f7cdedcc8ef06980bb1e1c42719ccf533516b0207475e84c6cf682f7
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, executor);}
c5a9a25809a4c0688fee82328523513a806f42a16bfdaf0da608b17c7e765e3a
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, context, executor);}
22506f11c706ceedd0e70aa2e1d18c7fb6104f72eacbab33a2529c722bb04fbd
forPath
public String forPath(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
a4fd7238bd04d3cafdfc9dc21a51e76bd75dc9c77ab7fd041f0ee08462fcba8f
forPath
public String forPath(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
4061c419bd4373867b72ce3549e9b7cb4db4fc2e09ef0d2857a6c92629bbcdca
withMode
public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode)
{    return CreateBuilderImpl.this.withMode(mode);}
f3c70b9e2372655468c3325089c4382d28d85e4364de62fac83dfbdb38e0756a
withProtection
public ACLCreateModeBackgroundPathAndBytesable<String> withProtection()
{    return CreateBuilderImpl.this.withProtection();}
4c9c29e1096fac1e9548589a3811aee8df3a230693c8349dd856381d650f4fc9
creatingParentsIfNeeded
public ProtectACLCreateModePathAndBytesable<String> creatingParentsIfNeeded()
{    return CreateBuilderImpl.this.creatingParentsIfNeeded();}
29500684de02c1526ff696e9ae14d21e5d552a048bb9bce94ab554ab6f3dde1b
creatingParentContainersIfNeeded
public ProtectACLCreateModePathAndBytesable<String> creatingParentContainersIfNeeded()
{    return CreateBuilderImpl.this.creatingParentContainersIfNeeded();}
e4479d923e9a95293b7d78575c39e04f8e1b36e27ea1718ceacef484044d4da0
getProtectedPrefix
private static String getProtectedPrefix(String protectedId)
{    return PROTECTED_PREFIX + protectedId + "-";}
051e767ae313c2484a98285344f12e0719d70a9187c785115b410eeba28fc6dc
backgroundCreateParentsThenNode
 static void backgroundCreateParentsThenNode(final CuratorFrameworkImpl client, final OperationAndData<T> mainOperationAndData, final String path, Backgrounding backgrounding, final InternalACLProvider aclProvider, final boolean createParentsAsContainers)
{    BackgroundOperation<T> operation = new BackgroundOperation<T>() {        @Override        public void performBackgroundOperation(OperationAndData<T> dummy) throws Exception {            try {                ZKPaths.mkdirs(client.getZooKeeper(), path, false, aclProvider, createParentsAsContainers);            } catch (KeeperException e) {                if (!RetryLoop.isRetryException(e)) {                    throw e;                }                        }            client.queueOperation(mainOperationAndData);        }    };    OperationAndData<T> parentOperation = new OperationAndData<>(operation, mainOperationAndData.getData(), null, null, backgrounding.getContext(), null);    client.queueOperation(parentOperation);}
024bcf4fa526461d08cc11bd5925efc40a2ba406958e90a824407da7ea456af7
performBackgroundOperation
public void performBackgroundOperation(OperationAndData<T> dummy) throws Exception
{    try {        ZKPaths.mkdirs(client.getZooKeeper(), path, false, aclProvider, createParentsAsContainers);    } catch (KeeperException e) {        if (!RetryLoop.isRetryException(e)) {            throw e;        }        }    client.queueOperation(mainOperationAndData);}
72d94e9608e69b3310acb49b56c7de95e1749d88e562815c1ba9d667ca49d4eb
backgroundSetData
private void backgroundSetData(final CuratorFrameworkImpl client, final OperationAndData<PathAndBytes> mainOperationAndData, final String path, final Backgrounding backgrounding)
{    final AsyncCallback.StatCallback statCallback = new AsyncCallback.StatCallback() {        @Override        public void processResult(int rc, String path, Object ctx, Stat stat) {            if (rc == KeeperException.Code.NONODE.intValue()) {                                client.queueOperation(mainOperationAndData);            } else {                sendBackgroundResponse(rc, path, ctx, path, stat, mainOperationAndData);            }        }    };    BackgroundOperation<PathAndBytes> operation = new BackgroundOperation<PathAndBytes>() {        @Override        public void performBackgroundOperation(OperationAndData<PathAndBytes> op) throws Exception {            try {                client.getZooKeeper().setData(path, mainOperationAndData.getData().getData(), setDataIfExistsVersion, statCallback, backgrounding.getContext());            } catch (KeeperException e) {                        }        }    };    client.queueOperation(new OperationAndData<>(operation, null, null, null, null, null));}
1653988579fabf57097982ee8a47dff699cc3eca4f907fda182e6e272411b776
processResult
public void processResult(int rc, String path, Object ctx, Stat stat)
{    if (rc == KeeperException.Code.NONODE.intValue()) {                client.queueOperation(mainOperationAndData);    } else {        sendBackgroundResponse(rc, path, ctx, path, stat, mainOperationAndData);    }}
d319e411dfe3b5332d4d8b30425abb921c7e7e95268266c57bd4159a2e6f848b
performBackgroundOperation
public void performBackgroundOperation(OperationAndData<PathAndBytes> op) throws Exception
{    try {        client.getZooKeeper().setData(path, mainOperationAndData.getData().getData(), setDataIfExistsVersion, statCallback, backgrounding.getContext());    } catch (KeeperException e) {        }}
82000c7a03725c046245e587e073680c2b136a0eb5eb27560943ed154101680d
sendBackgroundResponse
private void sendBackgroundResponse(int rc, String path, Object ctx, String name, Stat stat, OperationAndData<PathAndBytes> operationAndData)
{    path = client.unfixForNamespace(path);    name = client.unfixForNamespace(name);    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.CREATE, rc, path, name, ctx, stat, null, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
d9f4811511c2634e738fb39a7518750303a96c1aebe6eb9c6d6e60f8883d44d0
asACLCreateModePathAndBytesable
private ACLCreateModePathAndBytesable<String> asACLCreateModePathAndBytesable()
{    return new ACLCreateModePathAndBytesable<String>() {        @Override        public PathAndBytesable<String> withACL(List<ACL> aclList) {            return CreateBuilderImpl.this.withACL(aclList);        }        @Override        public PathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            CreateBuilderImpl.this.withACL(aclList, applyToParents);            return this;        }        @Override        public ACLPathAndBytesable<String> withMode(CreateMode mode) {            createMode = mode;            return new ACLPathAndBytesable<String>() {                @Override                public PathAndBytesable<String> withACL(List<ACL> aclList) {                    return CreateBuilderImpl.this.withACL(aclList);                }                @Override                public PathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {                    return CreateBuilderImpl.this.withACL(aclList, applyToParents);                }                @Override                public String forPath(String path, byte[] data) throws Exception {                    return CreateBuilderImpl.this.forPath(path, data);                }                @Override                public String forPath(String path) throws Exception {                    return CreateBuilderImpl.this.forPath(path);                }            };        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }    };}
63cf34712460cefe91b32c2a751313a5ca14c489c2e55e56e97dd195d7726d1c
withACL
public PathAndBytesable<String> withACL(List<ACL> aclList)
{    return CreateBuilderImpl.this.withACL(aclList);}
9eacb235a6c621f6b722ed97bd454f741de90b5ba1ea23ba75a88744fdd0512c
withACL
public PathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents)
{    CreateBuilderImpl.this.withACL(aclList, applyToParents);    return this;}
a465f420fadb133353ea443a08f0957a7721f1305b988e806c93ad0dc100d2f5
withMode
public ACLPathAndBytesable<String> withMode(CreateMode mode)
{    createMode = mode;    return new ACLPathAndBytesable<String>() {        @Override        public PathAndBytesable<String> withACL(List<ACL> aclList) {            return CreateBuilderImpl.this.withACL(aclList);        }        @Override        public PathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            return CreateBuilderImpl.this.withACL(aclList, applyToParents);        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }    };}
63cf34712460cefe91b32c2a751313a5ca14c489c2e55e56e97dd195d7726d1c
withACL
public PathAndBytesable<String> withACL(List<ACL> aclList)
{    return CreateBuilderImpl.this.withACL(aclList);}
9eacb235a6c621f6b722ed97bd454f741de90b5ba1ea23ba75a88744fdd0512c
withACL
public PathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents)
{    return CreateBuilderImpl.this.withACL(aclList, applyToParents);}
22506f11c706ceedd0e70aa2e1d18c7fb6104f72eacbab33a2529c722bb04fbd
forPath
public String forPath(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
a4fd7238bd04d3cafdfc9dc21a51e76bd75dc9c77ab7fd041f0ee08462fcba8f
forPath
public String forPath(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
22506f11c706ceedd0e70aa2e1d18c7fb6104f72eacbab33a2529c722bb04fbd
forPath
public String forPath(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
a4fd7238bd04d3cafdfc9dc21a51e76bd75dc9c77ab7fd041f0ee08462fcba8f
forPath
public String forPath(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
4a4f8c963e9dc3b860749bba84c2de32c3ef494832a047e802113fa63332b161
asCreateBackgroundModeACLable
private CreateBackgroundModeACLable asCreateBackgroundModeACLable()
{    return new CreateBackgroundModeACLable() {        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList) {            return CreateBuilderImpl.this.withACL(aclList);        }        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            return CreateBuilderImpl.this.withACL(aclList, applyToParents);        }        @Override        public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode) {            return CreateBuilderImpl.this.withMode(mode);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, executor);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context) {            return CreateBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback) {            return CreateBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(Object context) {            return CreateBuilderImpl.this.inBackground(context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground() {            return CreateBuilderImpl.this.inBackground();        }        @Override        public ACLPathAndBytesable<String> withProtectedEphemeralSequential() {            return CreateBuilderImpl.this.withProtectedEphemeralSequential();        }        @Override        public ACLCreateModePathAndBytesable<String> creatingParentsIfNeeded() {            createParentsIfNeeded = true;            return asACLCreateModePathAndBytesable();        }        @Override        public ACLCreateModePathAndBytesable<String> creatingParentContainersIfNeeded() {            setCreateParentsAsContainers();            return asACLCreateModePathAndBytesable();        }    };}
a0c82b8db604784ac3fa6f0b9f20619522f768da584e58c4a77335dcb7cedffc
withACL
public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList)
{    return CreateBuilderImpl.this.withACL(aclList);}
05c5f7286713214323fb1f7c1d7b6bca8d2d51b5dc6d2fe44741a98070ff31cc
withACL
public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents)
{    return CreateBuilderImpl.this.withACL(aclList, applyToParents);}
4061c419bd4373867b72ce3549e9b7cb4db4fc2e09ef0d2857a6c92629bbcdca
withMode
public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode)
{    return CreateBuilderImpl.this.withMode(mode);}
a4fd7238bd04d3cafdfc9dc21a51e76bd75dc9c77ab7fd041f0ee08462fcba8f
forPath
public String forPath(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
22506f11c706ceedd0e70aa2e1d18c7fb6104f72eacbab33a2529c722bb04fbd
forPath
public String forPath(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
c5a9a25809a4c0688fee82328523513a806f42a16bfdaf0da608b17c7e765e3a
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, context, executor);}
a86398b2f7cdedcc8ef06980bb1e1c42719ccf533516b0207475e84c6cf682f7
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, executor);}
4cf8d56c5dbd0d14ea8b2299f5cea6761b49ce1e3c6d09d7bebd6094688972e9
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context)
{    return CreateBuilderImpl.this.inBackground(callback, context);}
00e4799927493b1963e0d077991c9136cc5d740c14dbc707549f48a632e6066f
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback)
{    return CreateBuilderImpl.this.inBackground(callback);}
2a00312520d29dc1b21fe7e9b84f1577d7d37b986e6957576d67c536a8099832
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(Object context)
{    return CreateBuilderImpl.this.inBackground(context);}
a867bd5aa3890f16996a92b2adddb956f50541f5f9f2ffa4c82cea00a2e05fc2
inBackground
public ErrorListenerPathAndBytesable<String> inBackground()
{    return CreateBuilderImpl.this.inBackground();}
dbcb46aecbeb12bcdc22a61b4bc9accb1e873f20ea426015c337e534df805851
withProtectedEphemeralSequential
public ACLPathAndBytesable<String> withProtectedEphemeralSequential()
{    return CreateBuilderImpl.this.withProtectedEphemeralSequential();}
5952212996787b07ce45c52d01dc86b698ae2d249eab959bbc988b84639529c7
creatingParentsIfNeeded
public ACLCreateModePathAndBytesable<String> creatingParentsIfNeeded()
{    createParentsIfNeeded = true;    return asACLCreateModePathAndBytesable();}
2627a715dcaf9ec5953b1490ea037d52367a30f58106d2dd52426ff26ea4d192
creatingParentContainersIfNeeded
public ACLCreateModePathAndBytesable<String> creatingParentContainersIfNeeded()
{    setCreateParentsAsContainers();    return asACLCreateModePathAndBytesable();}
4861affeaf0de34769d76f691a762903aab688f45642bebc0e8920bf2823e9d5
asACLCreateModeStatBackgroundPathAndBytesable
private ACLCreateModeStatBackgroundPathAndBytesable<String> asACLCreateModeStatBackgroundPathAndBytesable()
{    return new ACLCreateModeStatBackgroundPathAndBytesable<String>() {        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList) {            return CreateBuilderImpl.this.withACL(aclList);        }        @Override        public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents) {            CreateBuilderImpl.this.withACL(aclList, applyToParents);            return this;        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground() {            return CreateBuilderImpl.this.inBackground();        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor) {            return CreateBuilderImpl.this.inBackground(callback, executor);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context) {            return CreateBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback) {            return CreateBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerPathAndBytesable<String> inBackground(Object context) {            return CreateBuilderImpl.this.inBackground(context);        }        @Override        public String forPath(String path) throws Exception {            return CreateBuilderImpl.this.forPath(path);        }        @Override        public String forPath(String path, byte[] data) throws Exception {            return CreateBuilderImpl.this.forPath(path, data);        }        @Override        public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode) {            return CreateBuilderImpl.this.withMode(mode);        }        @Override        public ACLCreateModeBackgroundPathAndBytesable<String> storingStatIn(Stat stat) {            storingStat = stat;            return CreateBuilderImpl.this;        }    };}
a0c82b8db604784ac3fa6f0b9f20619522f768da584e58c4a77335dcb7cedffc
withACL
public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList)
{    return CreateBuilderImpl.this.withACL(aclList);}
05c5f7286713214323fb1f7c1d7b6bca8d2d51b5dc6d2fe44741a98070ff31cc
withACL
public BackgroundPathAndBytesable<String> withACL(List<ACL> aclList, boolean applyToParents)
{    CreateBuilderImpl.this.withACL(aclList, applyToParents);    return this;}
a867bd5aa3890f16996a92b2adddb956f50541f5f9f2ffa4c82cea00a2e05fc2
inBackground
public ErrorListenerPathAndBytesable<String> inBackground()
{    return CreateBuilderImpl.this.inBackground();}
c5a9a25809a4c0688fee82328523513a806f42a16bfdaf0da608b17c7e765e3a
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, context, executor);}
a86398b2f7cdedcc8ef06980bb1e1c42719ccf533516b0207475e84c6cf682f7
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Executor executor)
{    return CreateBuilderImpl.this.inBackground(callback, executor);}
4cf8d56c5dbd0d14ea8b2299f5cea6761b49ce1e3c6d09d7bebd6094688972e9
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback, Object context)
{    return CreateBuilderImpl.this.inBackground(callback, context);}
00e4799927493b1963e0d077991c9136cc5d740c14dbc707549f48a632e6066f
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(BackgroundCallback callback)
{    return CreateBuilderImpl.this.inBackground(callback);}
2a00312520d29dc1b21fe7e9b84f1577d7d37b986e6957576d67c536a8099832
inBackground
public ErrorListenerPathAndBytesable<String> inBackground(Object context)
{    return CreateBuilderImpl.this.inBackground(context);}
a4fd7238bd04d3cafdfc9dc21a51e76bd75dc9c77ab7fd041f0ee08462fcba8f
forPath
public String forPath(String path) throws Exception
{    return CreateBuilderImpl.this.forPath(path);}
22506f11c706ceedd0e70aa2e1d18c7fb6104f72eacbab33a2529c722bb04fbd
forPath
public String forPath(String path, byte[] data) throws Exception
{    return CreateBuilderImpl.this.forPath(path, data);}
4061c419bd4373867b72ce3549e9b7cb4db4fc2e09ef0d2857a6c92629bbcdca
withMode
public ACLBackgroundPathAndBytesable<String> withMode(CreateMode mode)
{    return CreateBuilderImpl.this.withMode(mode);}
3a6749a2048c3633f71dbe87385fe007f2bf798c96d4da56fa31cd3f17972c85
storingStatIn
public ACLCreateModeBackgroundPathAndBytesable<String> storingStatIn(Stat stat)
{    storingStat = stat;    return CreateBuilderImpl.this;}
00370722141c5e9f7ba604da1ea6062ed951acc5e3e8dda3eba43a4fb5e2b6a6
pathInBackground
private void pathInBackground(final String path, final byte[] data, final String givenPath)
{    final AtomicBoolean firstTime = new AtomicBoolean(true);    OperationAndData<PathAndBytes> operationAndData = new OperationAndData<PathAndBytes>(this, new PathAndBytes(path, data), backgrounding.getCallback(), new OperationAndData.ErrorCallback<PathAndBytes>() {        public void retriesExhausted(OperationAndData<PathAndBytes> operationAndData) {            if (protectedMode.doProtected()) {                                new FindAndDeleteProtectedNodeInBackground(client, ZKPaths.getPathAndNode(path).getPath(), protectedMode.protectedId()).execute();                                protectedMode.resetProtectedId();            }        }    }, backgrounding.getContext(), null) {        @Override        void callPerformBackgroundOperation() throws Exception {            boolean callSuper = true;            boolean localFirstTime = firstTime.getAndSet(false) && !debugForceFindProtectedNode;            protectedMode.checkSetSessionId(client, createMode);            if (!localFirstTime && protectedMode.doProtected()) {                debugForceFindProtectedNode = false;                String createdPath = null;                try {                    createdPath = findProtectedNodeInForeground(path);                } catch (KeeperException.ConnectionLossException e) {                    sendBackgroundResponse(KeeperException.Code.CONNECTIONLOSS.intValue(), path, backgrounding.getContext(), null, null, this);                    callSuper = false;                }                if (createdPath != null) {                    try {                        sendBackgroundResponse(KeeperException.Code.OK.intValue(), createdPath, backgrounding.getContext(), createdPath, null, this);                    } catch (Exception e) {                        ThreadUtils.checkInterrupted(e);                        client.logError("Processing protected create for path: " + givenPath, e);                    }                    callSuper = false;                }            }            if (failNextCreateForTesting) {                failNextCreateForTesting = false;                                pathInForeground(path, data, acling.getAclList(path));                throw new KeeperException.ConnectionLossException();            }            if (callSuper) {                super.callPerformBackgroundOperation();            }        }    };    client.processBackgroundOperation(operationAndData, null);}
e2902c7994d073ef500efa7a51f421e5ca00aeb61b230ac482432f7c5c031bf8
retriesExhausted
public void retriesExhausted(OperationAndData<PathAndBytes> operationAndData)
{    if (protectedMode.doProtected()) {                new FindAndDeleteProtectedNodeInBackground(client, ZKPaths.getPathAndNode(path).getPath(), protectedMode.protectedId()).execute();                protectedMode.resetProtectedId();    }}
a7ff3c805f0c9722465732ca190001bed752435a5318fad9aabff0cb08b488c3
callPerformBackgroundOperation
 void callPerformBackgroundOperation() throws Exception
{    boolean callSuper = true;    boolean localFirstTime = firstTime.getAndSet(false) && !debugForceFindProtectedNode;    protectedMode.checkSetSessionId(client, createMode);    if (!localFirstTime && protectedMode.doProtected()) {        debugForceFindProtectedNode = false;        String createdPath = null;        try {            createdPath = findProtectedNodeInForeground(path);        } catch (KeeperException.ConnectionLossException e) {            sendBackgroundResponse(KeeperException.Code.CONNECTIONLOSS.intValue(), path, backgrounding.getContext(), null, null, this);            callSuper = false;        }        if (createdPath != null) {            try {                sendBackgroundResponse(KeeperException.Code.OK.intValue(), createdPath, backgrounding.getContext(), createdPath, null, this);            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                client.logError("Processing protected create for path: " + givenPath, e);            }            callSuper = false;        }    }    if (failNextCreateForTesting) {        failNextCreateForTesting = false;                pathInForeground(path, data, acling.getAclList(path));        throw new KeeperException.ConnectionLossException();    }    if (callSuper) {        super.callPerformBackgroundOperation();    }}
d60906dd93d06c528bc038b36064349b432408d8b352ad08def80b8e3acd13bc
pathInForeground
private String pathInForeground(final String path, final byte[] data, final List<ACL> aclList) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("CreateBuilderImpl-Foreground");    final AtomicBoolean firstTime = new AtomicBoolean(true);    String returnPath = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<String>() {        @Override        public String call() throws Exception {            boolean localFirstTime = firstTime.getAndSet(false) && !debugForceFindProtectedNode;            protectedMode.checkSetSessionId(client, createMode);            String createdPath = null;            if (!localFirstTime && protectedMode.doProtected()) {                debugForceFindProtectedNode = false;                createdPath = findProtectedNodeInForeground(path);            }            if (createdPath == null) {                try {                    if (client.isZk34CompatibilityMode()) {                        createdPath = client.getZooKeeper().create(path, data, aclList, createMode);                    } else {                        createdPath = client.getZooKeeper().create(path, data, aclList, createMode, storingStat, ttl);                    }                } catch (KeeperException.NoNodeException e) {                    if (createParentsIfNeeded) {                        ZKPaths.mkdirs(client.getZooKeeper(), path, false, acling.getACLProviderForParents(), createParentsAsContainers);                        if (client.isZk34CompatibilityMode()) {                            createdPath = client.getZooKeeper().create(path, data, acling.getAclList(path), createMode);                        } else {                            createdPath = client.getZooKeeper().create(path, data, acling.getAclList(path), createMode, storingStat, ttl);                        }                    } else {                        throw e;                    }                } catch (KeeperException.NodeExistsException e) {                    if (setDataIfExists) {                        Stat setStat = client.getZooKeeper().setData(path, data, setDataIfExistsVersion);                        if (storingStat != null) {                            DataTree.copyStat(setStat, storingStat);                        }                        createdPath = path;                    } else {                        throw e;                    }                }            }            if (failNextCreateForTesting) {                failNextCreateForTesting = false;                throw new KeeperException.ConnectionLossException();            }            return createdPath;        }    });    trace.setRequestBytesLength(data).setPath(path).commit();    return returnPath;}
0de366753fb2c2ae2fa0e376bb10ccfbbff19256a8a508826be7c2384f30ac4b
call
public String call() throws Exception
{    boolean localFirstTime = firstTime.getAndSet(false) && !debugForceFindProtectedNode;    protectedMode.checkSetSessionId(client, createMode);    String createdPath = null;    if (!localFirstTime && protectedMode.doProtected()) {        debugForceFindProtectedNode = false;        createdPath = findProtectedNodeInForeground(path);    }    if (createdPath == null) {        try {            if (client.isZk34CompatibilityMode()) {                createdPath = client.getZooKeeper().create(path, data, aclList, createMode);            } else {                createdPath = client.getZooKeeper().create(path, data, aclList, createMode, storingStat, ttl);            }        } catch (KeeperException.NoNodeException e) {            if (createParentsIfNeeded) {                ZKPaths.mkdirs(client.getZooKeeper(), path, false, acling.getACLProviderForParents(), createParentsAsContainers);                if (client.isZk34CompatibilityMode()) {                    createdPath = client.getZooKeeper().create(path, data, acling.getAclList(path), createMode);                } else {                    createdPath = client.getZooKeeper().create(path, data, acling.getAclList(path), createMode, storingStat, ttl);                }            } else {                throw e;            }        } catch (KeeperException.NodeExistsException e) {            if (setDataIfExists) {                Stat setStat = client.getZooKeeper().setData(path, data, setDataIfExistsVersion);                if (storingStat != null) {                    DataTree.copyStat(setStat, storingStat);                }                createdPath = path;            } else {                throw e;            }        }    }    if (failNextCreateForTesting) {        failNextCreateForTesting = false;        throw new KeeperException.ConnectionLossException();    }    return createdPath;}
8cbe01da69c76c7957e45679b3b072ee668ccff4c5e8b987b209de64e3be65a0
findProtectedNodeInForeground
private String findProtectedNodeInForeground(final String path) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("CreateBuilderImpl-findProtectedNodeInForeground");    String returnPath = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<String>() {        @Override        public String call() throws Exception {            String foundNode = null;            try {                final ZKPaths.PathAndNode pathAndNode = ZKPaths.getPathAndNode(path);                List<String> children = client.getZooKeeper().getChildren(pathAndNode.getPath(), false);                foundNode = findNode(children, pathAndNode.getPath(), protectedMode.protectedId());                log.debug("Protected mode findNode result: {}", foundNode);                foundNode = protectedMode.validateFoundNode(client, createMode, foundNode);            } catch (KeeperException.NoNodeException ignore) {                        }            return foundNode;        }    });    trace.setPath(path).commit();    return returnPath;}
0de366753fb2c2ae2fa0e376bb10ccfbbff19256a8a508826be7c2384f30ac4b
call
public String call() throws Exception
{    String foundNode = null;    try {        final ZKPaths.PathAndNode pathAndNode = ZKPaths.getPathAndNode(path);        List<String> children = client.getZooKeeper().getChildren(pathAndNode.getPath(), false);        foundNode = findNode(children, pathAndNode.getPath(), protectedMode.protectedId());        log.debug("Protected mode findNode result: {}", foundNode);        foundNode = protectedMode.validateFoundNode(client, createMode, foundNode);    } catch (KeeperException.NoNodeException ignore) {        }    return foundNode;}
c73de54291241df50747abccdedecfdef885c0aeb49a297206bb6880c7afb792
adjustPath
 String adjustPath(String path) throws Exception
{    if (protectedMode.doProtected()) {        ZKPaths.PathAndNode pathAndNode = ZKPaths.getPathAndNode(path);        String name = getProtectedPrefix(protectedMode.protectedId()) + pathAndNode.getNode();        path = ZKPaths.makePath(pathAndNode.getPath(), name);    }    return path;}
88832656485cd82ea28507648e435640b589444890ed4ebdd74a632d4d9d209c
findNode
 static String findNode(final List<String> children, final String path, final String protectedId)
{    final String protectedPrefix = getProtectedPrefix(protectedId);    String foundNode = Iterables.find(children, new Predicate<String>() {        @Override        public boolean apply(String node) {            return node.startsWith(protectedPrefix);        }    }, null);    if (foundNode != null) {        foundNode = ZKPaths.makePath(path, foundNode);    }    return foundNode;}
4fdd4d370c58e169c3d863658606249773c8a66af4a7b4876208471bafca88bd
apply
public boolean apply(String node)
{    return node.startsWith(protectedPrefix);}
dc3ccd09971f3f4b4240db028966cc2ac90b1deecc1d73aa27598f7ab3c62785
create
 static void create(ZooKeeper zooKeeper, String path, byte[] data, List<ACL> acl, CreateMode createMode, final CompatibleCreateCallback compatibleCallback, Object ctx, long ttl)
{    AsyncCallback.Create2Callback callback = new AsyncCallback.Create2Callback() {        @Override        public void processResult(int rc, String path, Object ctx, String name, Stat stat) {            compatibleCallback.processResult(rc, path, ctx, name, stat);        }    };    zooKeeper.create(path, data, acl, createMode, callback, ctx, ttl);}
97f9df91d456cebbaaad7cfbb0b68cb311bb45e521a178a7293efee09c214dcb
processResult
public void processResult(int rc, String path, Object ctx, String name, Stat stat)
{    compatibleCallback.processResult(rc, path, ctx, name, stat);}
29de7eac4bf67f8ae72ae2cc0a0628d9970360854c36ad8dea63197ee0e43f5a
getType
public CuratorEventType getType()
{    return type;}
1815a388de041505b9c6e2900403465e5b871bdd0b49e182d76bbe1380d9d203
getResultCode
public int getResultCode()
{    return resultCode;}
58e7b527ecd5014eaf5f30fc9c50ba33e1f005f8ce9d24246253d62377788662
getPath
public String getPath()
{    return path;}
2a262ec064f8492640d0ce221dea19835c968f44bd4571de0f85f161cb2a8b20
getContext
public Object getContext()
{    return context;}
caeb2b7d846f9588cde9a2efecc0ed94309a4fcf52121d0b14624bbd6216398b
getStat
public Stat getStat()
{    return stat;}
812b8f717be4a6f9c7add1b71268ba7fe7ce1b799031309a1709dc43be1dd152
getData
public byte[] getData()
{    return data;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
f9a07229383743359732fe042350b4fce5dce7729a470b5778b4b95d5c46a97a
getChildren
public List<String> getChildren()
{    return children;}
f1dd1e0a1b0a3a7895a1b6ccae15e3bbd9f93a5f65ab747d999e035322b3899c
getWatchedEvent
public WatchedEvent getWatchedEvent()
{    return watchedEvent;}
a39eaafd15e9af1578b99274536710ee498ae2f107040e4d2d07089daff4b611
getACLList
public List<ACL> getACLList()
{    return aclList;}
4d55a88cf198ff2ace0639a62aab96c7326cba2b890d37a72958168f64cb2709
getOpResults
public List<CuratorTransactionResult> getOpResults()
{    return opResults;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "CuratorEventImpl{" + "type=" + type + ", resultCode=" + resultCode + ", path='" + path + '\'' + ", name='" + name + '\'' + ", children=" + children + ", context=" + context + ", stat=" + stat + ", data=" + Arrays.toString(data) + ", watchedEvent=" + watchedEvent + ", aclList=" + aclList + ", opResults=" + opResults + '}';}
baed48b30cc86e492e1107c8f82a0d9c0ceaebc860e184f845c86f3a20dacb62
process
public void process(WatchedEvent watchedEvent)
{    CuratorEvent event = new CuratorEventImpl(CuratorFrameworkImpl.this, CuratorEventType.WATCHED, watchedEvent.getState().getIntValue(), unfixForNamespace(watchedEvent.getPath()), null, null, null, null, null, watchedEvent, null, null);    processEvent(event);}
4a9c88e32d4e156b447974ed2a077cb4b1b5afdbcd62fdb3eca1a6154ae9cc94
makeRunSafeService
private Executor makeRunSafeService(CuratorFrameworkFactory.Builder builder)
{    if (builder.getRunSafeService() != null) {        return builder.getRunSafeService();    }    ThreadFactory threadFactory = builder.getThreadFactory();    if (threadFactory == null) {        threadFactory = ThreadUtils.newThreadFactory("SafeNotifyService");    }    return Executors.newSingleThreadExecutor(threadFactory);}
f2d57e26251985822f7f8ced32b6a2df7ed8147a885a4fd9c725fb71d612da6b
buildAuths
private List<AuthInfo> buildAuths(CuratorFrameworkFactory.Builder builder)
{    ImmutableList.Builder<AuthInfo> builder1 = ImmutableList.builder();    if (builder.getAuthInfos() != null) {        builder1.addAll(builder.getAuthInfos());    }    return builder1.build();}
cea6ebbc4555e6b30bee80e4bcd4b0cc1f7c9cdedcc03be84f82406ec22a5578
runSafe
public CompletableFuture<Void> runSafe(Runnable runnable)
{    return CompletableFuture.runAsync(runnable, runSafeService);}
f8b6601fa685dd0045251e30b36f1e3f9ab403edd0efdc23a7988ff985ac7e57
newWatcherRemoveCuratorFramework
public WatcherRemoveCuratorFramework newWatcherRemoveCuratorFramework()
{    return new WatcherRemovalFacade(this);}
d88879d077a02cb000a6bf5e2e8edd6a45c0285b57f499cf90cc94e2bcd1cf16
getCurrentConfig
public QuorumVerifier getCurrentConfig()
{    return (ensembleTracker != null) ? ensembleTracker.getCurrentConfig() : null;}
8c080bf9ccf46f2d4c2277ecdca5462945d12dec10fbc2e1341563d1b9de90c6
makeZookeeperFactory
private ZookeeperFactory makeZookeeperFactory(final ZookeeperFactory actualZookeeperFactory)
{    return new ZookeeperFactory() {        @Override        public ZooKeeper newZooKeeper(String connectString, int sessionTimeout, Watcher watcher, boolean canBeReadOnly) throws Exception {            ZooKeeper zooKeeper = actualZookeeperFactory.newZooKeeper(connectString, sessionTimeout, watcher, canBeReadOnly);            for (AuthInfo auth : authInfos) {                zooKeeper.addAuthInfo(auth.getScheme(), auth.getAuth());            }            return zooKeeper;        }    };}
f4d92d44b671cd2ac427f23e0663369999581e3a6fcae562b24eb91de6c19622
newZooKeeper
public ZooKeeper newZooKeeper(String connectString, int sessionTimeout, Watcher watcher, boolean canBeReadOnly) throws Exception
{    ZooKeeper zooKeeper = actualZookeeperFactory.newZooKeeper(connectString, sessionTimeout, watcher, canBeReadOnly);    for (AuthInfo auth : authInfos) {        zooKeeper.addAuthInfo(auth.getScheme(), auth.getAuth());    }    return zooKeeper;}
f2e31b397eaec85048cc899cf0f3869eaef86e32e750e428cdc0100fe382ea45
getThreadFactory
private ThreadFactory getThreadFactory(CuratorFrameworkFactory.Builder builder)
{    ThreadFactory threadFactory = builder.getThreadFactory();    if (threadFactory == null) {        threadFactory = ThreadUtils.newThreadFactory("Framework");    }    return threadFactory;}
f3bb819bed8c08d10098c0ed2713076b3f3ff65414c57ac7e5a5675def7e870e
createContainers
public void createContainers(String path) throws Exception
{    checkExists().creatingParentContainersIfNeeded().forPath(ZKPaths.makePath(path, "foo"));}
db048c870821a465f922b0ab0f2ff2710f8dc3a830ef7868a02f4ea54e5bf8d7
clearWatcherReferences
public void clearWatcherReferences(Watcher watcher)
{}
11308a053676b3cb218861f5abaf10a1197db763f31bdb12edea5db95bb69f3a
getState
public CuratorFrameworkState getState()
{    return state.get();}
5c30d636d0c8b1febcea468cf0149466c576f16ad782e77e5e7abb20b02a12ea
isStarted
public boolean isStarted()
{    return state.get() == CuratorFrameworkState.STARTED;}
d5fcb08fe2b843802a607b105b532c1918c445753d71073beef19d19734ae972
blockUntilConnected
public boolean blockUntilConnected(int maxWaitTime, TimeUnit units) throws InterruptedException
{    return connectionStateManager.blockUntilConnected(maxWaitTime, units);}
d7938cbe3bde1de4f8927057deefc74d042a1b48a8fbc0cab509544e608e875a
blockUntilConnected
public void blockUntilConnected() throws InterruptedException
{    blockUntilConnected(0, null);}
6b42ed1019980b76bdaecac04e63aee7a71697a5961366cb386370d08268b31d
getConnectionStateErrorPolicy
public ConnectionStateErrorPolicy getConnectionStateErrorPolicy()
{    return connectionStateErrorPolicy;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    log.info("Starting");    if (!state.compareAndSet(CuratorFrameworkState.LATENT, CuratorFrameworkState.STARTED)) {        throw new IllegalStateException("Cannot be started more than once");    }    try {                connectionStateManager.start();        final ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (ConnectionState.CONNECTED == newState || ConnectionState.RECONNECTED == newState) {                    logAsErrorConnectionErrors.set(true);                }            }            @Override            public boolean doNotProxy() {                return true;            }        };        this.getConnectionStateListenable().addListener(listener);        client.start();        executorService = Executors.newSingleThreadScheduledExecutor(threadFactory);        executorService.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                backgroundOperationsLoop();                return null;            }        });        if (ensembleTracker != null) {            ensembleTracker.start();        }        log.info(schemaSet.toDocumentation());    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleBackgroundOperationException(null, e);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (ConnectionState.CONNECTED == newState || ConnectionState.RECONNECTED == newState) {        logAsErrorConnectionErrors.set(true);    }}
052fb1fa9dd744184daf95bc1b6fa794f18fa4939ad19b228ea3af7ce10e066f
doNotProxy
public boolean doNotProxy()
{    return true;}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    backgroundOperationsLoop();    return null;}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    log.debug("Closing");    if (state.compareAndSet(CuratorFrameworkState.STARTED, CuratorFrameworkState.STOPPED)) {        listeners.forEach(new Function<CuratorListener, Void>() {            @Override            public Void apply(CuratorListener listener) {                CuratorEvent event = new CuratorEventImpl(CuratorFrameworkImpl.this, CuratorEventType.CLOSING, 0, null, null, null, null, null, null, null, null, null);                try {                    listener.eventReceived(CuratorFrameworkImpl.this, event);                } catch (Exception e) {                    ThreadUtils.checkInterrupted(e);                    log.error("Exception while sending Closing event", e);                }                return null;            }        });        if (executorService != null) {            executorService.shutdownNow();            try {                executorService.awaitTermination(maxCloseWaitMs, TimeUnit.MILLISECONDS);            } catch (InterruptedException e) {                                Thread.currentThread().interrupt();            }        }        if (ensembleTracker != null) {            ensembleTracker.close();        }        listeners.clear();        unhandledErrorListeners.clear();        connectionStateManager.close();        client.close();    }}
75a82c75829578f5bdf11605706f91426252061dff7f289a398a56211f3f7693
apply
public Void apply(CuratorListener listener)
{    CuratorEvent event = new CuratorEventImpl(CuratorFrameworkImpl.this, CuratorEventType.CLOSING, 0, null, null, null, null, null, null, null, null, null);    try {        listener.eventReceived(CuratorFrameworkImpl.this, event);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        log.error("Exception while sending Closing event", e);    }    return null;}
411c752dd6216d607d8e41e08f5e5dac702f4a22b060d3c4efc7c0b9a31bf3bf
nonNamespaceView
public CuratorFramework nonNamespaceView()
{    return usingNamespace(null);}
4c9ff74e20a72d5f7b2e4ef2a83e03a78836fed625f24259c12254b95b6af94e
getNamespace
public String getNamespace()
{    String str = namespace.getNamespace();    return (str != null) ? str : "";}
bbd07edb07bcaa4ad6d86d40eb0cc3933879ab967f81cc6b9b76559770a3d596
checkState
private void checkState()
{    CuratorFrameworkState state = getState();    Preconditions.checkState(state == CuratorFrameworkState.STARTED, "Expected state [%s] was [%s]", CuratorFrameworkState.STARTED, state);}
a20a1c4db3f9eb8e0d93485fdc63395cbf99a245461e6cb67abf55a83545c791
usingNamespace
public CuratorFramework usingNamespace(String newNamespace)
{    checkState();    return namespaceFacadeCache.get(newNamespace);}
7b02f651cf1088bf61735232efbd540c60b05d9aea503761fb0bab420da03053
create
public CreateBuilder create()
{    checkState();    return new CreateBuilderImpl(this);}
3e2197e400fcde25f9bf51f9ebc0ed027558775881a828ac2f30000950febe56
delete
public DeleteBuilder delete()
{    checkState();    return new DeleteBuilderImpl(this);}
5095a04d6a020f7f831aa7c7146ebd11c66a8f1a185e05c4ec6879ada2b60cc2
checkExists
public ExistsBuilder checkExists()
{    checkState();    return new ExistsBuilderImpl(this);}
d1a1905891b89d67dcad260fe372a3dde0c7a02fb724c64be8c2a64311e31456
getData
public GetDataBuilder getData()
{    checkState();    return new GetDataBuilderImpl(this);}
f8f48482f15147417c642ad5b8e6d08b805252fd00517767c2261321750e7a34
setData
public SetDataBuilder setData()
{    checkState();    return new SetDataBuilderImpl(this);}
06b8e936fcc2128ac84ad8e927fd30c77539d0c4ddaa36efd02da00cefd9814b
getChildren
public GetChildrenBuilder getChildren()
{    checkState();    return new GetChildrenBuilderImpl(this);}
191a4aab3893de5b647feaf187779540571f0b34849e4042645b42cea59467b5
getACL
public GetACLBuilder getACL()
{    checkState();    return new GetACLBuilderImpl(this);}
a242400d2e06ecad2d23c6d087d6489280268f028f20edce5ee4cb885b64ff6d
setACL
public SetACLBuilder setACL()
{    checkState();    return new SetACLBuilderImpl(this);}
60b25615a517adc81e4674fe56064b00d3b4b9a3b1288854cb790f7b3be2e250
reconfig
public ReconfigBuilder reconfig()
{    Preconditions.checkState(!isZk34CompatibilityMode(), "reconfig/config APIs are not support when running in ZooKeeper 3.4 compatibility mode");    return new ReconfigBuilderImpl(this);}
d250fecc958cdf4e4d07a9e32bb083318e621e2961a7538a1e60e1cd61280973
getConfig
public GetConfigBuilder getConfig()
{    Preconditions.checkState(!isZk34CompatibilityMode(), "reconfig/config APIs are not support when running in ZooKeeper 3.4 compatibility mode");    return new GetConfigBuilderImpl(this);}
e13965198942eab6d7fba8483e31125b848d3b7bdcfc3feb84cfbafc57bd7838
inTransaction
public CuratorTransaction inTransaction()
{    checkState();    return new CuratorTransactionImpl(this);}
c90a90bffe9148f922de28ec2d72f3e685d7eb7dc455eb1f9b7ad47769fe6ff3
transaction
public CuratorMultiTransaction transaction()
{    checkState();    return new CuratorMultiTransactionImpl(this);}
d5a6b31ac0c2354f39fe3e81b94c6679aeeef2c2d80305166eb1e42ad21c716a
transactionOp
public TransactionOp transactionOp()
{    checkState();    return new TransactionOpImpl(this);}
e13808d604e8405be03413186c4b9e1c036656eb1d7fdefea0574a05483395d0
getConnectionStateListenable
public Listenable<ConnectionStateListener> getConnectionStateListenable()
{    return connectionStateManager.getListenable();}
dcaa652392e0c28ee05a36caa484c21329a1a09da88222252de7c461a9964230
getCuratorListenable
public Listenable<CuratorListener> getCuratorListenable()
{    return listeners;}
b3d8c32fff49d6f84e3a03fa63c3aa3356dba76f0989aaae6638b46c12e3fdb0
getUnhandledErrorListenable
public Listenable<UnhandledErrorListener> getUnhandledErrorListenable()
{    return unhandledErrorListeners;}
89fa8cee5a80c3c832aa26455ab863bb32958b9ff2d86ec97d576ef4958933df
sync
public void sync(String path, Object context)
{    checkState();    path = fixForNamespace(path);    internalSync(this, path, context);}
45b60fc392b7c22a5891741a30405bc26dbafce051c909dcbf767683eda23964
sync
public SyncBuilder sync()
{    return new SyncBuilderImpl(this);}
54d62e3a278df70f27f70839680a565cfcf985e714c265508072a0d5d91b6366
watches
public RemoveWatchesBuilder watches()
{    Preconditions.checkState(!isZk34CompatibilityMode(), "Remove watches APIs are not support when running in ZooKeeper 3.4 compatibility mode");    return new RemoveWatchesBuilderImpl(this);}
70dc1b47b3bf3291163086541fb016dd40b8d8f9951135dd2c83a5f90ea9c396
internalSync
protected void internalSync(CuratorFrameworkImpl impl, String path, Object context)
{    BackgroundOperation<String> operation = new BackgroundSyncImpl(impl, context);    performBackgroundOperation(new OperationAndData<String>(operation, path, null, null, context, null));}
1d6b70d040ccf31742e2278edbc6eab66dfccd1c6a0761b8b0eef130170256d1
getZookeeperClient
public CuratorZookeeperClient getZookeeperClient()
{    return client;}
1a15c389a2462368adce86012e6c68b530da2423eeed3e402f3d953e8442abc3
newNamespaceAwareEnsurePath
public EnsurePath newNamespaceAwareEnsurePath(String path)
{    return namespace.newNamespaceAwareEnsurePath(path);}
e97a91b7614d4d12daa7be7e9aabf6873e83df9fe8dc16379fe972d04122df36
getSchemaSet
public SchemaSet getSchemaSet()
{    return schemaSet;}
289d2f75d88fd9e8855f89cf1d64dcc7bd5991ed30200c9f8b0c86637c7f972f
getAclProvider
 ACLProvider getAclProvider()
{    return aclProvider;}
ebaaa6145951e4ae92905d3aae1c3de253d75f64dcf0a84a35bd373a8aa2dca1
getFailedDeleteManager
 FailedDeleteManager getFailedDeleteManager()
{    return failedDeleteManager;}
01dc5b685fd81dcc1514ab00597a9a31320c68215451cbc5386010c009ec394c
getFailedRemoveWatcherManager
 FailedRemoveWatchManager getFailedRemoveWatcherManager()
{    return failedRemoveWatcherManager;}
faa4514c18ba98064e265893a20e8e9ebf226051659272f3f597d33539ec9913
newRetryLoop
 RetryLoop newRetryLoop()
{    return client.newRetryLoop();}
f0891f7aab88f7cc4a33be47483c9249645409f0730f2bb08db5362769b1e641
getZooKeeper
 ZooKeeper getZooKeeper() throws Exception
{    return client.getZooKeeper();}
d4139661d16d18a2f7aaa72dcfa18a9193b807d1b22599221fe24f4baaa49658
getCompressionProvider
 CompressionProvider getCompressionProvider()
{    return compressionProvider;}
0b3311e0531006dfb6d3050d076d11231edd57f44323f0001cef26a399ee742a
useContainerParentsIfAvailable
 boolean useContainerParentsIfAvailable()
{    return useContainerParentsIfAvailable;}
df03d11e4a696d15f707f9e0394cc5b23269c61fcd4637dfadd091ad90b2dee2
processBackgroundOperation
 void processBackgroundOperation(OperationAndData<DATA_TYPE> operationAndData, CuratorEvent event)
{    boolean isInitialExecution = (event == null);    if (isInitialExecution) {        performBackgroundOperation(operationAndData);        return;    }    boolean doQueueOperation = false;    do {        if (RetryLoop.shouldRetry(event.getResultCode())) {            doQueueOperation = checkBackgroundRetry(operationAndData, event);            break;        }        if (operationAndData.getCallback() != null) {            sendToBackgroundCallback(operationAndData, event);            break;        }        processEvent(event);    } while (false);    if (doQueueOperation) {        queueOperation(operationAndData);    }}
53974b07cae19669193634f7b36245e29c9340c3933c9dd41db25a641a56abbe
queueOperation
 boolean queueOperation(OperationAndData<DATA_TYPE> operationAndData)
{    if (getState() == CuratorFrameworkState.STARTED) {        backgroundOperations.offer(operationAndData);        return true;    }    return false;}
337b01f1f21cc95504a22cb56b43c009c03f25f27deabbc1fea3158a3197c84c
logError
 void logError(String reason, final Throwable e)
{    if ((reason == null) || (reason.length() == 0)) {        reason = "n/a";    }    if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES) || !(e instanceof KeeperException)) {        if (e instanceof KeeperException.ConnectionLossException) {            if (LOG_ALL_CONNECTION_ISSUES_AS_ERROR_LEVEL || logAsErrorConnectionErrors.compareAndSet(true, false)) {                log.error(reason, e);            } else {                log.debug(reason, e);            }        } else {            log.error(reason, e);        }    }    final String localReason = reason;    unhandledErrorListeners.forEach(new Function<UnhandledErrorListener, Void>() {        @Override        public Void apply(UnhandledErrorListener listener) {            listener.unhandledError(localReason, e);            return null;        }    });    if (debugUnhandledErrorListener != null) {        debugUnhandledErrorListener.unhandledError(reason, e);    }}
35bf1c3292901c360d30d3d51fb60adad56e49953b606718329eb66af1fef60f
apply
public Void apply(UnhandledErrorListener listener)
{    listener.unhandledError(localReason, e);    return null;}
ec4e3ff02955c9ca8410bea65fe8ddcaa62e279f69bcff6e392341925f5a4dfb
unfixForNamespace
 String unfixForNamespace(String path)
{    return namespace.unfixForNamespace(path);}
1c998b5f31649a92e51dff1bc4186c8b9c281827723b902c76057701438d645c
fixForNamespace
 String fixForNamespace(String path)
{    return namespace.fixForNamespace(path, false);}
b43f3db7d08c9ce08b475c2334e8d41779026595caf40ca66256252b64c14ee2
fixForNamespace
 String fixForNamespace(String path, boolean isSequential)
{    return namespace.fixForNamespace(path, isSequential);}
8c288e8ef1e79e329d67ba9b886142d2681359dcded448006fa28a140754572d
getDefaultData
 byte[] getDefaultData()
{    return defaultData;}
ec58725b4b960d427983482a5838479924dc6b0f6b7ab0c80543aa01099b652b
getNamespaceFacadeCache
 NamespaceFacadeCache getNamespaceFacadeCache()
{    return namespaceFacadeCache;}
6cd8a692bafaa262b551d0d090428931aa8eadaae3d3b82ceae2e9eecdbd7cbd
validateConnection
 void validateConnection(Watcher.Event.KeeperState state)
{    if (state == Watcher.Event.KeeperState.Disconnected) {        internalConnectionHandler.suspendConnection(this);    } else if (state == Watcher.Event.KeeperState.Expired) {        connectionStateManager.addStateChange(ConnectionState.LOST);    } else if (state == Watcher.Event.KeeperState.SyncConnected) {        internalConnectionHandler.checkNewConnection(this);        connectionStateManager.addStateChange(ConnectionState.RECONNECTED);        unSleepBackgroundOperations();    } else if (state == Watcher.Event.KeeperState.ConnectedReadOnly) {        internalConnectionHandler.checkNewConnection(this);        connectionStateManager.addStateChange(ConnectionState.READ_ONLY);    }}
bf58addaa87f1bc5e429e84abcf93ab6f07bbbf4b2f5e9451f7a6408647b4a55
checkInstanceIndex
 void checkInstanceIndex()
{    long instanceIndex = client.getInstanceIndex();    long newInstanceIndex = currentInstanceIndex.getAndSet(instanceIndex);    if (    (newInstanceIndex >= 0) && (instanceIndex != newInstanceIndex)) {        connectionStateManager.addStateChange(ConnectionState.LOST);    }}
330629285fb7e12d7e1a57d7b5ff010a90931a6f799c720199a3fd6e7008022f
codeToState
 Watcher.Event.KeeperState codeToState(KeeperException.Code code)
{    switch(code) {        case AUTHFAILED:        case NOAUTH:            {                return Watcher.Event.KeeperState.AuthFailed;            }        case CONNECTIONLOSS:        case OPERATIONTIMEOUT:            {                return Watcher.Event.KeeperState.Disconnected;            }        case SESSIONEXPIRED:            {                return Watcher.Event.KeeperState.Expired;            }        case OK:        case SESSIONMOVED:            {                return Watcher.Event.KeeperState.SyncConnected;            }    }    return Watcher.Event.KeeperState.fromInt(-1);}
98f4b5efbfeeca4978ae8d80827f83ec7d4ee9688cbc84319cd27918750df93c
getWatcherRemovalManager
 WatcherRemovalManager getWatcherRemovalManager()
{    return null;}
fd89b7324c3de5af00b522ea3545d6234c8404ae244afb9e251d11cc322d87c7
setToSuspended
 boolean setToSuspended()
{    return connectionStateManager.setToSuspended();}
cd3f816527f0b313f1d2f1f387f9ef6bb0c9967ae97f5198e9627b828f04da01
addStateChange
 void addStateChange(ConnectionState newConnectionState)
{    connectionStateManager.addStateChange(newConnectionState);}
f597645b92818d8273294393ecf6097b7eacc1f37b71279b3efef9c95b51cdd7
isZk34CompatibilityMode
public boolean isZk34CompatibilityMode()
{    return zk34CompatibilityMode;}
176ba4719a83c86698e66968df84339e21e0133c6086ae17a9dd39083442173a
getEnsembleTracker
 EnsembleTracker getEnsembleTracker()
{    return ensembleTracker;}
9915cbd366f7f2ce4cb1e9bf3aa851e470e7b735e4d120ca326db6d26e310846
checkBackgroundRetry
private boolean checkBackgroundRetry(OperationAndData<DATA_TYPE> operationAndData, CuratorEvent event)
{    boolean doRetry = false;    if (client.getRetryPolicy().allowRetry(operationAndData.getThenIncrementRetryCount(), operationAndData.getElapsedTimeMs(), operationAndData)) {        doRetry = true;    } else {        if (operationAndData.getErrorCallback() != null) {            operationAndData.getErrorCallback().retriesExhausted(operationAndData);        }        if (operationAndData.getCallback() != null) {            sendToBackgroundCallback(operationAndData, event);        }        KeeperException.Code code = KeeperException.Code.get(event.getResultCode());        Exception e = null;        try {            e = (code != null) ? KeeperException.create(code) : null;        } catch (Throwable t) {            ThreadUtils.checkInterrupted(t);        }        if (e == null) {            e = new Exception("Unknown result codegetResultCode()");        }        validateConnection(codeToState(code));        logError("Background operation retry gave up", e);    }    return doRetry;}
93b6cb65c52cc0f253c8d970e5070a93988c439f63cda3c7337dc17f8c28ec35
sendToBackgroundCallback
private void sendToBackgroundCallback(OperationAndData<DATA_TYPE> operationAndData, CuratorEvent event)
{    try {        operationAndData.getCallback().processResult(this, event);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleBackgroundOperationException(operationAndData, e);    }}
ac4e8f27d9cf4ee895cfe8f03bab283404ffdf289dfec4ff0d96247cb2e31396
handleBackgroundOperationException
private void handleBackgroundOperationException(OperationAndData<DATA_TYPE> operationAndData, Throwable e)
{    do {        if ((operationAndData != null) && RetryLoop.isRetryException(e)) {            if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES)) {                log.debug("Retry-able exception received", e);            }            if (client.getRetryPolicy().allowRetry(operationAndData.getThenIncrementRetryCount(), operationAndData.getElapsedTimeMs(), operationAndData)) {                if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES)) {                    log.debug("Retrying operation");                }                backgroundOperations.offer(operationAndData);                break;            } else {                if (!Boolean.getBoolean(DebugUtils.PROPERTY_DONT_LOG_CONNECTION_ISSUES)) {                    log.debug("Retry policy did not allow retry");                }                if (operationAndData.getErrorCallback() != null) {                    operationAndData.getErrorCallback().retriesExhausted(operationAndData);                }            }        }        logError("Background exception was not retry-able or retry gave up", e);    } while (false);}
8f89dae9444d1cb4599ecefd197b457a9a9bb0094f2c5b393f4bd9b57d427f78
backgroundOperationsLoop
private void backgroundOperationsLoop()
{    try {        while (state.get() == CuratorFrameworkState.STARTED) {            OperationAndData<?> operationAndData;            try {                operationAndData = backgroundOperations.take();                if (debugListener != null) {                    debugListener.listen(operationAndData);                }                performBackgroundOperation(operationAndData);            } catch (InterruptedException e) {                                                }        }    } finally {        log.info("backgroundOperationsLoop exiting");    }}
f76d5d2d7d75b48813715a24e1d28850908e1f6375f153463fef0c2f00d0b5d6
performBackgroundOperation
 void performBackgroundOperation(OperationAndData<?> operationAndData)
{    try {        if (!operationAndData.isConnectionRequired() || client.isConnected()) {            operationAndData.callPerformBackgroundOperation();        } else {                        client.getZooKeeper();            if (operationAndData.getElapsedTimeMs() >= client.getConnectionTimeoutMs()) {                throw new CuratorConnectionLossException();            }            sleepAndQueueOperation(operationAndData);        }    } catch (Throwable e) {        ThreadUtils.checkInterrupted(e);        /**         * Fix edge case reported as CURATOR-52. ConnectionState.checkTimeouts() throws KeeperException.ConnectionLossException         * when the initial (or previously failed) connection cannot be re-established. This needs to be run through the retry policy         * and callbacks need to get invoked, etc.         */        if (e instanceof CuratorConnectionLossException) {            WatchedEvent watchedEvent = new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.Disconnected, null);            CuratorEvent event = new CuratorEventImpl(this, CuratorEventType.WATCHED, KeeperException.Code.CONNECTIONLOSS.intValue(), null, null, operationAndData.getContext(), null, null, null, watchedEvent, null, null);            if (checkBackgroundRetry(operationAndData, event)) {                queueOperation(operationAndData);            } else {                logError("Background retry gave up", e);            }        } else {            handleBackgroundOperationException(operationAndData, e);        }    }}
7919796e3c24832273960f5791ad4aab905d546c204af9d841b7c5a11efccdae
sleepAndQueueOperation
private void sleepAndQueueOperation(OperationAndData<?> operationAndData) throws InterruptedException
{    operationAndData.sleepFor(sleepAndQueueOperationSeconds, TimeUnit.SECONDS);    if (queueOperation(operationAndData)) {        forcedSleepOperations.add(operationAndData);    }}
20c748ba80240a5e9725090c21730499b570d675820f138d212cdda49cd18aa8
unSleepBackgroundOperations
private void unSleepBackgroundOperations()
{    Collection<OperationAndData<?>> drain = new ArrayList<>(forcedSleepOperations.size());    forcedSleepOperations.drainTo(drain);    log.debug("Clearing sleep for {} operations", drain.size());    for (OperationAndData<?> operation : drain) {        operation.clearSleep();        if (        backgroundOperations.remove(operation)) {            backgroundOperations.offer(operation);        }    }}
43dd90a5e38c5db052cd9152a08dc43c97b2ec33a936d75bdc8d2798288b5033
processEvent
private void processEvent(final CuratorEvent curatorEvent)
{    if (curatorEvent.getType() == CuratorEventType.WATCHED) {        validateConnection(curatorEvent.getWatchedEvent().getState());    }    listeners.forEach(new Function<CuratorListener, Void>() {        @Override        public Void apply(CuratorListener listener) {            try {                OperationTrace trace = client.startAdvancedTracer("EventListener");                listener.eventReceived(CuratorFrameworkImpl.this, curatorEvent);                trace.commit();            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                logError("Event listener threw exception", e);            }            return null;        }    });}
75a82c75829578f5bdf11605706f91426252061dff7f289a398a56211f3f7693
apply
public Void apply(CuratorListener listener)
{    try {        OperationTrace trace = client.startAdvancedTracer("EventListener");        listener.eventReceived(CuratorFrameworkImpl.this, curatorEvent);        trace.commit();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        logError("Event listener threw exception", e);    }    return null;}
57a7eae0f3017bed6ccf530327006d7b19339ab17b36284f0e992fa883a46eca
inBackground
public ErrorListenerMultiTransactionMain inBackground()
{    backgrounding = new Backgrounding(true);    return this;}
f4db269ba833d649eaf2a8e75552dc9e633537fe9842f9b5795de5008bb04926
inBackground
public ErrorListenerMultiTransactionMain inBackground(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
aa0c82feaa46998ac4aea1d795ebdcec129c540b3ef6b8c35b8053b9f4a9bc56
inBackground
public ErrorListenerMultiTransactionMain inBackground(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
0f39cd109a2c5bffa2b9e4731a7ecded5c36b9e93eb7662d11bbf0c9ad21fcc2
inBackground
public ErrorListenerMultiTransactionMain inBackground(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
8de45fd043a9a2825b7a37fa00ea1f10e14122072023053ef0d4b633987923d3
inBackground
public ErrorListenerMultiTransactionMain inBackground(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(callback, executor);    return this;}
83618e64b967b74b13b28e1e1e05cfc012648588513c4f8136d3a15ed2a71c46
inBackground
public ErrorListenerMultiTransactionMain inBackground(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
1d56618b7dc4de5abe437ea649197f61b734a850aced1f95e097d691c2341c16
withUnhandledErrorListener
public CuratorMultiTransactionMain withUnhandledErrorListener(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
c50299e6d4ce85e5c2b7780ca488e3187f336d2ad433595f1498ec8ecf3c7b2c
forOperations
public List<CuratorTransactionResult> forOperations(CuratorOp... operations) throws Exception
{    List<CuratorOp> ops = (operations != null) ? Arrays.asList(operations) : Lists.<CuratorOp>newArrayList();    return forOperations(ops);}
b09ab33c92608e18605416edc30ab6520aab51bc534c8b1a4ba0c98fae4f9f8a
forOperations
public List<CuratorTransactionResult> forOperations(List<CuratorOp> operations) throws Exception
{    operations = Preconditions.checkNotNull(operations, "operations cannot be null");    Preconditions.checkArgument(!operations.isEmpty(), "operations list cannot be empty");    CuratorMultiTransactionRecord record = new CuratorMultiTransactionRecord();    for (CuratorOp curatorOp : operations) {        Schema schema = client.getSchemaSet().getSchema(curatorOp.getTypeAndPath().getForPath());        record.add(curatorOp.get(), curatorOp.getTypeAndPath().getType(), curatorOp.getTypeAndPath().getForPath());        if ((curatorOp.get().getType() == ZooDefs.OpCode.create) || (curatorOp.get().getType() == ZooDefs.OpCode.createContainer)) {            CreateRequest createRequest = (CreateRequest) curatorOp.get().toRequestRecord();            CreateMode createMode;            if (client.isZk34CompatibilityMode()) {                try {                    createMode = CreateMode.fromFlag(createRequest.getFlags());                } catch (KeeperException.BadArgumentsException dummy) {                    createMode = CreateMode.PERSISTENT;                }            } else {                createMode = CreateMode.fromFlag(createRequest.getFlags(), CreateMode.PERSISTENT);            }            schema.validateCreate(createMode, createRequest.getPath(), createRequest.getData(), createRequest.getAcl());        } else if ((curatorOp.get().getType() == ZooDefs.OpCode.delete) || (curatorOp.get().getType() == ZooDefs.OpCode.deleteContainer)) {            DeleteRequest deleteRequest = (DeleteRequest) curatorOp.get().toRequestRecord();            schema.validateDelete(deleteRequest.getPath());        } else if (curatorOp.get().getType() == ZooDefs.OpCode.setData) {            SetDataRequest setDataRequest = (SetDataRequest) curatorOp.get().toRequestRecord();            schema.validateGeneral(setDataRequest.getPath(), setDataRequest.getData(), null);        }    }    if (backgrounding.inBackground()) {        client.processBackgroundOperation(new OperationAndData<>(this, record, backgrounding.getCallback(), null, backgrounding.getContext(), null), null);        return null;    } else {        return forOperationsInForeground(record);    }}
97052546155e83519f7c2b9a0e9d9020be5a83c5673bf6dd23cb6e402b00d7a6
performBackgroundOperation
public void performBackgroundOperation(final OperationAndData<CuratorMultiTransactionRecord> operationAndData) throws Exception
{    try {        final TimeTrace trace = client.getZookeeperClient().startTracer("CuratorMultiTransactionImpl-Background");        AsyncCallback.MultiCallback callback = new AsyncCallback.MultiCallback() {            @Override            public void processResult(int rc, String path, Object ctx, List<OpResult> opResults) {                trace.commit();                List<CuratorTransactionResult> curatorResults = (opResults != null) ? CuratorTransactionImpl.wrapResults(client, opResults, operationAndData.getData()) : null;                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.TRANSACTION, rc, path, null, ctx, null, null, null, null, null, curatorResults);                client.processBackgroundOperation(operationAndData, event);            }        };        client.getZooKeeper().multi(operationAndData.getData(), callback, backgrounding.getContext());    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
c3f43253c0cfa68b8cdedb13b40f581f946a3356a1a5b992fe9d5793677f693c
processResult
public void processResult(int rc, String path, Object ctx, List<OpResult> opResults)
{    trace.commit();    List<CuratorTransactionResult> curatorResults = (opResults != null) ? CuratorTransactionImpl.wrapResults(client, opResults, operationAndData.getData()) : null;    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.TRANSACTION, rc, path, null, ctx, null, null, null, null, null, curatorResults);    client.processBackgroundOperation(operationAndData, event);}
18fc04e04f22b9963cae9d8f4dd935fcbf48c2b7d041816b94c0190ae484cd18
forOperationsInForeground
private List<CuratorTransactionResult> forOperationsInForeground(final CuratorMultiTransactionRecord record) throws Exception
{    TimeTrace trace = client.getZookeeperClient().startTracer("CuratorMultiTransactionImpl-Foreground");    List<OpResult> responseData = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<List<OpResult>>() {        @Override        public List<OpResult> call() throws Exception {            return client.getZooKeeper().multi(record);        }    });    trace.commit();    return CuratorTransactionImpl.wrapResults(client, responseData, record);}
1f5d3e412b4d945f8feecfa13b5caafc5802db39237cf7192e259dba58bfcf9a
call
public List<OpResult> call() throws Exception
{    return client.getZooKeeper().multi(record);}
78f318f4e8ece98ed8cdd19bd92246866e2c31238d7a94afcc815131f25b2c75
add
public final void add(Op op)
{    throw new UnsupportedOperationException();}
f0f1284a1e1af70078bd57e610d2fea869fa44eb80e104fe0f9408e1c7d5bc58
add
 void add(Op op, OperationType type, String forPath)
{    super.add(op);    metadata.add(new TypeAndPath(type, forPath));}
43acba7bad5a3e354d5bc4b7c29b325db36d53e295b27234079c732204983d09
getMetadata
 TypeAndPath getMetadata(int index)
{    return metadata.get(index);}
e694e8cf2462053554362d1cbad4ed2cbb6bc8a64a489a13e8b7f3d893a0d0d4
metadataSize
 int metadataSize()
{    return metadata.size();}
26ec551098d0a257b443c4471d70b8c98450733ebc4386d73d46cd50e04a7ef0
addToDigest
 void addToDigest(MessageDigest digest)
{    for (Op op : this) {        digest.update(op.getPath().getBytes());        digest.update(Integer.toString(op.getType()).getBytes());        digest.update(op.toRequestRecord().toString().getBytes());    }}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    closeClient();}
86eefe8c2a73942d8af32645e81f87f2e62ff8d7c04920d198630aa4fce8a529
inTransaction
public CuratorTransaction inTransaction() throws Exception
{    openConnectionIfNeeded();    return new CuratorTransactionImpl(client);}
bea9126e52af63eacac7097e6faef6831afe53b140299cc154227449c1b620cb
getData
public TempGetDataBuilder getData() throws Exception
{    openConnectionIfNeeded();    return new TempGetDataBuilderImpl(client);}
01d404f4affd9450ba2269f45a4428372a34e7478dce4281e04c65e90d2e0541
getClient
 synchronized CuratorFrameworkImpl getClient()
{    return client;}
67a9e442a9bf605352d6c506760f60a81c86312259742ea892e7225d3827da51
getCleanup
 synchronized ScheduledExecutorService getCleanup()
{    return cleanup;}
45ad7ec4b79a91956318e9a1eee5347ca51f56812512acbc2c9a43ae2166a5b9
updateLastAccess
 synchronized void updateLastAccess()
{    lastAccess = System.currentTimeMillis();}
6c9856c3d70d75a93f8b2e29d212a24e82a298a0d8dfacf76ddba2c82a597f82
openConnectionIfNeeded
private synchronized void openConnectionIfNeeded() throws Exception
{    if (client == null) {                client = (CuratorFrameworkImpl) factory.build();        client.start();    }    if (cleanup == null) {        ThreadFactory threadFactory = factory.getThreadFactory();        if (threadFactory == null) {            threadFactory = ThreadUtils.newGenericThreadFactory("CuratorTempFrameworkImpl");        }        cleanup = Executors.newScheduledThreadPool(1, threadFactory);        Runnable command = new Runnable() {            @Override            public void run() {                checkInactive();            }        };        cleanup.scheduleAtFixedRate(command, inactiveThresholdMs, inactiveThresholdMs, TimeUnit.MILLISECONDS);    }    updateLastAccess();}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    checkInactive();}
6880b8967a7e08b51fe88bb7a1666c31419039769313d63ca354d0415e027229
checkInactive
private synchronized void checkInactive()
{    long elapsed = System.currentTimeMillis() - lastAccess;    if (elapsed >= inactiveThresholdMs) {        closeClient();    }}
67631813a39fd68d767ccb9f85912fe31b1e365697ca73f0557f2472158c38b4
closeClient
private synchronized void closeClient()
{    if (cleanup != null) {        cleanup.shutdownNow();        cleanup = null;    }    if (client != null) {        CloseableUtils.closeQuietly(client);        client = null;    }}
83b6a5e58edd4aacabcd587946953fa4b9e2c9e2013a6918348dd21137575ddf
and
public CuratorTransactionFinal and()
{    return this;}
c15cf4f57dea9216a1c745c7a1fb14507f9988b6592df282e7fd41eff42ff63e
create
public TransactionCreateBuilder<CuratorTransactionBridge> create()
{    Preconditions.checkState(!isCommitted, "transaction already committed");    CuratorTransactionBridge asBridge = this;    return new CreateBuilderImpl(client).asTransactionCreateBuilder(asBridge, transaction);}
10b0534b890c0746ef0fcfef49fbb77c8890ed97a2642de78ce38f21e45cc567
delete
public TransactionDeleteBuilder<CuratorTransactionBridge> delete()
{    Preconditions.checkState(!isCommitted, "transaction already committed");    CuratorTransactionBridge asBridge = this;    return new DeleteBuilderImpl(client).asTransactionDeleteBuilder(asBridge, transaction);}
3df2d0d8721af2c8c6d12ffdcea3cd50c389b3000f324aa99e0b761a1cbde48a
setData
public TransactionSetDataBuilder<CuratorTransactionBridge> setData()
{    Preconditions.checkState(!isCommitted, "transaction already committed");    CuratorTransactionBridge asBridge = this;    return new SetDataBuilderImpl(client).asTransactionSetDataBuilder(asBridge, transaction);}
ce43f99ad131b2b98660e1ef4abaf6f6d11dbae9994da7ce9e6e5c0c07d42125
check
public TransactionCheckBuilder<CuratorTransactionBridge> check()
{    Preconditions.checkState(!isCommitted, "transaction already committed");    CuratorTransactionBridge asBridge = this;    return makeTransactionCheckBuilder(client, asBridge, transaction);}
e98c14a8a4665f8ac80696ecfde4c3e75f889fbd2bf1aee94613fc1c8494f887
makeTransactionCheckBuilder
 static TransactionCheckBuilder<T> makeTransactionCheckBuilder(final CuratorFrameworkImpl client, final T context, final CuratorMultiTransactionRecord transaction)
{    return new TransactionCheckBuilder<T>() {        private int version = -1;        @Override        public T forPath(String path) throws Exception {            String fixedPath = client.fixForNamespace(path);            transaction.add(Op.check(fixedPath, version), OperationType.CHECK, path);            return context;        }        @Override        public Pathable<T> withVersion(int version) {            this.version = version;            return this;        }    };}
f78f8317545828af6938dc071d4101bc858a8de7ddea11ca44fff56534af53dc
forPath
public T forPath(String path) throws Exception
{    String fixedPath = client.fixForNamespace(path);    transaction.add(Op.check(fixedPath, version), OperationType.CHECK, path);    return context;}
455027be703787d13feae96918f7a5429fdc9271b64b2d2679749c43479a2f96
withVersion
public Pathable<T> withVersion(int version)
{    this.version = version;    return this;}
5eeb116c498f91bbf01259c7d419f2233dfd4e36c2beb744c1129977d6cf32d0
commit
public Collection<CuratorTransactionResult> commit() throws Exception
{    Preconditions.checkState(!isCommitted, "transaction already committed");    isCommitted = true;    List<OpResult> resultList = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<List<OpResult>>() {        @Override        public List<OpResult> call() throws Exception {            return doOperation();        }    });    if (resultList.size() != transaction.metadataSize()) {        throw new IllegalStateException(String.format("Result size (%d) doesn't match input size (%d)", resultList.size(), transaction.metadataSize()));    }    return wrapResults(client, resultList, transaction);}
1f5d3e412b4d945f8feecfa13b5caafc5802db39237cf7192e259dba58bfcf9a
call
public List<OpResult> call() throws Exception
{    return doOperation();}
143ed79608ed559c79fb0479824b1c5effa2208d0a01b1ad66bf32906cf09e57
wrapResults
 static List<CuratorTransactionResult> wrapResults(CuratorFrameworkImpl client, List<OpResult> resultList, CuratorMultiTransactionRecord transaction)
{    ImmutableList.Builder<CuratorTransactionResult> builder = ImmutableList.builder();    for (int i = 0; i < resultList.size(); ++i) {        OpResult opResult = resultList.get(i);        TypeAndPath metadata = transaction.getMetadata(i);        CuratorTransactionResult curatorResult = makeCuratorResult(client, opResult, metadata);        builder.add(curatorResult);    }    return builder.build();}
c278b636009451e91979a110358ebae810918fd51277f963f79dee7bc97a1bd1
makeCuratorResult
 static CuratorTransactionResult makeCuratorResult(CuratorFrameworkImpl client, OpResult opResult, TypeAndPath metadata)
{    String resultPath = null;    Stat resultStat = null;    int error = 0;    switch(opResult.getType()) {        default:            {                                break;            }        case ZooDefs.OpCode.create:            {                OpResult.CreateResult createResult = (OpResult.CreateResult) opResult;                resultPath = client.unfixForNamespace(createResult.getPath());                break;            }        case ZooDefs.OpCode.setData:            {                OpResult.SetDataResult setDataResult = (OpResult.SetDataResult) opResult;                resultStat = setDataResult.getStat();                break;            }        case ZooDefs.OpCode.error:            {                OpResult.ErrorResult errorResult = (OpResult.ErrorResult) opResult;                error = errorResult.getErr();                break;            }    }    return new CuratorTransactionResult(metadata.getType(), metadata.getForPath(), resultPath, resultStat, error);}
de725b368a3488d85464fe310e85970cb68133acc1e1cfdb67c7927698585b7f
doOperation
private List<OpResult> doOperation() throws Exception
{    List<OpResult> opResults = client.getZooKeeper().multi(transaction);    if (opResults.size() > 0) {        OpResult firstResult = opResults.get(0);        if (firstResult.getType() == ZooDefs.OpCode.error) {            OpResult.ErrorResult error = (OpResult.ErrorResult) firstResult;            KeeperException.Code code = KeeperException.Code.get(error.getErr());            if (code == null) {                code = KeeperException.Code.UNIMPLEMENTED;            }            throw KeeperException.create(code);        }    }    return opResults;}
608c4250279b9160905e4962b77bc1d258c8a726d186d1875dd0e18be5e9bcbb
getDefaultAcl
public List<ACL> getDefaultAcl()
{    return ZooDefs.Ids.OPEN_ACL_UNSAFE;}
948e924ac3cf12487fcf7f5ccc3b514ae7fc4b9d602a2962739b070d41126b34
getAclForPath
public List<ACL> getAclForPath(String path)
{    return ZooDefs.Ids.OPEN_ACL_UNSAFE;}
5f67311844741a5c6b11cdb8b4022b38dd651606fc31e809f946e2d64c5980d7
asTransactionDeleteBuilder
 TransactionDeleteBuilder<T> asTransactionDeleteBuilder(final T context, final CuratorMultiTransactionRecord transaction)
{    return new TransactionDeleteBuilder<T>() {        @Override        public T forPath(String path) throws Exception {            String fixedPath = client.fixForNamespace(path);            transaction.add(Op.delete(fixedPath, version), OperationType.DELETE, path);            return context;        }        @Override        public Pathable<T> withVersion(int version) {            DeleteBuilderImpl.this.withVersion(version);            return this;        }    };}
f78f8317545828af6938dc071d4101bc858a8de7ddea11ca44fff56534af53dc
forPath
public T forPath(String path) throws Exception
{    String fixedPath = client.fixForNamespace(path);    transaction.add(Op.delete(fixedPath, version), OperationType.DELETE, path);    return context;}
455027be703787d13feae96918f7a5429fdc9271b64b2d2679749c43479a2f96
withVersion
public Pathable<T> withVersion(int version)
{    DeleteBuilderImpl.this.withVersion(version);    return this;}
4d0b84c3570626ea6c7c4a913a4742d5c921d5b8077938e8f0491946a286f36e
quietly
public DeleteBuilderMain quietly()
{    quietly = true;    return this;}
a4b720862e8e7c4bd55ab1e99902504dcd75540fe3fa8b561ddd3d38aed6f988
guaranteed
public ChildrenDeletable guaranteed()
{    guaranteed = true;    return this;}
a486b587dfc247d297b50020420fb84668b3365466bfde8b56a28c8cce2a720d
deletingChildrenIfNeeded
public BackgroundVersionable deletingChildrenIfNeeded()
{    deletingChildrenIfNeeded = true;    return this;}
f2b50380fab1e1e2c7eb2a04ea67f33974955264694c6165ca72dc6b6c70f6ba
withVersion
public BackgroundPathable<Void> withVersion(int version)
{    this.version = version;    return this;}
34cee117719f9e8afbe0e19984b4f0ddf616e1298a89c5bf5cfd28e6df2b8ce6
inBackground
public ErrorListenerPathable<Void> inBackground(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
8fc2882e551603e6f04a3080c4df91a07a5716b4e49512020ae6bc8ff34193d5
inBackground
public ErrorListenerPathable<Void> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
b07ef64d8ae6fdc8f2165ccbe5182c8f027e5e71e2fdfe20fd6d32fc37d86361
inBackground
public ErrorListenerPathable<Void> inBackground(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
9a1a177a2a5c105b8c51cce1c88513c86e5f2cc0c54bc39b45f78bcab4e7ff6a
inBackground
public ErrorListenerPathable<Void> inBackground(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
432b3e2dd1c388f8c64000f2ce1822cf59ab8e6b968d54626e8a5db9349e2d5e
inBackground
public ErrorListenerPathable<Void> inBackground()
{    backgrounding = new Backgrounding(true);    return this;}
62988fed96608d5aed7f71052bf14f8688ce2d11e60964236538609bbbc577e5
inBackground
public ErrorListenerPathable<Void> inBackground(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
b30687aba7550ec7f699cd31b3de92272489b3de82641c094c05df75193eb336
withUnhandledErrorListener
public Pathable<Void> withUnhandledErrorListener(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
772f79cf5c4af16a3e1cf67e610e3b66d770948915f9c0cca395686aa2e4f144
performBackgroundOperation
public void performBackgroundOperation(final OperationAndData<String> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("DeleteBuilderImpl-Background");        client.getZooKeeper().delete(operationAndData.getData(), version, new AsyncCallback.VoidCallback() {            @Override            public void processResult(int rc, String path, Object ctx) {                trace.setReturnCode(rc).setPath(path).commit();                if ((rc == KeeperException.Code.NOTEMPTY.intValue()) && deletingChildrenIfNeeded) {                    backgroundDeleteChildrenThenNode(operationAndData);                } else {                    if ((rc == KeeperException.Code.NONODE.intValue()) && quietly) {                        rc = KeeperException.Code.OK.intValue();                    }                    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.DELETE, rc, path, null, ctx, null, null, null, null, null, null);                    client.processBackgroundOperation(operationAndData, event);                }            }        }, backgrounding.getContext());    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
1670bb3e4673da82391867e9228b38f3d7dfc7759993e3e7748dcea2c4b95bb2
processResult
public void processResult(int rc, String path, Object ctx)
{    trace.setReturnCode(rc).setPath(path).commit();    if ((rc == KeeperException.Code.NOTEMPTY.intValue()) && deletingChildrenIfNeeded) {        backgroundDeleteChildrenThenNode(operationAndData);    } else {        if ((rc == KeeperException.Code.NONODE.intValue()) && quietly) {            rc = KeeperException.Code.OK.intValue();        }        CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.DELETE, rc, path, null, ctx, null, null, null, null, null, null);        client.processBackgroundOperation(operationAndData, event);    }}
25c46a98169acea5f39a3fa13ac349a1e706fcad4bb15cbea4f8e698ae9869e7
backgroundDeleteChildrenThenNode
private void backgroundDeleteChildrenThenNode(final OperationAndData<String> mainOperationAndData)
{    BackgroundOperation<String> operation = new BackgroundOperation<String>() {        @Override        public void performBackgroundOperation(OperationAndData<String> dummy) throws Exception {            try {                ZKPaths.deleteChildren(client.getZooKeeper(), mainOperationAndData.getData(), false);            } catch (KeeperException e) {                        }            client.queueOperation(mainOperationAndData);        }    };    OperationAndData<String> parentOperation = new OperationAndData<String>(operation, mainOperationAndData.getData(), null, null, backgrounding.getContext(), null);    client.queueOperation(parentOperation);}
016ae7806b2c03dfbe91aaf42653bd6fd4ee20b0c93c30ece6faafa47b844905
performBackgroundOperation
public void performBackgroundOperation(OperationAndData<String> dummy) throws Exception
{    try {        ZKPaths.deleteChildren(client.getZooKeeper(), mainOperationAndData.getData(), false);    } catch (KeeperException e) {        }    client.queueOperation(mainOperationAndData);}
012300743f62d93bdc1341b856be6212f1beeef6472d9e490d9be52dda2292f2
forPath
public Void forPath(String path) throws Exception
{    client.getSchemaSet().getSchema(path).validateDelete(path);    final String unfixedPath = path;    path = client.fixForNamespace(path);    if (backgrounding.inBackground()) {        OperationAndData.ErrorCallback<String> errorCallback = null;        if (guaranteed) {            errorCallback = new OperationAndData.ErrorCallback<String>() {                @Override                public void retriesExhausted(OperationAndData<String> operationAndData) {                    client.getFailedDeleteManager().addFailedOperation(unfixedPath);                }            };        }        client.processBackgroundOperation(new OperationAndData<String>(this, path, backgrounding.getCallback(), errorCallback, backgrounding.getContext(), null), null);    } else {        pathInForeground(path, unfixedPath);    }    return null;}
154069a6dfe6c6202d51162d5c67154f5781e4e4165afa7eb4d6499e4e0c349d
retriesExhausted
public void retriesExhausted(OperationAndData<String> operationAndData)
{    client.getFailedDeleteManager().addFailedOperation(unfixedPath);}
9f67712f3b9f214ca7b392af6e5db3a77d403ecd0385e507664bc69c71708934
getVersion
protected int getVersion()
{    return version;}
4043b047b76d67ecf58fd53932175314911b3f7c55fbe5023085e2bda2257bf6
pathInForeground
private void pathInForeground(final String path, String unfixedPath) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("DeleteBuilderImpl-Foreground");    try {        RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<Void>() {            @Override            public Void call() throws Exception {                try {                    client.getZooKeeper().delete(path, version);                } catch (KeeperException.NoNodeException e) {                    if (!quietly) {                        throw e;                    }                } catch (KeeperException.NotEmptyException e) {                    if (deletingChildrenIfNeeded) {                        ZKPaths.deleteChildren(client.getZooKeeper(), path, true);                    } else {                        throw e;                    }                }                return null;            }        });    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);                if ((RetryLoop.isRetryException(e) || (e instanceof InterruptedException)) && guaranteed) {            client.getFailedDeleteManager().addFailedOperation(unfixedPath);        }        throw e;    }    trace.setPath(path).commit();}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    try {        client.getZooKeeper().delete(path, version);    } catch (KeeperException.NoNodeException e) {        if (!quietly) {            throw e;        }    } catch (KeeperException.NotEmptyException e) {        if (deletingChildrenIfNeeded) {            ZKPaths.deleteChildren(client.getZooKeeper(), path, true);        } else {            throw e;        }    }    return null;}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if ((newState == ConnectionState.CONNECTED) || (newState == ConnectionState.RECONNECTED)) {        try {            reset();        } catch (Exception e) {            log.error("Trying to reset after reconnection", e);        }    }}
052fb1fa9dd744184daf95bc1b6fa794f18fa4939ad19b228ea3af7ce10e066f
doNotProxy
public boolean doNotProxy()
{    return true;}
90ba0dddc593bd95e2a0c0c039c523b81bfb91f87814ebcb222c3914ca772ead
start
public void start() throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    client.getConnectionStateListenable().addListener(connectionStateListener);    reset();}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    if (state.compareAndSet(State.STARTED, State.CLOSED)) {        client.removeWatchers();        client.getConnectionStateListenable().removeListener(connectionStateListener);    }}
a4803fca4797306b4f772a40c997680043dc08b35469407056bd5b28cf26096b
process
public void process(WatchedEvent event) throws Exception
{    if (event.getType() == Watcher.Event.EventType.NodeDataChanged) {        reset();    }}
d88879d077a02cb000a6bf5e2e8edd6a45c0285b57f499cf90cc94e2bcd1cf16
getCurrentConfig
public QuorumVerifier getCurrentConfig()
{    return currentConfig.get();}
2f4f47a2b0d06f4c49e28c949cff97a9ab971e16a7a45793b1582bb8cbf6ab21
hasOutstanding
public boolean hasOutstanding()
{    return outstanding.get() > 0;}
d9325b48525d29e8fd87bd09cc08079162b8103b1fddcc84d99536f78d8f2d73
reset
private void reset() throws Exception
{    if ((client.getState() == CuratorFrameworkState.STARTED) && (state.get() == State.STARTED)) {        BackgroundCallback backgroundCallback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                outstanding.decrementAndGet();                if ((event.getType() == CuratorEventType.GET_CONFIG) && (event.getResultCode() == KeeperException.Code.OK.intValue())) {                    processConfigData(event.getData());                }            }        };        outstanding.incrementAndGet();        try {            client.getConfig().usingWatcher(this).inBackground(backgroundCallback).forEnsemble();                        outstanding.incrementAndGet();        } finally {            outstanding.decrementAndGet();        }    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    outstanding.decrementAndGet();    if ((event.getType() == CuratorEventType.GET_CONFIG) && (event.getResultCode() == KeeperException.Code.OK.intValue())) {        processConfigData(event.getData());    }}
514be95a2e22de7bbe2aae0de2ebb10cf24de11feddd69e6b37bdbddd1f0f3b9
configToConnectionString
public static String configToConnectionString(QuorumVerifier data) throws Exception
{    StringBuilder sb = new StringBuilder();    for (QuorumPeer.QuorumServer server : data.getAllMembers().values()) {        if (server.clientAddr == null) {                        continue;        }        if (sb.length() != 0) {            sb.append(",");        }        String hostAddress;        if (server.clientAddr.getAddress().isAnyLocalAddress()) {            hostAddress = server.addr.getAddress().getHostAddress();        } else {            hostAddress = server.clientAddr.getAddress().getHostAddress();        }        sb.append(hostAddress).append(":").append(server.clientAddr.getPort());    }    return sb.toString();}
d6fbbc32a32d059bff897b476e54548bfb260eb6d74fcb53244058a371d5b875
processConfigData
private void processConfigData(byte[] data) throws Exception
{    Properties properties = new Properties();    properties.load(new ByteArrayInputStream(data));    log.info("New config event received: {}", properties);    if (!properties.isEmpty()) {        QuorumMaj newConfig = new QuorumMaj(properties);        String connectionString = configToConnectionString(newConfig);        if (connectionString.trim().length() > 0) {            currentConfig.set(newConfig);            ensembleProvider.setConnectionString(connectionString);        } else {            log.error("Invalid config event received: {}", properties);        }    } else {        log.debug("Ignoring new config as it is empty");    }}
b1c9e5887165dd357f05e90f25a17e2dad16fd8f94003965fea3c08cabe96c92
creatingParentsIfNeeded
public ACLableExistBuilderMain creatingParentsIfNeeded()
{    createParentContainersIfNeeded = false;    createParentsIfNeeded = true;    return this;}
11cc4cacacd91cf6e8b9c5507a0ded2fd713d812cb2ab9d51effb25caacb3973
creatingParentContainersIfNeeded
public ACLableExistBuilderMain creatingParentContainersIfNeeded()
{    createParentContainersIfNeeded = true;    createParentsIfNeeded = false;    return this;}
6e185065857c2c4c09f07afedd9a2bbf5ed7413e265537be09f709d5610afdcf
withACL
public ExistsBuilderMain withACL(List<ACL> aclList)
{    acling = new ACLing(client.getAclProvider(), aclList, true);    return this;}
935076c3e5435bb84d41c084d1d5646c2dea6d6932de265f9ed510ae94f1f6ce
watched
public BackgroundPathable<Stat> watched()
{    watching = new Watching(client, true);    return this;}
86611e5b966aab1d92cd9a5fcb231838be6a8a0ea1e56f7239da2d617636f691
usingWatcher
public BackgroundPathable<Stat> usingWatcher(Watcher watcher)
{    watching = new Watching(client, watcher);    return this;}
a7d0dd96e99fa0029db00518c9ed3625f756e8899d5eda133ed7005cf9b04bbb
usingWatcher
public BackgroundPathable<Stat> usingWatcher(CuratorWatcher watcher)
{    watching = new Watching(client, watcher);    return this;}
e169d16ff4cf50bc71a1c0216e8d73341f9c7adbce8997ce2319f4a33e8e0f9a
inBackground
public ErrorListenerPathable<Stat> inBackground(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
083abced46a28092a693dcb8ed84b7df3ecbc381ee2c29d4a6f13f2a1fcedda9
inBackground
public ErrorListenerPathable<Stat> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
512f55d2e0eafcc54ff145c457c0f56d1b700486408abf08b7469fc6fb2cd824
inBackground
public ErrorListenerPathable<Stat> inBackground(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
768344386dd7390e8424ed1432d3f852f4d659038ba625449ca545a60fc72c3e
inBackground
public ErrorListenerPathable<Stat> inBackground(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
e69085b203da60aaba1c6504fc105c6da50b681758d365423ec68c8fed5f5539
inBackground
public ErrorListenerPathable<Stat> inBackground()
{    backgrounding = new Backgrounding(true);    return this;}
c4a454597d1ca387026c336f56880eb08e5feaa3bf14b9722a716d5cdcd54a36
inBackground
public ErrorListenerPathable<Stat> inBackground(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
772ee09bdd65569a912753d8079c732c88fdf6e948a5c1316451568b511046b7
withUnhandledErrorListener
public Pathable<Stat> withUnhandledErrorListener(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
772f79cf5c4af16a3e1cf67e610e3b66d770948915f9c0cca395686aa2e4f144
performBackgroundOperation
public void performBackgroundOperation(final OperationAndData<String> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("ExistsBuilderImpl-Background");        AsyncCallback.StatCallback callback = new AsyncCallback.StatCallback() {            @Override            public void processResult(int rc, String path, Object ctx, Stat stat) {                watching.commitWatcher(rc, true);                trace.setReturnCode(rc).setPath(path).setWithWatcher(watching.hasWatcher()).setStat(stat).commit();                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.EXISTS, rc, path, null, ctx, stat, null, null, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        };        if (watching.isWatched()) {            client.getZooKeeper().exists(operationAndData.getData(), true, callback, backgrounding.getContext());        } else {            client.getZooKeeper().exists(operationAndData.getData(), watching.getWatcher(operationAndData.getData()), callback, backgrounding.getContext());        }    } catch (Throwable e) {        backgrounding.checkError(e, watching);    }}
1653988579fabf57097982ee8a47dff699cc3eca4f907fda182e6e272411b776
processResult
public void processResult(int rc, String path, Object ctx, Stat stat)
{    watching.commitWatcher(rc, true);    trace.setReturnCode(rc).setPath(path).setWithWatcher(watching.hasWatcher()).setStat(stat).commit();    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.EXISTS, rc, path, null, ctx, stat, null, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
fa9a17290417ee5fd504790e9a78e109faa3bfdeeb4d9e49d611b00ff15e5958
forPath
public Stat forPath(String path) throws Exception
{    path = client.fixForNamespace(path);    client.getSchemaSet().getSchema(path).validateWatch(path, watching.isWatched() || watching.hasWatcher());    Stat returnStat = null;    if (backgrounding.inBackground()) {        OperationAndData<String> operationAndData = new OperationAndData<String>(this, path, backgrounding.getCallback(), null, backgrounding.getContext(), watching);        if (createParentContainersIfNeeded || createParentsIfNeeded) {            CreateBuilderImpl.backgroundCreateParentsThenNode(client, operationAndData, operationAndData.getData(), backgrounding, acling.getACLProviderForParents(), createParentContainersIfNeeded);        } else {            client.processBackgroundOperation(operationAndData, null);        }    } else {        returnStat = pathInForeground(path);    }    return returnStat;}
5f263c9170c7e0c947bf49691461ef440c8ecb5f82077cec60e31e49eaede866
pathInForeground
private Stat pathInForeground(final String path) throws Exception
{    if (createParentContainersIfNeeded || createParentsIfNeeded) {        final String parent = ZKPaths.getPathAndNode(path).getPath();        if (!parent.equals(ZKPaths.PATH_SEPARATOR)) {            OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("ExistsBuilderImpl-Foreground-CreateParents");            RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<Void>() {                @Override                public Void call() throws Exception {                    try {                        ZKPaths.mkdirs(client.getZooKeeper(), parent, true, acling.getACLProviderForParents(), createParentContainersIfNeeded);                    } catch (KeeperException.NodeExistsException e) {                                        } catch (KeeperException.NoNodeException e) {                                        }                    return null;                }            });            trace.setPath(path).commit();        }    }    return pathInForegroundStandard(path);}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    try {        ZKPaths.mkdirs(client.getZooKeeper(), parent, true, acling.getACLProviderForParents(), createParentContainersIfNeeded);    } catch (KeeperException.NodeExistsException e) {        } catch (KeeperException.NoNodeException e) {        }    return null;}
94894fed4f487ba8beaa88e4a0edf3bdca5543183c0f921db2db441ff62ab661
pathInForegroundStandard
private Stat pathInForegroundStandard(final String path) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("ExistsBuilderImpl-Foreground");    Stat returnStat = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<Stat>() {        @Override        public Stat call() throws Exception {            Stat returnStat;            if (watching.isWatched()) {                returnStat = client.getZooKeeper().exists(path, true);            } else {                returnStat = client.getZooKeeper().exists(path, watching.getWatcher(path));                int rc = (returnStat != null) ? KeeperException.NoNodeException.Code.OK.intValue() : KeeperException.NoNodeException.Code.NONODE.intValue();                watching.commitWatcher(rc, true);            }            return returnStat;        }    });    trace.setPath(path).setWithWatcher(watching.hasWatcher()).setStat(returnStat).commit();    return returnStat;}
b8e6c61d1ad0861ffb63b6e255cc9573670963d8e3c59317c9f9cc0da4742a26
call
public Stat call() throws Exception
{    Stat returnStat;    if (watching.isWatched()) {        returnStat = client.getZooKeeper().exists(path, true);    } else {        returnStat = client.getZooKeeper().exists(path, watching.getWatcher(path));        int rc = (returnStat != null) ? KeeperException.NoNodeException.Code.OK.intValue() : KeeperException.NoNodeException.Code.NONODE.intValue();        watching.commitWatcher(rc, true);    }    return returnStat;}
75a91fb4d50aa7c821122bff7d1d782a205777e03ebc468119b4bbd6f078342a
getRecord
 CuratorMultiTransactionRecord getRecord()
{    return record;}
70638665d9f0d72d4fc4751d87eef83b3ea95bd8b5a882e07cf449a6dccdf35d
getTypeAndPath
public TypeAndPath getTypeAndPath()
{    validate();    return record.getMetadata(0);}
d70f96f6ed32f1704ff81b0cbdc41cffb0976b65ccdbcc3925ef173408bbcf10
get
public Op get()
{    validate();    return record.iterator().next();}
277c1e3ac067f434336dcac95ce6b5624bc034548772b5e3f5abd6870622752f
addToDigest
public void addToDigest(MessageDigest digest)
{    record.addToDigest(digest);}
04278adab5ed6e09a7debb823345da0a4518a042bbc3add22d1f6e4d410b5b3e
validate
private void validate()
{    Preconditions.checkArgument(record.size() > 0, "No operation has been added");    Preconditions.checkArgument(record.size() == 1, "Multiple operations added");}
efd967b3c3a2c9592588a8bab523ca2ca490fb7b7df4e8753c69df91a0273fda
executeGuaranteedOperationInBackground
protected void executeGuaranteedOperationInBackground(String path) throws Exception
{    client.delete().guaranteed().inBackground().forPath(path);}
20deed42567628ce20f44fa8aa6035060c3efa19cb6556b02737b7af7736d8b6
addFailedOperation
 void addFailedOperation(T details)
{    if (debugListener != null) {        debugListener.pathAddedForGuaranteedOperation(details);    }    if (client.getState() == CuratorFrameworkState.STARTED) {        log.debug("Details being added to guaranteed operation set: " + details);        try {            executeGuaranteedOperationInBackground(details);        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);            addFailedOperation(details);        }    }}
63e3f3c60719940b4e3ebc310fa9a68882684860a6e95fbaed6f509968ca1b17
executeGuaranteedOperationInBackground
protected void executeGuaranteedOperationInBackground(FailedRemoveWatchDetails details) throws Exception
{    if (details.watcher == null) {        client.watches().removeAll().guaranteed().inBackground().forPath(details.path);    } else {        client.watches().remove(details.watcher).guaranteed().inBackground().forPath(details.path);    }}
380a838f52b801338e2e9243ecfd2db2ed447d69968c0a43a481781e5c56dae4
execute
 void execute()
{    OperationAndData.ErrorCallback<Void> errorCallback = new OperationAndData.ErrorCallback<Void>() {        @Override        public void retriesExhausted(OperationAndData<Void> operationAndData) {            operationAndData.reset();            client.processBackgroundOperation(operationAndData, null);        }    };    OperationAndData<Void> operationAndData = new OperationAndData<Void>(this, null, null, errorCallback, null, null);    client.processBackgroundOperation(operationAndData, null);}
090b8216fddce48430c8a7ca154311651668b4d52694fca4b69abea1e393069b
retriesExhausted
public void retriesExhausted(OperationAndData<Void> operationAndData)
{    operationAndData.reset();    client.processBackgroundOperation(operationAndData, null);}
d391a7bad20f3f50e657432aab1f534b25627342dc9dc8625af73bf2ec2aadac
performBackgroundOperation
public void performBackgroundOperation(final OperationAndData<Void> operationAndData) throws Exception
{    final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("FindAndDeleteProtectedNodeInBackground");    AsyncCallback.Children2Callback callback = new AsyncCallback.Children2Callback() {        @Override        public void processResult(int rc, String path, Object o, List<String> strings, Stat stat) {            trace.setReturnCode(rc).setPath(path).setStat(stat).commit();            if (debugInsertError.compareAndSet(true, false)) {                rc = KeeperException.Code.CONNECTIONLOSS.intValue();            }            if (rc == KeeperException.Code.OK.intValue()) {                                final String node = CreateBuilderImpl.findNode(strings, "/", protectedId);                if (node != null) {                    try {                        String deletePath = client.unfixForNamespace(ZKPaths.makePath(namespaceAdjustedParentPath, node));                        client.delete().guaranteed().inBackground().forPath(deletePath);                    } catch (Exception e) {                        ThreadUtils.checkInterrupted(e);                        log.error("Could not start guaranteed delete for node: " + node);                        rc = KeeperException.Code.CONNECTIONLOSS.intValue();                    }                }            }            if (rc != KeeperException.Code.OK.intValue()) {                CuratorEventImpl event = new CuratorEventImpl(client, CuratorEventType.CHILDREN, rc, path, null, o, stat, null, strings, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        }    };    client.getZooKeeper().getChildren(namespaceAdjustedParentPath, false, callback, null);}
80868df578e2061b14fbb6f399ae797967e7da5d49508df49692c54b4fdc8ccc
processResult
public void processResult(int rc, String path, Object o, List<String> strings, Stat stat)
{    trace.setReturnCode(rc).setPath(path).setStat(stat).commit();    if (debugInsertError.compareAndSet(true, false)) {        rc = KeeperException.Code.CONNECTIONLOSS.intValue();    }    if (rc == KeeperException.Code.OK.intValue()) {                final String node = CreateBuilderImpl.findNode(strings, "/", protectedId);        if (node != null) {            try {                String deletePath = client.unfixForNamespace(ZKPaths.makePath(namespaceAdjustedParentPath, node));                client.delete().guaranteed().inBackground().forPath(deletePath);            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                log.error("Could not start guaranteed delete for node: " + node);                rc = KeeperException.Code.CONNECTIONLOSS.intValue();            }        }    }    if (rc != KeeperException.Code.OK.intValue()) {        CuratorEventImpl event = new CuratorEventImpl(client, CuratorEventType.CHILDREN, rc, path, null, o, stat, null, strings, null, null, null);        client.processBackgroundOperation(operationAndData, event);    }}
683d96ac1f6092cc803a5dca7b030a74badab6e8ef12e868d73969a7424b8438
inBackground
public ErrorListenerPathable<List<ACL>> inBackground(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
a599cb227eec70d86fbdc594d6e1f501ccad6a4061a0165f42ef81d816414636
inBackground
public ErrorListenerPathable<List<ACL>> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
bc963a69c96749e692125db99a972ce536cc0ba5c7cb4735c8c7744c39f1b9ff
inBackground
public ErrorListenerPathable<List<ACL>> inBackground()
{    backgrounding = new Backgrounding(true);    return this;}
f1ae5e79ca7f762d88782e756dd9115d3e8088e646b397b92f47dfb871ae54ec
inBackground
public ErrorListenerPathable<List<ACL>> inBackground(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
c1b023a1c3105df0ccf2bcfc70e810a2834b485d79663677eadbbe6ca1d27e9d
inBackground
public ErrorListenerPathable<List<ACL>> inBackground(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
f52841dd46943bd862fdee188604fddf6f6490433a4a5f966b45468d2430c065
inBackground
public ErrorListenerPathable<List<ACL>> inBackground(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
91f21185f7eb7d4b8fb4429492b60c3e173ad2b1a17cfb2dedb0616eec42737e
withUnhandledErrorListener
public Pathable<List<ACL>> withUnhandledErrorListener(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
ab44f6288f6e4635eeff8053a88afef8d09bf7a0d0d92c8a52f24ce630a67da7
storingStatIn
public Pathable<List<ACL>> storingStatIn(Stat stat)
{    responseStat = stat;    return this;}
772f79cf5c4af16a3e1cf67e610e3b66d770948915f9c0cca395686aa2e4f144
performBackgroundOperation
public void performBackgroundOperation(final OperationAndData<String> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("GetACLBuilderImpl-Background");        AsyncCallback.ACLCallback callback = new AsyncCallback.ACLCallback() {            @Override            public void processResult(int rc, String path, Object ctx, List<ACL> acl, Stat stat) {                trace.setReturnCode(rc).setPath(path).setStat(stat).commit();                CuratorEventImpl event = new CuratorEventImpl(client, CuratorEventType.GET_ACL, rc, path, null, ctx, stat, null, null, null, acl, null);                client.processBackgroundOperation(operationAndData, event);            }        };        client.getZooKeeper().getACL(operationAndData.getData(), responseStat, callback, backgrounding.getContext());    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
27073a7a1f5835008d568700878dde38b58464d03c0db9bcb437594a85c5af85
processResult
public void processResult(int rc, String path, Object ctx, List<ACL> acl, Stat stat)
{    trace.setReturnCode(rc).setPath(path).setStat(stat).commit();    CuratorEventImpl event = new CuratorEventImpl(client, CuratorEventType.GET_ACL, rc, path, null, ctx, stat, null, null, null, acl, null);    client.processBackgroundOperation(operationAndData, event);}
7663cc7666d3d681675291ad84c829d324da6bb5dc4f489c494bf029a10b4e0c
forPath
public List<ACL> forPath(String path) throws Exception
{    path = client.fixForNamespace(path);    List<ACL> result = null;    if (backgrounding.inBackground()) {        client.processBackgroundOperation(new OperationAndData<String>(this, path, backgrounding.getCallback(), null, backgrounding.getContext(), null), null);    } else {        result = pathInForeground(path);    }    return result;}
308e633a8b5f0e0fc59e8d0579417b8d47d188e16573d304992a9cb5dffdef49
pathInForeground
private List<ACL> pathInForeground(final String path) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("GetACLBuilderImpl-Foreground");    List<ACL> result = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<List<ACL>>() {        @Override        public List<ACL> call() throws Exception {            return client.getZooKeeper().getACL(path, responseStat);        }    });    trace.setPath(path).setStat(responseStat).commit();    return result;}
b21faf3604a40a125cd8570692b9eb6ab14e551b69d9db5e085abd44d381899e
call
public List<ACL> call() throws Exception
{    return client.getZooKeeper().getACL(path, responseStat);}
dc7c69accd301fa10cff752d52b204f2d4111176dd9e83db3f33cf5fa9651e16
storingStatIn
public WatchPathable<List<String>> storingStatIn(Stat stat)
{    responseStat = stat;    return new WatchPathable<List<String>>() {        @Override        public List<String> forPath(String path) throws Exception {            return GetChildrenBuilderImpl.this.forPath(path);        }        @Override        public Pathable<List<String>> watched() {            GetChildrenBuilderImpl.this.watched();            return GetChildrenBuilderImpl.this;        }        @Override        public Pathable<List<String>> usingWatcher(Watcher watcher) {            GetChildrenBuilderImpl.this.usingWatcher(watcher);            return GetChildrenBuilderImpl.this;        }        @Override        public Pathable<List<String>> usingWatcher(CuratorWatcher watcher) {            GetChildrenBuilderImpl.this.usingWatcher(watcher);            return GetChildrenBuilderImpl.this;        }    };}
831c4b0da4c86564895f90b41e275faf1bee87ed9f3cb04e6b2eb062a47e0a46
forPath
public List<String> forPath(String path) throws Exception
{    return GetChildrenBuilderImpl.this.forPath(path);}
9a42c8be99fe87490c033d8bed9851d99d5715f620242fb7f530dee48fb6ab3f
watched
public Pathable<List<String>> watched()
{    GetChildrenBuilderImpl.this.watched();    return GetChildrenBuilderImpl.this;}
091aebfebb6cf3a0b956ca9e19f58877b8fce3fe7eff83f27f837295a2f821f3
usingWatcher
public Pathable<List<String>> usingWatcher(Watcher watcher)
{    GetChildrenBuilderImpl.this.usingWatcher(watcher);    return GetChildrenBuilderImpl.this;}
d88b5145ec32d50ba00ddb1dc766731c87eb423b9e2f678301b6313751e75479
usingWatcher
public Pathable<List<String>> usingWatcher(CuratorWatcher watcher)
{    GetChildrenBuilderImpl.this.usingWatcher(watcher);    return GetChildrenBuilderImpl.this;}
4f3342a221bb4181afe05843892feb587538e91168c879809bd6b79065bfb5b3
inBackground
public ErrorListenerPathable<List<String>> inBackground(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
b6ee365a9631f81f858cb8f13972545ca6e53257235057ba02f1ce79d1e045c3
inBackground
public ErrorListenerPathable<List<String>> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
496f7a754033db42b8bfb5405f99c45d1f26a0a442f85d16678cbffebc64ff38
inBackground
public ErrorListenerPathable<List<String>> inBackground(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
e1c1d18fa2d4e5212d336a9ba18099ebcc5089e0ac600530a183180f32d7a66b
inBackground
public ErrorListenerPathable<List<String>> inBackground(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
2786340ede9fa19e364e1f37730131cdb98fde06a848a787021d7c884c760586
inBackground
public ErrorListenerPathable<List<String>> inBackground()
{    backgrounding = new Backgrounding(true);    return this;}
f504bc67b1de91a0c41b04c410ca31fa0b980f44ff6d29365124d37f46aa742b
inBackground
public ErrorListenerPathable<List<String>> inBackground(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
99880a50ba921258e88e5b5281f0c9886692c25d3954377b9a5f38aa1498df5e
withUnhandledErrorListener
public Pathable<List<String>> withUnhandledErrorListener(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
e8f63393684f14621abea1d8782f1c181f9de7e08523ca30ebec914dc070e2de
watched
public BackgroundPathable<List<String>> watched()
{    watching = new Watching(client, true);    return this;}
aaa4ea22969de63964dd58fb1c8781ef4402328528b49d360d02866c792e6b6f
usingWatcher
public BackgroundPathable<List<String>> usingWatcher(Watcher watcher)
{    watching = new Watching(client, watcher);    return this;}
d45ca0e5b19209509e17ed54b5b61fa935328edfd1ed744158c01f14f8e502ca
usingWatcher
public BackgroundPathable<List<String>> usingWatcher(CuratorWatcher watcher)
{    watching = new Watching(client, watcher);    return this;}
772f79cf5c4af16a3e1cf67e610e3b66d770948915f9c0cca395686aa2e4f144
performBackgroundOperation
public void performBackgroundOperation(final OperationAndData<String> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("GetChildrenBuilderImpl-Background");        AsyncCallback.Children2Callback callback = new AsyncCallback.Children2Callback() {            @Override            public void processResult(int rc, String path, Object o, List<String> strings, Stat stat) {                watching.commitWatcher(rc, false);                trace.setReturnCode(rc).setPath(path).setWithWatcher(watching.hasWatcher()).setStat(stat).commit();                if (strings == null) {                    strings = Lists.newArrayList();                }                CuratorEventImpl event = new CuratorEventImpl(client, CuratorEventType.CHILDREN, rc, path, null, o, stat, null, strings, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        };        if (watching.isWatched()) {            client.getZooKeeper().getChildren(operationAndData.getData(), true, callback, backgrounding.getContext());        } else {            client.getZooKeeper().getChildren(operationAndData.getData(), watching.getWatcher(operationAndData.getData()), callback, backgrounding.getContext());        }    } catch (Throwable e) {        backgrounding.checkError(e, watching);    }}
80868df578e2061b14fbb6f399ae797967e7da5d49508df49692c54b4fdc8ccc
processResult
public void processResult(int rc, String path, Object o, List<String> strings, Stat stat)
{    watching.commitWatcher(rc, false);    trace.setReturnCode(rc).setPath(path).setWithWatcher(watching.hasWatcher()).setStat(stat).commit();    if (strings == null) {        strings = Lists.newArrayList();    }    CuratorEventImpl event = new CuratorEventImpl(client, CuratorEventType.CHILDREN, rc, path, null, o, stat, null, strings, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
831c4b0da4c86564895f90b41e275faf1bee87ed9f3cb04e6b2eb062a47e0a46
forPath
public List<String> forPath(String path) throws Exception
{    client.getSchemaSet().getSchema(path).validateWatch(path, watching.isWatched() || watching.hasWatcher());    path = client.fixForNamespace(path);    List<String> children = null;    if (backgrounding.inBackground()) {        client.processBackgroundOperation(new OperationAndData<String>(this, path, backgrounding.getCallback(), null, backgrounding.getContext(), watching), null);    } else {        children = pathInForeground(path);    }    return children;}
01a866c4c1284a410457799901aa2fa15a74c0628ef4af42bc9c9c6d0b44d4c6
pathInForeground
private List<String> pathInForeground(final String path) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("GetChildrenBuilderImpl-Foreground");    List<String> children = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<List<String>>() {        @Override        public List<String> call() throws Exception {            List<String> children;            if (watching.isWatched()) {                children = client.getZooKeeper().getChildren(path, true, responseStat);            } else {                children = client.getZooKeeper().getChildren(path, watching.getWatcher(path), responseStat);                watching.commitWatcher(KeeperException.NoNodeException.Code.OK.intValue(), false);            }            return children;        }    });    trace.setPath(path).setWithWatcher(watching.hasWatcher()).setStat(responseStat).commit();    return children;}
d0da1196838d0d7b6eac745ebcc36e00a54dd725679104c0a24e617093687b81
call
public List<String> call() throws Exception
{    List<String> children;    if (watching.isWatched()) {        children = client.getZooKeeper().getChildren(path, true, responseStat);    } else {        children = client.getZooKeeper().getChildren(path, watching.getWatcher(path), responseStat);        watching.commitWatcher(KeeperException.NoNodeException.Code.OK.intValue(), false);    }    return children;}
a7752893c2787a68a80d49d9f7278ddf0e495de8b0c1e18f82ff0ceac3a5df68
storingStatIn
public WatchBackgroundEnsembleable<byte[]> storingStatIn(Stat stat)
{    this.stat = stat;    return new WatchBackgroundEnsembleable<byte[]>() {        @Override        public ErrorListenerEnsembleable<byte[]> inBackground() {            return GetConfigBuilderImpl.this.inBackground();        }        @Override        public ErrorListenerEnsembleable<byte[]> inBackground(Object context) {            return GetConfigBuilderImpl.this.inBackground(context);        }        @Override        public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback) {            return GetConfigBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Object context) {            return GetConfigBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Executor executor) {            return GetConfigBuilderImpl.this.inBackground(callback, executor);        }        @Override        public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return GetConfigBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public byte[] forEnsemble() throws Exception {            return GetConfigBuilderImpl.this.forEnsemble();        }        @Override        public BackgroundEnsembleable<byte[]> watched() {            return GetConfigBuilderImpl.this.watched();        }        @Override        public BackgroundEnsembleable<byte[]> usingWatcher(Watcher watcher) {            return GetConfigBuilderImpl.this.usingWatcher(watcher);        }        @Override        public BackgroundEnsembleable<byte[]> usingWatcher(CuratorWatcher watcher) {            return GetConfigBuilderImpl.this.usingWatcher(watcher);        }    };}
ef6ebc3602aadae3bfedcf7c8ad5297224f8a0b2c6a9329f0db8bd40d08df118
inBackground
public ErrorListenerEnsembleable<byte[]> inBackground()
{    return GetConfigBuilderImpl.this.inBackground();}
f0ef0e205efb0ab0be436cf84c0c5532818d04bb275141bd21d911709596318a
inBackground
public ErrorListenerEnsembleable<byte[]> inBackground(Object context)
{    return GetConfigBuilderImpl.this.inBackground(context);}
3932a35ba3884a47c800556ab415d84d67333060636511333ef8fe7d6e5c8a08
inBackground
public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback)
{    return GetConfigBuilderImpl.this.inBackground(callback);}
17e9d8bcbc9df0d1b0b21fb23ee81548df34c17e30b17e3773b39220f17e67ac
inBackground
public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Object context)
{    return GetConfigBuilderImpl.this.inBackground(callback, context);}
0eeff0a2e872d26a9c4b7723b6e9bddcfff3be077278a2cff3089889dc4839b4
inBackground
public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Executor executor)
{    return GetConfigBuilderImpl.this.inBackground(callback, executor);}
e3f67eb7640e76816ed49c0172335d3fff06b1148ffb80997c4989dabc2cf822
inBackground
public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    return GetConfigBuilderImpl.this.inBackground(callback, context, executor);}
0f3ca0eb808271d8fcb9b5552ff16f7afde8cf89e72faee12f313f3d10492916
forEnsemble
public byte[] forEnsemble() throws Exception
{    return GetConfigBuilderImpl.this.forEnsemble();}
155c71e8b816ffb9d640e1828fdbcee44c279feae76407c7fc059d095037c593
watched
public BackgroundEnsembleable<byte[]> watched()
{    return GetConfigBuilderImpl.this.watched();}
e73f9d1e639699be33cd99acc10e7b68aa889e5a72a2940a902bda7a2443bf55
usingWatcher
public BackgroundEnsembleable<byte[]> usingWatcher(Watcher watcher)
{    return GetConfigBuilderImpl.this.usingWatcher(watcher);}
f7d11b9a94602421233067168a3102959d29eaaacb98c9fc75ce7c3567134f1e
usingWatcher
public BackgroundEnsembleable<byte[]> usingWatcher(CuratorWatcher watcher)
{    return GetConfigBuilderImpl.this.usingWatcher(watcher);}
155c71e8b816ffb9d640e1828fdbcee44c279feae76407c7fc059d095037c593
watched
public BackgroundEnsembleable<byte[]> watched()
{    watching = new Watching(client, true);    return new InternalBackgroundEnsembleable();}
e73f9d1e639699be33cd99acc10e7b68aa889e5a72a2940a902bda7a2443bf55
usingWatcher
public BackgroundEnsembleable<byte[]> usingWatcher(Watcher watcher)
{    watching = new Watching(client, watcher);    return new InternalBackgroundEnsembleable();}
f7d11b9a94602421233067168a3102959d29eaaacb98c9fc75ce7c3567134f1e
usingWatcher
public BackgroundEnsembleable<byte[]> usingWatcher(CuratorWatcher watcher)
{    watching = new Watching(client, watcher);    return new InternalBackgroundEnsembleable();}
ef6ebc3602aadae3bfedcf7c8ad5297224f8a0b2c6a9329f0db8bd40d08df118
inBackground
public ErrorListenerEnsembleable<byte[]> inBackground()
{    backgrounding = new Backgrounding(true);    return this;}
f0ef0e205efb0ab0be436cf84c0c5532818d04bb275141bd21d911709596318a
inBackground
public ErrorListenerEnsembleable<byte[]> inBackground(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
3932a35ba3884a47c800556ab415d84d67333060636511333ef8fe7d6e5c8a08
inBackground
public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
17e9d8bcbc9df0d1b0b21fb23ee81548df34c17e30b17e3773b39220f17e67ac
inBackground
public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
0eeff0a2e872d26a9c4b7723b6e9bddcfff3be077278a2cff3089889dc4839b4
inBackground
public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(callback, executor);    return this;}
e3f67eb7640e76816ed49c0172335d3fff06b1148ffb80997c4989dabc2cf822
inBackground
public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
eecfa95367a82b3f8da8b7af2a352e88ea7249956639617136fc5bf831e5c521
withUnhandledErrorListener
public Ensembleable<byte[]> withUnhandledErrorListener(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
0f3ca0eb808271d8fcb9b5552ff16f7afde8cf89e72faee12f313f3d10492916
forEnsemble
public byte[] forEnsemble() throws Exception
{    if (backgrounding.inBackground()) {        client.processBackgroundOperation(new OperationAndData<Void>(this, null, backgrounding.getCallback(), null, backgrounding.getContext(), watching), null);        return null;    } else {        return configInForeground();    }}
d391a7bad20f3f50e657432aab1f534b25627342dc9dc8625af73bf2ec2aadac
performBackgroundOperation
public void performBackgroundOperation(final OperationAndData<Void> operationAndData) throws Exception
{    try {        final TimeTrace trace = client.getZookeeperClient().startTracer("GetDataBuilderImpl-Background");        AsyncCallback.DataCallback callback = new AsyncCallback.DataCallback() {            @Override            public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {                watching.commitWatcher(rc, false);                trace.commit();                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.GET_CONFIG, rc, path, null, ctx, stat, data, null, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        };        if (watching.isWatched()) {            client.getZooKeeper().getConfig(true, callback, backgrounding.getContext());        } else {            client.getZooKeeper().getConfig(watching.getWatcher(ZooDefs.CONFIG_NODE), callback, backgrounding.getContext());        }    } catch (Throwable e) {        backgrounding.checkError(e, watching);    }}
8095a88fb8ba55a55093667b5b6bd6acf263ff0b62a4a48bc05f010dd6c85eea
processResult
public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
{    watching.commitWatcher(rc, false);    trace.commit();    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.GET_CONFIG, rc, path, null, ctx, stat, data, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
ae693945934e3a0a4458f75fc2dc8477baa846f0c5d4fbff6ed5ead85b404986
configInForeground
private byte[] configInForeground() throws Exception
{    TimeTrace trace = client.getZookeeperClient().startTracer("GetConfigBuilderImpl-Foreground");    try {        return RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<byte[]>() {            @Override            public byte[] call() throws Exception {                if (watching.isWatched()) {                    return client.getZooKeeper().getConfig(true, stat);                }                byte[] config = client.getZooKeeper().getConfig(watching.getWatcher(ZooDefs.CONFIG_NODE), stat);                watching.commitWatcher(KeeperException.NoNodeException.Code.OK.intValue(), false);                return config;            }        });    } finally {        trace.commit();    }}
83a7785785005bc10aa7aa2c88a1e360c37c5b49e1e383e61bc19ebb44d63db6
call
public byte[] call() throws Exception
{    if (watching.isWatched()) {        return client.getZooKeeper().getConfig(true, stat);    }    byte[] config = client.getZooKeeper().getConfig(watching.getWatcher(ZooDefs.CONFIG_NODE), stat);    watching.commitWatcher(KeeperException.NoNodeException.Code.OK.intValue(), false);    return config;}
ef6ebc3602aadae3bfedcf7c8ad5297224f8a0b2c6a9329f0db8bd40d08df118
inBackground
public ErrorListenerEnsembleable<byte[]> inBackground()
{    return GetConfigBuilderImpl.this.inBackground();}
f0ef0e205efb0ab0be436cf84c0c5532818d04bb275141bd21d911709596318a
inBackground
public ErrorListenerEnsembleable<byte[]> inBackground(Object context)
{    return GetConfigBuilderImpl.this.inBackground(context);}
3932a35ba3884a47c800556ab415d84d67333060636511333ef8fe7d6e5c8a08
inBackground
public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback)
{    return GetConfigBuilderImpl.this.inBackground(callback);}
17e9d8bcbc9df0d1b0b21fb23ee81548df34c17e30b17e3773b39220f17e67ac
inBackground
public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Object context)
{    return GetConfigBuilderImpl.this.inBackground(callback, context);}
0eeff0a2e872d26a9c4b7723b6e9bddcfff3be077278a2cff3089889dc4839b4
inBackground
public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Executor executor)
{    return GetConfigBuilderImpl.this.inBackground(callback, executor);}
e3f67eb7640e76816ed49c0172335d3fff06b1148ffb80997c4989dabc2cf822
inBackground
public ErrorListenerEnsembleable<byte[]> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    return GetConfigBuilderImpl.this.inBackground(callback, context, executor);}
0f3ca0eb808271d8fcb9b5552ff16f7afde8cf89e72faee12f313f3d10492916
forEnsemble
public byte[] forEnsemble() throws Exception
{    return GetConfigBuilderImpl.this.forEnsemble();}
496a87953f6e5b9d345c3ed68bfd043b0e7633b36a680c26916884bf9fc4f190
decompressed
public GetDataWatchBackgroundStatable decompressed()
{    decompress = true;    return new GetDataWatchBackgroundStatable() {        @Override        public ErrorListenerPathable<byte[]> inBackground() {            return GetDataBuilderImpl.this.inBackground();        }        @Override        public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback, Object context) {            return GetDataBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return GetDataBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public ErrorListenerPathable<byte[]> inBackground(Object context) {            return GetDataBuilderImpl.this.inBackground(context);        }        @Override        public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback) {            return GetDataBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback, Executor executor) {            return GetDataBuilderImpl.this.inBackground(callback, executor);        }        @Override        public byte[] forPath(String path) throws Exception {            return GetDataBuilderImpl.this.forPath(path);        }        @Override        public WatchPathable<byte[]> storingStatIn(Stat stat) {            return GetDataBuilderImpl.this.storingStatIn(stat);        }        @Override        public BackgroundPathable<byte[]> watched() {            return GetDataBuilderImpl.this.watched();        }        @Override        public BackgroundPathable<byte[]> usingWatcher(Watcher watcher) {            return GetDataBuilderImpl.this.usingWatcher(watcher);        }        @Override        public BackgroundPathable<byte[]> usingWatcher(CuratorWatcher watcher) {            return GetDataBuilderImpl.this.usingWatcher(watcher);        }    };}
6dd27b17a0cfde28cd883df898f6bfd57584c7942381cb5c98b48653474569e2
inBackground
public ErrorListenerPathable<byte[]> inBackground()
{    return GetDataBuilderImpl.this.inBackground();}
208d6fecb027337e3fd501dd7555780fbe2eb3d18da455c6a0892d3011db83f9
inBackground
public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback, Object context)
{    return GetDataBuilderImpl.this.inBackground(callback, context);}
65391ef306b9433a2d076d2d612b1aae592131281525b12c384ad1025b586732
inBackground
public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    return GetDataBuilderImpl.this.inBackground(callback, context, executor);}
0b1b7372a5fbf965aa0d623960255cf59d92cebf1c2effc275b66e41fa9dd836
inBackground
public ErrorListenerPathable<byte[]> inBackground(Object context)
{    return GetDataBuilderImpl.this.inBackground(context);}
3010d3f3a1b311ee296ba31903b8ec41e5117bd0cdd610a9546b0fe1e269f807
inBackground
public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback)
{    return GetDataBuilderImpl.this.inBackground(callback);}
7c13fe83e6c80e72362744059d11d04d9a062c09506ab82a14b4470f9d3b3200
inBackground
public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback, Executor executor)
{    return GetDataBuilderImpl.this.inBackground(callback, executor);}
7f46cf268f7e7a74def0fef4fd3d9c17af4d001ced1e388665af7e5af0e45194
forPath
public byte[] forPath(String path) throws Exception
{    return GetDataBuilderImpl.this.forPath(path);}
56ce8684336ffb3ca4fa9c00d518f760d668583917b8ea355f5f4f4d5f89682a
storingStatIn
public WatchPathable<byte[]> storingStatIn(Stat stat)
{    return GetDataBuilderImpl.this.storingStatIn(stat);}
e55e996ba8b6964c41b252c7daf57766211a4a1cfae792026ae90f21707afa07
watched
public BackgroundPathable<byte[]> watched()
{    return GetDataBuilderImpl.this.watched();}
248e8d34d07955f2ff20a53ed91068ebbea966d0353962e3270fb23d1ca1fd15
usingWatcher
public BackgroundPathable<byte[]> usingWatcher(Watcher watcher)
{    return GetDataBuilderImpl.this.usingWatcher(watcher);}
4f6b7da0c7d4a1cba2f5c0d0bf95bda9e9e6ec8aa71ba32d13ef72185503129d
usingWatcher
public BackgroundPathable<byte[]> usingWatcher(CuratorWatcher watcher)
{    return GetDataBuilderImpl.this.usingWatcher(watcher);}
56ce8684336ffb3ca4fa9c00d518f760d668583917b8ea355f5f4f4d5f89682a
storingStatIn
public WatchPathable<byte[]> storingStatIn(Stat stat)
{    this.responseStat = stat;    return new WatchPathable<byte[]>() {        @Override        public byte[] forPath(String path) throws Exception {            return GetDataBuilderImpl.this.forPath(path);        }        @Override        public Pathable<byte[]> watched() {            GetDataBuilderImpl.this.watched();            return GetDataBuilderImpl.this;        }        @Override        public Pathable<byte[]> usingWatcher(Watcher watcher) {            GetDataBuilderImpl.this.usingWatcher(watcher);            return GetDataBuilderImpl.this;        }        @Override        public Pathable<byte[]> usingWatcher(CuratorWatcher watcher) {            GetDataBuilderImpl.this.usingWatcher(watcher);            return GetDataBuilderImpl.this;        }    };}
7f46cf268f7e7a74def0fef4fd3d9c17af4d001ced1e388665af7e5af0e45194
forPath
public byte[] forPath(String path) throws Exception
{    return GetDataBuilderImpl.this.forPath(path);}
0cb9d4c8907418c05d44341f061ab4c54bee713bc591f1aa1fd89e0870bf46ca
watched
public Pathable<byte[]> watched()
{    GetDataBuilderImpl.this.watched();    return GetDataBuilderImpl.this;}
dd5ea573ca3241582cff6f6c6c362c33b9dc851a59bb33aaccd9acf44141579f
usingWatcher
public Pathable<byte[]> usingWatcher(Watcher watcher)
{    GetDataBuilderImpl.this.usingWatcher(watcher);    return GetDataBuilderImpl.this;}
c4b0865bacc7db9f6111ebce9e028362cd5bfcea2a720b0f868e8463c3adee1d
usingWatcher
public Pathable<byte[]> usingWatcher(CuratorWatcher watcher)
{    GetDataBuilderImpl.this.usingWatcher(watcher);    return GetDataBuilderImpl.this;}
208d6fecb027337e3fd501dd7555780fbe2eb3d18da455c6a0892d3011db83f9
inBackground
public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
65391ef306b9433a2d076d2d612b1aae592131281525b12c384ad1025b586732
inBackground
public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
3010d3f3a1b311ee296ba31903b8ec41e5117bd0cdd610a9546b0fe1e269f807
inBackground
public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
7c13fe83e6c80e72362744059d11d04d9a062c09506ab82a14b4470f9d3b3200
inBackground
public ErrorListenerPathable<byte[]> inBackground(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
6dd27b17a0cfde28cd883df898f6bfd57584c7942381cb5c98b48653474569e2
inBackground
public ErrorListenerPathable<byte[]> inBackground()
{    backgrounding = new Backgrounding(true);    return this;}
0b1b7372a5fbf965aa0d623960255cf59d92cebf1c2effc275b66e41fa9dd836
inBackground
public ErrorListenerPathable<byte[]> inBackground(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
3d90ca8cb9cdc47ffcdca5460fcb509b40e0a81fc46dbaddc345b64c8c012423
withUnhandledErrorListener
public Pathable<byte[]> withUnhandledErrorListener(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
e55e996ba8b6964c41b252c7daf57766211a4a1cfae792026ae90f21707afa07
watched
public BackgroundPathable<byte[]> watched()
{    watching = new Watching(client, true);    return this;}
248e8d34d07955f2ff20a53ed91068ebbea966d0353962e3270fb23d1ca1fd15
usingWatcher
public BackgroundPathable<byte[]> usingWatcher(Watcher watcher)
{    watching = new Watching(client, watcher);    return this;}
4f6b7da0c7d4a1cba2f5c0d0bf95bda9e9e6ec8aa71ba32d13ef72185503129d
usingWatcher
public BackgroundPathable<byte[]> usingWatcher(CuratorWatcher watcher)
{    watching = new Watching(client, watcher);    return this;}
772f79cf5c4af16a3e1cf67e610e3b66d770948915f9c0cca395686aa2e4f144
performBackgroundOperation
public void performBackgroundOperation(final OperationAndData<String> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("GetDataBuilderImpl-Background");        AsyncCallback.DataCallback callback = new AsyncCallback.DataCallback() {            @Override            public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {                watching.commitWatcher(rc, false);                trace.setReturnCode(rc).setResponseBytesLength(data).setPath(path).setWithWatcher(watching.hasWatcher()).setStat(stat).commit();                if ((responseStat != null) && (stat != null)) {                    DataTree.copyStat(stat, responseStat);                }                if (decompress && (data != null)) {                    try {                        data = client.getCompressionProvider().decompress(path, data);                    } catch (Exception e) {                        ThreadUtils.checkInterrupted(e);                        log.error("Decompressing for path: " + path, e);                        rc = KeeperException.Code.DATAINCONSISTENCY.intValue();                    }                }                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.GET_DATA, rc, path, null, ctx, stat, data, null, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        };        if (watching.isWatched()) {            client.getZooKeeper().getData(operationAndData.getData(), true, callback, backgrounding.getContext());        } else {            client.getZooKeeper().getData(operationAndData.getData(), watching.getWatcher(operationAndData.getData()), callback, backgrounding.getContext());        }    } catch (Throwable e) {        backgrounding.checkError(e, watching);    }}
8095a88fb8ba55a55093667b5b6bd6acf263ff0b62a4a48bc05f010dd6c85eea
processResult
public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat)
{    watching.commitWatcher(rc, false);    trace.setReturnCode(rc).setResponseBytesLength(data).setPath(path).setWithWatcher(watching.hasWatcher()).setStat(stat).commit();    if ((responseStat != null) && (stat != null)) {        DataTree.copyStat(stat, responseStat);    }    if (decompress && (data != null)) {        try {            data = client.getCompressionProvider().decompress(path, data);        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);            log.error("Decompressing for path: " + path, e);            rc = KeeperException.Code.DATAINCONSISTENCY.intValue();        }    }    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.GET_DATA, rc, path, null, ctx, stat, data, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
7f46cf268f7e7a74def0fef4fd3d9c17af4d001ced1e388665af7e5af0e45194
forPath
public byte[] forPath(String path) throws Exception
{    client.getSchemaSet().getSchema(path).validateWatch(path, watching.isWatched() || watching.hasWatcher());    path = client.fixForNamespace(path);    byte[] responseData = null;    if (backgrounding.inBackground()) {        client.processBackgroundOperation(new OperationAndData<String>(this, path, backgrounding.getCallback(), null, backgrounding.getContext(), watching), null);    } else {        responseData = pathInForeground(path);    }    return responseData;}
cb88e29bab47a6642c9d21d45eecbdcaa8fa40a279c6d1edc566d3c9cdee8ebf
pathInForeground
private byte[] pathInForeground(final String path) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("GetDataBuilderImpl-Foreground");    byte[] responseData = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<byte[]>() {        @Override        public byte[] call() throws Exception {            byte[] responseData;            if (watching.isWatched()) {                responseData = client.getZooKeeper().getData(path, true, responseStat);            } else {                responseData = client.getZooKeeper().getData(path, watching.getWatcher(path), responseStat);                watching.commitWatcher(KeeperException.NoNodeException.Code.OK.intValue(), false);            }            return responseData;        }    });    trace.setResponseBytesLength(responseData).setPath(path).setWithWatcher(watching.hasWatcher()).setStat(responseStat).commit();    return decompress ? client.getCompressionProvider().decompress(path, responseData) : responseData;}
83a7785785005bc10aa7aa2c88a1e360c37c5b49e1e383e61bc19ebb44d63db6
call
public byte[] call() throws Exception
{    byte[] responseData;    if (watching.isWatched()) {        responseData = client.getZooKeeper().getData(path, true, responseStat);    } else {        responseData = client.getZooKeeper().getData(path, watching.getWatcher(path), responseStat);        watching.commitWatcher(KeeperException.NoNodeException.Code.OK.intValue(), false);    }    return responseData;}
f8b18b7b56791d1b66b10365d8e5d5b866ae89f746b95bd421b98936ed48a11f
acquireDeflater
private static Deflater acquireDeflater()
{    Deflater deflater = DEFLATER_POOL.poll();    if (deflater == null) {                deflater = new Deflater(Deflater.DEFAULT_COMPRESSION, true);    }    return deflater;}
9506fb0a2610bcdfc5f5e3f90af6a49b587aad19b9ab53669a88f5eca820c91e
acquireInflater
private static Inflater acquireInflater()
{    Inflater inflater = INFLATER_POOL.poll();    if (inflater == null) {                inflater = new Inflater(true);    }    return inflater;}
06d5176229fa1a7824ea5b6490ef5358d42c27590ac532eccd8d3e08ba74054e
compress
public byte[] compress(String path, byte[] data)
{    if (data.length == 0) {                return COMPRESSED_EMPTY_BYTES.clone();    }    return doCompress(data);}
211537ca2d15fa48120f3bd2fa0462065c4277802159e204432ee8619dd971b3
doCompress
 static byte[] doCompress(byte[] data)
{    byte[] result = Arrays.copyOf(GZIP_HEADER, conservativeGZippedSizeEstimate(data.length));    Deflater deflater = acquireDeflater();    try {        deflater.setInput(data);        deflater.finish();        int offset = GZIP_HEADER_SIZE;        while (true) {            int available = result.length - GZIP_TRAILER_SIZE - offset;            int numCompressedBytes = deflater.deflate(result, offset, available);            offset += numCompressedBytes;            if (deflater.finished()) {                break;            }            int newResultLength = result.length + (result.length / 2);            result = Arrays.copyOf(result, newResultLength);        }                CRC32 crc = new CRC32();        crc.update(data, 0, data.length);        writeLittleEndianInt(result, offset, (int) crc.getValue());        writeLittleEndianInt(result, offset + 4, data.length);        int endOffset = offset + GZIP_TRAILER_SIZE;        if (result.length != endOffset) {            result = Arrays.copyOf(result, endOffset);        }        return result;    } finally {        deflater.reset();        DEFLATER_POOL.add(deflater);    }}
d2e527fd10b6db8445730b58f291beed679a179f9af3ef2818b5b3a7e8085f3e
conservativeGZippedSizeEstimate
private static int conservativeGZippedSizeEstimate(int dataSize)
{    int conservativeCompressedDataSizeEstimate;    if (dataSize < 512) {                conservativeCompressedDataSizeEstimate = Math.max(dataSize, MIN_COMPRESSED_DATA_SIZE);    } else {                conservativeCompressedDataSizeEstimate = Math.max(512, dataSize / 2);    }    return GZIP_HEADER_SIZE + conservativeCompressedDataSizeEstimate + GZIP_TRAILER_SIZE;}
bf8c0dca715408bbb7e5bd534aba0fcfdca063dea22b570503f466eb4347b89f
writeLittleEndianInt
private static void writeLittleEndianInt(byte[] b, int offset, int v)
{    b[offset] = (byte) v;    b[offset + 1] = (byte) (v >> 8);    b[offset + 2] = (byte) (v >> 16);    b[offset + 3] = (byte) (v >> 24);}
7e056d7038254fae789146a88a5263c0826f10359e1fee3e51bb3b632f51c75e
decompress
public byte[] decompress(String path, byte[] gzippedDataBytes) throws IOException
{    if (Arrays.equals(gzippedDataBytes, COMPRESSED_EMPTY_BYTES)) {                return new byte[0];    }    ByteBuffer gzippedData = ByteBuffer.wrap(gzippedDataBytes);    gzippedData.order(ByteOrder.LITTLE_ENDIAN);    int headerSize = readGzipHeader(gzippedData);    if (gzippedDataBytes.length < headerSize + MIN_COMPRESSED_DATA_SIZE + GZIP_TRAILER_SIZE) {        throw new EOFException("Too short GZipped data");    }    int compressedDataSize = gzippedDataBytes.length - headerSize - GZIP_TRAILER_SIZE;            int initialResultLength = (int) Math.min(compressedDataSize * 3L, MAX_SAFE_JAVA_BYTE_ARRAY_SIZE);    byte[] result = new byte[initialResultLength];    Inflater inflater = acquireInflater();    try {        inflater.setInput(gzippedDataBytes, headerSize, compressedDataSize);        CRC32 crc = new CRC32();        int offset = 0;        while (true) {            int numDecompressedBytes;            try {                numDecompressedBytes = inflater.inflate(result, offset, result.length - offset);            } catch (DataFormatException e) {                String s = e.getMessage();                throw new ZipException(s != null ? s : "Invalid ZLIB data format");            }            crc.update(result, offset, numDecompressedBytes);            offset += numDecompressedBytes;            if (inflater.finished() || inflater.needsDictionary()) {                break;            } else             if (numDecompressedBytes == 0 && inflater.needsInput()) {                throw new ZipException("Corrupt GZipped data");            }                        if (result.length == MAX_SAFE_JAVA_BYTE_ARRAY_SIZE && numDecompressedBytes == 0) {                throw new OutOfMemoryError("Unable to uncompress that much data into a single byte[] array");            }            int newResultLength = (int) Math.min((long) result.length + (result.length / 2), MAX_SAFE_JAVA_BYTE_ARRAY_SIZE);            if (result.length != newResultLength) {                result = Arrays.copyOf(result, newResultLength);            }        }        if (inflater.getRemaining() != 0) {            throw new ZipException("Expected just one GZip block, without garbage in the end");        }        int checksum = gzippedData.getInt(gzippedDataBytes.length - GZIP_TRAILER_SIZE);        int numUncompressedBytes = gzippedData.getInt(gzippedDataBytes.length - Integer.BYTES);        if (checksum != (int) crc.getValue() || numUncompressedBytes != offset) {            throw new ZipException("Corrupt GZIP trailer");        }        if (result.length != offset) {            result = Arrays.copyOf(result, offset);        }        return result;    } finally {        inflater.reset();        INFLATER_POOL.add(inflater);    }}
9949819bf06171b5e4174f75fb44fc9894b61ddfad82a660f20ca08fa2843fc2
readGzipHeader
private static int readGzipHeader(ByteBuffer gzippedData) throws IOException
{    try {        return doReadHeader(gzippedData);    } catch (BufferUnderflowException e) {        throw new EOFException();    }}
d95d336f6104c5338ea56e204109fb62289f24b4d6b7b3da177ece596dd3eb4d
doReadHeader
private static int doReadHeader(ByteBuffer gzippedData) throws IOException
{    if (gzippedData.getChar() != GZIP_MAGIC) {        throw new ZipException("Not in GZip format");    }    if (gzippedData.get() != Deflater.DEFLATED) {        throw new ZipException("Unsupported compression method");    }    int flags = gzippedData.get();        skip(gzippedData, Integer.BYTES + Byte.BYTES + Byte.BYTES);    if ((flags & FEXTRA) != 0) {        int extraBytes = gzippedData.getChar();        skip(gzippedData, extraBytes);    }    if ((flags & FNAME) != 0) {        skipZeroTerminatedString(gzippedData);    }    if ((flags & FCOMMENT) != 0) {        skipZeroTerminatedString(gzippedData);    }    if ((flags & FHCRC) != 0) {        CRC32 crc = new CRC32();        crc.update(gzippedData.array(), 0, gzippedData.position());        if (gzippedData.getChar() != (char) crc.getValue()) {            throw new ZipException("Corrupt GZIP header");        }    }    return gzippedData.position();}
8af30a44a9a5420a0f9e62bbaa1f6b3479ad15f0283fb3f76044ea3bf11861de
skip
private static void skip(ByteBuffer gzippedData, int skipBytes) throws IOException
{    try {        gzippedData.position(gzippedData.position() + skipBytes);    } catch (IllegalArgumentException e) {        throw new EOFException();    }}
ed79a6fb585bbe49bef4349f3499cae293afeb9f8a4a1891465c478935d1f120
skipZeroTerminatedString
private static void skipZeroTerminatedString(ByteBuffer gzippedData)
{    while (gzippedData.get() != 0) {        }}
411c752dd6216d607d8e41e08f5e5dac702f4a22b060d3c4efc7c0b9a31bf3bf
nonNamespaceView
public CuratorFramework nonNamespaceView()
{    return usingNamespace(null);}
a20a1c4db3f9eb8e0d93485fdc63395cbf99a245461e6cb67abf55a83545c791
usingNamespace
public CuratorFramework usingNamespace(String newNamespace)
{    return client.getNamespaceFacadeCache().get(newNamespace);}
4c9ff74e20a72d5f7b2e4ef2a83e03a78836fed625f24259c12254b95b6af94e
getNamespace
public String getNamespace()
{    return namespace.getNamespace();}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    throw new UnsupportedOperationException();}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    throw new UnsupportedOperationException();}
e13808d604e8405be03413186c4b9e1c036656eb1d7fdefea0574a05483395d0
getConnectionStateListenable
public Listenable<ConnectionStateListener> getConnectionStateListenable()
{    return client.getConnectionStateListenable();}
dcaa652392e0c28ee05a36caa484c21329a1a09da88222252de7c461a9964230
getCuratorListenable
public Listenable<CuratorListener> getCuratorListenable()
{    throw new UnsupportedOperationException("getCuratorListenable() is only available from a non-namespaced CuratorFramework instance");}
b3d8c32fff49d6f84e3a03fa63c3aa3356dba76f0989aaae6638b46c12e3fdb0
getUnhandledErrorListenable
public Listenable<UnhandledErrorListener> getUnhandledErrorListenable()
{    return client.getUnhandledErrorListenable();}
89fa8cee5a80c3c832aa26455ab863bb32958b9ff2d86ec97d576ef4958933df
sync
public void sync(String path, Object context)
{    internalSync(this, path, context);}
1d6b70d040ccf31742e2278edbc6eab66dfccd1c6a0761b8b0eef130170256d1
getZookeeperClient
public CuratorZookeeperClient getZookeeperClient()
{    return client.getZookeeperClient();}
faa4514c18ba98064e265893a20e8e9ebf226051659272f3f597d33539ec9913
newRetryLoop
 RetryLoop newRetryLoop()
{    return client.newRetryLoop();}
f0891f7aab88f7cc4a33be47483c9249645409f0730f2bb08db5362769b1e641
getZooKeeper
 ZooKeeper getZooKeeper() throws Exception
{    return client.getZooKeeper();}
df03d11e4a696d15f707f9e0394cc5b23269c61fcd4637dfadd091ad90b2dee2
processBackgroundOperation
 void processBackgroundOperation(OperationAndData<DATA_TYPE> operationAndData, CuratorEvent event)
{    client.processBackgroundOperation(operationAndData, event);}
64cccd40db71e98e34316d2a61669cf8515e60b5bc310c71b5190444683b4154
logError
 void logError(String reason, Throwable e)
{    client.logError(reason, e);}
ec4e3ff02955c9ca8410bea65fe8ddcaa62e279f69bcff6e392341925f5a4dfb
unfixForNamespace
 String unfixForNamespace(String path)
{    return namespace.unfixForNamespace(path);}
1c998b5f31649a92e51dff1bc4186c8b9c281827723b902c76057701438d645c
fixForNamespace
 String fixForNamespace(String path)
{    return namespace.fixForNamespace(path, false);}
b43f3db7d08c9ce08b475c2334e8d41779026595caf40ca66256252b64c14ee2
fixForNamespace
 String fixForNamespace(String path, boolean isSequential)
{    return namespace.fixForNamespace(path, isSequential);}
1a15c389a2462368adce86012e6c68b530da2423eeed3e402f3d953e8442abc3
newNamespaceAwareEnsurePath
public EnsurePath newNamespaceAwareEnsurePath(String path)
{    return namespace.newNamespaceAwareEnsurePath(path);}
ebaaa6145951e4ae92905d3aae1c3de253d75f64dcf0a84a35bd373a8aa2dca1
getFailedDeleteManager
 FailedDeleteManager getFailedDeleteManager()
{    return failedDeleteManager;}
8b4f04c347344a156510d1505f942c7a3f7047b131295608e67c8018392c5820
load
public NamespaceFacade load(String namespace) throws Exception
{    return new NamespaceFacade(client, namespace);}
aad48f8b53f2e0e2d0206a91201a402dd176adcf94fe5d56fd844b6113278bf4
get
 NamespaceFacade get(String namespace)
{    try {        return (namespace != null) ? cache.get(namespace) : nullNamespace;    } catch (ExecutionException e) {                throw new RuntimeException(e);    }}
83ce14258f16044d9f7fa25d1dd0058a1e84c1370d5c93a169714b9e2d071697
getNamespace
 String getNamespace()
{    return namespace;}
ec4e3ff02955c9ca8410bea65fe8ddcaa62e279f69bcff6e392341925f5a4dfb
unfixForNamespace
 String unfixForNamespace(String path)
{    if ((namespace != null) && (path != null)) {        String namespacePath = ZKPaths.makePath(namespace, null);        if (!namespacePath.equals("/") && path.startsWith(namespacePath)) {            path = (path.length() > namespacePath.length()) ? path.substring(namespacePath.length()) : "/";        }    }    return path;}
b43f3db7d08c9ce08b475c2334e8d41779026595caf40ca66256252b64c14ee2
fixForNamespace
 String fixForNamespace(String path, boolean isSequential)
{    if (ensurePathNeeded.get()) {        try {            final CuratorZookeeperClient zookeeperClient = client.getZookeeperClient();            RetryLoop.callWithRetry(zookeeperClient, new Callable<Object>() {                @Override                public Object call() throws Exception {                    ZKPaths.mkdirs(zookeeperClient.getZooKeeper(), ZKPaths.makePath("/", namespace), true, client.getAclProvider(), true);                    return null;                }            });            ensurePathNeeded.set(false);        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);            client.logError("Ensure path threw exception", e);        }    }    return ZKPaths.fixForNamespace(namespace, path, isSequential);}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    ZKPaths.mkdirs(zookeeperClient.getZooKeeper(), ZKPaths.makePath("/", namespace), true, client.getAclProvider(), true);    return null;}
9ca1ba970938301422eb05f53bd073c157399ee373804ad5bfb86c0928e744ea
newNamespaceAwareEnsurePath
 EnsurePath newNamespaceAwareEnsurePath(String path)
{    return new EnsurePath(fixForNamespace(path, false), client.getAclProvider());}
dd4b335d1fb156b5f96e922d3488448a70e3466ea44a604866d86292281caee8
getUnfixedPath
 String getUnfixedPath()
{    return unfixedPath;}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    client = null;    actualWatcher = null;    curatorWatcher = null;}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (client != null) {        if ((event.getType() != Event.EventType.None) && (client.getWatcherRemovalManager() != null)) {            client.getWatcherRemovalManager().noteTriggeredWatcher(this);        }        if (actualWatcher != null) {            actualWatcher.process(new NamespaceWatchedEvent(client, event));        } else if (curatorWatcher != null) {            try {                curatorWatcher.process(new NamespaceWatchedEvent(client, event));            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                client.logError("Watcher exception", e);            }        }    }}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null) {        return false;    }    if (getClass() == o.getClass()) {        NamespaceWatcher watcher = (NamespaceWatcher) o;        return Objects.equal(unfixedPath, watcher.getUnfixedPath()) && Objects.equal(actualWatcher, watcher.actualWatcher) && Objects.equal(curatorWatcher, watcher.curatorWatcher);    }    return false;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return Objects.hashCode(actualWatcher, unfixedPath, curatorWatcher);}
e81ce61afa6023c409f59e893a8e2992ea2dc468dba82aa6b7b33dc22be7eaff
reset
 void reset()
{    retryCount.set(0);    ordinal.set(nextOrdinal.getAndIncrement());}
de3d0345a88bdcea1eb11d641534fa2b3646d9d4ca97ccaf03dcfea9a9332b66
getContext
 Object getContext()
{    return context;}
249544b16ccf046911d1f5d78ee25ac3e021504e33cfd54a5dd15ed2eb73e9e6
isConnectionRequired
 boolean isConnectionRequired()
{    return connectionRequired;}
a7ff3c805f0c9722465732ca190001bed752435a5318fad9aabff0cb08b488c3
callPerformBackgroundOperation
 void callPerformBackgroundOperation() throws Exception
{    operation.performBackgroundOperation(this);}
50e2334adb110f9d9247972e17d0aaa612573783ee3c58a9febcfd6a1e45a896
getData
 T getData()
{    return data;}
329eb929602a9f934e9d8037714234562e9fbb9a59469ebbd624d30b5c90e67c
getElapsedTimeMs
 long getElapsedTimeMs()
{    return System.currentTimeMillis() - startTimeMs;}
1302d987c6283bfadc616f8626068fba2c68fbae9f1df1850295d451f5d5585d
getThenIncrementRetryCount
 int getThenIncrementRetryCount()
{    return retryCount.getAndIncrement();}
3486c8d8fd8de4a400ec277893382f706da1a0624965af99c58b1d882cd6dc9a
getCallback
 BackgroundCallback getCallback()
{    return callback;}
af87e8e534e4c9e0b9b30606e10ea5c8e6015bca3010f9a19132c3ab43b781ec
getErrorCallback
 ErrorCallback<T> getErrorCallback()
{    return errorCallback;}
9e14381352a34e864e89bb249359691cbafb91d54a63963a36fa773409f95519
getOperation
 BackgroundOperation<T> getOperation()
{    return operation;}
895c7091adf4c106c73287342ab7791e93b8d96dd99911feed790079d141659d
clearSleep
 void clearSleep()
{    sleepUntilTimeMs.set(0);}
5de58f59177c048d3f81181f0477ce1ef69d9762bb905ab72e907c2986f6a73f
sleepFor
public void sleepFor(long time, TimeUnit unit) throws InterruptedException
{    sleepUntilTimeMs.set(System.currentTimeMillis() + TimeUnit.MILLISECONDS.convert(time, unit));}
50a6ed0c895001f8d6a270a436bb8cd954bd54eeb309d1a0bbfbc7bf60b82505
getDelay
public long getDelay(TimeUnit unit)
{    return unit.convert(sleepUntilTimeMs.get() - System.currentTimeMillis(), TimeUnit.MILLISECONDS);}
fe2ed50417abd6f7fc316fe571d8e61f4108e685e86e33c0f819bbd54691810b
compareTo
public int compareTo(Delayed o)
{    if (o == this) {        return 0;    }    long diff = getDelay(TimeUnit.MILLISECONDS) - o.getDelay(TimeUnit.MILLISECONDS);    if (diff == 0) {        if (o instanceof OperationAndData) {            diff = ordinal.get() - ((OperationAndData) o).ordinal.get();        }    }    return (diff < 0) ? -1 : ((diff > 0) ? 1 : 0);}
944b41f44ac3191c402116f23c93048495c7b4b411a12817daebbc391c20e01f
getPath
 String getPath()
{    return path;}
d7620fd719a908c8e70d2ed09444dbfecccb5c8f880f191eb48650f2b409dfa3
getData
 byte[] getData()
{    return data;}
a162d0c129ae3e5f03b62e5a4423ef3cd059db8393370bfda10633590b0d314d
setProtectedMode
 void setProtectedMode()
{    doProtected = true;    resetProtectedId();}
6fecdc2686cac161bf1ea3720fa155cf575e4c447c3d9295ae8fb3deab21904f
resetProtectedId
 void resetProtectedId()
{    protectedId = UUID.randomUUID().toString();}
ed0dec960f4a194ce82c44d0dbb72dc123a7e6f21e86961f2d46e947fbb03ac2
doProtected
 boolean doProtected()
{    return doProtected;}
74baf04c4f68885817b76446b2001de472ee844ca8755cbf17f5f7215b326a19
protectedId
 String protectedId()
{    return protectedId;}
ac9b8da1285f41e82513f4d2a713fbdb8a96e354a366663d43ddf8ee1bc8d91f
checkSetSessionId
 void checkSetSessionId(CuratorFrameworkImpl client, CreateMode createMode) throws Exception
{    if (doProtected && (sessionId == 0) && createMode.isEphemeral()) {        sessionId = client.getZooKeeper().getSessionId();    }}
6fc013f318dec36146bd0edc28dcf69fc10b83517eda6c569ed8a44027186a85
validateFoundNode
 String validateFoundNode(CuratorFrameworkImpl client, CreateMode createMode, String foundNode) throws Exception
{    if (doProtected && createMode.isEphemeral()) {        long clientSessionId = client.getZooKeeper().getSessionId();        if (this.sessionId != clientSessionId) {            log.info("Session has changed during protected mode with ephemeral. old: {} new: {}", this.sessionId, clientSessionId);            if (foundNode != null) {                log.info("Deleted old session's found node: {}", foundNode);                client.getFailedDeleteManager().executeGuaranteedOperationInBackground(foundNode);                foundNode = null;            }            this.sessionId = clientSessionId;        }    }    return foundNode;}
0f3ca0eb808271d8fcb9b5552ff16f7afde8cf89e72faee12f313f3d10492916
forEnsemble
public byte[] forEnsemble() throws Exception
{    if (backgrounding.inBackground()) {        client.processBackgroundOperation(new OperationAndData<>(this, null, backgrounding.getCallback(), null, backgrounding.getContext(), null), null);        return new byte[0];    } else {        return ensembleInForeground();    }}
1ba0ec4817cabbc3d5b552203ba453fb972477aa6ec098d450153724d1d1f67a
inBackground
public ErrorListenerReconfigBuilderMain inBackground()
{    backgrounding = new Backgrounding(true);    return this;}
c4ece6badf06d5abb6b7afff4d03c0a156a07964acb04ce24d91e51c5812170f
inBackground
public ErrorListenerReconfigBuilderMain inBackground(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
3b46002623ba7b55af966c02665f4b7f9a9874b1b4d95139ecc8a568f9ce4040
inBackground
public ErrorListenerReconfigBuilderMain inBackground(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
1eed0567a66c956ffa3d235b08476eef38202b13be348c3c7145bf07b2a51ebd
inBackground
public ErrorListenerReconfigBuilderMain inBackground(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
04b0f5271e8ccbd2bdd6cc531ac8a569924ae0e5bbff70ee4adfc677c127934c
inBackground
public ErrorListenerReconfigBuilderMain inBackground(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(callback, executor);    return this;}
b2331add21449a4d3ca5e99c49bb7e94f2cbfa9bf57785c9d65f5e402e59efcc
inBackground
public ErrorListenerReconfigBuilderMain inBackground(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
badabd56d417ea9d0257810fc1dccdfcb26c2058ecde0d773ae66ad4b6b2df2a
withUnhandledErrorListener
public ReconfigBuilderMain withUnhandledErrorListener(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
d3e9185b0fd36705a68a228a9530f540d859a20627afe4ed0bcd21931755741d
withNewMembers
public StatConfigureEnsembleable withNewMembers(String... server)
{    return withNewMembers((server != null) ? Arrays.asList(server) : null);}
e71a948f20532a7783320afa6410dd5318affa8e8d2d5c7b6b936d92219b7b62
withNewMembers
public StatConfigureEnsembleable withNewMembers(List<String> servers)
{    newMembers = (servers != null) ? ImmutableList.copyOf(servers) : ImmutableList.<String>of();    return new StatConfigureEnsembleable() {        @Override        public Ensembleable<byte[]> fromConfig(long config) throws Exception {            fromConfig = config;            return this;        }        @Override        public byte[] forEnsemble() throws Exception {            return ReconfigBuilderImpl.this.forEnsemble();        }        @Override        public ConfigureEnsembleable storingStatIn(Stat stat) {            responseStat = stat;            return this;        }    };}
7792631aa90274de47c02e6271976695630b64d1596ea77de67f08ada9ff4602
fromConfig
public Ensembleable<byte[]> fromConfig(long config) throws Exception
{    fromConfig = config;    return this;}
0f3ca0eb808271d8fcb9b5552ff16f7afde8cf89e72faee12f313f3d10492916
forEnsemble
public byte[] forEnsemble() throws Exception
{    return ReconfigBuilderImpl.this.forEnsemble();}
7a3c708de4f45daf9b1228cda72cc1c4bb54e6c478a32663a3a5a582fb39730e
storingStatIn
public ConfigureEnsembleable storingStatIn(Stat stat)
{    responseStat = stat;    return this;}
50a57756c1a71930523b5000adb7281dc0776297da46b9bea2274edf9ae85474
joining
public LeaveStatConfigEnsembleable joining(String... server)
{    return joining((server != null) ? Arrays.asList(server) : null);}
b83d45bc71f0c7638c70cd80e92926028cec7046f3009ef38138465804a62672
joining
public LeaveStatConfigEnsembleable joining(List<String> servers)
{    joining = (servers != null) ? ImmutableList.copyOf(servers) : ImmutableList.<String>of();    return new LeaveStatConfigEnsembleable() {        @Override        public byte[] forEnsemble() throws Exception {            return ReconfigBuilderImpl.this.forEnsemble();        }        @Override        public ConfigureEnsembleable storingStatIn(Stat stat) {            responseStat = stat;            return this;        }        @Override        public Ensembleable<byte[]> fromConfig(long config) throws Exception {            fromConfig = config;            return this;        }        @Override        public JoinStatConfigEnsembleable leaving(String... server) {            return ReconfigBuilderImpl.this.leaving(server);        }        @Override        public JoinStatConfigEnsembleable leaving(List<String> servers) {            return ReconfigBuilderImpl.this.leaving(servers);        }    };}
0f3ca0eb808271d8fcb9b5552ff16f7afde8cf89e72faee12f313f3d10492916
forEnsemble
public byte[] forEnsemble() throws Exception
{    return ReconfigBuilderImpl.this.forEnsemble();}
7a3c708de4f45daf9b1228cda72cc1c4bb54e6c478a32663a3a5a582fb39730e
storingStatIn
public ConfigureEnsembleable storingStatIn(Stat stat)
{    responseStat = stat;    return this;}
7792631aa90274de47c02e6271976695630b64d1596ea77de67f08ada9ff4602
fromConfig
public Ensembleable<byte[]> fromConfig(long config) throws Exception
{    fromConfig = config;    return this;}
d3cf940061bda7e42e664c868f88f28f1e30649d796748827bc9d9626a4ba110
leaving
public JoinStatConfigEnsembleable leaving(String... server)
{    return ReconfigBuilderImpl.this.leaving(server);}
30187d319a6704055c68dfbdcbe2b38a155e42be47d1a83532b1d78481d14f63
leaving
public JoinStatConfigEnsembleable leaving(List<String> servers)
{    return ReconfigBuilderImpl.this.leaving(servers);}
d3cf940061bda7e42e664c868f88f28f1e30649d796748827bc9d9626a4ba110
leaving
public JoinStatConfigEnsembleable leaving(String... server)
{    return leaving((server != null) ? Arrays.asList(server) : null);}
30187d319a6704055c68dfbdcbe2b38a155e42be47d1a83532b1d78481d14f63
leaving
public JoinStatConfigEnsembleable leaving(List<String> servers)
{    leaving = (servers != null) ? ImmutableList.copyOf(servers) : ImmutableList.<String>of();    return new JoinStatConfigEnsembleable() {        @Override        public byte[] forEnsemble() throws Exception {            return ReconfigBuilderImpl.this.forEnsemble();        }        @Override        public ConfigureEnsembleable storingStatIn(Stat stat) {            responseStat = stat;            return this;        }        @Override        public Ensembleable<byte[]> fromConfig(long config) throws Exception {            fromConfig = config;            return this;        }        @Override        public LeaveStatConfigEnsembleable joining(String... server) {            return joining((server != null) ? Arrays.asList(server) : null);        }        @Override        public LeaveStatConfigEnsembleable joining(List<String> servers) {            return ReconfigBuilderImpl.this.joining(servers);        }    };}
0f3ca0eb808271d8fcb9b5552ff16f7afde8cf89e72faee12f313f3d10492916
forEnsemble
public byte[] forEnsemble() throws Exception
{    return ReconfigBuilderImpl.this.forEnsemble();}
7a3c708de4f45daf9b1228cda72cc1c4bb54e6c478a32663a3a5a582fb39730e
storingStatIn
public ConfigureEnsembleable storingStatIn(Stat stat)
{    responseStat = stat;    return this;}
7792631aa90274de47c02e6271976695630b64d1596ea77de67f08ada9ff4602
fromConfig
public Ensembleable<byte[]> fromConfig(long config) throws Exception
{    fromConfig = config;    return this;}
50a57756c1a71930523b5000adb7281dc0776297da46b9bea2274edf9ae85474
joining
public LeaveStatConfigEnsembleable joining(String... server)
{    return joining((server != null) ? Arrays.asList(server) : null);}
b83d45bc71f0c7638c70cd80e92926028cec7046f3009ef38138465804a62672
joining
public LeaveStatConfigEnsembleable joining(List<String> servers)
{    return ReconfigBuilderImpl.this.joining(servers);}
e21c4340a9546d55cfc4ab9e8f47c9b4db8c87beabbdd3f06c6500ca588fd6c1
performBackgroundOperation
public void performBackgroundOperation(final OperationAndData<Void> data) throws Exception
{    try {        final TimeTrace trace = client.getZookeeperClient().startTracer("ReconfigBuilderImpl-Background");        AsyncCallback.DataCallback callback = new AsyncCallback.DataCallback() {            @Override            public void processResult(int rc, String path, Object ctx, byte[] bytes, Stat stat) {                trace.commit();                if ((responseStat != null) && (stat != null)) {                    DataTree.copyStat(stat, responseStat);                }                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.RECONFIG, rc, path, null, ctx, stat, bytes, null, null, null, null);                client.processBackgroundOperation(data, event);            }        };        client.getZooKeeper().reconfig(joining, leaving, newMembers, fromConfig, callback, backgrounding.getContext());    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
ec9cee82204e6e1fdc8aca9074c381388d7d18c188d303d1a5f57951b9fdf34f
processResult
public void processResult(int rc, String path, Object ctx, byte[] bytes, Stat stat)
{    trace.commit();    if ((responseStat != null) && (stat != null)) {        DataTree.copyStat(stat, responseStat);    }    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.RECONFIG, rc, path, null, ctx, stat, bytes, null, null, null, null);    client.processBackgroundOperation(data, event);}
9de974564e066e258d26b91d751778c10c34938d998f65846ddea0ffbe010d89
ensembleInForeground
private byte[] ensembleInForeground() throws Exception
{    TimeTrace trace = client.getZookeeperClient().startTracer("ReconfigBuilderImpl-Foreground");    byte[] responseData = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<byte[]>() {        @Override        public byte[] call() throws Exception {            return client.getZooKeeper().reconfig(joining, leaving, newMembers, fromConfig, responseStat);        }    });    trace.commit();    return responseData;}
83a7785785005bc10aa7aa2c88a1e360c37c5b49e1e383e61bc19ebb44d63db6
call
public byte[] call() throws Exception
{    return client.getZooKeeper().reconfig(joining, leaving, newMembers, fromConfig, responseStat);}
8cc3fed7deb80edee4d7183f482ae5960a764a9961ad6340a6f0de60ac1820e6
internalRemoval
 void internalRemoval(Watcher watcher, String path) throws Exception
{    this.watcher = watcher;    watcherType = WatcherType.Any;    quietly = true;    guaranteed = true;    if (Boolean.getBoolean(DebugUtils.PROPERTY_REMOVE_WATCHERS_IN_FOREGROUND)) {        this.backgrounding = new Backgrounding();        pathInForeground(path);    } else {        this.backgrounding = new Backgrounding(true);        pathInBackground(path);    }}
f2ebd7da2b8ebbcb4986152f07d3964b31cc33f3c450f5f5933db3fc7a0b14d4
remove
public RemoveWatchesType remove(Watcher watcher)
{    this.watcher = watcher;    this.curatorWatcher = null;    return this;}
7cfd09ee5267b3ad008ad9b58ff8339f283d08c88a9ade438ab62790dfc41f32
remove
public RemoveWatchesType remove(CuratorWatcher watcher)
{    this.watcher = null;    this.curatorWatcher = watcher;    return this;}
873334e0ce61e0b2e65631f43e488778182d265de76932c64586f9ad9365e69b
removeAll
public RemoveWatchesType removeAll()
{    this.watcher = null;    this.curatorWatcher = null;    return this;}
d176299822177bb81e2c250627b6539cbb08c0bf6856a101e14485b623f89e7f
ofType
public RemoveWatchesLocal ofType(WatcherType watcherType)
{    this.watcherType = watcherType;    return this;}
34cee117719f9e8afbe0e19984b4f0ddf616e1298a89c5bf5cfd28e6df2b8ce6
inBackground
public ErrorListenerPathable<Void> inBackground(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
8fc2882e551603e6f04a3080c4df91a07a5716b4e49512020ae6bc8ff34193d5
inBackground
public ErrorListenerPathable<Void> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
b07ef64d8ae6fdc8f2165ccbe5182c8f027e5e71e2fdfe20fd6d32fc37d86361
inBackground
public ErrorListenerPathable<Void> inBackground(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
9a1a177a2a5c105b8c51cce1c88513c86e5f2cc0c54bc39b45f78bcab4e7ff6a
inBackground
public ErrorListenerPathable<Void> inBackground(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
432b3e2dd1c388f8c64000f2ce1822cf59ab8e6b968d54626e8a5db9349e2d5e
inBackground
public ErrorListenerPathable<Void> inBackground()
{    backgrounding = new Backgrounding(true);    return this;}
62988fed96608d5aed7f71052bf14f8688ce2d11e60964236538609bbbc577e5
inBackground
public ErrorListenerPathable<Void> inBackground(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
b30687aba7550ec7f699cd31b3de92272489b3de82641c094c05df75193eb336
withUnhandledErrorListener
public Pathable<Void> withUnhandledErrorListener(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
dce0478c217836b6d535c1192feab3b3e1271ec73e6ded65ba682f57d50ed014
guaranteed
public RemoveWatchesLocal guaranteed()
{    guaranteed = true;    return this;}
b1611a349773f82afb39e2fcd5d2de51b6aa5cbee47b229d5a1aad9e3246d2d7
locally
public BackgroundPathableQuietlyable<Void> locally()
{    local = true;    return this;}
bd6d4114a433bb145159bdc6b3bd90d69c3ad86ba292e0163e20be7b9fa717d2
quietly
public BackgroundPathable<Void> quietly()
{    quietly = true;    return this;}
012300743f62d93bdc1341b856be6212f1beeef6472d9e490d9be52dda2292f2
forPath
public Void forPath(String path) throws Exception
{    final String adjustedPath = client.fixForNamespace(path);    if (backgrounding.inBackground()) {        pathInBackground(adjustedPath);    } else {        pathInForeground(adjustedPath);    }    return null;}
9fb8dc026c0d938b5a345bd8a576792e2f737dadf033273a15607c128f9701a5
pathInBackground
private void pathInBackground(final String path)
{    OperationAndData.ErrorCallback<String> errorCallback = null;        if (guaranteed) {        errorCallback = new OperationAndData.ErrorCallback<String>() {            @Override            public void retriesExhausted(OperationAndData<String> operationAndData) {                client.getFailedRemoveWatcherManager().addFailedOperation(new FailedRemoveWatchManager.FailedRemoveWatchDetails(path, watcher));            }        };    }    client.processBackgroundOperation(new OperationAndData<String>(this, path, backgrounding.getCallback(), errorCallback, backgrounding.getContext(), !local), null);}
154069a6dfe6c6202d51162d5c67154f5781e4e4165afa7eb4d6499e4e0c349d
retriesExhausted
public void retriesExhausted(OperationAndData<String> operationAndData)
{    client.getFailedRemoveWatcherManager().addFailedOperation(new FailedRemoveWatchManager.FailedRemoveWatchDetails(path, watcher));}
f07060c6f2a2027b2da1eb6e26dfe79c6716ca0bf7c1eb4f483795a3306e7d80
pathInForeground
private void pathInForeground(final String path) throws Exception
{    NamespaceWatcher namespaceWatcher = makeNamespaceWatcher(path);        if (local) {        ZooKeeper zkClient = client.getZooKeeper();        if (namespaceWatcher != null) {            zkClient.removeWatches(path, namespaceWatcher, watcherType, local);        } else {            zkClient.removeAllWatches(path, watcherType, local);        }    } else {        final NamespaceWatcher finalNamespaceWatcher = namespaceWatcher;        RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<Void>() {            @Override            public Void call() throws Exception {                try {                    ZooKeeper zkClient = client.getZookeeperClient().getZooKeeper();                    if (finalNamespaceWatcher != null) {                        zkClient.removeWatches(path, finalNamespaceWatcher, watcherType, false);                    } else {                        zkClient.removeAllWatches(path, watcherType, false);                    }                } catch (Exception e) {                    if (RetryLoop.isRetryException(e) && guaranteed) {                                                client.getFailedRemoveWatcherManager().addFailedOperation(new FailedRemoveWatchManager.FailedRemoveWatchDetails(path, finalNamespaceWatcher));                        throw e;                    } else if (e instanceof KeeperException.NoWatcherException && quietly) {                                        } else {                                                throw e;                    }                }                return null;            }        });    }}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    try {        ZooKeeper zkClient = client.getZookeeperClient().getZooKeeper();        if (finalNamespaceWatcher != null) {            zkClient.removeWatches(path, finalNamespaceWatcher, watcherType, false);        } else {            zkClient.removeAllWatches(path, watcherType, false);        }    } catch (Exception e) {        if (RetryLoop.isRetryException(e) && guaranteed) {                        client.getFailedRemoveWatcherManager().addFailedOperation(new FailedRemoveWatchManager.FailedRemoveWatchDetails(path, finalNamespaceWatcher));            throw e;        } else if (e instanceof KeeperException.NoWatcherException && quietly) {                } else {                        throw e;        }    }    return null;}
dd8526c9f77b7ee93076c37169c873cfcadfe5b756f855f3938d9fb40e522486
makeNamespaceWatcher
private NamespaceWatcher makeNamespaceWatcher(String path)
{    NamespaceWatcher namespaceWatcher = null;    if (watcher != null) {        if (watcher instanceof NamespaceWatcher) {            namespaceWatcher = (NamespaceWatcher) watcher;        } else {            namespaceWatcher = new NamespaceWatcher(client, watcher, path);        }    } else if (curatorWatcher != null) {        namespaceWatcher = new NamespaceWatcher(client, curatorWatcher, path);    }    return namespaceWatcher;}
772f79cf5c4af16a3e1cf67e610e3b66d770948915f9c0cca395686aa2e4f144
performBackgroundOperation
public void performBackgroundOperation(final OperationAndData<String> operationAndData) throws Exception
{    try {        final TimeTrace trace = client.getZookeeperClient().startTracer("RemoteWatches-Background");        AsyncCallback.VoidCallback callback = new AsyncCallback.VoidCallback() {            @Override            public void processResult(int rc, String path, Object ctx) {                trace.commit();                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.REMOVE_WATCHES, rc, path, null, ctx, null, null, null, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        };        ZooKeeper zkClient = client.getZooKeeper();        NamespaceWatcher namespaceWatcher = makeNamespaceWatcher(operationAndData.getData());        if (namespaceWatcher == null) {            zkClient.removeAllWatches(operationAndData.getData(), watcherType, local, callback, operationAndData.getContext());        } else {            zkClient.removeWatches(operationAndData.getData(), namespaceWatcher, watcherType, local, callback, operationAndData.getContext());        }    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
1670bb3e4673da82391867e9228b38f3d7dfc7759993e3e7748dcea2c4b95bb2
processResult
public void processResult(int rc, String path, Object ctx)
{    trace.commit();    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.REMOVE_WATCHES, rc, path, null, ctx, null, null, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
494e9db4b0717bb1ce33f725a4a8fa77bf3507c60bef69ada89ba4836bd1db55
withACL
public BackgroundPathable<Stat> withACL(List<ACL> aclList)
{    acling = new ACLing(client.getAclProvider(), aclList, false);    return this;}
fbc2f2c6914e79fb5b4623ac72b58d6d5499f6d8d649b41b053c7e192d90523e
withVersion
public ACLable<BackgroundPathable<Stat>> withVersion(int version)
{    this.version = version;    return this;}
e69085b203da60aaba1c6504fc105c6da50b681758d365423ec68c8fed5f5539
inBackground
public ErrorListenerPathable<Stat> inBackground()
{    backgrounding = new Backgrounding(true);    return this;}
c4a454597d1ca387026c336f56880eb08e5feaa3bf14b9722a716d5cdcd54a36
inBackground
public ErrorListenerPathable<Stat> inBackground(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
512f55d2e0eafcc54ff145c457c0f56d1b700486408abf08b7469fc6fb2cd824
inBackground
public ErrorListenerPathable<Stat> inBackground(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
e169d16ff4cf50bc71a1c0216e8d73341f9c7adbce8997ce2319f4a33e8e0f9a
inBackground
public ErrorListenerPathable<Stat> inBackground(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
083abced46a28092a693dcb8ed84b7df3ecbc381ee2c29d4a6f13f2a1fcedda9
inBackground
public ErrorListenerPathable<Stat> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
768344386dd7390e8424ed1432d3f852f4d659038ba625449ca545a60fc72c3e
inBackground
public ErrorListenerPathable<Stat> inBackground(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
772ee09bdd65569a912753d8079c732c88fdf6e948a5c1316451568b511046b7
withUnhandledErrorListener
public Pathable<Stat> withUnhandledErrorListener(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
fa9a17290417ee5fd504790e9a78e109faa3bfdeeb4d9e49d611b00ff15e5958
forPath
public Stat forPath(String path) throws Exception
{    String fixedPath = client.fixForNamespace(path);    List<ACL> aclList = acling.getAclList(fixedPath);    client.getSchemaSet().getSchema(path).validateGeneral(path, null, aclList);    Stat resultStat = null;    if (backgrounding.inBackground()) {        client.processBackgroundOperation(new OperationAndData<String>(this, fixedPath, backgrounding.getCallback(), null, backgrounding.getContext(), null), null);    } else {        resultStat = pathInForeground(fixedPath, aclList);    }    return resultStat;}
772f79cf5c4af16a3e1cf67e610e3b66d770948915f9c0cca395686aa2e4f144
performBackgroundOperation
public void performBackgroundOperation(final OperationAndData<String> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("SetACLBuilderImpl-Background");        String path = operationAndData.getData();        client.getZooKeeper().setACL(path, acling.getAclList(path), version, new AsyncCallback.StatCallback() {            @SuppressWarnings({ "unchecked" })            @Override            public void processResult(int rc, String path, Object ctx, Stat stat) {                trace.setReturnCode(rc).setPath(path).setStat(stat).commit();                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.SET_ACL, rc, path, null, ctx, stat, null, null, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        }, backgrounding.getContext());    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
1653988579fabf57097982ee8a47dff699cc3eca4f907fda182e6e272411b776
processResult
public void processResult(int rc, String path, Object ctx, Stat stat)
{    trace.setReturnCode(rc).setPath(path).setStat(stat).commit();    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.SET_ACL, rc, path, null, ctx, stat, null, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
bb96f63822e2a9307be0e6352712a98c5be8f7ab1d4933e88ea2308fea7e8aa7
pathInForeground
private Stat pathInForeground(final String path, final List<ACL> aclList) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("SetACLBuilderImpl-Foreground");    Stat resultStat = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<Stat>() {        @Override        public Stat call() throws Exception {            return client.getZooKeeper().setACL(path, aclList, version);        }    });    trace.setPath(path).setStat(resultStat).commit();    return resultStat;}
b8e6c61d1ad0861ffb63b6e255cc9573670963d8e3c59317c9f9cc0da4742a26
call
public Stat call() throws Exception
{    return client.getZooKeeper().setACL(path, aclList, version);}
ba22571bc4922ac7a04ce9484a8e722006baab6d444c995b6d5a675baf222dd6
asTransactionSetDataBuilder
 TransactionSetDataBuilder<T> asTransactionSetDataBuilder(final T context, final CuratorMultiTransactionRecord transaction)
{    return new TransactionSetDataBuilder<T>() {        @Override        public T forPath(String path, byte[] data) throws Exception {            if (compress) {                data = client.getCompressionProvider().compress(path, data);            }            String fixedPath = client.fixForNamespace(path);            transaction.add(Op.setData(fixedPath, data, version), OperationType.SET_DATA, path);            return context;        }        @Override        public T forPath(String path) throws Exception {            return forPath(path, client.getDefaultData());        }        @Override        public PathAndBytesable<T> withVersion(int version) {            SetDataBuilderImpl.this.withVersion(version);            return this;        }        @Override        public VersionPathAndBytesable<T> compressed() {            compress = true;            return this;        }    };}
f4933f0a03f2288d5503baa255999eb6c8a2c0ff401e979a5403e23e66878288
forPath
public T forPath(String path, byte[] data) throws Exception
{    if (compress) {        data = client.getCompressionProvider().compress(path, data);    }    String fixedPath = client.fixForNamespace(path);    transaction.add(Op.setData(fixedPath, data, version), OperationType.SET_DATA, path);    return context;}
f78f8317545828af6938dc071d4101bc858a8de7ddea11ca44fff56534af53dc
forPath
public T forPath(String path) throws Exception
{    return forPath(path, client.getDefaultData());}
d2a860cd1aad47f3d716c19f4b4438f3b4fa649730c0eb6f16144d50c2727367
withVersion
public PathAndBytesable<T> withVersion(int version)
{    SetDataBuilderImpl.this.withVersion(version);    return this;}
901274f1ff848a68e4683ce1bdc915434e8ad26fbe631d6c924bb7d0c29decdf
compressed
public VersionPathAndBytesable<T> compressed()
{    compress = true;    return this;}
e0205b97a1fe9bca34600159fdb6599908ff5720625a71083c07f3e3a497a6d1
compressed
public SetDataBackgroundVersionable compressed()
{    compress = true;    return new SetDataBackgroundVersionable() {        @Override        public ErrorListenerPathAndBytesable<Stat> inBackground() {            return SetDataBuilderImpl.this.inBackground();        }        @Override        public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback, Object context) {            return SetDataBuilderImpl.this.inBackground(callback, context);        }        @Override        public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback, Object context, Executor executor) {            return SetDataBuilderImpl.this.inBackground(callback, context, executor);        }        @Override        public ErrorListenerPathAndBytesable<Stat> inBackground(Object context) {            return SetDataBuilderImpl.this.inBackground(context);        }        @Override        public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback) {            return SetDataBuilderImpl.this.inBackground(callback);        }        @Override        public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback, Executor executor) {            return SetDataBuilderImpl.this.inBackground(callback, executor);        }        @Override        public Stat forPath(String path, byte[] data) throws Exception {            return SetDataBuilderImpl.this.forPath(path, data);        }        @Override        public Stat forPath(String path) throws Exception {            return SetDataBuilderImpl.this.forPath(path);        }        @Override        public BackgroundPathAndBytesable<Stat> withVersion(int version) {            return SetDataBuilderImpl.this.withVersion(version);        }    };}
e6640bbfffea03943993c5c9bac385c5f0fee5962958d3571e0f6d898af2eac5
inBackground
public ErrorListenerPathAndBytesable<Stat> inBackground()
{    return SetDataBuilderImpl.this.inBackground();}
ebe74b968002a17ac2d6addda8324ceeb29bd1e1c8660b2b5b7e5e005b2d5da0
inBackground
public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback, Object context)
{    return SetDataBuilderImpl.this.inBackground(callback, context);}
29993df8b5d7e36964c83778d37131419926081cc8d4919f8bbb4c2004642f83
inBackground
public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    return SetDataBuilderImpl.this.inBackground(callback, context, executor);}
ac09efb5a60b3f3955cb887c944677524127842a1ea88d3ee7062cddda530e31
inBackground
public ErrorListenerPathAndBytesable<Stat> inBackground(Object context)
{    return SetDataBuilderImpl.this.inBackground(context);}
9c18775779b2c9ad40b839e3f9dd912636aa09c59a87f77ec587926ffca68762
inBackground
public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback)
{    return SetDataBuilderImpl.this.inBackground(callback);}
a9e84cac548bfff85a04de0d613db570b1bc214c3954f2ccf126c9e819cf62dc
inBackground
public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback, Executor executor)
{    return SetDataBuilderImpl.this.inBackground(callback, executor);}
4c80007248577e78f360ee95ba1f2891c4dcb6f5a1ee71b2769fd1330f57fc1a
forPath
public Stat forPath(String path, byte[] data) throws Exception
{    return SetDataBuilderImpl.this.forPath(path, data);}
fa9a17290417ee5fd504790e9a78e109faa3bfdeeb4d9e49d611b00ff15e5958
forPath
public Stat forPath(String path) throws Exception
{    return SetDataBuilderImpl.this.forPath(path);}
fb76bde50922fc51786ee3abf6d547ad02df4db3df5201027d6fc72d05b2a0a5
withVersion
public BackgroundPathAndBytesable<Stat> withVersion(int version)
{    return SetDataBuilderImpl.this.withVersion(version);}
fb76bde50922fc51786ee3abf6d547ad02df4db3df5201027d6fc72d05b2a0a5
withVersion
public BackgroundPathAndBytesable<Stat> withVersion(int version)
{    this.version = version;    return this;}
ebe74b968002a17ac2d6addda8324ceeb29bd1e1c8660b2b5b7e5e005b2d5da0
inBackground
public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
29993df8b5d7e36964c83778d37131419926081cc8d4919f8bbb4c2004642f83
inBackground
public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
9c18775779b2c9ad40b839e3f9dd912636aa09c59a87f77ec587926ffca68762
inBackground
public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
e6640bbfffea03943993c5c9bac385c5f0fee5962958d3571e0f6d898af2eac5
inBackground
public ErrorListenerPathAndBytesable<Stat> inBackground()
{    backgrounding = new Backgrounding(true);    return this;}
ac09efb5a60b3f3955cb887c944677524127842a1ea88d3ee7062cddda530e31
inBackground
public ErrorListenerPathAndBytesable<Stat> inBackground(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
a9e84cac548bfff85a04de0d613db570b1bc214c3954f2ccf126c9e819cf62dc
inBackground
public ErrorListenerPathAndBytesable<Stat> inBackground(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
03906932985e60f49c578bf564f9f0bc38135a7c56e9b3339ba821139df5ceea
withUnhandledErrorListener
public PathAndBytesable<Stat> withUnhandledErrorListener(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
8282537fcedcf8bd947cd15b06cdcaafad9692a374332747ed39e569c9d265eb
performBackgroundOperation
public void performBackgroundOperation(final OperationAndData<PathAndBytes> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("SetDataBuilderImpl-Background");        final byte[] data = operationAndData.getData().getData();        client.getZooKeeper().setData(operationAndData.getData().getPath(), data, version, new AsyncCallback.StatCallback() {            @SuppressWarnings({ "unchecked" })            @Override            public void processResult(int rc, String path, Object ctx, Stat stat) {                trace.setReturnCode(rc).setRequestBytesLength(data).setPath(path).setStat(stat).commit();                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.SET_DATA, rc, path, null, ctx, stat, null, null, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        }, backgrounding.getContext());    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
1653988579fabf57097982ee8a47dff699cc3eca4f907fda182e6e272411b776
processResult
public void processResult(int rc, String path, Object ctx, Stat stat)
{    trace.setReturnCode(rc).setRequestBytesLength(data).setPath(path).setStat(stat).commit();    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.SET_DATA, rc, path, null, ctx, stat, null, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
fa9a17290417ee5fd504790e9a78e109faa3bfdeeb4d9e49d611b00ff15e5958
forPath
public Stat forPath(String path) throws Exception
{    return forPath(path, client.getDefaultData());}
4c80007248577e78f360ee95ba1f2891c4dcb6f5a1ee71b2769fd1330f57fc1a
forPath
public Stat forPath(String path, byte[] data) throws Exception
{    client.getSchemaSet().getSchema(path).validateGeneral(path, data, null);    if (compress) {        data = client.getCompressionProvider().compress(path, data);    }    path = client.fixForNamespace(path);    Stat resultStat = null;    if (backgrounding.inBackground()) {        client.processBackgroundOperation(new OperationAndData<>(this, new PathAndBytes(path, data), backgrounding.getCallback(), null, backgrounding.getContext(), null), null);    } else {        resultStat = pathInForeground(path, data);    }    return resultStat;}
79a966a07ccbcb0b4d9ecf92f24220884c3e0f26014374b2d7a63a7f8c67d9a8
getVersion
 int getVersion()
{    return version;}
1a46fbac4c0057946286e12665be9f7eaf0c62cd12f575c49919ba4e87c1a0cf
pathInForeground
private Stat pathInForeground(final String path, final byte[] data) throws Exception
{    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("SetDataBuilderImpl-Foreground");    Stat resultStat = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<Stat>() {        @Override        public Stat call() throws Exception {            return client.getZooKeeper().setData(path, data, version);        }    });    trace.setRequestBytesLength(data).setPath(path).setStat(resultStat).commit();    return resultStat;}
b8e6c61d1ad0861ffb63b6e255cc9573670963d8e3c59317c9f9cc0da4742a26
call
public Stat call() throws Exception
{    return client.getZooKeeper().setData(path, data, version);}
d45cad0b25ec41d5343f997256b4f90b5c299c427bf99f4b61b29e819c622bef
suspendConnection
public void suspendConnection(CuratorFrameworkImpl client)
{    client.setToSuspended();}
0ffa89db17abce6921b6a01c904cde966b632a413169c943ffe39bb1a8f1f2b4
checkNewConnection
public void checkNewConnection(CuratorFrameworkImpl client)
{    client.checkInstanceIndex();}
432b3e2dd1c388f8c64000f2ce1822cf59ab8e6b968d54626e8a5db9349e2d5e
inBackground
public ErrorListenerPathable<Void> inBackground()
{        return this;}
62988fed96608d5aed7f71052bf14f8688ce2d11e60964236538609bbbc577e5
inBackground
public ErrorListenerPathable<Void> inBackground(Object context)
{    backgrounding = new Backgrounding(context);    return this;}
b07ef64d8ae6fdc8f2165ccbe5182c8f027e5e71e2fdfe20fd6d32fc37d86361
inBackground
public ErrorListenerPathable<Void> inBackground(BackgroundCallback callback)
{    backgrounding = new Backgrounding(callback);    return this;}
34cee117719f9e8afbe0e19984b4f0ddf616e1298a89c5bf5cfd28e6df2b8ce6
inBackground
public ErrorListenerPathable<Void> inBackground(BackgroundCallback callback, Object context)
{    backgrounding = new Backgrounding(callback, context);    return this;}
9a1a177a2a5c105b8c51cce1c88513c86e5f2cc0c54bc39b45f78bcab4e7ff6a
inBackground
public ErrorListenerPathable<Void> inBackground(BackgroundCallback callback, Executor executor)
{    backgrounding = new Backgrounding(client, callback, executor);    return this;}
8fc2882e551603e6f04a3080c4df91a07a5716b4e49512020ae6bc8ff34193d5
inBackground
public ErrorListenerPathable<Void> inBackground(BackgroundCallback callback, Object context, Executor executor)
{    backgrounding = new Backgrounding(client, callback, context, executor);    return this;}
b30687aba7550ec7f699cd31b3de92272489b3de82641c094c05df75193eb336
withUnhandledErrorListener
public Pathable<Void> withUnhandledErrorListener(UnhandledErrorListener listener)
{    backgrounding = new Backgrounding(backgrounding, listener);    return this;}
772f79cf5c4af16a3e1cf67e610e3b66d770948915f9c0cca395686aa2e4f144
performBackgroundOperation
public void performBackgroundOperation(final OperationAndData<String> operationAndData) throws Exception
{    try {        final OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("SyncBuilderImpl-Background");        final String path = operationAndData.getData();        String adjustedPath = client.fixForNamespace(path);        AsyncCallback.VoidCallback voidCallback = new AsyncCallback.VoidCallback() {            @Override            public void processResult(int rc, String path, Object ctx) {                trace.setReturnCode(rc).setPath(path).commit();                CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.SYNC, rc, path, path, ctx, null, null, null, null, null, null);                client.processBackgroundOperation(operationAndData, event);            }        };        client.getZooKeeper().sync(adjustedPath, voidCallback, backgrounding.getContext());    } catch (Throwable e) {        backgrounding.checkError(e, null);    }}
1670bb3e4673da82391867e9228b38f3d7dfc7759993e3e7748dcea2c4b95bb2
processResult
public void processResult(int rc, String path, Object ctx)
{    trace.setReturnCode(rc).setPath(path).commit();    CuratorEvent event = new CuratorEventImpl(client, CuratorEventType.SYNC, rc, path, path, ctx, null, null, null, null, null, null);    client.processBackgroundOperation(operationAndData, event);}
012300743f62d93bdc1341b856be6212f1beeef6472d9e490d9be52dda2292f2
forPath
public Void forPath(String path) throws Exception
{    OperationAndData<String> operationAndData = new OperationAndData<String>(this, path, backgrounding.getCallback(), null, backgrounding.getContext(), null);    client.processBackgroundOperation(operationAndData, null);    return null;}
6492f61afd7eaec62cf240a9b499ef0a70b0703a9cb4a412fdefd86e399de8f4
decompressed
public StatPathable<byte[]> decompressed()
{    decompress = true;    return this;}
5f0ea2a189a61ce12917d01622763b2df37f14490f6bede6e3b055d9b264c22b
storingStatIn
public Pathable<byte[]> storingStatIn(Stat stat)
{    responseStat = stat;    return this;}
7f46cf268f7e7a74def0fef4fd3d9c17af4d001ced1e388665af7e5af0e45194
forPath
public byte[] forPath(String path) throws Exception
{    final String localPath = client.fixForNamespace(path);    OperationTrace trace = client.getZookeeperClient().startAdvancedTracer("GetDataBuilderImpl-Foreground");    byte[] responseData = RetryLoop.callWithRetry(client.getZookeeperClient(), new Callable<byte[]>() {        @Override        public byte[] call() throws Exception {            return client.getZooKeeper().getData(localPath, false, responseStat);        }    });    trace.setResponseBytesLength(responseData).setPath(path).setStat(responseStat).commit();    return decompress ? client.getCompressionProvider().decompress(path, responseData) : responseData;}
83a7785785005bc10aa7aa2c88a1e360c37c5b49e1e383e61bc19ebb44d63db6
call
public byte[] call() throws Exception
{    return client.getZooKeeper().getData(localPath, false, responseStat);}
6a78b99e33835f39df99fcdd7c56c7fbf53d9de3e657d045478194e51cf23bdf
create
public TransactionCreateBuilder<CuratorOp> create()
{    ExtractingCuratorOp op = new ExtractingCuratorOp();    return new CreateBuilderImpl(client).<CuratorOp>asTransactionCreateBuilder(op, op.getRecord());}
262d35c8762217ebf544358a98cea41462a6ab7d4fb8825a18068cef7764cf71
delete
public TransactionDeleteBuilder<CuratorOp> delete()
{    ExtractingCuratorOp op = new ExtractingCuratorOp();    return new DeleteBuilderImpl(client).<CuratorOp>asTransactionDeleteBuilder(op, op.getRecord());}
e6d9a53ae5d5bd6863a3846f9f5f38a47ec50aac7b09c67a091967d8d935801f
setData
public TransactionSetDataBuilder<CuratorOp> setData()
{    ExtractingCuratorOp op = new ExtractingCuratorOp();    return new SetDataBuilderImpl(client).<CuratorOp>asTransactionSetDataBuilder(op, op.getRecord());}
b2e0a16841e8e09b23e6609e026609eef659a9f002d9fa2e7a766f589c6cee2c
check
public TransactionCheckBuilder<CuratorOp> check()
{    ExtractingCuratorOp op = new ExtractingCuratorOp();    return CuratorTransactionImpl.<CuratorOp>makeTransactionCheckBuilder(client, op, op.getRecord());}
f8b6601fa685dd0045251e30b36f1e3f9ab403edd0efdc23a7988ff985ac7e57
newWatcherRemoveCuratorFramework
public WatcherRemoveCuratorFramework newWatcherRemoveCuratorFramework()
{    return client.newWatcherRemoveCuratorFramework();}
bcd9af7765e1f66d5fc4cbb4c43ab2a762fe62bb6ee09aab5538a44f1c9677fb
getRemovalManager
 WatcherRemovalManager getRemovalManager()
{    return removalManager;}
d88879d077a02cb000a6bf5e2e8edd6a45c0285b57f499cf90cc94e2bcd1cf16
getCurrentConfig
public QuorumVerifier getCurrentConfig()
{    return client.getCurrentConfig();}
d8c5cd1e5487e93661b4c2a1c9ee0ea7549a8cf5779d495709fa31493db660b9
removeWatchers
public void removeWatchers()
{    removalManager.removeWatchers();}
98f4b5efbfeeca4978ae8d80827f83ec7d4ee9688cbc84319cd27918750df93c
getWatcherRemovalManager
 WatcherRemovalManager getWatcherRemovalManager()
{    return removalManager;}
411c752dd6216d607d8e41e08f5e5dac702f4a22b060d3c4efc7c0b9a31bf3bf
nonNamespaceView
public CuratorFramework nonNamespaceView()
{    return client.nonNamespaceView();}
a20a1c4db3f9eb8e0d93485fdc63395cbf99a245461e6cb67abf55a83545c791
usingNamespace
public CuratorFramework usingNamespace(String newNamespace)
{    return client.usingNamespace(newNamespace);}
4c9ff74e20a72d5f7b2e4ef2a83e03a78836fed625f24259c12254b95b6af94e
getNamespace
public String getNamespace()
{    return client.getNamespace();}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    throw new UnsupportedOperationException();}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    throw new UnsupportedOperationException();}
e13808d604e8405be03413186c4b9e1c036656eb1d7fdefea0574a05483395d0
getConnectionStateListenable
public Listenable<ConnectionStateListener> getConnectionStateListenable()
{    return client.getConnectionStateListenable();}
dcaa652392e0c28ee05a36caa484c21329a1a09da88222252de7c461a9964230
getCuratorListenable
public Listenable<CuratorListener> getCuratorListenable()
{    return client.getCuratorListenable();}
b3d8c32fff49d6f84e3a03fa63c3aa3356dba76f0989aaae6638b46c12e3fdb0
getUnhandledErrorListenable
public Listenable<UnhandledErrorListener> getUnhandledErrorListenable()
{    return client.getUnhandledErrorListenable();}
89fa8cee5a80c3c832aa26455ab863bb32958b9ff2d86ec97d576ef4958933df
sync
public void sync(String path, Object context)
{    client.sync(path, context);}
1d6b70d040ccf31742e2278edbc6eab66dfccd1c6a0761b8b0eef130170256d1
getZookeeperClient
public CuratorZookeeperClient getZookeeperClient()
{    return client.getZookeeperClient();}
faa4514c18ba98064e265893a20e8e9ebf226051659272f3f597d33539ec9913
newRetryLoop
 RetryLoop newRetryLoop()
{    return client.newRetryLoop();}
f0891f7aab88f7cc4a33be47483c9249645409f0730f2bb08db5362769b1e641
getZooKeeper
 ZooKeeper getZooKeeper() throws Exception
{    return client.getZooKeeper();}
df03d11e4a696d15f707f9e0394cc5b23269c61fcd4637dfadd091ad90b2dee2
processBackgroundOperation
 void processBackgroundOperation(OperationAndData<DATA_TYPE> operationAndData, CuratorEvent event)
{    client.processBackgroundOperation(operationAndData, event);}
64cccd40db71e98e34316d2a61669cf8515e60b5bc310c71b5190444683b4154
logError
 void logError(String reason, Throwable e)
{    client.logError(reason, e);}
ec4e3ff02955c9ca8410bea65fe8ddcaa62e279f69bcff6e392341925f5a4dfb
unfixForNamespace
 String unfixForNamespace(String path)
{    return client.unfixForNamespace(path);}
1c998b5f31649a92e51dff1bc4186c8b9c281827723b902c76057701438d645c
fixForNamespace
 String fixForNamespace(String path)
{    return client.fixForNamespace(path);}
b43f3db7d08c9ce08b475c2334e8d41779026595caf40ca66256252b64c14ee2
fixForNamespace
 String fixForNamespace(String path, boolean isSequential)
{    return client.fixForNamespace(path, isSequential);}
1a15c389a2462368adce86012e6c68b530da2423eeed3e402f3d953e8442abc3
newNamespaceAwareEnsurePath
public EnsurePath newNamespaceAwareEnsurePath(String path)
{    return client.newNamespaceAwareEnsurePath(path);}
ebaaa6145951e4ae92905d3aae1c3de253d75f64dcf0a84a35bd373a8aa2dca1
getFailedDeleteManager
 FailedDeleteManager getFailedDeleteManager()
{    return client.getFailedDeleteManager();}
1ee273d7663845c7f10d85d1c23fab845f18327c588eb2aa69761a9a98647c05
add
 void add(NamespaceWatcher watcher)
{    watcher = Preconditions.checkNotNull(watcher, "watcher cannot be null");    entries.add(watcher);}
72310413644a5024333a9f399cf51cbe89a1e30e23d752b81f495cf5e9d25120
getEntries
 Set<? extends Watcher> getEntries()
{    return Sets.newHashSet(entries);}
b3240497b3df66baa072a223051983a420bcfdd661ef7609f840084e69ea8616
removeWatchers
 void removeWatchers()
{    if (client.isZk34CompatibilityMode()) {        return;    }    List<NamespaceWatcher> localEntries = Lists.newArrayList(entries);    while (localEntries.size() > 0) {        NamespaceWatcher watcher = localEntries.remove(0);        if (entries.remove(watcher) && !client.isZk34CompatibilityMode()) {            try {                log.debug("Removing watcher for path: " + watcher.getUnfixedPath());                RemoveWatchesBuilderImpl builder = new RemoveWatchesBuilderImpl(client);                builder.internalRemoval(watcher, watcher.getUnfixedPath());            } catch (Exception e) {                log.error("Could not remove watcher for path: " + watcher.getUnfixedPath());            }        }    }}
e88287ba4d8313dbef48b86ad698f92097d8cc259ed666e7a12b2a0087f1bb7e
noteTriggeredWatcher
 void noteTriggeredWatcher(NamespaceWatcher watcher)
{    entries.remove(watcher);}
3bbb7ba633180191a7e33afacac12280cafcd7403d813905a5bfe1c443aa7d2f
getWatcher
 Watcher getWatcher(String unfixedPath)
{    namespaceWatcher = null;    if (watcher != null) {        namespaceWatcher = new NamespaceWatcher(client, this.watcher, unfixedPath);    } else if (curatorWatcher != null) {        namespaceWatcher = new NamespaceWatcher(client, curatorWatcher, unfixedPath);    }    return namespaceWatcher;}
4fb0b2749ae5d7d6774fed822b061593f34d0a49d7d06e295aaf758450e1ca48
hasWatcher
 boolean hasWatcher()
{    return (watcher != null) || (curatorWatcher != null);}
229e31466f384c4052d599b85162f0c2c7ff0de8046d315fda67155d42071307
isWatched
 boolean isWatched()
{    return watched;}
dbd4a393ab61a121b2ed3a599a845876d9119b48eeba8efac72a148106815db4
commitWatcher
 void commitWatcher(int rc, boolean isExists)
{    boolean doCommit = false;    if (isExists) {        doCommit = ((rc == KeeperException.Code.OK.intValue()) || (rc == KeeperException.Code.NONODE.intValue()));    } else {        doCommit = (rc == KeeperException.Code.OK.intValue());    }    if (doCommit && (namespaceWatcher != null)) {        if (client.getWatcherRemovalManager() != null) {            client.getWatcherRemovalManager().add(namespaceWatcher);        }    }}
13f3b2b1a33a2ec0976847d578b16462239e54627810d11fe0605580c6b86688
addListener
public void addListener(T listener)
{    addListener(listener, MoreExecutors.directExecutor());}
4befbf333d5800c9a8f2776606f04de3b179f35c74b6b8fd9f8c53f1cd277d29
addListener
public void addListener(T listener, Executor executor)
{    listeners.put(listener, new ListenerEntry<T>(listener, executor));}
b2388cadbfb7a5126bbc3493105e3121c35287ed5a7ca7317f1c7fc44e2bd28d
removeListener
public void removeListener(T listener)
{    if (listener != null) {        listeners.remove(listener);    }}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    listeners.clear();}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return listeners.size();}
21268224d1e050386f8ae291577f564874907c69b4215f28ebaa8dc426791cb3
forEach
public void forEach(final Function<T, Void> function)
{    for (final ListenerEntry<T> entry : listeners.values()) {        entry.executor.execute(new Runnable() {            @Override            public void run() {                try {                    function.apply(entry.listener);                } catch (Throwable e) {                    ThreadUtils.checkInterrupted(e);                    log.error(String.format("Listener (%s) threw an exception", entry.listener), e);                }            }        });    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        function.apply(entry.listener);    } catch (Throwable e) {        ThreadUtils.checkInterrupted(e);        log.error(String.format("Listener (%s) threw an exception", entry.listener), e);    }}
d022d4c8e30dae80d047906393039bcb0807c3aec2567ce5ef0b40afeca60b65
isEmpty
 boolean isEmpty()
{    return size() == 0;}
3ffbe046b01f6d3a4b7f4c37d215fa8a6f7e702fb66bf7d5557def98c67b0e66
mapping
public static ListenerManager<K, V> mapping(Function<K, V> mapper)
{    return new MappingListenerManager<>(mapper);}
80213424026bd14695a30f5568badbfb05ae887869258e75cfae796934ba574c
addListener
public void addListener(K listener)
{    addListener(listener, Runnable::run);}
0d4f2f72d715159667f0a5460efd43932d3643dd9a6d5999ae79cd2724bc90d4
addListener
public void addListener(K listener, Executor executor)
{    V mapped = mapper.apply(listener);    listeners.put(listener, new ListenerEntry<>(mapped, executor));}
d47d2969a53d88abad3f8e7cd6a9df319a0a6ef83289f8f454ce8854dcdf782f
removeListener
public void removeListener(K listener)
{    if (listener != null) {        listeners.remove(listener);    }}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    listeners.clear();}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return listeners.size();}
0b9d5d101fa1f24d69d1fe13ab704ff5d693b2f1c1dbca913b65e9be73035e81
forEach
public void forEach(Consumer<V> function)
{    for (ListenerEntry<V> entry : listeners.values()) {        entry.executor.execute(() -> {            try {                function.accept(entry.listener);            } catch (Throwable e) {                ThreadUtils.checkInterrupted(e);                log.error(String.format("Listener (%s) threw an exception", entry.listener), e);            }        });    }}
86da98e1d5211960c8cab63f41167b01845aa8b4058d603864b5e42da316df08
standard
public static StandardListenerManager<T> standard()
{    MappingListenerManager<T, T> container = new MappingListenerManager<>(Function.identity());    return new StandardListenerManager<>(container);}
c09d626ba3c7030e504c4671630ae2570b70d9647b235ed1c340a63de79ffd25
mappingStandard
public static StandardListenerManager<T> mappingStandard(UnaryOperator<T> mapper)
{    MappingListenerManager<T, T> container = new MappingListenerManager<>(mapper);    return new StandardListenerManager<>(container);}
13f3b2b1a33a2ec0976847d578b16462239e54627810d11fe0605580c6b86688
addListener
public void addListener(T listener)
{    container.addListener(listener);}
4befbf333d5800c9a8f2776606f04de3b179f35c74b6b8fd9f8c53f1cd277d29
addListener
public void addListener(T listener, Executor executor)
{    container.addListener(listener, executor);}
b2388cadbfb7a5126bbc3493105e3121c35287ed5a7ca7317f1c7fc44e2bd28d
removeListener
public void removeListener(T listener)
{    container.removeListener(listener);}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    container.clear();}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return container.size();}
f24fe48dd61aacc9cd2b596d0398181d0fddad9fcb77df5175ef597fdb2051b1
forEach
public void forEach(Consumer<T> function)
{    container.forEach(function);}
b553ffd9f5a57e09696858fab168840b824ec3e4d113ce431c260200824a8e09
isTtl
public boolean isTtl(CreateMode mode)
{    return mode.isTTL();}
b21033c99b4dfbac0e44988ea75eb48ae3d81fc70eb5323661c6269c78319836
isTtl
public static boolean isTtl(CreateMode mode)
{    return !Compatibility.isZK34() && Internal.instance.isTtl(mode);}
4dd27bc0255a4567b42d9dab830ee2af76cde5f11beb92791531b3ae8d93b00f
isValid
public boolean isValid(Schema schema, String path, byte[] data, List<ACL> acl)
{    return true;}
6ddaa157a9c54da550844c360670f900568f0a3578cf1d596efa9ae605900f2e
builder
public static SchemaBuilder builder(String path)
{    return new SchemaBuilder(null, path);}
27cd0393a8dca977eba7ee83e0a0fdd33db2fb30366b555d38e6f7427d8ed4af
builder
public static SchemaBuilder builder(Pattern pathRegex)
{    return new SchemaBuilder(pathRegex, null);}
8d79d028601da8c1075d8ae14018f309e72dec5fad5c085e25a6e546f6e15db5
builderForRecipeParent
public static SchemaBuilder builderForRecipeParent(String parentPath)
{    return new SchemaBuilder(null, parentPath).sequential(Allowance.CANNOT).ephemeral(Allowance.CANNOT);}
4cd8bfa4f339582a3d3e6d64b8ddf55e803e48d31da29a85cf291164bcc32c94
builderForRecipe
public static SchemaBuilder builderForRecipe(String parentPath)
{    return new SchemaBuilder(Pattern.compile(ZKPaths.makePath(parentPath, ".*")), null).sequential(Allowance.MUST).ephemeral(Allowance.MUST).watched(Allowance.MUST).canBeDeleted(true);}
eff4845378fab396401e20144c8895386cab8f7068e04de6ebe782021605ae8b
fixPath
private String fixPath(String path)
{    if (path != null) {        if (path.endsWith(ZKPaths.PATH_SEPARATOR)) {            return (path.length() > 1) ? path.substring(0, path.length() - 1) : "";        }        return path;    }    return null;}
3a0aafa2e4ca78c45dafe4b6d8cd8ac4a47a95179a7ea149b8b0d21565e91b6c
validateDelete
public void validateDelete(String path)
{    if (!canBeDeleted) {        throw new SchemaViolation(this, new SchemaViolation.ViolatorData(path, null, null), "Cannot be deleted");    }}
a569a40b01cec89106e3fe2edc5f74b091089ec5ccea077f3d166d06f1b73de2
validateWatch
public void validateWatch(String path, boolean isWatching)
{    if (isWatching && (watched == Allowance.CANNOT)) {        throw new SchemaViolation(this, new SchemaViolation.ViolatorData(path, null, null), "Cannot be watched");    }    if (!isWatching && (watched == Allowance.MUST)) {        throw new SchemaViolation(this, new SchemaViolation.ViolatorData(path, null, null), "Must be watched");    }}
1561f2a5f3773977331296c3cfe8e2755887faa543bf3e048fb817b18b955123
validateCreate
public void validateCreate(CreateMode mode, String path, byte[] data, List<ACL> acl)
{    if (mode.isEphemeral() && (ephemeral == Allowance.CANNOT)) {        throw new SchemaViolation(this, new SchemaViolation.ViolatorData(path, data, acl), "Cannot be ephemeral");    }    if (!mode.isEphemeral() && (ephemeral == Allowance.MUST)) {        throw new SchemaViolation(this, new SchemaViolation.ViolatorData(path, data, acl), "Must be ephemeral");    }    if (mode.isSequential() && (sequential == Allowance.CANNOT)) {        throw new SchemaViolation(this, new SchemaViolation.ViolatorData(path, data, acl), "Cannot be sequential");    }    if (!mode.isSequential() && (sequential == Allowance.MUST)) {        throw new SchemaViolation(this, new SchemaViolation.ViolatorData(path, data, acl), "Must be sequential");    }    validateGeneral(path, data, acl);}
4b2689d628db7db9ffbd63d14184dcec9771ede75d3e05ebf34daadbb7cf27ce
validateGeneral
public void validateGeneral(String path, byte[] data, List<ACL> acl)
{    if (!schemaValidator.isValid(this, path, data, acl)) {        throw new SchemaViolation(this, new SchemaViolation.ViolatorData(path, data, acl), "Data is not valid");    }}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
2cd5f9cc0299af056a65d10673acb2f6748c5b94324bce54c4368571cb993a80
getRawPath
public String getRawPath()
{    return (fixedPath != null) ? fixedPath : pathRegex.pattern();}
21ce5ed5210ec1ea0d15cd10c79794a62bd4673842806e0e140e88d46a5160f6
getMetadata
public Map<String, String> getMetadata()
{    return metadata;}
1327306d5d6ff82a77abf90818e35312d6a9e8c057f92884493806ce83c76620
getPathRegex
public Pattern getPathRegex()
{    return pathRegex;}
58e7b527ecd5014eaf5f30fc9c50ba33e1f005f8ce9d24246253d62377788662
getPath
public String getPath()
{    return fixedPath;}
1a63d9163b1856c1069663dccfe12398f881c7ae608c91c15172014a06480c12
getDocumentation
public String getDocumentation()
{    return documentation;}
0c0ce925cf146e56711c6e0d19a97b5d3a500a18b1308f0b551d8603be05befd
getSchemaValidator
public SchemaValidator getSchemaValidator()
{    return schemaValidator;}
8b19165f951e38a260070f905f49f4d6f8571aea8dff64311e18fa349d44b1e8
getEphemeral
public Allowance getEphemeral()
{    return ephemeral;}
fba311a82ee1cbbc42d7a1ca7611cb4e2880855f2a86983198a86e961e6c3ffa
getSequential
public Allowance getSequential()
{    return sequential;}
4857aadc84e7d7de311b369d972464cf46d7cb2461fa0004a7b7d1171d3f5c74
getWatched
public Allowance getWatched()
{    return watched;}
72913ac58991fc710a8d3c4bf008e0e924460caa22a878f5f0b1f5869ae7574f
canBeDeleted
public boolean canBeDeleted()
{    return canBeDeleted;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    Schema schema = (Schema) o;        if (!pathRegex.equals(schema.pathRegex)) {        return false;    }    return fixedPath.equals(schema.fixedPath);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = pathRegex.hashCode();    result = 31 * result + fixedPath.hashCode();    return result;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "Schema{" + "name='" + name + '\'' + ", pathRegex=" + pathRegex + ", path='" + fixedPath + '\'' + ", documentation='" + documentation + '\'' + ", dataValidator=" + schemaValidator.getClass() + ", ephemeral=" + ephemeral + ", sequential=" + sequential + ", watched=" + watched + ", canBeDeleted=" + canBeDeleted + ", metadata=" + metadata + '}';}
d146c06974058fa881049ad8623b898c7f75c3c11baf1e842e6ea560b55c5cac
toDocumentation
public String toDocumentation()
{    String pathLabel = (pathRegex != null) ? "Path Regex: " : "Path: ";    return "Name: " + name + '\n' + pathLabel + getRawPath() + '\n' + "Doc: " + documentation + '\n' + "Validator: " + schemaValidator.getClass().getSimpleName() + '\n' + "Meta: " + metadata + '\n' + String.format("ephemeral: %s | sequential: %s | watched: %s | canBeDeleted: %s", ephemeral, sequential, watched, canBeDeleted) + '\n';}
afc0cee14c48342d7288a0c01991c9820a21555a34d6b5c00b6860c22c9ac450
build
public Schema build()
{    return new Schema(name, pathRegex, path, documentation, schemaValidator, ephemeral, sequential, watched, canBeDeleted, metadata);}
433952bbd911caf50be64d24b13265806d61d563ded0554f62af5eef912f1c3a
name
public SchemaBuilder name(String name)
{    this.name = Preconditions.checkNotNull(name, "name cannot be null");    return this;}
c0eaf0f97a0a90f343475e4574e91056da09824df199267a6c600638d5e3a32b
documentation
public SchemaBuilder documentation(String documentation)
{    this.documentation = Preconditions.checkNotNull(documentation, "documentation cannot be null");    return this;}
fa613cf630db5a9bc299cef7deab7dceee6eb21cd8fc3e92aa786e55e5abb529
dataValidator
public SchemaBuilder dataValidator(SchemaValidator schemaValidator)
{    this.schemaValidator = Preconditions.checkNotNull(schemaValidator, "dataValidator cannot be null");    return this;}
c7c4cbb5aa98ad6c47fe8a8a1918e555f950c2beb2c17d8364c9b02db378b40c
ephemeral
public SchemaBuilder ephemeral(Schema.Allowance ephemeral)
{    this.ephemeral = Preconditions.checkNotNull(ephemeral, "ephemeral cannot be null");    return this;}
73fe068ecf0594c49175ba1349de36160a3f47adf4b813d29d59e2eb0289e71b
sequential
public SchemaBuilder sequential(Schema.Allowance sequential)
{    this.sequential = Preconditions.checkNotNull(sequential, "sequential cannot be null");    return this;}
3a798ae78137067e0ddb4331146307d573b6f7661e6694d58435c60aee501e0f
watched
public SchemaBuilder watched(Schema.Allowance watched)
{    this.watched = watched;    return this;}
32a519a1591a2b3ea05b00461b2e5d97d22c4c70686fb411b1b0b8fba5651cda
canBeDeleted
public SchemaBuilder canBeDeleted(boolean canBeDeleted)
{    this.canBeDeleted = canBeDeleted;    return this;}
bf25d1fb13b81c36ef2a3aa2ef2a0d414a02744a71e740d1329ff5376514417e
metadata
public SchemaBuilder metadata(Map<String, String> metadata)
{    this.metadata = ImmutableMap.copyOf(metadata);    return this;}
dac7bf6e2738f35a4fb2516c4cd1c615e2e71756e50e9d5b4039ed9217788d85
load
public Schema load(String path) throws Exception
{    for (Schema schema : regexSchemas) {        if (schema.getPathRegex().matcher(path).matches()) {            log.debug("path -> {}", schema);            return schema;        }    }    return nullSchema;}
041076efd28ef90a5536ceef10b9d4db9ca94b2b5f6705b7a0a85e56c92eb103
getDefaultSchemaSet
public static SchemaSet getDefaultSchemaSet()
{    return new SchemaSet(Collections.<Schema>emptyList(), true) {        @Override        public String toDocumentation() {            return "Default schema";        }    };}
d146c06974058fa881049ad8623b898c7f75c3c11baf1e842e6ea560b55c5cac
toDocumentation
public String toDocumentation()
{    return "Default schema";}
16fd6be6668611c66e0165fa3b1dd4a741f6e00eeda7a95a7c062e0557317183
apply
public String apply(Schema schema)
{    return schema.getName();}
21d3a2408ffb87dba01cdd336f0da455d1069fb8a1587ce0a5644e6d57096452
getSchemas
public Collection<Schema> getSchemas()
{    return schemas.values();}
f8caef33f79337b68147c43f00796465f657c4100321e17036d06fbe8efa88e5
getSchema
public Schema getSchema(String path)
{    if (schemas.size() > 0) {        Schema schema = pathToSchemas.get(path);        if (schema == null) {            try {                schema = regexCache.get(path);                if (schema.equals(nullSchema)) {                    schema = useDefaultSchema ? defaultSchema : null;                }            } catch (ExecutionException e) {                throw new RuntimeException(e);            }        }        if (schema != null) {            return schema;        }    }    if (useDefaultSchema) {        return defaultSchema;    }    throw new SchemaViolation(null, new SchemaViolation.ViolatorData(path, null, null), "No schema found for: " + path);}
d60256fab1bf8ab9cfd797dba8370f45c5df2dfdd77eaa38277052bac4b33069
getNamedPath
public static String getNamedPath(CuratorFramework client, String name)
{    return client.getSchemaSet().getNamedSchema(name).getRawPath();}
46550730f820f3f94c45ab4110c36abf32e632f913e6fcc0522c901884348a2d
getNamedSchema
public Schema getNamedSchema(String name)
{    return schemas.get(name);}
d146c06974058fa881049ad8623b898c7f75c3c11baf1e842e6ea560b55c5cac
toDocumentation
public String toDocumentation()
{    StringBuilder str = new StringBuilder("Curator Schemas:\n\n");    for (Map.Entry<String, Schema> schemaEntry : schemas.entrySet()) {        str.append(schemaEntry.getKey()).append('\n').append(schemaEntry.getValue().toDocumentation()).append('\n');    }    return str.toString();}
34fa829cea6ceab75bd950b8ff163e955fa7db9e1d42ba2b1060f94217628023
toSchemaSet
public SchemaSet toSchemaSet(boolean useDefaultSchema)
{    return new SchemaSet(schemas, useDefaultSchema);}
4c2744847666ec3ff63769a33427688a6eaf8cc037cde0fd850ef3418c41a6ef
getSchemas
public List<Schema> getSchemas()
{    return schemas;}
9f09756b04230fcff5150082ad907f1fa7fe0497505db3b73e277ade3387a7a1
getRoot
private static JsonNode getRoot(Reader in)
{    try {        return new ObjectMapper().readTree(in);    } catch (IOException e) {        throw new RuntimeException(e);    }}
1597e6c3606fb387f209ed4ed3352f8e2fe93f16ddbc1b06c9875e7d7a39d4e7
read
private void read(ImmutableList.Builder<Schema> builder, JsonNode node, SchemaValidatorMapper schemaValidatorMapper)
{    for (JsonNode child : node) {        readNode(builder, child, schemaValidatorMapper);    }}
7cca3430d51b81a6dffa98361e4cde8ef617946174f8a3db9d5dbfc121c4561d
readNode
private void readNode(ImmutableList.Builder<Schema> builder, JsonNode node, SchemaValidatorMapper schemaValidatorMapper)
{    String name = getText(node, "name", null);    String path = getText(node, "path", null);    boolean isRegex = getBoolean(node, "isRegex");    if (name == null) {        throw new RuntimeException("name is required at: " + node);    }    if (path == null) {        throw new RuntimeException("path is required at: " + node);    }    SchemaBuilder schemaBuilder = isRegex ? Schema.builder(Pattern.compile(path)) : Schema.builder(path);    String schemaValidatorName = getText(node, "schemaValidator", null);    if (schemaValidatorName != null) {        if (schemaValidatorMapper == null) {            throw new RuntimeException("No SchemaValidatorMapper provided but needed at: " + node);        }        schemaBuilder.dataValidator(schemaValidatorMapper.getSchemaValidator(schemaValidatorName));    }    Map<String, String> metadata = Maps.newHashMap();    if (node.has("metadata")) {        JsonNode metadataNode = node.get("metadata");        Iterator<String> fieldNameIterator = metadataNode.fieldNames();        while (fieldNameIterator.hasNext()) {            String fieldName = fieldNameIterator.next();            metadata.put(fieldName, getText(metadataNode, fieldName, ""));        }    }    Schema schema = schemaBuilder.name(name).documentation(getText(node, "documentation", "")).ephemeral(getAllowance(node, "ephemeral")).sequential(getAllowance(node, "sequential")).watched(getAllowance(node, "watched")).canBeDeleted(getBoolean(node, "canBeDeleted")).metadata(metadata).build();    builder.add(schema);}
c8349ea8e6fd69aedc680dbd450eb4f595671838e1d312fcc84689467adab27d
getText
private String getText(JsonNode node, String name, String defaultValue)
{    JsonNode namedNode = node.get(name);    return (namedNode != null) ? namedNode.asText() : defaultValue;}
2ef3d51cb0108194624f1307009dfb657bb6da201de2792c9562652c53b76b77
getBoolean
private boolean getBoolean(JsonNode node, String name)
{    JsonNode namedNode = node.get(name);    return (namedNode != null) && namedNode.asBoolean();}
ebf4d6b9c3ebef6f60a14f1ce8daa45a33aaaef09720a1f969f3102831acbdc6
getAllowance
private Schema.Allowance getAllowance(JsonNode node, String name)
{    JsonNode namedNode = node.get(name);    try {        return (namedNode != null) ? Schema.Allowance.valueOf(namedNode.asText().toUpperCase()) : Schema.Allowance.CAN;    } catch (IllegalArgumentException ignore) {        throw new RuntimeException("Must be one of: " + Arrays.toString(Schema.Allowance.values()) + " at " + node);    }}
58e7b527ecd5014eaf5f30fc9c50ba33e1f005f8ce9d24246253d62377788662
getPath
public String getPath()
{    return path;}
812b8f717be4a6f9c7add1b71268ba7fe7ce1b799031309a1709dc43be1dd152
getData
public byte[] getData()
{    return data;}
6c321425367cdffc5080771d9ac6bb4fc28413a81d213555938a244e37e97e29
getAcl
public List<ACL> getAcl()
{    return acl;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    String dataString = (data != null) ? new String(data) : "";    return "ViolatorData{" + "path='" + path + '\'' + ", data=" + dataString + ", acl=" + acl + '}';}
b74ae948bba816a824396f5fcd959e744592a67ff01eb79c422acb487a04550a
getSchema
public Schema getSchema()
{    return schema;}
7066e83d1179c6537853daf05a9c0d4fa34d0d2c8a5496f6d29912a22a56aa94
getViolation
public String getViolation()
{    return violation;}
0ae698626ed1610c516784bc39dbd77d7f0fa54950979fcd20c9124c60d614e8
getViolatorData
public ViolatorData getViolatorData()
{    return violatorData;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return toString(schema, violation, violatorData) + super.toString();}
21f0b64269a5ab302e4cb55d923aaa781732bd35eafd498718b26ebd728a87b6
toString
private static String toString(Schema schema, String violation, ViolatorData violatorData)
{    return (violation != null ? violation : "") + " " + schema + " " + violatorData;}
9ee4a04547eceb9258fdd4ce5a896e672a6ad58d387e1f8123262801dafcdac4
build
 static CircuitBreaker build(RetryPolicy retryPolicy)
{    return new CircuitBreaker(retryPolicy, ThreadUtils.newSingleThreadScheduledExecutor("CircuitBreakingConnectionStateListener"));}
6246a528113e0e54fe951345b78c0d0eeacd7be41b1e293af9361551d34b4b4a
build
 static CircuitBreaker build(RetryPolicy retryPolicy, ScheduledExecutorService service)
{    return new CircuitBreaker(retryPolicy, service);}
9a494fa84b33fce8695f0601a9f25e9f3d7358b8932dbbbd3f0f2ec49c4161e3
isOpen
 boolean isOpen()
{    return isOpen;}
3dd54cd58fb9914888c8408ed126792bb97936f729caf7b17c6cd6333dd91de0
getRetryCount
 int getRetryCount()
{    return retryCount;}
84c05974b1d3a706603a1c1bd907a9340d7f65419a7d2baaf21f9b2d004d5546
tryToOpen
 boolean tryToOpen(Runnable completion)
{    if (isOpen) {        return false;    }    isOpen = true;    retryCount = 0;    startNanos = System.nanoTime();    if (tryToRetry(completion)) {        return true;    }    close();    return false;}
ae0dd6f6527ec31ff97cd73a130fe260c75fd358f79aa53a75593d76ffee14ce
tryToRetry
 boolean tryToRetry(Runnable completion)
{    if (!isOpen) {        return false;    }    long[] sleepTimeNanos = new long[] { 0L };    RetrySleeper retrySleeper = (time, unit) -> sleepTimeNanos[0] = unit.toNanos(time);    Duration elapsedTime = Duration.ofNanos(System.nanoTime() - startNanos);    if (retryPolicy.allowRetry(retryCount, elapsedTime.toMillis(), retrySleeper)) {        ++retryCount;        service.schedule(completion, sleepTimeNanos[0], TimeUnit.NANOSECONDS);        return true;    }    return false;}
fe7377f341ed3dcf1c29af2dda5b62846f7a753a2f3b14bf3d1882672c7464b3
close
 boolean close()
{    boolean wasOpen = isOpen;    retryCount = 0;    isOpen = false;    startNanos = 0;    return wasOpen;}
861cc654480f7e3e5c0b56375b09764347adfd352d55988316a8ed00def50485
stateChanged
public synchronized void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (circuitBreaker.isOpen()) {        handleOpenStateChange(newState);    } else {        handleClosedStateChange(newState);    }}
8e821e51bfcd59c427f104113b5826d05c149917281b748bb21cc1fd5c72398b
isOpen
public synchronized boolean isOpen()
{    return circuitBreaker.isOpen();}
988b711b63db95cf270e05877465a16035e2057a256b70e83c8f83f04ab5f40c
handleClosedStateChange
private synchronized void handleClosedStateChange(ConnectionState newState)
{    if (!newState.isConnected()) {        if (circuitBreaker.tryToOpen(this::checkCloseCircuit)) {            log.info("Circuit is opening. State: {} post-retryCount: {}", newState, circuitBreaker.getRetryCount());            circuitLastState = circuitInitialState = newState;            circuitLostHasBeenSent = (newState == ConnectionState.LOST);        } else {            log.debug("Could not open circuit breaker. State: {}", newState);        }    }    callListener(newState);}
369d69fb034ab6bf98af82ccff4f7a79dfd5fd88a3fc670cf150b281d5d17b2d
handleOpenStateChange
private synchronized void handleOpenStateChange(ConnectionState newState)
{    if (circuitLostHasBeenSent || (newState != ConnectionState.LOST)) {        log.debug("Circuit is open. Ignoring state change: {}", newState);        circuitLastState = newState;    } else {        log.debug("Circuit is open. State changed to LOST. Sending to listener.");        circuitLostHasBeenSent = true;        circuitLastState = circuitInitialState = ConnectionState.LOST;        callListener(ConnectionState.LOST);    }}
b10450009da58abdde62bcf56740058280ca27f3ee665d24050058c5f5e03cc2
checkCloseCircuit
private synchronized void checkCloseCircuit()
{    if ((circuitLastState == null) || circuitLastState.isConnected()) {        log.info("Circuit is closing. Initial state: {} - Last state: {}", circuitInitialState, circuitLastState);        closeCircuit();    } else if (circuitBreaker.tryToRetry(this::checkCloseCircuit)) {        log.debug("Circuit open is continuing due to retry. State: {} post-retryCount: {}", circuitLastState, circuitBreaker.getRetryCount());    } else {        log.info("Circuit is closing due to retries exhausted. Initial state: {} - Last state: {}", circuitInitialState, circuitLastState);        closeCircuit();    }}
c3ce87f67318cf33cbfb0ad62080c6f7f053050bd48fd961d9d77bb682355225
callListener
private synchronized void callListener(ConnectionState newState)
{    if (newState != null) {        listener.stateChanged(client, newState);    }}
8fbf0661713c8a56ad1dc218f3f8b5008da4489fc068f979d6c509eb4c4f36c7
closeCircuit
private synchronized void closeCircuit()
{    ConnectionState stateToSend = (circuitLastState == circuitInitialState) ? null : circuitLastState;    reset();    callListener(stateToSend);}
f8313df04017a6ff547852835ab44b1f88061c314337bff0f52c7fc8b51aecf5
reset
private synchronized void reset()
{    circuitLastState = null;    circuitInitialState = null;    circuitLostHasBeenSent = false;    circuitBreaker.close();}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    doNotProxyContainer.clear();    mainContainer.clear();}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return mainContainer.size() + doNotProxyContainer.size();}
8a5f6ac393cbb039f483609d8e8bde83b0eaaecd6b82c300444b028934595526
forEach
public void forEach(Consumer<ConnectionStateListener> function)
{    doNotProxyContainer.forEach(function);    function.accept(masterListener);}
6e2d52a076d85c2970550b61b2c5533d2e019fda988022228d8c84eb2a3ecf6f
addListener
public void addListener(ConnectionStateListener listener)
{    if (listener.doNotProxy()) {        doNotProxyContainer.addListener(listener);    } else {        mainContainer.addListener(listener);    }}
1a07f3a4f250c734f03f688343a30fe0776a4e94e740fec05f356c9a9c0f923a
addListener
public void addListener(ConnectionStateListener listener, Executor executor)
{    if (listener.doNotProxy()) {        doNotProxyContainer.addListener(listener, executor);    } else {        mainContainer.addListener(listener, executor);    }}
dde714c7aaae247672b97f6c9e6234ab16c9c6d53fc96abcad799e7a7bdba94f
removeListener
public void removeListener(ConnectionStateListener listener)
{    mainContainer.removeListener(listener);    doNotProxyContainer.removeListener(listener);}
d281b583c7876c25d7ad9fa27ea2d785aca24efb5315460c0e085a5cb6230e07
isConnected
public boolean isConnected()
{    return true;}
d281b583c7876c25d7ad9fa27ea2d785aca24efb5315460c0e085a5cb6230e07
isConnected
public boolean isConnected()
{    return false;}
d281b583c7876c25d7ad9fa27ea2d785aca24efb5315460c0e085a5cb6230e07
isConnected
public boolean isConnected()
{    return true;}
d281b583c7876c25d7ad9fa27ea2d785aca24efb5315460c0e085a5cb6230e07
isConnected
public boolean isConnected()
{    return false;}
d281b583c7876c25d7ad9fa27ea2d785aca24efb5315460c0e085a5cb6230e07
isConnected
public boolean isConnected()
{    return true;}
8ded872db27f30a6b931de37d9cd795ae428348dee7673076d58e401c6a48a48
doNotProxy
 boolean doNotProxy()
{    return false;}
2ac967151220d6ed1a4370542a2375a084151f09ec9d86089635b6ccbe1dffa3
circuitBreaking
 static ConnectionStateListenerManagerFactory circuitBreaking(RetryPolicy retryPolicy)
{    return client -> new CircuitBreakingManager(client, CircuitBreaker.build(retryPolicy));}
9cd03fdde0cf03e8412c70c05d2d0d30b45f73d034735ed589e803035fcbb71e
circuitBreaking
 static ConnectionStateListenerManagerFactory circuitBreaking(RetryPolicy retryPolicy, ScheduledExecutorService service)
{    return client -> new CircuitBreakingManager(client, CircuitBreaker.build(retryPolicy, service));}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    service.submit(new Callable<Object>() {        @Override        public Object call() throws Exception {            processEvents();            return null;        }    });}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    processEvents();    return null;}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    if (state.compareAndSet(State.STARTED, State.CLOSED)) {        service.shutdownNow();        listeners.clear();    }}
b5925d0fa69bcd0f08e41134df8e65d80ebbd755f97897ac6df7e1ccc2b4787b
getListenable
public Listenable<ConnectionStateListener> getListenable()
{    return listeners;}
d941364201096297a5674f42602984e4539045d3e67c69b1ff8770325730d98e
setToSuspended
public synchronized boolean setToSuspended()
{    if (state.get() != State.STARTED) {        return false;    }    if ((currentConnectionState == ConnectionState.LOST) || (currentConnectionState == ConnectionState.SUSPENDED)) {        return false;    }    setCurrentConnectionState(ConnectionState.SUSPENDED);    postState(ConnectionState.SUSPENDED);    return true;}
80c831fbbe33ebc55717c51daf99a3a4e4332e0b4f66c90027a99d0da70c585b
addStateChange
public synchronized boolean addStateChange(ConnectionState newConnectionState)
{    if (state.get() != State.STARTED) {        return false;    }    ConnectionState previousState = currentConnectionState;    if (previousState == newConnectionState) {        return false;    }    setCurrentConnectionState(newConnectionState);    ConnectionState localState = newConnectionState;    boolean isNegativeMessage = ((newConnectionState == ConnectionState.LOST) || (newConnectionState == ConnectionState.SUSPENDED) || (newConnectionState == ConnectionState.READ_ONLY));    if (!isNegativeMessage && initialConnectMessageSent.compareAndSet(false, true)) {        localState = ConnectionState.CONNECTED;    }    postState(localState);    return true;}
18933900e696aa0635206b42883462bdc5a16554414845518468a0302962251d
blockUntilConnected
public synchronized boolean blockUntilConnected(int maxWaitTime, TimeUnit units) throws InterruptedException
{    long startTime = System.currentTimeMillis();    boolean hasMaxWait = (units != null);    long maxWaitTimeMs = hasMaxWait ? TimeUnit.MILLISECONDS.convert(maxWaitTime, units) : 0;    while (!isConnected()) {        if (hasMaxWait) {            long waitTime = maxWaitTimeMs - (System.currentTimeMillis() - startTime);            if (waitTime <= 0) {                return isConnected();            }            wait(waitTime);        } else {            wait();        }    }    return isConnected();}
b290187fc9d7bf1681b2363abe66e3d374cb0ed4adac841a9976c10900e43cf8
isConnected
public synchronized boolean isConnected()
{    return (currentConnectionState != null) && currentConnectionState.isConnected();}
9745fd30ca7f16ce8ad66712394732b349028666a90cf786bc95d9798000d4fe
postState
private void postState(ConnectionState state)
{    log.info("State change: " + state);    notifyAll();    while (!eventQueue.offer(state)) {        eventQueue.poll();        log.warn("ConnectionStateManager queue full - dropping events to make room");    }}
ddacff89df98f41d5dd195bedd6d2fe804a0f6fca79ba6ed87712ea258bf0fe6
processEvents
private void processEvents()
{    while (state.get() == State.STARTED) {        try {            int useSessionTimeoutMs = getUseSessionTimeoutMs();            long elapsedMs = startOfSuspendedEpoch == 0 ? useSessionTimeoutMs / 2 : System.currentTimeMillis() - startOfSuspendedEpoch;            long pollMaxMs = useSessionTimeoutMs - elapsedMs;            final ConnectionState newState = eventQueue.poll(pollMaxMs, TimeUnit.MILLISECONDS);            if (newState != null) {                if (listeners.isEmpty()) {                    log.warn("There are no ConnectionStateListeners registered.");                }                listeners.forEach(listener -> listener.stateChanged(client, newState));            } else if (sessionExpirationPercent > 0) {                synchronized (this) {                    checkSessionExpiration();                }            }        } catch (InterruptedException e) {                                }    }}
3446abd53a7c0dd977181e7955360b1f1ffd9c8f03e6e87703656c94a3d00c81
checkSessionExpiration
private void checkSessionExpiration()
{    if ((currentConnectionState == ConnectionState.SUSPENDED) && (startOfSuspendedEpoch != 0)) {        long elapsedMs = System.currentTimeMillis() - startOfSuspendedEpoch;        int useSessionTimeoutMs = getUseSessionTimeoutMs();        if (elapsedMs >= useSessionTimeoutMs) {                        startOfSuspendedEpoch = System.currentTimeMillis();            log.warn(String.format("Session timeout has elapsed while SUSPENDED. Injecting a session expiration. Elapsed ms: %d. Adjusted session timeout ms: %d", elapsedMs, useSessionTimeoutMs));            try {                Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());            } catch (Exception e) {                log.error("Could not inject session expiration", e);            }        }    } else if (currentConnectionState == ConnectionState.LOST) {        try {                        client.getZookeeperClient().getZooKeeper();        } catch (Exception e) {            log.error("Could not get ZooKeeper", e);        }    }}
55b6fc085b2c5f0189b488d3270f37f338725ea83dfdc9fc4cdc23392471ed1c
setCurrentConnectionState
private void setCurrentConnectionState(ConnectionState newConnectionState)
{    currentConnectionState = newConnectionState;    startOfSuspendedEpoch = (currentConnectionState == ConnectionState.SUSPENDED) ? System.currentTimeMillis() : 0;}
679c67e0074d18bb10a1ec7487b3fb5d3480c2bcaf5c7315365106446a372f5b
getUseSessionTimeoutMs
private int getUseSessionTimeoutMs()
{    int lastNegotiatedSessionTimeoutMs = client.getZookeeperClient().getLastNegotiatedSessionTimeoutMs();    int useSessionTimeoutMs = (lastNegotiatedSessionTimeoutMs > 0) ? lastNegotiatedSessionTimeoutMs : sessionTimeoutMs;    useSessionTimeoutMs = sessionExpirationPercent > 0 && startOfSuspendedEpoch != 0 ? (useSessionTimeoutMs * sessionExpirationPercent) / 100 : useSessionTimeoutMs;    return useSessionTimeoutMs;}
4bfed3e3e4140af742a4d97ed94fc287c02f836db8a1487a46384452e90a1f47
isErrorState
public boolean isErrorState(ConnectionState state)
{    return state == ConnectionState.LOST;}
4bfed3e3e4140af742a4d97ed94fc287c02f836db8a1487a46384452e90a1f47
isErrorState
public boolean isErrorState(ConnectionState state)
{    return ((state == ConnectionState.SUSPENDED) || (state == ConnectionState.LOST));}
0e0411efe5e7868378f7f03580d84579275f5762c392b06dea78c574fd2c1d57
testBasic
public void testBasic()
{    Semaphore counter = new Semaphore(0);    final CuratorFramework client = newClient(counter);    try {        client.start();        Assert.assertTrue(timing.acquireSemaphore(counter));    } finally {        CloseableUtils.closeQuietly(client);    }}
4f4859a4d31b5e19bbc8f5cd9204641ff9c15a9d25006f17433e2d76dd3e27c7
testAfterSessionExpiration
public void testAfterSessionExpiration() throws Exception
{    TestingServer oldServer = server;    Semaphore counter = new Semaphore(0);    final CuratorFramework client = newClient(counter);    try {        final CountDownLatch connectedLatch = new CountDownLatch(1);        final CountDownLatch lostLatch = new CountDownLatch(1);        final CountDownLatch reconnectedLatch = new CountDownLatch(1);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.CONNECTED) {                    connectedLatch.countDown();                }                if (newState == ConnectionState.LOST) {                    lostLatch.countDown();                }                if (newState == ConnectionState.RECONNECTED) {                    reconnectedLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        client.start();        Assert.assertTrue(timing.awaitLatch(connectedLatch));        server.stop();        Assert.assertTrue(timing.awaitLatch(lostLatch));        counter.drainPermits();        for (int i = 0; i < 5; ++i) {                        Assert.assertTrue(timing.acquireSemaphore(counter), "Failed when i is: " + i);        }                server = new TestingServer();        Assert.assertTrue(timing.awaitLatch(reconnectedLatch));    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(oldServer);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    }    if (newState == ConnectionState.LOST) {        lostLatch.countDown();    }    if (newState == ConnectionState.RECONNECTED) {        reconnectedLatch.countDown();    }}
a18e7919c1ddb2d2a1ea6cd7f30396bdeb94453de53c41532c3c5f28536fdf01
newClient
private CuratorFramework newClient(Semaphore counter)
{    return CuratorFrameworkFactory.builder().ensembleProvider(new CountingEnsembleProvider(counter)).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new RetryOneTime(1)).build();}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{}
3a15ca2ed8208cd07404b01c15089fa841a6e5aecf12a07cc9d92b33a3adb8ac
getConnectionString
public String getConnectionString()
{    getConnectionStringCounter.release();    return server.getConnectString();}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{}
8288ce4403dd68ee31bc3e4125518f3f79dd8811760a6c6877cce621be05ce5a
setConnectionString
public void setConnectionString(String connectionString)
{}
4d8f8c3644e8bcf9c25bb24a5c68147d454045b529f3acc5b3ab9f472ebbed35
updateServerListEnabled
public boolean updateServerListEnabled()
{    return false;}
444eb22038bacc945eaa128ce52dae5f4458e7ff6df8935974c79cd9dbfef5d8
testBlockUntilConnectedCurrentlyConnected
public void testBlockUntilConnectedCurrentlyConnected() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        final CountDownLatch connectedLatch = new CountDownLatch(1);        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState.isConnected()) {                    connectedLatch.countDown();                }            }        });        client.start();        Assert.assertTrue(timing.awaitLatch(connectedLatch), "Timed out awaiting latch");        Assert.assertTrue(client.blockUntilConnected(1, TimeUnit.SECONDS), "Not connected");    } catch (InterruptedException e) {        Assert.fail("Unexpected interruption");    } finally {        CloseableUtils.closeQuietly(client);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState.isConnected()) {        connectedLatch.countDown();    }}
25a5548866baf5ad07452be8fe0a705fb50e1fb993c67f844c0a8fda82e85525
testBlockUntilConnectedCurrentlyNeverConnected
public void testBlockUntilConnectedCurrentlyNeverConnected()
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        Assert.assertTrue(client.blockUntilConnected(5, TimeUnit.SECONDS), "Not connected");    } catch (InterruptedException e) {        Assert.fail("Unexpected interruption");    } finally {        CloseableUtils.closeQuietly(client);    }}
cfc4cdbb246800c15964b814de6016500eb716148d47e7f61898115d8c33a2a3
testBlockUntilConnectedCurrentlyAwaitingReconnect
public void testBlockUntilConnectedCurrentlyAwaitingReconnect()
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).retryPolicy(new RetryOneTime(1)).build();    final CountDownLatch lostLatch = new CountDownLatch(1);    client.getConnectionStateListenable().addListener(new ConnectionStateListener() {        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {            if (newState == ConnectionState.LOST) {                lostLatch.countDown();            }        }    });    try {        client.start();                Assert.assertTrue(client.blockUntilConnected(5, TimeUnit.SECONDS), "Failed to connect");                CloseableUtils.closeQuietly(server);                Assert.assertTrue(timing.awaitLatch(lostLatch), "Failed to reach LOST state");        server = new TestingServer(server.getPort(), server.getTempDirectory());        Assert.assertTrue(client.blockUntilConnected(5, TimeUnit.SECONDS), "Not connected");    } catch (Exception e) {        Assert.fail("Unexpected exception " + e);    } finally {        CloseableUtils.closeQuietly(client);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        lostLatch.countDown();    }}
aa7b31ddd381c9418529e1f4f8677457479ae5e0b609307813e5b67da84d8bb4
testBlockUntilConnectedConnectTimeout
public void testBlockUntilConnectedConnectTimeout()
{        CloseableUtils.closeQuietly(server);    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        Assert.assertFalse(client.blockUntilConnected(5, TimeUnit.SECONDS), "Connected");    } catch (InterruptedException e) {        Assert.fail("Unexpected interruption");    } finally {        CloseableUtils.closeQuietly(client);    }}
f5344cccdca7ea92d6a090df80df8eed07da089b8339b729b1f8cedadf1451ca
testBlockUntilConnectedInterrupt
public void testBlockUntilConnectedInterrupt()
{        CloseableUtils.closeQuietly(server);    final CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final Thread threadToInterrupt = Thread.currentThread();        Timer timer = new Timer();        timer.schedule(new TimerTask() {            @Override            public void run() {                threadToInterrupt.interrupt();            }        }, 3000);        client.blockUntilConnected(5, TimeUnit.SECONDS);        Assert.fail("Expected interruption did not occur");    } catch (InterruptedException e) {        } finally {        CloseableUtils.closeQuietly(client);    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    threadToInterrupt.interrupt();}
e07a1f7d7c2b2e47b64d47a02c5ba8cb6b13cc978538011dbd4b4998ed28485a
testBlockUntilConnectedTightLoop
public void testBlockUntilConnectedTightLoop() throws InterruptedException
{    CuratorFramework client;    for (int i = 0; i < 50; i++) {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(100));        try {            client.start();            client.blockUntilConnected();            Assert.assertTrue(client.getZookeeperClient().isConnected(), "Not connected after blocking for connection #" + i);        } finally {            client.close();        }    }}
5af8657091093df12eeffe7cf87c53ee1c30907937fa7eabeec85273fbe8f699
closeAndTestClean
public static void closeAndTestClean(CuratorFramework client)
{    if (client == null) {        return;    }    if (Compatibility.isZK34()) {        CloseableUtils.closeQuietly(client);        return;    }    try {        Timing2 timing = new Timing2();        CuratorFrameworkImpl internalClient = (CuratorFrameworkImpl) client;        EnsembleTracker ensembleTracker = internalClient.getEnsembleTracker();        if (ensembleTracker != null) {            while (ensembleTracker.hasOutstanding()) {                Thread.sleep(100);            }            ensembleTracker.close();        }        ZooKeeper zooKeeper = internalClient.getZooKeeper();        if (zooKeeper != null) {            final int maxLoops = 3;            for (            int i = 0;             i < maxLoops;             ++i) {                if (i > 0) {                    timing.multiple(.5).sleepABit();                }                boolean isLast = (i + 1) == maxLoops;                if (WatchersDebug.getChildWatches(zooKeeper).size() != 0) {                    if (isLast) {                        throw new AssertionError("One or more child watchers are still registered: " + WatchersDebug.getChildWatches(zooKeeper));                    }                    continue;                }                if (WatchersDebug.getExistWatches(zooKeeper).size() != 0) {                    if (isLast) {                        throw new AssertionError("One or more exists watchers are still registered: " + WatchersDebug.getExistWatches(zooKeeper));                    }                    continue;                }                if (WatchersDebug.getDataWatches(zooKeeper).size() != 0) {                    if (isLast) {                        throw new AssertionError("One or more data watchers are still registered: " + WatchersDebug.getDataWatches(zooKeeper));                    }                    continue;                }                break;            }        }    } catch (IllegalStateException ignore) {        } catch (Exception e) {                e.printStackTrace();    } finally {        CloseableUtils.closeQuietly(client);    }}
7a211e67b1dcd7a04c2ae11b07617f2a6eaf7c246fe9114f0900ecce50ba5926
test
public static void test(CuratorFramework client, Callable<Void> proc) throws Exception
{    boolean succeeded = false;    try {        proc.call();        succeeded = true;    } finally {        if (succeeded) {            closeAndTestClean(client);        } else {            CloseableUtils.closeQuietly(client);        }    }}
c0068ed52c3162f8218249676672cd36cd6caf4321d897ac29c35d0c809985d6
testCompressionProvider
public void testCompressionProvider() throws Exception
{    final byte[] data = "here's a string".getBytes();    final AtomicInteger compressCounter = new AtomicInteger();    final AtomicInteger decompressCounter = new AtomicInteger();    CompressionProvider compressionProvider = new CompressionProvider() {        @Override        public byte[] compress(String path, byte[] data) throws Exception {            compressCounter.incrementAndGet();            byte[] bytes = new byte[data.length * 2];            System.arraycopy(data, 0, bytes, 0, data.length);            System.arraycopy(data, 0, bytes, data.length, data.length);            return bytes;        }        @Override        public byte[] decompress(String path, byte[] compressedData) throws Exception {            decompressCounter.incrementAndGet();            byte[] bytes = new byte[compressedData.length / 2];            System.arraycopy(compressedData, 0, bytes, 0, bytes.length);            return bytes;        }    };    CuratorFramework client = CuratorFrameworkFactory.builder().compressionProvider(compressionProvider).connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        client.create().compressed().creatingParentsIfNeeded().forPath("/a/b/c", data);        Assert.assertNotEquals(data, client.getData().forPath("/a/b/c"));        Assert.assertEquals(data.length, client.getData().decompressed().forPath("/a/b/c").length);    } finally {        CloseableUtils.closeQuietly(client);    }    Assert.assertEquals(compressCounter.get(), 1);    Assert.assertEquals(decompressCounter.get(), 1);}
6bc036cd8e9b142e45eadf7ea3df1ed854dd5f6cda92c51e95722456fcb49ff7
compress
public byte[] compress(String path, byte[] data) throws Exception
{    compressCounter.incrementAndGet();    byte[] bytes = new byte[data.length * 2];    System.arraycopy(data, 0, bytes, 0, data.length);    System.arraycopy(data, 0, bytes, data.length, data.length);    return bytes;}
42446b2ea6897e7ea2cc7b901f03cd8955a1b711b1b9e335ea2994dc3fbfc4be
decompress
public byte[] decompress(String path, byte[] compressedData) throws Exception
{    decompressCounter.incrementAndGet();    byte[] bytes = new byte[compressedData.length / 2];    System.arraycopy(compressedData, 0, bytes, 0, bytes.length);    return bytes;}
cd25e4c2d2b01bc45010c8ec6810d690e89e0778f3936e98d4a7344b326216d0
testSetData
public void testSetData() throws Exception
{    final byte[] data = "here's a string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/a/b/c", data);        Assert.assertEquals(data, client.getData().forPath("/a/b/c"));        client.setData().compressed().forPath("/a/b/c", data);        Assert.assertEquals(data.length, client.getData().decompressed().forPath("/a/b/c").length);    } finally {        CloseableUtils.closeQuietly(client);    }}
7e6ef9a15f502c76aa39b9e99c40c2704757556d14668cef0634754950c971d9
testSimple
public void testSimple() throws Exception
{    final byte[] data = "here's a string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.create().compressed().creatingParentsIfNeeded().forPath("/a/b/c", data);        Assert.assertNotEquals(data, client.getData().forPath("/a/b/c"));        Assert.assertEquals(data.length, client.getData().decompressed().forPath("/a/b/c").length);    } finally {        CloseableUtils.closeQuietly(client);    }}
cd25e4c2d2b01bc45010c8ec6810d690e89e0778f3936e98d4a7344b326216d0
testSetData
public void testSetData() throws Exception
{    final String path = "/a";    final byte[] data = "here's a string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();                CuratorOp op = client.transactionOp().create().forPath(path, data);        client.transaction().forOperations(op);        Assert.assertEquals(data, client.getData().forPath(path));                op = client.transactionOp().setData().compressed().forPath(path, data);        client.transaction().forOperations(op);        Assert.assertEquals(data, client.getData().decompressed().forPath(path));    } finally {        CloseableUtils.closeQuietly(client);    }}
3bc7d4a0b3e1004e2dd980c43678fc1adef412d4aa044e38ec3b0641d8515f9e
testSetCompressedAndUncompressed
public void testSetCompressedAndUncompressed() throws Exception
{    final String path1 = "/a";    final String path2 = "/b";    final byte[] data1 = "here's a string".getBytes();    final byte[] data2 = "here's another string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();                CuratorOp op1 = client.transactionOp().create().compressed().forPath(path1);        CuratorOp op2 = client.transactionOp().create().forPath(path2);        client.transaction().forOperations(op1, op2);                Assert.assertNotNull(client.checkExists().forPath(path1));        Assert.assertNotNull(client.checkExists().forPath(path2));                op1 = client.transactionOp().setData().compressed().forPath(path1, data1);        op2 = client.transactionOp().setData().forPath(path2, data2);        client.transaction().forOperations(op1, op2);        Assert.assertNotEquals(data1, client.getData().forPath(path1));        Assert.assertEquals(data1, client.getData().decompressed().forPath(path1));        Assert.assertEquals(data2, client.getData().forPath(path2));    } finally {        CloseableUtils.closeQuietly(client);    }}
7e6ef9a15f502c76aa39b9e99c40c2704757556d14668cef0634754950c971d9
testSimple
public void testSimple() throws Exception
{    final String path1 = "/a";    final String path2 = "/a/b";    final byte[] data1 = "here's a string".getBytes();    final byte[] data2 = "here's another string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        CuratorOp op1 = client.transactionOp().create().compressed().forPath(path1, data1);        CuratorOp op2 = client.transactionOp().create().compressed().forPath(path2, data2);        client.transaction().forOperations(op1, op2);        Assert.assertNotEquals(data1, client.getData().forPath(path1));        Assert.assertEquals(data1, client.getData().decompressed().forPath(path1));        Assert.assertNotEquals(data2, client.getData().forPath(path2));        Assert.assertEquals(data2, client.getData().decompressed().forPath(path2));    } finally {        CloseableUtils.closeQuietly(client);    }}
b83bb0cfe3010c03be6e6ee48cec771db09b03eaa6b02c2646d675d6c7e46d24
testCreateCompressedAndUncompressed
public void testCreateCompressedAndUncompressed() throws Exception
{    final String path1 = "/a";    final String path2 = "/b";    final byte[] data1 = "here's a string".getBytes();    final byte[] data2 = "here's another string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        CuratorOp op1 = client.transactionOp().create().compressed().forPath(path1, data1);        CuratorOp op2 = client.transactionOp().create().forPath(path2, data2);        client.transaction().forOperations(op1, op2);        Assert.assertNotEquals(data1, client.getData().forPath(path1));        Assert.assertEquals(data1, client.getData().decompressed().forPath(path1));        Assert.assertEquals(data2, client.getData().forPath(path2));    } finally {        CloseableUtils.closeQuietly(client);    }}
cd25e4c2d2b01bc45010c8ec6810d690e89e0778f3936e98d4a7344b326216d0
testSetData
public void testSetData() throws Exception
{    final String path = "/a";    final byte[] data = "here's a string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();                client.inTransaction().create().forPath(path, data).and().commit();        Assert.assertEquals(data, client.getData().forPath(path));                client.inTransaction().setData().compressed().forPath(path, data).and().commit();        Assert.assertEquals(data, client.getData().decompressed().forPath(path));    } finally {        CloseableUtils.closeQuietly(client);    }}
3bc7d4a0b3e1004e2dd980c43678fc1adef412d4aa044e38ec3b0641d8515f9e
testSetCompressedAndUncompressed
public void testSetCompressedAndUncompressed() throws Exception
{    final String path1 = "/a";    final String path2 = "/b";    final byte[] data1 = "here's a string".getBytes();    final byte[] data2 = "here's another string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();                client.inTransaction().create().compressed().forPath(path1).and().create().forPath(path2).and().commit();                Assert.assertNotNull(client.checkExists().forPath(path1));        Assert.assertNotNull(client.checkExists().forPath(path2));                client.inTransaction().setData().compressed().forPath(path1, data1).and().setData().forPath(path2, data2).and().commit();        Assert.assertNotEquals(data1, client.getData().forPath(path1));        Assert.assertEquals(data1, client.getData().decompressed().forPath(path1));        Assert.assertEquals(data2, client.getData().forPath(path2));    } finally {        CloseableUtils.closeQuietly(client);    }}
7e6ef9a15f502c76aa39b9e99c40c2704757556d14668cef0634754950c971d9
testSimple
public void testSimple() throws Exception
{    final String path1 = "/a";    final String path2 = "/a/b";    final byte[] data1 = "here's a string".getBytes();    final byte[] data2 = "here's another string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.inTransaction().create().compressed().forPath(path1, data1).and().create().compressed().forPath(path2, data2).and().commit();        Assert.assertNotEquals(data1, client.getData().forPath(path1));        Assert.assertEquals(data1, client.getData().decompressed().forPath(path1));        Assert.assertNotEquals(data2, client.getData().forPath(path2));        Assert.assertEquals(data2, client.getData().decompressed().forPath(path2));    } finally {        CloseableUtils.closeQuietly(client);    }}
b83bb0cfe3010c03be6e6ee48cec771db09b03eaa6b02c2646d675d6c7e46d24
testCreateCompressedAndUncompressed
public void testCreateCompressedAndUncompressed() throws Exception
{    final String path1 = "/a";    final String path2 = "/b";    final byte[] data1 = "here's a string".getBytes();    final byte[] data2 = "here's another string".getBytes();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.inTransaction().create().compressed().forPath(path1, data1).and().create().forPath(path2, data2).and().commit();        Assert.assertNotEquals(data1, client.getData().forPath(path1));        Assert.assertEquals(data1, client.getData().decompressed().forPath(path1));        Assert.assertEquals(data2, client.getData().forPath(path2));    } finally {        CloseableUtils.closeQuietly(client);    }}
608c4250279b9160905e4962b77bc1d258c8a726d186d1875dd0e18be5e9bcbb
getDefaultAcl
public List<ACL> getDefaultAcl()
{    return ZooDefs.Ids.OPEN_ACL_UNSAFE;}
948e924ac3cf12487fcf7f5ccc3b514ae7fc4b9d602a2962739b070d41126b34
getAclForPath
public List<ACL> getAclForPath(String path)
{    switch(path) {        case "/bar":            return READ_CREATE;        case "/bar/foo":            return READ_CREATE_WRITE;    }    return null;}
90237aa30ac85389a2b92347a22ff32fbe9415d1642b2df85b649f96a4c090c3
createClient
private CuratorFramework createClient(ACLProvider aclProvider)
{    return CuratorFrameworkFactory.builder().aclProvider(aclProvider).connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();}
bbe392d4f03c683d1ce76174f7a04ce44ebbda9f8a755c93a514e3df927a28a8
testCreateWithParentsWithAcl
public void testCreateWithParentsWithAcl() throws Exception
{    CuratorFramework client = createClient(new DefaultACLProvider());    try {        client.start();        String path = "/bar/foo";        List<ACL> acl = Collections.singletonList(new ACL(ZooDefs.Perms.CREATE | ZooDefs.Perms.READ, ANYONE_ID_UNSAFE));        client.create().creatingParentsIfNeeded().withACL(acl).forPath(path);        List<ACL> actual_bar_foo = client.getACL().forPath(path);        Assert.assertEquals(actual_bar_foo, acl);        List<ACL> actual_bar = client.getACL().forPath("/bar");        Assert.assertEquals(actual_bar, ZooDefs.Ids.OPEN_ACL_UNSAFE);    } finally {        CloseableUtils.closeQuietly(client);    }}
a89c9b9a9f1ffdca85729608b3d3073086931302acf22c5b461c92559de77d83
testCreateWithParentsWithAclApplyToParents
public void testCreateWithParentsWithAclApplyToParents() throws Exception
{    CuratorFramework client = createClient(new DefaultACLProvider());    try {        client.start();        String path = "/bar/foo";        List<ACL> acl = Collections.singletonList(new ACL(ZooDefs.Perms.CREATE | ZooDefs.Perms.READ, ANYONE_ID_UNSAFE));        client.create().creatingParentsIfNeeded().withACL(acl, true).forPath(path);        List<ACL> actual_bar_foo = client.getACL().forPath(path);        Assert.assertEquals(actual_bar_foo, acl);        List<ACL> actual_bar = client.getACL().forPath("/bar");        Assert.assertEquals(actual_bar, acl);    } finally {        CloseableUtils.closeQuietly(client);    }}
13e252ed8be7c78eab972e92bd0d794be760ab3131c02b0c7b9ac8d023875cae
testCreateWithParentsWithAclInBackground
public void testCreateWithParentsWithAclInBackground() throws Exception
{    CuratorFramework client = createClient(new DefaultACLProvider());    try {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        String path = "/bar/foo";        List<ACL> acl = Collections.singletonList(new ACL(ZooDefs.Perms.CREATE | ZooDefs.Perms.READ, ANYONE_ID_UNSAFE));        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                latch.countDown();            }        };        client.create().creatingParentsIfNeeded().withACL(acl).inBackground(callback).forPath(path);        Assert.assertTrue(latch.await(2000, TimeUnit.MILLISECONDS), "Callback not invoked");        List<ACL> actual_bar_foo = client.getACL().forPath(path);        Assert.assertEquals(actual_bar_foo, acl);        List<ACL> actual_bar = client.getACL().forPath("/bar");        Assert.assertEquals(actual_bar, ZooDefs.Ids.OPEN_ACL_UNSAFE);    } finally {        CloseableUtils.closeQuietly(client);    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
20d2ec31439a2bef1dca9bbb5572e5cdc01bff6fa55c9dd03ef14afbef57db48
testCreateWithParentsWithAclApplyToParentsInBackground
public void testCreateWithParentsWithAclApplyToParentsInBackground() throws Exception
{    CuratorFramework client = createClient(new DefaultACLProvider());    try {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        String path = "/bar/foo";        List<ACL> acl = Collections.singletonList(new ACL(ZooDefs.Perms.CREATE | ZooDefs.Perms.READ, ANYONE_ID_UNSAFE));        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                latch.countDown();            }        };        client.create().creatingParentsIfNeeded().withACL(acl, true).inBackground(callback).forPath(path);        Assert.assertTrue(latch.await(2000, TimeUnit.MILLISECONDS), "Callback not invoked");        List<ACL> actual_bar_foo = client.getACL().forPath(path);        Assert.assertEquals(actual_bar_foo, acl);        List<ACL> actual_bar = client.getACL().forPath("/bar");        Assert.assertEquals(actual_bar, acl);    } finally {        CloseableUtils.closeQuietly(client);    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
653aa609d2a780f1e1b2f3b461f57d08f6df473cf74fcc2b3fa144fda05b5839
testCreateWithParentsWithoutAcl
public void testCreateWithParentsWithoutAcl() throws Exception
{    CuratorFramework client = createClient(testACLProvider);    try {        client.start();        String path = "/bar/foo/boo";        client.create().creatingParentsIfNeeded().forPath(path);        List<ACL> actual_bar_foo_boo = client.getACL().forPath("/bar/foo/boo");        Assert.assertEquals(actual_bar_foo_boo, ZooDefs.Ids.OPEN_ACL_UNSAFE);        List<ACL> actual_bar_foo = client.getACL().forPath("/bar/foo");        Assert.assertEquals(actual_bar_foo, READ_CREATE_WRITE);        List<ACL> actual_bar = client.getACL().forPath("/bar");        Assert.assertEquals(actual_bar, READ_CREATE);    } finally {        CloseableUtils.closeQuietly(client);    }}
a52cffae0ec9feb0a4893c7f4c7908960ea8edd2ee7f61a5d42e5f5c5abf411f
testCreateWithParentsWithoutAclInBackground
public void testCreateWithParentsWithoutAclInBackground() throws Exception
{    CuratorFramework client = createClient(testACLProvider);    try {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                latch.countDown();            }        };        final String path = "/bar/foo/boo";        client.create().creatingParentsIfNeeded().inBackground(callback).forPath(path);        Assert.assertTrue(latch.await(2000, TimeUnit.MILLISECONDS), "Callback not invoked");        List<ACL> actual_bar_foo_boo = client.getACL().forPath(path);        Assert.assertEquals(actual_bar_foo_boo, ZooDefs.Ids.OPEN_ACL_UNSAFE);        List<ACL> actual_bar_foo = client.getACL().forPath("/bar/foo");        Assert.assertEquals(actual_bar_foo, READ_CREATE_WRITE);        List<ACL> actual_bar = client.getACL().forPath("/bar");        Assert.assertEquals(actual_bar, READ_CREATE);    } finally {        CloseableUtils.closeQuietly(client);    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
7d31b294e0314ec09f5b96e0547a31658bb58c73445a198979453f960a733763
createClient
private CuratorFramework createClient()
{    return CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();}
159d954687633f318638a48b58523cf578ba9365f8392058d1fbd3eacc6383a7
compare
private void compare(CuratorFramework client, String path, Stat expected) throws Exception
{    Stat queriedStat = client.checkExists().forPath(path);    Assert.assertEquals(queriedStat, expected);}
23eb698d2ce6c09cb9773862a3257bd4a3f3b346e61e63f7476f0edebfa1405e
testOrSetDataStoringStatIn
public void testOrSetDataStoringStatIn() throws Exception
{    try (CuratorFramework client = createClient()) {        client.start();        client.getZookeeperClient().blockUntilConnectedOrTimedOut();        final String path = "/test";        final Stat versionZeroStat = new Stat();        client.create().orSetData().storingStatIn(versionZeroStat).forPath(path);        Assert.assertEquals(0, versionZeroStat.getVersion());        final Stat versionOneStat = new Stat();        client.create().orSetData().storingStatIn(versionOneStat).forPath(path);        Assert.assertEquals(versionZeroStat.getAversion(), versionOneStat.getAversion());        Assert.assertEquals(versionZeroStat.getCtime(), versionOneStat.getCtime());        Assert.assertEquals(versionZeroStat.getCversion(), versionOneStat.getCversion());        Assert.assertEquals(versionZeroStat.getCzxid(), versionOneStat.getCzxid());        Assert.assertEquals(versionZeroStat.getDataLength(), versionOneStat.getDataLength());        Assert.assertEquals(versionZeroStat.getEphemeralOwner(), versionOneStat.getEphemeralOwner());        Assert.assertTrue(versionZeroStat.getMtime() <= versionOneStat.getMtime());        Assert.assertNotEquals(versionZeroStat.getMzxid(), versionOneStat.getMzxid());        Assert.assertEquals(versionZeroStat.getNumChildren(), versionOneStat.getNumChildren());        Assert.assertEquals(versionZeroStat.getPzxid(), versionOneStat.getPzxid());        Assert.assertEquals(1, versionOneStat.getVersion());    }}
7b7a0dc4650ef0d4098ced6f15bcec15b1e17b1b2b2719d0061b40effacb97ce
testCreateReturningStat
public void testCreateReturningStat() throws Exception
{    CuratorFramework client = createClient();    try {        client.start();        String path = "/bla";        Stat stat = new Stat();        client.create().storingStatIn(stat).forPath(path);        compare(client, path, stat);    } finally {        CloseableUtils.closeQuietly(client);    }}
fd2af54324f74c6ffcf9f189325d7da4bf15dca12bbccb20dc6eb94e112f62e7
testCreateReturningStatIncludingParents
public void testCreateReturningStatIncludingParents() throws Exception
{    CuratorFramework client = createClient();    try {        client.start();        String path = "/bla/bla";        Stat stat = new Stat();        client.create().creatingParentsIfNeeded().storingStatIn(stat).forPath(path);        compare(client, path, stat);    } finally {        CloseableUtils.closeQuietly(client);    }}
4e059f9c331920d9b4a5fb28da3acde34e20afcc114dfe134a0d970a4ad0425a
testCreateReturningStatIncludingParentsReverse
public void testCreateReturningStatIncludingParentsReverse() throws Exception
{    CuratorFramework client = createClient();    try {        client.start();        String path = "/bla/bla";        Stat stat = new Stat();        client.create().storingStatIn(stat).creatingParentsIfNeeded().forPath(path);        compare(client, path, stat);    } finally {        CloseableUtils.closeQuietly(client);    }}
de9c060a83c4a7e2c7420fda151f61f8f9891dd565575d1c3388363e85ea168b
testCreateReturningStatCompressed
public void testCreateReturningStatCompressed() throws Exception
{    CuratorFramework client = createClient();    try {        client.start();        String path = "/bla";        Stat stat = new Stat();        client.create().compressed().storingStatIn(stat).forPath(path);        compare(client, path, stat);    } finally {        CloseableUtils.closeQuietly(client);    }}
d541a5a166bbebfb4d1d7795136ae5942e6967934cdf5de61b77466b31ae32a1
testCreateReturningStatWithProtected
public void testCreateReturningStatWithProtected() throws Exception
{    CuratorFramework client = createClient();    try {        client.start();        String path = "/bla";        Stat stat = new Stat();        path = client.create().withProtection().storingStatIn(stat).forPath(path);        compare(client, path, stat);    } finally {        CloseableUtils.closeQuietly(client);    }}
13e313c595535e3d88d4e3513977aa2c8681ebf26039db108feb879f5888109e
testCreateReturningStatInBackground
public void testCreateReturningStatInBackground() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = createClient();    try {        client.start();        String path = "/bla";        Stat stat = new Stat();        final CountDownLatch latch = new CountDownLatch(1);        final AtomicReference<Stat> statRef = new AtomicReference<>();        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.CREATE) {                    statRef.set(event.getStat());                    latch.countDown();                }            }        };        client.create().storingStatIn(stat).inBackground(callback).forPath(path);        if (!timing.awaitLatch(latch)) {            Assert.fail("Timed out awaing latch");        }        compare(client, path, statRef.get());        compare(client, path, stat);    } finally {        CloseableUtils.closeQuietly(client);    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.CREATE) {        statRef.set(event.getStat());        latch.countDown();    }}
27681e68ec2a1eb903f955680ebe003ceb3707295c8aad884b692d378c6e37cf
setup
public void setup() throws Exception
{    super.setup();    client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).connectionTimeoutMs(timing.connection()).sessionTimeoutMs(timing.session()).retryPolicy(new RetryOneTime(1)).build();    client.start();    states = Queues.newLinkedBlockingQueue();    ConnectionStateListener listener = new ConnectionStateListener() {        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {            states.add(newState);        }    };    client.getConnectionStateListenable().addListener(listener);}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    states.add(newState);}
7c529460b940c419ef707bd1846a5575ea1bfc48c129127836c31f0184c1d8fb
teardown
public void teardown() throws Exception
{    try {        CloseableUtils.closeQuietly(client);    } finally {        super.teardown();    }}
07ffd9fa5ae6f0cc62989391a6eac3958e8898a64ecb752106cd38824e8d6816
testResetCausesLost
public void testResetCausesLost() throws Exception
{    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED);        client.checkExists().forPath("/");    client.getZookeeperClient().reset();    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST);    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.RECONNECTED);}
a0041c2b200206db4c44b49d1f5931a9b429ab03a2404b0cc2e60074a224ca6e
testInjectedWatchedEvent
public void testInjectedWatchedEvent() throws Exception
{    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED);    final CountDownLatch latch = new CountDownLatch(1);    Watcher watcher = new Watcher() {        @Override        public void process(WatchedEvent event) {            if (event.getType() == Event.EventType.None) {                if (event.getState() == Event.KeeperState.Expired) {                    latch.countDown();                }            }        }    };    client.checkExists().usingWatcher(watcher).forPath("/");    server.stop();    Assert.assertTrue(timing.forSessionSleep().awaitLatch(latch));}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (event.getType() == Event.EventType.None) {        if (event.getState() == Event.KeeperState.Expired) {            latch.countDown();        }    }}
967c5be49e759c2cfc86b202db2b3e9c280b76791538a58b6a63495f9856c25a
testKillSession
public void testKillSession() throws Exception
{    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED);    Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());    Assert.assertEquals(states.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST);    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.RECONNECTED);}
b0a6e5fe77c656968156c720a6b1b9e17623440bffaa46910193c37b0c25674a
testReconnectWithoutExpiration
public void testReconnectWithoutExpiration() throws Exception
{    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED);    server.stop();    try {                client.checkExists().forPath("/");    } catch (KeeperException.ConnectionLossException ignore) {    }    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED);    server.restart();    client.checkExists().forPath("/");    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.RECONNECTED);}
6ee6b2ddba633987d4ace64cc8f5f7e2da2d4f264e7995942d308c1432147c14
testSessionExpirationFromTimeout
public void testSessionExpirationFromTimeout() throws Exception
{    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED);    server.stop();    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED);    Assert.assertEquals(states.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST);}
1e26784a1a07bac4e04dc6b03c623941d07e723027bc2d7d2b251b4095430863
testSessionExpirationFromTimeoutWithRestart
public void testSessionExpirationFromTimeoutWithRestart() throws Exception
{    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED);    server.stop();    timing.forSessionSleep().sleep();    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED);    Assert.assertEquals(states.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST);    server.restart();    client.checkExists().forPath("/");    Assert.assertEquals(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.RECONNECTED);        Assert.assertNull(states.poll(timing.multiple(.5).milliseconds(), TimeUnit.MILLISECONDS));}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        EnsureContainers ensureContainers = new EnsureContainers(client, "/one/two/three");        ensureContainers.ensure();        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(client);    }}
e9cda63250f09a5fd717b247faecf7cad2c06ce65f1545a81d3daf77c302f07b
testSingleExecution
public void testSingleExecution() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        EnsureContainers ensureContainers = new EnsureContainers(client, "/one/two/three");        ensureContainers.ensure();        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        client.delete().forPath("/one/two/three");        ensureContainers.ensure();        Assert.assertNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(client);    }}
101c163d07f7b6d30aa54b8c8c1c06bb3b07e78e1e694b3082066db8bcdb5d74
testExistsWithParentsWithAclApplyToParents
public void testExistsWithParentsWithAclApplyToParents() throws Exception
{    CuratorFramework client = createClient(new DefaultACLProvider());    try {        client.start();        String path = "/bar/foo/test";        List<ACL> acl = Collections.singletonList(new ACL(ZooDefs.Perms.CREATE | ZooDefs.Perms.READ, ANYONE_ID_UNSAFE));        assertNull(client.checkExists().creatingParentsIfNeeded().withACL(acl).forPath(path));        List<ACL> actual_bar = client.getACL().forPath("/bar");        Assert.assertEquals(actual_bar, acl);        List<ACL> actual_bar_foo = client.getACL().forPath("/bar/foo");        Assert.assertEquals(actual_bar_foo, acl);    } finally {        CloseableUtils.closeQuietly(client);    }}
244b9ce97c75ca6a10e0cfa7fc38414bf1cbe51e255cd34e41e9bbbb1cc23ef1
testExistsWithParentsWithAclApplyToParentsInBackground
public void testExistsWithParentsWithAclApplyToParentsInBackground() throws Exception
{    CuratorFramework client = createClient(new DefaultACLProvider());    try {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        String path = "/bar/foo/test";        List<ACL> acl = Collections.singletonList(new ACL(ZooDefs.Perms.CREATE | ZooDefs.Perms.READ, ANYONE_ID_UNSAFE));        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                latch.countDown();            }        };        client.checkExists().creatingParentsIfNeeded().withACL(acl).inBackground(callback).forPath(path);        Assert.assertTrue(latch.await(2000, TimeUnit.MILLISECONDS), "Callback not invoked");        List<ACL> actual_bar = client.getACL().forPath("/bar");        Assert.assertEquals(actual_bar, acl);        List<ACL> actual_bar_foo = client.getACL().forPath("/bar/foo");        Assert.assertEquals(actual_bar_foo, acl);    } finally {        CloseableUtils.closeQuietly(client);    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
90237aa30ac85389a2b92347a22ff32fbe9415d1642b2df85b649f96a4c090c3
createClient
private CuratorFramework createClient(ACLProvider aclProvider)
{    return CuratorFrameworkFactory.builder().aclProvider(aclProvider).connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();}
14288071c8be24c7b8b2dd7ef86677d54505fa2756b64afb447cfc160003a958
testLostSession
public void testLostSession() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));    try {        client.start();        client.create().forPath("/test-me");        final CountDownLatch latch = new CountDownLatch(1);        final Semaphore semaphore = new Semaphore(0);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if ((newState == ConnectionState.LOST) || (newState == ConnectionState.SUSPENDED)) {                    semaphore.release();                } else if (newState == ConnectionState.RECONNECTED) {                    latch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        server.stop();        Assert.assertTrue(timing.acquireSemaphore(semaphore));        try {            client.delete().guaranteed().forPath("/test-me");            Assert.fail();        } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {                }        Assert.assertTrue(timing.acquireSemaphore(semaphore));        timing.sleepABit();        server.restart();        Assert.assertTrue(timing.awaitLatch(latch));        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/test-me"));    } finally {        CloseableUtils.closeQuietly(client);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if ((newState == ConnectionState.LOST) || (newState == ConnectionState.SUSPENDED)) {        semaphore.release();    } else if (newState == ConnectionState.RECONNECTED) {        latch.countDown();    }}
047a9dbe3886063d11c1c67b66396d650f488ea52665c29ca59afea13df9ba2a
testWithNamespaceAndLostSession
public void testWithNamespaceAndLostSession() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new ExponentialBackoffRetry(100, 3)).namespace("aisa").build();    try {        client.start();        client.create().forPath("/test-me");        final CountDownLatch latch = new CountDownLatch(1);        final Semaphore semaphore = new Semaphore(0);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if ((newState == ConnectionState.LOST) || (newState == ConnectionState.SUSPENDED)) {                    semaphore.release();                } else if (newState == ConnectionState.RECONNECTED) {                    latch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        server.stop();        Assert.assertTrue(timing.acquireSemaphore(semaphore));        try {            client.delete().guaranteed().forPath("/test-me");            Assert.fail();        } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {                }        Assert.assertTrue(timing.acquireSemaphore(semaphore));        timing.sleepABit();        server.restart();        Assert.assertTrue(timing.awaitLatch(latch));        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/test-me"));    } finally {        CloseableUtils.closeQuietly(client);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if ((newState == ConnectionState.LOST) || (newState == ConnectionState.SUSPENDED)) {        semaphore.release();    } else if (newState == ConnectionState.RECONNECTED) {        latch.countDown();    }}
3198e597e0d05cc26ae254005a201f5f092538a848d99ed7c14c4af51148b965
testWithNamespaceAndLostSessionAlt
public void testWithNamespaceAndLostSessionAlt() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new ExponentialBackoffRetry(100, 3)).build();    try {        client.start();        CuratorFramework namespaceClient = client.usingNamespace("foo");        namespaceClient.create().forPath("/test-me");        final CountDownLatch latch = new CountDownLatch(1);        final Semaphore semaphore = new Semaphore(0);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if ((newState == ConnectionState.LOST) || (newState == ConnectionState.SUSPENDED)) {                    semaphore.release();                } else if (newState == ConnectionState.RECONNECTED) {                    latch.countDown();                }            }        };        namespaceClient.getConnectionStateListenable().addListener(listener);        server.stop();        Assert.assertTrue(timing.acquireSemaphore(semaphore));        try {            namespaceClient.delete().guaranteed().forPath("/test-me");            Assert.fail();        } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {                }        Assert.assertTrue(timing.acquireSemaphore(semaphore));        timing.sleepABit();        server.restart();        Assert.assertTrue(timing.awaitLatch(latch));        timing.sleepABit();        Assert.assertNull(namespaceClient.checkExists().forPath("/test-me"));    } finally {        CloseableUtils.closeQuietly(client);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if ((newState == ConnectionState.LOST) || (newState == ConnectionState.SUSPENDED)) {        semaphore.release();    } else if (newState == ConnectionState.RECONNECTED) {        latch.countDown();    }}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    final String PATH = "/one/two/three";    Timing timing = new Timing();    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).connectionTimeoutMs(timing.connection()).sessionTimeoutMs(timing.session());    CuratorFrameworkImpl client = new CuratorFrameworkImpl(builder);    client.start();    try {        client.create().creatingParentsIfNeeded().forPath(PATH);        Assert.assertNotNull(client.checkExists().forPath(PATH));                server.stop();        try {            client.delete().forPath(PATH);            Assert.fail();        } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {                }        server.restart();        Assert.assertNotNull(client.checkExists().forPath(PATH));                server.stop();        try {            client.delete().guaranteed().forPath(PATH);            Assert.fail();        } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {                }        server.restart();        final int TRIES = 5;        for (int i = 0; i < TRIES; ++i) {            if (client.checkExists().forPath(PATH) != null) {                timing.sleepABit();            }        }        Assert.assertNull(client.checkExists().forPath(PATH));    } finally {        CloseableUtils.closeQuietly(client);    }}
4cc921151f6e4ba9e03ff82943eaa32b4fec3c95089ff0c3f4202fe4fd875745
testGuaranteedDeleteOnNonExistentNodeInForeground
public void testGuaranteedDeleteOnNonExistentNodeInForeground() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    final AtomicBoolean pathAdded = new AtomicBoolean(false);    ((CuratorFrameworkImpl) client).getFailedDeleteManager().debugListener = new FailedOperationManager.FailedOperationManagerListener<String>() {        @Override        public void pathAddedForGuaranteedOperation(String path) {            pathAdded.set(true);        }    };    try {        client.delete().guaranteed().forPath("/nonexistent");        Assert.fail();    } catch (NoNodeException e) {                Assert.assertFalse(pathAdded.get());    } finally {        client.close();    }}
ece007f6f803959953e336b6c4ed0611844d48b85d337b24af51b40595fdd984
pathAddedForGuaranteedOperation
public void pathAddedForGuaranteedOperation(String path)
{    pathAdded.set(true);}
b5a69cacd94f24dc96125b0c1f80644a91a5ed4652dc9d5638fff1c4019e53ff
testGuaranteedDeleteOnNonExistentNodeInBackground
public void testGuaranteedDeleteOnNonExistentNodeInBackground() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    final AtomicBoolean pathAdded = new AtomicBoolean(false);    ((CuratorFrameworkImpl) client).getFailedDeleteManager().debugListener = new FailedOperationManager.FailedOperationManagerListener<String>() {        @Override        public void pathAddedForGuaranteedOperation(String path) {            pathAdded.set(true);        }    };    final CountDownLatch backgroundLatch = new CountDownLatch(1);    BackgroundCallback background = new BackgroundCallback() {        @Override        public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {            backgroundLatch.countDown();        }    };    try {        client.delete().guaranteed().inBackground(background).forPath("/nonexistent");        backgroundLatch.await();                Assert.assertFalse(pathAdded.get());    } finally {        client.close();    }}
ece007f6f803959953e336b6c4ed0611844d48b85d337b24af51b40595fdd984
pathAddedForGuaranteedOperation
public void pathAddedForGuaranteedOperation(String path)
{    pathAdded.set(true);}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    backgroundLatch.countDown();}
27681e68ec2a1eb903f955680ebe003ceb3707295c8aad884b692d378c6e37cf
setup
public void setup() throws Exception
{    System.setProperty("znode.container.checkIntervalMs", "1000");    super.setup();}
7c529460b940c419ef707bd1846a5575ea1bfc48c129127836c31f0184c1d8fb
teardown
public void teardown() throws Exception
{    System.clearProperty("znode.container.checkIntervalMs");    super.teardown();}
f7bfda2c95d264d8117331774e30785c0322de1609caa46b89a479a389cf650b
testWaitForShutdownTimeoutMs
public void testWaitForShutdownTimeoutMs() throws Exception
{    final BlockingQueue<Integer> timeoutQueue = new ArrayBlockingQueue<>(1);    ZookeeperFactory zookeeperFactory = new ZookeeperFactory() {        @Override        public ZooKeeper newZooKeeper(String connectString, int sessionTimeout, Watcher watcher, boolean canBeReadOnly) throws IOException {            return new ZooKeeper(connectString, sessionTimeout, watcher, canBeReadOnly) {                @Override                public boolean close(int waitForShutdownTimeoutMs) throws InterruptedException {                    timeoutQueue.add(waitForShutdownTimeoutMs);                    return super.close(waitForShutdownTimeoutMs);                }            };        }    };    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).zookeeperFactory(zookeeperFactory).waitForShutdownTimeoutMs(10064).build();    try {        client.start();        client.checkExists().forPath("/foo");    } finally {        CloseableUtils.closeQuietly(client);    }    Integer polledValue = timeoutQueue.poll(new Timing().milliseconds(), TimeUnit.MILLISECONDS);    Assert.assertNotNull(polledValue);    Assert.assertEquals(10064, polledValue.intValue());}
42a640cd6431ba0d0a97c768177933f3964fcadc11a5075a7d2438b25cccfe85
newZooKeeper
public ZooKeeper newZooKeeper(String connectString, int sessionTimeout, Watcher watcher, boolean canBeReadOnly) throws IOException
{    return new ZooKeeper(connectString, sessionTimeout, watcher, canBeReadOnly) {        @Override        public boolean close(int waitForShutdownTimeoutMs) throws InterruptedException {            timeoutQueue.add(waitForShutdownTimeoutMs);            return super.close(waitForShutdownTimeoutMs);        }    };}
d6246bc2641676ec01115cfdb896356efcda150d7296cee7e24a187a5a0418d0
close
public boolean close(int waitForShutdownTimeoutMs) throws InterruptedException
{    timeoutQueue.add(waitForShutdownTimeoutMs);    return super.close(waitForShutdownTimeoutMs);}
ecbdb9be5a3ddb7dd46021aa17a67a2a33f97f45694d734ddd8e64eef7b12f37
testSessionLossWithLongTimeout
public void testSessionLossWithLongTimeout() throws Exception
{    final Timing timing = new Timing();    try (final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.forWaiting().milliseconds(), timing.connection(), new RetryOneTime(1))) {        final CountDownLatch connectedLatch = new CountDownLatch(1);        final CountDownLatch lostLatch = new CountDownLatch(1);        final CountDownLatch restartedLatch = new CountDownLatch(1);        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.CONNECTED) {                    connectedLatch.countDown();                } else if (newState == ConnectionState.LOST) {                    lostLatch.countDown();                } else if (newState == ConnectionState.RECONNECTED) {                    restartedLatch.countDown();                }            }        });        client.start();        Assert.assertTrue(timing.awaitLatch(connectedLatch));        server.stop();        timing.sleepABit();        Assert.assertTrue(timing.awaitLatch(lostLatch));        server.restart();        Assert.assertTrue(timing.awaitLatch(restartedLatch));    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    } else if (newState == ConnectionState.LOST) {        lostLatch.countDown();    } else if (newState == ConnectionState.RECONNECTED) {        restartedLatch.countDown();    }}
09944facd4b4fd465b020fadbf71fc3a9d8eace08f492a40b8c4d2f3e9a34147
testConnectionState
public void testConnectionState() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        final BlockingQueue<ConnectionState> queue = new LinkedBlockingQueue<ConnectionState>();        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                queue.add(newState);            }        };        client.getConnectionStateListenable().addListener(listener);        client.start();        Assert.assertEquals(queue.poll(timing.multiple(4).seconds(), TimeUnit.SECONDS), ConnectionState.CONNECTED);        server.stop();        Assert.assertEquals(queue.poll(timing.multiple(4).seconds(), TimeUnit.SECONDS), ConnectionState.SUSPENDED);        Assert.assertEquals(queue.poll(timing.multiple(4).seconds(), TimeUnit.SECONDS), ConnectionState.LOST);    } finally {        CloseableUtils.closeQuietly(client);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    queue.add(newState);}
899fc4045a80dadd48a50ad17ee8c83f4421a9b6244b0c2d5e32081d8d6e5b43
testCreateOrSetData
public void testCreateOrSetData() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        String name = client.create().forPath("/hey", "there".getBytes());        Assert.assertEquals(name, "/hey");        name = client.create().orSetData().forPath("/hey", "other".getBytes());        Assert.assertEquals(name, "/hey");        Assert.assertEquals(client.getData().forPath("/hey"), "other".getBytes());        name = client.create().orSetData().creatingParentsIfNeeded().forPath("/a/b/c", "there".getBytes());        Assert.assertEquals(name, "/a/b/c");        name = client.create().orSetData().creatingParentsIfNeeded().forPath("/a/b/c", "what".getBytes());        Assert.assertEquals(name, "/a/b/c");        Assert.assertEquals(client.getData().forPath("/a/b/c"), "what".getBytes());        final BlockingQueue<CuratorEvent> queue = new LinkedBlockingQueue<>();        BackgroundCallback backgroundCallback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                queue.add(event);            }        };        client.create().orSetData().inBackground(backgroundCallback).forPath("/a/b/c", "another".getBytes());        CuratorEvent event = queue.poll(new Timing().milliseconds(), TimeUnit.MILLISECONDS);        Assert.assertNotNull(event);        Assert.assertEquals(event.getResultCode(), KeeperException.Code.OK.intValue());        Assert.assertEquals(event.getType(), CuratorEventType.CREATE);        Assert.assertEquals(event.getPath(), "/a/b/c");        Assert.assertEquals(event.getName(), "/a/b/c");                CuratorEvent unexpectedEvent = queue.poll(new Timing().milliseconds(), TimeUnit.MILLISECONDS);        Assert.assertNull(unexpectedEvent);    } finally {        CloseableUtils.closeQuietly(client);    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    queue.add(event);}
3540d895af45dbd440c9ff37f642ddb1d8d5ec4856c98b18c3be6a49fce318c3
testQuietDelete
public void testQuietDelete() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.delete().quietly().forPath("/foo/bar");        final BlockingQueue<Integer> rc = new LinkedBlockingQueue<>();        BackgroundCallback backgroundCallback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                rc.add(event.getResultCode());            }        };        client.delete().quietly().inBackground(backgroundCallback).forPath("/foo/bar/hey");        Integer code = rc.poll(new Timing().milliseconds(), TimeUnit.MILLISECONDS);        Assert.assertNotNull(code);        Assert.assertEquals(code.intValue(), KeeperException.Code.OK.intValue());    } finally {        CloseableUtils.closeQuietly(client);    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    rc.add(event.getResultCode());}
3dde1eb790d57617bc9a8a1cc93da9a7f217b15221b030f585c14a5bd07eec54
testNamespaceWithWatcher
public void testNamespaceWithWatcher() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).namespace("aisa").retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        final BlockingQueue<String> queue = new LinkedBlockingQueue<String>();        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                try {                    queue.put(event.getPath());                } catch (InterruptedException e) {                    throw new Error(e);                }            }        };        client.create().forPath("/base");        client.getChildren().usingWatcher(watcher).forPath("/base");        client.create().forPath("/base/child");        String path = new Timing2().takeFromQueue(queue);        Assert.assertEquals(path, "/base");    } finally {        CloseableUtils.closeQuietly(client);    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    try {        queue.put(event.getPath());    } catch (InterruptedException e) {        throw new Error(e);    }}
fef8c6a1c457f2f5117f1d8d96997f93e0b8387020fc39d3da9eb8869a8607a8
testNamespaceInBackground
public void testNamespaceInBackground() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).namespace("aisa").retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        final BlockingQueue<String> queue = new LinkedBlockingQueue<String>();        CuratorListener listener = new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.EXISTS) {                    queue.put(event.getPath());                }            }        };        client.getCuratorListenable().addListener(listener);        client.create().forPath("/base");        client.checkExists().inBackground().forPath("/base");        String path = queue.poll(10, TimeUnit.SECONDS);        Assert.assertEquals(path, "/base");        client.getCuratorListenable().removeListener(listener);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                queue.put(event.getPath());            }        };        client.getChildren().inBackground(callback).forPath("/base");        path = queue.poll(10, TimeUnit.SECONDS);        Assert.assertEquals(path, "/base");    } finally {        CloseableUtils.closeQuietly(client);    }}
e958fd31854b02620bcc0e47a47ca286f0584d1be38198248b0d2054a45a8cea
eventReceived
public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.EXISTS) {        queue.put(event.getPath());    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    queue.put(event.getPath());}
f3c6aec4239e1ab5832a00263623aed6d78c356e92f6e518a9882eee6d01748d
testCreateACLSingleAuth
public void testCreateACLSingleAuth() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).authorization("digest", "me1:pass1".getBytes()).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        ACL acl = new ACL(ZooDefs.Perms.WRITE, ZooDefs.Ids.AUTH_IDS);        List<ACL> aclList = Lists.newArrayList(acl);        client.create().withACL(aclList).forPath("/test", "test".getBytes());        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "me1:pass1".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            client.setData().forPath("/test", "test".getBytes());        } catch (KeeperException.NoAuthException e) {            Assert.fail("Auth failed");        }        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "something:else".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            client.setData().forPath("/test", "test".getBytes());            Assert.fail("Should have failed with auth exception");        } catch (KeeperException.NoAuthException e) {                }    } finally {        CloseableUtils.closeQuietly(client);    }}
c7924b077f11e395651ba789623727d8877dda47bbb1ebc4e63877c8dfe36b4a
testACLDeprecatedApis
public void testACLDeprecatedApis() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1));    Assert.assertNull(builder.getAuthScheme());    Assert.assertNull(builder.getAuthValue());    builder = builder.authorization("digest", "me1:pass1".getBytes());    Assert.assertEquals(builder.getAuthScheme(), "digest");    Assert.assertEquals(builder.getAuthValue(), "me1:pass1".getBytes());}
acf2b34ac3f45c02e841180a38327d25139350d5b14fd594bdf966d6e5015cf7
testCreateACLMultipleAuths
public void testCreateACLMultipleAuths() throws Exception
{        List<AuthInfo> authInfos = new ArrayList<AuthInfo>();    authInfos.add(new AuthInfo("digest", "me1:pass1".getBytes()));    authInfos.add(new AuthInfo("digest", "me2:pass2".getBytes()));    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).authorization(authInfos).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        ACL acl = new ACL(ZooDefs.Perms.WRITE, ZooDefs.Ids.AUTH_IDS);        List<ACL> aclList = Lists.newArrayList(acl);        client.create().withACL(aclList).forPath("/test", "test".getBytes());        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "me1:pass1".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            client.setData().forPath("/test", "test".getBytes());        } catch (KeeperException.NoAuthException e) {            Assert.fail("Auth failed");        }        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "me2:pass2".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            client.setData().forPath("/test", "test".getBytes());        } catch (KeeperException.NoAuthException e) {            Assert.fail("Auth failed");        }        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "something:else".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            client.setData().forPath("/test", "test".getBytes());            Assert.fail("Should have failed with auth exception");        } catch (KeeperException.NoAuthException e) {                }    } finally {        CloseableUtils.closeQuietly(client);    }}
59e3713ee5f73d8681e44b532dc66e22c16f22aeef102a672e123793c79af6b9
testCreateACLWithReset
public void testCreateACLWithReset() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).authorization("digest", "me:pass".getBytes()).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        final CountDownLatch lostLatch = new CountDownLatch(1);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    lostLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        ACL acl = new ACL(ZooDefs.Perms.WRITE, ZooDefs.Ids.AUTH_IDS);        List<ACL> aclList = Lists.newArrayList(acl);        client.create().withACL(aclList).forPath("/test", "test".getBytes());        server.stop();        Assert.assertTrue(timing.awaitLatch(lostLatch));        try {            client.checkExists().forPath("/");            Assert.fail("Connection should be down");        } catch (KeeperException.ConnectionLossException e) {                }        server.restart();        try {            client.setData().forPath("/test", "test".getBytes());        } catch (KeeperException.NoAuthException e) {            Assert.fail("Auth failed");        }    } finally {        CloseableUtils.closeQuietly(client);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        lostLatch.countDown();    }}
caba90133d27da25374d789c0091f2f81c52e334063767c0b3b5f45f34124329
testCreateParents
public void testCreateParents() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        client.create().creatingParentsIfNeeded().forPath("/one/two/three", "foo".getBytes());        byte[] data = client.getData().forPath("/one/two/three");        Assert.assertEquals(data, "foo".getBytes());        client.create().creatingParentsIfNeeded().forPath("/one/two/another", "bar".getBytes());        data = client.getData().forPath("/one/two/another");        Assert.assertEquals(data, "bar".getBytes());    } finally {        CloseableUtils.closeQuietly(client);    }}
adf38268ca9d33f020a8dad45c6798ffe9927f6e3867e8fab393565ad394a637
testOverrideCreateParentContainers
public void testOverrideCreateParentContainers() throws Exception
{    if (!checkForContainers()) {        return;    }    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).dontUseContainerParents().build();    try {        client.start();        client.create().creatingParentContainersIfNeeded().forPath("/one/two/three", "foo".getBytes());        byte[] data = client.getData().forPath("/one/two/three");        Assert.assertEquals(data, "foo".getBytes());        client.delete().forPath("/one/two/three");        new Timing().sleepABit();        Assert.assertNotNull(client.checkExists().forPath("/one/two"));        new Timing().sleepABit();        Assert.assertNotNull(client.checkExists().forPath("/one"));    } finally {        CloseableUtils.closeQuietly(client);    }}
ab8dd35b09234632f16034d94cad1562cf6db4d875be8d3d96991e8185caaed1
testCreateParentContainers
public void testCreateParentContainers() throws Exception
{    if (!checkForContainers()) {        return;    }    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        client.create().creatingParentContainersIfNeeded().forPath("/one/two/three", "foo".getBytes());        byte[] data = client.getData().forPath("/one/two/three");        Assert.assertEquals(data, "foo".getBytes());        client.delete().forPath("/one/two/three");        new Timing().sleepABit();        Assert.assertNull(client.checkExists().forPath("/one/two"));        new Timing().sleepABit();        Assert.assertNull(client.checkExists().forPath("/one"));    } finally {        CloseableUtils.closeQuietly(client);    }}
e1648d823b54cca25a9328f7b965961dc52080b8ca5472adeb50e9af61556638
checkForContainers
private boolean checkForContainers()
{    if (ZKPaths.getContainerCreateMode() == CreateMode.PERSISTENT) {        System.out.println("Not using CreateMode.CONTAINER enabled version of ZooKeeper");        return false;    }    return true;}
821e611866b72b1a13969b1951b3b21f7e7809e603389a986feb72d4f43d9564
testCreatingParentsTheSame
public void testCreatingParentsTheSame() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        Assert.assertNull(client.checkExists().forPath("/one/two"));        client.create().creatingParentContainersIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two"));        client.delete().deletingChildrenIfNeeded().forPath("/one");        Assert.assertNull(client.checkExists().forPath("/one"));        Assert.assertNull(client.checkExists().forPath("/one/two"));        client.checkExists().creatingParentContainersIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two"));        Assert.assertNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(client);    }}
3d1d19624ef0a2aa0c3c6c8ac2e6dee35caa9eb96633f67e4763dc5c7b3f2f39
testExistsCreatingParents
public void testExistsCreatingParents() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        Assert.assertNull(client.checkExists().forPath("/one/two"));        client.checkExists().creatingParentContainersIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two"));        Assert.assertNull(client.checkExists().forPath("/one/two/three"));        Assert.assertNull(client.checkExists().creatingParentContainersIfNeeded().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(client);    }}
7042d2ebbdd168f66e0639b63d95006dc87cc3ec6ef4325e70fb0df20b01ae55
testExistsCreatingParentsInBackground
public void testExistsCreatingParentsInBackground() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        Assert.assertNull(client.checkExists().forPath("/one/two"));        final CountDownLatch latch = new CountDownLatch(1);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                latch.countDown();            }        };        client.checkExists().creatingParentContainersIfNeeded().inBackground(callback).forPath("/one/two/three");        Assert.assertTrue(new Timing().awaitLatch(latch));        Assert.assertNotNull(client.checkExists().forPath("/one/two"));        Assert.assertNull(client.checkExists().forPath("/one/two/three"));        Assert.assertNull(client.checkExists().creatingParentContainersIfNeeded().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(client);    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
760d261ef8390f591640e3ba4ce779ecc103a31fedefc74607667b9cbcb305a5
testEnsurePathWithNamespace
public void testEnsurePathWithNamespace() throws Exception
{    final String namespace = "jz";    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace(namespace).build();    client.start();    try {        EnsurePath ensurePath = new EnsurePath("/pity/the/fool");        ensurePath.ensure(client.getZookeeperClient());        Assert.assertNull(client.getZookeeperClient().getZooKeeper().exists("/jz/pity/the/fool", false));        ensurePath = client.newNamespaceAwareEnsurePath("/pity/the/fool");        ensurePath.ensure(client.getZookeeperClient());        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/jz/pity/the/fool", false));    } finally {        CloseableUtils.closeQuietly(client);    }}
1eeb1ecc03ea8cab3a35d560647128fadf148f5041360ef13d821aec142f9a8e
testCreateContainersWithNamespace
public void testCreateContainersWithNamespace() throws Exception
{    final String namespace = "container1";    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace(namespace).build();    try {        client.start();        String path = "/path1/path2";        client.createContainers(path);        Assert.assertNotNull(client.checkExists().forPath(path));        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/" + namespace + path, false));    } finally {        CloseableUtils.closeQuietly(client);    }}
8d4bd10e2f49fe49c776b7ddf2ec6e5eef880c89c9777147048ec1529ff9d5cd
testCreateContainersUsingNamespace
public void testCreateContainersUsingNamespace() throws Exception
{    final String namespace = "container2";    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        CuratorFramework nsClient = client.usingNamespace(namespace);        String path = "/path1/path2";        nsClient.createContainers(path);        Assert.assertNotNull(nsClient.checkExists().forPath(path));        Assert.assertNotNull(nsClient.getZookeeperClient().getZooKeeper().exists("/" + namespace + path, false));    } finally {        CloseableUtils.closeQuietly(client);    }}
59e0a32a550326f899edb7a0544309735f1d15d04012ece82e219b78969df6bf
testNamespace
public void testNamespace() throws Exception
{    final String namespace = "TestNamespace";    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace(namespace).build();    client.start();    try {        String actualPath = client.create().forPath("/test");        Assert.assertEquals(actualPath, "/test");        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/" + namespace + "/test", false));        Assert.assertNull(client.getZookeeperClient().getZooKeeper().exists("/test", false));        actualPath = client.usingNamespace(null).create().forPath("/non");        Assert.assertEquals(actualPath, "/non");        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/non", false));        client.create().forPath("/test/child", "hey".getBytes());        byte[] bytes = client.getData().forPath("/test/child");        Assert.assertEquals(bytes, "hey".getBytes());        bytes = client.usingNamespace(null).getData().forPath("/" + namespace + "/test/child");        Assert.assertEquals(bytes, "hey".getBytes());    } finally {        CloseableUtils.closeQuietly(client);    }}
c9b9b83fcb655a2277acc2232b72c54a414661520552387cf42473005b7933ac
testCustomCallback
public void testCustomCallback() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch latch = new CountDownLatch(1);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.CREATE) {                    if (event.getPath().equals("/head")) {                        latch.countDown();                    }                }            }        };        client.create().inBackground(callback).forPath("/head");        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(client);    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.CREATE) {        if (event.getPath().equals("/head")) {            latch.countDown();        }    }}
5662ea62c800aca7fb2a0e9f97d55ff62980971a589d1449838c92ba5eae18c8
testSync
public void testSync() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.SYNC) {                    Assert.assertEquals(event.getPath(), "/head");                    ((CountDownLatch) event.getContext()).countDown();                }            }        });        client.create().forPath("/head");        Assert.assertNotNull(client.checkExists().forPath("/head"));        CountDownLatch latch = new CountDownLatch(1);        client.sync("/head", latch);        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(client);    }}
e958fd31854b02620bcc0e47a47ca286f0584d1be38198248b0d2054a45a8cea
eventReceived
public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.SYNC) {        Assert.assertEquals(event.getPath(), "/head");        ((CountDownLatch) event.getContext()).countDown();    }}
17ec4e6b2a36eab222d7f6d50783463968a82ae293f838aea6d5bc91f8ef14e8
testSyncNew
public void testSyncNew() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/head");        Assert.assertNotNull(client.checkExists().forPath("/head"));        final CountDownLatch latch = new CountDownLatch(1);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.SYNC) {                    latch.countDown();                }            }        };        client.sync().inBackground(callback).forPath("/head");        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(client);    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.SYNC) {        latch.countDown();    }}
a2b46b3e072d359e82c6539e8d67a2aca37366ce8863b8c80aa3231749c52bfd
testBackgroundDelete
public void testBackgroundDelete() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.DELETE) {                    Assert.assertEquals(event.getPath(), "/head");                    ((CountDownLatch) event.getContext()).countDown();                }            }        });        client.create().forPath("/head");        Assert.assertNotNull(client.checkExists().forPath("/head"));        CountDownLatch latch = new CountDownLatch(1);        client.delete().inBackground(latch).forPath("/head");        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        Assert.assertNull(client.checkExists().forPath("/head"));    } finally {        CloseableUtils.closeQuietly(client);    }}
e958fd31854b02620bcc0e47a47ca286f0584d1be38198248b0d2054a45a8cea
eventReceived
public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.DELETE) {        Assert.assertEquals(event.getPath(), "/head");        ((CountDownLatch) event.getContext()).countDown();    }}
f2bb01cbd8c1671805cd0bbbabe20d349fa5ca74a4db74e863fc3754e173b557
testBackgroundDeleteWithChildren
public void testBackgroundDeleteWithChildren() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.DELETE) {                    Assert.assertEquals(event.getPath(), "/one/two");                    ((CountDownLatch) event.getContext()).countDown();                }            }        });        client.create().creatingParentsIfNeeded().forPath("/one/two/three/four");        Assert.assertNotNull(client.checkExists().forPath("/one/two/three/four"));        CountDownLatch latch = new CountDownLatch(1);        client.delete().deletingChildrenIfNeeded().inBackground(latch).forPath("/one/two");        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        Assert.assertNull(client.checkExists().forPath("/one/two"));    } finally {        CloseableUtils.closeQuietly(client);    }}
e958fd31854b02620bcc0e47a47ca286f0584d1be38198248b0d2054a45a8cea
eventReceived
public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.DELETE) {        Assert.assertEquals(event.getPath(), "/one/two");        ((CountDownLatch) event.getContext()).countDown();    }}
d588d24d86f0ebbff2cd80210ca2cce069b8c9b5ef0b61e20fb792c431381f7f
testDelete
public void testDelete() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/head");        Assert.assertNotNull(client.checkExists().forPath("/head"));        client.delete().forPath("/head");        Assert.assertNull(client.checkExists().forPath("/head"));    } finally {        CloseableUtils.closeQuietly(client);    }}
e496dc4cf0ca72f4e56323791ff91072eb9499035f84285dfaef361dc9f228f4
testDeleteWithChildren
public void testDeleteWithChildren() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        client.create().creatingParentsIfNeeded().forPath("/one/two/three/four/five/six", "foo".getBytes());        client.delete().deletingChildrenIfNeeded().forPath("/one/two/three/four/five");        Assert.assertNull(client.checkExists().forPath("/one/two/three/four/five"));        client.delete().deletingChildrenIfNeeded().forPath("/one/two");        Assert.assertNull(client.checkExists().forPath("/one/two"));    } finally {        CloseableUtils.closeQuietly(client);    }}
ddfdd96807b66ba54111d400ce1027cc8ab772b8d6258bdfd6cf80d6eb0696d2
testDeleteGuaranteedWithChildren
public void testDeleteGuaranteedWithChildren() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        client.create().creatingParentsIfNeeded().forPath("/one/two/three/four/five/six", "foo".getBytes());        client.delete().guaranteed().deletingChildrenIfNeeded().forPath("/one/two/three/four/five");        Assert.assertNull(client.checkExists().forPath("/one/two/three/four/five"));        client.delete().guaranteed().deletingChildrenIfNeeded().forPath("/one/two");        Assert.assertNull(client.checkExists().forPath("/one/two"));    } finally {        CloseableUtils.closeQuietly(client);    }}
7390795dc40492f531274662e1ef013c0a3d590187d9c70c36ab78f49a4638d0
testGetSequentialChildren
public void testGetSequentialChildren() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/head");        for (int i = 0; i < 10; ++i) {            client.create().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath("/head/child");        }        List<String> children = client.getChildren().forPath("/head");        Assert.assertEquals(children.size(), 10);    } finally {        CloseableUtils.closeQuietly(client);    }}
7cbfd46f72595c544cdd150b0300e9bc50d498c94adf816cdb5f8a12a97c4359
testBackgroundGetDataWithWatch
public void testBackgroundGetDataWithWatch() throws Exception
{    final byte[] data1 = { 1, 2, 3 };    final byte[] data2 = { 4, 5, 6, 7 };    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch watchedLatch = new CountDownLatch(1);        client.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.GET_DATA) {                    Assert.assertEquals(event.getPath(), "/test");                    Assert.assertEquals(event.getData(), data1);                    ((CountDownLatch) event.getContext()).countDown();                } else if (event.getType() == CuratorEventType.WATCHED) {                    if (event.getWatchedEvent().getType() == Watcher.Event.EventType.NodeDataChanged) {                        Assert.assertEquals(event.getPath(), "/test");                        watchedLatch.countDown();                    }                }            }        });        client.create().forPath("/test", data1);        CountDownLatch backgroundLatch = new CountDownLatch(1);        client.getData().watched().inBackground(backgroundLatch).forPath("/test");        Assert.assertTrue(backgroundLatch.await(10, TimeUnit.SECONDS));        client.setData().forPath("/test", data2);        Assert.assertTrue(watchedLatch.await(10, TimeUnit.SECONDS));        byte[] checkData = client.getData().forPath("/test");        Assert.assertEquals(checkData, data2);    } finally {        CloseableUtils.closeQuietly(client);    }}
e958fd31854b02620bcc0e47a47ca286f0584d1be38198248b0d2054a45a8cea
eventReceived
public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.GET_DATA) {        Assert.assertEquals(event.getPath(), "/test");        Assert.assertEquals(event.getData(), data1);        ((CountDownLatch) event.getContext()).countDown();    } else if (event.getType() == CuratorEventType.WATCHED) {        if (event.getWatchedEvent().getType() == Watcher.Event.EventType.NodeDataChanged) {            Assert.assertEquals(event.getPath(), "/test");            watchedLatch.countDown();        }    }}
c73fde3cf012683f8e4997bb700af461175ab6c2455006737e1f6cecc00591e7
testBackgroundCreate
public void testBackgroundCreate() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.CREATE) {                    Assert.assertEquals(event.getPath(), "/test");                    ((CountDownLatch) event.getContext()).countDown();                }            }        });        CountDownLatch latch = new CountDownLatch(1);        client.create().inBackground(latch).forPath("/test", new byte[] { 1, 2, 3 });        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(client);    }}
e958fd31854b02620bcc0e47a47ca286f0584d1be38198248b0d2054a45a8cea
eventReceived
public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.CREATE) {        Assert.assertEquals(event.getPath(), "/test");        ((CountDownLatch) event.getContext()).countDown();    }}
56eb8d9c395269871853c3eb39bcf8c61f169d95c3a0451f054abd486f48e3fd
testCreateModes
public void testCreateModes() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        byte[] writtenBytes = { 1, 2, 3 };                client.create().forPath("/test", writtenBytes);        client.close();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        byte[] readBytes = client.getData().forPath("/test");        Assert.assertEquals(writtenBytes, readBytes);        client.create().withMode(CreateMode.EPHEMERAL).forPath("/ghost", writtenBytes);        client.close();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        readBytes = client.getData().forPath("/test");        Assert.assertEquals(writtenBytes, readBytes);        Stat stat = client.checkExists().forPath("/ghost");        Assert.assertNull(stat);        String realPath = client.create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath("/pseq", writtenBytes);        Assert.assertNotSame(realPath, "/pseq");        client.close();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        readBytes = client.getData().forPath(realPath);        Assert.assertEquals(writtenBytes, readBytes);        realPath = client.create().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath("/eseq", writtenBytes);        Assert.assertNotSame(realPath, "/eseq");        client.close();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        stat = client.checkExists().forPath(realPath);        Assert.assertNull(stat);    } finally {        CloseableUtils.closeQuietly(client);    }}
7e6ef9a15f502c76aa39b9e99c40c2704757556d14668cef0634754950c971d9
testSimple
public void testSimple() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        String path = client.create().withMode(CreateMode.PERSISTENT).forPath("/test", new byte[] { 1, 2, 3 });        Assert.assertEquals(path, "/test");    } finally {        CloseableUtils.closeQuietly(client);    }}
39c3963663299b0f852b76c210ad409ba8d42cef73f802978e4f5ad796359fa0
testSequentialWithTrailingSeparator
public void testSequentialWithTrailingSeparator() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");                String path = client.create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath("/test/");        Assert.assertTrue(path.startsWith("/test/"));    } finally {        CloseableUtils.closeQuietly(client);    }}
7f1fb39687574648b87ecc430a2537fc33da81f945a21c037812ab07141c3466
testErrorListener
public void testErrorListener() throws Exception
{                final AtomicBoolean aclProviderCalled = new AtomicBoolean(false);    ACLProvider badAclProvider = new ACLProvider() {        @Override        public List<ACL> getDefaultAcl() {            if (aclProviderCalled.getAndSet(true)) {                throw new UnsupportedOperationException();            } else {                return new ArrayList<>();            }        }        @Override        public List<ACL> getAclForPath(String path) {            if (aclProviderCalled.getAndSet(true)) {                throw new UnsupportedOperationException();            } else {                return new ArrayList<>();            }        }    };    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).aclProvider(badAclProvider).build();    try {        client.start();        final CountDownLatch errorLatch = new CountDownLatch(1);        UnhandledErrorListener listener = new UnhandledErrorListener() {            @Override            public void unhandledError(String message, Throwable e) {                if (e instanceof UnsupportedOperationException) {                    errorLatch.countDown();                }            }        };        client.create().inBackground().withUnhandledErrorListener(listener).forPath("/foo");        Assert.assertTrue(new Timing().awaitLatch(errorLatch));    } finally {        CloseableUtils.closeQuietly(client);    }}
608c4250279b9160905e4962b77bc1d258c8a726d186d1875dd0e18be5e9bcbb
getDefaultAcl
public List<ACL> getDefaultAcl()
{    if (aclProviderCalled.getAndSet(true)) {        throw new UnsupportedOperationException();    } else {        return new ArrayList<>();    }}
948e924ac3cf12487fcf7f5ccc3b514ae7fc4b9d602a2962739b070d41126b34
getAclForPath
public List<ACL> getAclForPath(String path)
{    if (aclProviderCalled.getAndSet(true)) {        throw new UnsupportedOperationException();    } else {        return new ArrayList<>();    }}
221ba1c9d4a2fdcc828fc4f3549df182bc257ecbc2aca5ee2533f97d06bdf4d9
unhandledError
public void unhandledError(String message, Throwable e)
{    if (e instanceof UnsupportedOperationException) {        errorLatch.countDown();    }}
a407e35b86348e1b9174727207e1463bf7e188c181a9c372860e16ffbf203656
testListenerConnectedAtStart
public void testListenerConnectedAtStart() throws Exception
{    server.stop();    Timing timing = new Timing(2);    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryNTimes(0, 0));    try {        client.start();        final CountDownLatch connectedLatch = new CountDownLatch(1);        final AtomicBoolean firstListenerAction = new AtomicBoolean(true);        final AtomicReference<ConnectionState> firstListenerState = new AtomicReference<ConnectionState>();        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (firstListenerAction.compareAndSet(true, false)) {                    firstListenerState.set(newState);                    System.out.println("First listener state is " + newState);                }                if (newState == ConnectionState.CONNECTED) {                    connectedLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);                client.create().inBackground().forPath("/foo");        server.restart();        Assert.assertTrue(timing.awaitLatch(connectedLatch));        Assert.assertFalse(firstListenerAction.get());        ConnectionState firstconnectionState = firstListenerState.get();        Assert.assertEquals(firstconnectionState, ConnectionState.CONNECTED, "First listener state MUST BE CONNECTED but is " + firstconnectionState);    } finally {        CloseableUtils.closeQuietly(client);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (firstListenerAction.compareAndSet(true, false)) {        firstListenerState.set(newState);        System.out.println("First listener state is " + newState);    }    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    }}
d3c96a008163c9ce24e62dede800abca66090c52ee686b6ae2f0e3a5f15b518b
testRetries
public void testRetries() throws Exception
{    final int SLEEP = 1000;    final int TIMES = 5;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryNTimes(TIMES, SLEEP));    try {        client.start();        client.getZookeeperClient().blockUntilConnectedOrTimedOut();        final CountDownLatch latch = new CountDownLatch(TIMES);        final List<Long> times = Lists.newArrayList();        final AtomicLong start = new AtomicLong(System.currentTimeMillis());        ((CuratorFrameworkImpl) client).debugListener = new CuratorFrameworkImpl.DebugBackgroundListener() {            @Override            public void listen(OperationAndData<?> data) {                if (data.getOperation().getClass().getName().contains("CreateBuilderImpl")) {                    long now = System.currentTimeMillis();                    times.add(now - start.get());                    start.set(now);                    latch.countDown();                }            }        };        server.stop();        client.create().inBackground().forPath("/one");        latch.await();        for (        long elapsed :         times.subList(1, times.size())) {            Assert.assertTrue(elapsed >= SLEEP, elapsed + ": " + times);        }    } finally {        CloseableUtils.closeQuietly(client);    }}
2dbcfe658d665c94ac03172d21f8e1181fbb93a02edd5e38b90c856cd45f7e98
listen
public void listen(OperationAndData<?> data)
{    if (data.getOperation().getClass().getName().contains("CreateBuilderImpl")) {        long now = System.currentTimeMillis();        times.add(now - start.get());        start.set(now);        latch.countDown();    }}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final BlockingQueue<String> paths = Queues.newLinkedBlockingQueue();        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                paths.add(event.getPath());            }        };        client.create().inBackground(callback).forPath("/one");        Assert.assertEquals(paths.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), "/one");        client.create().inBackground(callback).forPath("/one/two");        Assert.assertEquals(paths.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), "/one/two");        client.create().inBackground(callback).forPath("/one/two/three");        Assert.assertEquals(paths.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), "/one/two/three");    } finally {        CloseableUtils.closeQuietly(client);    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    paths.add(event.getPath());}
abf484428a0c119774a0c70ff237380e71c5914e3ebc6d7fcc083568ddc04d23
testCuratorCallbackOnError
public void testCuratorCallbackOnError() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new RetryOneTime(1000)).build();    final CountDownLatch latch = new CountDownLatch(1);    try {        client.start();        BackgroundCallback curatorCallback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getResultCode() == Code.CONNECTIONLOSS.intValue()) {                    latch.countDown();                }            }        };                server.stop();                client.getChildren().inBackground(curatorCallback).forPath("/");                Assert.assertTrue(timing.awaitLatch(latch), "Callback has not been called by curator !");    } finally {        client.close();    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getResultCode() == Code.CONNECTIONLOSS.intValue()) {        latch.countDown();    }}
659b4ca410a3c5e577ee7b133a343a7ff41a06e4bca46289075d3f4c02f9e208
testShutdown
public void testShutdown() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new RetryOneTime(1)).maxCloseWaitMs(timing.forWaiting().milliseconds()).build();    try {        final AtomicBoolean hadIllegalStateException = new AtomicBoolean(false);        ((CuratorFrameworkImpl) client).debugUnhandledErrorListener = new UnhandledErrorListener() {            @Override            public void unhandledError(String message, Throwable e) {                if (e instanceof IllegalStateException) {                    hadIllegalStateException.set(true);                }            }        };        client.start();        final CountDownLatch operationReadyLatch = new CountDownLatch(1);        ((CuratorFrameworkImpl) client).debugListener = new CuratorFrameworkImpl.DebugBackgroundListener() {            @Override            public void listen(OperationAndData<?> data) {                try {                    operationReadyLatch.await();                } catch (InterruptedException e) {                    Thread.currentThread().interrupt();                }            }        };                client.create().inBackground().forPath("/hey");        timing.sleepABit();                client.close();                operationReadyLatch.countDown();        timing.sleepABit();                Assert.assertFalse(hadIllegalStateException.get());    } finally {        CloseableUtils.closeQuietly(client);    }}
221ba1c9d4a2fdcc828fc4f3549df182bc257ecbc2aca5ee2533f97d06bdf4d9
unhandledError
public void unhandledError(String message, Throwable e)
{    if (e instanceof IllegalStateException) {        hadIllegalStateException.set(true);    }}
2dbcfe658d665c94ac03172d21f8e1181fbb93a02edd5e38b90c856cd45f7e98
listen
public void listen(OperationAndData<?> data)
{    try {        operationReadyLatch.await();    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }}
a80321659a99b352c8cc43cf7a4af27cfb9d2bc91b4f60096aee3b259fe65fe6
setUpClass
public static void setUpClass()
{    System.setProperty("zookeeper.extendedTypesEnabled", "true");}
024c001f3e912e617c9e9e1f72cde399d784d4da00ea89bd211bab863251b959
testInjectSessionExpiration
public void testInjectSessionExpiration() throws Exception
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        CountDownLatch expiredLatch = new CountDownLatch(1);        Watcher watcher = event -> {            if (event.getState() == Watcher.Event.KeeperState.Expired) {                expiredLatch.countDown();            }        };        client.checkExists().usingWatcher(watcher).forPath("/foobar");        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        Assert.assertTrue(timing.awaitLatch(expiredLatch));    }}
a0c86c5392ada3e2a48d9a8baddc4b67ef1a8aafa9011cb2c8fa87c5809081d2
testProtectionWithKilledSession
public void testProtectionWithKilledSession() throws Exception
{        server.stop();    try (TestingCluster cluster = new TestingCluster(3)) {        cluster.start();        InstanceSpec instanceSpec0 = cluster.getServers().get(0).getInstanceSpec();        CountDownLatch serverStoppedLatch = new CountDownLatch(1);        RetryPolicy retryPolicy = new RetryForever(100) {            @Override            public boolean allowRetry(int retryCount, long elapsedTimeMs, RetrySleeper sleeper) {                if (serverStoppedLatch.getCount() > 0) {                    try {                        cluster.killServer(instanceSpec0);                    } catch (Exception e) {                                        }                    serverStoppedLatch.countDown();                }                return super.allowRetry(retryCount, elapsedTimeMs, sleeper);            }        };        try (CuratorFramework client = CuratorFrameworkFactory.newClient(instanceSpec0.getConnectString(), timing.session(), timing.connection(), retryPolicy)) {            BlockingQueue<String> createdNode = new LinkedBlockingQueue<>();            BackgroundCallback callback = (__, event) -> {                if (event.getType() == CuratorEventType.CREATE) {                    createdNode.offer(event.getPath());                }            };            client.start();            client.create().forPath("/test");            ErrorListenerPathAndBytesable<String> builder = client.create().withProtection().withMode(CreateMode.EPHEMERAL).inBackground(callback);            ((CreateBuilderImpl) builder).failNextCreateForTesting = true;            builder.forPath("/test/hey");            Assert.assertTrue(timing.awaitLatch(serverStoppedLatch));                        timing.forSessionSleep().sleep();            cluster.restartServer(instanceSpec0);            String path = timing.takeFromQueue(createdNode);            List<String> children = client.getChildren().forPath("/test");            Assert.assertEquals(Collections.singletonList(ZKPaths.getNodeFromPath(path)), children);        }    }}
4c63ebeaaff7bb355ad5a04b35052b1142def4893beee8762659de3e7ad378f5
allowRetry
public boolean allowRetry(int retryCount, long elapsedTimeMs, RetrySleeper sleeper)
{    if (serverStoppedLatch.getCount() > 0) {        try {            cluster.killServer(instanceSpec0);        } catch (Exception e) {                }        serverStoppedLatch.countDown();    }    return super.allowRetry(retryCount, elapsedTimeMs, sleeper);}
719df07828e7544b5287868710f7d203460b9b6513606b1f03aea1dabdadd480
testBackgroundLatencyUnSleep
public void testBackgroundLatencyUnSleep() throws Exception
{    server.stop();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        ((CuratorFrameworkImpl) client).sleepAndQueueOperationSeconds = Integer.MAX_VALUE;        final CountDownLatch latch = new CountDownLatch(3);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                if ((event.getType() == CuratorEventType.CREATE) && (event.getResultCode() == KeeperException.Code.OK.intValue())) {                    latch.countDown();                }            }        };                client.create().inBackground(callback).forPath("/test");        client.create().inBackground(callback).forPath("/test/one");        client.create().inBackground(callback).forPath("/test/two");        server.restart();        Assert.assertTrue(timing.awaitLatch(latch));    } finally {        CloseableUtils.closeQuietly(client);    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if ((event.getType() == CuratorEventType.CREATE) && (event.getResultCode() == KeeperException.Code.OK.intValue())) {        latch.countDown();    }}
aece81ae6a9db3ecb9be14d0804edd392fc76d383adbfcbb3805367a4229e20e
testCreateContainersForBadConnect
public void testCreateContainersForBadConnect() throws Exception
{    final int serverPort = server.getPort();    server.close();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), 1000, 1000, new RetryNTimes(10, timing.forSleepingABit().milliseconds()));    try {        new Thread() {            @Override            public void run() {                try {                    Thread.sleep(3000);                    server = new TestingServer(serverPort, true);                } catch (Exception e) {                    e.printStackTrace();                }            }        }.start();        client.start();        client.createContainers("/this/does/not/exist");        Assert.assertNotNull(client.checkExists().forPath("/this/does/not/exist"));    } finally {        CloseableUtils.closeQuietly(client);    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        Thread.sleep(3000);        server = new TestingServer(serverPort, true);    } catch (Exception e) {        e.printStackTrace();    }}
e6bc86dd3253b2c539cbadb3d62bda38543a1a63bf291a9a8930e653ad30ec76
testQuickClose
public void testQuickClose() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), 1, new RetryNTimes(0, 0));    try {        client.start();        client.close();    } finally {        CloseableUtils.closeQuietly(client);    }}
4717c1ceb6f9adaf7407d875ee1b2899711432e6508bf0233d2a4742cf28c6f0
testProtectedCreateNodeDeletion
public void testProtectedCreateNodeDeletion() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), 1, new RetryNTimes(0, 0));    try {        client.start();        for (int i = 0; i < 2; ++i) {            CuratorFramework localClient = (i == 0) ? client : client.usingNamespace("nm");            localClient.create().forPath("/parent");            Assert.assertEquals(localClient.getChildren().forPath("/parent").size(), 0);            CreateBuilderImpl createBuilder = (CreateBuilderImpl) localClient.create();            createBuilder.failNextCreateForTesting = true;            FindAndDeleteProtectedNodeInBackground.debugInsertError.set(true);            try {                createBuilder.withProtection().forPath("/parent/test");                Assert.fail("failNextCreateForTesting should have caused a ConnectionLossException");            } catch (KeeperException.ConnectionLossException e) {                        }            timing.sleepABit();            List<String> children = localClient.getChildren().forPath("/parent");                        Assert.assertEquals(children.size(), 0, children.toString());            localClient.delete().forPath("/parent");        }    } finally {        CloseableUtils.closeQuietly(client);    }}
b70507096fb327b00f6e7c1e45973bc5ba9fbdf0aeab38b3b2ba08c2e28e80d5
testPathsFromProtectingInBackground
public void testPathsFromProtectingInBackground() throws Exception
{    for (CreateMode mode : CreateMode.values()) {        internalTestPathsFromProtectingInBackground(mode);    }}
c9501a2d6c31f9c6eaecc2845cc7ba0feaaf6a204eed2f7bb3636aea31867fb8
internalTestPathsFromProtectingInBackground
private void internalTestPathsFromProtectingInBackground(CreateMode mode) throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), 1, new RetryOneTime(1));    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/a/b/c");        final BlockingQueue<String> paths = new ArrayBlockingQueue<String>(2);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                paths.put(event.getName());                paths.put(event.getPath());            }        };        final String TEST_PATH = "/a/b/c/test-";        long ttl = timing.forWaiting().milliseconds() * 1000;        CreateBuilder firstCreateBuilder = client.create();        if (SafeIsTtlMode.isTtl(mode)) {            firstCreateBuilder.withTtl(ttl);        }        firstCreateBuilder.withMode(mode).inBackground(callback).forPath(TEST_PATH);        String name1 = timing.takeFromQueue(paths);        String path1 = timing.takeFromQueue(paths);        client.close();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), 1, new RetryOneTime(1));        client.start();        CreateBuilderImpl createBuilder = (CreateBuilderImpl) client.create();        createBuilder.withProtection();        if (SafeIsTtlMode.isTtl(mode)) {            createBuilder.withTtl(ttl);        }        client.create().forPath(createBuilder.adjustPath(TEST_PATH));        createBuilder.debugForceFindProtectedNode = true;        createBuilder.withMode(mode).inBackground(callback).forPath(TEST_PATH);        String name2 = timing.takeFromQueue(paths);        String path2 = timing.takeFromQueue(paths);        Assert.assertEquals(ZKPaths.getPathAndNode(name1).getPath(), ZKPaths.getPathAndNode(TEST_PATH).getPath());        Assert.assertEquals(ZKPaths.getPathAndNode(name2).getPath(), ZKPaths.getPathAndNode(TEST_PATH).getPath());        Assert.assertEquals(ZKPaths.getPathAndNode(path1).getPath(), ZKPaths.getPathAndNode(TEST_PATH).getPath());        Assert.assertEquals(ZKPaths.getPathAndNode(path2).getPath(), ZKPaths.getPathAndNode(TEST_PATH).getPath());        client.delete().deletingChildrenIfNeeded().forPath("/a/b/c");        client.delete().forPath("/a/b");        client.delete().forPath("/a");    } finally {        CloseableUtils.closeQuietly(client);    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    paths.put(event.getName());    paths.put(event.getPath());}
63ae9093d3b7362fb61c02c157893ecbc583bc1176c96f9357c25e3ab8cd9122
connectionLossWithBackgroundTest
public void connectionLossWithBackgroundTest() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), 1, new RetryOneTime(1));    try {        final CountDownLatch latch = new CountDownLatch(1);        client.start();        client.getZookeeperClient().blockUntilConnectedOrTimedOut();        server.close();        client.getChildren().inBackground(new BackgroundCallback() {            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                latch.countDown();            }        }).forPath("/");        Assert.assertTrue(timing.awaitLatch(latch));    } finally {        CloseableUtils.closeQuietly(client);    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
763d6a08f3467c79944fe9438aa1bf7a0e936c1fd7c54ea57ec8d6b8a0511abe
testReconnectAfterLoss
public void testReconnectAfterLoss() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final CountDownLatch lostLatch = new CountDownLatch(1);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    lostLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        client.checkExists().forPath("/");        server.stop();        Assert.assertTrue(timing.awaitLatch(lostLatch));        try {            client.checkExists().forPath("/");            Assert.fail();        } catch (KeeperException.ConnectionLossException e) {                }        server.restart();        client.checkExists().forPath("/");    } finally {        CloseableUtils.closeQuietly(client);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        lostLatch.countDown();    }}
83d07de0ee99031b4fc04cd7f5656cbe8832fbfa220fd7b801affadc267c6039
testGetAclNoStat
public void testGetAclNoStat() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        try {            client.getACL().forPath("/");        } catch (NullPointerException e) {            Assert.fail();        }    } finally {        CloseableUtils.closeQuietly(client);    }}
858eedb4aec545d6163a7d37ca2daac916bc1ebd5c366b69950684b28ddaec22
testMissedResponseOnBackgroundESCreate
public void testMissedResponseOnBackgroundESCreate() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        CreateBuilderImpl createBuilder = (CreateBuilderImpl) client.create();        createBuilder.failNextCreateForTesting = true;        final BlockingQueue<String> queue = Queues.newArrayBlockingQueue(1);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                queue.put(event.getPath());            }        };        createBuilder.withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).inBackground(callback).forPath("/");        String ourPath = queue.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertTrue(ourPath.startsWith(ZKPaths.makePath("/", CreateBuilderImpl.PROTECTED_PREFIX)));        Assert.assertFalse(createBuilder.failNextCreateForTesting);    } finally {        CloseableUtils.closeQuietly(client);    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    queue.put(event.getPath());}
77306576fc55623d4fd73f15c12fca9837c4b221345201e7f8e4926d6393d23a
testMissedResponseOnESCreate
public void testMissedResponseOnESCreate() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        CreateBuilderImpl createBuilder = (CreateBuilderImpl) client.create();        createBuilder.failNextCreateForTesting = true;        String ourPath = createBuilder.withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath("/");        Assert.assertTrue(ourPath.startsWith(ZKPaths.makePath("/", CreateBuilderImpl.PROTECTED_PREFIX)));        Assert.assertFalse(createBuilder.failNextCreateForTesting);    } finally {        CloseableUtils.closeQuietly(client);    }}
f4e20f01833c49cb33bb913bd4fbaf144618168c9b4d7679e9ae2c7d06220662
testSessionKilled
public void testSessionKilled() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/sessionTest");        CountDownLatch sessionDiedLatch = new CountDownLatch(1);        Watcher watcher = event -> {            if (event.getState() == Watcher.Event.KeeperState.Expired) {                sessionDiedLatch.countDown();            }        };        client.checkExists().usingWatcher(watcher).forPath("/sessionTest");        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        Assert.assertTrue(timing.awaitLatch(sessionDiedLatch));        Assert.assertNotNull(client.checkExists().forPath("/sessionTest"));    } finally {        CloseableUtils.closeQuietly(client);    }}
c6112df1b981e6a52ded062f26fede720a639a542205430aafa7137580d43180
testNestedCalls
public void testNestedCalls() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.EXISTS) {                    Stat stat = client.checkExists().forPath("/yo/yo/yo");                    Assert.assertNull(stat);                    client.create().inBackground(event.getContext()).forPath("/what");                } else if (event.getType() == CuratorEventType.CREATE) {                    ((CountDownLatch) event.getContext()).countDown();                }            }        });        CountDownLatch latch = new CountDownLatch(1);        client.checkExists().inBackground(latch).forPath("/hey");        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(client);    }}
e958fd31854b02620bcc0e47a47ca286f0584d1be38198248b0d2054a45a8cea
eventReceived
public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.EXISTS) {        Stat stat = client.checkExists().forPath("/yo/yo/yo");        Assert.assertNull(stat);        client.create().inBackground(event.getContext()).forPath("/what");    } else if (event.getType() == CuratorEventType.CREATE) {        ((CountDownLatch) event.getContext()).countDown();    }}
7bd0dd57aad3a2e38f51f57f97a72e4d335f53987a034021dfa9cc5cb4da9db5
testBackgroundFailure
public void testBackgroundFailure() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch latch = new CountDownLatch(1);        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    latch.countDown();                }            }        });        client.checkExists().forPath("/hey");        client.checkExists().inBackground().forPath("/hey");        server.stop();        client.checkExists().inBackground().forPath("/hey");        Assert.assertTrue(timing.awaitLatch(latch));    } finally {        CloseableUtils.closeQuietly(client);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        latch.countDown();    }}
259a7bcd21565e0c4543988b7492069953660bb71c81d98797380438fa6bbd17
testFailure
public void testFailure() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), 100, 100, new RetryOneTime(1));    client.start();    try {        client.checkExists().forPath("/hey");        client.checkExists().inBackground().forPath("/hey");        server.stop();        client.checkExists().forPath("/hey");        Assert.fail();    } catch (KeeperException.ConnectionLossException e) {        } finally {        CloseableUtils.closeQuietly(client);    }}
6c9a0476a31b040692d695f58e540d0b4fe2c4da4d062b79b51ef589ad3ab77c
testRetry
public void testRetry() throws Exception
{    final int MAX_RETRIES = 3;    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(10));    client.start();    try {        final AtomicInteger retries = new AtomicInteger(0);        final Semaphore semaphore = new Semaphore(0);        RetryPolicy policy = new RetryPolicy() {            @Override            public boolean allowRetry(int retryCount, long elapsedTimeMs, RetrySleeper sleeper) {                semaphore.release();                if (retries.incrementAndGet() == MAX_RETRIES) {                    try {                        server.restart();                    } catch (Exception e) {                        throw new Error(e);                    }                }                try {                    sleeper.sleepFor(100, TimeUnit.MILLISECONDS);                } catch (InterruptedException e) {                    Thread.currentThread().interrupt();                }                return true;            }        };        client.getZookeeperClient().setRetryPolicy(policy);        server.stop();                client.checkExists().forPath("/hey");        Assert.assertTrue(semaphore.tryAcquire(MAX_RETRIES, timing.forWaiting().seconds(), TimeUnit.SECONDS), "Remaining leases: " + semaphore.availablePermits());                client.getZookeeperClient().setRetryPolicy(new RetryOneTime(100));        client.checkExists().forPath("/hey");        client.getZookeeperClient().setRetryPolicy(policy);        semaphore.drainPermits();        retries.set(0);        server.stop();                client.checkExists().inBackground().forPath("/hey");        Assert.assertTrue(semaphore.tryAcquire(MAX_RETRIES, timing.forWaiting().seconds(), TimeUnit.SECONDS), "Remaining leases: " + semaphore.availablePermits());    } finally {        CloseableUtils.closeQuietly(client);    }}
4c63ebeaaff7bb355ad5a04b35052b1142def4893beee8762659de3e7ad378f5
allowRetry
public boolean allowRetry(int retryCount, long elapsedTimeMs, RetrySleeper sleeper)
{    semaphore.release();    if (retries.incrementAndGet() == MAX_RETRIES) {        try {            server.restart();        } catch (Exception e) {            throw new Error(e);        }    }    try {        sleeper.sleepFor(100, TimeUnit.MILLISECONDS);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }    return true;}
47c3eee6d219f1f235e35d96063d956bf56305a240f66f725316c415063cf788
testNotStarted
public void testNotStarted() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.getData();        Assert.fail();    } catch (Exception e) {        } catch (Throwable e) {        Assert.fail("", e);    }}
2fd357ee2753b5e8a7860cbeb21525b9bad64236e80e6703850e588bb4a882de
testStopped
public void testStopped() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.getData();    } finally {        CloseableUtils.closeQuietly(client);    }    try {        client.getData();        Assert.fail();    } catch (Exception e) {        }}
dcfdf9c19013114707dddf61aa7a5895bb981aa02324a11dd0bfababc0296b3d
testDeleteChildrenConcurrently
public void testDeleteChildrenConcurrently() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    CuratorFramework client2 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.getZookeeperClient().blockUntilConnectedOrTimedOut();        client2.start();        client2.getZookeeperClient().blockUntilConnectedOrTimedOut();        int childCount = 5000;        for (int i = 0; i < childCount; i++) {            client.create().creatingParentsIfNeeded().forPath("/parent/child" + i);        }        final CountDownLatch latch = new CountDownLatch(1);        new Thread(new Runnable() {            @Override            public void run() {                long start = System.currentTimeMillis();                try {                    client.delete().deletingChildrenIfNeeded().forPath("/parent");                } catch (Exception e) {                    if (e instanceof KeeperException.NoNodeException) {                        Assert.fail("client delete failed, shouldn't throw NoNodeException", e);                    } else {                        Assert.fail("unexpected exception", e);                    }                } finally {                    log.info("client has deleted children, it costs: {}ms", System.currentTimeMillis() - start);                    latch.countDown();                }            }        }).start();        boolean threadDeleted = false;        boolean client2Deleted = false;        Random random = new Random();        for (int i = 0; i < childCount; i++) {            String child = "/parent/child" + random.nextInt(childCount);            try {                if (!threadDeleted) {                    Stat stat = client2.checkExists().forPath(child);                    if (stat == null) {                                                threadDeleted = true;                        log.info("client has deleted the child {}", child);                    }                } else {                    try {                        client2.delete().forPath(child);                        client2Deleted = true;                        log.info("client2 deleted the child {} successfully", child);                        break;                    } catch (Exception e) {                        if (e instanceof KeeperException.NoNodeException) {                                                } else {                            Assert.fail("unexpected exception", e);                        }                    }                }            } catch (Exception e) {                Assert.fail("unexpected exception", e);            }        }                Assert.assertTrue(client2Deleted);        Assert.assertTrue(timing.awaitLatch(latch));        Assert.assertNull(client2.checkExists().forPath("/parent"));    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(client2);    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    long start = System.currentTimeMillis();    try {        client.delete().deletingChildrenIfNeeded().forPath("/parent");    } catch (Exception e) {        if (e instanceof KeeperException.NoNodeException) {            Assert.fail("client delete failed, shouldn't throw NoNodeException", e);        } else {            Assert.fail("unexpected exception", e);        }    } finally {        log.info("client has deleted children, it costs: {}ms", System.currentTimeMillis() - start);        latch.countDown();    }}
32a84367eb013cb94c7ed1f29a1624497de1920a58948a2e1df03fccabd66c62
testSimple
public void testSimple() throws IOException
{    GzipCompressionProvider provider = new GzipCompressionProvider();    byte[] data = "Hello, world!".getBytes();    byte[] compressedData = provider.compress(null, data);    byte[] jdkCompressedData = jdkCompress(data);    Assert.assertTrue(Arrays.equals(compressedData, jdkCompressedData));    byte[] decompressedData = provider.decompress(null, compressedData);    Assert.assertTrue(Arrays.equals(decompressedData, data));}
6d266e23a12e7b44b43f6272d9371f4f65fd0bfcd7aae46611809c3c2fc59d94
testEmpty
public void testEmpty() throws IOException
{    GzipCompressionProvider provider = new GzipCompressionProvider();    byte[] compressedData = provider.compress(null, new byte[0]);    byte[] compressedData2 = GzipCompressionProvider.doCompress(new byte[0]);    byte[] jdkCompress = jdkCompress(new byte[0]);        Assert.assertTrue(Arrays.equals(compressedData, compressedData2));    Assert.assertTrue(Arrays.equals(compressedData, jdkCompress));    byte[] decompressedData = provider.decompress(null, compressedData);    Assert.assertEquals(0, decompressedData.length);}
7566a489308a68711eee87ee4d1d242303d34e13632a52195d84118cb7b69b89
testDecompressCorrupt
public void testDecompressCorrupt()
{    GzipCompressionProvider provider = new GzipCompressionProvider();    try {        provider.decompress(null, new byte[100]);        Assert.fail("Expected IOException");    } catch (IOException ignore) {        }    byte[] compressedData = provider.compress(null, new byte[0]);    for (int i = 0; i < compressedData.length; i++) {        try {            provider.decompress(null, Arrays.copyOf(compressedData, i));        } catch (IOException ignore) {                }        for (int change = 1; change < 256; change++) {            byte b = compressedData[i];            compressedData[i] = (byte) (b + change);            try {                provider.decompress(null, compressedData);                        } catch (IOException ignore) {                        }                        compressedData[i] = b;        }    }}
0035ce1b147deafc21c6ab5b64bf2a2fbc3513a93b63d45e0df44863146793b2
smokeTestRandomDataWithJdk
public void smokeTestRandomDataWithJdk() throws IOException
{    GzipCompressionProvider provider = new GzipCompressionProvider();    ThreadLocalRandom random = ThreadLocalRandom.current();    for (int len = 1; len < 100; len++) {        byte[] data = new byte[len];        for (int i = 0; i < 100; i++) {            byte[] compressedData = provider.compress(null, data);            byte[] jdkCompressedData = jdkCompress(data);            Assert.assertTrue(Arrays.equals(compressedData, jdkCompressedData));            byte[] decompressedData = provider.decompress(null, compressedData);            Assert.assertTrue(Arrays.equals(decompressedData, data));                        random.nextBytes(data);        }    }}
ca74ef70c05b22de5b3724591b5d18f52dce51d1127f2c9dca3267753b1e4c86
jdkCompress
private static byte[] jdkCompress(byte[] data) throws IOException
{    ByteArrayOutputStream bytes = new ByteArrayOutputStream();    try (GZIPOutputStream out = new GZIPOutputStream(bytes)) {        out.write(data);        out.finish();    }    return bytes.toByteArray();}
61cf1f7778ad5acf8c107f110e68b6e3c0a8f21cb5dc4f65694762c537621bc2
testNotify
public void testNotify() throws Exception
{    CuratorFramework client1 = null;    CuratorFramework client2 = null;    try {        client1 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client2 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client1.start();        client2.start();        final CountDownLatch latch = new CountDownLatch(1);        client1.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.WATCHED) {                    if (event.getWatchedEvent().getType() == Watcher.Event.EventType.NodeDataChanged) {                        if (event.getPath().equals("/test")) {                            latch.countDown();                        }                    }                }            }        });        client1.create().forPath("/test", new byte[] { 1, 2, 3 });        client1.checkExists().watched().forPath("/test");        client2.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.SYNC) {                    client.setData().forPath("/test", new byte[] { 10, 20 });                }            }        });        client2.sync().forPath("/test");        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(client1);        CloseableUtils.closeQuietly(client2);    }}
e958fd31854b02620bcc0e47a47ca286f0584d1be38198248b0d2054a45a8cea
eventReceived
public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.WATCHED) {        if (event.getWatchedEvent().getType() == Watcher.Event.EventType.NodeDataChanged) {            if (event.getPath().equals("/test")) {                latch.countDown();            }        }    }}
e958fd31854b02620bcc0e47a47ca286f0584d1be38198248b0d2054a45a8cea
eventReceived
public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.SYNC) {        client.setData().forPath("/test", new byte[] { 10, 20 });    }}
01c98bf02b9f68a1daec251c9281f9f8fd7adf8deeca49efd57dec3723bb6263
testInvalid
public void testInvalid() throws Exception
{    try {        CuratorFrameworkFactory.builder().namespace("/snafu").retryPolicy(new RetryOneTime(1)).connectString("foo").build();        Assert.fail();    } catch (IllegalArgumentException e) {        }}
169f68ff7aba6af391c7b9f86f59e3d96da49d7d112b112854ddc02bf8ed5af8
testGetNamespace
public void testGetNamespace() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    CuratorFramework client2 = CuratorFrameworkFactory.builder().namespace("snafu").retryPolicy(new RetryOneTime(1)).connectString("foo").build();    try {        client.start();        CuratorFramework fooClient = client.usingNamespace("foo");        CuratorFramework barClient = client.usingNamespace("bar");        Assert.assertEquals(client.getNamespace(), "");        Assert.assertEquals(client2.getNamespace(), "snafu");        Assert.assertEquals(fooClient.getNamespace(), "foo");        Assert.assertEquals(barClient.getNamespace(), "bar");    } finally {        CloseableUtils.closeQuietly(client2);        CloseableUtils.closeQuietly(client);    }}
9a457089d3c0aa7e392d47714920a87bc7bbdbafca19e6cb15457a777de93ed0
testSimultaneous
public void testSimultaneous() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        CuratorFramework fooClient = client.usingNamespace("foo");        CuratorFramework barClient = client.usingNamespace("bar");        fooClient.create().forPath("/one");        barClient.create().forPath("/one");        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/foo/one", false));        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/bar/one", false));    } finally {        CloseableUtils.closeQuietly(client);    }}
262162e24300eabe1c6b7a6f8527138d5f66f6dc70a8c47816da86ae3e964667
testCache
public void testCache() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        Assert.assertSame(client.usingNamespace("foo"), client.usingNamespace("foo"));        Assert.assertNotSame(client.usingNamespace("foo"), client.usingNamespace("bar"));    } finally {        CloseableUtils.closeQuietly(client);    }}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/one");        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/one", false));        client.usingNamespace("space").create().forPath("/one");        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/space", false));        client.usingNamespace("name").create().forPath("/one");        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/name", false));        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/name/one", false));    } finally {        CloseableUtils.closeQuietly(client);    }}
87daebac5701bf125237bb78b61dcb650f410015305ddeae8cf3b0f0d4aedd0b
testRootAccess
public void testRootAccess() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/one");        Assert.assertNotNull(client.getZookeeperClient().getZooKeeper().exists("/one", false));        Assert.assertNotNull(client.checkExists().forPath("/"));        try {            client.checkExists().forPath("");            Assert.fail("IllegalArgumentException expected");        } catch (IllegalArgumentException expected) {        }        Assert.assertNotNull(client.usingNamespace("one").checkExists().forPath("/"));        try {            client.usingNamespace("one").checkExists().forPath("");            Assert.fail("IllegalArgumentException expected");        } catch (IllegalArgumentException expected) {        }    } finally {        CloseableUtils.closeQuietly(client);    }}
6f452e3a14811fdfbcd1158018523cfa59cb1c5752dcfe631cbefe33c95f3735
testIsStarted
public void testIsStarted() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    CuratorFramework namespaced = client.usingNamespace(null);    Assert.assertEquals(client.getState(), namespaced.getState(), "Namespaced state did not match true state after call to start.");    client.close();    Assert.assertEquals(client.getState(), namespaced.getState(), "Namespaced state did not match true state after call to close.");}
fffef14b1589473e4dd7786504a2d65d6735782141032dbb5a81220843a42245
testACL
public void testACL() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    client.getZookeeperClient().blockUntilConnectedOrTimedOut();    client.create().creatingParentsIfNeeded().forPath("/parent/child", "A string".getBytes());    CuratorFramework client2 = client.usingNamespace("parent");    Assert.assertNotNull(client2.getData().forPath("/child"));    client.setACL().withACL(Collections.singletonList(new ACL(ZooDefs.Perms.WRITE, ZooDefs.Ids.ANYONE_ID_UNSAFE))).forPath("/parent/child");        try {        List<ACL> acls = client2.getACL().forPath("/child");        Assert.assertNotNull(acls);        Assert.assertEquals(acls.size(), 1);        Assert.assertEquals(acls.get(0).getId(), ZooDefs.Ids.ANYONE_ID_UNSAFE);        Assert.assertEquals(acls.get(0).getPerms(), ZooDefs.Perms.WRITE);        client2.setACL().withACL(Collections.singletonList(new ACL(ZooDefs.Perms.DELETE, ZooDefs.Ids.ANYONE_ID_UNSAFE))).forPath("/child");        Assert.fail("Expected auth exception was not thrown");    } catch (NoAuthException e) {        }}
8fbeda8ecbf17b92cfe5dd8e39546fcebc78687163d8efbe6262b8e5b533dbdf
testUnfixForEmptyNamespace
public void testUnfixForEmptyNamespace()
{    CuratorFramework client = CuratorFrameworkFactory.builder().namespace("").retryPolicy(new RetryOneTime(1)).connectString("foo").build();    CuratorFrameworkImpl clientImpl = (CuratorFrameworkImpl) client;    Assert.assertEquals(clientImpl.unfixForNamespace("/foo/bar"), "/foo/bar");    CloseableUtils.closeQuietly(client);}
db8bcb1f55ef955877560be58b6f9fe91b4d5649dd165bc1ddf6796a28d34efc
testNeverConnected
public void testNeverConnected() throws Exception
{    Timing timing = new Timing();        CuratorFramework client = CuratorFrameworkFactory.newClient("localhost:1111", 100, 100, new RetryOneTime(1));    try {        final BlockingQueue<ConnectionState> queue = Queues.newLinkedBlockingQueue();        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState state) {                queue.add(state);            }        };        client.getConnectionStateListenable().addListener(listener);        client.start();        client.create().inBackground().forPath("/");        ConnectionState polled = queue.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertEquals(polled, ConnectionState.SUSPENDED);        polled = queue.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertEquals(polled, ConnectionState.LOST);    } finally {        CloseableUtils.closeQuietly(client);    }}
cffcf8f5282c00a213311a31c5d10543a03040507c0b2b09c19176bdf43920e4
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState state)
{    queue.add(state);}
5ff0b8f7d2b080bcc6214fa5f91be74727145ea81cacb63a99c8d0f3106c089f
setup
public void setup()
{    System.setProperty("readonlymode.enabled", "true");}
39e5ba029cc67f6f1d45c6d20f0df595ec16bc61da20d7680fcbbdae4fe7f95b
tearDown
public void tearDown()
{    System.setProperty("readonlymode.enabled", "false");}
9429cecd952fa103118a1574cdb715793bff607420b1ca1d1103312d10336e8c
testConnectionStateNewClient
public void testConnectionStateNewClient() throws Exception
{    Timing timing = new Timing();    TestingCluster cluster = new TestingCluster(3);    CuratorFramework client = null;    try {        cluster.start();        client = CuratorFrameworkFactory.newClient(cluster.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(100));        client.start();        client.checkExists().forPath("/");        client.close();        client = null;        Iterator<InstanceSpec> iterator = cluster.getInstances().iterator();        for (int i = 0; i < 2; ++i) {            cluster.killServer(iterator.next());        }        client = CuratorFrameworkFactory.builder().connectString(cluster.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new RetryNTimes(3, timing.milliseconds())).canBeReadOnly(true).build();        final BlockingQueue<ConnectionState> states = Queues.newLinkedBlockingQueue();        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                states.add(newState);            }        });        client.start();        client.checkExists().forPath("/");        ConnectionState state = states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS);        Assert.assertEquals(state, ConnectionState.READ_ONLY);    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(cluster);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    states.add(newState);}
67a4931182f091ce9db6a626a3a12a4781b272d0eee6e8eb710d87ae62e0e3ae
testReadOnly
public void testReadOnly() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = null;    TestingCluster cluster = new TestingCluster(2);    try {        cluster.start();        client = CuratorFrameworkFactory.builder().connectString(cluster.getConnectString()).canBeReadOnly(true).connectionTimeoutMs(timing.connection()).sessionTimeoutMs(timing.session()).retryPolicy(new ExponentialBackoffRetry(100, 3)).build();        client.start();        client.create().forPath("/test");        final CountDownLatch readOnlyLatch = new CountDownLatch(1);        final CountDownLatch reconnectedLatch = new CountDownLatch(1);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.READ_ONLY) {                    readOnlyLatch.countDown();                } else if (newState == ConnectionState.RECONNECTED) {                    reconnectedLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        InstanceSpec ourInstance = cluster.findConnectionInstance(client.getZookeeperClient().getZooKeeper());        Iterator<InstanceSpec> iterator = cluster.getInstances().iterator();        InstanceSpec killInstance = iterator.next();        if (killInstance.equals(ourInstance)) {                        killInstance = iterator.next();        }        cluster.killServer(killInstance);        Assert.assertEquals(reconnectedLatch.getCount(), 1);        Assert.assertTrue(timing.awaitLatch(readOnlyLatch));        Assert.assertEquals(reconnectedLatch.getCount(), 1);        cluster.restartServer(killInstance);        Assert.assertTrue(timing.awaitLatch(reconnectedLatch));    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(cluster);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.READ_ONLY) {        readOnlyLatch.countDown();    } else if (newState == ConnectionState.RECONNECTED) {        reconnectedLatch.countDown();    }}
27681e68ec2a1eb903f955680ebe003ceb3707295c8aad884b692d378c6e37cf
setup
public void setup() throws Exception
{    super.setup();    QuorumPeerConfig.setReconfigEnabled(true);    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", superUserPasswordDigest);    CloseableUtils.closeQuietly(server);    server = null;    cluster = new TestingCluster(3);    cluster.start();}
7c529460b940c419ef707bd1846a5575ea1bfc48c129127836c31f0184c1d8fb
teardown
public void teardown() throws Exception
{    CloseableUtils.closeQuietly(cluster);    ensembleProvider = null;    System.clearProperty("zookeeper.DigestAuthenticationProvider.superDigest");    super.teardown();}
56a8819d3914fec39c711606f894388c5173199a2103283e0952bc776bada3ba
testApiPermutations
public void testApiPermutations() throws Exception
{        Watcher watcher = null;    Stat stat = null;    CuratorFramework client = null;    client.getConfig().forEnsemble();    client.getConfig().inBackground().forEnsemble();    client.getConfig().usingWatcher(watcher).forEnsemble();    client.getConfig().usingWatcher(watcher).inBackground().forEnsemble();    client.getConfig().storingStatIn(stat).forEnsemble();    client.getConfig().storingStatIn(stat).inBackground().forEnsemble();    client.getConfig().storingStatIn(stat).usingWatcher(watcher).forEnsemble();    client.getConfig().storingStatIn(stat).usingWatcher(watcher).inBackground().forEnsemble();        client.reconfig().leaving().forEnsemble();    client.reconfig().joining().forEnsemble();    client.reconfig().leaving().joining().forEnsemble();    client.reconfig().joining().leaving().forEnsemble();    client.reconfig().withNewMembers().forEnsemble();    client.reconfig().leaving().fromConfig(0).forEnsemble();    client.reconfig().joining().fromConfig(0).forEnsemble();    client.reconfig().leaving().joining().fromConfig(0).forEnsemble();    client.reconfig().joining().leaving().fromConfig(0).forEnsemble();    client.reconfig().withNewMembers().fromConfig(0).forEnsemble();    client.reconfig().leaving().storingStatIn(stat).forEnsemble();    client.reconfig().joining().storingStatIn(stat).forEnsemble();    client.reconfig().leaving().joining().storingStatIn(stat).forEnsemble();    client.reconfig().joining().leaving().storingStatIn(stat).forEnsemble();    client.reconfig().withNewMembers().storingStatIn(stat).forEnsemble();    client.reconfig().leaving().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().joining().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().leaving().joining().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().joining().leaving().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().withNewMembers().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().inBackground().leaving().forEnsemble();    client.reconfig().inBackground().joining().forEnsemble();    client.reconfig().inBackground().leaving().joining().forEnsemble();    client.reconfig().inBackground().joining().leaving().forEnsemble();    client.reconfig().inBackground().withNewMembers().forEnsemble();    client.reconfig().inBackground().leaving().fromConfig(0).forEnsemble();    client.reconfig().inBackground().joining().fromConfig(0).forEnsemble();    client.reconfig().inBackground().leaving().joining().fromConfig(0).forEnsemble();    client.reconfig().inBackground().joining().leaving().fromConfig(0).forEnsemble();    client.reconfig().inBackground().withNewMembers().fromConfig(0).forEnsemble();    client.reconfig().inBackground().leaving().storingStatIn(stat).forEnsemble();    client.reconfig().inBackground().joining().storingStatIn(stat).forEnsemble();    client.reconfig().inBackground().leaving().joining().storingStatIn(stat).forEnsemble();    client.reconfig().inBackground().joining().leaving().storingStatIn(stat).forEnsemble();    client.reconfig().inBackground().withNewMembers().storingStatIn(stat).forEnsemble();    client.reconfig().inBackground().leaving().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().inBackground().joining().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().inBackground().leaving().joining().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().inBackground().joining().leaving().storingStatIn(stat).fromConfig(0).forEnsemble();    client.reconfig().inBackground().withNewMembers().storingStatIn(stat).fromConfig(0).forEnsemble();}
b89d6491f8e0282e002da7cc6a4198edf86b38fccf2c9defdf27cc784f40e500
testBasicGetConfig
public void testBasicGetConfig() throws Exception
{    try (CuratorFramework client = newClient()) {        client.start();        byte[] configData = client.getConfig().forEnsemble();        QuorumVerifier quorumVerifier = toQuorumVerifier(configData);        System.out.println(quorumVerifier);        assertConfig(quorumVerifier, cluster.getInstances());        Assert.assertEquals(EnsembleTracker.configToConnectionString(quorumVerifier), ensembleProvider.getConnectionString());    }}
266bd6610687c556a6e052ba35215041a3b057678d0654cc7b13db9b2f4ac9ef
testAdd
public void testAdd() throws Exception
{    try (CuratorFramework client = newClient()) {        client.start();        QuorumVerifier oldConfig = toQuorumVerifier(client.getConfig().forEnsemble());        assertConfig(oldConfig, cluster.getInstances());        CountDownLatch latch = setChangeWaiter(client);        try (TestingCluster newCluster = new TestingCluster(TestingCluster.makeSpecs(1, false))) {            newCluster.start();            client.reconfig().joining(toReconfigSpec(newCluster.getInstances())).fromConfig(oldConfig.getVersion()).forEnsemble();            Assert.assertTrue(timing.awaitLatch(latch));            byte[] newConfigData = client.getConfig().forEnsemble();            QuorumVerifier newConfig = toQuorumVerifier(newConfigData);            List<InstanceSpec> newInstances = Lists.newArrayList(cluster.getInstances());            newInstances.addAll(newCluster.getInstances());            assertConfig(newConfig, newInstances);            Assert.assertEquals(EnsembleTracker.configToConnectionString(newConfig), ensembleProvider.getConnectionString());        }    }}
c5ac5dcbd97e1d62b587ad2f4b8212c3d023b85fb29284b2dde550af5fae0c7b
testAddAsync
public void testAddAsync() throws Exception
{    try (CuratorFramework client = newClient()) {        client.start();        QuorumVerifier oldConfig = toQuorumVerifier(client.getConfig().forEnsemble());        assertConfig(oldConfig, cluster.getInstances());        CountDownLatch latch = setChangeWaiter(client);        try (TestingCluster newCluster = new TestingCluster(TestingCluster.makeSpecs(1, false))) {            newCluster.start();            final CountDownLatch callbackLatch = new CountDownLatch(1);            BackgroundCallback callback = new BackgroundCallback() {                @Override                public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                    if (event.getType() == CuratorEventType.RECONFIG) {                        callbackLatch.countDown();                    }                }            };            client.reconfig().inBackground(callback).joining(toReconfigSpec(newCluster.getInstances())).fromConfig(oldConfig.getVersion()).forEnsemble();            Assert.assertTrue(timing.awaitLatch(callbackLatch));            Assert.assertTrue(timing.awaitLatch(latch));            byte[] newConfigData = client.getConfig().forEnsemble();            QuorumVerifier newConfig = toQuorumVerifier(newConfigData);            List<InstanceSpec> newInstances = Lists.newArrayList(cluster.getInstances());            newInstances.addAll(newCluster.getInstances());            assertConfig(newConfig, newInstances);            Assert.assertEquals(EnsembleTracker.configToConnectionString(newConfig), ensembleProvider.getConnectionString());        }    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.RECONFIG) {        callbackLatch.countDown();    }}
690de980d89e31b933eccb583c3a21b5edf85b64151f1cb82431b575d028398b
testAddAndRemove
public void testAddAndRemove() throws Exception
{    try (CuratorFramework client = newClient()) {        client.start();        QuorumVerifier oldConfig = toQuorumVerifier(client.getConfig().forEnsemble());        assertConfig(oldConfig, cluster.getInstances());        CountDownLatch latch = setChangeWaiter(client);        try (TestingCluster newCluster = new TestingCluster(TestingCluster.makeSpecs(1, false))) {            newCluster.start();            Collection<InstanceSpec> oldInstances = cluster.getInstances();            InstanceSpec us = cluster.findConnectionInstance(client.getZookeeperClient().getZooKeeper());            InstanceSpec removeSpec = oldInstances.iterator().next();            if (us.equals(removeSpec)) {                Iterator<InstanceSpec> iterator = oldInstances.iterator();                iterator.next();                removeSpec = iterator.next();            }            Collection<InstanceSpec> instances = newCluster.getInstances();            client.reconfig().leaving(Integer.toString(removeSpec.getServerId())).joining(toReconfigSpec(instances)).fromConfig(oldConfig.getVersion()).forEnsemble();            Assert.assertTrue(timing.awaitLatch(latch));            byte[] newConfigData = client.getConfig().forEnsemble();            QuorumVerifier newConfig = toQuorumVerifier(newConfigData);            ArrayList<InstanceSpec> newInstances = Lists.newArrayList(oldInstances);            newInstances.addAll(instances);            newInstances.remove(removeSpec);            assertConfig(newConfig, newInstances);            Assert.assertEquals(EnsembleTracker.configToConnectionString(newConfig), ensembleProvider.getConnectionString());        }    }}
2229a8594b3860eb87563337865e87ca8ccd87b8f0b1f093073660a4f5330f3a
testNewMembers
public void testNewMembers() throws Exception
{    cluster.close();    cluster = null;    TestingCluster smallCluster = null;    TestingCluster localCluster = new TestingCluster(5);    try {        List<TestingZooKeeperServer> servers = localCluster.getServers();        List<InstanceSpec> smallClusterInstances = Lists.newArrayList();        for (        int i = 0;         i < 3;         ++i) {            TestingZooKeeperServer server = servers.get(i);            server.start();            smallClusterInstances.add(server.getInstanceSpec());        }        smallCluster = new TestingCluster(smallClusterInstances);        try (CuratorFramework client = newClient(smallCluster.getConnectString())) {            client.start();            QuorumVerifier oldConfig = toQuorumVerifier(client.getConfig().forEnsemble());            Assert.assertEquals(oldConfig.getAllMembers().size(), 5);            assertConfig(oldConfig, localCluster.getInstances());            CountDownLatch latch = setChangeWaiter(client);            client.reconfig().withNewMembers(toReconfigSpec(smallClusterInstances)).forEnsemble();            Assert.assertTrue(timing.awaitLatch(latch));            byte[] newConfigData = client.getConfig().forEnsemble();            QuorumVerifier newConfig = toQuorumVerifier(newConfigData);            Assert.assertEquals(newConfig.getAllMembers().size(), 3);            assertConfig(newConfig, smallClusterInstances);            Assert.assertEquals(EnsembleTracker.configToConnectionString(newConfig), ensembleProvider.getConnectionString());        }    } finally {        CloseableUtils.closeQuietly(smallCluster);        CloseableUtils.closeQuietly(localCluster);    }}
5831674f6b9d75bf1156f292b53a3d3032822e6d7a6a54d753dffe7b5df5ab25
testConfigToConnectionStringIPv4Normal
public void testConfigToConnectionStringIPv4Normal() throws Exception
{    String config = "server.1=10.1.2.3:2888:3888:participant;10.2.3.4:2181";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("10.2.3.4:2181", configString);}
9d1a8302d77652da734064c934961807c56db5beff03cbb2287088c33e7b5b23
testConfigToConnectionStringIPv6Normal
public void testConfigToConnectionStringIPv6Normal() throws Exception
{    String config = "server.1=[1010:0001:0002:0003:0004:0005:0006:0007]:2888:3888:participant;[2001:db8:85a3:0:0:8a2e:370:7334]:2181";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("2001:db8:85a3:0:0:8a2e:370:7334:2181", configString);}
a24f1746b2700e4e6e1ab92a9322fbc2a9823409a12763f56a02dccfa82b25b7
testConfigToConnectionStringIPv4NoClientAddr
public void testConfigToConnectionStringIPv4NoClientAddr() throws Exception
{    String config = "server.1=10.1.2.3:2888:3888:participant;2181";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("10.1.2.3:2181", configString);}
06e55a3e8174a0bc90dc602176be70a71af5d73f5e1e33f71f498fa7cca0dab1
testConfigToConnectionStringIPv4WildcardClientAddr
public void testConfigToConnectionStringIPv4WildcardClientAddr() throws Exception
{    String config = "server.1=10.1.2.3:2888:3888:participant;0.0.0.0:2181";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("10.1.2.3:2181", configString);}
7b00cd9c0d292e8765fb96d099609097557fcd58ca36571eeb461316e5c5683d
testConfigToConnectionStringNoClientAddrOrPort
public void testConfigToConnectionStringNoClientAddrOrPort() throws Exception
{    String config = "server.1=10.1.2.3:2888:3888:participant";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("", configString);}
7032b9ceeb10c9c829d47dfad617c3c18800333e670d43fbf713de8088f39254
testIPv6Wildcard1
public void testIPv6Wildcard1() throws Exception
{    String config = "server.1=[2001:db8:85a3:0:0:8a2e:370:7334]:2888:3888:participant;[::]:2181";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("2001:db8:85a3:0:0:8a2e:370:7334:2181", configString);}
b737b3013db64af04f1f218fb337d21f10e6d881a04194f793af4ae59a90d277
testIPv6Wildcard2
public void testIPv6Wildcard2() throws Exception
{    String config = "server.1=[1010:0001:0002:0003:0004:0005:0006:0007]:2888:3888:participant;[::0]:2181";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("1010:1:2:3:4:5:6:7:2181", configString);}
f09004386733b432033822c5be9168cc8d9c019dd0f85c40f7efbea35b3ff1e6
testMixedIPv1
public void testMixedIPv1() throws Exception
{    String config = "server.1=10.1.2.3:2888:3888:participant;[::]:2181";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("10.1.2.3:2181", configString);}
8413391bd29c7b4a13a335b7b1a3bc69f6dbd636d05e1c72451a608d6cae8516
testMixedIPv2
public void testMixedIPv2() throws Exception
{    String config = "server.1=[2001:db8:85a3:0:0:8a2e:370:7334]:2888:3888:participant;127.0.0.1:2181";    String configString = EnsembleTracker.configToConnectionString(toQuorumVerifier(config.getBytes()));    Assert.assertEquals("127.0.0.1:2181", configString);}
bad4e821b27f5a4d9093806abf14ab34648135a80dd3b783fa5643cbca8e943e
newClient
private CuratorFramework newClient()
{    return newClient(cluster.getConnectString());}
fe2a4eae0c08dd95e5e0b6019e560d94e6a283d97c5027e319ca93492a13df74
newClient
private CuratorFramework newClient(String connectionString)
{    final AtomicReference<String> connectString = new AtomicReference<>(connectionString);    ensembleProvider = new EnsembleProvider() {        @Override        public void start() throws Exception {        }        @Override        public boolean updateServerListEnabled() {            return false;        }        @Override        public String getConnectionString() {            return connectString.get();        }        @Override        public void close() throws IOException {        }        @Override        public void setConnectionString(String connectionString) {            connectString.set(connectionString);        }    };    return CuratorFrameworkFactory.builder().ensembleProvider(ensembleProvider).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).authorization("digest", superUserPassword.getBytes()).retryPolicy(new ExponentialBackoffRetry(timing.forSleepingABit().milliseconds(), 3)).build();}
90ba0dddc593bd95e2a0c0c039c523b81bfb91f87814ebcb222c3914ca772ead
start
public void start() throws Exception
{}
4d8f8c3644e8bcf9c25bb24a5c68147d454045b529f3acc5b3ab9f472ebbed35
updateServerListEnabled
public boolean updateServerListEnabled()
{    return false;}
3a15ca2ed8208cd07404b01c15089fa841a6e5aecf12a07cc9d92b33a3adb8ac
getConnectionString
public String getConnectionString()
{    return connectString.get();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{}
8288ce4403dd68ee31bc3e4125518f3f79dd8811760a6c6877cce621be05ce5a
setConnectionString
public void setConnectionString(String connectionString)
{    connectString.set(connectionString);}
547a958d439954a023b4ff6a463dbb1f15c6cf4ab99786626166f8eef34991ae
setChangeWaiter
private CountDownLatch setChangeWaiter(CuratorFramework client) throws Exception
{    final CountDownLatch latch = new CountDownLatch(1);    Watcher watcher = new Watcher() {        @Override        public void process(WatchedEvent event) {            if (event.getType() == Event.EventType.NodeDataChanged) {                latch.countDown();            }        }    };    client.getConfig().usingWatcher(watcher).forEnsemble();    return latch;}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (event.getType() == Event.EventType.NodeDataChanged) {        latch.countDown();    }}
56ef6fb1f860b12194ff8ee8a2fc5f7c219aac811fb9eab82a848afa9fbb3ec3
assertConfig
private void assertConfig(QuorumVerifier config, Collection<InstanceSpec> instances)
{    for (InstanceSpec instance : instances) {        QuorumPeer.QuorumServer quorumServer = config.getAllMembers().get((long) instance.getServerId());        Assert.assertNotNull(quorumServer, String.format("Looking for %s - found %s", instance.getServerId(), config.getAllMembers()));        Assert.assertEquals(quorumServer.clientAddr.getPort(), instance.getPort());    }}
a4ac4f3674b98ee68def783c95ff628c5544e47a1fca89b0c2b888c092687d1d
toReconfigSpec
private List<String> toReconfigSpec(Collection<InstanceSpec> instances) throws Exception
{    String localhost = new InetSocketAddress((InetAddress) null, 0).getAddress().getHostAddress();    List<String> specs = Lists.newArrayList();    for (InstanceSpec instance : instances) {        specs.add("server." + instance.getServerId() + "=" + localhost + ":" + instance.getElectionPort() + ":" + instance.getQuorumPort() + ";" + instance.getPort());    }    return specs;}
9a4928755db85cd5c8d002d2b7bb8aeeb98f37018c260e515196c9a86c148860
toQuorumVerifier
private static QuorumVerifier toQuorumVerifier(byte[] bytes) throws Exception
{    Assert.assertNotNull(bytes);    Properties properties = new Properties();    properties.load(new ByteArrayInputStream(bytes));    return new QuorumMaj(properties);}
72ae4948f2b023e3bc8cbf9e41237bbe8a8f3fee0747fb018d589a54b5e061df
registerConnectionStateListener
private AtomicReference<ConnectionState> registerConnectionStateListener(CuratorFramework client)
{    final AtomicReference<ConnectionState> state = new AtomicReference<ConnectionState>();    client.getConnectionStateListenable().addListener(new ConnectionStateListener() {        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {            state.set(newState);            synchronized (state) {                state.notify();            }        }    });    return state;}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    state.set(newState);    synchronized (state) {        state.notify();    }}
6cdc3a51b5dfa4767a04c321907a13753c2f373c15ae64fa885c367284fa58ae
blockUntilDesiredConnectionState
private boolean blockUntilDesiredConnectionState(AtomicReference<ConnectionState> stateRef, Timing timing, final ConnectionState desiredState)
{    if (stateRef.get() == desiredState) {        return true;    }        synchronized (stateRef) {        if (stateRef.get() == desiredState) {            return true;        }        try {            stateRef.wait(timing.milliseconds());            return stateRef.get() == desiredState;        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            return false;        }    }}
988fc499262b98dd40e288a67530df0855119cc01bb38c67c2973024d982249e
testRemoveCuratorDefaultWatcher
public void testRemoveCuratorDefaultWatcher() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final CountDownLatch removedLatch = new CountDownLatch(1);        final String path = "/";        client.getCuratorListenable().addListener(new CuratorListener() {            @Override            public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.WATCHED && event.getWatchedEvent().getType() == EventType.DataWatchRemoved) {                    removedLatch.countDown();                }            }        });        client.checkExists().watched().forPath(path);        client.watches().removeAll().forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");    } finally {        CloseableUtils.closeQuietly(client);    }}
e958fd31854b02620bcc0e47a47ca286f0584d1be38198248b0d2054a45a8cea
eventReceived
public void eventReceived(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.WATCHED && event.getWatchedEvent().getType() == EventType.DataWatchRemoved) {        removedLatch.countDown();    }}
0f866bd59c159659388d114774319f040cdfa6d07a157763ed2d4f2873fe0e64
testRemoveCuratorWatch
public void testRemoveCuratorWatch() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkImpl client = (CuratorFrameworkImpl) CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final CountDownLatch removedLatch = new CountDownLatch(1);        final String path = "/";        CuratorWatcher watcher = new CuratorWatcher() {            @Override            public void process(WatchedEvent event) throws Exception {                if (event.getPath().equals(path) && event.getType() == EventType.DataWatchRemoved) {                    removedLatch.countDown();                }            }        };        client.checkExists().usingWatcher(watcher).forPath(path);        client.watches().remove(watcher).forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");    } finally {        CloseableUtils.closeQuietly(client);    }}
a4803fca4797306b4f772a40c997680043dc08b35469407056bd5b28cf26096b
process
public void process(WatchedEvent event) throws Exception
{    if (event.getPath().equals(path) && event.getType() == EventType.DataWatchRemoved) {        removedLatch.countDown();    }}
901fb553bd86b76b249b3054bfafbb8cfb66be8d555732ae21f261c3d55f64ca
testRemoveWatch
public void testRemoveWatch() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkImpl client = (CuratorFrameworkImpl) CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final CountDownLatch removedLatch = new CountDownLatch(1);        final String path = "/";        Watcher watcher = new CountDownWatcher(path, removedLatch, EventType.DataWatchRemoved);        client.checkExists().usingWatcher(watcher).forPath(path);        client.watches().remove(watcher).forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");    } finally {        CloseableUtils.closeQuietly(client);    }}
2455ffc25b02a43fd1626d03345c3324f6195b4d7b2705db0d812a7a458326bc
testRemoveWatchInBackgroundWithCallback
public void testRemoveWatchInBackgroundWithCallback() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkImpl client = (CuratorFrameworkImpl) CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();                final CountDownLatch removedLatch = new CountDownLatch(2);        final String path = "/";        Watcher watcher = new CountDownWatcher(path, removedLatch, EventType.DataWatchRemoved);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getType() == CuratorEventType.REMOVE_WATCHES && event.getPath().equals(path)) {                    removedLatch.countDown();                }            }        };        client.checkExists().usingWatcher(watcher).forPath(path);        client.watches().remove(watcher).ofType(WatcherType.Any).inBackground(callback).forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");    } finally {        CloseableUtils.closeQuietly(client);    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getType() == CuratorEventType.REMOVE_WATCHES && event.getPath().equals(path)) {        removedLatch.countDown();    }}
5a75febf7a71de8eacc20f2f5270df909f8b3eb69d31fd6bab2b7cbdfdd9db0e
testRemoveWatchInBackgroundWithNoCallback
public void testRemoveWatchInBackgroundWithNoCallback() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkImpl client = (CuratorFrameworkImpl) CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final String path = "/";        final CountDownLatch removedLatch = new CountDownLatch(1);        Watcher watcher = new CountDownWatcher(path, removedLatch, EventType.DataWatchRemoved);        client.checkExists().usingWatcher(watcher).forPath(path);        client.watches().remove(watcher).inBackground().forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");    } finally {        CloseableUtils.closeQuietly(client);    }}
b1eb4ef4aa1ca765d43c9eb68c154b5c624b03971b8eb9468b908b76d2451b5a
testRemoveAllWatches
public void testRemoveAllWatches() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkImpl client = (CuratorFrameworkImpl) CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final String path = "/";        final CountDownLatch removedLatch = new CountDownLatch(2);        Watcher watcher1 = new CountDownWatcher(path, removedLatch, EventType.ChildWatchRemoved);        Watcher watcher2 = new CountDownWatcher(path, removedLatch, EventType.DataWatchRemoved);        client.getChildren().usingWatcher(watcher1).forPath(path);        client.checkExists().usingWatcher(watcher2).forPath(path);        client.watches().removeAll().forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");    } finally {        CloseableUtils.closeQuietly(client);    }}
7cb9cea407c9050ecc5f429241029f4808dd0118caef37894e158a6c1d2c7e7f
testRemoveAllDataWatches
public void testRemoveAllDataWatches() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final String path = "/";        final AtomicBoolean removedFlag = new AtomicBoolean(false);        final CountDownLatch removedLatch = new CountDownLatch(1);        Watcher watcher1 = new BooleanWatcher(path, removedFlag, EventType.ChildWatchRemoved);        Watcher watcher2 = new CountDownWatcher(path, removedLatch, EventType.DataWatchRemoved);        client.getChildren().usingWatcher(watcher1).forPath(path);        client.checkExists().usingWatcher(watcher2).forPath(path);        client.watches().removeAll().ofType(WatcherType.Data).forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");        Assert.assertEquals(removedFlag.get(), false);    } finally {        CloseableUtils.closeQuietly(client);    }}
9eb4cec932f55b7197d09730208576019b7ca6b89dbd459cbf2958cf09750fd5
testRemoveAllChildWatches
public void testRemoveAllChildWatches() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final String path = "/";        final AtomicBoolean removedFlag = new AtomicBoolean(false);        final CountDownLatch removedLatch = new CountDownLatch(1);        Watcher watcher1 = new BooleanWatcher(path, removedFlag, EventType.DataWatchRemoved);        Watcher watcher2 = new CountDownWatcher(path, removedLatch, EventType.ChildWatchRemoved);        client.checkExists().usingWatcher(watcher1).forPath(path);        client.getChildren().usingWatcher(watcher2).forPath(path);        client.watches().removeAll().ofType(WatcherType.Children).forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");        Assert.assertEquals(removedFlag.get(), false);    } finally {        CloseableUtils.closeQuietly(client);    }}
e40d49a4a3e4e957beff9e3d35c6af6129c338151f428f8f487c311840bf8295
testRemoveLocalWatch
public void testRemoveLocalWatch() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkImpl client = (CuratorFrameworkImpl) CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        AtomicReference<ConnectionState> stateRef = registerConnectionStateListener(client);        final String path = "/";        final CountDownLatch removedLatch = new CountDownLatch(1);        Watcher watcher = new CountDownWatcher(path, removedLatch, EventType.DataWatchRemoved);        client.checkExists().usingWatcher(watcher).forPath(path);                server.stop();        Assert.assertTrue(blockUntilDesiredConnectionState(stateRef, timing, ConnectionState.SUSPENDED));        client.watches().removeAll().locally().forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");    } finally {        CloseableUtils.closeQuietly(client);    }}
297c449f8fc9832dd11f5663772616d3526c07301c899bd384b5bb80cb3de550
testRemoveLocalWatchInBackground
public void testRemoveLocalWatchInBackground() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkImpl client = (CuratorFrameworkImpl) CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        AtomicReference<ConnectionState> stateRef = registerConnectionStateListener(client);        final String path = "/";        final CountDownLatch removedLatch = new CountDownLatch(1);        Watcher watcher = new CountDownWatcher(path, removedLatch, EventType.DataWatchRemoved);        client.checkExists().usingWatcher(watcher).forPath(path);                server.stop();        Assert.assertTrue(blockUntilDesiredConnectionState(stateRef, timing, ConnectionState.SUSPENDED));        client.watches().removeAll().locally().inBackground().forPath(path);        Assert.assertTrue(timing.awaitLatch(removedLatch), "Timed out waiting for watch removal");    } finally {        CloseableUtils.closeQuietly(client);    }}
6edf7ac97126562f1633d3d7ae766f944a30eaf8dabd3f36cd4007cdf6208bdb
testRemoveUnregisteredWatcher
public void testRemoveUnregisteredWatcher() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final String path = "/";        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {            }        };        try {            client.watches().remove(watcher).forPath(path);            Assert.fail("Expected KeeperException.NoWatcherException");        } catch (KeeperException.NoWatcherException expected) {                }    } finally {        CloseableUtils.closeQuietly(client);    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{}
b4e5d6380a51992a74300baf86d9f693e547cf101e609e44fadf238f63d8adf9
testRemoveUnregisteredWatcherQuietly
public void testRemoveUnregisteredWatcherQuietly() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final AtomicBoolean watcherRemoved = new AtomicBoolean(false);        final String path = "/";        Watcher watcher = new BooleanWatcher(path, watcherRemoved, EventType.DataWatchRemoved);        client.watches().remove(watcher).quietly().forPath(path);        timing.sleepABit();                Assert.assertEquals(watcherRemoved.get(), false);    } finally {        CloseableUtils.closeQuietly(client);    }}
130c9abf16f75380201e08a454f82de4bb7c08267f6a88211fa809aa66cf8571
testGuaranteedRemoveWatch
public void testGuaranteedRemoveWatch() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        AtomicReference<ConnectionState> stateRef = registerConnectionStateListener(client);        String path = "/";        CountDownLatch removeLatch = new CountDownLatch(1);        Watcher watcher = new CountDownWatcher(path, removeLatch, EventType.DataWatchRemoved);        client.checkExists().usingWatcher(watcher).forPath(path);        server.stop();        Assert.assertTrue(blockUntilDesiredConnectionState(stateRef, timing, ConnectionState.SUSPENDED));                try {            client.watches().remove(watcher).guaranteed().forPath(path);            Assert.fail();        } catch (KeeperException.ConnectionLossException e) {                }        server.restart();        timing.awaitLatch(removeLatch);    } finally {        CloseableUtils.closeQuietly(client);    }}
19a2e54f89e38a875558720e16a09ef9c3c31e6783c0a0dc221746eab90d541c
testGuaranteedRemoveWatchInBackground
public void testGuaranteedRemoveWatchInBackground() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));    try {        client.start();        AtomicReference<ConnectionState> stateRef = registerConnectionStateListener(client);        final CountDownLatch guaranteeAddedLatch = new CountDownLatch(1);        ((CuratorFrameworkImpl) client).getFailedRemoveWatcherManager().debugListener = new FailedOperationManager.FailedOperationManagerListener<FailedRemoveWatchManager.FailedRemoveWatchDetails>() {            @Override            public void pathAddedForGuaranteedOperation(FailedRemoveWatchDetails detail) {                guaranteeAddedLatch.countDown();            }        };        String path = "/";        CountDownLatch removeLatch = new CountDownLatch(1);        Watcher watcher = new CountDownWatcher(path, removeLatch, EventType.DataWatchRemoved);        client.checkExists().usingWatcher(watcher).forPath(path);        server.stop();        Assert.assertTrue(blockUntilDesiredConnectionState(stateRef, timing, ConnectionState.SUSPENDED));                client.watches().remove(watcher).guaranteed().inBackground().forPath(path);        timing.awaitLatch(guaranteeAddedLatch);        server.restart();        timing.awaitLatch(removeLatch);    } finally {        CloseableUtils.closeQuietly(client);    }}
955cd4d734a47a5f25b77fce3c803decc65e63f8b4f96fa46469021cb3aaf1d6
pathAddedForGuaranteedOperation
public void pathAddedForGuaranteedOperation(FailedRemoveWatchDetails detail)
{    guaranteeAddedLatch.countDown();}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (event.getPath() == null || event.getType() == null) {        return;    }    if (event.getPath().equals(path) && event.getType() == eventType) {        removeLatch.countDown();    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (event.getPath() == null || event.getType() == null) {        return;    }    if (event.getPath().equals(path) && event.getType() == eventType) {        removedFlag.set(true);    }}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    CuratorTempFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).buildTemp();    try {        client.inTransaction().create().forPath("/foo", "data".getBytes()).and().commit();        byte[] bytes = client.getData().forPath("/foo");        Assert.assertEquals(bytes, "data".getBytes());    } finally {        CloseableUtils.closeQuietly(client);    }}
decbc27f97bf6bd91b24a21ecbb339812ac2551651366550fefee82b13c75a25
testInactivity
public void testInactivity() throws Exception
{    final CuratorTempFrameworkImpl client = (CuratorTempFrameworkImpl) CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).buildTemp(1, TimeUnit.SECONDS);    try {        ScheduledExecutorService service = Executors.newScheduledThreadPool(1);        Runnable command = new Runnable() {            @Override            public void run() {                client.updateLastAccess();            }        };        service.scheduleAtFixedRate(command, 10, 10, TimeUnit.MILLISECONDS);        client.inTransaction().create().forPath("/foo", "data".getBytes()).and().commit();        service.shutdownNow();        Thread.sleep(2000);        Assert.assertNull(client.getCleanup());        Assert.assertNull(client.getClient());    } finally {        CloseableUtils.closeQuietly(client);    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    client.updateLastAccess();}
af87a99ddfb511e59cc4a0cca21ea7f06010d422dab0ec08b8c3cb97760eafc9
testErrors
public void testErrors() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        CuratorOp createOp1 = client.transactionOp().create().forPath("/bar");        CuratorOp createOp2 = client.transactionOp().create().forPath("/z/blue");        final BlockingQueue<CuratorEvent> callbackQueue = new LinkedBlockingQueue<>();        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                callbackQueue.add(event);            }        };        client.transaction().inBackground(callback).forOperations(createOp1, createOp2);        CuratorEvent event = callbackQueue.poll(new Timing().milliseconds(), TimeUnit.MILLISECONDS);        Assert.assertNotNull(event);        Assert.assertNotNull(event.getOpResults());        Assert.assertEquals(event.getOpResults().size(), 2);        Assert.assertEquals(event.getOpResults().get(0).getError(), KeeperException.Code.OK.intValue());        Assert.assertEquals(event.getOpResults().get(1).getError(), KeeperException.Code.NONODE.intValue());    } finally {        CloseableUtils.closeQuietly(client);    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    callbackQueue.add(event);}
180e03a0f15ca907175c2687fe74c8cb477db8888fca9489ee6f847a8978bb21
testCheckVersion
public void testCheckVersion() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/foo");                Stat stat = client.setData().forPath("/foo", "new".getBytes());        CuratorOp statOp = client.transactionOp().check().withVersion(stat.getVersion() + 1).forPath("/foo");        CuratorOp createOp = client.transactionOp().create().forPath("/bar");        try {            client.transaction().forOperations(statOp, createOp);            Assert.fail();        } catch (KeeperException.BadVersionException correct) {                }        Assert.assertNull(client.checkExists().forPath("/bar"));    } finally {        CloseableUtils.closeQuietly(client);    }}
b7fe4c4498bd40571d4924cef6afaf6f3e4e688754f5b9e2a6c8bef2ea59ce9d
testWithNamespace
public void testWithNamespace() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace("galt").build();    try {        client.start();        CuratorOp createOp1 = client.transactionOp().create().forPath("/foo", "one".getBytes());        CuratorOp createOp2 = client.transactionOp().create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath("/test-", "one".getBytes());        CuratorOp setDataOp = client.transactionOp().setData().forPath("/foo", "two".getBytes());        CuratorOp createOp3 = client.transactionOp().create().forPath("/foo/bar");        CuratorOp deleteOp = client.transactionOp().delete().forPath("/foo/bar");        Collection<CuratorTransactionResult> results = client.transaction().forOperations(createOp1, createOp2, setDataOp, createOp3, deleteOp);        Assert.assertTrue(client.checkExists().forPath("/foo") != null);        Assert.assertTrue(client.usingNamespace(null).checkExists().forPath("/galt/foo") != null);        Assert.assertEquals(client.getData().forPath("/foo"), "two".getBytes());        Assert.assertTrue(client.checkExists().forPath("/foo/bar") == null);        CuratorTransactionResult ephemeralResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/test-"));        Assert.assertNotNull(ephemeralResult);        Assert.assertNotEquals(ephemeralResult.getResultPath(), "/test-");        Assert.assertTrue(ephemeralResult.getResultPath().startsWith("/test-"));    } finally {        CloseableUtils.closeQuietly(client);    }}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        CuratorOp createOp1 = client.transactionOp().create().forPath("/foo");        CuratorOp createOp2 = client.transactionOp().create().forPath("/foo/bar", "snafu".getBytes());        Collection<CuratorTransactionResult> results = client.transaction().forOperations(createOp1, createOp2);        Assert.assertTrue(client.checkExists().forPath("/foo/bar") != null);        Assert.assertEquals(client.getData().forPath("/foo/bar"), "snafu".getBytes());        CuratorTransactionResult fooResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/foo"));        CuratorTransactionResult fooBarResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/foo/bar"));        Assert.assertNotNull(fooResult);        Assert.assertNotNull(fooBarResult);        Assert.assertNotSame(fooResult, fooBarResult);        Assert.assertEquals(fooResult.getResultPath(), "/foo");        Assert.assertEquals(fooBarResult.getResultPath(), "/foo/bar");    } finally {        CloseableUtils.closeQuietly(client);    }}
b7b29d9cf28ecb588341f2feb1c907b56e64cea34456ebbdcc0df93c660b0797
testBackground
public void testBackground() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        CuratorOp createOp1 = client.transactionOp().create().forPath("/foo");        CuratorOp createOp2 = client.transactionOp().create().forPath("/foo/bar", "snafu".getBytes());        final BlockingQueue<List<CuratorTransactionResult>> queue = Queues.newLinkedBlockingQueue();        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                queue.add(event.getOpResults());            }        };        client.transaction().inBackground(callback).forOperations(createOp1, createOp2);        Collection<CuratorTransactionResult> results = queue.poll(5, TimeUnit.SECONDS);        Assert.assertNotNull(results);        Assert.assertTrue(client.checkExists().forPath("/foo/bar") != null);        Assert.assertEquals(client.getData().forPath("/foo/bar"), "snafu".getBytes());        CuratorTransactionResult fooResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/foo"));        CuratorTransactionResult fooBarResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/foo/bar"));        Assert.assertNotNull(fooResult);        Assert.assertNotNull(fooBarResult);        Assert.assertNotSame(fooResult, fooBarResult);        Assert.assertEquals(fooResult.getResultPath(), "/foo");        Assert.assertEquals(fooBarResult.getResultPath(), "/foo/bar");    } finally {        CloseableUtils.closeQuietly(client);    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    queue.add(event.getOpResults());}
0b3090fd8c7e493945eee5dfd3baedb318cea1d6e5f83e68bca99c5c43dafb24
testBackgroundWithNamespace
public void testBackgroundWithNamespace() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace("galt").build();    try {        client.start();        CuratorOp createOp1 = client.transactionOp().create().forPath("/foo", "one".getBytes());        CuratorOp createOp2 = client.transactionOp().create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath("/test-", "one".getBytes());        CuratorOp setDataOp = client.transactionOp().setData().forPath("/foo", "two".getBytes());        CuratorOp createOp3 = client.transactionOp().create().forPath("/foo/bar");        CuratorOp deleteOp = client.transactionOp().delete().forPath("/foo/bar");        final BlockingQueue<List<CuratorTransactionResult>> queue = Queues.newLinkedBlockingQueue();        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                queue.add(event.getOpResults());            }        };        client.transaction().inBackground(callback).forOperations(createOp1, createOp2, setDataOp, createOp3, deleteOp);        Collection<CuratorTransactionResult> results = queue.poll(5, TimeUnit.SECONDS);        Assert.assertNotNull(results);        Assert.assertTrue(client.checkExists().forPath("/foo") != null);        Assert.assertTrue(client.usingNamespace(null).checkExists().forPath("/galt/foo") != null);        Assert.assertEquals(client.getData().forPath("/foo"), "two".getBytes());        Assert.assertTrue(client.checkExists().forPath("/foo/bar") == null);        CuratorTransactionResult ephemeralResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/test-"));        Assert.assertNotNull(ephemeralResult);        Assert.assertNotEquals(ephemeralResult.getResultPath(), "/test-");        Assert.assertTrue(ephemeralResult.getResultPath().startsWith("/test-"));    } finally {        CloseableUtils.closeQuietly(client);    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    queue.add(event.getOpResults());}
180e03a0f15ca907175c2687fe74c8cb477db8888fca9489ee6f847a8978bb21
testCheckVersion
public void testCheckVersion() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/foo");                Stat stat = client.setData().forPath("/foo", "new".getBytes());        try {            client.inTransaction().check().withVersion(stat.getVersion() + 1).forPath(            "/foo").and().create().forPath("/bar").and().commit();            Assert.fail();        } catch (KeeperException.BadVersionException correct) {                }        Assert.assertNull(client.checkExists().forPath("/bar"));    } finally {        CloseableUtils.closeQuietly(client);    }}
b7fe4c4498bd40571d4924cef6afaf6f3e4e688754f5b9e2a6c8bef2ea59ce9d
testWithNamespace
public void testWithNamespace() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace("galt").build();    try {        client.start();        Collection<CuratorTransactionResult> results = client.inTransaction().create().forPath("/foo", "one".getBytes()).and().create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath("/test-", "one".getBytes()).and().setData().forPath("/foo", "two".getBytes()).and().create().forPath("/foo/bar").and().delete().forPath("/foo/bar").and().commit();        Assert.assertTrue(client.checkExists().forPath("/foo") != null);        Assert.assertTrue(client.usingNamespace(null).checkExists().forPath("/galt/foo") != null);        Assert.assertEquals(client.getData().forPath("/foo"), "two".getBytes());        Assert.assertTrue(client.checkExists().forPath("/foo/bar") == null);        CuratorTransactionResult ephemeralResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/test-"));        Assert.assertNotNull(ephemeralResult);        Assert.assertNotEquals(ephemeralResult.getResultPath(), "/test-");        Assert.assertTrue(ephemeralResult.getResultPath().startsWith("/test-"));    } finally {        CloseableUtils.closeQuietly(client);    }}
9f25378b629301ecdcaef09cc7015efd09348718caf1f56aeef6e31bc3080615
testWithCompression
public void testWithCompression() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace("galt").build();    client.start();    try {        Collection<CuratorTransactionResult> results = client.inTransaction().create().compressed().forPath("/foo", "one".getBytes()).and().create().compressed().withACL(ZooDefs.Ids.READ_ACL_UNSAFE).forPath("/bar", "two".getBytes()).and().create().compressed().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath("/test-", "three".getBytes()).and().create().compressed().withMode(CreateMode.PERSISTENT).withACL(ZooDefs.Ids.READ_ACL_UNSAFE).forPath("/baz", "four".getBytes()).and().setData().compressed().withVersion(0).forPath("/foo", "five".getBytes()).and().commit();        Assert.assertTrue(client.checkExists().forPath("/foo") != null);        Assert.assertEquals(client.getData().decompressed().forPath("/foo"), "five".getBytes());        Assert.assertTrue(client.checkExists().forPath("/bar") != null);        Assert.assertEquals(client.getData().decompressed().forPath("/bar"), "two".getBytes());        Assert.assertEquals(client.getACL().forPath("/bar"), ZooDefs.Ids.READ_ACL_UNSAFE);        CuratorTransactionResult ephemeralResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/test-"));        Assert.assertNotNull(ephemeralResult);        Assert.assertNotEquals(ephemeralResult.getResultPath(), "/test-");        Assert.assertTrue(ephemeralResult.getResultPath().startsWith("/test-"));        Assert.assertTrue(client.checkExists().forPath("/baz") != null);        Assert.assertEquals(client.getData().decompressed().forPath("/baz"), "four".getBytes());        Assert.assertEquals(client.getACL().forPath("/baz"), ZooDefs.Ids.READ_ACL_UNSAFE);    } finally {        client.close();    }}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        Collection<CuratorTransactionResult> results = client.inTransaction().create().forPath("/foo").and().create().forPath("/foo/bar", "snafu".getBytes()).and().commit();        Assert.assertTrue(client.checkExists().forPath("/foo/bar") != null);        Assert.assertEquals(client.getData().forPath("/foo/bar"), "snafu".getBytes());        CuratorTransactionResult fooResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/foo"));        CuratorTransactionResult fooBarResult = Iterables.find(results, CuratorTransactionResult.ofTypeAndPath(OperationType.CREATE, "/foo/bar"));        Assert.assertNotNull(fooResult);        Assert.assertNotNull(fooBarResult);        Assert.assertNotSame(fooResult, fooBarResult);        Assert.assertEquals(fooResult.getResultPath(), "/foo");        Assert.assertEquals(fooBarResult.getResultPath(), "/foo/bar");    } finally {        CloseableUtils.closeQuietly(client);    }}
a80321659a99b352c8cc43cf7a4af27cfb9d2bc91b4f60096aee3b259fe65fe6
setUpClass
public static void setUpClass()
{    System.setProperty("zookeeper.extendedTypesEnabled", "true");}
27681e68ec2a1eb903f955680ebe003ceb3707295c8aad884b692d378c6e37cf
setup
public void setup() throws Exception
{    System.setProperty("znode.container.checkIntervalMs", "1");    super.setup();}
7c529460b940c419ef707bd1846a5575ea1bfc48c129127836c31f0184c1d8fb
teardown
public void teardown() throws Exception
{    super.teardown();    System.clearProperty("znode.container.checkIntervalMs");}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        client.create().withTtl(10).creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT_WITH_TTL).forPath("/a/b/c");        Thread.sleep(20);        Assert.assertNull(client.checkExists().forPath("/a/b/c"));    }}
6736c5e108667e9fe92bcee0e3568b7eb929125e05742ff4f55072915ceecc1a
testBasicInBackground
public void testBasicInBackground() throws Exception
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                latch.countDown();            }        };        client.create().withTtl(10).creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT_WITH_TTL).inBackground(callback).forPath("/a/b/c");        Assert.assertTrue(new Timing().awaitLatch(latch));        Thread.sleep(20);        Assert.assertNull(client.checkExists().forPath("/a/b/c"));    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
a4803fca4797306b4f772a40c997680043dc08b35469407056bd5b28cf26096b
process
public void process(WatchedEvent event) throws Exception
{    count.incrementAndGet();}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    count.incrementAndGet();}
e027492e6f8cfec32096647120b13c63efba28a55a2fb5b8cf7e8b13c5805b96
testSameWatcherPerZKDocs
public void testSameWatcherPerZKDocs() throws Exception
{    CountZKWatcher actualWatcher = new CountZKWatcher();    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/test");                client.checkExists().usingWatcher(actualWatcher).forPath("/test");        client.getData().usingWatcher(actualWatcher).forPath("/test");        client.setData().forPath("/test", "foo".getBytes());        client.delete().forPath("/test");        timing.sleepABit();        Assert.assertEquals(actualWatcher.count.getAndSet(0), 1);        client.create().forPath("/test");        client.checkExists().usingWatcher(actualWatcher).forPath("/test");        client.delete().forPath("/test");        timing.sleepABit();        Assert.assertEquals(actualWatcher.count.get(), 1);    } finally {        CloseableUtils.closeQuietly(client);    }}
777f9ecc2d75f74bf648d249dd130f37e34eede6ca0df942d238bab279173176
testSameCuratorWatcherPerZKDocs
public void testSameCuratorWatcherPerZKDocs() throws Exception
{    CountCuratorWatcher actualWatcher = new CountCuratorWatcher();    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/test");                client.checkExists().usingWatcher(actualWatcher).forPath("/test");        client.getData().usingWatcher(actualWatcher).forPath("/test");        client.setData().forPath("/test", "foo".getBytes());        client.delete().forPath("/test");        timing.sleepABit();        Assert.assertEquals(actualWatcher.count.getAndSet(0), 1);        client.create().forPath("/test");        client.checkExists().usingWatcher(actualWatcher).forPath("/test");        client.delete().forPath("/test");        timing.sleepABit();        Assert.assertEquals(actualWatcher.count.get(), 1);    } finally {        CloseableUtils.closeQuietly(client);    }}
09901c7b9fd54db00378ec97ebb21e433b7b1f225b53ef765aec37586a0ce6e7
testSetAddition
public void testSetAddition()
{    Watcher watcher = new Watcher() {        @Override        public void process(WatchedEvent event) {        }    };    NamespaceWatcher namespaceWatcher1 = new NamespaceWatcher(null, watcher, "/foo");    NamespaceWatcher namespaceWatcher2 = new NamespaceWatcher(null, watcher, "/foo");    Assert.assertEquals(namespaceWatcher1, namespaceWatcher2);    Assert.assertFalse(namespaceWatcher1.equals(watcher));    Assert.assertFalse(watcher.equals(namespaceWatcher1));    Set<Watcher> set = Sets.newHashSet();    set.add(namespaceWatcher1);    set.add(namespaceWatcher2);    Assert.assertEquals(set.size(), 1);}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{}
d9f9897fbc129102ad047be5bbbdd709b9b7f485fa8d5b30e9215de37b0b3bb6
testCuratorWatcher
public void testCuratorWatcher() throws Exception
{    Timing timing = new Timing();    CountCuratorWatcher watcher = new CountCuratorWatcher();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().forPath(PATH);                client.getData().usingWatcher(watcher).forPath(PATH);        client.getData().usingWatcher(watcher).forPath(PATH);                client.setData().forPath(PATH, new byte[] {});        timing.sleepABit();        Assert.assertEquals(1, watcher.count.get());    } finally {        CloseableUtils.closeQuietly(client);    }}
16da4ababb918d7b1ad37b8491dd6c1d0753b431d70d8b2ccf5392471df30658
testZKWatcher
public void testZKWatcher() throws Exception
{    Timing timing = new Timing();    CountZKWatcher watcher = new CountZKWatcher();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().forPath(PATH);                client.getData().usingWatcher(watcher).forPath(PATH);        client.getData().usingWatcher(watcher).forPath(PATH);                client.setData().forPath(PATH, new byte[] {});        timing.sleepABit();        Assert.assertEquals(1, watcher.count.get());    } finally {        CloseableUtils.closeQuietly(client);    }}
99c8c5670120cfde85ceb8d821637470a01c33f197368da96aa8c0369674b094
testSameWatcherDifferentPaths1Triggered
public void testSameWatcherDifferentPaths1Triggered() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        final CountDownLatch latch = new CountDownLatch(1);        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                latch.countDown();            }        };        removerClient.checkExists().usingWatcher(watcher).forPath("/a/b/c");        removerClient.checkExists().usingWatcher(watcher).forPath("/d/e/f");        removerClient.create().creatingParentsIfNeeded().forPath("/d/e/f");        Timing timing = new Timing();        Assert.assertTrue(timing.awaitLatch(latch));        timing.sleepABit();        removerClient.removeWatchers();    } finally {        TestCleanState.closeAndTestClean(client);    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    latch.countDown();}
29ed623097783d0a82e28564fb740245c86bdba217d70fbe30f012763a614a03
testSameWatcherDifferentPaths
public void testSameWatcherDifferentPaths() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                        }        };        removerClient.checkExists().usingWatcher(watcher).forPath("/a/b/c");        removerClient.checkExists().usingWatcher(watcher).forPath("/d/e/f");        Assert.assertEquals(removerClient.getWatcherRemovalManager().getEntries().size(), 2);        removerClient.removeWatchers();    } finally {        TestCleanState.closeAndTestClean(client);    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{}
98d2328ffa936f32a708c09f87cafba2acea957d388424eebca380730e4ac4d5
testSameWatcherDifferentKinds1Triggered
public void testSameWatcherDifferentKinds1Triggered() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        final CountDownLatch latch = new CountDownLatch(1);        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                latch.countDown();            }        };        removerClient.create().creatingParentsIfNeeded().forPath("/a/b/c");        removerClient.checkExists().usingWatcher(watcher).forPath("/a/b/c");        removerClient.getData().usingWatcher(watcher).forPath("/a/b/c");        removerClient.setData().forPath("/a/b/c", "new".getBytes());        Timing timing = new Timing();        Assert.assertTrue(timing.awaitLatch(latch));        timing.sleepABit();        removerClient.removeWatchers();    } finally {        TestCleanState.closeAndTestClean(client);    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    latch.countDown();}
11eaf18abb7c7b1978157deaa35c6ad47600ce8a49d2f59009ae952ba5907941
testSameWatcherDifferentKinds
public void testSameWatcherDifferentKinds() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                        }        };        removerClient.create().creatingParentsIfNeeded().forPath("/a/b/c");        removerClient.checkExists().usingWatcher(watcher).forPath("/a/b/c");        removerClient.getData().usingWatcher(watcher).forPath("/a/b/c");        removerClient.removeWatchers();    } finally {        TestCleanState.closeAndTestClean(client);    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{}
94e6622bdcaa7a3357c261ec363504e07a5488222c0e855f8e5775ee0d0fe548
testWithRetry
public void testWithRetry() throws Exception
{    server.stop();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        Watcher w = new Watcher() {            @Override            public void process(WatchedEvent event) {                        }        };        try {            removerClient.checkExists().usingWatcher(w).forPath("/one/two/three");            Assert.fail("Should have thrown ConnectionLossException");        } catch (KeeperException.ConnectionLossException expected) {                }        Assert.assertEquals(removerClient.getWatcherRemovalManager().getEntries().size(), 0);    } finally {        TestCleanState.closeAndTestClean(client);    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{}
f0d1cde49c11f037cc80f1174dde0c9f6fef693e5eebf94f5d167bee1a9d4737
testWithRetryInBackground
public void testWithRetryInBackground() throws Exception
{    server.stop();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        Watcher w = new Watcher() {            @Override            public void process(WatchedEvent event) {                        }        };        final CountDownLatch latch = new CountDownLatch(1);        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                latch.countDown();            }        };        removerClient.checkExists().usingWatcher(w).inBackground(callback).forPath("/one/two/three");        Assert.assertTrue(new Timing().awaitLatch(latch));        Assert.assertEquals(removerClient.getWatcherRemovalManager().getEntries().size(), 0);    } finally {        TestCleanState.closeAndTestClean(client);    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
d4f8218a8b5f5eeb2f061b36c7555c06d6a42416a4e7b568f093a505d250e43e
testMissingNode
public void testMissingNode() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        Watcher w = new Watcher() {            @Override            public void process(WatchedEvent event) {                        }        };        try {            removerClient.getData().usingWatcher(w).forPath("/one/two/three");            Assert.fail("Should have thrown NoNodeException");        } catch (KeeperException.NoNodeException expected) {                }        removerClient.removeWatchers();    } finally {        TestCleanState.closeAndTestClean(client);    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{}
a749047d37e79570bee08bd0e80452321c981fdd518078d73b052942a945ffb1
testMissingNodeInBackground
public void testMissingNodeInBackground() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    Callable<Void> proc = new Callable<Void>() {        @Override        public Void call() throws Exception {            client.start();            WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();            Watcher w = new Watcher() {                @Override                public void process(WatchedEvent event) {                                }            };            final CountDownLatch latch = new CountDownLatch(1);            BackgroundCallback callback = new BackgroundCallback() {                @Override                public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                    latch.countDown();                }            };            removerClient.getData().usingWatcher(w).inBackground(callback).forPath("/one/two/three");            Assert.assertTrue(new Timing().awaitLatch(latch));            Assert.assertEquals(removerClient.getWatcherRemovalManager().getEntries().size(), 0);            removerClient.removeWatchers();            return null;        }    };    TestCleanState.test(client, proc);}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    client.start();    WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();    Watcher w = new Watcher() {        @Override        public void process(WatchedEvent event) {                }    };    final CountDownLatch latch = new CountDownLatch(1);    BackgroundCallback callback = new BackgroundCallback() {        @Override        public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {            latch.countDown();        }    };    removerClient.getData().usingWatcher(w).inBackground(callback).forPath("/one/two/three");    Assert.assertTrue(new Timing().awaitLatch(latch));    Assert.assertEquals(removerClient.getWatcherRemovalManager().getEntries().size(), 0);    removerClient.removeWatchers();    return null;}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    latch.countDown();}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        internalTryBasic(client);    } finally {        TestCleanState.closeAndTestClean(client);    }}
80362221c96fa083226e98652b8a13c162bb31f971179a733794dbc46be1964e
testBasicNamespace1
public void testBasicNamespace1() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        internalTryBasic(client.usingNamespace("foo"));    } finally {        TestCleanState.closeAndTestClean(client);    }}
ea366b47a8f12b0844a812a63c604956676d6bb4c76fb6ecb8c4d7e5a6507552
testBasicNamespace2
public void testBasicNamespace2() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace("hey").build();    try {        client.start();        internalTryBasic(client);    } finally {        TestCleanState.closeAndTestClean(client);    }}
fcdb674fc132d283cef9a3096607344fbbe42e313025402a8b41cda8aaa5ad50
testBasicNamespace3
public void testBasicNamespace3() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).namespace("hey").build();    try {        client.start();        internalTryBasic(client.usingNamespace("lakjsf"));    } finally {        TestCleanState.closeAndTestClean(client);    }}
ddc57455b40e5426623ecb44a87da7e9f038e7ccd1ad8e4ca98787a8e7a54c87
testSameWatcher
public void testSameWatcher() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/test");        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                        }        };        removerClient.getData().usingWatcher(watcher).forPath("/test");        Assert.assertEquals(removerClient.getRemovalManager().getEntries().size(), 1);        removerClient.getData().usingWatcher(watcher).forPath("/test");        Assert.assertEquals(removerClient.getRemovalManager().getEntries().size(), 1);        removerClient.removeWatchers();    } finally {        TestCleanState.closeAndTestClean(client);    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{}
bbe18afcf87597260ccce2691986f02be754de4455e09c9dbb9cb673eb479990
testTriggered
public void testTriggered() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        final CountDownLatch latch = new CountDownLatch(1);        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                if (event.getType() == Event.EventType.NodeCreated) {                    latch.countDown();                }            }        };        removerClient.checkExists().usingWatcher(watcher).forPath("/yo");        Assert.assertEquals(removerClient.getRemovalManager().getEntries().size(), 1);        removerClient.create().forPath("/yo");        Assert.assertTrue(new Timing().awaitLatch(latch));        Assert.assertEquals(removerClient.getRemovalManager().getEntries().size(), 0);    } finally {        TestCleanState.closeAndTestClean(client);    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (event.getType() == Event.EventType.NodeCreated) {        latch.countDown();    }}
c6e60f3f0153f84f5b35fd3fd6aef6bd7e7777782875ac42b67c87d18d197277
testResetFromWatcher
public void testResetFromWatcher() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final WatcherRemovalFacade removerClient = (WatcherRemovalFacade) client.newWatcherRemoveCuratorFramework();        final CountDownLatch createdLatch = new CountDownLatch(1);        final CountDownLatch deletedLatch = new CountDownLatch(1);        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                if (event.getType() == Event.EventType.NodeCreated) {                    try {                        removerClient.checkExists().usingWatcher(this).forPath("/yo");                    } catch (Exception e) {                        e.printStackTrace();                    }                    createdLatch.countDown();                } else if (event.getType() == Event.EventType.NodeDeleted) {                    deletedLatch.countDown();                }            }        };        removerClient.checkExists().usingWatcher(watcher).forPath("/yo");        Assert.assertEquals(removerClient.getRemovalManager().getEntries().size(), 1);        removerClient.create().forPath("/yo");        Assert.assertTrue(timing.awaitLatch(createdLatch));        Assert.assertEquals(removerClient.getRemovalManager().getEntries().size(), 1);        removerClient.delete().forPath("/yo");        Assert.assertTrue(timing.awaitLatch(deletedLatch));        Assert.assertEquals(removerClient.getRemovalManager().getEntries().size(), 0);    } finally {        TestCleanState.closeAndTestClean(client);    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (event.getType() == Event.EventType.NodeCreated) {        try {            removerClient.checkExists().usingWatcher(this).forPath("/yo");        } catch (Exception e) {            e.printStackTrace();        }        createdLatch.countDown();    } else if (event.getType() == Event.EventType.NodeDeleted) {        deletedLatch.countDown();    }}
81c111f87a1366a17c34fb17c5a31b0cef40f29b8807a99be3feffe5588e6ea7
internalTryBasic
private void internalTryBasic(CuratorFramework client) throws Exception
{    WatcherRemoveCuratorFramework removerClient = client.newWatcherRemoveCuratorFramework();    final CountDownLatch latch = new CountDownLatch(1);    Watcher watcher = new Watcher() {        @Override        public void process(WatchedEvent event) {            if (event.getType() == Event.EventType.DataWatchRemoved) {                latch.countDown();            }        }    };    removerClient.checkExists().usingWatcher(watcher).forPath("/hey");    List<String> existWatches = WatchersDebug.getExistWatches(client.getZookeeperClient().getZooKeeper());    Assert.assertEquals(existWatches.size(), 1);    removerClient.removeWatchers();    Assert.assertTrue(new Timing().awaitLatch(latch));    existWatches = WatchersDebug.getExistWatches(client.getZookeeperClient().getZooKeeper());    Assert.assertEquals(existWatches.size(), 0);}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (event.getType() == Event.EventType.DataWatchRemoved) {        latch.countDown();    }}
25748df5b9257c58d1787a8f1cf073f55e17363c89ce0f8aec98b1398e18189c
testSessionSurvives
public void testSessionSurvives() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = null;    TestingCluster cluster = new TestingCluster(3);    cluster.start();    try {        client = CuratorFrameworkFactory.newClient(cluster.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));        client.start();        final CountDownLatch reconnectedLatch = new CountDownLatch(1);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.RECONNECTED) {                    reconnectedLatch.countDown();                    ;                }            }        };        client.getConnectionStateListenable().addListener(listener);        client.create().withMode(CreateMode.EPHEMERAL).forPath("/temp", "value".getBytes());        Assert.assertNotNull(client.checkExists().forPath("/temp"));        for (InstanceSpec spec : cluster.getInstances()) {            cluster.killServer(spec);            timing.sleepABit();            cluster.restartServer(spec);            timing.sleepABit();        }        Assert.assertTrue(timing.awaitLatch(reconnectedLatch));        Assert.assertNotNull(client.checkExists().forPath("/temp"));    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(cluster);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.RECONNECTED) {        reconnectedLatch.countDown();        ;    }}
6335bb78cd17a2ba510ae800135657c76c2a34f2d401647084b8e90041de2f5c
testSplitBrain
public void testSplitBrain() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = null;    TestingCluster cluster = new TestingCluster(3);    cluster.start();    try {                for (InstanceSpec instanceSpec : cluster.getInstances()) {            client = CuratorFrameworkFactory.newClient(instanceSpec.getConnectString(), new RetryOneTime(1));            client.start();            client.checkExists().forPath("/");            client.close();            client = null;        }        client = CuratorFrameworkFactory.newClient(cluster.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        final CountDownLatch latch = new CountDownLatch(2);        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if ((newState == ConnectionState.SUSPENDED) || (newState == ConnectionState.LOST)) {                    latch.countDown();                }            }        });        client.checkExists().forPath("/");        for (InstanceSpec instanceSpec : cluster.getInstances()) {            if (!instanceSpec.equals(cluster.findConnectionInstance(client.getZookeeperClient().getZooKeeper()))) {                Assert.assertTrue(cluster.killServer(instanceSpec));            }        }        Assert.assertTrue(timing.awaitLatch(latch));    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(cluster);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if ((newState == ConnectionState.SUSPENDED) || (newState == ConnectionState.LOST)) {        latch.countDown();    }}
c7a00a749ec37d419bb105a770af2763d5fcf8d56782795615b23e4402333b9b
testBasics
public void testBasics() throws Exception
{    SchemaSet schemaSet = loadSchemaSet("schema1.json", null);    Schema schema = schemaSet.getNamedSchema("test");    Assert.assertNotNull(schema);    Map<String, String> expectedMetadata = Maps.newHashMap();    expectedMetadata.put("one", "1");    expectedMetadata.put("two", "2");    Assert.assertEquals(schema.getMetadata(), expectedMetadata);    CuratorFramework client = newClient(schemaSet);    try {        client.start();        try {            String rawPath = schema.getRawPath();            Assert.assertEquals(rawPath, "/a/b/c");            client.create().creatingParentsIfNeeded().forPath(rawPath);            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }        client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath("/a/b/c");    } finally {        CloseableUtils.closeQuietly(client);    }}
1fb0cb88c1dbe7787990e623448976368384ef21b97fb8f4311f527e2b9afbce
testSchemaValidator
public void testSchemaValidator() throws Exception
{    final SchemaValidator schemaValidator = new SchemaValidator() {        @Override        public boolean isValid(Schema schema, String path, byte[] data, List<ACL> acl) {            return data.length > 0;        }    };    SchemaSetLoader.SchemaValidatorMapper schemaValidatorMapper = new SchemaSetLoader.SchemaValidatorMapper() {        @Override        public SchemaValidator getSchemaValidator(String name) {            return schemaValidator;        }    };    SchemaSet schemaSet = loadSchemaSet("schema3.json", schemaValidatorMapper);    CuratorFramework client = newClient(schemaSet);    try {        client.start();        try {            client.create().forPath("/test", new byte[0]);            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }        client.create().forPath("/test", "good".getBytes());    } finally {        CloseableUtils.closeQuietly(client);    }}
4dd27bc0255a4567b42d9dab830ee2af76cde5f11beb92791531b3ae8d93b00f
isValid
public boolean isValid(Schema schema, String path, byte[] data, List<ACL> acl)
{    return data.length > 0;}
160e5f880c35728b9973d37dfa9967b42676855cabb3572a107cba81b0aa36a4
getSchemaValidator
public SchemaValidator getSchemaValidator(String name)
{    return schemaValidator;}
88eb518cdeb089aca428f017b47a175a0194c174298672b1b20db431dfb7b0bb
testMulti
public void testMulti() throws Exception
{    SchemaSet schemaSet = loadSchemaSet("schema2.json", null);    CuratorFramework client = newClient(schemaSet);    try {        client.start();        try {            client.create().creatingParentsIfNeeded().forPath("/a/b/c");            Assert.fail("Should've violated schema: test");        } catch (SchemaViolation dummy) {                }        try {            client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath("/a/b/c/d/e");            Assert.fail("Should've violated schema: test2");        } catch (SchemaViolation dummy) {                }    } finally {        CloseableUtils.closeQuietly(client);    }}
7eebeba2755c4394d5d8415a42b017267155efc24aa0e5eec14286223b68fe82
testTransaction
public void testTransaction() throws Exception
{    final SchemaValidator schemaValidator = new SchemaValidator() {        @Override        public boolean isValid(Schema schema, String path, byte[] data, List<ACL> acl) {            return data.length > 0;        }    };    SchemaSetLoader.SchemaValidatorMapper schemaValidatorMapper = new SchemaSetLoader.SchemaValidatorMapper() {        @Override        public SchemaValidator getSchemaValidator(String name) {            return schemaValidator;        }    };    SchemaSet schemaSet = loadSchemaSet("schema4.json", schemaValidatorMapper);    CuratorFramework client = newClient(schemaSet);    try {        client.start();        CuratorOp createAPersistent = client.transactionOp().create().forPath("/a");        CuratorOp createAEphemeral = client.transactionOp().create().withMode(CreateMode.EPHEMERAL).forPath("/a");        CuratorOp deleteA = client.transactionOp().delete().forPath("/a");        CuratorOp createBEmptyData = client.transactionOp().create().forPath("/b", new byte[0]);        CuratorOp createBWithData = client.transactionOp().create().forPath("/b", new byte[10]);        CuratorOp setBEmptyData = client.transactionOp().setData().forPath("/b", new byte[0]);        CuratorOp setBWithData = client.transactionOp().setData().forPath("/b", new byte[10]);        try {            client.transaction().forOperations(createAPersistent, createAEphemeral);            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }        client.transaction().forOperations(createAEphemeral);        try {            client.transaction().forOperations(deleteA);            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }        try {            client.transaction().forOperations(createBEmptyData);            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }        client.transaction().forOperations(createBWithData);        try {            client.transaction().forOperations(setBEmptyData);            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }        client.transaction().forOperations(setBWithData);    } finally {        CloseableUtils.closeQuietly(client);    }}
4dd27bc0255a4567b42d9dab830ee2af76cde5f11beb92791531b3ae8d93b00f
isValid
public boolean isValid(Schema schema, String path, byte[] data, List<ACL> acl)
{    return data.length > 0;}
160e5f880c35728b9973d37dfa9967b42676855cabb3572a107cba81b0aa36a4
getSchemaValidator
public SchemaValidator getSchemaValidator(String name)
{    return schemaValidator;}
c4ec738a5fff8700e399a58231320df1882f663a9d40e0915d8fd23539dda43e
testYaml
public void testYaml() throws Exception
{    String yaml = Resources.toString(Resources.getResource("schema.yaml"), Charsets.UTF_8);    JsonNode root = new ObjectMapper(new YAMLFactory()).readTree(yaml);    List<Schema> schemas = new SchemaSetLoader(root, null).getSchemas();    Assert.assertEquals(schemas.size(), 2);    Assert.assertEquals(schemas.get(0).getName(), "test");    Assert.assertEquals(schemas.get(0).getMetadata().size(), 0);    Assert.assertEquals(schemas.get(1).getName(), "test2");    Assert.assertEquals(schemas.get(1).getMetadata().size(), 2);    Assert.assertEquals(schemas.get(1).getMetadata().get("two"), "2");}
e941e25a4bc02316d68ee14d64643dbc013e40979189114e45f6474bef7a9ec2
testOrdering
public void testOrdering() throws Exception
{    SchemaSet schemaSet = loadSchemaSet("schema5.json", null);    CuratorFramework client = newClient(schemaSet);    try {        client.start();        try {            client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath("/exact/match");            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }        try {            client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath("/exact/foo/bar");            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }        try {            client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath("/exact/other/bar");            Assert.fail("Should've violated schema");        } catch (SchemaViolation dummy) {                }                client.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath("/exact/match");                client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath("/exact/other/thing");                client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath("/exact/foo/bar");    } finally {        CloseableUtils.closeQuietly(client);    }}
89b780c8a8ef04d410c0f88db826eafe2f9c2fa30143d9f9f719ba5dd094199b
newClient
private CuratorFramework newClient(SchemaSet schemaSet)
{    return CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).schemaSet(schemaSet).build();}
2a17e807dbaad4d1adf5f69970417cd85767f10e42e41fd9db2531425e51a726
loadSchemaSet
private SchemaSet loadSchemaSet(String name, SchemaSetLoader.SchemaValidatorMapper schemaValidatorMapper) throws IOException
{    String json = Resources.toString(Resources.getResource(name), Charsets.UTF_8);    return new SchemaSetLoader(json, schemaValidatorMapper).toSchemaSet(true);}
57b289a5d111e9bda38f82dbb648744ebe61c1afb53cb8324058da81208921f1
schedule
public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit)
{    lastDelay[0] = Duration.of(unit.toNanos(delay), ChronoUnit.NANOS);    command.run();    return null;}
39e5ba029cc67f6f1d45c6d20f0df595ec16bc61da20d7680fcbbdae4fe7f95b
tearDown
public void tearDown()
{    service.shutdownNow();}
0e0411efe5e7868378f7f03580d84579275f5762c392b06dea78c574fd2c1d57
testBasic
public void testBasic()
{    final int retryQty = 1;    final Duration delay = Duration.ofSeconds(10);    CircuitBreaker circuitBreaker = CircuitBreaker.build(new RetryNTimes(retryQty, (int) delay.toMillis()), service);    AtomicInteger counter = new AtomicInteger(0);    Assert.assertTrue(circuitBreaker.tryToOpen(counter::incrementAndGet));    Assert.assertEquals(lastDelay[0], delay);    Assert.assertFalse(circuitBreaker.tryToOpen(counter::incrementAndGet));    Assert.assertEquals(circuitBreaker.getRetryCount(), 1);    Assert.assertEquals(counter.get(), 1);    Assert.assertFalse(circuitBreaker.tryToRetry(counter::incrementAndGet));    Assert.assertEquals(circuitBreaker.getRetryCount(), 1);    Assert.assertEquals(counter.get(), 1);    Assert.assertTrue(circuitBreaker.close());    Assert.assertEquals(circuitBreaker.getRetryCount(), 0);    Assert.assertFalse(circuitBreaker.close());}
6deee60f29d2000cc02d302c2c358b60c85f091deeab22418bdc15e7e4538759
testVariousOpenRetryFails
public void testVariousOpenRetryFails()
{    CircuitBreaker circuitBreaker = CircuitBreaker.build(new RetryForever(1), service);    Assert.assertFalse(circuitBreaker.tryToRetry(() -> {    }));    Assert.assertTrue(circuitBreaker.tryToOpen(() -> {    }));    Assert.assertFalse(circuitBreaker.tryToOpen(() -> {    }));    Assert.assertTrue(circuitBreaker.close());    Assert.assertFalse(circuitBreaker.close());}
89ff4c0a36cbd2136631a96755ecee9f96d4772d26ec297ffb7889482db042b9
testWithRetryUntilElapsed
public void testWithRetryUntilElapsed()
{    RetryPolicy retryPolicy = new RetryUntilElapsed(10000, 10000);    CircuitBreaker circuitBreaker = CircuitBreaker.build(retryPolicy, service);    Assert.assertTrue(circuitBreaker.tryToOpen(() -> {    }));    Assert.assertEquals(lastDelay[0], Duration.ofMillis(10000));}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    stateChanges.offer(newState);}
4c63ebeaaff7bb355ad5a04b35052b1142def4893beee8762659de3e7ad378f5
allowRetry
public boolean allowRetry(int retryCount, long elapsedTimeMs, RetrySleeper sleeper)
{    return isRetrying && super.allowRetry(retryCount, elapsedTimeMs, sleeper);}
5ff0b8f7d2b080bcc6214fa5f91be74727145ea81cacb63a99c8d0f3106c089f
setup
public void setup()
{    service = new ScheduledThreadPoolExecutor(1);}
39e5ba029cc67f6f1d45c6d20f0df595ec16bc61da20d7680fcbbdae4fe7f95b
tearDown
public void tearDown()
{    service.shutdownNow();}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    RecordingListener recordingListener = new RecordingListener();    TestRetryPolicy retryPolicy = new TestRetryPolicy();    CircuitBreakingConnectionStateListener listener = new CircuitBreakingConnectionStateListener(dummyClient, recordingListener, retryPolicy, service);    listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.RECONNECTED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.SUSPENDED);        listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    Assert.assertTrue(recordingListener.stateChanges.isEmpty());    listener.stateChanged(dummyClient, ConnectionState.LOST);    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.LOST);    synchronized (    listener) {                listener.stateChanged(dummyClient, ConnectionState.READ_ONLY);                listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);                listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);                listener.stateChanged(dummyClient, ConnectionState.LOST);                listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    }    retryTiming.multiple(2).sleep();    Assert.assertTrue(recordingListener.stateChanges.isEmpty());        retryPolicy.isRetrying = false;    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.SUSPENDED);}
c4411143227c2af7450aba648357145bea0d454790fd9b3a5e7f97b3d1a653f8
testResetsAfterReconnect
public void testResetsAfterReconnect() throws Exception
{    RecordingListener recordingListener = new RecordingListener();    TestRetryPolicy retryPolicy = new TestRetryPolicy();    CircuitBreakingConnectionStateListener listener = new CircuitBreakingConnectionStateListener(dummyClient, recordingListener, retryPolicy, service);    synchronized (    listener) {        listener.stateChanged(dummyClient, ConnectionState.LOST);                listener.stateChanged(dummyClient, ConnectionState.LOST);    }    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.LOST);    Assert.assertTrue(recordingListener.stateChanges.isEmpty());        listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.RECONNECTED);}
88eecb9c0b7f430112be89bb5ba79fab09aa07b47ebe9f7e8f98bed008ce9e75
testRetryNever
public void testRetryNever() throws Exception
{    RecordingListener recordingListener = new RecordingListener();    RetryPolicy retryNever = (retryCount, elapsedTimeMs, sleeper) -> false;    CircuitBreakingConnectionStateListener listener = new CircuitBreakingConnectionStateListener(dummyClient, recordingListener, retryNever, service);    listener.stateChanged(dummyClient, ConnectionState.LOST);    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.LOST);    Assert.assertFalse(listener.isOpen());    listener.stateChanged(dummyClient, ConnectionState.LOST);    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.LOST);    Assert.assertFalse(listener.isOpen());}
d9ef04aa2e9ca3ca298c8fa1c46034ba8951eeb52bd65a62cc2fb005ca326865
testRetryOnce
public void testRetryOnce() throws Exception
{    RecordingListener recordingListener = new RecordingListener();    RetryPolicy retryOnce = new RetryOneTime(retryTiming.milliseconds());    CircuitBreakingConnectionStateListener listener = new CircuitBreakingConnectionStateListener(dummyClient, recordingListener, retryOnce, service);    synchronized (    listener) {        listener.stateChanged(dummyClient, ConnectionState.LOST);        listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);        Assert.assertTrue(listener.isOpen());    }    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.LOST);    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.SUSPENDED);    Assert.assertFalse(listener.isOpen());}
5ea06977ccde3f98f6e9134a6ca23029725bf203843fad5d2b57470d223a1935
testSuspendedToLostRatcheting
public void testSuspendedToLostRatcheting() throws Exception
{    RecordingListener recordingListener = new RecordingListener();    RetryPolicy retryInfinite = new RetryForever(Integer.MAX_VALUE);    CircuitBreakingConnectionStateListener listener = new CircuitBreakingConnectionStateListener(dummyClient, recordingListener, retryInfinite, service);    listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    Assert.assertFalse(listener.isOpen());    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.RECONNECTED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    Assert.assertTrue(listener.isOpen());    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    listener.stateChanged(dummyClient, ConnectionState.READ_ONLY);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    listener.stateChanged(dummyClient, ConnectionState.READ_ONLY);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    Assert.assertTrue(recordingListener.stateChanges.isEmpty());    Assert.assertTrue(listener.isOpen());    listener.stateChanged(dummyClient, ConnectionState.LOST);    Assert.assertEquals(timing.takeFromQueue(recordingListener.stateChanges), ConnectionState.LOST);    Assert.assertTrue(listener.isOpen());    listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    listener.stateChanged(dummyClient, ConnectionState.READ_ONLY);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    listener.stateChanged(dummyClient, ConnectionState.READ_ONLY);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    Assert.assertTrue(recordingListener.stateChanges.isEmpty());    Assert.assertTrue(listener.isOpen());    listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    listener.stateChanged(dummyClient, ConnectionState.READ_ONLY);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.LOST);    listener.stateChanged(dummyClient, ConnectionState.LOST);    listener.stateChanged(dummyClient, ConnectionState.LOST);    listener.stateChanged(dummyClient, ConnectionState.RECONNECTED);    listener.stateChanged(dummyClient, ConnectionState.READ_ONLY);    listener.stateChanged(dummyClient, ConnectionState.LOST);    listener.stateChanged(dummyClient, ConnectionState.SUSPENDED);    listener.stateChanged(dummyClient, ConnectionState.LOST);    Assert.assertTrue(recordingListener.stateChanges.isEmpty());    Assert.assertTrue(listener.isOpen());}
99faeaaf551b03a876eadc76f0731f499ba23ed68e5f138d15c428814444d0da
testSessionConnectionStateErrorPolicyWithExpirationPercent30
public void testSessionConnectionStateErrorPolicyWithExpirationPercent30() throws Exception
{    Timing2 timing = new Timing2();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).connectionTimeoutMs(1000).sessionTimeoutMs(timing.session()).retryPolicy(new RetryOneTime(1)).connectionStateErrorPolicy(new SessionConnectionStateErrorPolicy()).connectionHandlingPolicy(new StandardConnectionHandlingPolicy(30)).build();        final int lostStateExpectedMs = (timing.session() / 3) + timing.forSleepingABit().milliseconds();    try {        CountDownLatch connectedLatch = new CountDownLatch(1);        CountDownLatch lostLatch = new CountDownLatch(1);        ConnectionStateListener stateListener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.CONNECTED) {                    connectedLatch.countDown();                }                if (newState == ConnectionState.LOST) {                    lostLatch.countDown();                }            }        };        timing.sleepABit();        client.getConnectionStateListenable().addListener(stateListener);        client.start();        Assert.assertTrue(timing.awaitLatch(connectedLatch));        server.close();        Assert.assertTrue(lostLatch.await(lostStateExpectedMs, TimeUnit.MILLISECONDS));    } finally {        CloseableUtils.closeQuietly(client);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    }    if (newState == ConnectionState.LOST) {        lostLatch.countDown();    }}
7604c8a1b88705716ed952119d6fb6aba82049609c8443a37de8718464b3c174
execute
public static Future<?> execute(final CuratorFramework client, final Runnable runAfterConnection) throws Exception
{        final ExecutorService executor = ThreadUtils.newSingleThreadExecutor(ThreadUtils.getProcessName(runAfterConnection.getClass()));    Runnable internalCall = new Runnable() {        @Override        public void run() {            try {                client.blockUntilConnected();                runAfterConnection.run();            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                log.error("An error occurred blocking until a connection is available", e);            } finally {                executor.shutdown();            }        }    };    return executor.submit(internalCall);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        client.blockUntilConnected();        runAfterConnection.run();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        log.error("An error occurred blocking until a connection is available", e);    } finally {        executor.shutdown();    }}
4c014d3848aab13a249b08c5fe2251d006bda3ff725881a96706c12ef64cbc54
getOptimisticTries
public int getOptimisticTries()
{    return optimisticTries;}
70a0d2d125e89d6e3085c5ac04f26b4cf284c0442a2aec3df7d4ee84847d78cb
getPromotedLockTries
public int getPromotedLockTries()
{    return promotedLockTries;}
35216206e0994629fcc2cb19d9fe5f2e6e9a30fcc6a31a00fb62df5bfa8d30f1
getOptimisticTimeMs
public long getOptimisticTimeMs()
{    return optimisticTimeMs;}
cd13d98481bd5b6931454b00594d15e7009801febb0297546b86e57da6eaec68
getPromotedTimeMs
public long getPromotedTimeMs()
{    return promotedTimeMs;}
f1aad5b1659fed200dfb5c5badd799f39b5442db4f5beb319128b9ce45bdb02c
incrementOptimisticTries
 void incrementOptimisticTries()
{    ++optimisticTries;}
3fd1f8c7a79bdfe075b12e54d405c909af480dfa57dd523e52e0d32d6a05a991
incrementPromotedTries
 void incrementPromotedTries()
{    ++promotedLockTries;}
1d455ddf661f1ff480fac418c4c1c1a36c5cb68dfeb5f6489b36733df60b4a62
setOptimisticTimeMs
 void setOptimisticTimeMs(long optimisticTimeMs)
{    this.optimisticTimeMs = optimisticTimeMs;}
3bb511add4aa79d13d6b3b9f6ca3c8f754c728f807cbfd29993151f712525774
setPromotedTimeMs
 void setPromotedTimeMs(long promotedTimeMs)
{    this.promotedTimeMs = promotedTimeMs;}
f89352a6bccde69dffc41953d5d605cd5993da815c145d0db03717e9addecb06
next
public AtomicValue<Integer> next() throws Exception
{    MutableAtomicValue<Integer> result = new MutableAtomicValue<Integer>(0, 0);    if (currentValue == null) {        currentValue = number.add(cacheFactor);        if (!currentValue.succeeded()) {            currentValue = null;            result.succeeded = false;            return result;        }        currentIndex = 0;    }    result.succeeded = true;    result.preValue = currentValue.preValue() + currentIndex;    result.postValue = result.preValue + 1;    if (++currentIndex >= cacheFactor) {        currentValue = null;    }    return result;}
489c746f7a7eb54d6e922d4e0a8820abdf091409608973ab680deeeaa1d57051
next
public AtomicValue<Long> next() throws Exception
{    MutableAtomicValue<Long> result = new MutableAtomicValue<Long>(0L, 0L);    if (currentValue == null) {        currentValue = number.add(cacheFactor);        if (!currentValue.succeeded()) {            currentValue = null;            result.succeeded = false;            return result;        }        currentIndex = 0;    }    result.succeeded = true;    result.preValue = currentValue.preValue() + currentIndex;    result.postValue = result.preValue + 1;    if (++currentIndex >= cacheFactor) {        currentValue = null;    }    return result;}
d8d50c6b19059bb87ebeccf992f2f39fca4fac1b5d2b30d78b20d21752cdb7f1
get
public AtomicValue<Integer> get() throws Exception
{    return new AtomicInteger(value.get());}
819a3e1092846f8724f624ac1afeb4147ac267f3f7791745fcdcf305206a03cd
forceSet
public void forceSet(Integer newValue) throws Exception
{    value.forceSet(valueToBytes(newValue));}
9bc35e42f37d89533b9f80c038948dd7bd8d003fe18608062d55e3047235007f
compareAndSet
public AtomicValue<Integer> compareAndSet(Integer expectedValue, Integer newValue) throws Exception
{    return new AtomicInteger(value.compareAndSet(valueToBytes(expectedValue), valueToBytes(newValue)));}
e6e75ecb33998380bc0f087db5bbb9b64fbaf0c6307f624579caf458bda96766
trySet
public AtomicValue<Integer> trySet(Integer newValue) throws Exception
{    return new AtomicInteger(value.trySet(valueToBytes(newValue)));}
68918a245be7d9f43fab42c009240cc6a98dff1ab738974e99acdfdb13b3f157
initialize
public boolean initialize(Integer initialize) throws Exception
{    return value.initialize(valueToBytes(initialize));}
d99c40abdc65d864db44b471c54bfcde2b2641fd4f242f08e6b95a5cbb0d1520
increment
public AtomicValue<Integer> increment() throws Exception
{    return worker(1);}
cbd40f1ef5401e4c1e253042788454b539494228e345da66798ce8a5185ecf1d
decrement
public AtomicValue<Integer> decrement() throws Exception
{    return worker(-1);}
0b92229cca87dfd1028996f0a7c9f52d94ec72178dc39e98fd7987960ad06482
add
public AtomicValue<Integer> add(Integer delta) throws Exception
{    return worker(delta);}
e49359c1e9dfad78480ceab40466d920142212e57047442b980526cca61bf095
subtract
public AtomicValue<Integer> subtract(Integer delta) throws Exception
{    return worker(-1 * delta);}
90a9d7ccb9d27e201b27e96e5b9cd2650a1df3ed5937ed19437fab59879b20b1
valueToBytes
 byte[] valueToBytes(Integer newValue)
{    Preconditions.checkNotNull(newValue, "newValue cannot be null");    byte[] newData = new byte[4];    ByteBuffer wrapper = ByteBuffer.wrap(newData);    wrapper.putInt(newValue);    return newData;}
dc74f54b3261a7e711d2381804eea625a472e8cffc24187655189f7e83dc3d7b
bytesToValue
 int bytesToValue(byte[] data)
{    if ((data == null) || (data.length == 0)) {        return 0;    }    ByteBuffer wrapper = ByteBuffer.wrap(data);    try {        return wrapper.getInt();    } catch (BufferUnderflowException e) {        throw value.createCorruptionException(data);    } catch (BufferOverflowException e) {        throw value.createCorruptionException(data);    }}
5e62cc041c87fc01592d64ddf8921daaad9c704ec54698a5acd6dff5cef39c9e
worker
private AtomicValue<Integer> worker(final Integer addAmount) throws Exception
{    Preconditions.checkNotNull(addAmount, "addAmount cannot be null");    MakeValue makeValue = new MakeValue() {        @Override        public byte[] makeFrom(byte[] previous) {            int previousValue = (previous != null) ? bytesToValue(previous) : 0;            int newValue = previousValue + addAmount;            return valueToBytes(newValue);        }    };    AtomicValue<byte[]> result = value.trySet(makeValue);    return new AtomicInteger(result);}
282dd283c93bd943f8a9b05c3408dd878339949c5ba2b7c4b5a12b6f69ae1312
makeFrom
public byte[] makeFrom(byte[] previous)
{    int previousValue = (previous != null) ? bytesToValue(previous) : 0;    int newValue = previousValue + addAmount;    return valueToBytes(newValue);}
6b2d8198cbb598cabc04ad5183f5856cca98ac924e034a21b5770376ef813cc8
succeeded
public boolean succeeded()
{    return bytes.succeeded();}
e575e1e75dca96c50daa99d3f24503e41e0aabbadc1de38fd6f0c78865ae3463
preValue
public Integer preValue()
{    return bytesToValue(bytes.preValue());}
614f46e43663db04752ba27eccbcf809bc2b0f8e90b014d6d04f07f62e2bdbb1
postValue
public Integer postValue()
{    return bytesToValue(bytes.postValue());}
72abbea497b4f31b3caa3235ca13c5e2fa5597e8fee3bd1962b36276a4a46695
getStats
public AtomicStats getStats()
{    return bytes.getStats();}
c14cb8ac9c9622d3b7d38eacf777225847afc6e324d8d4458c999d8902fce1a5
get
public AtomicValue<Long> get() throws Exception
{    return new AtomicLong(value.get());}
1c15dc62e03d70e25bce7f0dea76ed8ed86d4053ddc9f902d6d4c862fa0ba65c
forceSet
public void forceSet(Long newValue) throws Exception
{    value.forceSet(valueToBytes(newValue));}
7ae8ce55d04da2ba35e30d77a68ec3a6a93bcf3f08339e8cbb79c7b745e3dc1a
compareAndSet
public AtomicValue<Long> compareAndSet(Long expectedValue, Long newValue) throws Exception
{    return new AtomicLong(value.compareAndSet(valueToBytes(expectedValue), valueToBytes(newValue)));}
96d4314f6dac42c3dc32caf9b8b9c228494de5deaa6af0d029fcdc3cdbeb0cfa
trySet
public AtomicValue<Long> trySet(Long newValue) throws Exception
{    return new AtomicLong(value.trySet(valueToBytes(newValue)));}
0a8928fbd809be31cf6e4ce5ca5cca83b0d0389113efed37e6c468929786650a
initialize
public boolean initialize(Long initialize) throws Exception
{    return value.initialize(valueToBytes(initialize));}
2c6e9af0b0ad4b2dcb000eb9943ccfe6c382576279dbdf9feceaff746836783d
increment
public AtomicValue<Long> increment() throws Exception
{    return worker(1L);}
753f2ac35c2cda68c14d24e99a41aca5af20ce34c7b662d4adbce65ff507aaac
decrement
public AtomicValue<Long> decrement() throws Exception
{    return worker(-1L);}
a271b84d10429c3cd259184de50dc732cf0929c3b6497b05d9887e684053db67
add
public AtomicValue<Long> add(Long delta) throws Exception
{    return worker(delta);}
c0ad49256a08ded4ad1e2a14e6dd85ac42afc9dce79ad1efbce4ba6f4b943d8c
subtract
public AtomicValue<Long> subtract(Long delta) throws Exception
{    return worker(-1 * delta);}
c7f4b95e9a9ebc7eb423e307aa1390899e69c689d2ceab86827b49782563cea7
valueToBytes
 byte[] valueToBytes(Long newValue)
{    Preconditions.checkNotNull(newValue, "newValue cannot be null");    byte[] newData = new byte[8];    ByteBuffer wrapper = ByteBuffer.wrap(newData);    wrapper.putLong(newValue);    return newData;}
2ab85fe604a08fc73f9abdbe46c9eae5b5e9942bf5822fba22cc36756859c919
bytesToValue
 long bytesToValue(byte[] data)
{    if ((data == null) || (data.length == 0)) {        return 0;    }    ByteBuffer wrapper = ByteBuffer.wrap(data);    try {        return wrapper.getLong();    } catch (BufferUnderflowException e) {        throw value.createCorruptionException(data);    } catch (BufferOverflowException e) {        throw value.createCorruptionException(data);    }}
79668db6ee399b920837f9323099c576f009d6964e397ee7ac21fc1cab7d3273
worker
private AtomicValue<Long> worker(final Long addAmount) throws Exception
{    Preconditions.checkNotNull(addAmount, "addAmount cannot be null");    MakeValue makeValue = new MakeValue() {        @Override        public byte[] makeFrom(byte[] previous) {            long previousValue = (previous != null) ? bytesToValue(previous) : 0;            long newValue = previousValue + addAmount;            return valueToBytes(newValue);        }    };    AtomicValue<byte[]> result = value.trySet(makeValue);    return new AtomicLong(result);}
282dd283c93bd943f8a9b05c3408dd878339949c5ba2b7c4b5a12b6f69ae1312
makeFrom
public byte[] makeFrom(byte[] previous)
{    long previousValue = (previous != null) ? bytesToValue(previous) : 0;    long newValue = previousValue + addAmount;    return valueToBytes(newValue);}
6b2d8198cbb598cabc04ad5183f5856cca98ac924e034a21b5770376ef813cc8
succeeded
public boolean succeeded()
{    return bytes.succeeded();}
ef91bacf04523b15fe3a327e5a7495b930a1482b6a05b4753e8f2e4494920aad
preValue
public Long preValue()
{    return bytesToValue(bytes.preValue());}
53c90dec4d1307929c6f68d7d5acbb506dc4e3f6339472fbe935c10a202e0381
postValue
public Long postValue()
{    return bytesToValue(bytes.postValue());}
72abbea497b4f31b3caa3235ca13c5e2fa5597e8fee3bd1962b36276a4a46695
getStats
public AtomicStats getStats()
{    return bytes.getStats();}
818ff05a02bc0d07e685a2e4fe71a75bcff62f486d7fc19e91cd8a186435ae6d
get
public AtomicValue<byte[]> get() throws Exception
{    MutableAtomicValue<byte[]> result = new MutableAtomicValue<byte[]>(null, null, false);    getCurrentValue(result, new Stat());    result.postValue = result.preValue;    result.succeeded = true;    return result;}
3a9a08f325bab52d3cd0a2d7ad4a7a99c8d120592b6b97e9f5cdfe0f9679f971
forceSet
public void forceSet(byte[] newValue) throws Exception
{    try {        client.setData().forPath(path, newValue);    } catch (KeeperException.NoNodeException dummy) {        try {            client.create().creatingParentContainersIfNeeded().forPath(path, newValue);        } catch (KeeperException.NodeExistsException dummy2) {            client.setData().forPath(path, newValue);        }    }}
df22f2ab4756fe79cacb83fc51ac5fc59f69db53d983853ad5feaf81791f0096
compareAndSet
public AtomicValue<byte[]> compareAndSet(byte[] expectedValue, byte[] newValue) throws Exception
{    Stat stat = new Stat();    MutableAtomicValue<byte[]> result = new MutableAtomicValue<byte[]>(null, null, false);    boolean createIt = getCurrentValue(result, stat);    if (!createIt && Arrays.equals(expectedValue, result.preValue)) {        try {            client.setData().withVersion(stat.getVersion()).forPath(path, newValue);            result.succeeded = true;            result.postValue = newValue;        } catch (KeeperException.BadVersionException dummy) {            result.succeeded = false;        } catch (KeeperException.NoNodeException dummy) {            result.succeeded = false;        }    } else {        result.succeeded = false;    }    return result;}
9579745bfca077521eea6c53a9a5b878d7a88e007f623209974dbf0c201db14d
trySet
public AtomicValue<byte[]> trySet(final byte[] newValue) throws Exception
{    MutableAtomicValue<byte[]> result = new MutableAtomicValue<byte[]>(null, null, false);    MakeValue makeValue = new MakeValue() {        @Override        public byte[] makeFrom(byte[] previous) {            return newValue;        }    };    tryOptimistic(result, makeValue);    if (!result.succeeded() && (mutex != null)) {        tryWithMutex(result, makeValue);    }    return result;}
282dd283c93bd943f8a9b05c3408dd878339949c5ba2b7c4b5a12b6f69ae1312
makeFrom
public byte[] makeFrom(byte[] previous)
{    return newValue;}
3c4a3277cd1d0c5e8b9ad6fea305b40e7a7ee0d206d91b0a875a238cf7b92249
initialize
public boolean initialize(byte[] value) throws Exception
{    try {        client.create().creatingParentContainersIfNeeded().forPath(path, value);    } catch (KeeperException.NodeExistsException ignore) {                return false;    }    return true;}
bd8e7558ad1f6c6d2d8a42933471191ed6375eda6ad39d683317ab0459f2efb9
trySet
 AtomicValue<byte[]> trySet(MakeValue makeValue) throws Exception
{    MutableAtomicValue<byte[]> result = new MutableAtomicValue<byte[]>(null, null, false);    tryOptimistic(result, makeValue);    if (!result.succeeded() && (mutex != null)) {        tryWithMutex(result, makeValue);    }    return result;}
893964659961e9f4db25b8fa191ff1119465a1bfd7e4b49602057179ad3f1061
createCorruptionException
 RuntimeException createCorruptionException(byte[] bytes)
{    StringBuilder str = new StringBuilder();    str.append('[');    boolean first = true;    for (byte b : bytes) {        if (first) {            first = false;        } else {            str.append(", ");        }        str.append("0x").append(Integer.toHexString((b & 0xff)));    }    str.append(']');    return new RuntimeException(String.format("Corrupted data for node \"%s\": %s", path, str.toString()));}
e8637e3d859fdd14681e28dfa0dea677c7202ef9bd500ee0706454a59573d84c
getCurrentValue
private boolean getCurrentValue(MutableAtomicValue<byte[]> result, Stat stat) throws Exception
{    boolean createIt = false;    try {        result.preValue = client.getData().storingStatIn(stat).forPath(path);    } catch (KeeperException.NoNodeException e) {        result.preValue = null;        createIt = true;    }    return createIt;}
eb1a2d9ee93e907a2be4a71ebea0c8a20ab8c5a1ff8cb718d8731c955007c504
tryWithMutex
private void tryWithMutex(MutableAtomicValue<byte[]> result, MakeValue makeValue) throws Exception
{    long startMs = System.currentTimeMillis();    int retryCount = 0;    if (mutex.acquire(promotedToLock.getMaxLockTime(), promotedToLock.getMaxLockTimeUnit())) {        try {            boolean done = false;            while (!done) {                result.stats.incrementPromotedTries();                if (tryOnce(result, makeValue)) {                    result.succeeded = true;                    done = true;                } else {                    if (!promotedToLock.getRetryPolicy().allowRetry(retryCount++, System.currentTimeMillis() - startMs, RetryLoop.getDefaultRetrySleeper())) {                        done = true;                    }                }            }        } finally {            mutex.release();        }    }    result.stats.setPromotedTimeMs(System.currentTimeMillis() - startMs);}
1a4c715fa2591778611235fdfe625976afdf454e93e916cec41a07ac525efbf4
tryOptimistic
private void tryOptimistic(MutableAtomicValue<byte[]> result, MakeValue makeValue) throws Exception
{    long startMs = System.currentTimeMillis();    int retryCount = 0;    boolean done = false;    while (!done) {        result.stats.incrementOptimisticTries();        if (tryOnce(result, makeValue)) {            result.succeeded = true;            done = true;        } else {            if (!retryPolicy.allowRetry(retryCount++, System.currentTimeMillis() - startMs, RetryLoop.getDefaultRetrySleeper())) {                done = true;            }        }    }    result.stats.setOptimisticTimeMs(System.currentTimeMillis() - startMs);}
85117ac9f082a56602cb87e3abcfeeb2a5880f36aa182c7e0e6b8bd2f8de585e
tryOnce
private boolean tryOnce(MutableAtomicValue<byte[]> result, MakeValue makeValue) throws Exception
{    Stat stat = new Stat();    boolean createIt = getCurrentValue(result, stat);    boolean success = false;    try {        byte[] newValue = makeValue.makeFrom(result.preValue);        if (createIt) {            client.create().creatingParentContainersIfNeeded().forPath(path, newValue);        } else {            client.setData().withVersion(stat.getVersion()).forPath(path, newValue);        }        result.postValue = Arrays.copyOf(newValue, newValue.length);        success = true;    } catch (KeeperException.NodeExistsException e) {        } catch (KeeperException.BadVersionException e) {        } catch (KeeperException.NoNodeException e) {        }    return success;}
2989f082070e7fc98d627bdc2ba59a123858a701da0a2639ba75aeceaa761650
preValue
public T preValue()
{    return preValue;}
f94aa60d5eeae947eba1915213a5822835599416403819bdf9e00d98debb755d
postValue
public T postValue()
{    return postValue;}
6b2d8198cbb598cabc04ad5183f5856cca98ac924e034a21b5770376ef813cc8
succeeded
public boolean succeeded()
{    return succeeded;}
72abbea497b4f31b3caa3235ca13c5e2fa5597e8fee3bd1962b36276a4a46695
getStats
public AtomicStats getStats()
{    return stats;}
cf558fab344ef794057daaaf3d4721487c20c3f85d09e31f5c8f20f006d4a450
builder
public static Builder builder()
{    return new Builder();}
45b193acafadaba684af27e1889f8cd8d04bff8bdf8d49c9bcbb1dfe2aed9c72
build
public PromotedToLock build()
{    Preconditions.checkNotNull(instance.path, "path cannot be null");    Preconditions.checkNotNull(instance.retryPolicy, "retryPolicy cannot be null");    return new PromotedToLock(instance.path, instance.maxLockTime, instance.maxLockTimeUnit, instance.retryPolicy);}
fa2645c50cc44224a48215a98e1f9f613bcc4286c3521d4e6cef41f77306c673
lockPath
public Builder lockPath(String path)
{    instance = new PromotedToLock(PathUtils.validatePath(path), instance.maxLockTime, instance.maxLockTimeUnit, instance.retryPolicy);    return this;}
ce99c018c019b591d285e82270a53f427c7e6fed9b3ed7811cd8f52236d01567
retryPolicy
public Builder retryPolicy(RetryPolicy retryPolicy)
{    instance = new PromotedToLock(instance.path, instance.maxLockTime, instance.maxLockTimeUnit, retryPolicy);    return this;}
7571fdcb35c2b5208eac5138e82b2528b7b4273cd4035587e2d00d0f6b10daab
timeout
public Builder timeout(long maxLockTime, TimeUnit maxLockTimeUnit)
{    instance = new PromotedToLock(instance.path, maxLockTime, maxLockTimeUnit, instance.retryPolicy);    return this;}
944b41f44ac3191c402116f23c93048495c7b4b411a12817daebbc391c20e01f
getPath
 String getPath()
{    return path;}
cc930465e5ab2c379a5e1ea81ed38d7169f92e32504c349462593789f045af4b
getMaxLockTime
 long getMaxLockTime()
{    return maxLockTime;}
6003ccff25c7a3038de8d775692fa909bee82122d11ab87d5a6bf4aa663f0378
getMaxLockTimeUnit
 TimeUnit getMaxLockTimeUnit()
{    return maxLockTimeUnit;}
08a54a03ecdbb76335c56188bf46021b0d709901826d7918bb99650ef27e8335
getRetryPolicy
 RetryPolicy getRetryPolicy()
{    return retryPolicy;}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    client.postSafeNotify(DistributedBarrier.this);}
3111b23cce9d6b1fbc69113b1c853ecb06b244b5af509e33d4cc8c55e4863a94
setBarrier
public synchronized void setBarrier() throws Exception
{    try {        client.create().creatingParentContainersIfNeeded().forPath(barrierPath);    } catch (KeeperException.NodeExistsException ignore) {        }}
c7ae9c11fb6a6fc6ad20554a5455bad1781ea49f1b1bfdd7091b9020f1d6f7c4
removeBarrier
public synchronized void removeBarrier() throws Exception
{    try {        client.delete().forPath(barrierPath);    } catch (KeeperException.NoNodeException ignore) {        }}
ac1d4a27e7c21d46a59d83a46eccde47d5d28ee2f3421b4599b2cccaf91ad6a2
waitOnBarrier
public synchronized void waitOnBarrier() throws Exception
{    waitOnBarrier(-1, null);}
42ffaa28084f3144db910c3177431dba54467aaf7c23e099985fc1dc9bbc4bfc
waitOnBarrier
public synchronized boolean waitOnBarrier(long maxWait, TimeUnit unit) throws Exception
{    long startMs = System.currentTimeMillis();    boolean hasMaxWait = (unit != null);    long maxWaitMs = hasMaxWait ? TimeUnit.MILLISECONDS.convert(maxWait, unit) : Long.MAX_VALUE;    boolean result;    for (; ; ) {        result = (client.checkExists().usingWatcher(watcher).forPath(barrierPath) == null);        if (result) {            break;        }        if (hasMaxWait) {            long elapsed = System.currentTimeMillis() - startMs;            long thisWaitMs = maxWaitMs - elapsed;            if (thisWaitMs <= 0) {                break;            }            wait(thisWaitMs);        } else {            wait();        }    }    return result;}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    connectionLost.set(event.getState() != Event.KeeperState.SyncConnected);    client.runSafe(() -> {        synchronized (DistributedDoubleBarrier.this) {            hasBeenNotified.set(true);            DistributedDoubleBarrier.this.notifyAll();        }    });}
c6002ff57cc6c5ab3a7f14837082388e8d4f40a245339b2162d870821b70b4e7
enter
public void enter() throws Exception
{    enter(-1, null);}
4a01f7f2c0fcd200e34f12ab7fd3c966e936ec2b80d97fe0991fe29de612d647
enter
public boolean enter(long maxWait, TimeUnit unit) throws Exception
{    long startMs = System.currentTimeMillis();    boolean hasMaxWait = (unit != null);    long maxWaitMs = hasMaxWait ? TimeUnit.MILLISECONDS.convert(maxWait, unit) : Long.MAX_VALUE;    boolean readyPathExists = (client.checkExists().usingWatcher(watcher).forPath(readyPath) != null);    client.create().creatingParentContainersIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(ourPath);    boolean result = (readyPathExists || internalEnter(startMs, hasMaxWait, maxWaitMs));    if (connectionLost.get()) {        throw new KeeperException.ConnectionLossException();    }    return result;}
cb455806d29d10ffb85b3dcf357fb2229b207a99f07497c3fd7040a77956f154
leave
public synchronized void leave() throws Exception
{    leave(-1, null);}
5eb8ffa47c7e7c7ecf67dbd25e9121ec3833c4986233b30c4756bf85de10bc43
leave
public synchronized boolean leave(long maxWait, TimeUnit unit) throws Exception
{    long startMs = System.currentTimeMillis();    boolean hasMaxWait = (unit != null);    long maxWaitMs = hasMaxWait ? TimeUnit.MILLISECONDS.convert(maxWait, unit) : Long.MAX_VALUE;    return internalLeave(startMs, hasMaxWait, maxWaitMs);}
9b7b434cebb41a0d2451644b08927a9eb397e463a114fbeedd791d678936d50d
getChildrenForEntering
protected List<String> getChildrenForEntering() throws Exception
{    return client.getChildren().forPath(barrierPath);}
2321e64af185b7f882f82298d06342fd1ace652fce2af4abbd9dc9190da00ab1
filterAndSortChildren
private List<String> filterAndSortChildren(List<String> children)
{    Iterable<String> filtered = Iterables.filter(children, new Predicate<String>() {        @Override        public boolean apply(String name) {            return !name.equals(READY_NODE);        }    });    ArrayList<String> filteredList = Lists.newArrayList(filtered);    Collections.sort(filteredList);    return filteredList;}
30643132427677c984628c3b2b684164d1853815d074a61100f5f85dbce9a063
apply
public boolean apply(String name)
{    return !name.equals(READY_NODE);}
a86cff92721d7b75874a00575edd1bc6a96a3da65e92b1e4f725002c44bb1f1b
internalLeave
private boolean internalLeave(long startMs, boolean hasMaxWait, long maxWaitMs) throws Exception
{    String ourPathName = ZKPaths.getNodeFromPath(ourPath);    boolean ourNodeShouldExist = true;    boolean result = true;    for (; ; ) {        if (connectionLost.get()) {            throw new KeeperException.ConnectionLossException();        }        List<String> children;        try {            children = client.getChildren().forPath(barrierPath);        } catch (KeeperException.NoNodeException dummy) {            children = Lists.newArrayList();        }        children = filterAndSortChildren(children);        if ((children == null) || (children.size() == 0)) {            break;        }        int ourIndex = children.indexOf(ourPathName);        if ((ourIndex < 0) && ourNodeShouldExist) {            if (connectionLost.get()) {                                break;            } else {                throw new IllegalStateException(String.format("Our path (%s) is missing", ourPathName));            }        }        if (children.size() == 1) {            if (ourNodeShouldExist && !children.get(0).equals(ourPathName)) {                throw new IllegalStateException(String.format("Last path (%s) is not ours (%s)", children.get(0), ourPathName));            }            checkDeleteOurPath(ourNodeShouldExist);            break;        }        Stat stat;        boolean IsLowestNode = (ourIndex == 0);        if (IsLowestNode) {            String highestNodePath = ZKPaths.makePath(barrierPath, children.get(children.size() - 1));            stat = client.checkExists().usingWatcher(watcher).forPath(highestNodePath);        } else {            String lowestNodePath = ZKPaths.makePath(barrierPath, children.get(0));            stat = client.checkExists().usingWatcher(watcher).forPath(lowestNodePath);            checkDeleteOurPath(ourNodeShouldExist);            ourNodeShouldExist = false;        }        if (stat != null) {            if (hasMaxWait) {                long elapsed = System.currentTimeMillis() - startMs;                long thisWaitMs = maxWaitMs - elapsed;                if (thisWaitMs <= 0) {                    result = false;                    break;                } else {                    wait(thisWaitMs);                }            } else {                wait();            }        }    }    try {        client.delete().forPath(readyPath);    } catch (KeeperException.NoNodeException ignore) {        }    return result;}
5d4f803c949c1bb4632a2f45c7dc8ec63be631c89f3694ba4ee725deb0721ad8
checkDeleteOurPath
private void checkDeleteOurPath(boolean shouldExist) throws Exception
{    if (shouldExist) {        client.delete().forPath(ourPath);    }}
f8b747211d4dc766522e18898f14b0fb1e5840c5b6149b6b94ff7953bc546c35
internalEnter
private synchronized boolean internalEnter(long startMs, boolean hasMaxWait, long maxWaitMs) throws Exception
{    boolean result = true;    do {        List<String> children = getChildrenForEntering();        int count = (children != null) ? children.size() : 0;        if (count >= memberQty) {            try {                client.create().forPath(readyPath);            } catch (KeeperException.NodeExistsException ignore) {                        }            break;        }        if (hasMaxWait && !hasBeenNotified.get()) {            long elapsed = System.currentTimeMillis() - startMs;            long thisWaitMs = maxWaitMs - elapsed;            if (thisWaitMs <= 0) {                result = false;            } else {                wait(thisWaitMs);            }            if (!hasBeenNotified.get()) {                result = false;            }        } else {            wait();        }    } while (false);    return result;}
9b10cabe836286688a82415e129a4bc5ddda0ceca3517d7064c4e3498225c251
compareTo
public int compareTo(ChildData rhs)
{    if (this == rhs) {        return 0;    }    if (rhs == null || getClass() != rhs.getClass()) {        return -1;    }    return path.compareTo(rhs.path);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    ChildData childData = (ChildData) o;    if (!Arrays.equals(data, childData.data)) {        return false;    }    if (path != null ? !path.equals(childData.path) : childData.path != null) {        return false;    }    if (stat != null ? !stat.equals(childData.stat) : childData.stat != null) {        return false;    }    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = path != null ? path.hashCode() : 0;    result = 31 * result + (stat != null ? stat.hashCode() : 0);    result = 31 * result + Arrays.hashCode(data);    return result;}
58e7b527ecd5014eaf5f30fc9c50ba33e1f005f8ce9d24246253d62377788662
getPath
public String getPath()
{    return path;}
caeb2b7d846f9588cde9a2efecc0ed94309a4fcf52121d0b14624bbd6216398b
getStat
public Stat getStat()
{    return stat;}
812b8f717be4a6f9c7add1b71268ba7fe7ce1b799031309a1709dc43be1dd152
getData
public byte[] getData()
{    return data;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "ChildData{" + "path='" + path + '\'' + ", stat=" + stat + ", data=" + Arrays.toString(data) + '}';}
a329bc63e04f91227a45b19477132d01e85c23b037ef7122430b7b6890f1d001
traverseChildren
public boolean traverseChildren(String fullPath)
{    return true;}
e15a3694e431f11e14b58aa188efa027ee40bcf5b18b25716a29de7962bfa83c
acceptChild
public boolean acceptChild(String fullPath)
{    return true;}
2d502ef949b12c4896245916f0a4fda192ff23b4ae4cf04d890e9d31d4db0ce8
invoke
public void invoke()
{    cache.callListeners(event);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "EventOperation{" + "event=" + event + '}';}
3123c01a42d932f204074808c13c4f72b1e3239f2369166b923ebfef185d1b39
invoke
public void invoke() throws Exception
{    cache.getDataAndStat(fullPath);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    GetDataOperation that = (GetDataOperation) o;        if (!fullPath.equals(that.fullPath)) {        return false;    }    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return fullPath.hashCode();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "GetDataOperation{" + "fullPath='" + fullPath + '\'' + '}';}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if ((newState == ConnectionState.CONNECTED) || (newState == ConnectionState.RECONNECTED)) {        if (isConnected.compareAndSet(false, true)) {            try {                reset();            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                log.error("Trying to reset after reconnection", e);            }        }    } else {        isConnected.set(false);    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    try {        reset();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleException(e);    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    processBackgroundResult(event);}
518b6bcd210d55f023bb8a9ddbfa3d2e116d5292ad8c1f8bea0cefab3383dce3
getClient
public CuratorFramework getClient()
{    return client;}
90ba0dddc593bd95e2a0c0c039c523b81bfb91f87814ebcb222c3914ca772ead
start
public void start() throws Exception
{    start(false);}
17c5ad1bb42a909217756540a6d3682d89ad97e63a43ac6e60dab5d592963e1a
start
public void start(boolean buildInitial) throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    client.getConnectionStateListenable().addListener(connectionStateListener);    if (buildInitial) {        client.checkExists().creatingParentContainersIfNeeded().forPath(path);        internalRebuild();    }    reset();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    if (state.compareAndSet(State.STARTED, State.CLOSED)) {        client.removeWatchers();        listeners.clear();        client.getConnectionStateListenable().removeListener(connectionStateListener);                                        connectionStateListener = null;        watcher = null;    }}
5a90237e0a40e4cdd1bd892d38b56ede6cae2d7099858157b6466f96642154b4
getListenable
public ListenerContainer<NodeCacheListener> getListenable()
{    Preconditions.checkState(state.get() != State.CLOSED, "Closed");    return listeners;}
e6c7730bad09859f443ff362623cba1bf509b2469a1d907f672a7108be4c712c
rebuild
public void rebuild() throws Exception
{    Preconditions.checkState(state.get() == State.STARTED, "Not started");    internalRebuild();    reset();}
2deaeb7fc030fa7eae068ddbca24c6addf1216d13a26ec4e786dd3eb798ef6b1
getCurrentData
public ChildData getCurrentData()
{    return data.get();}
58e7b527ecd5014eaf5f30fc9c50ba33e1f005f8ce9d24246253d62377788662
getPath
public String getPath()
{    return path;}
d9325b48525d29e8fd87bd09cc08079162b8103b1fddcc84d99536f78d8f2d73
reset
private void reset() throws Exception
{    if ((state.get() == State.STARTED) && isConnected.get()) {        client.checkExists().creatingParentContainersIfNeeded().usingWatcher(watcher).inBackground(backgroundCallback).forPath(path);    }}
4680961d3af714a748f955f790b2e5d3214b6362f71be08b5af1701b26eac350
internalRebuild
private void internalRebuild() throws Exception
{    try {        Stat stat = new Stat();        byte[] bytes = dataIsCompressed ? client.getData().decompressed().storingStatIn(stat).forPath(path) : client.getData().storingStatIn(stat).forPath(path);        data.set(new ChildData(path, stat, bytes));    } catch (KeeperException.NoNodeException e) {        data.set(null);    }}
ee46b397956fbf29b8c55f224278ae9347fb56b4dec13487744eec0673ab2f77
processBackgroundResult
private void processBackgroundResult(CuratorEvent event) throws Exception
{    switch(event.getType()) {        case GET_DATA:            {                if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                    ChildData childData = new ChildData(path, event.getStat(), event.getData());                    setNewData(childData);                }                break;            }        case EXISTS:            {                if (event.getResultCode() == KeeperException.Code.NONODE.intValue()) {                    setNewData(null);                } else if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                    if (dataIsCompressed) {                        client.getData().decompressed().usingWatcher(watcher).inBackground(backgroundCallback).forPath(path);                    } else {                        client.getData().usingWatcher(watcher).inBackground(backgroundCallback).forPath(path);                    }                }                break;            }    }}
f4276b92934fa5792db8a7fbceb6350d0b6b3205ae0a781d464d02478c982385
setNewData
private void setNewData(ChildData newData) throws InterruptedException
{    ChildData previousData = data.getAndSet(newData);    if (!Objects.equal(previousData, newData)) {        listeners.forEach(new Function<NodeCacheListener, Void>() {            @Override            public Void apply(NodeCacheListener listener) {                try {                    listener.nodeChanged();                } catch (Exception e) {                    ThreadUtils.checkInterrupted(e);                    log.error("Calling listener", e);                }                return null;            }        });        if (rebuildTestExchanger != null) {            try {                rebuildTestExchanger.exchange(new Object());            } catch (InterruptedException e) {                Thread.currentThread().interrupt();            }        }    }}
df288a7307418ad67bcfa7f049624c423cdc1f57c0dd534b2d576da81408ee26
apply
public Void apply(NodeCacheListener listener)
{    try {        listener.nodeChanged();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        log.error("Calling listener", e);    }    return null;}
acf01c7be23198ba58e96419e1afeacf9079d217f740104c3c3b8060824dc321
handleException
protected void handleException(Throwable e)
{    log.error("", e);}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    offerOperation(new RefreshOperation(PathChildrenCache.this, RefreshMode.STANDARD));}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    try {        if (event.getType() == Event.EventType.NodeDeleted) {            remove(event.getPath());        } else if (event.getType() == Event.EventType.NodeDataChanged) {            offerOperation(new GetDataOperation(PathChildrenCache.this, event.getPath()));        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleException(e);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    handleStateChange(newState);}
90ba0dddc593bd95e2a0c0c039c523b81bfb91f87814ebcb222c3914ca772ead
start
public void start() throws Exception
{    start(StartMode.NORMAL);}
17c5ad1bb42a909217756540a6d3682d89ad97e63a43ac6e60dab5d592963e1a
start
public void start(boolean buildInitial) throws Exception
{    start(buildInitial ? StartMode.BUILD_INITIAL_CACHE : StartMode.NORMAL);}
5ca9612fca21e9ad9e92171e90885f9bae79537b75813190f82f32e6db90a05b
start
public void start(StartMode mode) throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "already started");    mode = Preconditions.checkNotNull(mode, "mode cannot be null");    client.getConnectionStateListenable().addListener(connectionStateListener);    switch(mode) {        case NORMAL:            {                offerOperation(new RefreshOperation(this, RefreshMode.STANDARD));                break;            }        case BUILD_INITIAL_CACHE:            {                rebuild();                break;            }        case POST_INITIALIZED_EVENT:            {                initialSet.set(Maps.<String, ChildData>newConcurrentMap());                offerOperation(new RefreshOperation(this, RefreshMode.POST_INITIALIZED));                break;            }    }}
e6c7730bad09859f443ff362623cba1bf509b2469a1d907f672a7108be4c712c
rebuild
public void rebuild() throws Exception
{    Preconditions.checkState(state.get() == State.STARTED, "cache has been closed");    ensurePath();    clear();    List<String> children = client.getChildren().forPath(path);    for (String child : children) {        String fullPath = ZKPaths.makePath(path, child);        internalRebuildNode(fullPath);        if (rebuildTestExchanger != null) {            rebuildTestExchanger.exchange(new Object());        }    }        offerOperation(new RefreshOperation(this, RefreshMode.FORCE_GET_DATA_AND_STAT));}
f169a20ed45a82bd64ed585e62b68af06cdae7b60f938c6aa5215d0c4c744565
rebuildNode
public void rebuildNode(String fullPath) throws Exception
{    Preconditions.checkArgument(ZKPaths.getPathAndNode(fullPath).getPath().equals(path), "Node is not part of this cache: " + fullPath);    Preconditions.checkState(state.get() == State.STARTED, "cache has been closed");    ensurePath();    internalRebuildNode(fullPath);            offerOperation(new RefreshOperation(this, RefreshMode.FORCE_GET_DATA_AND_STAT));}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    if (state.compareAndSet(State.STARTED, State.CLOSED)) {        client.getConnectionStateListenable().removeListener(connectionStateListener);        listeners.clear();        executorService.close();        client.removeWatchers();                                connectionStateListener = null;        childrenWatcher = null;        dataWatcher = null;    }}
a017ac230d78a07bac37609fe0e53e0ba422085c66b7f744160144ee623682e7
getListenable
public ListenerContainer<PathChildrenCacheListener> getListenable()
{    return listeners;}
591f8fc33ea98d774753b7d138d0fb0be17b8d53228f090cb2b02058b0ef7c7d
getCurrentData
public List<ChildData> getCurrentData()
{    return ImmutableList.copyOf(Sets.<ChildData>newTreeSet(currentData.values()));}
9ca704b3c7a251866a5d064ce2bddfce7e0a2d2d85b03da7bb427b562470a6aa
getCurrentData
public ChildData getCurrentData(String fullPath)
{    return currentData.get(fullPath);}
c90ed1a72067ec518e6a93a12c22ce9348ab9c57723c2ca1200b0830f7e90e52
clearDataBytes
public void clearDataBytes(String fullPath)
{    clearDataBytes(fullPath, -1);}
4dafef840c6889d928420b4303985f4f0cbdc81faa55130a4302061c2edff1ec
clearDataBytes
public boolean clearDataBytes(String fullPath, int ifVersion)
{    ChildData data = currentData.get(fullPath);    if (data != null) {        if ((ifVersion < 0) || (ifVersion == data.getStat().getVersion())) {            if (data.getData() != null) {                currentData.replace(fullPath, data, new ChildData(data.getPath(), data.getStat(), null));            }            return true;        }    }    return false;}
a54603100ef28194a6e167de74ee246115a9dc965260f539b1aac0ac705fdde5
clearAndRefresh
public void clearAndRefresh() throws Exception
{    currentData.clear();    offerOperation(new RefreshOperation(this, RefreshMode.STANDARD));}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    currentData.clear();}
1a9d7223de9aec7f4c01cb75b6e704cc559815ab78c87662865e7742152fff55
refresh
 void refresh(final RefreshMode mode) throws Exception
{    ensurePath();    final BackgroundCallback callback = new BackgroundCallback() {        @Override        public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {            if (reRemoveWatchersOnBackgroundClosed()) {                return;            }            if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                processChildren(event.getChildren(), mode);            } else if (event.getResultCode() == KeeperException.Code.NONODE.intValue()) {                if (mode == RefreshMode.NO_NODE_EXCEPTION) {                    log.debug("KeeperException.NoNodeException received for getChildren() and refresh has failed. Resetting ensureContainers but not refreshing. Path: [{}]", path);                    ensureContainers.reset();                } else {                    log.debug("KeeperException.NoNodeException received for getChildren(). Resetting ensureContainers. Path: [{}]", path);                    ensureContainers.reset();                    offerOperation(new RefreshOperation(PathChildrenCache.this, RefreshMode.NO_NODE_EXCEPTION));                }            }        }    };    client.getChildren().usingWatcher(childrenWatcher).inBackground(callback).forPath(path);}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (reRemoveWatchersOnBackgroundClosed()) {        return;    }    if (event.getResultCode() == KeeperException.Code.OK.intValue()) {        processChildren(event.getChildren(), mode);    } else if (event.getResultCode() == KeeperException.Code.NONODE.intValue()) {        if (mode == RefreshMode.NO_NODE_EXCEPTION) {            log.debug("KeeperException.NoNodeException received for getChildren() and refresh has failed. Resetting ensureContainers but not refreshing. Path: [{}]", path);            ensureContainers.reset();        } else {            log.debug("KeeperException.NoNodeException received for getChildren(). Resetting ensureContainers. Path: [{}]", path);            ensureContainers.reset();            offerOperation(new RefreshOperation(PathChildrenCache.this, RefreshMode.NO_NODE_EXCEPTION));        }    }}
103bb0ca6ff94265835b8863cd0cba8259c1f0cdffd66404fa7b9995d9f26ebe
callListeners
 void callListeners(final PathChildrenCacheEvent event)
{    listeners.forEach(new Function<PathChildrenCacheListener, Void>() {        @Override        public Void apply(PathChildrenCacheListener listener) {            try {                listener.childEvent(client, event);            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                handleException(e);            }            return null;        }    });}
245f34947543b207db163ceb52d2b937a4df301cfb8ca9855b377d06c398ba25
apply
public Void apply(PathChildrenCacheListener listener)
{    try {        listener.childEvent(client, event);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleException(e);    }    return null;}
df46a1929c17fc7189ad398b0e51789ea57fd3839a296b2732efd4d3e08ca127
getDataAndStat
 void getDataAndStat(final String fullPath) throws Exception
{    BackgroundCallback callback = new BackgroundCallback() {        @Override        public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {            if (reRemoveWatchersOnBackgroundClosed()) {                return;            }            applyNewData(fullPath, event.getResultCode(), event.getStat(), cacheData ? event.getData() : null);        }    };    if (USE_EXISTS && !cacheData) {        client.checkExists().usingWatcher(dataWatcher).inBackground(callback).forPath(fullPath);    } else {                if (dataIsCompressed && cacheData) {            client.getData().decompressed().usingWatcher(dataWatcher).inBackground(callback).forPath(fullPath);        } else {            client.getData().usingWatcher(dataWatcher).inBackground(callback).forPath(fullPath);        }    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (reRemoveWatchersOnBackgroundClosed()) {        return;    }    applyNewData(fullPath, event.getResultCode(), event.getStat(), cacheData ? event.getData() : null);}
acf01c7be23198ba58e96419e1afeacf9079d217f740104c3c3b8060824dc321
handleException
protected void handleException(Throwable e)
{    log.error("", e);}
b4def6d6853ff3668c34d38ddfa38cc1024cbf7430c55e8f67e5fa0f3dc074dd
ensurePath
protected void ensurePath() throws Exception
{    ensureContainers.ensure();}
41bff715800a53a669820477628e5b706a93b05c458fef5e306f0ba3e4742a6c
remove
protected void remove(String fullPath)
{    ChildData data = currentData.remove(fullPath);    if (data != null) {        offerOperation(new EventOperation(this, new PathChildrenCacheEvent(PathChildrenCacheEvent.Type.CHILD_REMOVED, data)));    }    Map<String, ChildData> localInitialSet = initialSet.get();    if (localInitialSet != null) {        localInitialSet.remove(ZKPaths.getNodeFromPath(fullPath));        maybeOfferInitializedEvent(localInitialSet);    }}
50e62562189b8765fa6baa86e45f5c63e35997dd1b368466ba4d6d113c91580e
reRemoveWatchersOnBackgroundClosed
private boolean reRemoveWatchersOnBackgroundClosed()
{    if (state.get().equals(State.CLOSED)) {        client.removeWatchers();        return true;    }    return false;}
597bac0cbfa6f27a2dc831aa31f4dbaa3862efe911448cb6ad34d0cc402fc976
internalRebuildNode
private void internalRebuildNode(String fullPath) throws Exception
{    if (cacheData) {        try {            Stat stat = new Stat();            byte[] bytes = dataIsCompressed ? client.getData().decompressed().storingStatIn(stat).forPath(fullPath) : client.getData().storingStatIn(stat).forPath(fullPath);            currentData.put(fullPath, new ChildData(fullPath, stat, bytes));        } catch (KeeperException.NoNodeException ignore) {                        currentData.remove(fullPath);        }    } else {        Stat stat = client.checkExists().forPath(fullPath);        if (stat != null) {            currentData.put(fullPath, new ChildData(fullPath, stat, null));        } else {                        currentData.remove(fullPath);        }    }}
8c06c26f04c887210d8d9aaa6e3c8efbdeb0381710c1cd9b2efbb55dc61af0c0
handleStateChange
private void handleStateChange(ConnectionState newState)
{    switch(newState) {        case SUSPENDED:            {                offerOperation(new EventOperation(this, new PathChildrenCacheEvent(PathChildrenCacheEvent.Type.CONNECTION_SUSPENDED, null)));                break;            }        case LOST:            {                offerOperation(new EventOperation(this, new PathChildrenCacheEvent(PathChildrenCacheEvent.Type.CONNECTION_LOST, null)));                break;            }        case CONNECTED:        case RECONNECTED:            {                try {                    offerOperation(new RefreshOperation(this, RefreshMode.FORCE_GET_DATA_AND_STAT));                    offerOperation(new EventOperation(this, new PathChildrenCacheEvent(PathChildrenCacheEvent.Type.CONNECTION_RECONNECTED, null)));                } catch (Exception e) {                    ThreadUtils.checkInterrupted(e);                    handleException(e);                }                break;            }    }}
aaca27144e18e256cd2e52b7de908f5a0ff602496133db375a591330455e0669
processChildren
private void processChildren(List<String> children, RefreshMode mode) throws Exception
{    Set<String> removedNodes = Sets.newHashSet(currentData.keySet());    for (String child : children) {        removedNodes.remove(ZKPaths.makePath(path, child));    }    for (String fullPath : removedNodes) {        remove(fullPath);    }    for (String name : children) {        String fullPath = ZKPaths.makePath(path, name);        if ((mode == RefreshMode.FORCE_GET_DATA_AND_STAT) || !currentData.containsKey(fullPath)) {            getDataAndStat(fullPath);        }        updateInitialSet(name, NULL_CHILD_DATA);    }    maybeOfferInitializedEvent(initialSet.get());}
3b55d2b65434aeaae946001e967f46a95160949900ba937ef96c976f8be9c148
applyNewData
private void applyNewData(String fullPath, int resultCode, Stat stat, byte[] bytes)
{    if (    resultCode == KeeperException.Code.OK.intValue()) {        ChildData data = new ChildData(fullPath, stat, bytes);        ChildData previousData = currentData.put(fullPath, data);        if (        previousData == null) {            offerOperation(new EventOperation(this, new PathChildrenCacheEvent(PathChildrenCacheEvent.Type.CHILD_ADDED, data)));        } else if (stat.getMzxid() != previousData.getStat().getMzxid()) {            offerOperation(new EventOperation(this, new PathChildrenCacheEvent(PathChildrenCacheEvent.Type.CHILD_UPDATED, data)));        }        updateInitialSet(ZKPaths.getNodeFromPath(fullPath), data);    } else if (resultCode == KeeperException.Code.NONODE.intValue()) {        log.debug("NoNode at path {}, removing child from initialSet", fullPath);        remove(fullPath);    }}
d482ed13f31c7b10becf20d2fc57b3d3e6c77e75d337aec01ef03998ee6535fc
updateInitialSet
private void updateInitialSet(String name, ChildData data)
{    Map<String, ChildData> localInitialSet = initialSet.get();    if (localInitialSet != null) {        localInitialSet.put(name, data);        maybeOfferInitializedEvent(localInitialSet);    }}
9fe7b73d2ab0e98605075afe5e6cea6a6354cc48d372a882ac9ee5a556da095e
maybeOfferInitializedEvent
private void maybeOfferInitializedEvent(Map<String, ChildData> localInitialSet)
{    if (!hasUninitialized(localInitialSet)) {        if (        initialSet.getAndSet(null) != null) {            final List<ChildData> children = ImmutableList.copyOf(localInitialSet.values());            PathChildrenCacheEvent event = new PathChildrenCacheEvent(PathChildrenCacheEvent.Type.INITIALIZED, null) {                @Override                public List<ChildData> getInitialData() {                    return children;                }            };            offerOperation(new EventOperation(this, event));        }    }}
c738a222fb7ec12760dc865a2ca816a24d6cc6a945f9105550570001e6b3db1d
getInitialData
public List<ChildData> getInitialData()
{    return children;}
0d07726ba285ef40d8e870e72f1e10465ef0283ad512314287605e06d24e72a2
hasUninitialized
private boolean hasUninitialized(Map<String, ChildData> localInitialSet)
{    if (localInitialSet == null) {        return false;    }    Map<String, ChildData> uninitializedChildren = Maps.filterValues(localInitialSet, new Predicate<ChildData>() {        @Override        public boolean apply(ChildData input) {                        return (input == NULL_CHILD_DATA);        }    });    return (uninitializedChildren.size() != 0);}
e4d7eeb9bb15778071dd112580746b9f00e8af80258df3feeecaa9dade2807f9
apply
public boolean apply(ChildData input)
{        return (input == NULL_CHILD_DATA);}
c20a4387d7b7ca623cc5007357cec6c022d57ae52879717bc63bf0cda9864003
offerOperation
 void offerOperation(final Operation operation)
{    if (operationsQuantizer.add(operation)) {        submitToExecutor(new Runnable() {            @Override            public void run() {                try {                    operationsQuantizer.remove(operation);                    operation.invoke();                } catch (InterruptedException e) {                                        if (state.get() != State.CLOSED) {                        handleException(e);                    }                    Thread.currentThread().interrupt();                } catch (Exception e) {                    ThreadUtils.checkInterrupted(e);                    handleException(e);                }            }        });    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        operationsQuantizer.remove(operation);        operation.invoke();    } catch (InterruptedException e) {                if (state.get() != State.CLOSED) {            handleException(e);        }        Thread.currentThread().interrupt();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleException(e);    }}
a7dddc4e7b42be24c3b8f863a1980f35cd297de2b2bd674491aa7974c02c360d
submitToExecutor
private synchronized void submitToExecutor(final Runnable command)
{    if (state.get() == State.STARTED) {        executorService.submit(command);    }}
b36c0cb78d388571653840506cba5d90e12b262c755658912fc2224c314bcbf6
getType
public Type getType()
{    return type;}
b5ccbe96d3ea71a37d30b982195ead474da2e7dd985ecda146e59432b6fe4fb9
getData
public ChildData getData()
{    return data;}
c738a222fb7ec12760dc865a2ca816a24d6cc6a945f9105550570001e6b3db1d
getInitialData
public List<ChildData> getInitialData()
{    return null;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "PathChildrenCacheEvent{" + "type=" + type + ", data=" + data + '}';}
3123c01a42d932f204074808c13c4f72b1e3239f2369166b923ebfef185d1b39
invoke
public void invoke() throws Exception
{    cache.refresh(mode);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    RefreshOperation that = (RefreshOperation) o;        if (mode != that.mode) {        return false;    }    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return mode.hashCode();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "RefreshOperation(" + mode + "){}";}
dd72b274834c45b298720b1518c5ed410fff19d9f030432e56f4da8572f87b45
build
public TreeCache build()
{    ExecutorService executor = executorService;    if (executor == null) {        executor = Executors.newSingleThreadExecutor(defaultThreadFactory);    }    return new TreeCache(client, path, cacheData, dataIsCompressed, maxDepth, executor, createParentNodes, disableZkWatches, selector);}
5293233746fd4e8624a0546b1ef8b0125879f6f2f85d397c5072aba6a0e795d7
setCacheData
public Builder setCacheData(boolean cacheData)
{    this.cacheData = cacheData;    return this;}
8d051b7bb92897fbeeb74dba8f66b86f88c8ee4f31208269146e98db92ce8eaf
setDataIsCompressed
public Builder setDataIsCompressed(boolean dataIsCompressed)
{    this.dataIsCompressed = dataIsCompressed;    return this;}
222e6d0af2941ac4c7ffe646ebfcc6debff60b009c5663e12c48b5db3434bd30
setExecutor
public Builder setExecutor(ThreadFactory threadFactory)
{    return setExecutor(Executors.newSingleThreadExecutor(threadFactory));}
42b4dbe2cc4e2268d8f579d4e278748ed71a906cecc2e15e1755609c8a4ceaf1
setExecutor
public Builder setExecutor(ExecutorService executorService)
{    this.executorService = checkNotNull(executorService);    return this;}
5ff50833139eed806696d1584bad23a715e28163fe0d4803df57a682795cec38
setMaxDepth
public Builder setMaxDepth(int maxDepth)
{    this.maxDepth = maxDepth;    return this;}
22d38ef17aa9394b3633348e8a01b3fcb4b04e583f4ce8e7087a46c9e507a793
setCreateParentNodes
public Builder setCreateParentNodes(boolean createParentNodes)
{    this.createParentNodes = createParentNodes;    return this;}
7eed7e45c33e4c65977242b67da07ada03ae4354c46670db28fbceb07121f691
disableZkWatches
public Builder disableZkWatches(boolean disableZkWatches)
{    this.disableZkWatches = disableZkWatches;    return this;}
019f4dcd8dca10f3aec292f28ab23c765daaeadc2c2382d0c96f237b95c3c999
setSelector
public Builder setSelector(TreeCacheSelector selector)
{    this.selector = selector;    return this;}
1cdd411d638eca3a07c31767ad8ce3b6e1470c821042746290ca25a8df234059
newBuilder
public static Builder newBuilder(CuratorFramework client, String path)
{    return new Builder(client, path);}
c3ac793f83e46b3b5758ed3eef9dce50d127a1003194862d6a983ad112e9cf3c
isLive
private static boolean isLive(ChildData cd)
{    return cd != null && cd != DEAD;}
4317dc0de617b41fedb0871f06256c7e8e367d4167675db04c89e64955fdd501
refresh
private void refresh() throws Exception
{    if ((depth < maxDepth) && selector.traverseChildren(path)) {        outstandingOps.addAndGet(2);        doRefreshData();        doRefreshChildren();    } else {        refreshData();    }}
5535fe79f64a877244b0e303d806e6cd6fa4de53c8f4eb9d60123a23d3f31805
refreshChildren
private void refreshChildren() throws Exception
{    if ((depth < maxDepth) && selector.traverseChildren(path)) {        outstandingOps.incrementAndGet();        doRefreshChildren();    }}
2ee2602589dce1da91fcc620543441172aedbbb0edcc06e3565e5f85026dfa0b
refreshData
private void refreshData() throws Exception
{    outstandingOps.incrementAndGet();    doRefreshData();}
a71a0b35de09d69881b992313e216d84ca7c03573c36fc5878f04d9efcc1094f
doRefreshChildren
private void doRefreshChildren() throws Exception
{    if (treeState.get() == TreeState.STARTED) {        maybeWatch(client.getChildren()).forPath(path);    }}
09e8a3c432454e7a49fef1ab71f17dcf3ccc3ca08e4a690733d5b9d5b100337f
doRefreshData
private void doRefreshData() throws Exception
{    if (treeState.get() == TreeState.STARTED) {        if (dataIsCompressed) {            maybeWatch(client.getData().decompressed()).forPath(path);        } else {            maybeWatch(client.getData()).forPath(path);        }    }}
dbe1df1354d2b11b4171b24fec91b6b4fca8e5978ed82d0d21a8b683de24fe12
maybeWatch
private Pathable<T> maybeWatch(P dataBuilder)
{    if (disableZkWatches) {        return dataBuilder.inBackground(this);    } else {        return dataBuilder.usingWatcher(this).inBackground(this);    }}
0dd7600ab79ce3138a09c65f60333b37b53aef06200876f2f64dfc43a403fcac
wasReconnected
 void wasReconnected() throws Exception
{    refresh();    ConcurrentMap<String, TreeNode> childMap = children;    if (childMap != null) {        for (TreeNode child : childMap.values()) {            child.wasReconnected();        }    }}
0a1b94846c219e17270b98bf4f8be0204f192d8faea0f9ad0e2aa56e9ba6ab2d
wasCreated
 void wasCreated() throws Exception
{    refresh();}
b92de403a109e5abc00fa1bc133fa64ddc48b9b66ecdc4cb601b212343abf687
wasDeleted
 void wasDeleted() throws Exception
{    ChildData oldChildData = childDataUpdater.getAndSet(this, DEAD);    if (oldChildData == DEAD) {        return;    }    ConcurrentMap<String, TreeNode> childMap = childrenUpdater.getAndSet(this, null);    if (childMap != null) {        ArrayList<TreeNode> childCopy = new ArrayList<TreeNode>(childMap.values());        childMap.clear();        for (TreeNode child : childCopy) {            child.wasDeleted();        }    }    if (treeState.get() == TreeState.CLOSED) {        return;    }    if (isLive(oldChildData)) {        publishEvent(TreeCacheEvent.Type.NODE_REMOVED, oldChildData);    }    if (parent == null) {                maybeWatch(client.checkExists()).forPath(path);    } else {                ConcurrentMap<String, TreeNode> parentChildMap = parent.children;        if (parentChildMap != null) {            parentChildMap.remove(ZKPaths.getNodeFromPath(path), this);        }    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    LOG.debug("process: {}", event);    try {        switch(event.getType()) {            case NodeCreated:                Preconditions.checkState(parent == null, "unexpected NodeCreated on non-root node");                wasCreated();                break;            case NodeChildrenChanged:                refreshChildren();                break;            case NodeDataChanged:                refreshData();                break;            case NodeDeleted:                wasDeleted();                break;        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleException(e);    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    LOG.debug("processResult: {}", event);    Stat newStat = event.getStat();    switch(event.getType()) {        case EXISTS:            Preconditions.checkState(parent == null, "unexpected EXISTS on non-root node");            if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                childDataUpdater.compareAndSet(this, DEAD, null);                wasCreated();            }            break;        case CHILDREN:            if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                ChildData oldChildData = childData;                                if (isLive(oldChildData) && oldChildData.getStat().getMzxid() == newStat.getMzxid()) {                                                            childDataUpdater.compareAndSet(this, oldChildData, new ChildData(oldChildData.getPath(), newStat, oldChildData.getData()));                }                if (event.getChildren().isEmpty()) {                    break;                }                ConcurrentMap<String, TreeNode> childMap = children;                while (childMap == null) {                    childMap = Maps.newConcurrentMap();                    if (!childrenUpdater.compareAndSet(this, null, childMap)) {                        childMap = children;                    }                }                                List<String> newChildren = new ArrayList<String>();                for (String child : event.getChildren()) {                    if (!childMap.containsKey(child) && selector.acceptChild(ZKPaths.makePath(path, child))) {                        newChildren.add(child);                    }                }                Collections.sort(newChildren);                for (String child : newChildren) {                    String fullPath = ZKPaths.makePath(path, child);                    TreeNode node = new TreeNode(fullPath, this);                    if (childMap.putIfAbsent(child, node) == null) {                        node.wasCreated();                    }                }            } else if (event.getResultCode() == KeeperException.Code.NONODE.intValue()) {                wasDeleted();            }            break;        case GET_DATA:            if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                String eventPath = event.getPath();                ChildData toPublish = new ChildData(eventPath, newStat, event.getData());                ChildData toUpdate = cacheData ? toPublish : new ChildData(eventPath, newStat, null);                while (true) {                    final ChildData oldChildData = childData;                                        if (isLive(oldChildData) && newStat.getMzxid() <= oldChildData.getStat().getMzxid()) {                        break;                    }                                        if (parent != null && oldChildData == DEAD) {                        break;                    }                    if (childDataUpdater.compareAndSet(this, oldChildData, toUpdate)) {                        publishEvent(isLive(oldChildData) ? TreeCacheEvent.Type.NODE_UPDATED : TreeCacheEvent.Type.NODE_ADDED, toPublish);                        break;                    }                }            } else if (event.getResultCode() == KeeperException.Code.NONODE.intValue()) {                wasDeleted();            }            break;        default:                        LOG.info(String.format("Unknown event %s", event));                        outstandingOps.decrementAndGet();            return;    }    if (outstandingOps.decrementAndGet() == 0) {        if (isInitialized.compareAndSet(false, true)) {            publishEvent(TreeCacheEvent.Type.INITIALIZED);        }    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    handleStateChange(newState);}
17ffb43d42797f16033a4369360301756a8cb4b8c63af4b7cb53bfb005863aad
start
public TreeCache start() throws Exception
{    Preconditions.checkState(treeState.compareAndSet(TreeState.LATENT, TreeState.STARTED), "already started");    if (createParentNodes) {        client.createContainers(root.path);    }    client.getConnectionStateListenable().addListener(connectionStateListener);    if (client.getZookeeperClient().isConnected()) {        root.wasCreated();    }    return this;}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    if (treeState.compareAndSet(TreeState.STARTED, TreeState.CLOSED)) {        client.removeWatchers();        client.getConnectionStateListenable().removeListener(connectionStateListener);        listeners.clear();        executorService.shutdown();        try {            root.wasDeleted();        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);            handleException(e);        }    }}
935e26dc205c896853a538f0fbb06b39193d9bbab92fbb4602e507be6435b0a9
getListenable
public Listenable<TreeCacheListener> getListenable()
{    return listeners;}
b3d8c32fff49d6f84e3a03fa63c3aa3356dba76f0989aaae6638b46c12e3fdb0
getUnhandledErrorListenable
public Listenable<UnhandledErrorListener> getUnhandledErrorListenable()
{    return errorListeners;}
daf2da116073b6bab3341d2121906fb233fb8737d962ae6a5805e9a4292c3061
find
private TreeNode find(String findPath)
{    PathUtils.validatePath(findPath);    LinkedList<String> rootElements = new LinkedList<String>(ZKPaths.split(root.path));    LinkedList<String> findElements = new LinkedList<String>(ZKPaths.split(findPath));    while (!rootElements.isEmpty()) {        if (findElements.isEmpty()) {                        return null;        }        String nextRoot = rootElements.removeFirst();        String nextFind = findElements.removeFirst();        if (!nextFind.equals(nextRoot)) {                        return null;        }    }    TreeNode current = root;    while (!findElements.isEmpty()) {        String nextFind = findElements.removeFirst();        ConcurrentMap<String, TreeNode> map = current.children;        if (map == null) {            return null;        }        current = map.get(nextFind);        if (current == null) {            return null;        }    }    return current;}
c4cadfcf3be5f116835883e7b392de57cc5298e096d96803c235c1864976a7a9
getCurrentChildren
public Map<String, ChildData> getCurrentChildren(String fullPath)
{    TreeNode node = find(fullPath);    if (node == null || !isLive(node.childData)) {        return null;    }    ConcurrentMap<String, TreeNode> map = node.children;    Map<String, ChildData> result;    if (map == null) {        result = ImmutableMap.of();    } else {        ImmutableMap.Builder<String, ChildData> builder = ImmutableMap.builder();        for (Map.Entry<String, TreeNode> entry : map.entrySet()) {            ChildData childData = entry.getValue().childData;                        if (isLive(childData)) {                builder.put(entry.getKey(), childData);            }        }        result = builder.build();    }        return isLive(node.childData) ? result : null;}
9ca704b3c7a251866a5d064ce2bddfce7e0a2d2d85b03da7bb427b562470a6aa
getCurrentData
public ChildData getCurrentData(String fullPath)
{    TreeNode node = find(fullPath);    if (node == null) {        return null;    }    ChildData result = node.childData;    return isLive(result) ? result : null;}
0b070adb65fbb563cc56b7156408155e587aa658ac20acc97e32dcc1614137d2
callListeners
private void callListeners(final TreeCacheEvent event)
{    listeners.forEach(new Function<TreeCacheListener, Void>() {        @Override        public Void apply(TreeCacheListener listener) {            try {                listener.childEvent(client, event);            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                handleException(e);            }            return null;        }    });}
4e0042e90fdf96dd46ac7c72ddfc3c1e11a5084a41b86c5148c7ff2b1f4d03c0
apply
public Void apply(TreeCacheListener listener)
{    try {        listener.childEvent(client, event);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleException(e);    }    return null;}
641e08b3402032b10df1e02d289db1468c92b559bddca803b8bda2a643f7b5a7
handleException
private void handleException(final Throwable e)
{    if (errorListeners.size() == 0) {        LOG.error("", e);    } else {        errorListeners.forEach(new Function<UnhandledErrorListener, Void>() {            @Override            public Void apply(UnhandledErrorListener listener) {                try {                    listener.unhandledError("", e);                } catch (Exception e) {                    ThreadUtils.checkInterrupted(e);                    LOG.error("Exception handling exception", e);                }                return null;            }        });    }}
35bf1c3292901c360d30d3d51fb60adad56e49953b606718329eb66af1fef60f
apply
public Void apply(UnhandledErrorListener listener)
{    try {        listener.unhandledError("", e);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        LOG.error("Exception handling exception", e);    }    return null;}
8c06c26f04c887210d8d9aaa6e3c8efbdeb0381710c1cd9b2efbb55dc61af0c0
handleStateChange
private void handleStateChange(ConnectionState newState)
{    switch(newState) {        case SUSPENDED:            publishEvent(TreeCacheEvent.Type.CONNECTION_SUSPENDED);            break;        case LOST:            isInitialized.set(false);            publishEvent(TreeCacheEvent.Type.CONNECTION_LOST);            break;        case CONNECTED:            try {                root.wasCreated();            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                handleException(e);            }            break;        case RECONNECTED:            try {                root.wasReconnected();                publishEvent(TreeCacheEvent.Type.CONNECTION_RECONNECTED);            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                handleException(e);            }            break;    }}
b7e4950dab13097532cb3b52dc3a888cf0c3c412e88a4c6a82828e3a959abc51
publishEvent
private void publishEvent(TreeCacheEvent.Type type)
{    publishEvent(new TreeCacheEvent(type, null));}
c17cb050d4ba0cc82f43ffb814be04494de503dbbfa338d112700d9d221d2eda
publishEvent
private void publishEvent(TreeCacheEvent.Type type, ChildData data)
{    publishEvent(new TreeCacheEvent(type, data));}
6e399969e2a15a2aa3426fc7ff2b95cc5663af267660e6236cc306f9778b7243
publishEvent
private void publishEvent(final TreeCacheEvent event)
{    if (treeState.get() != TreeState.CLOSED) {        LOG.debug("publishEvent: {}", event);        executorService.submit(new Runnable() {            @Override            public void run() {                try {                    callListeners(event);                } catch (Exception e) {                    ThreadUtils.checkInterrupted(e);                    handleException(e);                }            }        });    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        callListeners(event);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        handleException(e);    }}
b36c0cb78d388571653840506cba5d90e12b262c755658912fc2224c314bcbf6
getType
public Type getType()
{    return type;}
b5ccbe96d3ea71a37d30b982195ead474da2e7dd985ecda146e59432b6fe4fb9
getData
public ChildData getData()
{    return data;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return TreeCacheEvent.class.getSimpleName() + "{" + "type=" + type + ", data=" + data + '}';}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    handleStateChange(newState);}
2ca37aecb7b6d50b96d16e509436bd8fcd1ce1da9670ebeab2a9fb863c384b3c
fixForSorting
public String fixForSorting(String str, String lockName)
{    return StandardLockInternalsDriver.standardFixForSorting(str, lockName);}
90ba0dddc593bd95e2a0c0c039c523b81bfb91f87814ebcb222c3914ca772ead
start
public void start() throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    startTask.set(AfterConnectionEstablished.execute(client, new Runnable() {        @Override        public void run() {            try {                internalStart();            } finally {                startTask.set(null);            }        }    }));}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        internalStart();    } finally {        startTask.set(null);    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    close(closeMode);}
f47d714f89b42b899e7026c22859d453611ae3e0c186fb3f376e4125fa777f40
close
public synchronized void close(CloseMode closeMode) throws IOException
{    Preconditions.checkState(state.compareAndSet(State.STARTED, State.CLOSED), "Already closed or has not been started");    Preconditions.checkNotNull(closeMode, "closeMode cannot be null");    cancelStartTask();    try {        setNode(null);        client.removeWatchers();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new IOException(e);    } finally {        client.getConnectionStateListenable().removeListener(listener);        switch(closeMode) {            case NOTIFY_LEADER:                {                    setLeadership(false);                    listeners.clear();                    break;                }            default:                {                    listeners.clear();                    setLeadership(false);                    break;                }        }    }}
d2fc38a68fc298ff7f5574735d7007394f37a3fb13b846bdffa5dcdc2e7beca0
cancelStartTask
protected boolean cancelStartTask()
{    Future<?> localStartTask = startTask.getAndSet(null);    if (localStartTask != null) {        localStartTask.cancel(true);        return true;    }    return false;}
fb2c1c6a6074b4219d0cc3b1f6aab32eb55c2b42d022c46027b23a05a4b16564
addListener
public void addListener(LeaderLatchListener listener)
{    listeners.addListener(listener);}
ad4bd8d91becdedef287cee90d24620077a20e180f4a642e47c2ec9983ea06a9
addListener
public void addListener(LeaderLatchListener listener, Executor executor)
{    listeners.addListener(listener, executor);}
f42242f2733f1c992d2c5947ede298c21521a0af84c78dd7550cde67f27a4422
removeListener
public void removeListener(LeaderLatchListener listener)
{    listeners.removeListener(listener);}
70ebf35779959b6fb2230ea1e9dc6357ff3885fa7452ead488fd135891a061ff
await
public void await() throws InterruptedException, EOFException
{    synchronized (this) {        while ((state.get() == State.STARTED) && !hasLeadership.get()) {            wait();        }    }    if (state.get() != State.STARTED) {        throw new EOFException();    }}
aec691ac572613f6470369e9ac9b55730842d059f64adb4aca8408ea91746578
await
public boolean await(long timeout, TimeUnit unit) throws InterruptedException
{    long waitNanos = TimeUnit.NANOSECONDS.convert(timeout, unit);    synchronized (this) {        while (true) {            if (state.get() != State.STARTED) {                return false;            }            if (hasLeadership()) {                return true;            }            if (waitNanos <= 0) {                return false;            }            long startNanos = System.nanoTime();            TimeUnit.NANOSECONDS.timedWait(this, waitNanos);            long elapsed = System.nanoTime() - startNanos;            waitNanos -= elapsed;        }    }}
09e8f13a9a603d31d64bb498b77d15572483824d843d0e82a570643192f62186
getId
public String getId()
{    return id;}
25732bf4689a2f9e30b003ed7ca49c4862da4931f831c5d1f6b63d803ca45d30
getState
public State getState()
{    return state.get();}
ce3e7c99f718200e7a14eaf0262ea54b222fcfd0f2673c10535f344387ba066c
getParticipants
public Collection<Participant> getParticipants() throws Exception
{    Collection<String> participantNodes = LockInternals.getParticipantNodes(client, latchPath, LOCK_NAME, sorter);    return LeaderSelector.getParticipants(client, participantNodes);}
a2ddbfe39be85b17a7eefd881bc28b65608d8b94c4a182cd194f759803c17584
getLeader
public Participant getLeader() throws Exception
{    Collection<String> participantNodes = LockInternals.getParticipantNodes(client, latchPath, LOCK_NAME, sorter);    return LeaderSelector.getLeader(client, participantNodes);}
d2b5a3e660bdfe13d8d3e3e17cd6b8819a8f781aff061a1c7604523d7f551da5
hasLeadership
public boolean hasLeadership()
{    return (state.get() == State.STARTED) && hasLeadership.get();}
b8f00567ce1ec5043e122f2412cb3e3292d88dbaf98791242839bef0d902f3ca
getOurPath
public String getOurPath()
{    return ourPath.get();}
922a27998ffa2d361afe12609da246c21073c9ed1662bab9de7bb303c29ab236
reset
 void reset() throws Exception
{    setLeadership(false);    setNode(null);    BackgroundCallback callback = new BackgroundCallback() {        @Override        public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {            if (debugResetWaitLatch != null) {                debugResetWaitLatch.await();                debugResetWaitLatch = null;            }            if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                setNode(event.getName());                if (state.get() == State.CLOSED) {                    setNode(null);                } else {                    getChildren();                }            } else {                log.error("getChildren() failed. rc = " + event.getResultCode());            }        }    };    client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).inBackground(callback).forPath(ZKPaths.makePath(latchPath, LOCK_NAME), LeaderSelector.getIdBytes(id));}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (debugResetWaitLatch != null) {        debugResetWaitLatch.await();        debugResetWaitLatch = null;    }    if (event.getResultCode() == KeeperException.Code.OK.intValue()) {        setNode(event.getName());        if (state.get() == State.CLOSED) {            setNode(null);        } else {            getChildren();        }    } else {        log.error("getChildren() failed. rc = " + event.getResultCode());    }}
13971e452fe121a739340573f989db594b6f1ad5394493127afa58c0778457de
internalStart
private synchronized void internalStart()
{    if (state.get() == State.STARTED) {        client.getConnectionStateListenable().addListener(listener);        try {            reset();        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);            log.error("An error occurred checking resetting leadership.", e);        }    }}
5f052b684f6f5948c8b899a59cb5ee83fa93f7dea685605bc4aeffffe66378d7
checkLeadership
private void checkLeadership(List<String> children) throws Exception
{    if (debugCheckLeaderShipLatch != null) {        debugCheckLeaderShipLatch.await();    }    final String localOurPath = ourPath.get();    List<String> sortedChildren = LockInternals.getSortedChildren(LOCK_NAME, sorter, children);    int ourIndex = (localOurPath != null) ? sortedChildren.indexOf(ZKPaths.getNodeFromPath(localOurPath)) : -1;    if (ourIndex < 0) {        log.error("Can't find our node. Resetting. Index: " + ourIndex);        reset();    } else if (ourIndex == 0) {        setLeadership(true);    } else {        String watchPath = sortedChildren.get(ourIndex - 1);        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                if ((state.get() == State.STARTED) && (event.getType() == Event.EventType.NodeDeleted) && (localOurPath != null)) {                    try {                        getChildren();                    } catch (Exception ex) {                        ThreadUtils.checkInterrupted(ex);                        log.error("An error occurred checking the leadership.", ex);                    }                }            }        };        BackgroundCallback callback = new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                if (event.getResultCode() == KeeperException.Code.NONODE.intValue()) {                                        reset();                }            }        };                client.getData().usingWatcher(watcher).inBackground(callback).forPath(ZKPaths.makePath(latchPath, watchPath));    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if ((state.get() == State.STARTED) && (event.getType() == Event.EventType.NodeDeleted) && (localOurPath != null)) {        try {            getChildren();        } catch (Exception ex) {            ThreadUtils.checkInterrupted(ex);            log.error("An error occurred checking the leadership.", ex);        }    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getResultCode() == KeeperException.Code.NONODE.intValue()) {                reset();    }}
7baadbb9546335d2230bd07a7eb27dd3c063629b6c1d3917eadba82a256af2f7
getChildren
private void getChildren() throws Exception
{    BackgroundCallback callback = new BackgroundCallback() {        @Override        public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {            if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                checkLeadership(event.getChildren());            }        }    };    client.getChildren().inBackground(callback).forPath(ZKPaths.makePath(latchPath, null));}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getResultCode() == KeeperException.Code.OK.intValue()) {        checkLeadership(event.getChildren());    }}
0b14149ab076fe69681b1eb7701980c464fd3bab3ddd4e305914519de05167a3
handleStateChange
protected void handleStateChange(ConnectionState newState)
{    switch(newState) {        default:            {                                break;            }        case RECONNECTED:            {                try {                    if (client.getConnectionStateErrorPolicy().isErrorState(ConnectionState.SUSPENDED) || !hasLeadership.get()) {                        reset();                    }                } catch (Exception e) {                    ThreadUtils.checkInterrupted(e);                    log.error("Could not reset leader latch", e);                    setLeadership(false);                }                break;            }        case SUSPENDED:            {                if (client.getConnectionStateErrorPolicy().isErrorState(ConnectionState.SUSPENDED)) {                    setLeadership(false);                }                break;            }        case LOST:            {                setLeadership(false);                break;            }    }}
e20940f884f87417ee1374c3fc7f89208dc1bba6ab735ecd4fb80660b0ca3680
setLeadership
private synchronized void setLeadership(boolean newValue)
{    boolean oldValue = hasLeadership.getAndSet(newValue);    if (oldValue && !newValue) {                listeners.forEach(new Function<LeaderLatchListener, Void>() {            @Override            public Void apply(LeaderLatchListener listener) {                listener.notLeader();                return null;            }        });    } else if (!oldValue && newValue) {                listeners.forEach(new Function<LeaderLatchListener, Void>() {            @Override            public Void apply(LeaderLatchListener input) {                input.isLeader();                return null;            }        });    }    notifyAll();}
8dca980012d5c3fd267b00c4afcbf215affa656a7875f6774cbd194545687fcc
apply
public Void apply(LeaderLatchListener listener)
{    listener.notLeader();    return null;}
7c7b43f2de70d73b9c6e59aac002de2d23ae6079e8ef8fc1ea4027cbb22a94b2
apply
public Void apply(LeaderLatchListener input)
{    input.isLeader();    return null;}
3265cacedb87db98994f63adf229accf3ae3c17c89b8adc95c6fa15f6e9f00f2
setNode
private void setNode(String newValue) throws Exception
{    String oldPath = ourPath.getAndSet(newValue);    if (oldPath != null) {        client.delete().guaranteed().inBackground().forPath(oldPath);    }}
9924044de1e900451df539c88d66e635743f1a2fa594ffa6f12e8a2db63bf274
getLockNodeBytes
protected byte[] getLockNodeBytes()
{    return (id.length() > 0) ? getIdBytes(id) : null;}
dce3476b778ff82b7c9ad7832e7a0244b289e458f9971835f5a5f6ffc7956c47
getIdBytes
 static byte[] getIdBytes(String id)
{    try {        return id.getBytes("UTF-8");    } catch (UnsupportedEncodingException e) {                throw new Error(e);    }}
e2925282c376b297701e2a3b0ff31bbb33947077e857ec615e71b95a6b05d836
autoRequeue
public void autoRequeue()
{    autoRequeue.set(true);}
ef03857fdefb7c5e949826b070dcbdc52b14cca8f50e0c7e1f5da4ee7e390f1a
setId
public void setId(String id)
{    Preconditions.checkNotNull(id, "id cannot be null");    this.id = id;}
09e8f13a9a603d31d64bb498b77d15572483824d843d0e82a570643192f62186
getId
public String getId()
{    return id;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    Preconditions.checkState(!executorService.isShutdown(), "Already started");    Preconditions.checkState(!hasLeadership, "Already has leadership");    client.getConnectionStateListenable().addListener(listener);    requeue();}
177bde75d4170c21887a154a16f2b461d7f97deaa742a0ac7e8b05eb7f18910e
requeue
public boolean requeue()
{    Preconditions.checkState(state.get() == State.STARTED, "close() has already been called");    return internalRequeue();}
e340535b1566ce5faab3f67560c5c64ed66bb4567e645a94d349af0d5cc9a096
internalRequeue
private synchronized boolean internalRequeue()
{    if (!isQueued && (state.get() == State.STARTED)) {        isQueued = true;        Future<Void> task = executorService.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                try {                    doWorkLoop();                } finally {                    clearIsQueued();                    if (autoRequeue.get()) {                        internalRequeue();                    }                }                return null;            }        });        ourTask.set(task);        return true;    }    return false;}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    try {        doWorkLoop();    } finally {        clearIsQueued();        if (autoRequeue.get()) {            internalRequeue();        }    }    return null;}
1634b5aa1082b112f2c3bd6adf76e79a763f622542a36ea905f99d4c25d3c562
close
public synchronized void close()
{    Preconditions.checkState(state.compareAndSet(State.STARTED, State.CLOSED), "Already closed or has not been started");    client.getConnectionStateListenable().removeListener(listener);    executorService.close();    ourTask.set(null);}
ce3e7c99f718200e7a14eaf0262ea54b222fcfd0f2673c10535f344387ba066c
getParticipants
public Collection<Participant> getParticipants() throws Exception
{    Collection<String> participantNodes = mutex.getParticipantNodes();    return getParticipants(client, participantNodes);}
4fad3a123f2f09a97161ab4cff4da37012cb6c95fe73e781c2c19ae5d15b3a90
getParticipants
 static Collection<Participant> getParticipants(CuratorFramework client, Collection<String> participantNodes) throws Exception
{    ImmutableList.Builder<Participant> builder = ImmutableList.builder();    boolean isLeader = true;    for (String path : participantNodes) {        Participant participant = participantForPath(client, path, isLeader);        if (participant != null) {            builder.add(participant);                        isLeader = false;        }    }    return builder.build();}
a2ddbfe39be85b17a7eefd881bc28b65608d8b94c4a182cd194f759803c17584
getLeader
public Participant getLeader() throws Exception
{    Collection<String> participantNodes = mutex.getParticipantNodes();    return getLeader(client, participantNodes);}
729fdaa7017958ada7f03973135c296abf4bedbcdad02c3f8f1bf08b0d0e18a7
getLeader
 static Participant getLeader(CuratorFramework client, Collection<String> participantNodes) throws Exception
{    Participant result = null;    if (participantNodes.size() > 0) {        Iterator<String> iter = participantNodes.iterator();        while (iter.hasNext()) {            result = participantForPath(client, iter.next(), true);            if (result != null) {                break;            }        }    }    if (result == null) {        result = new Participant();    }    return result;}
d2b5a3e660bdfe13d8d3e3e17cd6b8819a8f781aff061a1c7604523d7f551da5
hasLeadership
public boolean hasLeadership()
{    return hasLeadership;}
1593fb38c5b7a669d3130998f618e543906d83096a1c2a1137c122964b4d0692
interruptLeadership
public synchronized void interruptLeadership()
{    Future<?> task = ourTask.get();    if (task != null) {        task.cancel(true);    }}
f9667d21dee49ca5a0922a759ecd4c5cea7a7b17623e83ea19bec256551b9c22
participantForPath
private static Participant participantForPath(CuratorFramework client, String path, boolean markAsLeader) throws Exception
{    try {        byte[] bytes = client.getData().forPath(path);        String thisId = new String(bytes, "UTF-8");        return new Participant(thisId, markAsLeader);    } catch (KeeperException.NoNodeException e) {        return null;    }}
3d9630e49e039b490dece26c5d4a508f269fa7ac3149d590725076afdc8ce37d
doWork
 void doWork() throws Exception
{    hasLeadership = false;    try {        mutex.acquire();        hasLeadership = true;        try {            if (debugLeadershipLatch != null) {                debugLeadershipLatch.countDown();            }            if (debugLeadershipWaitLatch != null) {                debugLeadershipWaitLatch.await();            }            listener.takeLeadership(client);        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            throw e;        } catch (Throwable e) {            ThreadUtils.checkInterrupted(e);        } finally {            clearIsQueued();        }    } catch (InterruptedException e) {        Thread.currentThread().interrupt();        throw e;    } finally {        if (hasLeadership) {            hasLeadership = false;                        boolean wasInterrupted = Thread.interrupted();            try {                mutex.release();            } catch (Exception e) {                if (failedMutexReleaseCount != null) {                    failedMutexReleaseCount.incrementAndGet();                }                ThreadUtils.checkInterrupted(e);                log.error("The leader threw an exception", e);                        } finally {                if (wasInterrupted) {                    Thread.currentThread().interrupt();                }            }        }    }}
7680e0b907189d03606a0b5093853104039d41642b0690eddac6c2c008af506a
doWorkLoop
private void doWorkLoop() throws Exception
{    KeeperException exception = null;    try {        doWork();    } catch (KeeperException.ConnectionLossException e) {        exception = e;    } catch (KeeperException.SessionExpiredException e) {        exception = e;    } catch (InterruptedException ignore) {        Thread.currentThread().interrupt();    }    if (    (exception != null) && !autoRequeue.get()) {        throw exception;    }}
759fee404d04e5e452d5ca7c7105ea3947c2775baa15b8f8757fca482484dfa0
clearIsQueued
private synchronized void clearIsQueued()
{    isQueued = false;}
3ac59670c4956c98603c5c77dbd600c895e591b78bfb40693b61f39f595fb207
wrapExecutor
private static ExecutorService wrapExecutor(final Executor executor)
{    return new AbstractExecutorService() {        private volatile boolean isShutdown = false;        private volatile boolean isTerminated = false;        @Override        public void shutdown() {            isShutdown = true;        }        @Override        public List<Runnable> shutdownNow() {            return Lists.newArrayList();        }        @Override        public boolean isShutdown() {            return isShutdown;        }        @Override        public boolean isTerminated() {            return isTerminated;        }        @Override        public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {            throw new UnsupportedOperationException();        }        @Override        public void execute(Runnable command) {            try {                executor.execute(command);            } finally {                isShutdown = true;                isTerminated = true;            }        }    };}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    isShutdown = true;}
4c45ee4d9eb054ebd067dd5874751b7bfc3a2cf2eb45214279db5bb2815019b3
shutdownNow
public List<Runnable> shutdownNow()
{    return Lists.newArrayList();}
de15ce9b0ad9865c54a52f6c64043391e5b29feda58b57b6926cb3d5b0e7aeb8
isShutdown
public boolean isShutdown()
{    return isShutdown;}
a7705ddf21784ead75c5c8f226430ffc5611289fd8b0395c0e703726e9e0c05f
isTerminated
public boolean isTerminated()
{    return isTerminated;}
0914a9f004463fdc403eb8812a27433de347d542e24b38c16435c5081f5e4e41
awaitTermination
public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException
{    throw new UnsupportedOperationException();}
ad84c13a4b48a71ac9cc53c212690071850fba3a6bebe8ae99378f76de235551
execute
public void execute(Runnable command)
{    try {        executor.execute(command);    } finally {        isShutdown = true;        isTerminated = true;    }}
572980c734fcdd22464cc98d1931013f84abfc71246389b062e7e113e357572e
takeLeadership
public void takeLeadership(CuratorFramework client) throws Exception
{    listener.takeLeadership(client);}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    try {        listener.stateChanged(client, newState);    } catch (CancelLeadershipException dummy) {        leaderSelector.interruptLeadership();    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (client.getConnectionStateErrorPolicy().isErrorState(newState)) {        throw new CancelLeadershipException();    }}
09e8f13a9a603d31d64bb498b77d15572483824d843d0e82a570643192f62186
getId
public String getId()
{    return id;}
261b1d5329a359f54179b707447d10aad0876e9640502da1514ed8a1925a3d54
isLeader
public boolean isLeader()
{    return isLeader;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "Participant{" + "id='" + id + '\'' + ", isLeader=" + isLeader + '}';}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    Participant that = (Participant) o;    if (isLeader != that.isLeader) {        return false;    }    if (!id.equals(that.id)) {        return false;    }    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = id.hashCode();    result = 31 * result + (isLeader ? 1 : 0);    return result;}
90ba0dddc593bd95e2a0c0c039c523b81bfb91f87814ebcb222c3914ca772ead
start
public void start() throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    task = executor.scheduleWithFixedDelay(new Runnable() {        @Override        public void run() {            doWork();        }    }, reapingThresholdMs, reapingThresholdMs, TimeUnit.MILLISECONDS);    if (leaderLatch != null) {        leaderLatch.start();    }    reaper.start();}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    doWork();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    if (state.compareAndSet(State.STARTED, State.CLOSED)) {        CloseableUtils.closeQuietly(reaper);        if (leaderLatch != null) {            CloseableUtils.closeQuietly(leaderLatch);        }        task.cancel(true);    }}
fd0530e59c9cb93a1378886c536c6af3000786b0b03f5c025b0eb7e263264db6
addPath
public ChildReaper addPath(String path)
{    paths.add(PathUtils.validatePath(path));    return this;}
87f6a7175ee706d0487e3c48db8dc782dcb441f81efb244a72fdc6fdbf962fd4
removePath
public boolean removePath(String path)
{    return paths.remove(PathUtils.validatePath(path));}
20142ff4453e0c136b7de9762efef86eabb495ba183e5cbf21847702cd615461
setMaxChildren
public void setMaxChildren(int maxChildren)
{    this.maxChildren.set(maxChildren);}
be5673c8428dd5f3a8ae3e2a26cbbd3211695f422705854f80f12e400f716cae
newExecutorService
public static ScheduledExecutorService newExecutorService()
{    return ThreadUtils.newFixedThreadScheduledPool(2, "ChildReaper");}
b2d3fe2ef189346bd0fb917b0edb79d2b9756abbf21bf1f506e5275adf58097c
warnMaxChildren
protected void warnMaxChildren(String path, Stat stat)
{    log.warn(String.format("Skipping %s as it has too many children: %d", path, stat.getNumChildren()));}
0c2c9b2d21d37ec98de145f3465d8b991facb850a3031a5f0f27575bc1fadc9d
doWork
private void doWork()
{    if (shouldDoWork()) {        if ((pathIterator == null) || !pathIterator.hasNext()) {            pathIterator = paths.iterator();        }        while (pathIterator.hasNext()) {            String path = pathIterator.next();            try {                int maxChildren = this.maxChildren.get();                if (maxChildren > 0) {                    Stat stat = client.checkExists().forPath(path);                    if ((stat != null) && (stat.getNumChildren() > maxChildren)) {                        warnMaxChildren(path, stat);                        continue;                    }                }                List<String> children = client.getChildren().forPath(path);                log.info(String.format("Found %d children for %s", children.size(), path));                for (String name : children) {                    String childPath = ZKPaths.makePath(path, name);                    addPathToReaperIfEmpty(childPath);                    for (String subNode : lockSchema) {                        addPathToReaperIfEmpty(ZKPaths.makePath(childPath, subNode));                    }                }            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                log.error("Could not get children for path: " + path, e);            }        }    }}
1480e35a618282b4cf859e81ec28ddf858ddade1325ac58ab02e89d4a4811127
addPathToReaperIfEmpty
private void addPathToReaperIfEmpty(String path) throws Exception
{    Stat stat = client.checkExists().forPath(path);    if ((stat != null) && (stat.getNumChildren() == 0)) {        log.info("Adding " + path);        reaper.addPath(path, mode);    }}
c14fb254817c4562f26896d295827b5dce94793e560d8b9fcbd477fc614edf50
shouldDoWork
private boolean shouldDoWork()
{    return this.leaderLatch == null || this.leaderLatch.hasLeadership();}
3bf764f016c26d8499e724815c1325a3a1ee7ab699c1cac630f76e7aa0a5dbfe
makeLocks
private static List<InterProcessLock> makeLocks(CuratorFramework client, List<String> paths)
{    ImmutableList.Builder<InterProcessLock> builder = ImmutableList.builder();    for (String path : paths) {        InterProcessLock lock = new InterProcessMutex(client, path);        builder.add(lock);    }    return builder.build();}
6ed01f514324c2abdcf4abfde4f82ec6a096b3dc9765c28e667f9ae924b4ecba
acquire
public void acquire() throws Exception
{    acquire(-1, null);}
e84db03b70d95fa516f1561b83f3738c78a129a52a8adede3d11a5b2bbfd3a21
acquire
public boolean acquire(long time, TimeUnit unit) throws Exception
{    Exception exception = null;    List<InterProcessLock> acquired = Lists.newArrayList();    boolean success = true;    for (InterProcessLock lock : locks) {        try {            if (unit == null) {                lock.acquire();                acquired.add(lock);            } else {                if (lock.acquire(time, unit)) {                    acquired.add(lock);                } else {                    success = false;                    break;                }            }        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);            success = false;            exception = e;        }    }    if (!success) {        for (InterProcessLock lock : reverse(acquired)) {            try {                lock.release();            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                        }        }    }    if (exception != null) {        throw exception;    }    return success;}
2187182fd29f91ee50dbcfccb36eca8ff23e4babb9314492e149031ef6797143
release
public synchronized void release() throws Exception
{    Exception baseException = null;    for (InterProcessLock lock : reverse(locks)) {        try {            lock.release();        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);            if (baseException == null) {                baseException = e;            } else {                baseException = new Exception(baseException);            }        }    }    if (baseException != null) {        throw baseException;    }}
4696ad371d8e332c24fbe5e0d31046c97f54040994718a0eb6f3fd12a2efa7cd
isAcquiredInThisProcess
public synchronized boolean isAcquiredInThisProcess()
{    for (InterProcessLock lock : locks) {        if (!lock.isAcquiredInThisProcess()) {            return false;        }    }    return true;}
6ed01f514324c2abdcf4abfde4f82ec6a096b3dc9765c28e667f9ae924b4ecba
acquire
public void acquire() throws Exception
{    if (!internalLock(-1, null)) {        throw new IOException("Lost connection while trying to acquire lock: " + basePath);    }}
e84db03b70d95fa516f1561b83f3738c78a129a52a8adede3d11a5b2bbfd3a21
acquire
public boolean acquire(long time, TimeUnit unit) throws Exception
{    return internalLock(time, unit);}
745d135b8331357b385fbaa7e0423401f2ab75f33e409e679d1ef190a299a7e1
isAcquiredInThisProcess
public boolean isAcquiredInThisProcess()
{    return (threadData.size() > 0);}
416a94a1896246da1af92845d0098abfbff6e67323e4afe5a7de2f1dccecf83a
release
public void release() throws Exception
{    /*            Note on concurrency: a given lockData instance            can be only acted on by a single thread so locking isn't necessary         */    Thread currentThread = Thread.currentThread();    LockData lockData = threadData.get(currentThread);    if (lockData == null) {        throw new IllegalMonitorStateException("You do not own the lock: " + basePath);    }    int newLockCount = lockData.lockCount.decrementAndGet();    if (newLockCount > 0) {        return;    }    if (newLockCount < 0) {        throw new IllegalMonitorStateException("Lock count has gone negative for lock: " + basePath);    }    try {        internals.releaseLock(lockData.lockPath);    } finally {        threadData.remove(currentThread);    }}
7a26efa913664025c50b0093570c38763b104a386800c040efd6caf507a38ac8
getParticipantNodes
public Collection<String> getParticipantNodes() throws Exception
{    return LockInternals.getParticipantNodes(internals.getClient(), basePath, internals.getLockName(), internals.getDriver());}
1a629e47827388cd7c7d59aacacf936d6bbde7e09380bbf1845578769a30a232
makeRevocable
public void makeRevocable(RevocationListener<InterProcessMutex> listener)
{    makeRevocable(listener, MoreExecutors.directExecutor());}
0f4aabe5d47fbc5c011c4f175b4c06dfc60ce1b3d74fe1cea6db242b1a4e1561
makeRevocable
public void makeRevocable(final RevocationListener<InterProcessMutex> listener, Executor executor)
{    internals.makeRevocable(new RevocationSpec(executor, new Runnable() {        @Override        public void run() {            listener.revocationRequested(InterProcessMutex.this);        }    }));}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    listener.revocationRequested(InterProcessMutex.this);}
ff166f603179ffcf9f07c3620ce78dd047710d24cc1eb424584499941677d9a6
isOwnedByCurrentThread
public boolean isOwnedByCurrentThread()
{    LockData lockData = threadData.get(Thread.currentThread());    return (lockData != null) && (lockData.lockCount.get() > 0);}
9924044de1e900451df539c88d66e635743f1a2fa594ffa6f12e8a2db63bf274
getLockNodeBytes
protected byte[] getLockNodeBytes()
{    return null;}
c3627a6102cb7f457e75d361dddf2067ac03f8540008eda55def433bb3040558
getLockPath
protected String getLockPath()
{    LockData lockData = threadData.get(Thread.currentThread());    return lockData != null ? lockData.lockPath : null;}
64f0397dac6a8e0ac29b0251d5ff08369c5218e1fc0ca13e3452d3f7831be2de
internalLock
private boolean internalLock(long time, TimeUnit unit) throws Exception
{    /*           Note on concurrency: a given lockData instance           can be only acted on by a single thread so locking isn't necessary        */    Thread currentThread = Thread.currentThread();    LockData lockData = threadData.get(currentThread);    if (lockData != null) {                lockData.lockCount.incrementAndGet();        return true;    }    String lockPath = internals.attemptLock(time, unit, getLockNodeBytes());    if (lockPath != null) {        LockData newLockData = new LockData(currentThread, lockPath);        threadData.put(currentThread, newLockData);        return true;    }    return false;}
216bc050fade1c739b5808384fdbc3a02d04995443a812b5c618da550054ed21
fixForSorting
public final String fixForSorting(String str, String lockName)
{    str = super.fixForSorting(str, READ_LOCK_NAME);    str = super.fixForSorting(str, WRITE_LOCK_NAME);    return str;}
7a26efa913664025c50b0093570c38763b104a386800c040efd6caf507a38ac8
getParticipantNodes
public Collection<String> getParticipantNodes() throws Exception
{    Collection<String> nodes = super.getParticipantNodes();    Iterable<String> filtered = Iterables.filter(nodes, new Predicate<String>() {        @Override        public boolean apply(String node) {            return node.contains(lockName);        }    });    return ImmutableList.copyOf(filtered);}
4fdd4d370c58e169c3d863658606249773c8a66af4a7b4876208471bafca88bd
apply
public boolean apply(String node)
{    return node.contains(lockName);}
9924044de1e900451df539c88d66e635743f1a2fa594ffa6f12e8a2db63bf274
getLockNodeBytes
protected byte[] getLockNodeBytes()
{    return lockData;}
780efcf91497f90cf23ec420ad24e2f5ab49707cfed51b2c3672fd65672190f2
getsTheLock
public PredicateResults getsTheLock(CuratorFramework client, List<String> children, String sequenceNodeName, int maxLeases) throws Exception
{    return super.getsTheLock(client, children, sequenceNodeName, maxLeases);}
780efcf91497f90cf23ec420ad24e2f5ab49707cfed51b2c3672fd65672190f2
getsTheLock
public PredicateResults getsTheLock(CuratorFramework client, List<String> children, String sequenceNodeName, int maxLeases) throws Exception
{    return readLockPredicate(children, sequenceNodeName);}
a5a54dfe9fe6a249da9dc4144903620ac915287990788627b0e42479bbddde5e
readLock
public InterProcessMutex readLock()
{    return readMutex;}
495ed1b9014e18ca6890fd3ba9619c089d5fd6ff91c4d32a419c00241b4f9f09
writeLock
public InterProcessMutex writeLock()
{    return writeMutex;}
898657919efca9adea3105e97f5f97a7b2711d9944ce58d499508cfba1e322af
readLockPredicate
private PredicateResults readLockPredicate(List<String> children, String sequenceNodeName) throws Exception
{    if (writeMutex.isOwnedByCurrentThread()) {        return new PredicateResults(null, true);    }    int index = 0;    int firstWriteIndex = Integer.MAX_VALUE;    int ourIndex = -1;    for (String node : children) {        if (node.contains(WRITE_LOCK_NAME)) {            firstWriteIndex = Math.min(index, firstWriteIndex);        } else if (node.startsWith(sequenceNodeName)) {            ourIndex = index;            break;        }        ++index;    }    StandardLockInternalsDriver.validateOurIndex(sequenceNodeName, ourIndex);    boolean getsTheLock = (ourIndex < firstWriteIndex);    String pathToWatch = getsTheLock ? null : children.get(firstWriteIndex);    return new PredicateResults(pathToWatch, getsTheLock);}
6cb5a4c33a23ad3a87a85d3f5e1c50afe030ad793b4527cb8e6e4c65c96a7900
countHasChanged
public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception
{    internals.setMaxLeases(newCount);}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
533ffe1faf3675d72c867bb5accd488a447a9a02b4d2c9f4efbbb6713acd0a53
returnAll
public void returnAll(Collection<Lease> leases)
{    for (Lease l : leases) {        CloseableUtils.closeQuietly(l);    }}
c40330f53d48a68ca5215c080ea8d90aa04c01a47565cbc1f92846f2536a52c7
returnLease
public void returnLease(Lease lease)
{    CloseableUtils.closeQuietly(lease);}
ccbefa6d9fde0af0f4ed0f1a7205aacf8b46f083a9c21ba48755b87fc5357ac3
acquire
public Lease acquire() throws Exception
{    String path = internals.attemptLock(-1, null, null);    return makeLease(path);}
9d506934763f309ae0b89461b6d6802e7eac86e856bed1fc8458d18f70c6209e
acquire
public Collection<Lease> acquire(int qty) throws Exception
{    Preconditions.checkArgument(qty > 0, "qty cannot be 0");    ImmutableList.Builder<Lease> builder = ImmutableList.builder();    try {        while (qty-- > 0) {            String path = internals.attemptLock(-1, null, null);            builder.add(makeLease(path));        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        returnAll(builder.build());        throw e;    }    return builder.build();}
8db1fd562ff43f8347d1acc2f1668044cafd9603e2ea1fd8d92b1d580929daf9
acquire
public Lease acquire(long time, TimeUnit unit) throws Exception
{    String path = internals.attemptLock(time, unit, null);    return (path != null) ? makeLease(path) : null;}
96b74abc5b8846fbb11150014d28bc8c5fbf075663c1d52274bf4fdb2b324a28
acquire
public Collection<Lease> acquire(int qty, long time, TimeUnit unit) throws Exception
{    long startMs = System.currentTimeMillis();    long waitMs = TimeUnit.MILLISECONDS.convert(time, unit);    Preconditions.checkArgument(qty > 0, "qty cannot be 0");    ImmutableList.Builder<Lease> builder = ImmutableList.builder();    try {        while (qty-- > 0) {            long elapsedMs = System.currentTimeMillis() - startMs;            long thisWaitMs = waitMs - elapsedMs;            String path = (thisWaitMs > 0) ? internals.attemptLock(thisWaitMs, TimeUnit.MILLISECONDS, null) : null;            if (path == null) {                returnAll(builder.build());                return null;            }            builder.add(makeLease(path));        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        returnAll(builder.build());        throw e;    }    return builder.build();}
28f37906e940f6bd0c8543d11c444dfabc8939d2351250851903e94bc3597dac
makeLease
private Lease makeLease(final String path)
{    return new Lease() {        @Override        public void close() throws IOException {            try {                internals.releaseLock(path);            } catch (KeeperException.NoNodeException e) {                log.warn("Lease already released", e);            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                throw new IOException(e);            }        }        @Override        public byte[] getData() throws Exception {            return internals.getClient().getData().forPath(path);        }        @Override        public String getNodeName() {            return ZKPaths.getNodeFromPath(path);        }    };}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    try {        internals.releaseLock(path);    } catch (KeeperException.NoNodeException e) {        log.warn("Lease already released", e);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new IOException(e);    }}
262bde86a3f1a9b88c6cad5e6ac791517c1815e0d00ac56e72badaa4847eaac1
getData
public byte[] getData() throws Exception
{    return internals.getClient().getData().forPath(path);}
edd32f81e470f458e3f6ec5756cb53b22e8def567feb7a38b5bd55d1b358cb1b
getNodeName
public String getNodeName()
{    return ZKPaths.getNodeFromPath(path);}
6ed01f514324c2abdcf4abfde4f82ec6a096b3dc9765c28e667f9ae924b4ecba
acquire
public void acquire() throws Exception
{    lease = semaphore.acquire();}
e84db03b70d95fa516f1561b83f3738c78a129a52a8adede3d11a5b2bbfd3a21
acquire
public boolean acquire(long time, TimeUnit unit) throws Exception
{    Lease acquiredLease = semaphore.acquire(time, unit);    if (acquiredLease == null) {                return false;    }    lease = acquiredLease;    return true;}
416a94a1896246da1af92845d0098abfbff6e67323e4afe5a7de2f1dccecf83a
release
public void release() throws Exception
{    Lease lease = this.lease;    Preconditions.checkState(lease != null, "Not acquired");    this.lease = null;    lease.close();    watcherRemoveClient.removeWatchers();}
745d135b8331357b385fbaa7e0423401f2ab75f33e409e679d1ef190a299a7e1
isAcquiredInThisProcess
public boolean isAcquiredInThisProcess()
{    return (lease != null);}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    client.postSafeNotify(InterProcessSemaphoreV2.this);}
6cb5a4c33a23ad3a87a85d3f5e1c50afe030ad793b4527cb8e6e4c65c96a7900
countHasChanged
public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception
{    InterProcessSemaphoreV2.this.maxLeases = newCount;    client.postSafeNotify(InterProcessSemaphoreV2.this);}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
eb36c7cb244299287bab80288db74045bbdbedb796a43cf75b3676076e599817
setNodeData
public void setNodeData(byte[] nodeData)
{    this.nodeData = (nodeData != null) ? Arrays.copyOf(nodeData, nodeData.length) : null;}
7a26efa913664025c50b0093570c38763b104a386800c040efd6caf507a38ac8
getParticipantNodes
public Collection<String> getParticipantNodes() throws Exception
{    return client.getChildren().forPath(leasesPath);}
533ffe1faf3675d72c867bb5accd488a447a9a02b4d2c9f4efbbb6713acd0a53
returnAll
public void returnAll(Collection<Lease> leases)
{    for (Lease l : leases) {        CloseableUtils.closeQuietly(l);    }}
c40330f53d48a68ca5215c080ea8d90aa04c01a47565cbc1f92846f2536a52c7
returnLease
public void returnLease(Lease lease)
{    CloseableUtils.closeQuietly(lease);}
ccbefa6d9fde0af0f4ed0f1a7205aacf8b46f083a9c21ba48755b87fc5357ac3
acquire
public Lease acquire() throws Exception
{    Collection<Lease> leases = acquire(1, 0, null);    return leases.iterator().next();}
9d506934763f309ae0b89461b6d6802e7eac86e856bed1fc8458d18f70c6209e
acquire
public Collection<Lease> acquire(int qty) throws Exception
{    return acquire(qty, 0, null);}
8db1fd562ff43f8347d1acc2f1668044cafd9603e2ea1fd8d92b1d580929daf9
acquire
public Lease acquire(long time, TimeUnit unit) throws Exception
{    Collection<Lease> leases = acquire(1, time, unit);    return (leases != null) ? leases.iterator().next() : null;}
96b74abc5b8846fbb11150014d28bc8c5fbf075663c1d52274bf4fdb2b324a28
acquire
public Collection<Lease> acquire(int qty, long time, TimeUnit unit) throws Exception
{    long startMs = System.currentTimeMillis();    boolean hasWait = (unit != null);    long waitMs = hasWait ? TimeUnit.MILLISECONDS.convert(time, unit) : 0;    Preconditions.checkArgument(qty > 0, "qty cannot be 0");    ImmutableList.Builder<Lease> builder = ImmutableList.builder();    boolean success = false;    try {        while (qty-- > 0) {            int retryCount = 0;            long startMillis = System.currentTimeMillis();            boolean isDone = false;            while (!isDone) {                switch(internalAcquire1Lease(builder, startMs, hasWait, waitMs)) {                    case CONTINUE:                        {                            isDone = true;                            break;                        }                    case RETURN_NULL:                        {                            return null;                        }                    case RETRY_DUE_TO_MISSING_NODE:                        {                                                        if (!client.getZookeeperClient().getRetryPolicy().allowRetry(retryCount++, System.currentTimeMillis() - startMillis, RetryLoop.getDefaultRetrySleeper())) {                                throw new KeeperException.NoNodeException("Sequential path not found - possible session loss");                            }                                                        break;                        }                }            }        }        success = true;    } finally {        if (!success) {            returnAll(builder.build());        }    }    return builder.build();}
1da61066b78350f39f4825c5b5b61a414f81776654fcd7b21ae5cf22bcf7aafe
internalAcquire1Lease
private InternalAcquireResult internalAcquire1Lease(ImmutableList.Builder<Lease> builder, long startMs, boolean hasWait, long waitMs) throws Exception
{    if (client.getState() != CuratorFrameworkState.STARTED) {        return InternalAcquireResult.RETURN_NULL;    }    if (hasWait) {        long thisWaitMs = getThisWaitMs(startMs, waitMs);        if (!lock.acquire(thisWaitMs, TimeUnit.MILLISECONDS)) {            return InternalAcquireResult.RETURN_NULL;        }    } else {        lock.acquire();    }    Lease lease = null;    boolean success = false;    try {        PathAndBytesable<String> createBuilder = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL);        String path = (nodeData != null) ? createBuilder.forPath(ZKPaths.makePath(leasesPath, LEASE_BASE_NAME), nodeData) : createBuilder.forPath(ZKPaths.makePath(leasesPath, LEASE_BASE_NAME));        String nodeName = ZKPaths.getNodeFromPath(path);        lease = makeLease(path);        if (debugAcquireLatch != null) {            debugAcquireLatch.await();        }        try {            synchronized (this) {                for (; ; ) {                    List<String> children;                    try {                        children = client.getChildren().usingWatcher(watcher).forPath(leasesPath);                    } catch (Exception e) {                        if (debugFailedGetChildrenLatch != null) {                            debugFailedGetChildrenLatch.countDown();                        }                        throw e;                    }                    if (!children.contains(nodeName)) {                        log.error("Sequential path not found: " + path);                        return InternalAcquireResult.RETRY_DUE_TO_MISSING_NODE;                    }                    if (children.size() <= maxLeases) {                        break;                    }                    if (hasWait) {                        long thisWaitMs = getThisWaitMs(startMs, waitMs);                        if (thisWaitMs <= 0) {                            return InternalAcquireResult.RETURN_NULL;                        }                        if (debugWaitLatch != null) {                            debugWaitLatch.countDown();                        }                        wait(thisWaitMs);                    } else {                        if (debugWaitLatch != null) {                            debugWaitLatch.countDown();                        }                        wait();                    }                }                success = true;            }        } finally {            if (!success) {                returnLease(lease);            }            client.removeWatchers();        }    } finally {        lock.release();    }    builder.add(Preconditions.checkNotNull(lease));    return InternalAcquireResult.CONTINUE;}
d265e9d7ccbae1fdcebed025961203f75d805c8f92e28750ee73503069c19a9b
getThisWaitMs
private long getThisWaitMs(long startMs, long waitMs)
{    long elapsedMs = System.currentTimeMillis() - startMs;    return waitMs - elapsedMs;}
28f37906e940f6bd0c8543d11c444dfabc8939d2351250851903e94bc3597dac
makeLease
private Lease makeLease(final String path)
{    return new Lease() {        @Override        public void close() throws IOException {            try {                client.delete().guaranteed().forPath(path);            } catch (KeeperException.NoNodeException e) {                log.warn("Lease already released", e);            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                throw new IOException(e);            }        }        @Override        public byte[] getData() throws Exception {            return client.getData().forPath(path);        }        @Override        public String getNodeName() {            return ZKPaths.getNodeFromPath(path);        }    };}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    try {        client.delete().guaranteed().forPath(path);    } catch (KeeperException.NoNodeException e) {        log.warn("Lease already released", e);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new IOException(e);    }}
262bde86a3f1a9b88c6cad5e6ac791517c1815e0d00ac56e72badaa4847eaac1
getData
public byte[] getData() throws Exception
{    return client.getData().forPath(path);}
edd32f81e470f458e3f6ec5756cb53b22e8def567feb7a38b5bd55d1b358cb1b
getNodeName
public String getNodeName()
{    return ZKPaths.getNodeFromPath(path);}
01bdbe3d598775bcdfd40c576dd509ca608ffa3f8e9f84c10577008566681778
close
public void close() throws Exception
{    if (acquired.compareAndSet(true, false)) {        releaseLock();    }}
e5798827e11a94146936acf264ce15ed06e2d6865524b917634fdf3df607cbc5
releaseLock
protected void releaseLock() throws Exception
{    lock.release();}
66cc893f0dc54e4d5378ec6e86eb96264aa6b8b42dbf0a4e753dcd8e3d5904d2
acquireLock
protected void acquireLock(InterProcessLock lock) throws Exception
{    lock.acquire();}
4f0151a0bff037565569312aaeae12d318076f0d95c937a5373573ccfaf1218c
acquireLock
protected boolean acquireLock(InterProcessLock lock, long timeout, TimeUnit unit) throws Exception
{    return lock.acquire(timeout, unit);}
a4803fca4797306b4f772a40c997680043dc08b35469407056bd5b28cf26096b
process
public void process(WatchedEvent event) throws Exception
{    if (event.getType() == Watcher.Event.EventType.NodeDataChanged) {        checkRevocableWatcher(event.getPath());    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    client.postSafeNotify(LockInternals.this);}
4691d3ca15a62911d6627b2804316f7a3de2d3eb81dbd7ce7cd194593fe45625
clean
public void clean() throws Exception
{    try {        client.delete().forPath(basePath);    } catch (KeeperException.BadVersionException ignore) {        } catch (KeeperException.NotEmptyException ignore) {        }}
aa8909b88c3c29323dace0a706cf77c3006386e9f247b958a4b1a20e2711853e
setMaxLeases
 synchronized void setMaxLeases(int maxLeases)
{    this.maxLeases = maxLeases;    notifyAll();}
5fa937a4076de4a626a7f421135bf55ccd270eb50ba1a3171c9458bc4f89baef
makeRevocable
 void makeRevocable(RevocationSpec entry)
{    revocable.set(entry);}
8eaee5668036d0379f5366fde9ce08c086c4480aaa12b8d886e67ad25afc3d0d
releaseLock
 final void releaseLock(String lockPath) throws Exception
{    client.removeWatchers();    revocable.set(null);    deleteOurPath(lockPath);}
85ccbd5af870f9e622dece9448bbae07346a4c1cee08145eb1b325830b7ad326
getClient
 CuratorFramework getClient()
{    return client;}
d55c55e595446812184467127d31482347f39176557cdc25ccf1104275127b67
getParticipantNodes
public static Collection<String> getParticipantNodes(CuratorFramework client, final String basePath, String lockName, LockInternalsSorter sorter) throws Exception
{    List<String> names = getSortedChildren(client, basePath, lockName, sorter);    Iterable<String> transformed = Iterables.transform(names, new Function<String, String>() {        @Override        public String apply(String name) {            return ZKPaths.makePath(basePath, name);        }    });    return ImmutableList.copyOf(transformed);}
3d850bd045b6aaf487e2ff1254b04d2e889c6c51e2625108d1d2a04ceb99c249
apply
public String apply(String name)
{    return ZKPaths.makePath(basePath, name);}
8b296eb3d44893501658f79c2d1c4c2c704c3917c1eaf788b8ddbed86a3d964c
getSortedChildren
public static List<String> getSortedChildren(CuratorFramework client, String basePath, final String lockName, final LockInternalsSorter sorter) throws Exception
{    try {        List<String> children = client.getChildren().forPath(basePath);        List<String> sortedList = Lists.newArrayList(children);        Collections.sort(sortedList, new Comparator<String>() {            @Override            public int compare(String lhs, String rhs) {                return sorter.fixForSorting(lhs, lockName).compareTo(sorter.fixForSorting(rhs, lockName));            }        });        return sortedList;    } catch (KeeperException.NoNodeException ignore) {        return Collections.emptyList();    }}
80a99ba733b8810309e25a56c68e39a02feaa30a4871ae341e6626a430a08bee
compare
public int compare(String lhs, String rhs)
{    return sorter.fixForSorting(lhs, lockName).compareTo(sorter.fixForSorting(rhs, lockName));}
eabdc8a70133118b1ebdf6002cd6440eae7e957337a81ddb67bdfdebe7b705bb
getSortedChildren
public static List<String> getSortedChildren(final String lockName, final LockInternalsSorter sorter, List<String> children)
{    List<String> sortedList = Lists.newArrayList(children);    Collections.sort(sortedList, new Comparator<String>() {        @Override        public int compare(String lhs, String rhs) {            return sorter.fixForSorting(lhs, lockName).compareTo(sorter.fixForSorting(rhs, lockName));        }    });    return sortedList;}
80a99ba733b8810309e25a56c68e39a02feaa30a4871ae341e6626a430a08bee
compare
public int compare(String lhs, String rhs)
{    return sorter.fixForSorting(lhs, lockName).compareTo(sorter.fixForSorting(rhs, lockName));}
df57bbeb0ea69c55a1df19798331577ed3313a93873a7f030dcdfa9a629ab454
getSortedChildren
 List<String> getSortedChildren() throws Exception
{    return getSortedChildren(client, basePath, lockName, driver);}
35f8fc61b1ef58774dab774d954adc40956a1d779880a087ed45e373cd6fcbf6
getLockName
 String getLockName()
{    return lockName;}
97ab83cfe2a995bea90d156974fca43c840d82cab4d18ebd16d6445e2b3057af
getDriver
 LockInternalsDriver getDriver()
{    return driver;}
eca0c5ac082142d5c158bf6891f71cba0e7c7383451340e8d9b0332cb11f239b
attemptLock
 String attemptLock(long time, TimeUnit unit, byte[] lockNodeBytes) throws Exception
{    final long startMillis = System.currentTimeMillis();    final Long millisToWait = (unit != null) ? unit.toMillis(time) : null;    final byte[] localLockNodeBytes = (revocable.get() != null) ? new byte[0] : lockNodeBytes;    int retryCount = 0;    String ourPath = null;    boolean hasTheLock = false;    boolean isDone = false;    while (!isDone) {        isDone = true;        try {            ourPath = driver.createsTheLock(client, path, localLockNodeBytes);            hasTheLock = internalLockLoop(startMillis, millisToWait, ourPath);        } catch (KeeperException.NoNodeException e) {                        if (client.getZookeeperClient().getRetryPolicy().allowRetry(retryCount++, System.currentTimeMillis() - startMillis, RetryLoop.getDefaultRetrySleeper())) {                isDone = false;            } else {                throw e;            }        }    }    if (hasTheLock) {        return ourPath;    }    return null;}
5f3fb98d8c8bab2c473c781f0e8b8046ba7d45ce21b9562c4908c5701a354c03
checkRevocableWatcher
private void checkRevocableWatcher(String path) throws Exception
{    RevocationSpec entry = revocable.get();    if (entry != null) {        try {            byte[] bytes = client.getData().usingWatcher(revocableWatcher).forPath(path);            if (Arrays.equals(bytes, REVOKE_MESSAGE)) {                entry.getExecutor().execute(entry.getRunnable());            }        } catch (KeeperException.NoNodeException ignore) {                }    }}
111881e2f65f6272d76c01eb04be7bc5ad08aadcf2be6df3ced571d633978650
internalLockLoop
private boolean internalLockLoop(long startMillis, Long millisToWait, String ourPath) throws Exception
{    boolean haveTheLock = false;    boolean doDelete = false;    try {        if (revocable.get() != null) {            client.getData().usingWatcher(revocableWatcher).forPath(ourPath);        }        while ((client.getState() == CuratorFrameworkState.STARTED) && !haveTheLock) {            List<String> children = getSortedChildren();                        String sequenceNodeName = ourPath.substring(basePath.length() + 1);            PredicateResults predicateResults = driver.getsTheLock(client, children, sequenceNodeName, maxLeases);            if (predicateResults.getsTheLock()) {                haveTheLock = true;            } else {                String previousSequencePath = basePath + "/" + predicateResults.getPathToWatch();                synchronized (this) {                    try {                                                client.getData().usingWatcher(watcher).forPath(previousSequencePath);                        if (millisToWait != null) {                            millisToWait -= (System.currentTimeMillis() - startMillis);                            startMillis = System.currentTimeMillis();                            if (millisToWait <= 0) {                                                                doDelete = true;                                break;                            }                            wait(millisToWait);                        } else {                            wait();                        }                    } catch (KeeperException.NoNodeException e) {                                        }                }            }        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        doDelete = true;        throw e;    } finally {        if (doDelete) {            deleteOurPath(ourPath);        }    }    return haveTheLock;}
1eb53b459f4ca2f3c305ba4b352f1fa7faddd762f18d9df73d40fd41dcf16a41
deleteOurPath
private void deleteOurPath(String ourPath) throws Exception
{    try {        client.delete().guaranteed().forPath(ourPath);    } catch (KeeperException.NoNodeException e) {        }}
376f9cadda484d012faf39f41bfc3dca92b78e278046ea6ffd26b7219fd23b6b
getPathToWatch
public String getPathToWatch()
{    return pathToWatch;}
f49d6c4ed4311c11c5fd87f71335459deb0e0a6919d7611300d27e426636dc58
getsTheLock
public boolean getsTheLock()
{    return getsTheLock;}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    reap(this);}
8dd8fc6a56c18394e9b9c7da80619f954b13824b7bed6b48d3bd5db44ec9e6cf
addPath
public void addPath(String path)
{    addPath(path, Mode.REAP_INDEFINITELY);}
375de05f5e71ade33563eb9b741ed199d9d3caa3afc2b5638ec97a03b2181574
addPath
public void addPath(String path, Mode mode)
{    PathHolder pathHolder = new PathHolder(path, mode, 0);    activePaths.put(path, pathHolder);    schedule(pathHolder, reapingThresholdMs);}
87f6a7175ee706d0487e3c48db8dc782dcb441f81efb244a72fdc6fdbf962fd4
removePath
public boolean removePath(String path)
{    return activePaths.remove(path) != null;}
90ba0dddc593bd95e2a0c0c039c523b81bfb91f87814ebcb222c3914ca772ead
start
public void start() throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    if (leaderLatch != null && ownsLeaderLatch) {        leaderLatch.start();    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    if (state.compareAndSet(State.STARTED, State.CLOSED)) {        executor.close();        if (leaderLatch != null && ownsLeaderLatch) {            leaderLatch.close();        }    }}
3ce6b0689169804e7217b1efd90afc302700596a36430c907c5cfe8b64fa13d8
schedule
protected Future<?> schedule(PathHolder pathHolder, int reapingThresholdMs)
{    if (reapingIsActive.get()) {        return executor.schedule(pathHolder, reapingThresholdMs, TimeUnit.MILLISECONDS);    }    return null;}
9e50df4f707ec4adc5d6f0dac3145a6659eacc62aba48f2d5b5fad507868b9e3
reap
protected void reap(PathHolder holder)
{    if (!activePaths.containsKey(holder.path)) {        return;    }    boolean addBack = true;    int newEmptyCount = 0;    try {        Stat stat = client.checkExists().forPath(holder.path);        if (        stat != null) {            if (stat.getNumChildren() == 0) {                if ((holder.emptyCount + 1) >= EMPTY_COUNT_THRESHOLD) {                    try {                        client.delete().forPath(holder.path);                        log.info("Reaping path: " + holder.path);                        if (holder.mode == Mode.REAP_UNTIL_DELETE || holder.mode == Mode.REAP_UNTIL_GONE) {                            addBack = false;                        }                    } catch (KeeperException.NoNodeException ignore) {                                                if (holder.mode == Mode.REAP_UNTIL_GONE) {                            addBack = false;                        }                    } catch (KeeperException.NotEmptyException ignore) {                                        }                } else {                    newEmptyCount = holder.emptyCount + 1;                }            }        } else {            if (holder.mode == Mode.REAP_UNTIL_GONE) {                addBack = false;            }        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        log.error("Trying to reap: " + holder.path, e);    }    if (!addBack) {        activePaths.remove(holder.path);    } else if (!Thread.currentThread().isInterrupted() && (state.get() == State.STARTED) && activePaths.containsKey(holder.path)) {        activePaths.put(holder.path, holder);        schedule(new PathHolder(holder.path, holder.mode, newEmptyCount), reapingThresholdMs);    }}
be5673c8428dd5f3a8ae3e2a26cbbd3211695f422705854f80f12e400f716cae
newExecutorService
public static ScheduledExecutorService newExecutorService()
{    return ThreadUtils.newSingleThreadScheduledExecutor("Reaper");}
6033342b89be6d0ffe459d20c9d7e0b2947ba0727f439d10c1c4153fdd9c3617
addListenerToLeaderLatch
private void addListenerToLeaderLatch(LeaderLatch leaderLatch)
{    LeaderLatchListener listener = new LeaderLatchListener() {        @Override        public void isLeader() {            reapingIsActive.set(true);            for (PathHolder holder : activePaths.values()) {                schedule(holder, reapingThresholdMs);            }        }        @Override        public void notLeader() {            reapingIsActive.set(false);        }    };    leaderLatch.addListener(listener);    reapingIsActive.set(leaderLatch.hasLeadership());}
161f2b20fcb60bb29fa4dd2a2de4c5bd28f8ea5b6a88f6601db69778560262ec
isLeader
public void isLeader()
{    reapingIsActive.set(true);    for (PathHolder holder : activePaths.values()) {        schedule(holder, reapingThresholdMs);    }}
7309ee5a376f42d6463d9f23a9cface128ecba20f10d327fca13beb4c4b92859
notLeader
public void notLeader()
{    reapingIsActive.set(false);}
12662bcf6340e5d9b986363853fe8c77792392c3bf9e8d89fb756aed2a8c45f5
makeLeaderLatchIfPathNotNull
private static LeaderLatch makeLeaderLatchIfPathNotNull(CuratorFramework client, String leaderPath)
{    if (leaderPath == null) {        return null;    } else {        return new LeaderLatch(client, leaderPath);    }}
f24911db92c53d78b6457523ae9339c4512d3f3a86a863b12b278b613f048868
getRunnable
 Runnable getRunnable()
{    return runnable;}
3364ef55e04231edbf637c169d6e837bbe598cb769a584a99d14539523e40ec6
getExecutor
 Executor getExecutor()
{    return executor;}
1618b8971108025237690c00dad602b9705f74b825ac81ca1ca5a2db60467724
attemptRevoke
public static void attemptRevoke(CuratorFramework client, String path) throws Exception
{    try {        client.setData().forPath(path, LockInternals.REVOKE_MESSAGE);    } catch (KeeperException.NoNodeException ignore) {        }}
780efcf91497f90cf23ec420ad24e2f5ab49707cfed51b2c3672fd65672190f2
getsTheLock
public PredicateResults getsTheLock(CuratorFramework client, List<String> children, String sequenceNodeName, int maxLeases) throws Exception
{    int ourIndex = children.indexOf(sequenceNodeName);    validateOurIndex(sequenceNodeName, ourIndex);    boolean getsTheLock = ourIndex < maxLeases;    String pathToWatch = getsTheLock ? null : children.get(ourIndex - maxLeases);    return new PredicateResults(pathToWatch, getsTheLock);}
506f093807b1e716e8c815826020fe70fc150d32d4c5dfb49b6facdacb32c4bf
createsTheLock
public String createsTheLock(CuratorFramework client, String path, byte[] lockNodeBytes) throws Exception
{    String ourPath;    if (lockNodeBytes != null) {        ourPath = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path, lockNodeBytes);    } else {        ourPath = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path);    }    return ourPath;}
2ca37aecb7b6d50b96d16e509436bd8fcd1ce1da9670ebeab2a9fb863c384b3c
fixForSorting
public String fixForSorting(String str, String lockName)
{    return standardFixForSorting(str, lockName);}
f1900b84240e5f8611849c1df239f7117a10881342bbf0485e68a97617ecd350
standardFixForSorting
public static String standardFixForSorting(String str, String lockName)
{    int index = str.lastIndexOf(lockName);    if (index >= 0) {        index += lockName.length();        return index <= str.length() ? str.substring(index) : "";    }    return str;}
91ebccec85b544f355b9d34c7af138afa3174366217e3b50cc257e3d519a9537
validateOurIndex
 static void validateOurIndex(String sequenceNodeName, int ourIndex) throws KeeperException
{    if (ourIndex < 0) {        throw new KeeperException.NoNodeException("Sequential path not found: " + sequenceNodeName);    }}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    pen.start();    try {        cache.start();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        Throwables.propagate(e);    }}
97f01b79226eab5bc0438798a780a7a985fac4248129e8789af70cc318909777
setThisData
public void setThisData(byte[] data)
{    try {        pen.setData(data);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        Throwables.propagate(e);    }}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    CloseableUtils.closeQuietly(cache);    CloseableUtils.closeQuietly(pen);}
2a92ae0d7c54ff99a46ecf0369bdfe7f374c944d892cd8283bdbe062684c563b
getCurrentMembers
public Map<String, byte[]> getCurrentMembers()
{    ImmutableMap.Builder<String, byte[]> builder = ImmutableMap.builder();    boolean thisIdAdded = false;    for (ChildData data : cache.getCurrentData()) {        String id = idFromPath(data.getPath());        thisIdAdded = thisIdAdded || id.equals(thisId);        builder.put(id, data.getData());    }    if (!thisIdAdded) {                builder.put(thisId, pen.getData());    }    return builder.build();}
9f9165499462740818ad8b35351bea68d8ffbcdea3e812f0b8b32a631707e974
idFromPath
public String idFromPath(String path)
{    return ZKPaths.getNodeFromPath(path);}
047b73fef51187905e6bec83be58ab6d37d118d64823f28c5e4c067b8f183007
newPersistentEphemeralNode
protected PersistentEphemeralNode newPersistentEphemeralNode(CuratorFramework client, String membershipPath, String thisId, byte[] payload)
{    return new PersistentEphemeralNode(client, PersistentEphemeralNode.Mode.EPHEMERAL, ZKPaths.makePath(membershipPath, thisId), payload);}
ca7c46a857b22291675b8825cc9e49ce03c97cf2bd76691a61813fb3ee3af60d
newPathChildrenCache
protected PathChildrenCache newPathChildrenCache(CuratorFramework client, String membershipPath)
{    return new PathChildrenCache(client, membershipPath, true);}
1dbf94481cb5e395511e19e42e74c3a489bce4192687d423d32722043d58486d
getCreateMode
protected CreateMode getCreateMode(boolean pathIsSet)
{    return CreateMode.EPHEMERAL;}
6c575cfd8deb0cd071468af6bf329dd945748f001ccb3fc0930a76794f8c2aa3
isProtected
protected boolean isProtected()
{    return false;}
1dbf94481cb5e395511e19e42e74c3a489bce4192687d423d32722043d58486d
getCreateMode
protected CreateMode getCreateMode(boolean pathIsSet)
{    return pathIsSet ? CreateMode.EPHEMERAL : CreateMode.EPHEMERAL_SEQUENTIAL;}
6c575cfd8deb0cd071468af6bf329dd945748f001ccb3fc0930a76794f8c2aa3
isProtected
protected boolean isProtected()
{    return false;}
1dbf94481cb5e395511e19e42e74c3a489bce4192687d423d32722043d58486d
getCreateMode
protected CreateMode getCreateMode(boolean pathIsSet)
{    return CreateMode.EPHEMERAL;}
6c575cfd8deb0cd071468af6bf329dd945748f001ccb3fc0930a76794f8c2aa3
isProtected
protected boolean isProtected()
{    return true;}
1dbf94481cb5e395511e19e42e74c3a489bce4192687d423d32722043d58486d
getCreateMode
protected CreateMode getCreateMode(boolean pathIsSet)
{    return pathIsSet ? CreateMode.EPHEMERAL : CreateMode.EPHEMERAL_SEQUENTIAL;}
6c575cfd8deb0cd071468af6bf329dd945748f001ccb3fc0930a76794f8c2aa3
isProtected
protected boolean isProtected()
{    return true;}
a4803fca4797306b4f772a40c997680043dc08b35469407056bd5b28cf26096b
process
public void process(WatchedEvent event) throws Exception
{    if (isActive()) {        if (event.getType() == EventType.NodeDeleted) {            createNode();        } else if (event.getType() == EventType.NodeDataChanged) {            watchNode();        }    }}
e692686d168d5fb96aa9c66d408bde115766795a25db23b5c7cfa0ed26b64a93
processResult
public void processResult(CuratorFramework dummy, CuratorEvent event) throws Exception
{    if (isActive()) {        if (event.getResultCode() == KeeperException.Code.NONODE.intValue()) {            createNode();        } else {            boolean isEphemeral = event.getStat().getEphemeralOwner() != 0;            if (isEphemeral != mode.isEphemeral()) {                log.warn("Existing node ephemeral state doesn't match requested state. Maybe the node was created outside of PersistentNode? " + basePath);            }        }    } else {        client.removeWatchers();    }}
e692686d168d5fb96aa9c66d408bde115766795a25db23b5c7cfa0ed26b64a93
processResult
public void processResult(CuratorFramework dummy, CuratorEvent event) throws Exception
{        if (event.getResultCode() == KeeperException.Code.OK.intValue()) {                initialisationComplete();    } else if (event.getResultCode() == KeeperException.Code.NOAUTH.intValue()) {        log.warn("Client does not have authorisation to write node at path {}", event.getPath());        authFailure.set(true);    }}
43320e50220c9ee9a93cd20c6e55cfc1ed6c214c30a4023773f28f9be96acc38
stateChanged
public void stateChanged(CuratorFramework dummy, ConnectionState newState)
{    if ((newState == ConnectionState.RECONNECTED) && isActive()) {        createNode();    }}
e692686d168d5fb96aa9c66d408bde115766795a25db23b5c7cfa0ed26b64a93
processResult
public void processResult(CuratorFramework dummy, CuratorEvent event) throws Exception
{    if (isActive()) {        processBackgroundCallback(event);    } else {        processBackgroundCallbackClosedState(event);    }}
f995c00ea210310226137e74cfc343114ede099ee80a153e7d800c84e67b4843
processBackgroundCallbackClosedState
private void processBackgroundCallbackClosedState(CuratorEvent event)
{    String path = null;    if (event.getResultCode() == KeeperException.Code.NODEEXISTS.intValue()) {        path = event.getPath();    } else if (event.getResultCode() == KeeperException.Code.OK.intValue()) {        path = event.getName();    }    if (path != null) {        try {            client.delete().guaranteed().inBackground().forPath(path);        } catch (Exception e) {            log.error("Could not delete node after close", e);        }    }}
062774e56b8facfe9b7f24ad465d5153dc7d3d3484b7322572021cd041be6b5a
processBackgroundCallback
private void processBackgroundCallback(CuratorEvent event) throws Exception
{    String path = null;    boolean nodeExists = false;    if (event.getResultCode() == KeeperException.Code.NODEEXISTS.intValue()) {        path = event.getPath();        nodeExists = true;    } else if (event.getResultCode() == KeeperException.Code.OK.intValue()) {        path = event.getName();    } else if (event.getResultCode() == KeeperException.Code.NOAUTH.intValue()) {        log.warn("Client does not have authorisation to create node at path {}", event.getPath());        authFailure.set(true);        return;    }    if (path != null) {        authFailure.set(false);        nodePath.set(path);        watchNode();        if (nodeExists) {            client.setData().inBackground(setDataCallback).forPath(getActualPath(), getData());        } else {            initialisationComplete();            notifyListeners();        }    } else {        createNode();    }}
9a40194341dfcada64a189e15a4e445efcb11afc50ae998f63f1245bc9295917
initialisationComplete
private void initialisationComplete()
{    CountDownLatch localLatch = initialCreateLatch.getAndSet(null);    if (localLatch != null) {        localLatch.countDown();    }}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Already started");    client.getConnectionStateListenable().addListener(connectionStateListener);    createNode();}
e346554b439cf6fab97147374660eaab9ca2bea8e1765d183648448c56be50ac
waitForInitialCreate
public boolean waitForInitialCreate(long timeout, TimeUnit unit) throws InterruptedException
{    Preconditions.checkState(state.get() == State.STARTED, "Not started");    CountDownLatch localLatch = initialCreateLatch.get();    return (localLatch == null) || localLatch.await(timeout, unit);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    if (debugWaitMsForBackgroundBeforeClose.get() > 0) {        try {            Thread.sleep(debugWaitMsForBackgroundBeforeClose.get());        } catch (InterruptedException e) {            Thread.currentThread().interrupt();        }    }    if (!state.compareAndSet(State.STARTED, State.CLOSED)) {        return;    }    client.getConnectionStateListenable().removeListener(connectionStateListener);    try {        deleteNode();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new IOException(e);    }    client.removeWatchers();}
ef368df0ed8baff5255902a6bcf4b2c2631c9cfe9c24f7035e849165e8e0b827
getListenable
public ListenerContainer<PersistentNodeListener> getListenable()
{    return listeners;}
f2b248417ab0aa05ac3d1038fad1a806b1643b457aa946e443c8910a306b670b
getActualPath
public String getActualPath()
{    return nodePath.get();}
0baaea60c586312650a230b8db32b904fe631d8216c8864a003618d00866af5d
setData
public void setData(byte[] data) throws Exception
{    data = Preconditions.checkNotNull(data, "data cannot be null");    Preconditions.checkState(nodePath.get() != null, "initial create has not been processed. Call waitForInitialCreate() to ensure.");    this.data.set(Arrays.copyOf(data, data.length));    if (isActive()) {        client.setData().inBackground(setDataCallback).forPath(getActualPath(), getData());    }}
812b8f717be4a6f9c7add1b71268ba7fe7ce1b799031309a1709dc43be1dd152
getData
public byte[] getData()
{    return this.data.get();}
d8cdf041fc520aa107067c6aa14f97af906bea4670c1dce7e8afb8e5c3dd664b
deleteNode
protected void deleteNode() throws Exception
{    String localNodePath = nodePath.getAndSet(null);    if (localNodePath != null) {        try {            client.delete().guaranteed().forPath(localNodePath);        } catch (KeeperException.NoNodeException ignore) {                }    }}
4fcefbed4af14a8afb6b907fcbaed43427a4464d894807e7ae1d6b0f4270dee9
createNode
private void createNode()
{    if (!isActive()) {        return;    }    if (debugCreateNodeLatch != null) {        try {            debugCreateNodeLatch.await();        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            return;        }    }    try {        String existingPath = nodePath.get(), createPath;        if (existingPath != null && !useProtection) {            createPath = existingPath;        } else if (existingPath != null && mode.isSequential()) {            createPath = basePath + ZKPaths.extractSequentialSuffix(existingPath);        } else {            createPath = basePath;        }        CreateModable<ACLBackgroundPathAndBytesable<String>> localCreateMethod = createMethod.get();        if (localCreateMethod == null) {            CreateBuilderMain createBuilder = SafeIsTtlMode.isTtl(mode) ? client.create().withTtl(ttl) : client.create();            CreateModable<ACLBackgroundPathAndBytesable<String>> tempCreateMethod = useProtection ? createBuilder.creatingParentContainersIfNeeded().withProtection() : createBuilder.creatingParentContainersIfNeeded();            createMethod.compareAndSet(null, tempCreateMethod);            localCreateMethod = createMethod.get();        }        localCreateMethod.withMode(getCreateMode(existingPath != null)).inBackground(backgroundCallback).forPath(createPath, data.get());    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);                throw new RuntimeException("Creating node. BasePath: " + basePath, e);    }}
bb6d99b00c9ee7d8ff825f1ec20f599a7564978bb150717620ba6be44ffa8e46
getCreateMode
private CreateMode getCreateMode(boolean pathIsSet)
{    if (pathIsSet) {        switch(mode) {            default:                {                    break;                }            case EPHEMERAL_SEQUENTIAL:                {                                        return CreateMode.EPHEMERAL;                }            case PERSISTENT_SEQUENTIAL:                {                                        return CreateMode.PERSISTENT;                }            case PERSISTENT_SEQUENTIAL_WITH_TTL:                {                                        return CreateMode.PERSISTENT_WITH_TTL;                }        }    }    return mode;}
72b4a7d7c2c4f778488d5cb857eab7e9eb3dfe3c3c50b450c5bb2a5dcae304af
watchNode
private void watchNode() throws Exception
{    if (!isActive()) {        return;    }    String localNodePath = nodePath.get();    if (localNodePath != null) {        client.checkExists().usingWatcher(watcher).inBackground(checkExistsCallback).forPath(localNodePath);    }}
dc497f5f4ecc37ca0db03650140d6b1f2ea9a6172f2a0c02ff8e04c4fe306d4b
notifyListeners
private void notifyListeners()
{    final String path = getActualPath();    listeners.forEach(new Function<PersistentNodeListener, Void>() {        @Override        public Void apply(PersistentNodeListener listener) {            try {                listener.nodeCreated(path);            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                log.error("From PersistentNode listener", e);            }            return null;        }    });}
3b4d3ebf84f4826982f272e4ced75ec2b3b4e30fccdcce49cdec87baa1a486d1
apply
public Void apply(PersistentNodeListener listener)
{    try {        listener.nodeCreated(path);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        log.error("From PersistentNode listener", e);    }    return null;}
27d02e53a129875076c8415f582a2f427b916bf020f865456779d5a6b698d856
isActive
private boolean isActive()
{    return (state.get() == State.STARTED);}
8793649e405d4839c9d2cc85ef616bf645a621b7af725f5d683c1d00e575f16f
isAuthFailure
 boolean isAuthFailure()
{    return authFailure.get();}
602a7f55ddf0054d17c9c25c8e59b0c53e845336ff4afbb5a75a6767cae0cf01
deleteNode
protected void deleteNode()
{}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    node.start();    Runnable touchTask = new Runnable() {        @Override        public void run() {            try {                try {                    client.setData().forPath(childPath);                } catch (KeeperException.NoNodeException e) {                    client.create().orSetData().withTtl(ttlMs).withMode(CreateMode.PERSISTENT_WITH_TTL).forPath(childPath);                }            } catch (KeeperException.NoNodeException ignore) {                        } catch (Exception e) {                if (!ThreadUtils.checkInterrupted(e)) {                    log.debug("Could not touch child node", e);                }            }        }    };    Future<?> future = executorService.scheduleAtFixedRate(touchTask, ttlMs / touchScheduleFactor, ttlMs / touchScheduleFactor, TimeUnit.MILLISECONDS);    futureRef.set(future);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        try {            client.setData().forPath(childPath);        } catch (KeeperException.NoNodeException e) {            client.create().orSetData().withTtl(ttlMs).withMode(CreateMode.PERSISTENT_WITH_TTL).forPath(childPath);        }    } catch (KeeperException.NoNodeException ignore) {        } catch (Exception e) {        if (!ThreadUtils.checkInterrupted(e)) {            log.debug("Could not touch child node", e);        }    }}
e346554b439cf6fab97147374660eaab9ca2bea8e1765d183648448c56be50ac
waitForInitialCreate
public boolean waitForInitialCreate(long timeout, TimeUnit unit) throws InterruptedException
{    return node.waitForInitialCreate(timeout, unit);}
0baaea60c586312650a230b8db32b904fe631d8216c8864a003618d00866af5d
setData
public void setData(byte[] data) throws Exception
{    node.setData(data);}
812b8f717be4a6f9c7add1b71268ba7fe7ce1b799031309a1709dc43be1dd152
getData
public byte[] getData()
{    return node.getData();}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    Future<?> future = futureRef.getAndSet(null);    if (future != null) {        future.cancel(true);    }    try {        node.close();    } catch (IOException e) {        throw new RuntimeException(e);    }}
95bcef2dbd7ab6b6e8addffac05b9963bb615d82d1bdcd25db7c65ee3fb59494
consumeMessage
public void consumeMessage(T message) throws Exception
{    items.add(message);}
2b0994330304cbb8b86c70f4a909752e610497a01b7340fda944230d82fa7145
getItems
public List<T> getItems()
{    return ImmutableList.copyOf(items);}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return items.size();}
6b918c502db48bdec7932e966b732f790386e40edc607cc9142dbe9513777f08
take
public T take() throws InterruptedException
{    return items.take();}
37e409409d815ada24be8a3aab13f27fb30e1e9d7c7ce73a7ae53e62af3e400d
take
public T take(int time, TimeUnit unit) throws InterruptedException
{    return items.poll(time, unit);}
78be1e67f29c8caaa1f0b3a77a4c0532a8c372471beaebfed0e4b2316337d350
drainTo
public int drainTo(Collection<? super T> c)
{    return items.drainTo(c);}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    connectionStateListener.stateChanged(client, newState);}
a4803fca4797306b4f772a40c997680043dc08b35469407056bd5b28cf26096b
process
public void process(WatchedEvent event) throws Exception
{    if (!isClosed.get()) {        sync(true);    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getResultCode() == KeeperException.Code.OK.intValue()) {        setNewChildren(event.getChildren());    }}
8f101449c86baab2969a87a3a7266faf85a5bd26417e524dafe0f5a4d9c5a9da
start
 void start() throws Exception
{    sync(true);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    client.removeWatchers();    isClosed.set(true);    notifyFromCallback();}
2aaea8784c951a093398f74e7f5959429eb5f408bd9f60b4096c12bc6c916ff8
getData
 Data getData()
{    return children.get();}
be025ec5fc45a3dab1331b3cb2d1e93412e702f4230bf3776c5125e25415a4ad
blockingNextGetData
 Data blockingNextGetData(long startVersion) throws InterruptedException
{    return blockingNextGetData(startVersion, 0, null);}
f7e21ba5db954b89759c501b1ac8541521805b05ef7824000f41a01a5ab44dcb
blockingNextGetData
 synchronized Data blockingNextGetData(long startVersion, long maxWait, TimeUnit unit) throws InterruptedException
{    long startMs = System.currentTimeMillis();    boolean hasMaxWait = (unit != null);    long maxWaitMs = hasMaxWait ? unit.toMillis(maxWait) : -1;    while (startVersion == children.get().version) {        if (hasMaxWait) {            long elapsedMs = System.currentTimeMillis() - startMs;            long thisWaitMs = maxWaitMs - elapsedMs;            if (thisWaitMs <= 0) {                break;            }            wait(thisWaitMs);        } else {            wait();        }    }    return children.get();}
7ee172dde611f8cf7d38716996343ea377338a744fb2eebe8ff701be780a68e9
notifyFromCallback
private synchronized void notifyFromCallback()
{    notifyAll();}
5ab68b7f7094670045be6da833800f8af233f73ee3d5c10c3fadd86df8b1c73b
sync
private synchronized void sync(boolean watched) throws Exception
{    if (watched) {        client.getChildren().usingWatcher(watcher).inBackground(callback).forPath(path);    } else {        client.getChildren().inBackground(callback).forPath(path);    }}
0ff6c01cf4137d7e976c82889181b2b87d19606894622f5c0dac3da96823f98f
setNewChildren
private synchronized void setNewChildren(List<String> newChildren)
{    if (newChildren != null) {        Data currentData = children.get();        children.set(new Data(newChildren, currentData.version + 1));        notifyFromCallback();    }}
02d07b35142ac4ef9c1e8ee5a4da20dad5d427d59aa873fe0bf0f9e5f55abdb3
getDelay
protected long getDelay(String itemNode)
{    return getDelay(itemNode, System.currentTimeMillis());}
276f32b937661186ab69beed55d26eaf90cfdf04b0abe650be27c9066ad742f9
getDelay
private long getDelay(String itemNode, long sortTime)
{    long epoch = getEpoch(itemNode);    return epoch - sortTime;}
cbb19aa66d1327de7e2dec7cadcaa4b3812cbe5b51e0971bd580d7399c659907
sortChildren
protected void sortChildren(List<String> children)
{    final long sortTime = System.currentTimeMillis();    Collections.sort(children, new Comparator<String>() {        @Override        public int compare(String o1, String o2) {            long diff = getDelay(o1, sortTime) - getDelay(o2, sortTime);            return (diff < 0) ? -1 : ((diff > 0) ? 1 : 0);        }    });}
35d131fdb7692f658b664d81b2ed14d907062a6b10b2966883992d774b8c32bd
compare
public int compare(String o1, String o2)
{    long diff = getDelay(o1, sortTime) - getDelay(o2, sortTime);    return (diff < 0) ? -1 : ((diff > 0) ? 1 : 0);}
90ba0dddc593bd95e2a0c0c039c523b81bfb91f87814ebcb222c3914ca772ead
start
public void start() throws Exception
{    queue.start();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    queue.close();}
241b02b3a7c2f5c91df1ac9503c4ea6bd7bab478288d1252ce3024619044c300
put
public void put(T item, long delayUntilEpoch) throws Exception
{    put(item, delayUntilEpoch, 0, null);}
67783d6cf84cda9afa6357630b704e79dc864a39868af17d3a5658fd7fa1b027
put
public boolean put(T item, long delayUntilEpoch, int maxWait, TimeUnit unit) throws Exception
{    Preconditions.checkArgument(delayUntilEpoch > 0, "delayUntilEpoch cannot be negative");    queue.checkState();    return queue.internalPut(item, null, queue.makeItemPath() + epochToString(delayUntilEpoch), maxWait, unit);}
f51e414060a964293eaa043b0d7f8d594faa4c5f983bac7a51abda5048e2f634
putMulti
public void putMulti(MultiItem<T> items, long delayUntilEpoch) throws Exception
{    putMulti(items, delayUntilEpoch, 0, null);}
ad0c4cabc8e35e8596e9b6d71d8500632e24926be4e71f5a1252a9442207f0a1
putMulti
public boolean putMulti(MultiItem<T> items, long delayUntilEpoch, int maxWait, TimeUnit unit) throws Exception
{    Preconditions.checkArgument(delayUntilEpoch > 0, "delayUntilEpoch cannot be negative");    queue.checkState();    return queue.internalPut(null, items, queue.makeItemPath() + epochToString(delayUntilEpoch), maxWait, unit);}
72b37de2175912fbfdb2ca9d52b5f2e6c74945b8057bddbce880e52a8bf5b211
setErrorMode
public void setErrorMode(ErrorMode newErrorMode)
{    queue.setErrorMode(newErrorMode);}
9db0334f768c6c0bcdabe9009cca53141fd8cf947ebbeb043b56aaa2c84b2f44
flushPuts
public boolean flushPuts(long waitTime, TimeUnit timeUnit) throws InterruptedException
{    return queue.flushPuts(waitTime, timeUnit);}
3c0af63b2575ebd84366d5bf9fd14ee73b87ebabc831d2da6a779b0ebc2727f6
getPutListenerContainer
public ListenerContainer<QueuePutListener<T>> getPutListenerContainer()
{    return queue.getPutListenerContainer();}
a7f13c20cf22242fec524d83dd657c8ddcd6f200a6d02f148afcb1d1a641c945
getLastMessageCount
public int getLastMessageCount()
{    return queue.getLastMessageCount();}
85f22a43b5e423ffc69e94e78a9986d295380b6111bb5d65ad6c76a6984cd1ce
epochToString
 static String epochToString(long epoch)
{    return SEPARATOR + String.format("%08X", epoch) + SEPARATOR;}
ac0c045211f2d193be56031bb9af15ec709cbc0120789bbd79cface7d4be72dd
getEpoch
private static long getEpoch(String itemNode)
{    int index2 = itemNode.lastIndexOf(SEPARATOR);    int index1 = (index2 > 0) ? itemNode.lastIndexOf(SEPARATOR, index2 - 1) : -1;    if ((index1 > 0) && (index2 > (index1 + 1))) {        try {            String epochStr = itemNode.substring(index1 + 1, index2);            return Long.parseLong(epochStr, 16);        } catch (NumberFormatException ignore) {                }    }    return 0;}
cbb19aa66d1327de7e2dec7cadcaa4b3812cbe5b51e0971bd580d7399c659907
sortChildren
protected void sortChildren(List<String> children)
{    internalSortChildren(children);}
b6896a54a6b75ddefa5cf16439eb361c5d43aa802e2c6c1f76517227b964a66a
makeRequeueItemPath
protected String makeRequeueItemPath(String itemPath)
{    return makeIdPath(parseId(itemPath).id);}
90ba0dddc593bd95e2a0c0c039c523b81bfb91f87814ebcb222c3914ca772ead
start
public void start() throws Exception
{    queue.start();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    queue.close();}
3c0af63b2575ebd84366d5bf9fd14ee73b87ebabc831d2da6a779b0ebc2727f6
getPutListenerContainer
public ListenerContainer<QueuePutListener<T>> getPutListenerContainer()
{    return queue.getPutListenerContainer();}
72b37de2175912fbfdb2ca9d52b5f2e6c74945b8057bddbce880e52a8bf5b211
setErrorMode
public void setErrorMode(ErrorMode newErrorMode)
{    queue.setErrorMode(newErrorMode);}
9db0334f768c6c0bcdabe9009cca53141fd8cf947ebbeb043b56aaa2c84b2f44
flushPuts
public boolean flushPuts(long waitTime, TimeUnit timeUnit) throws InterruptedException
{    return queue.flushPuts(waitTime, timeUnit);}
a7f13c20cf22242fec524d83dd657c8ddcd6f200a6d02f148afcb1d1a641c945
getLastMessageCount
public int getLastMessageCount()
{    return queue.getLastMessageCount();}
b8c521fa012115903bd4df3281bf536df4b899c773ddf245a3263c680942964e
put
public void put(T item, String itemId) throws Exception
{    put(item, itemId, 0, null);}
f0ab754a88712c2718ebe506aaf19a2598c3eaa5723435848616bdc671174845
put
public boolean put(T item, String itemId, int maxWait, TimeUnit unit) throws Exception
{    Preconditions.checkArgument(isValidId(itemId), "Invalid id: " + itemId);    queue.checkState();    return queue.internalPut(item, null, makeIdPath(itemId), maxWait, unit);}
9b81182592a7bf81f6c55a26aef3c3133fa5d165588757799650568bd3d28cde
remove
public int remove(String id) throws Exception
{    id = Preconditions.checkNotNull(id, "id cannot be null");    queue.checkState();    int count = 0;    for (String name : queue.getChildren()) {        if (parseId(name).id.equals(id)) {            if (queue.tryRemove(name)) {                ++count;            }        }    }    return count;}
13a46b3435c3613b9a122e3bc07df04ee9638b4ae1a1a39ea43dc83a6f83be0f
debugIsQueued
 boolean debugIsQueued(String id) throws Exception
{    for (String name : queue.getChildren()) {        if (parseId(name).id.equals(id)) {            return true;        }    }    return false;}
6e1dc2e883ba3bf792bd57225bb3bc06c3ea7a7c33b11dd5701047350daea721
makeIdPath
private String makeIdPath(String itemId)
{    return queue.makeItemPath() + SEPARATOR + fixId(itemId) + SEPARATOR;}
28bff8d2730b9cfc92e8744cb3b997ab387e359ff7b2f909601f8c1eb62dc355
internalSortChildren
private void internalSortChildren(List<String> children)
{    Collections.sort(children, new Comparator<String>() {        @Override        public int compare(String o1, String o2) {            return parseId(o1).cleaned.compareTo(parseId(o2).cleaned);        }    });}
35d131fdb7692f658b664d81b2ed14d907062a6b10b2966883992d774b8c32bd
compare
public int compare(String o1, String o2)
{    return parseId(o1).cleaned.compareTo(parseId(o2).cleaned);}
b28ed7a13a8c9282c81169ef31a36d64fbc328d5bddf69323f3fefd71ed973de
isValidId
private boolean isValidId(String id)
{    return (id != null) && (id.length() > 0);}
0209e739f7d204fcdf50c414845eefa986b8922b74821bba405fa590fbd70590
fixId
private static String fixId(String id)
{    String fixed = id.replace('/', '_');    return fixed.replace(SEPARATOR, '_');}
3c569670b546eb286de70de9d60a3a65d6dca59dfe7bc8bf24d414e8e52c557d
parseId
private Parts parseId(String name)
{    int firstIndex = name.indexOf(SEPARATOR);    int secondIndex = name.indexOf(SEPARATOR, firstIndex + 1);    if ((firstIndex < 0) || (secondIndex < 0)) {        log.error("Bad node in queue: " + name);        return new Parts(name, name);    }    return new Parts(name.substring(firstIndex + 1, secondIndex), name.substring(0, firstIndex) + name.substring(secondIndex + 1));}
90ba0dddc593bd95e2a0c0c039c523b81bfb91f87814ebcb222c3914ca772ead
start
public void start() throws Exception
{    queue.start();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    queue.close();}
92ca6c418366e6e6f12d8d3071b833acadb3005ebe4350407564b4baf9f2c1f8
put
public void put(T item, int priority) throws Exception
{    put(item, priority, 0, null);}
7305953f0b7ad78435858d17838acfcac4cb94c00d2288309bdf023cee20ce74
put
public boolean put(T item, int priority, int maxWait, TimeUnit unit) throws Exception
{    queue.checkState();    String priorityHex = priorityToString(priority);    return queue.internalPut(item, null, queue.makeItemPath() + priorityHex, maxWait, unit);}
1e7fed76f72958bc2c47bf91a5f043804a614eb1ecb764ead25a99049ff81ba5
putMulti
public void putMulti(MultiItem<T> items, int priority) throws Exception
{    putMulti(items, priority, 0, null);}
b20091a1f3ae02dad939ce3066b6c21360db9a9a9e43826765fa1d6872404f79
putMulti
public boolean putMulti(MultiItem<T> items, int priority, int maxWait, TimeUnit unit) throws Exception
{    queue.checkState();    String priorityHex = priorityToString(priority);    return queue.internalPut(null, items, queue.makeItemPath() + priorityHex, maxWait, unit);}
72b37de2175912fbfdb2ca9d52b5f2e6c74945b8057bddbce880e52a8bf5b211
setErrorMode
public void setErrorMode(ErrorMode newErrorMode)
{    queue.setErrorMode(newErrorMode);}
9db0334f768c6c0bcdabe9009cca53141fd8cf947ebbeb043b56aaa2c84b2f44
flushPuts
public boolean flushPuts(long waitTime, TimeUnit timeUnit) throws InterruptedException
{    return queue.flushPuts(waitTime, timeUnit);}
3c0af63b2575ebd84366d5bf9fd14ee73b87ebabc831d2da6a779b0ebc2727f6
getPutListenerContainer
public ListenerContainer<QueuePutListener<T>> getPutListenerContainer()
{    return queue.getPutListenerContainer();}
a7f13c20cf22242fec524d83dd657c8ddcd6f200a6d02f148afcb1d1a641c945
getLastMessageCount
public int getLastMessageCount()
{    return queue.getLastMessageCount();}
1f68d824269eb8769d8c807e2cb8ce42d233e630dc9778ed0dde3e0f8eb06eca
getCache
 ChildrenCache getCache()
{    return queue.getCache();}
4abbb37c2486a22ade219b61da572eff8a4d8f0e569493b17260c4fad7f442f9
priorityToString
 static String priorityToString(int priority)
{            long l = (long) priority & 0xFFFFFFFFL;    return String.format("%s%08X", (priority >= 0) ? "1" : "0", l);}
90ba0dddc593bd95e2a0c0c039c523b81bfb91f87814ebcb222c3914ca772ead
start
public void start() throws Exception
{    if (!state.compareAndSet(State.LATENT, State.STARTED)) {        throw new IllegalStateException();    }    try {        client.create().creatingParentContainersIfNeeded().forPath(queuePath);    } catch (KeeperException.NodeExistsException ignore) {        }    if (lockPath != null) {        try {            client.create().creatingParentContainersIfNeeded().forPath(lockPath);        } catch (KeeperException.NodeExistsException ignore) {                }    }    if (!isProducerOnly || (maxItems != QueueBuilder.NOT_SET)) {        childrenCache.start();    }    if (!isProducerOnly) {        service.submit(new Callable<Object>() {            @Override            public Object call() {                runLoop();                return null;            }        });    }}
8ddbbc8cc2055115ac600cd3c188d8462671957754411c629518534bb9a3af36
call
public Object call()
{    runLoop();    return null;}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    if (state.compareAndSet(State.STARTED, State.STOPPED)) {        if (finalFlushMs > 0) {            try {                flushPuts(finalFlushMs, TimeUnit.MILLISECONDS);            } catch (InterruptedException e) {                Thread.currentThread().interrupt();            }        }        CloseableUtils.closeQuietly(childrenCache);        putListenerContainer.clear();        service.shutdownNow();    }}
3c0af63b2575ebd84366d5bf9fd14ee73b87ebabc831d2da6a779b0ebc2727f6
getPutListenerContainer
public ListenerContainer<QueuePutListener<T>> getPutListenerContainer()
{    return putListenerContainer;}
72b37de2175912fbfdb2ca9d52b5f2e6c74945b8057bddbce880e52a8bf5b211
setErrorMode
public void setErrorMode(ErrorMode newErrorMode)
{    Preconditions.checkNotNull(lockPath, "lockPath cannot be null");    if (newErrorMode == ErrorMode.REQUEUE) {        log.warn("ErrorMode.REQUEUE requires ZooKeeper version 3.4.x+ - make sure you are not using a prior version");    }    errorMode.set(newErrorMode);}
9db0334f768c6c0bcdabe9009cca53141fd8cf947ebbeb043b56aaa2c84b2f44
flushPuts
public boolean flushPuts(long waitTime, TimeUnit timeUnit) throws InterruptedException
{    long msWaitRemaining = TimeUnit.MILLISECONDS.convert(waitTime, timeUnit);    synchronized (putCount) {        while (putCount.get() > 0) {            if (msWaitRemaining <= 0) {                return false;            }            long startMs = System.currentTimeMillis();            putCount.wait(msWaitRemaining);            long elapsedMs = System.currentTimeMillis() - startMs;            msWaitRemaining -= elapsedMs;        }    }    return true;}
03df6f560dbe5f74ffb3c40cff1d6c41b9b8387bd1f86ef2cc4f738966869d24
put
public void put(T item) throws Exception
{    put(item, 0, null);}
51483d987770e098be8ffdb63d6219dc53145b80f54c3be67ce21cea020858ec
put
public boolean put(T item, int maxWait, TimeUnit unit) throws Exception
{    checkState();    String path = makeItemPath();    return internalPut(item, null, path, maxWait, unit);}
6996cb4ce91362eebf0bccb2bd48b3e0e5e4af7b6c2de979c1818939f9fff25c
putMulti
public void putMulti(MultiItem<T> items) throws Exception
{    putMulti(items, 0, null);}
b39282d65774fa6c0d4a67b2aa5f245ac24e38b3da1119934f3b9a68c2be56e6
putMulti
public boolean putMulti(MultiItem<T> items, int maxWait, TimeUnit unit) throws Exception
{    checkState();    String path = makeItemPath();    return internalPut(null, items, path, maxWait, unit);}
a7f13c20cf22242fec524d83dd657c8ddcd6f200a6d02f148afcb1d1a641c945
getLastMessageCount
public int getLastMessageCount()
{    return lastChildCount.get();}
50576131dd10f9bb60957941619523a6be3e733f74502594a3bdfb9aefb33c41
internalPut
 boolean internalPut(final T item, MultiItem<T> multiItem, String path, int maxWait, TimeUnit unit) throws Exception
{    if (!blockIfMaxed(maxWait, unit)) {        return false;    }    final MultiItem<T> givenMultiItem = multiItem;    if (item != null) {        final AtomicReference<T> ref = new AtomicReference<T>(item);        multiItem = new MultiItem<T>() {            @Override            public T nextItem() throws Exception {                return ref.getAndSet(null);            }        };    }    putCount.incrementAndGet();    byte[] bytes = ItemSerializer.serialize(multiItem, serializer);    if (putInBackground) {        doPutInBackground(item, path, givenMultiItem, bytes);    } else {        doPutInForeground(item, path, givenMultiItem, bytes);    }    return true;}
2de9ba6babf82c3ab415e7756162daac3c0414b0f3922d4ffebe19fde192d0c5
nextItem
public T nextItem() throws Exception
{    return ref.getAndSet(null);}
33d31dd4180ce60d8804bd285e9cb9e1c576dfd03882035b979ccd4c6cfea23a
doPutInForeground
private void doPutInForeground(final T item, String path, final MultiItem<T> givenMultiItem, byte[] bytes) throws Exception
{    client.create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath(path, bytes);    synchronized (putCount) {        putCount.decrementAndGet();        putCount.notifyAll();    }    putListenerContainer.forEach(new Function<QueuePutListener<T>, Void>() {        @Override        public Void apply(QueuePutListener<T> listener) {            if (item != null) {                listener.putCompleted(item);            } else {                listener.putMultiCompleted(givenMultiItem);            }            return null;        }    });}
aa2ff55b22edca5d60b10abc719f9e7954279ac44598aed072f172228d7f3ba6
apply
public Void apply(QueuePutListener<T> listener)
{    if (item != null) {        listener.putCompleted(item);    } else {        listener.putMultiCompleted(givenMultiItem);    }    return null;}
a35734bd8836e28a17c4e4aeb5b51d46fe22ecb935036213504b6fdffbf10197
doPutInBackground
private void doPutInBackground(final T item, String path, final MultiItem<T> givenMultiItem, byte[] bytes) throws Exception
{    BackgroundCallback callback = new BackgroundCallback() {        @Override        public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {            if (event.getResultCode() != KeeperException.Code.OK.intValue()) {                return;            }            if (event.getType() == CuratorEventType.CREATE) {                synchronized (putCount) {                    putCount.decrementAndGet();                    putCount.notifyAll();                }            }            putListenerContainer.forEach(new Function<QueuePutListener<T>, Void>() {                @Override                public Void apply(QueuePutListener<T> listener) {                    if (item != null) {                        listener.putCompleted(item);                    } else {                        listener.putMultiCompleted(givenMultiItem);                    }                    return null;                }            });        }    };    internalCreateNode(path, bytes, callback);}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getResultCode() != KeeperException.Code.OK.intValue()) {        return;    }    if (event.getType() == CuratorEventType.CREATE) {        synchronized (putCount) {            putCount.decrementAndGet();            putCount.notifyAll();        }    }    putListenerContainer.forEach(new Function<QueuePutListener<T>, Void>() {        @Override        public Void apply(QueuePutListener<T> listener) {            if (item != null) {                listener.putCompleted(item);            } else {                listener.putMultiCompleted(givenMultiItem);            }            return null;        }    });}
aa2ff55b22edca5d60b10abc719f9e7954279ac44598aed072f172228d7f3ba6
apply
public Void apply(QueuePutListener<T> listener)
{    if (item != null) {        listener.putCompleted(item);    } else {        listener.putMultiCompleted(givenMultiItem);    }    return null;}
d30f4a8013b646cd5c07be21fda8d0748dde4e8eea05d7fcd7ef5a014925b296
internalCreateNode
 void internalCreateNode(String path, byte[] bytes, BackgroundCallback callback) throws Exception
{    client.create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).inBackground(callback).forPath(path, bytes);}
98b63bfaa60b413068d9024766f60759bd4ce0292417c9a2afdf59d1c91a04bc
checkState
 void checkState() throws Exception
{    if (state.get() != State.STARTED) {        throw new IllegalStateException();    }}
edb3443d8ba9c4635224dcc4b5ac7000d628a013de8b51822bd7e2fb8ee66bdb
makeItemPath
 String makeItemPath()
{    return ZKPaths.makePath(queuePath, QUEUE_ITEM_NAME);}
1f68d824269eb8769d8c807e2cb8ce42d233e630dc9778ed0dde3e0f8eb06eca
getCache
 ChildrenCache getCache()
{    return childrenCache;}
cbb19aa66d1327de7e2dec7cadcaa4b3812cbe5b51e0971bd580d7399c659907
sortChildren
protected void sortChildren(List<String> children)
{    Collections.sort(children);}
83a0dbfdc2a931fa64d7750f4e643c981eba883fe973982e7bfb89fcb0167921
getChildren
protected List<String> getChildren() throws Exception
{    return client.getChildren().forPath(queuePath);}
02d07b35142ac4ef9c1e8ee5a4da20dad5d427d59aa873fe0bf0f9e5f55abdb3
getDelay
protected long getDelay(String itemNode)
{    return 0;}
3b059528690ce7248c5a9d9b697cec106a889fb39d07af0504e50b9f5a7cc594
tryRemove
protected boolean tryRemove(String itemNode) throws Exception
{    boolean isUsingLockSafety = (lockPath != null);    if (isUsingLockSafety) {        return processWithLockSafety(itemNode, ProcessType.REMOVE);    }    return processNormally(itemNode, ProcessType.REMOVE);}
c4165bae944e62f532cc77bdec9237c047f693f87ce1cd2969fe07ca73fe83a2
blockIfMaxed
private boolean blockIfMaxed(int maxWait, TimeUnit unit) throws Exception
{    ChildrenCache.Data data = childrenCache.getData();    while (data.children.size() >= maxItems) {        long previousVersion = data.version;        data = childrenCache.blockingNextGetData(data.version, maxWait, unit);        if (data.version == previousVersion) {            return false;        }    }    return true;}
4bad449a7cb9e0e24665d851cc68ed14f1474e6099c92ad1b4d0b02dcc803a83
runLoop
private void runLoop()
{    long currentVersion = -1;    long maxWaitMs = -1;    try {        while (state.get() == State.STARTED) {            try {                ChildrenCache.Data data = (maxWaitMs > 0) ? childrenCache.blockingNextGetData(currentVersion, maxWaitMs, TimeUnit.MILLISECONDS) : childrenCache.blockingNextGetData(currentVersion);                currentVersion = data.version;                List<String> children = Lists.newArrayList(data.children);                                sortChildren(children);                if (children.size() > 0) {                    maxWaitMs = getDelay(children.get(0));                    if (maxWaitMs > 0) {                        continue;                    }                } else {                    continue;                }                processChildren(children, currentVersion);            } catch (InterruptedException e) {                                                }        }    } catch (Exception e) {        log.error("Exception caught in background handler", e);    }}
efb4f950fcc9e63b2fbc040b06b8f7836114288db68f607865c7ac4d864bad54
processChildren
private void processChildren(List<String> children, long currentVersion) throws Exception
{    final Semaphore processedLatch = new Semaphore(0);    final boolean isUsingLockSafety = (lockPath != null);    int min = minItemsBeforeRefresh;    for (final String itemNode : children) {        if (Thread.currentThread().isInterrupted()) {            processedLatch.release(children.size());            break;        }        if (!itemNode.startsWith(QUEUE_ITEM_NAME)) {            log.warn("Foreign node in queue path: " + itemNode);            processedLatch.release();            continue;        }        if (min-- <= 0) {            if (refreshOnWatch && (currentVersion != childrenCache.getData().version)) {                processedLatch.release(children.size());                break;            }        }        if (getDelay(itemNode) > 0) {            processedLatch.release();            continue;        }        executor.execute(new Runnable() {            @Override            public void run() {                try {                    if (isUsingLockSafety) {                        processWithLockSafety(itemNode, ProcessType.NORMAL);                    } else {                        processNormally(itemNode, ProcessType.NORMAL);                    }                } catch (Exception e) {                    ThreadUtils.checkInterrupted(e);                    log.error("Error processing message at " + itemNode, e);                } finally {                    processedLatch.release();                }            }        });    }    processedLatch.acquire(children.size());}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        if (isUsingLockSafety) {            processWithLockSafety(itemNode, ProcessType.NORMAL);        } else {            processNormally(itemNode, ProcessType.NORMAL);        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        log.error("Error processing message at " + itemNode, e);    } finally {        processedLatch.release();    }}
7e9d5ef4d6bf46fba7a6de7337c55fc9ff388989a21665ef4335e98550ef2ec5
processMessageBytes
private ProcessMessageBytesCode processMessageBytes(String itemNode, byte[] bytes) throws Exception
{    ProcessMessageBytesCode resultCode = ProcessMessageBytesCode.NORMAL;    MultiItem<T> items;    try {        items = ItemSerializer.deserialize(bytes, serializer);    } catch (Throwable e) {        ThreadUtils.checkInterrupted(e);        log.error("Corrupted queue item: " + itemNode, e);        return resultCode;    }    for (; ; ) {        T item = items.nextItem();        if (item == null) {            break;        }        try {            consumer.consumeMessage(item);        } catch (Throwable e) {            ThreadUtils.checkInterrupted(e);            log.error("Exception processing queue item: " + itemNode, e);            if (errorMode.get() == ErrorMode.REQUEUE) {                resultCode = ProcessMessageBytesCode.REQUEUE;                break;            }        }    }    return resultCode;}
e0dd79c77798a83a92b124fa558b3da480ebb5eabdd96149eb2ae48482df6f42
processNormally
private boolean processNormally(String itemNode, ProcessType type) throws Exception
{    try {        String itemPath = ZKPaths.makePath(queuePath, itemNode);        Stat stat = new Stat();        byte[] bytes = null;        if (type == ProcessType.NORMAL) {            bytes = client.getData().storingStatIn(stat).forPath(itemPath);        }        if (client.getState() == CuratorFrameworkState.STARTED) {            client.delete().withVersion(stat.getVersion()).forPath(itemPath);        }        if (type == ProcessType.NORMAL) {            processMessageBytes(itemNode, bytes);        }        return true;    } catch (KeeperException.NodeExistsException ignore) {        } catch (KeeperException.NoNodeException ignore) {        } catch (KeeperException.BadVersionException ignore) {        }    return false;}
3e881935c74c40af8ace1a3f758d9770843540da5226b1934d2bfdd87d90df2b
processWithLockSafety
protected boolean processWithLockSafety(String itemNode, ProcessType type) throws Exception
{    String lockNodePath = ZKPaths.makePath(lockPath, itemNode);    boolean lockCreated = false;    try {        client.create().withMode(CreateMode.EPHEMERAL).forPath(lockNodePath);        lockCreated = true;        String itemPath = ZKPaths.makePath(queuePath, itemNode);        boolean requeue = false;        byte[] bytes = null;        if (type == ProcessType.NORMAL) {            bytes = client.getData().forPath(itemPath);            requeue = (processMessageBytes(itemNode, bytes) == ProcessMessageBytesCode.REQUEUE);        }        if (requeue) {            client.inTransaction().delete().forPath(itemPath).and().create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath(makeRequeueItemPath(itemPath), bytes).and().commit();        } else {            client.delete().forPath(itemPath);        }        return true;    } catch (KeeperException.NodeExistsException ignore) {        } catch (KeeperException.NoNodeException ignore) {        } catch (KeeperException.BadVersionException ignore) {        } finally {        if (lockCreated) {            client.delete().guaranteed().forPath(lockNodePath);        }    }    return false;}
b6896a54a6b75ddefa5cf16439eb361c5d43aa802e2c6c1f76517227b964a66a
makeRequeueItemPath
protected String makeRequeueItemPath(String itemPath)
{    return makeItemPath();}
49c6ae579238e09bfacd72a573737e1bd59bebbf4ebd66ca21089e600aa456eb
deserialize
 static MultiItem<T> deserialize(byte[] bytes, QueueSerializer<T> serializer) throws Exception
{    DataInputStream in = new DataInputStream(new ByteArrayInputStream(bytes));    int version = in.readInt();    if (version != VERSION) {        throw new IOException(String.format("Incorrect version. Expected %d - Found: %d", VERSION, version));    }    List<T> items = Lists.newArrayList();    for (; ; ) {        byte opcode = in.readByte();        if (opcode == EOF_OPCODE) {            break;        }        if (opcode != ITEM_OPCODE) {            throw new IOException(String.format("Incorrect opcode. Expected %d - Found: %d", ITEM_OPCODE, opcode));        }        int size = in.readInt();        if (size < 0) {            throw new IOException(String.format("Bad size: %d", size));        }        byte[] itemBytes = new byte[size];        if (size > 0) {            in.readFully(itemBytes);        }        items.add(serializer.deserialize(itemBytes));    }    final Iterator<T> iterator = items.iterator();    return new MultiItem<T>() {        @Override        public T nextItem() {            return iterator.hasNext() ? iterator.next() : null;        }    };}
6bb4269dea2a6e114a66bb3a7fec5b0ba5ac2a763d51c5dd2c0b6e573e97ad26
nextItem
public T nextItem()
{    return iterator.hasNext() ? iterator.next() : null;}
625f47544d80e1e2246585cbb18010d9d6e33a308b3242f3b38d78847fe251bd
serialize
 static byte[] serialize(MultiItem<T> items, QueueSerializer<T> serializer) throws Exception
{    ByteArrayOutputStream bytes = new ByteArrayOutputStream(INITIAL_BUFFER_SIZE);    DataOutputStream out = new DataOutputStream(bytes);    out.writeInt(VERSION);    for (; ; ) {        T item = items.nextItem();        if (item == null) {            break;        }        byte[] itemBytes = serializer.serialize(item);        out.writeByte(ITEM_OPCODE);        out.writeInt(itemBytes.length);        if (itemBytes.length > 0) {            out.write(itemBytes);        }    }    out.writeByte(EOF_OPCODE);    out.close();    return bytes.toByteArray();}
3db6432ebebc31248c548a1bcc0408d83860fd5babc691c6a8285b5ff7fbe170
builder
public static QueueBuilder<T> builder(CuratorFramework client, QueueConsumer<T> consumer, QueueSerializer<T> serializer, String queuePath)
{    return new QueueBuilder<T>(client, consumer, serializer, queuePath);}
824c8fd023c9a58cc00f1fd0a2da52dbd02798d7d564b04333fc1ee721bc0d04
buildQueue
public DistributedQueue<T> buildQueue()
{    return new DistributedQueue<T>(client, consumer, serializer, queuePath, factory, executor, Integer.MAX_VALUE, false, lockPath, maxItems, putInBackground, finalFlushMs);}
a10d3c6240fe486c5f78bca0a4f0b7a75e8bdca099b751f884611d68b7218b94
buildIdQueue
public DistributedIdQueue<T> buildIdQueue()
{    return new DistributedIdQueue<T>(client, consumer, serializer, queuePath, factory, executor, Integer.MAX_VALUE, false, lockPath, maxItems, putInBackground, finalFlushMs);}
9333cfe4d901950f326a036250ecd55e03fc4d288c0676a180d35ee0c793ee40
buildPriorityQueue
public DistributedPriorityQueue<T> buildPriorityQueue(int minItemsBeforeRefresh)
{    return new DistributedPriorityQueue<T>(client, consumer, serializer, queuePath, factory, executor, minItemsBeforeRefresh, lockPath, maxItems, putInBackground, finalFlushMs);}
1505100e37a8cc7acd3f871d05fe60a46daa711c6922e897f94fceeb18124721
buildDelayQueue
public DistributedDelayQueue<T> buildDelayQueue()
{    return new DistributedDelayQueue<T>(client, consumer, serializer, queuePath, factory, executor, Integer.MAX_VALUE, lockPath, maxItems, putInBackground, finalFlushMs);}
f4cee70e60707d2a30f824dd2685780e674c904a4ac5e381da65f1751b3392ac
threadFactory
public QueueBuilder<T> threadFactory(ThreadFactory factory)
{    Preconditions.checkNotNull(factory, "factory cannot be null");    this.factory = factory;    return this;}
5e51362021cdd25467006f8589fde7daf3371b5b635b9a6df73792605ca298ed
executor
public QueueBuilder<T> executor(Executor executor)
{    Preconditions.checkNotNull(executor, "executor cannot be null");    this.executor = executor;    return this;}
464702d3c37396841503d4be850cae5493e70d8628877eb76ff8fff27b6cd205
lockPath
public QueueBuilder<T> lockPath(String path)
{    lockPath = PathUtils.validatePath(path);    return this;}
8f47cf7df96fced9813b8428a20b92188fc19c76d56a013809d9cf29876b0948
maxItems
public QueueBuilder<T> maxItems(int maxItems)
{    this.maxItems = maxItems;    putInBackground = false;    return this;}
c155d54c88d845245a2f5702a41387bd4baf1966c2dc4d65954ff0045b352c63
putInBackground
public QueueBuilder<T> putInBackground(boolean putInBackground)
{    this.putInBackground = putInBackground;    return this;}
dcd50b4aa40122580ddabe9a3382d4381cc3a49875cab9060905270333911191
finalFlushTime
public QueueBuilder<T> finalFlushTime(int time, TimeUnit unit)
{    finalFlushMs = (int) unit.toMillis(time);    return this;}
7124f369ef1e51b0c73e2cf3fd9c5240507bc4d1823d190ba0826ffc19b35659
getLockPath
 String getLockPath()
{    return lockPath;}
98700a98d30e3b9684fcb33477d01d22a47d34a02daea80b1aa4edd2dd282731
getConsumer
 QueueConsumer<T> getConsumer()
{    return consumer;}
07d03fe2494a3a04be394d523760653c66e68c3fe2226c05445a92175b41e1cc
getQueue
 BlockingQueue<T> getQueue()
{    return queue;}
90ba0dddc593bd95e2a0c0c039c523b81bfb91f87814ebcb222c3914ca772ead
start
public void start() throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    client.createContainers(queuePath);    getInitialQueues();    leaderLatch.start();    service.submit(new Callable<Void>() {        @Override        public Void call() throws Exception {            while (state.get() == State.STARTED) {                try {                    Thread.sleep(policies.getThresholdCheckMs());                    checkThreshold();                } catch (InterruptedException e) {                                                                }            }            return null;        }    });}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    while (state.get() == State.STARTED) {        try {            Thread.sleep(policies.getThresholdCheckMs());            checkThreshold();        } catch (InterruptedException e) {                                }    }    return null;}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    if (state.compareAndSet(State.STARTED, State.CLOSED)) {        service.shutdownNow();        CloseableUtils.closeQuietly(leaderLatch);        for (T queue : queues.values()) {            try {                queue.close();            } catch (IOException e) {                log.error("Closing a queue", e);            }        }    }}
e14b1c22682412ddfa06a81031f9a9b44e23480f0b30243b73e98d4bde973c6e
getQueue
public T getQueue()
{    Preconditions.checkState(state.get() == State.STARTED, "Not started");    List<String> localPreferredQueues = Lists.newArrayList(preferredQueues);    if (localPreferredQueues.size() > 0) {        String key = localPreferredQueues.get(random.nextInt(localPreferredQueues.size()));        return queues.get(key);    }    List<String> keys = Lists.newArrayList(queues.keySet());    String key = keys.get(random.nextInt(keys.size()));    return queues.get(key);}
1c19fe0ec10eb4db6a11ab130c7ee8cd8b4b758f2f2bd2c14ff8bac10e6ab9ab
getShardQty
public int getShardQty()
{    return queues.size();}
c39d006253b0004c6d74cdf5354554f70c3fb9051e9138477eccc766b94b1e60
getQueuePaths
public Collection<String> getQueuePaths()
{    return ImmutableSet.copyOf(queues.keySet());}
a8d026d718edd61b159effc2b660a2c0d395ede60c0c9ce7ecc17c8d73771e32
getInitialQueues
private void getInitialQueues() throws Exception
{    List<String> children = client.getChildren().forPath(queuePath);    for (String child : children) {        String queuePath = ZKPaths.makePath(this.queuePath, child);        addNewQueueIfNeeded(queuePath);    }    if (children.size() == 0) {        addNewQueueIfNeeded(null);    }}
5029152068c0f80857f775daaf5c23a53ac3e9f17741e0fec824e61a46d1304b
addNewQueueIfNeeded
private void addNewQueueIfNeeded(String newQueuePath) throws Exception
{    if (newQueuePath == null) {        newQueuePath = ZKPaths.makePath(queuePath, QUEUE_PREFIX + UUID.randomUUID().toString());    }    if (!queues.containsKey(newQueuePath)) {        T queue = queueAllocator.allocateQueue(client, newQueuePath);        if (queues.putIfAbsent(newQueuePath, queue) == null) {            queue.start();            preferredQueues.add(newQueuePath);        }    }}
3ecd4cf288e2445356e66d3c831b5d077f75d456b734f78d6bf6509aa99f3f08
checkThreshold
private void checkThreshold()
{    try {        boolean addAQueueIfLeader = false;        int size = 0;        List<String> children = client.getChildren().forPath(queuePath);        for (String child : children) {            String queuePath = ZKPaths.makePath(this.queuePath, child);            addNewQueueIfNeeded(queuePath);            Stat stat = client.checkExists().forPath(queuePath);            if (stat.getNumChildren() >= policies.getNewQueueThreshold()) {                size = stat.getNumChildren();                addAQueueIfLeader = true;                preferredQueues.remove(queuePath);            } else if (stat.getNumChildren() <= (policies.getNewQueueThreshold() / 2)) {                preferredQueues.add(queuePath);            }        }        if (addAQueueIfLeader && leaderLatch.hasLeadership()) {            if (queues.size() < policies.getMaxQueues()) {                log.info(String.format("Adding a queue due to exceeded threshold. Queue Size: %d - Threshold: %d", size, policies.getNewQueueThreshold()));                addNewQueueIfNeeded(null);            } else {                log.warn(String.format("Max number of queues (%d) reached. Consider increasing the max.", policies.getMaxQueues()));            }        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        log.error("Checking queue counts against threshold", e);    }}
d715e9be637d90353a91d8307669aae52d900858543503ec4ee51a4c1f12c3c7
newQueueThreshold
public Builder newQueueThreshold(int newQueueThreshold)
{    Preconditions.checkArgument(newQueueThreshold > 0, "newQueueThreshold must be a positive number");    policies.newQueueThreshold = newQueueThreshold;    return this;}
5316804d7724cb5b35c0c95ca2c24d751fc6987eaa54fa30ac451010f6d81d0a
thresholdCheckMs
public Builder thresholdCheckMs(int thresholdCheckMs)
{    Preconditions.checkArgument(thresholdCheckMs > 0, "thresholdCheckMs must be a positive number");    policies.thresholdCheckMs = thresholdCheckMs;    return this;}
ead9888a8f1e0b9bbfe86a8164f9cd0a5a62ca24f2b952f900bbb8ee0792763e
maxQueues
public Builder maxQueues(int maxQueues)
{    Preconditions.checkArgument(maxQueues > 0, "thresholdCheckMs must be a positive number");    policies.maxQueues = maxQueues;    return this;}
537a1b22e89f7a7e3454807b30e52b45971de78814dbd226bd24513ef52fc8e6
threadFactory
public Builder threadFactory(ThreadFactory threadFactory)
{    policies.threadFactory = Preconditions.checkNotNull(threadFactory, "threadFactory cannot be null");    return this;}
c933891ecca8663938412c22861536b09e283b3cea90a3784ce6ac2c546354a9
build
public QueueSharderPolicies build()
{    try {        return policies;    } finally {        policies = new QueueSharderPolicies();    }}
cf558fab344ef794057daaaf3d4721487c20c3f85d09e31f5c8f20f006d4a450
builder
public static Builder builder()
{    return new Builder();}
bb41e77d54993a95b021abf49f0019ce9f74b95cff407efc3e330ca37163d37d
getNewQueueThreshold
 int getNewQueueThreshold()
{    return newQueueThreshold;}
b101f313341988345a964591291a3d846c99ef468735f9479a38cc28ddc376c8
getThresholdCheckMs
 int getThresholdCheckMs()
{    return thresholdCheckMs;}
a3c2571a81e0aa305aea74e0c2c64a21bce26ef6cb4f6204ae14bcc2ac3f2d9a
getMaxQueues
 int getMaxQueues()
{    return maxQueues;}
c08fcf216c96af219e80cca5d249bf07c7295176ba0e9d27d094b1ddfba9b307
getThreadFactory
 ThreadFactory getThreadFactory()
{    return threadFactory;}
b5478fc4e4374e75ef718f9139df1b0bf627d520560601c8dfb2066c834b6777
element
public byte[] element() throws Exception
{    byte[] bytes = internalElement(false, null);    if (bytes == null) {        throw new NoSuchElementException();    }    return bytes;}
58947336ee23b3ede1085fb3e37026b6ad948fffc2fc8c8d5f17f044d94705b0
remove
public byte[] remove() throws Exception
{    byte[] bytes = internalElement(true, null);    if (bytes == null) {        throw new NoSuchElementException();    }    return bytes;}
a4a61689062e2b679d4d45ab36c64c55ffcd6269b2eeeeca7614b62fbd6dfcf9
take
public byte[] take() throws Exception
{    return internalPoll(0, null);}
e0e6413ca4fd738f17f529fbc29a0275fd25196563e2f683ace86a8a45078759
offer
public boolean offer(byte[] data) throws Exception
{    String thisPath = ZKPaths.makePath(path, PREFIX);    client.create().creatingParentContainersIfNeeded().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath(thisPath, data);    return true;}
9d444ff14f1906349d92401d890177f16c9cf9e45e1b0de9ac3c1eeef5d82685
peek
public byte[] peek() throws Exception
{    try {        return element();    } catch (NoSuchElementException e) {        return null;    }}
2404642bc989e7851f556d28648790d45e056a7b1102d5357f6c15bdab2ad45e
poll
public byte[] poll(long timeout, TimeUnit unit) throws Exception
{    return internalPoll(timeout, unit);}
3b2e33ae4f2a160380589396577aa8816df8de69c1b115fb1309f372b1ee712d
poll
public byte[] poll() throws Exception
{    try {        return remove();    } catch (NoSuchElementException e) {        return null;    }}
b4def6d6853ff3668c34d38ddfa38cc1024cbf7430c55e8f67e5fa0f3dc074dd
ensurePath
protected void ensurePath() throws Exception
{    ensureContainers.ensure();}
22264df5359886099cac86f4c3d43d34c5fc99d22d126c10bf89bbe4c4073427
internalPoll
private byte[] internalPoll(long timeout, TimeUnit unit) throws Exception
{    ensurePath();    long startMs = System.currentTimeMillis();    boolean hasTimeout = (unit != null);    long maxWaitMs = hasTimeout ? TimeUnit.MILLISECONDS.convert(timeout, unit) : Long.MAX_VALUE;    for (; ; ) {        final CountDownLatch latch = new CountDownLatch(1);        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                latch.countDown();            }        };        byte[] bytes;        try {            bytes = internalElement(true, watcher);        } catch (NoSuchElementException dummy) {            log.debug("Parent containers appear to have lapsed - recreate and retry");            ensureContainers.reset();            continue;        }        if (bytes != null) {            return bytes;        }        if (hasTimeout) {            long elapsedMs = System.currentTimeMillis() - startMs;            long thisWaitMs = maxWaitMs - elapsedMs;            if (thisWaitMs <= 0) {                return null;            }            latch.await(thisWaitMs, TimeUnit.MILLISECONDS);        } else {            latch.await();        }    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    latch.countDown();}
08b25a32287c057186fde0b8d0bbc782967d07e99d18c042d6faa4c1caaddfde
internalElement
private byte[] internalElement(boolean removeIt, Watcher watcher) throws Exception
{    ensurePath();    List<String> nodes;    try {        nodes = (watcher != null) ? client.getChildren().usingWatcher(watcher).forPath(path) : client.getChildren().forPath(path);    } catch (KeeperException.NoNodeException dummy) {        throw new NoSuchElementException();    }    Collections.sort(nodes);    for (String node : nodes) {        if (!node.startsWith(PREFIX)) {            log.warn("Foreign node in queue path: " + node);            continue;        }        String thisPath = ZKPaths.makePath(path, node);        try {            byte[] bytes = client.getData().forPath(thisPath);            if (removeIt) {                client.delete().forPath(thisPath);            }            return bytes;        } catch (KeeperException.NoNodeException ignore) {                }    }    return null;}
29fa59e92e8a9fa433fd7b38ebb21e8ece484149bc8e4a2726bba6f5dab39acf
getCount
public int getCount()
{    return fromBytes(sharedValue.getValue());}
d1f85098b69172321937d9dc64e39908e38aeaee59c4389c701c66888130516a
getVersionedValue
public VersionedValue<Integer> getVersionedValue()
{    VersionedValue<byte[]> localValue = sharedValue.getVersionedValue();    return new VersionedValue<Integer>(localValue.getVersion(), fromBytes(localValue.getValue()));}
450ed78f1753865e0e17ad466d9e167c4d880d338cb20b35f9b9491b6861c570
setCount
public void setCount(int newCount) throws Exception
{    sharedValue.setValue(toBytes(newCount));}
91e504a28ab3e12fb6759e8ff2f4a489dfac92145c118e862594e0e9d21c9921
trySetCount
public boolean trySetCount(int newCount) throws Exception
{    return sharedValue.trySetValue(toBytes(newCount));}
8cdf7d7b415f8b83757a0db51fe03f099cf49208923832367ab2c224c8068879
trySetCount
public boolean trySetCount(VersionedValue<Integer> previous, int newCount) throws Exception
{    VersionedValue<byte[]> previousCopy = new VersionedValue<byte[]>(previous.getVersion(), toBytes(previous.getValue()));    return sharedValue.trySetValue(previousCopy, toBytes(newCount));}
1f4b813de1e7a7631670715825cb91477df22f5bf6a7f752dfa7bece54360591
addListener
public void addListener(SharedCountListener listener)
{    addListener(listener, MoreExecutors.directExecutor());}
88f9e3d75bcdb8733b2c83373c15a9ef1fb05d9a11b24840a1df94d6283bff77
addListener
public void addListener(final SharedCountListener listener, Executor executor)
{    SharedValueListener valueListener = new SharedValueListener() {        @Override        public void valueHasChanged(SharedValueReader sharedValue, byte[] newValue) throws Exception {            listener.countHasChanged(SharedCount.this, fromBytes(newValue));        }        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {            listener.stateChanged(client, newState);        }    };    sharedValue.getListenable().addListener(valueListener, executor);    listeners.put(listener, valueListener);}
60359555278767a8e2b5bfb3054d78a2e5348fb90573da5b58db1b4c1e53297a
valueHasChanged
public void valueHasChanged(SharedValueReader sharedValue, byte[] newValue) throws Exception
{    listener.countHasChanged(SharedCount.this, fromBytes(newValue));}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    listener.stateChanged(client, newState);}
25087a7ac2b5574a5299870104af20bfdbd87fa2ebad42f8054d2056a943eab7
removeListener
public void removeListener(SharedCountListener listener)
{    SharedValueListener valueListener = listeners.remove(listener);    if (valueListener != null) {        sharedValue.getListenable().removeListener(valueListener);    }}
90ba0dddc593bd95e2a0c0c039c523b81bfb91f87814ebcb222c3914ca772ead
start
public void start() throws Exception
{    sharedValue.start();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    sharedValue.close();}
d8f527f8c85f225bece86cc2d9e821112c5b66da48c4a05ddb1721d6ac26a0c2
toBytes
 static byte[] toBytes(int value)
{    byte[] bytes = new byte[4];    ByteBuffer.wrap(bytes).putInt(value);    return bytes;}
45121b6b8734a258c5b03636286e2e323236ab8002cf498dea48b00bbee0503b
fromBytes
private static int fromBytes(byte[] bytes)
{    return ByteBuffer.wrap(bytes).getInt();}
a4803fca4797306b4f772a40c997680043dc08b35469407056bd5b28cf26096b
process
public void process(WatchedEvent event) throws Exception
{    if (state.get() == State.STARTED && event.getType() != Watcher.Event.EventType.None) {                readValueAndNotifyListenersInBackground();    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    notifyListenerOfStateChanged(newState);    if (newState.isConnected()) {        try {            readValueAndNotifyListenersInBackground();        } catch (Exception e) {            ThreadUtils.checkInterrupted(e);            log.error("Could not read value after reconnect", e);        }    }}
768cb464386b001b0f4378ca3117eaa61a9d8c39dfb7b4046c129329af53abcb
getValue
public byte[] getValue()
{    VersionedValue<byte[]> localCopy = currentValue.get();    return Arrays.copyOf(localCopy.getValue(), localCopy.getValue().length);}
293edbdf79fc35ff9f42422f9d986c0778eba7e3ffd350f104837e9261f3c5c4
getVersionedValue
public VersionedValue<byte[]> getVersionedValue()
{    VersionedValue<byte[]> localCopy = currentValue.get();    return new VersionedValue<byte[]>(localCopy.getVersion(), Arrays.copyOf(localCopy.getValue(), localCopy.getValue().length));}
1f86cf0b6759c3eee045c7dda8f5b4893bf7948840b7c5cbe4645be2a4f1c3e1
setValue
public void setValue(byte[] newValue) throws Exception
{    Preconditions.checkState(state.get() == State.STARTED, "not started");    Stat result = client.setData().forPath(path, newValue);    updateValue(result.getVersion(), Arrays.copyOf(newValue, newValue.length));}
db3b0fe4ba4aaa92c5024e5100821114185f341dff40383f27cbfc48c48f1d30
trySetValue
public boolean trySetValue(byte[] newValue) throws Exception
{    return trySetValue(currentValue.get(), newValue);}
448004c8ea230b6e2749063e44fa930de131dd46679598abc4dd13c506c7fd00
trySetValue
public boolean trySetValue(VersionedValue<byte[]> previous, byte[] newValue) throws Exception
{    Preconditions.checkState(state.get() == State.STARTED, "not started");    VersionedValue<byte[]> current = currentValue.get();    if (previous.getVersion() != current.getVersion() || !Arrays.equals(previous.getValue(), current.getValue())) {        return false;    }    try {        Stat result = client.setData().withVersion(previous.getVersion()).forPath(path, newValue);        updateValue(result.getVersion(), Arrays.copyOf(newValue, newValue.length));        return true;    } catch (KeeperException.BadVersionException ignore) {        }    readValue();    return false;}
b608853efa500a43515f7b7a045c49b6a4d1b0e44415e8dd9669bea161640497
updateValue
private void updateValue(int version, byte[] bytes)
{    while (true) {        VersionedValue<byte[]> current = currentValue.get();        if (current.getVersion() >= version) {                        return;        }        if (currentValue.compareAndSet(current, new VersionedValue<byte[]>(version, bytes))) {                        return;        }        }}
34f4a15d1f2ed3b0c4bb7a69fac1254975228d243c55750bac65aceef3c315fe
getListenable
public ListenerContainer<SharedValueListener> getListenable()
{    return listeners;}
90ba0dddc593bd95e2a0c0c039c523b81bfb91f87814ebcb222c3914ca772ead
start
public void start() throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    client.getConnectionStateListenable().addListener(connectionStateListener);    try {        client.create().creatingParentContainersIfNeeded().forPath(path, seedValue);    } catch (KeeperException.NodeExistsException ignore) {        }    readValue();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    state.set(State.CLOSED);    client.removeWatchers();    client.getConnectionStateListenable().removeListener(connectionStateListener);    listeners.clear();}
43c62046ddc4538d934110eea69e089b02c98b2be61f7b0a2ef27ac40a0dc8f3
readValue
private void readValue() throws Exception
{    Stat localStat = new Stat();    byte[] bytes = client.getData().storingStatIn(localStat).usingWatcher(watcher).forPath(path);    updateValue(localStat.getVersion(), bytes);}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    if (event.getResultCode() == KeeperException.Code.OK.intValue()) {        updateValue(event.getStat().getVersion(), event.getData());        notifyListeners();    }}
cb84036d56a14c032d5069f05dee53f992a440c2144bad8b4e67de11855d77d1
readValueAndNotifyListenersInBackground
private void readValueAndNotifyListenersInBackground() throws Exception
{    client.getData().usingWatcher(watcher).inBackground(upadateAndNotifyListenerCallback).forPath(path);}
dc497f5f4ecc37ca0db03650140d6b1f2ea9a6172f2a0c02ff8e04c4fe306d4b
notifyListeners
private void notifyListeners()
{    final byte[] localValue = getValue();    listeners.forEach(new Function<SharedValueListener, Void>() {        @Override        public Void apply(SharedValueListener listener) {            try {                listener.valueHasChanged(SharedValue.this, localValue);            } catch (Exception e) {                ThreadUtils.checkInterrupted(e);                log.error("From SharedValue listener", e);            }            return null;        }    });}
4f813c9b8e7e0e67667748e6006f1df13d36129818361e1d592e2762b7e8931a
apply
public Void apply(SharedValueListener listener)
{    try {        listener.valueHasChanged(SharedValue.this, localValue);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        log.error("From SharedValue listener", e);    }    return null;}
21f43cabc499a4063459bd735b4e19b18d707b2fffde2953097038bd6c19511c
notifyListenerOfStateChanged
private void notifyListenerOfStateChanged(final ConnectionState newState)
{    listeners.forEach(new Function<SharedValueListener, Void>() {        @Override        public Void apply(SharedValueListener listener) {            listener.stateChanged(client, newState);            return null;        }    });}
4f813c9b8e7e0e67667748e6006f1df13d36129818361e1d592e2762b7e8931a
apply
public Void apply(SharedValueListener listener)
{    listener.stateChanged(client, newState);    return null;}
54bc0b349a40e5994cc6b2b7c63b7bdb8eaebafd56321e290c868307cb2a4574
getVersion
public int getVersion()
{    return version;}
5d1a642cd3f56327936f74c7e42620bdce9a2aa959d5c16e15c526e66eba684a
getValue
public T getValue()
{    return value;}
0e0b6a90addcb5140d7b61d5cb35de4050d85bbc964b7ec1a6f129377daa2f00
testListenersReconnectedIsOK
public void testListenersReconnectedIsOK() throws Exception
{    server.close();    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    PersistentEphemeralNode node = null;    try {        client.start();        node = new PersistentEphemeralNode(client, PersistentEphemeralNode.Mode.EPHEMERAL, "/abc/node", "hello".getBytes());        node.start();        final CountDownLatch connectedLatch = new CountDownLatch(1);        final CountDownLatch reconnectedLatch = new CountDownLatch(1);        final AtomicReference<ConnectionState> lastState = new AtomicReference<ConnectionState>();        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                lastState.set(newState);                if (newState == ConnectionState.CONNECTED) {                    connectedLatch.countDown();                }                if (newState == ConnectionState.RECONNECTED) {                    reconnectedLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        timing.sleepABit();        server = new TestingServer(server.getPort());        Assert.assertTrue(timing.awaitLatch(connectedLatch));        timing.sleepABit();        Assert.assertTrue(node.waitForInitialCreate(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS));        server.restart();        timing.sleepABit();        Assert.assertTrue(timing.awaitLatch(reconnectedLatch));        timing.sleepABit();        Assert.assertEquals(lastState.get(), ConnectionState.RECONNECTED);    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(node);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    lastState.set(newState);    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    }    if (newState == ConnectionState.RECONNECTED) {        reconnectedLatch.countDown();    }}
069cc1d1f2d774c0219d42c8979f7df325f9eb7cf874a5ab585ac0a681a5a396
testConnectionStateListener
public void testConnectionStateListener() throws Exception
{    server.close();    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(timing.milliseconds()));    try {        client.start();        final BlockingQueue<ConnectionState> stateVector = Queues.newLinkedBlockingQueue(1);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                stateVector.offer(newState);            }        };        Timing waitingTiming = timing.forWaiting();        client.getConnectionStateListenable().addListener(listener);        server = new TestingServer(server.getPort());        Assert.assertEquals(stateVector.poll(waitingTiming.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED);        server.stop();        Assert.assertEquals(stateVector.poll(waitingTiming.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED);        Assert.assertEquals(stateVector.poll(waitingTiming.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST);        server.restart();        Assert.assertEquals(stateVector.poll(waitingTiming.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.RECONNECTED);        server.close();        Assert.assertEquals(stateVector.poll(waitingTiming.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED);        Assert.assertEquals(stateVector.poll(waitingTiming.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST);    } finally {        CloseableUtils.closeQuietly(client);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    stateVector.offer(newState);}
069cc1d1f2d774c0219d42c8979f7df325f9eb7cf874a5ab585ac0a681a5a396
testConnectionStateListener
public void testConnectionStateListener() throws Exception
{    server.stop();    LeaderSelector selector = null;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        timing.sleepABit();        LeaderSelectorListener listenerLeader = new LeaderSelectorListenerAdapter() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                Thread.currentThread().join();            }        };        selector = new LeaderSelector(client, "/leader", listenerLeader);        selector.autoRequeue();        selector.start();        final BlockingQueue<ConnectionState> listenerSequence = Queues.newLinkedBlockingQueue();        ConnectionStateListener listener1 = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                listenerSequence.add(newState);            }        };        Timing forWaiting = timing.forWaiting();        client.getConnectionStateListenable().addListener(listener1);        log.debug("Starting ZK server");        server.restart();        Assert.assertEquals(listenerSequence.poll(forWaiting.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED);        log.debug("Stopping ZK server");        server.stop();        Assert.assertEquals(listenerSequence.poll(forWaiting.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED);        Assert.assertEquals(listenerSequence.poll(forWaiting.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST);        log.debug("Starting ZK server");        server.restart();        Assert.assertEquals(listenerSequence.poll(forWaiting.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.RECONNECTED);        log.debug("Stopping ZK server");        server.close();        Assert.assertEquals(listenerSequence.poll(forWaiting.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED);        Assert.assertEquals(listenerSequence.poll(forWaiting.milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST);    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
572980c734fcdd22464cc98d1931013f84abfc71246389b062e7e113e357572e
takeLeadership
public void takeLeadership(CuratorFramework client) throws Exception
{    Thread.currentThread().join();}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    listenerSequence.add(newState);}
32910a2246f284a3126d2df73956c06b66e6dc94999f37da0dae91d771e4320d
testWithError
public void testWithError() throws Exception
{    final int FACTOR = 100;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        AtomicValue<Long> value = new MutableAtomicValue<Long>(0L, (long) FACTOR, true);        final AtomicReference<AtomicValue<Long>> fakeValueRef = new AtomicReference<AtomicValue<Long>>(value);        DistributedAtomicLong dal = new DistributedAtomicLong(client, "/", null, null) {            @Override            public AtomicValue<Long> trySet(Long newValue) throws Exception {                return fakeValueRef.get();            }            @Override            public AtomicValue<Long> get() throws Exception {                return fakeValueRef.get();            }            @Override            public AtomicValue<Long> increment() throws Exception {                return fakeValueRef.get();            }            @Override            public AtomicValue<Long> decrement() throws Exception {                return fakeValueRef.get();            }            @Override            public AtomicValue<Long> add(Long delta) throws Exception {                return fakeValueRef.get();            }            @Override            public AtomicValue<Long> subtract(Long delta) throws Exception {                return fakeValueRef.get();            }            @Override            public void forceSet(Long newValue) throws Exception {            }            @Override            public AtomicValue<Long> compareAndSet(Long expectedValue, Long newValue) throws Exception {                return fakeValueRef.get();            }        };        CachedAtomicLong cachedLong = new CachedAtomicLong(dal, FACTOR);        for (int i = 0; i < FACTOR; ++i) {            value = cachedLong.next();            Assert.assertTrue(value.succeeded());            Assert.assertEquals(value.preValue().longValue(), i);            Assert.assertEquals(value.postValue().longValue(), i + 1);            if (i == 0) {                MutableAtomicValue<Long> badValue = new MutableAtomicValue<Long>(0L, 0L);                badValue.succeeded = false;                fakeValueRef.set(badValue);            }        }        value = cachedLong.next();        Assert.assertFalse(value.succeeded());    } finally {        client.close();    }}
96d4314f6dac42c3dc32caf9b8b9c228494de5deaa6af0d029fcdc3cdbeb0cfa
trySet
public AtomicValue<Long> trySet(Long newValue) throws Exception
{    return fakeValueRef.get();}
c14cb8ac9c9622d3b7d38eacf777225847afc6e324d8d4458c999d8902fce1a5
get
public AtomicValue<Long> get() throws Exception
{    return fakeValueRef.get();}
2c6e9af0b0ad4b2dcb000eb9943ccfe6c382576279dbdf9feceaff746836783d
increment
public AtomicValue<Long> increment() throws Exception
{    return fakeValueRef.get();}
753f2ac35c2cda68c14d24e99a41aca5af20ce34c7b662d4adbce65ff507aaac
decrement
public AtomicValue<Long> decrement() throws Exception
{    return fakeValueRef.get();}
a271b84d10429c3cd259184de50dc732cf0929c3b6497b05d9887e684053db67
add
public AtomicValue<Long> add(Long delta) throws Exception
{    return fakeValueRef.get();}
c0ad49256a08ded4ad1e2a14e6dd85ac42afc9dce79ad1efbce4ba6f4b943d8c
subtract
public AtomicValue<Long> subtract(Long delta) throws Exception
{    return fakeValueRef.get();}
1c15dc62e03d70e25bce7f0dea76ed8ed86d4053ddc9f902d6d4c862fa0ba65c
forceSet
public void forceSet(Long newValue) throws Exception
{}
7ae8ce55d04da2ba35e30d77a68ec3a6a93bcf3f08339e8cbb79c7b745e3dc1a
compareAndSet
public AtomicValue<Long> compareAndSet(Long expectedValue, Long newValue) throws Exception
{    return fakeValueRef.get();}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        DistributedAtomicLong dal = new DistributedAtomicLong(client, "/counter", new RetryOneTime(1));        CachedAtomicLong cachedLong = new CachedAtomicLong(dal, 100);        for (long i = 0; i < 200; ++i) {            AtomicValue<Long> value = cachedLong.next();            Assert.assertTrue(value.succeeded());            Assert.assertEquals(value.preValue().longValue(), i);            Assert.assertEquals(value.postValue().longValue(), i + 1);        }    } finally {        client.close();    }}
6b9fbe837382f9ac645a67c2c9a482d57efdf6f6af9145916d0ec24dec3a40f6
testCorruptedValue
public void testCorruptedValue() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/counter", "foo".getBytes());        DistributedAtomicLong dal = new DistributedAtomicLong(client, "/counter", new RetryOneTime(1));        try {            dal.get().postValue();        } catch (BufferUnderflowException e) {            Assert.fail("", e);        } catch (BufferOverflowException e) {            Assert.fail("", e);        } catch (RuntimeException e) {                }    } finally {        client.close();    }}
c4d69807db30100a123a79df419498cef264e0fa3ff09aef2adeeca2dab42739
testCompareAndSetWithFreshInstance
public void testCompareAndSetWithFreshInstance() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        DistributedAtomicLong dal = new DistributedAtomicLong(client, "/counter", new RetryOneTime(1));        AtomicValue<Long> result = dal.compareAndSet(0L, 1L);        Assert.assertFalse(result.succeeded());        Assert.assertTrue(dal.initialize(0L));        result = dal.compareAndSet(0L, 1L);        Assert.assertTrue(result.succeeded());        Assert.assertFalse(dal.initialize(0L));    } finally {        CloseableUtils.closeQuietly(client);    }}
ccb52a758aed83e67bd0586d43838ebc04927efc9beab37efbc5c26d9f873a97
testCompareAndSet
public void testCompareAndSet() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final AtomicBoolean doIncrement = new AtomicBoolean(false);        DistributedAtomicLong dal = new DistributedAtomicLong(client, "/counter", new RetryOneTime(1)) {            @Override            public byte[] valueToBytes(Long newValue) {                if (doIncrement.get()) {                    DistributedAtomicLong inc = new DistributedAtomicLong(client, "/counter", new RetryOneTime(1));                    try {                                                inc.increment();                    } catch (Exception e) {                        throw new Error(e);                    }                }                return super.valueToBytes(newValue);            }        };        dal.forceSet(1L);        Assert.assertTrue(dal.compareAndSet(1L, 5L).succeeded());        Assert.assertFalse(dal.compareAndSet(1L, 5L).succeeded());        doIncrement.set(true);        Assert.assertFalse(dal.compareAndSet(5L, 10L).succeeded());    } finally {        client.close();    }}
723ba4752ff2a2317c851aeb8b1a889a22083861d3dd85e9ace12b3df35a7ed5
valueToBytes
public byte[] valueToBytes(Long newValue)
{    if (doIncrement.get()) {        DistributedAtomicLong inc = new DistributedAtomicLong(client, "/counter", new RetryOneTime(1));        try {                        inc.increment();        } catch (Exception e) {            throw new Error(e);        }    }    return super.valueToBytes(newValue);}
ae939a9a543d7f9b3aa750765eae8b148a680bfacb7c44896fba02353826724d
testForceSet
public void testForceSet() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final DistributedAtomicLong dal = new DistributedAtomicLong(client, "/counter", new RetryOneTime(1));        ExecutorService executorService = Executors.newFixedThreadPool(2);        executorService.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                for (int i = 0; i < 1000; ++i) {                    dal.increment();                    Thread.sleep(10);                }                return null;            }        });        executorService.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                for (int i = 0; i < 1000; ++i) {                    dal.forceSet(0L);                    Thread.sleep(10);                }                return null;            }        });        Assert.assertTrue(dal.get().preValue() < 10);    } finally {        client.close();    }}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    for (int i = 0; i < 1000; ++i) {        dal.increment();        Thread.sleep(10);    }    return null;}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    for (int i = 0; i < 1000; ++i) {        dal.forceSet(0L);        Thread.sleep(10);    }    return null;}
ccb0dd3bf51602531293b9b3de65dd39b4a8ff9c002f36cdff68ae2f3275ca10
testSimulation
public void testSimulation() throws Exception
{    final int threadQty = 20;    final int executionQty = 50;    final AtomicInteger optimisticTries = new AtomicInteger();    final AtomicInteger promotedLockTries = new AtomicInteger();    final AtomicInteger failures = new AtomicInteger();    final AtomicInteger errors = new AtomicInteger();    final SummaryStatistics timingStats = new SynchronizedSummaryStatistics();    List<Future<Void>> procs = Lists.newArrayList();    ExecutorService executorService = Executors.newFixedThreadPool(threadQty);    for (int i = 0; i < threadQty; ++i) {        Callable<Void> proc = new Callable<Void>() {            @Override            public Void call() throws Exception {                doSimulation(executionQty, timingStats, optimisticTries, promotedLockTries, failures, errors);                return null;            }        };        procs.add(executorService.submit(proc));    }    for (Future<Void> f : procs) {        f.get();    }    System.out.println("OptimisticTries: " + optimisticTries.get());    System.out.println("PromotedLockTries: " + promotedLockTries.get());    System.out.println("Failures: " + failures.get());    System.out.println("Errors: " + errors.get());    System.out.println();    System.out.println("Avg time: " + timingStats.getMean());    System.out.println("Max time: " + timingStats.getMax());    System.out.println("Min time: " + timingStats.getMin());    System.out.println("Qty: " + timingStats.getN());    Assert.assertEquals(errors.get(), 0);    Assert.assertTrue(optimisticTries.get() > 0);    Assert.assertTrue(promotedLockTries.get() > 0);}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    doSimulation(executionQty, timingStats, optimisticTries, promotedLockTries, failures, errors);    return null;}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        DistributedAtomicLong dal = new DistributedAtomicLong(client, "/foo/bar/counter", new RetryOneTime(1));        AtomicValue<Long> value = dal.increment();        Assert.assertTrue(value.succeeded());        Assert.assertEquals(value.getStats().getOptimisticTries(), 1);        Assert.assertEquals(value.getStats().getPromotedLockTries(), 0);        Assert.assertEquals(value.preValue().longValue(), 0L);        Assert.assertEquals(value.postValue().longValue(), 1L);        value = dal.decrement();        Assert.assertTrue(value.succeeded());        Assert.assertEquals(value.getStats().getOptimisticTries(), 1);        Assert.assertEquals(value.getStats().getPromotedLockTries(), 0);        Assert.assertEquals(value.preValue().longValue(), 1L);        Assert.assertEquals(value.postValue().longValue(), 0L);        value = dal.add(10L);        Assert.assertTrue(value.succeeded());        Assert.assertEquals(value.getStats().getOptimisticTries(), 1);        Assert.assertEquals(value.getStats().getPromotedLockTries(), 0);        Assert.assertEquals(value.preValue().longValue(), 0L);        Assert.assertEquals(value.postValue().longValue(), 10L);        value = dal.subtract(5L);        Assert.assertTrue(value.succeeded());        Assert.assertEquals(value.getStats().getOptimisticTries(), 1);        Assert.assertEquals(value.getStats().getPromotedLockTries(), 0);        Assert.assertEquals(value.preValue().longValue(), 10L);        Assert.assertEquals(value.postValue().longValue(), 5L);    } finally {        client.close();    }}
4217f9f22a04687001a22818b552db03f01294f8b8bf61963430cbbc366001c1
doSimulation
private void doSimulation(int executionQty, SummaryStatistics timingStats, AtomicInteger optimisticTries, AtomicInteger promotedLockTries, AtomicInteger failures, AtomicInteger errors) throws Exception
{    Random random = new Random();    long previousValue = -1;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        RetryPolicy retryPolicy = new ExponentialBackoffRetry(3, 3);        PromotedToLock.Builder builder = PromotedToLock.builder().lockPath("/lock").retryPolicy(retryPolicy);        DistributedAtomicLong dal = new DistributedAtomicLong(client, "/counter", retryPolicy, builder.build());        for (int i = 0; i < executionQty; ++i) {            Thread.sleep(random.nextInt(10));            long start = System.currentTimeMillis();            AtomicValue<Long> value = dal.increment();            long elapsed = System.currentTimeMillis() - start;            timingStats.addValue(elapsed);            if (value.succeeded()) {                if (value.postValue() <= previousValue) {                    errors.incrementAndGet();                }                previousValue = value.postValue();            } else {                failures.incrementAndGet();            }            optimisticTries.addAndGet(value.getStats().getOptimisticTries());            promotedLockTries.addAndGet(value.getStats().getPromotedLockTries());        }    } finally {        client.close();    }}
1ced06219cbab521678bb70f909bd310615232a81816bc2ee06f163f62e8b320
testServerCrash
public void testServerCrash() throws Exception
{    final int TIMEOUT = 1000;    final CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).connectionTimeoutMs(TIMEOUT).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        final DistributedBarrier barrier = new DistributedBarrier(client, "/barrier");        barrier.setBarrier();        final ExecutorService service = Executors.newSingleThreadExecutor();        Future<Object> future = service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                Thread.sleep(TIMEOUT / 2);                server.stop();                return null;            }        });        barrier.waitOnBarrier(TIMEOUT * 2, TimeUnit.SECONDS);        future.get();        Assert.fail();    } catch (KeeperException.ConnectionLossException expected) {        } finally {        client.close();    }}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    Thread.sleep(TIMEOUT / 2);    server.stop();    return null;}
3f2c3634caf7eddab51c2ca0c2d46ce63540e463011743ebb877489ef76675ab
testMultiClient
public void testMultiClient() throws Exception
{    CuratorFramework client1 = null;    CuratorFramework client2 = null;    try {        {            CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            try {                client.start();                DistributedBarrier barrier = new DistributedBarrier(client, "/barrier");                barrier.setBarrier();            } finally {                CloseableUtils.closeQuietly(client);            }        }        client1 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client2 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        List<Future<Object>> futures = Lists.newArrayList();        ExecutorService service = Executors.newCachedThreadPool();        for (final CuratorFramework c : new CuratorFramework[] { client1, client2 }) {            Future<Object> future = service.submit(new Callable<Object>() {                @Override                public Object call() throws Exception {                    c.start();                    DistributedBarrier barrier = new DistributedBarrier(c, "/barrier");                    barrier.waitOnBarrier(10, TimeUnit.MILLISECONDS);                    return null;                }            });            futures.add(future);        }        Thread.sleep(1000);        {            CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            try {                client.start();                DistributedBarrier barrier = new DistributedBarrier(client, "/barrier");                barrier.removeBarrier();            } finally {                CloseableUtils.closeQuietly(client);            }        }        for (Future<Object> f : futures) {            f.get();        }    } finally {        CloseableUtils.closeQuietly(client1);        CloseableUtils.closeQuietly(client2);    }}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    c.start();    DistributedBarrier barrier = new DistributedBarrier(c, "/barrier");    barrier.waitOnBarrier(10, TimeUnit.MILLISECONDS);    return null;}
095102ad91ff9de9019e9bb7ff3326129c8d03b826eee2123931152cc75eb1a0
testNoBarrier
public void testNoBarrier() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final DistributedBarrier barrier = new DistributedBarrier(client, "/barrier");        Assert.assertTrue(barrier.waitOnBarrier(10, TimeUnit.SECONDS));                ExecutorService service = Executors.newSingleThreadExecutor();        Future<Object> future = service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                barrier.waitOnBarrier();                return "";            }        });        Assert.assertTrue(future.get(10, TimeUnit.SECONDS) != null);    } finally {        client.close();    }}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    barrier.waitOnBarrier();    return "";}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final DistributedBarrier barrier = new DistributedBarrier(client, "/barrier");        barrier.setBarrier();        ExecutorService service = Executors.newSingleThreadExecutor();        service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                Thread.sleep(1000);                barrier.removeBarrier();                return null;            }        });        Assert.assertTrue(barrier.waitOnBarrier(10, TimeUnit.SECONDS));    } finally {        client.close();    }}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    Thread.sleep(1000);    barrier.removeBarrier();    return null;}
3f2c3634caf7eddab51c2ca0c2d46ce63540e463011743ebb877489ef76675ab
testMultiClient
public void testMultiClient() throws Exception
{    final Timing timing = new Timing();    final CountDownLatch postEnterLatch = new CountDownLatch(QTY);    final CountDownLatch postLeaveLatch = new CountDownLatch(QTY);    final AtomicInteger count = new AtomicInteger(0);    final AtomicInteger max = new AtomicInteger(0);    List<Future<Void>> futures = Lists.newArrayList();    ExecutorService service = Executors.newCachedThreadPool();    for (int i = 0; i < QTY; ++i) {        Future<Void> future = service.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));                try {                    client.start();                    DistributedDoubleBarrier barrier = new DistributedDoubleBarrier(client, "/barrier", QTY);                    Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));                    synchronized (TestDistributedDoubleBarrier.this) {                        int thisCount = count.incrementAndGet();                        if (thisCount > max.get()) {                            max.set(thisCount);                        }                    }                    postEnterLatch.countDown();                    Assert.assertTrue(timing.awaitLatch(postEnterLatch));                    Assert.assertEquals(count.get(), QTY);                    Assert.assertTrue(barrier.leave(timing.seconds(), TimeUnit.SECONDS));                    count.decrementAndGet();                    postLeaveLatch.countDown();                    Assert.assertTrue(timing.awaitLatch(postEnterLatch));                } finally {                    CloseableUtils.closeQuietly(client);                }                return null;            }        });        futures.add(future);    }    for (Future<Void> f : futures) {        f.get();    }    Assert.assertEquals(count.get(), 0);    Assert.assertEquals(max.get(), QTY);}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        DistributedDoubleBarrier barrier = new DistributedDoubleBarrier(client, "/barrier", QTY);        Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));        synchronized (TestDistributedDoubleBarrier.this) {            int thisCount = count.incrementAndGet();            if (thisCount > max.get()) {                max.set(thisCount);            }        }        postEnterLatch.countDown();        Assert.assertTrue(timing.awaitLatch(postEnterLatch));        Assert.assertEquals(count.get(), QTY);        Assert.assertTrue(barrier.leave(timing.seconds(), TimeUnit.SECONDS));        count.decrementAndGet();        postLeaveLatch.countDown();        Assert.assertTrue(timing.awaitLatch(postEnterLatch));    } finally {        CloseableUtils.closeQuietly(client);    }    return null;}
93b07a54aa16779c60055acfbafd146e15ee88ab19193139e805160128a8663c
testOverSubscribed
public void testOverSubscribed() throws Exception
{    final Timing timing = new Timing();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    ExecutorService service = Executors.newCachedThreadPool();    ExecutorCompletionService<Void> completionService = new ExecutorCompletionService<Void>(service);    try {        client.start();        final Semaphore semaphore = new Semaphore(0);        final CountDownLatch latch = new CountDownLatch(1);        for (int i = 0; i < (QTY + 1); ++i) {            completionService.submit(new Callable<Void>() {                @Override                public Void call() throws Exception {                    DistributedDoubleBarrier barrier = new DistributedDoubleBarrier(client, "/barrier", QTY) {                        @Override                        protected List<String> getChildrenForEntering() throws Exception {                            semaphore.release();                            Assert.assertTrue(timing.awaitLatch(latch));                            return super.getChildrenForEntering();                        }                    };                    Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));                    Assert.assertTrue(barrier.leave(timing.seconds(), TimeUnit.SECONDS));                    return null;                }            });        }                Assert.assertTrue(semaphore.tryAcquire(QTY + 1, timing.seconds(), TimeUnit.SECONDS));        latch.countDown();        for (int i = 0; i < (QTY + 1); ++i) {                        completionService.take().get();        }    } finally {        service.shutdown();        CloseableUtils.closeQuietly(client);    }}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    DistributedDoubleBarrier barrier = new DistributedDoubleBarrier(client, "/barrier", QTY) {        @Override        protected List<String> getChildrenForEntering() throws Exception {            semaphore.release();            Assert.assertTrue(timing.awaitLatch(latch));            return super.getChildrenForEntering();        }    };    Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));    Assert.assertTrue(barrier.leave(timing.seconds(), TimeUnit.SECONDS));    return null;}
9b7b434cebb41a0d2451644b08927a9eb397e463a114fbeedd791d678936d50d
getChildrenForEntering
protected List<String> getChildrenForEntering() throws Exception
{    semaphore.release();    Assert.assertTrue(timing.awaitLatch(latch));    return super.getChildrenForEntering();}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    final Timing timing = new Timing();    final List<Closeable> closeables = Lists.newArrayList();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        closeables.add(client);        client.start();        final CountDownLatch postEnterLatch = new CountDownLatch(QTY);        final CountDownLatch postLeaveLatch = new CountDownLatch(QTY);        final AtomicInteger count = new AtomicInteger(0);        final AtomicInteger max = new AtomicInteger(0);        List<Future<Void>> futures = Lists.newArrayList();        ExecutorService service = Executors.newCachedThreadPool();        for (int i = 0; i < QTY; ++i) {            Future<Void> future = service.submit(new Callable<Void>() {                @Override                public Void call() throws Exception {                    DistributedDoubleBarrier barrier = new DistributedDoubleBarrier(client, "/barrier", QTY);                    Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));                    synchronized (TestDistributedDoubleBarrier.this) {                        int thisCount = count.incrementAndGet();                        if (thisCount > max.get()) {                            max.set(thisCount);                        }                    }                    postEnterLatch.countDown();                    Assert.assertTrue(timing.awaitLatch(postEnterLatch));                    Assert.assertEquals(count.get(), QTY);                    Assert.assertTrue(barrier.leave(10, TimeUnit.SECONDS));                    count.decrementAndGet();                    postLeaveLatch.countDown();                    Assert.assertTrue(timing.awaitLatch(postLeaveLatch));                    return null;                }            });            futures.add(future);        }        for (Future<Void> f : futures) {            f.get();        }        Assert.assertEquals(count.get(), 0);        Assert.assertEquals(max.get(), QTY);    } finally {        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    DistributedDoubleBarrier barrier = new DistributedDoubleBarrier(client, "/barrier", QTY);    Assert.assertTrue(barrier.enter(timing.seconds(), TimeUnit.SECONDS));    synchronized (TestDistributedDoubleBarrier.this) {        int thisCount = count.incrementAndGet();        if (thisCount > max.get()) {            max.set(thisCount);        }    }    postEnterLatch.countDown();    Assert.assertTrue(timing.awaitLatch(postEnterLatch));    Assert.assertEquals(count.get(), QTY);    Assert.assertTrue(barrier.leave(10, TimeUnit.SECONDS));    count.decrementAndGet();    postLeaveLatch.countDown();    Assert.assertTrue(timing.awaitLatch(postLeaveLatch));    return null;}
34e4997ab63acd7237bdfdebf2fc71e9d6d6126197060970008dd8f81cdd0288
childEvent
public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception
{        if (event.getData() != null && event.getData().getPath().startsWith("/zookeeper")) {        return;    }    events.add(event);}
221ba1c9d4a2fdcc828fc4f3549df182bc257ecbc2aca5ee2533f97d06bdf4d9
unhandledError
public void unhandledError(String message, Throwable e)
{    hadBackgroundException.set(true);    e.printStackTrace(System.err);}
0024f2dbbfe87950574db0c413183c5e7313f576d6972901cb0ab1397c076119
newTreeCacheWithListeners
protected TreeCache newTreeCacheWithListeners(CuratorFramework client, String path)
{    TreeCache result = new TreeCache(client, path);    result.getListenable().addListener(eventListener);    result.getUnhandledErrorListenable().addListener(errorListener);    return result;}
8cbc63c2a15119abdfd8ce47fa21964517966a1e6df79695bd99f1a6870b472f
buildWithListeners
protected TreeCache buildWithListeners(TreeCache.Builder builder)
{    TreeCache result = builder.build();    result.getListenable().addListener(eventListener);    result.getUnhandledErrorListenable().addListener(errorListener);    return result;}
27681e68ec2a1eb903f955680ebe003ceb3707295c8aad884b692d378c6e37cf
setup
public void setup() throws Exception
{    super.setup();    initCuratorFramework();}
a2b5a198fe55b73950955111a5b768d8523c4d61b7daa7488f0505a93e2e184b
initCuratorFramework
 void initCuratorFramework()
{    client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    client.getUnhandledErrorListenable().addListener(errorListener);}
7c529460b940c419ef707bd1846a5575ea1bfc48c129127836c31f0184c1d8fb
teardown
public void teardown() throws Exception
{    try {        try {            Assert.assertFalse(hadBackgroundException.get(), "Background exceptions were thrown, see stderr for details");            assertNoMoreEvents();        } finally {            CloseableUtils.closeQuietly(cache);            TestCleanState.closeAndTestClean(client);        }    } finally {        super.teardown();    }}
b5d0a96226d10cc7e03ba51a68ef943aa581ef259d83525e601e4f5bda1fc863
assertNoMoreEvents
 void assertNoMoreEvents() throws InterruptedException
{    timing.sleepABit();    Assert.assertTrue(events.isEmpty(), String.format("Expected no events, found %d; first event: %s", events.size(), events.peek()));}
0488e5d90313682e010f0a21cf817f1a34d0a9ef8a156cec06e05eabfb75dd89
assertEvent
 TreeCacheEvent assertEvent(TreeCacheEvent.Type expectedType) throws InterruptedException
{    return assertEvent(expectedType, null);}
a6cca20e2f50c51d2b4bbc6b463602ea2bb04a8e83e88f649ae4cb5bb498c0b6
assertEvent
 TreeCacheEvent assertEvent(TreeCacheEvent.Type expectedType, String expectedPath) throws InterruptedException
{    return assertEvent(expectedType, expectedPath, null);}
6da7cdbc2454df3711bad057c6cb1541e8e8847b6ad137a64be666bb8310522b
assertEvent
 TreeCacheEvent assertEvent(TreeCacheEvent.Type expectedType, String expectedPath, byte[] expectedData) throws InterruptedException
{    return assertEvent(expectedType, expectedPath, expectedData, false);}
86dd0571cdaa64c4c6691ab9192e03ce4eee8c4b253eb5761e08501d981aded3
assertEvent
 TreeCacheEvent assertEvent(TreeCacheEvent.Type expectedType, String expectedPath, byte[] expectedData, boolean ignoreConnectionEvents) throws InterruptedException
{    TreeCacheEvent event = events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS);    Assert.assertNotNull(event, String.format("Expected type: %s, path: %s", expectedType, expectedPath));    if (ignoreConnectionEvents) {        if ((event.getType() == TreeCacheEvent.Type.CONNECTION_SUSPENDED) || (event.getType() == TreeCacheEvent.Type.CONNECTION_LOST) || (event.getType() == TreeCacheEvent.Type.CONNECTION_RECONNECTED)) {            return assertEvent(expectedType, expectedPath, expectedData, ignoreConnectionEvents);        }    }    String message = event.toString();    Assert.assertEquals(event.getType(), expectedType, message);    if (expectedPath == null) {        Assert.assertNull(event.getData(), message);    } else {        Assert.assertNotNull(event.getData(), message);        Assert.assertEquals(event.getData().getPath(), expectedPath, message);    }    if (expectedData != null) {        Assert.assertEquals(event.getData().getData(), expectedData, message);    }    return event;}
cfaeccd8740b5066395fbb989c93a7f9becf328ed6b884d5be45d8d35e0b4e9c
testEventOrdering
public void testEventOrdering() throws Exception
{    ExecutorService executorService = Executors.newFixedThreadPool(THREAD_QTY);    BlockingQueue<Event> events = Queues.newLinkedBlockingQueue();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    T cache = null;    try {        client.start();        client.create().forPath("/root");        cache = newCache(client, "/root", events);        final Random random = new Random();        final Callable<Void> task = new Callable<Void>() {            @Override            public Void call() throws Exception {                for (int i = 0; i < ITERATIONS; ++i) {                    String node = "/root/" + random.nextInt(NODE_QTY);                    try {                        switch(random.nextInt(3)) {                            default:                            case 0:                                client.create().forPath(node);                                break;                            case 1:                                client.setData().forPath(node, "new".getBytes());                                break;                            case 2:                                client.delete().forPath(node);                                break;                        }                    } catch (KeeperException ignore) {                                        }                }                return null;            }        };        final CountDownLatch latch = new CountDownLatch(THREAD_QTY);        for (int i = 0; i < THREAD_QTY; ++i) {            Callable<Void> wrapped = new Callable<Void>() {                @Override                public Void call() throws Exception {                    try {                        return task.call();                    } finally {                        latch.countDown();                    }                }            };            executorService.submit(wrapped);        }        Assert.assertTrue(timing.awaitLatch(latch));        timing.sleepABit();        List<Event> localEvents = Lists.newArrayList();        int eventSuggestedQty = 0;        while (events.size() > 0) {            Event event = timing.takeFromQueue(events);            localEvents.add(event);            eventSuggestedQty += (event.eventType == EventType.ADDED) ? 1 : -1;        }        int actualQty = getActualQty(cache);        Assert.assertEquals(actualQty, eventSuggestedQty, String.format("actual %s expected %s:\n %s", actualQty, eventSuggestedQty, asString(localEvents)));    } finally {        executorService.shutdownNow();                executorService.awaitTermination(timing.milliseconds(), TimeUnit.MILLISECONDS);        CloseableUtils.closeQuietly(cache);        CloseableUtils.closeQuietly(client);    }}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    for (int i = 0; i < ITERATIONS; ++i) {        String node = "/root/" + random.nextInt(NODE_QTY);        try {            switch(random.nextInt(3)) {                default:                case 0:                    client.create().forPath(node);                    break;                case 1:                    client.setData().forPath(node, "new".getBytes());                    break;                case 2:                    client.delete().forPath(node);                    break;            }        } catch (KeeperException ignore) {                }    }    return null;}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    try {        return task.call();    } finally {        latch.countDown();    }}
767b5fecec6e41395fb0b5b53d6ad2b5d957fc41cf6a06f4d01745342794adc3
asString
private String asString(List<Event> events)
{    int qty = 0;    StringBuilder str = new StringBuilder();    for (Event event : events) {        qty += (event.eventType == EventType.ADDED) ? 1 : -1;        str.append(event.eventType).append(" ").append(event.path).append(" @ ").append(event.time - start).append(' ').append(qty);        str.append("\n");    }    return str.toString();}
1c993f97815108a4b0b777614fe8e13a9e373f555db217b8dd1d9e6987112a08
testDeleteThenCreate
public void testDeleteThenCreate() throws Exception
{    NodeCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().creatingParentsIfNeeded().forPath("/test/foo", "one".getBytes());        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();        client.getUnhandledErrorListenable().addListener(new UnhandledErrorListener() {            @Override            public void unhandledError(String message, Throwable e) {                error.set(e);            }        });        final Semaphore semaphore = new Semaphore(0);        cache = new NodeCache(client, "/test/foo");        cache.getListenable().addListener(new NodeCacheListener() {            @Override            public void nodeChanged() throws Exception {                semaphore.release();            }        });        cache.start(true);        Assert.assertEquals(cache.getCurrentData().getData(), "one".getBytes());        client.delete().forPath("/test/foo");        Assert.assertTrue(semaphore.tryAcquire(1, 10, TimeUnit.SECONDS));        client.create().forPath("/test/foo", "two".getBytes());        Assert.assertTrue(semaphore.tryAcquire(1, 10, TimeUnit.SECONDS));        Throwable t = error.get();        if (t != null) {            Assert.fail("Assert", t);        }        Assert.assertEquals(cache.getCurrentData().getData(), "two".getBytes());        cache.close();    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
221ba1c9d4a2fdcc828fc4f3549df182bc257ecbc2aca5ee2533f97d06bdf4d9
unhandledError
public void unhandledError(String message, Throwable e)
{    error.set(e);}
95a1d12a17566499008636423784493306962712fbc4daf5f8810e4e38689b3c
nodeChanged
public void nodeChanged() throws Exception
{    semaphore.release();}
2ac1ff5a339f7c8eac33c076bf00b3388a14e33690edbecdcbb73237a1fa194d
testRebuildAgainstOtherProcesses
public void testRebuildAgainstOtherProcesses() throws Exception
{    Timing2 timing2 = new Timing2();    NodeCache cache = null;    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");        client.create().forPath("/test/snafu", "original".getBytes());        final CountDownLatch latch = new CountDownLatch(1);        cache = new NodeCache(client, "/test/snafu");        cache.getListenable().addListener(new NodeCacheListener() {            @Override            public void nodeChanged() throws Exception {                latch.countDown();            }        });        cache.rebuildTestExchanger = new Exchanger<Object>();        ExecutorService service = Executors.newSingleThreadExecutor();        final NodeCache finalCache = cache;        Future<Object> future = service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                finalCache.rebuildTestExchanger.exchange(new Object(), timing2.forWaiting().seconds(), TimeUnit.SECONDS);                                client.setData().forPath("/test/snafu", "other".getBytes());                ChildData currentData = finalCache.getCurrentData();                Assert.assertNotNull(currentData);                finalCache.rebuildTestExchanger.exchange(new Object(), timing2.forWaiting().seconds(), TimeUnit.SECONDS);                return null;            }        });        cache.start(false);        future.get();        Assert.assertTrue(timing2.awaitLatch(latch));        Assert.assertNotNull(cache.getCurrentData());        Assert.assertEquals(cache.getCurrentData().getData(), "other".getBytes());    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
95a1d12a17566499008636423784493306962712fbc4daf5f8810e4e38689b3c
nodeChanged
public void nodeChanged() throws Exception
{    latch.countDown();}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    finalCache.rebuildTestExchanger.exchange(new Object(), timing2.forWaiting().seconds(), TimeUnit.SECONDS);        client.setData().forPath("/test/snafu", "other".getBytes());    ChildData currentData = finalCache.getCurrentData();    Assert.assertNotNull(currentData);    finalCache.rebuildTestExchanger.exchange(new Object(), timing2.forWaiting().seconds(), TimeUnit.SECONDS);    return null;}
936fa9edcb8fd2ba6b5b9ef1ce09b39676da41bf85aa3cbdd99e3a1d444edcde
testKilledSession
public void testKilledSession() throws Exception
{    NodeCache cache = null;    Timing timing = new Timing();    CuratorFramework client = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        client.create().creatingParentsIfNeeded().forPath("/test/node", "start".getBytes());        cache = new NodeCache(client, "/test/node");        cache.start(true);        final CountDownLatch latch = new CountDownLatch(1);        cache.getListenable().addListener(new NodeCacheListener() {            @Override            public void nodeChanged() throws Exception {                latch.countDown();            }        });        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        Thread.sleep(timing.multiple(1.5).session());        Assert.assertEquals(cache.getCurrentData().getData(), "start".getBytes());        client.setData().forPath("/test/node", "new data".getBytes());        Assert.assertTrue(timing.awaitLatch(latch));    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
95a1d12a17566499008636423784493306962712fbc4daf5f8810e4e38689b3c
nodeChanged
public void nodeChanged() throws Exception
{    latch.countDown();}
c7a00a749ec37d419bb105a770af2763d5fcf8d56782795615b23e4402333b9b
testBasics
public void testBasics() throws Exception
{    NodeCache cache = null;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");        cache = new NodeCache(client, "/test/node");        cache.start(true);        final Semaphore semaphore = new Semaphore(0);        cache.getListenable().addListener(new NodeCacheListener() {            @Override            public void nodeChanged() throws Exception {                semaphore.release();            }        });        Assert.assertNull(cache.getCurrentData());        client.create().forPath("/test/node", "a".getBytes());        Assert.assertTrue(timing.acquireSemaphore(semaphore));        Assert.assertEquals(cache.getCurrentData().getData(), "a".getBytes());        client.setData().forPath("/test/node", "b".getBytes());        Assert.assertTrue(timing.acquireSemaphore(semaphore));        Assert.assertEquals(cache.getCurrentData().getData(), "b".getBytes());        client.delete().forPath("/test/node");        Assert.assertTrue(timing.acquireSemaphore(semaphore));        Assert.assertNull(cache.getCurrentData());    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
95a1d12a17566499008636423784493306962712fbc4daf5f8810e4e38689b3c
nodeChanged
public void nodeChanged() throws Exception
{    semaphore.release();}
5fc9c19966cc19322815e2112ef32074460c03a2b08a4db446e9050af9ffadd1
testParentContainerMissing
public void testParentContainerMissing() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    PathChildrenCache cache = new PathChildrenCache(client, "/a/b/test", true);    try {        client.start();                client.blockUntilConnected();        final BlockingQueue<PathChildrenCacheEvent.Type> events = Queues.newLinkedBlockingQueue();        PathChildrenCacheListener listener = new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                events.add(event.getType());            }        };        cache.getListenable().addListener(listener);        cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);        Assert.assertEquals(events.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.INITIALIZED);        client.create().forPath("/a/b/test/one");        client.create().forPath("/a/b/test/two");        Assert.assertEquals(events.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CHILD_ADDED);        Assert.assertEquals(events.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CHILD_ADDED);        client.delete().forPath("/a/b/test/one");        client.delete().forPath("/a/b/test/two");        client.delete().forPath("/a/b/test");        Assert.assertEquals(events.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CHILD_REMOVED);        Assert.assertEquals(events.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CHILD_REMOVED);        timing.sleepABit();        client.create().creatingParentContainersIfNeeded().forPath("/a/b/test/new");        Assert.assertEquals(events.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CHILD_ADDED);    } finally {        CloseableUtils.closeQuietly(cache);        CloseableUtils.closeQuietly(client);    }}
d6477cd5e4da923bd9799bbf8d4db46d7d153fc78458c819b2b186c1ddff908e
childEvent
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    events.add(event.getType());}
575432eec4dcfdb2d217a615e8e067122e011d1e7d80ecb9ef6943c2e9c82e7b
testInitializedEvenIfChildDeleted
public void testInitializedEvenIfChildDeleted() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    PathChildrenCache cache = new PathChildrenCache(client, "/a/b/test", true) {        @Override        void getDataAndStat(final String fullPath) throws Exception {                        client.delete().forPath("/a/b/test/one");            super.getDataAndStat(fullPath);        }    };    Timing timing = new Timing();    try {        client.start();        final CountDownLatch cacheInitialized = new CountDownLatch(1);        PathChildrenCacheListener listener = new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                if (event.getType() == PathChildrenCacheEvent.Type.INITIALIZED) {                    cacheInitialized.countDown();                }            }        };        cache.getListenable().addListener(listener);        client.create().creatingParentsIfNeeded().forPath("/a/b/test/one");        cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);        Assert.assertTrue(timing.awaitLatch(cacheInitialized));        Assert.assertEquals(cache.getCurrentData().size(), 0);    } finally {        CloseableUtils.closeQuietly(cache);        CloseableUtils.closeQuietly(client);    }}
df46a1929c17fc7189ad398b0e51789ea57fd3839a296b2732efd4d3e08ca127
getDataAndStat
 void getDataAndStat(final String fullPath) throws Exception
{        client.delete().forPath("/a/b/test/one");    super.getDataAndStat(fullPath);}
d6477cd5e4da923bd9799bbf8d4db46d7d153fc78458c819b2b186c1ddff908e
childEvent
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.INITIALIZED) {        cacheInitialized.countDown();    }}
280f917e77e906589d22057b8dbaf98f143a9f4b2213f6a8578b44b765e68c35
testWithBadConnect
public void testWithBadConnect() throws Exception
{    final int serverPort = server.getPort();    server.close();    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), 1000, 1000, new RetryOneTime(1));    try {        client.start();        final CountDownLatch ensurePathLatch = new CountDownLatch(1);        PathChildrenCache cache = new PathChildrenCache(client, "/", true) {            @Override            protected void ensurePath() throws Exception {                try {                    super.ensurePath();                } catch (Exception e) {                    ensurePathLatch.countDown();                    throw e;                }            }        };        final CountDownLatch addedLatch = new CountDownLatch(1);        PathChildrenCacheListener listener = new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED && event.getData().getPath().equals("/baz")) {                    addedLatch.countDown();                }            }        };        cache.getListenable().addListener(listener);        cache.start();        Assert.assertTrue(timing.awaitLatch(ensurePathLatch));        final CountDownLatch connectedLatch = new CountDownLatch(1);        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.CONNECTED) {                    connectedLatch.countDown();                }            }        });        server = new TestingServer(serverPort, true);        Assert.assertTrue(timing.awaitLatch(connectedLatch));        client.create().creatingParentContainersIfNeeded().forPath("/baz", new byte[] { 1, 2, 3 });        assertNotNull("/baz does not exist", client.checkExists().forPath("/baz"));        Assert.assertTrue(timing.awaitLatch(addedLatch));        assertNotNull("cache doesn't see /baz", cache.getCurrentData("/baz"));    } finally {        CloseableUtils.closeQuietly(client);    }}
b4def6d6853ff3668c34d38ddfa38cc1024cbf7430c55e8f67e5fa0f3dc074dd
ensurePath
protected void ensurePath() throws Exception
{    try {        super.ensurePath();    } catch (Exception e) {        ensurePathLatch.countDown();        throw e;    }}
d6477cd5e4da923bd9799bbf8d4db46d7d153fc78458c819b2b186c1ddff908e
childEvent
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED && event.getData().getPath().equals("/baz")) {        addedLatch.countDown();    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    }}
d06c8e4f075ab8d639146f500fb5536f9220586e7ab4a8c7db044c46a62e937f
testPostInitializedForEmpty
public void testPostInitializedForEmpty() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        cache = new PathChildrenCache(client, "/test", true);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                if (event.getType() == PathChildrenCacheEvent.Type.INITIALIZED) {                    latch.countDown();                }            }        });        cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);        Assert.assertTrue(timing.awaitLatch(latch));    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
d6477cd5e4da923bd9799bbf8d4db46d7d153fc78458c819b2b186c1ddff908e
childEvent
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.INITIALIZED) {        latch.countDown();    }}
92342813cce1e277dba674ae90f7b54424620b0fcfd77eaf53d884023a18551a
testAsyncInitialPopulation
public void testAsyncInitialPopulation() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/test");        client.create().forPath("/test/one", "hey there".getBytes());        final BlockingQueue<PathChildrenCacheEvent> events = new LinkedBlockingQueue<PathChildrenCacheEvent>();        cache = new PathChildrenCache(client, "/test", true);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                events.offer(event);            }        });        cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);        PathChildrenCacheEvent event = events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertEquals(event.getType(), PathChildrenCacheEvent.Type.CHILD_ADDED);        event = events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertEquals(event.getType(), PathChildrenCacheEvent.Type.INITIALIZED);        Assert.assertEquals(event.getInitialData().size(), 1);    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
d6477cd5e4da923bd9799bbf8d4db46d7d153fc78458c819b2b186c1ddff908e
childEvent
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    events.offer(event);}
0c35fe000d285ae052344b21b246096e8ebf53281cfa00b93c4684b1e6bd477b
testChildrenInitialized
public void testChildrenInitialized() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/test");        cache = new PathChildrenCache(client, "/test", true);        final CountDownLatch addedLatch = new CountDownLatch(3);        final CountDownLatch initLatch = new CountDownLatch(1);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {                    addedLatch.countDown();                } else if (event.getType() == PathChildrenCacheEvent.Type.INITIALIZED) {                    initLatch.countDown();                }            }        });        client.create().forPath("/test/1", "1".getBytes());        client.create().forPath("/test/2", "2".getBytes());        client.create().forPath("/test/3", "3".getBytes());        cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);        Assert.assertTrue(timing.awaitLatch(addedLatch));        Assert.assertTrue(timing.awaitLatch(initLatch));        Assert.assertEquals(cache.getCurrentData().size(), 3);        Assert.assertEquals(cache.getCurrentData().get(0).getData(), "1".getBytes());        Assert.assertEquals(cache.getCurrentData().get(1).getData(), "2".getBytes());        Assert.assertEquals(cache.getCurrentData().get(2).getData(), "3".getBytes());    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
d6477cd5e4da923bd9799bbf8d4db46d7d153fc78458c819b2b186c1ddff908e
childEvent
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {        addedLatch.countDown();    } else if (event.getType() == PathChildrenCacheEvent.Type.INITIALIZED) {        initLatch.countDown();    }}
7f4a3cb885d3533230feabe38c52c064c5387461a6cfd4120c324ec380ff6c4d
testChildrenInitializedNormal
public void testChildrenInitializedNormal() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().forPath("/test");        cache = new PathChildrenCache(client, "/test", true);        final CountDownLatch addedLatch = new CountDownLatch(3);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                Assert.assertNotEquals(event.getType(), PathChildrenCacheEvent.Type.INITIALIZED);                if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {                    addedLatch.countDown();                }            }        });        client.create().forPath("/test/1", "1".getBytes());        client.create().forPath("/test/2", "2".getBytes());        client.create().forPath("/test/3", "3".getBytes());        cache.start(PathChildrenCache.StartMode.NORMAL);        Assert.assertTrue(timing.awaitLatch(addedLatch));        Assert.assertEquals(cache.getCurrentData().size(), 3);        Assert.assertEquals(cache.getCurrentData().get(0).getData(), "1".getBytes());        Assert.assertEquals(cache.getCurrentData().get(1).getData(), "2".getBytes());        Assert.assertEquals(cache.getCurrentData().get(2).getData(), "3".getBytes());    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
d6477cd5e4da923bd9799bbf8d4db46d7d153fc78458c819b2b186c1ddff908e
childEvent
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    Assert.assertNotEquals(event.getType(), PathChildrenCacheEvent.Type.INITIALIZED);    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {        addedLatch.countDown();    }}
aeac80bebe2c0224580b6bfb841576632a40dc7f0243822008bd65208277a26f
testUpdateWhenNotCachingData
public void testUpdateWhenNotCachingData() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch updatedLatch = new CountDownLatch(1);        final CountDownLatch addedLatch = new CountDownLatch(1);        client.create().creatingParentsIfNeeded().forPath("/test");        cache = new PathChildrenCache(client, "/test", false);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                if (event.getType() == PathChildrenCacheEvent.Type.CHILD_UPDATED) {                    updatedLatch.countDown();                } else if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {                    addedLatch.countDown();                }            }        });        cache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);        client.create().forPath("/test/foo", "first".getBytes());        Assert.assertTrue(timing.awaitLatch(addedLatch));        client.setData().forPath("/test/foo", "something new".getBytes());        Assert.assertTrue(timing.awaitLatch(updatedLatch));    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
d6477cd5e4da923bd9799bbf8d4db46d7d153fc78458c819b2b186c1ddff908e
childEvent
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_UPDATED) {        updatedLatch.countDown();    } else if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {        addedLatch.countDown();    }}
5d39235dd3b964b92ffc0cbfe805450e3331ea10b486c8f59ee6326c1630a153
testEnsurePath
public void testEnsurePath() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        try (PathChildrenCache cache = new PathChildrenCache(client, "/one/two/three", false)) {            cache.start();            timing.sleepABit();            try {                client.create().forPath("/one/two/three/four");            } catch (KeeperException.NoNodeException e) {                Assert.fail("Path should exist", e);            }        }        timing.sleepABit();    } finally {        TestCleanState.closeAndTestClean(client);    }}
1c993f97815108a4b0b777614fe8e13a9e373f555db217b8dd1d9e6987112a08
testDeleteThenCreate
public void testDeleteThenCreate() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");        client.create().forPath("/test/foo", "one".getBytes());        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();        client.getUnhandledErrorListenable().addListener(new UnhandledErrorListener() {            @Override            public void unhandledError(String message, Throwable e) {                error.set(e);            }        });        final CountDownLatch removedLatch = new CountDownLatch(1);        final CountDownLatch postRemovedLatch = new CountDownLatch(1);        final CountDownLatch dataLatch = new CountDownLatch(1);        try (PathChildrenCache cache = new PathChildrenCache(client, "/test", true)) {            cache.getListenable().addListener(new PathChildrenCacheListener() {                @Override                public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_REMOVED) {                        removedLatch.countDown();                        Assert.assertTrue(postRemovedLatch.await(10, TimeUnit.SECONDS));                    } else {                        try {                            Assert.assertEquals(event.getData().getData(), "two".getBytes());                        } finally {                            dataLatch.countDown();                        }                    }                }            });            cache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);            client.delete().forPath("/test/foo");            Assert.assertTrue(timing.awaitLatch(removedLatch));            client.create().forPath("/test/foo", "two".getBytes());            postRemovedLatch.countDown();            Assert.assertTrue(timing.awaitLatch(dataLatch));            Throwable t = error.get();            if (t != null) {                Assert.fail("Assert", t);            }        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
221ba1c9d4a2fdcc828fc4f3549df182bc257ecbc2aca5ee2533f97d06bdf4d9
unhandledError
public void unhandledError(String message, Throwable e)
{    error.set(e);}
d6477cd5e4da923bd9799bbf8d4db46d7d153fc78458c819b2b186c1ddff908e
childEvent
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_REMOVED) {        removedLatch.countDown();        Assert.assertTrue(postRemovedLatch.await(10, TimeUnit.SECONDS));    } else {        try {            Assert.assertEquals(event.getData().getData(), "two".getBytes());        } finally {            dataLatch.countDown();        }    }}
2ac1ff5a339f7c8eac33c076bf00b3388a14e33690edbecdcbb73237a1fa194d
testRebuildAgainstOtherProcesses
public void testRebuildAgainstOtherProcesses() throws Exception
{    Timing timing = new Timing();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");        client.create().forPath("/test/foo");        client.create().forPath("/test/bar");        client.create().forPath("/test/snafu", "original".getBytes());        final CountDownLatch addedLatch = new CountDownLatch(2);        try (final PathChildrenCache cache = new PathChildrenCache(client, "/test", true)) {            cache.getListenable().addListener(new PathChildrenCacheListener() {                @Override                public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {                        if (event.getData().getPath().equals("/test/test")) {                            addedLatch.countDown();                        }                    } else if (event.getType() == PathChildrenCacheEvent.Type.CHILD_UPDATED) {                        if (event.getData().getPath().equals("/test/snafu")) {                            addedLatch.countDown();                        }                    }                }            });            cache.rebuildTestExchanger = new Exchanger<Object>();            ExecutorService service = Executors.newSingleThreadExecutor();            final AtomicReference<String> deletedPath = new AtomicReference<String>();            Future<Object> future = service.submit(new Callable<Object>() {                @Override                public Object call() throws Exception {                    cache.rebuildTestExchanger.exchange(new Object());                                        client.create().forPath("/test/test");                    List<ChildData> currentData = cache.getCurrentData();                    Assert.assertTrue(currentData.size() > 0);                                        client.delete().forPath(currentData.get(0).getPath());                    deletedPath.set(currentData.get(0).getPath());                    cache.rebuildTestExchanger.exchange(new Object());                    ChildData childData = null;                    while (childData == null) {                        childData = cache.getCurrentData("/test/snafu");                        Thread.sleep(1000);                    }                    Assert.assertEquals(childData.getData(), "original".getBytes());                    client.setData().forPath("/test/snafu", "grilled".getBytes());                    cache.rebuildTestExchanger.exchange(new Object());                    return null;                }            });            cache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);            future.get();            Assert.assertTrue(timing.awaitLatch(addedLatch));            Assert.assertNotNull(cache.getCurrentData("/test/test"));            Assert.assertNull(cache.getCurrentData(deletedPath.get()));            Assert.assertEquals(cache.getCurrentData("/test/snafu").getData(), "grilled".getBytes());        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
d6477cd5e4da923bd9799bbf8d4db46d7d153fc78458c819b2b186c1ddff908e
childEvent
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {        if (event.getData().getPath().equals("/test/test")) {            addedLatch.countDown();        }    } else if (event.getType() == PathChildrenCacheEvent.Type.CHILD_UPDATED) {        if (event.getData().getPath().equals("/test/snafu")) {            addedLatch.countDown();        }    }}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    cache.rebuildTestExchanger.exchange(new Object());        client.create().forPath("/test/test");    List<ChildData> currentData = cache.getCurrentData();    Assert.assertTrue(currentData.size() > 0);        client.delete().forPath(currentData.get(0).getPath());    deletedPath.set(currentData.get(0).getPath());    cache.rebuildTestExchanger.exchange(new Object());    ChildData childData = null;    while (childData == null) {        childData = cache.getCurrentData("/test/snafu");        Thread.sleep(1000);    }    Assert.assertEquals(childData.getData(), "original".getBytes());    client.setData().forPath("/test/snafu", "grilled".getBytes());    cache.rebuildTestExchanger.exchange(new Object());    return null;}
4c0253f352afa97bd1782f3bc8e7b25e9d836177f522b9d4a0c00cf1015837c7
testIssue27
public void testIssue27() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/base");        client.create().forPath("/base/a");        client.create().forPath("/base/b");        client.create().forPath("/base/c");        client.getChildren().forPath("/base");        final List<PathChildrenCacheEvent.Type> events = Lists.newArrayList();        final Semaphore semaphore = new Semaphore(0);        cache = new PathChildrenCache(client, "/base", true);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                events.add(event.getType());                semaphore.release();            }        });        cache.start();        Assert.assertTrue(timing.acquireSemaphore(semaphore, 3));        client.delete().forPath("/base/a");        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        client.create().forPath("/base/a");        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        List<PathChildrenCacheEvent.Type> expected = Lists.newArrayList(PathChildrenCacheEvent.Type.CHILD_ADDED, PathChildrenCacheEvent.Type.CHILD_ADDED, PathChildrenCacheEvent.Type.CHILD_ADDED, PathChildrenCacheEvent.Type.CHILD_REMOVED, PathChildrenCacheEvent.Type.CHILD_ADDED);        Assert.assertEquals(expected, events);    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
d6477cd5e4da923bd9799bbf8d4db46d7d153fc78458c819b2b186c1ddff908e
childEvent
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    events.add(event.getType());    semaphore.release();}
73519d999955903c67903622b15773098ee5e4b97763340f3726c18fac4b00e1
testIssue27Alt
public void testIssue27Alt() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/base");        client.create().forPath("/base/a");        client.create().forPath("/base/b");        client.create().forPath("/base/c");        client.getChildren().forPath("/base");        final List<PathChildrenCacheEvent.Type> events = Lists.newArrayList();        final Semaphore semaphore = new Semaphore(0);        cache = new PathChildrenCache(client, "/base", true);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                events.add(event.getType());                semaphore.release();            }        });        cache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);        client.delete().forPath("/base/a");        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        client.create().forPath("/base/a");        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        List<PathChildrenCacheEvent.Type> expected = Lists.newArrayList(PathChildrenCacheEvent.Type.CHILD_REMOVED, PathChildrenCacheEvent.Type.CHILD_ADDED);        Assert.assertEquals(expected, events);    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
d6477cd5e4da923bd9799bbf8d4db46d7d153fc78458c819b2b186c1ddff908e
childEvent
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    events.add(event.getType());    semaphore.release();}
936fa9edcb8fd2ba6b5b9ef1ce09b39676da41bf85aa3cbdd99e3a1d444edcde
testKilledSession
public void testKilledSession() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        client.create().forPath("/test");        cache = new PathChildrenCache(client, "/test", true);        cache.start();        final CountDownLatch childAddedLatch = new CountDownLatch(1);        final CountDownLatch lostLatch = new CountDownLatch(1);        final CountDownLatch reconnectedLatch = new CountDownLatch(1);        final CountDownLatch removedLatch = new CountDownLatch(1);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {                    childAddedLatch.countDown();                } else if (event.getType() == PathChildrenCacheEvent.Type.CONNECTION_LOST) {                    lostLatch.countDown();                } else if (event.getType() == PathChildrenCacheEvent.Type.CONNECTION_RECONNECTED) {                    reconnectedLatch.countDown();                } else if (event.getType() == PathChildrenCacheEvent.Type.CHILD_REMOVED) {                    removedLatch.countDown();                }            }        });        client.create().withMode(CreateMode.EPHEMERAL).forPath("/test/me", "data".getBytes());        Assert.assertTrue(timing.awaitLatch(childAddedLatch));        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        Assert.assertTrue(timing.awaitLatch(lostLatch));        Assert.assertTrue(timing.awaitLatch(reconnectedLatch));        Assert.assertTrue(timing.awaitLatch(removedLatch));    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
d6477cd5e4da923bd9799bbf8d4db46d7d153fc78458c819b2b186c1ddff908e
childEvent
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {        childAddedLatch.countDown();    } else if (event.getType() == PathChildrenCacheEvent.Type.CONNECTION_LOST) {        lostLatch.countDown();    } else if (event.getType() == PathChildrenCacheEvent.Type.CONNECTION_RECONNECTED) {        reconnectedLatch.countDown();    } else if (event.getType() == PathChildrenCacheEvent.Type.CHILD_REMOVED) {        removedLatch.countDown();    }}
a0a0e5381d2c1dce3a434e7b00fe169f7825330582b8588758294ce580d63866
testModes
public void testModes() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");        for (boolean cacheData : new boolean[] { false, true }) {            internalTestMode(client, cacheData);            client.delete().forPath("/test/one");            client.delete().forPath("/test/two");        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
ef81ffbcd2129dc554b4665bf4db065f38b673e745b9afbf1ba1b29ba5c214e0
testRebuildNode
public void testRebuildNode() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/test/one", "one".getBytes());        final CountDownLatch latch = new CountDownLatch(1);        final AtomicInteger counter = new AtomicInteger();        final Semaphore semaphore = new Semaphore(1);        cache = new PathChildrenCache(client, "/test", true) {            @Override            void getDataAndStat(String fullPath) throws Exception {                semaphore.acquire();                counter.incrementAndGet();                super.getDataAndStat(fullPath);                latch.countDown();            }        };        cache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);        Assert.assertTrue(timing.awaitLatch(latch));        int saveCounter = counter.get();        client.setData().forPath("/test/one", "alt".getBytes());        cache.rebuildNode("/test/one");        Assert.assertEquals(cache.getCurrentData("/test/one").getData(), "alt".getBytes());        Assert.assertEquals(saveCounter, counter.get());        semaphore.release(1000);        timing.sleepABit();    } finally {        CloseableUtils.closeQuietly(cache);        TestCleanState.closeAndTestClean(client);    }}
6c84f1e55074cce3c787689d5dcd85e5e79e5f9a7fa6bfe43056e648a7affead
getDataAndStat
 void getDataAndStat(String fullPath) throws Exception
{    semaphore.acquire();    counter.incrementAndGet();    super.getDataAndStat(fullPath);    latch.countDown();}
668465484a4afaa2c8b4674980f94cbd3fdb16fc0086dc49c2dd69fc921cf949
internalTestMode
private void internalTestMode(CuratorFramework client, boolean cacheData) throws Exception
{    try (PathChildrenCache cache = new PathChildrenCache(client, "/test", cacheData)) {        final CountDownLatch latch = new CountDownLatch(2);        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {                    latch.countDown();                }            }        });        cache.start();        client.create().forPath("/test/one", "one".getBytes());        client.create().forPath("/test/two", "two".getBytes());        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        for (ChildData data : cache.getCurrentData()) {            if (cacheData) {                Assert.assertNotNull(data.getData());                Assert.assertNotNull(data.getStat());            } else {                Assert.assertNull(data.getData());                Assert.assertNotNull(data.getStat());            }        }    }}
d6477cd5e4da923bd9799bbf8d4db46d7d153fc78458c819b2b186c1ddff908e
childEvent
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {        latch.countDown();    }}
c7a00a749ec37d419bb105a770af2763d5fcf8d56782795615b23e4402333b9b
testBasics
public void testBasics() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");        final BlockingQueue<PathChildrenCacheEvent.Type> events = new LinkedBlockingQueue<PathChildrenCacheEvent.Type>();        try (PathChildrenCache cache = new PathChildrenCache(client, "/test", true)) {            cache.getListenable().addListener(new PathChildrenCacheListener() {                @Override                public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                    if (event.getData().getPath().equals("/test/one")) {                        events.offer(event.getType());                    }                }            });            cache.start();            client.create().forPath("/test/one", "hey there".getBytes());            Assert.assertEquals(events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_ADDED);            client.setData().forPath("/test/one", "sup!".getBytes());            Assert.assertEquals(events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_UPDATED);            Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "sup!");            client.delete().forPath("/test/one");            Assert.assertEquals(events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_REMOVED);        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
d6477cd5e4da923bd9799bbf8d4db46d7d153fc78458c819b2b186c1ddff908e
childEvent
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getData().getPath().equals("/test/one")) {        events.offer(event.getType());    }}
1883d4ec2c9a964f210d32199e661cb1558de4530d3a98e7001d3402745c3d98
testBasicsOnTwoCachesWithSameExecutor
public void testBasicsOnTwoCachesWithSameExecutor() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");        final BlockingQueue<PathChildrenCacheEvent.Type> events = new LinkedBlockingQueue<PathChildrenCacheEvent.Type>();        final ExecutorService exec = Executors.newSingleThreadExecutor();        try (PathChildrenCache cache = new PathChildrenCache(client, "/test", true, false, exec)) {            cache.getListenable().addListener(new PathChildrenCacheListener() {                @Override                public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                    if (event.getData().getPath().equals("/test/one")) {                        events.offer(event.getType());                    }                }            });            cache.start();            final BlockingQueue<PathChildrenCacheEvent.Type> events2 = new LinkedBlockingQueue<PathChildrenCacheEvent.Type>();            try (PathChildrenCache cache2 = new PathChildrenCache(client, "/test", true, false, exec)) {                cache2.getListenable().addListener(new PathChildrenCacheListener() {                    @Override                    public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                        if (event.getData().getPath().equals("/test/one")) {                            events2.offer(event.getType());                        }                    }                });                cache2.start();                client.create().forPath("/test/one", "hey there".getBytes());                Assert.assertEquals(events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_ADDED);                Assert.assertEquals(events2.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_ADDED);                client.setData().forPath("/test/one", "sup!".getBytes());                Assert.assertEquals(events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_UPDATED);                Assert.assertEquals(events2.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_UPDATED);                Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "sup!");                Assert.assertEquals(new String(cache2.getCurrentData("/test/one").getData()), "sup!");                client.delete().forPath("/test/one");                Assert.assertEquals(events.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_REMOVED);                Assert.assertEquals(events2.poll(timing.forWaiting().seconds(), TimeUnit.SECONDS), PathChildrenCacheEvent.Type.CHILD_REMOVED);            }        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
d6477cd5e4da923bd9799bbf8d4db46d7d153fc78458c819b2b186c1ddff908e
childEvent
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getData().getPath().equals("/test/one")) {        events.offer(event.getType());    }}
d6477cd5e4da923bd9799bbf8d4db46d7d153fc78458c819b2b186c1ddff908e
childEvent
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getData().getPath().equals("/test/one")) {        events2.offer(event.getType());    }}
f3514485d96a505aae18321fc276f69cb27425df9512ba593f1f99082219f68c
testDeleteNodeAfterCloseDoesntCallExecutor
public void testDeleteNodeAfterCloseDoesntCallExecutor() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/test");        final ExecuteCalledWatchingExecutorService exec = new ExecuteCalledWatchingExecutorService(Executors.newSingleThreadExecutor());        try (PathChildrenCache cache = new PathChildrenCache(client, "/test", true, false, exec)) {            cache.start();            client.create().forPath("/test/one", "hey there".getBytes());            cache.rebuild();            Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "hey there");            Assert.assertTrue(exec.isExecuteCalled());            exec.setExecuteCalled(false);        }        Assert.assertFalse(exec.isExecuteCalled());        client.delete().forPath("/test/one");        timing.sleepABit();        Assert.assertFalse(exec.isExecuteCalled());    } finally {        TestCleanState.closeAndTestClean(client);    }}
cc014e9ce92633621dfe50062410236b8898189d5d2a98b64142232691d2e032
testInterruptedOperationOnShutdown
public void testInterruptedOperationOnShutdown() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), 30000, 30000, new RetryOneTime(1));    client.start();    try {        final CountDownLatch latch = new CountDownLatch(1);        try (final PathChildrenCache cache = new PathChildrenCache(client, "/test", false) {            @Override            protected void handleException(Throwable e) {                latch.countDown();            }        }) {            cache.start();            cache.offerOperation(new Operation() {                @Override                public void invoke() throws Exception {                    Thread.sleep(5000);                }            });            Thread.sleep(1000);        }        latch.await(5, TimeUnit.SECONDS);        Assert.assertTrue(latch.getCount() == 1, "Unexpected exception occurred");    } finally {        TestCleanState.closeAndTestClean(client);    }}
acf01c7be23198ba58e96419e1afeacf9079d217f740104c3c3b8060824dc321
handleException
protected void handleException(Throwable e)
{    latch.countDown();}
3123c01a42d932f204074808c13c4f72b1e3239f2369166b923ebfef185d1b39
invoke
public void invoke() throws Exception
{    Thread.sleep(5000);}
fe37d207c17db7994d50140c25bc42d3b2cf27f8852aff56b3ac9e1c5f495802
getActualQty
protected int getActualQty(PathChildrenCache cache)
{    return cache.getCurrentData().size();}
a5280eeb5cae715151312522f2f128057b57d79328cf1b9bb1b23f732a186ed4
newCache
protected PathChildrenCache newCache(CuratorFramework client, String path, final BlockingQueue<Event> events) throws Exception
{    PathChildrenCache cache = new PathChildrenCache(client, path, false);    PathChildrenCacheListener listener = new PathChildrenCacheListener() {        @Override        public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {            if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {                events.add(new Event(EventType.ADDED, event.getData().getPath()));            }            if (event.getType() == PathChildrenCacheEvent.Type.CHILD_REMOVED) {                events.add(new Event(EventType.DELETED, event.getData().getPath()));            }        }    };    cache.getListenable().addListener(listener);    cache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);    return cache;}
d6477cd5e4da923bd9799bbf8d4db46d7d153fc78458c819b2b186c1ddff908e
childEvent
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {        events.add(new Event(EventType.ADDED, event.getData().getPath()));    }    if (event.getType() == PathChildrenCacheEvent.Type.CHILD_REMOVED) {        events.add(new Event(EventType.DELETED, event.getData().getPath()));    }}
dbbc1596e7b1f17431389a71d2969896dcd07f8e0f0af47294ee52e17f59eaf4
testMissedDelete
public void testMissedDelete() throws Exception
{    Timing timing = new Timing();    PathChildrenCache cache = null;    CuratorFramework client1 = null;    CuratorFramework client2 = null;    TestingCluster cluster = new TestingCluster(3);    try {        cluster.start();                InstanceSpec client1Instance = cluster.getInstances().iterator().next();        client1 = CuratorFrameworkFactory.newClient(client1Instance.getConnectString(), 1000, 1000, new RetryOneTime(1));        cache = new PathChildrenCache(client1, "/test", true);        final BlockingQueue<PathChildrenCacheEvent.Type> events = Queues.newLinkedBlockingQueue();        PathChildrenCacheListener listener = new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                events.add(event.getType());            }        };        cache.getListenable().addListener(listener);        client2 = CuratorFrameworkFactory.newClient(cluster.getConnectString(), 1000, 1000, new RetryOneTime(1));        client1.start();        client2.start();        cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);        Assert.assertEquals(events.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CONNECTION_RECONNECTED);        Assert.assertEquals(events.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.INITIALIZED);        client2.create().creatingParentsIfNeeded().forPath("/test/node", "first".getBytes());        Assert.assertEquals(events.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CHILD_ADDED);        cluster.killServer(client1Instance);        Assert.assertEquals(events.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CONNECTION_SUSPENDED);        Assert.assertEquals(events.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CONNECTION_LOST);        client2.delete().forPath("/test/node");        client2.create().forPath("/test/node", "second".getBytes());        cluster.restartServer(client1Instance);        Assert.assertEquals(events.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CONNECTION_RECONNECTED);                Assert.assertEquals(events.poll(timing.milliseconds(), TimeUnit.MILLISECONDS), PathChildrenCacheEvent.Type.CHILD_UPDATED);    } finally {        CloseableUtils.closeQuietly(client1);        CloseableUtils.closeQuietly(client2);        CloseableUtils.closeQuietly(cache);        CloseableUtils.closeQuietly(cluster);    }}
d6477cd5e4da923bd9799bbf8d4db46d7d153fc78458c819b2b186c1ddff908e
childEvent
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    events.add(event.getType());}
812d88cf1a34f44cdaa45349dad5bfc64d648c627dcffaf0d730290906219c28
testServerLoss
public void testServerLoss() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = null;    PathChildrenCache cache = null;    TestingCluster cluster = new TestingCluster(3);    try {        cluster.start();        client = CuratorFrameworkFactory.newClient(cluster.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        client.create().creatingParentsIfNeeded().forPath("/test");        cache = new PathChildrenCache(client, "/test", false);        cache.start();        final CountDownLatch resetLatch = new CountDownLatch(1);        final CountDownLatch reconnectLatch = new CountDownLatch(1);        final AtomicReference<CountDownLatch> latch = new AtomicReference<CountDownLatch>(new CountDownLatch(3));        cache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                if (event.getType() == PathChildrenCacheEvent.Type.CONNECTION_SUSPENDED) {                    resetLatch.countDown();                } else if (event.getType() == PathChildrenCacheEvent.Type.CONNECTION_RECONNECTED) {                    reconnectLatch.countDown();                } else if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {                    latch.get().countDown();                }            }        });        client.create().forPath("/test/one");        client.create().forPath("/test/two");        client.create().forPath("/test/three");        Assert.assertTrue(latch.get().await(10, TimeUnit.SECONDS));        InstanceSpec connectionInstance = cluster.findConnectionInstance(client.getZookeeperClient().getZooKeeper());        cluster.killServer(connectionInstance);        Assert.assertTrue(timing.awaitLatch(reconnectLatch));        Assert.assertEquals(cache.getCurrentData().size(), 3);    } finally {        CloseableUtils.closeQuietly(cache);        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(cluster);    }}
d6477cd5e4da923bd9799bbf8d4db46d7d153fc78458c819b2b186c1ddff908e
childEvent
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if (event.getType() == PathChildrenCacheEvent.Type.CONNECTION_SUSPENDED) {        resetLatch.countDown();    } else if (event.getType() == PathChildrenCacheEvent.Type.CONNECTION_RECONNECTED) {        reconnectLatch.countDown();    } else if (event.getType() == PathChildrenCacheEvent.Type.CHILD_ADDED) {        latch.get().countDown();    }}
cb40fe027cffa19f0528efcf6147c3f60ac1f828f64d9d85a9b5ea5e96f79357
testSelector
public void testSelector() throws Exception
{    client.create().forPath("/root");    client.create().forPath("/root/n1-a");    client.create().forPath("/root/n1-b");    client.create().forPath("/root/n1-b/n2-a");    client.create().forPath("/root/n1-b/n2-b");    client.create().forPath("/root/n1-b/n2-b/n3-a");    client.create().forPath("/root/n1-c");    client.create().forPath("/root/n1-d");    TreeCacheSelector selector = new TreeCacheSelector() {        @Override        public boolean traverseChildren(String fullPath) {            return !fullPath.equals("/root/n1-b/n2-b");        }        @Override        public boolean acceptChild(String fullPath) {            return !fullPath.equals("/root/n1-c");        }    };    cache = buildWithListeners(TreeCache.newBuilder(client, "/root").setSelector(selector));    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/root");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/root/n1-a");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/root/n1-b");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/root/n1-d");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/root/n1-b/n2-a");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/root/n1-b/n2-b");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();}
a329bc63e04f91227a45b19477132d01e85c23b037ef7122430b7b6890f1d001
traverseChildren
public boolean traverseChildren(String fullPath)
{    return !fullPath.equals("/root/n1-b/n2-b");}
e15a3694e431f11e14b58aa188efa027ee40bcf5b18b25716a29de7962bfa83c
acceptChild
public boolean acceptChild(String fullPath)
{    return !fullPath.equals("/root/n1-c");}
123186140ffceb4440599456274a5bbf61d872f6cc13a45cf521df3c3a718295
testStartup
public void testStartup() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/1", "one".getBytes());    client.create().forPath("/test/2", "two".getBytes());    client.create().forPath("/test/3", "three".getBytes());    client.create().forPath("/test/2/sub", "two-sub".getBytes());    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/1", "one".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/2", "two".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/3", "three".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/2/sub", "two-sub".getBytes());    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of("1", "2", "3"));    Assert.assertEquals(cache.getCurrentChildren("/test/1").keySet(), ImmutableSet.of());    Assert.assertEquals(cache.getCurrentChildren("/test/2").keySet(), ImmutableSet.of("sub"));    Assert.assertNull(cache.getCurrentChildren("/test/non_exist"));}
caba90133d27da25374d789c0091f2f81c52e334063767c0b3b5f45f34124329
testCreateParents
public void testCreateParents() throws Exception
{    cache = newTreeCacheWithListeners(client, "/one/two/three");    cache.start();    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertNull(client.checkExists().forPath("/one/two/three"));    cache.close();    cache = buildWithListeners(TreeCache.newBuilder(client, "/one/two/three").setCreateParentNodes(true));    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/one/two/three");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));}
0f70704ce0ed4acd8fd683bc5af8c19afb975a8b35b6ca6542c77b24748dc2f1
testStartEmpty
public void testStartEmpty() throws Exception
{    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.create().forPath("/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertNoMoreEvents();}
6c3d29a3d5970e9daed025ab283fbf0119608c1ae3585bbfa2cde47ecb614946
testStartEmptyDeeper
public void testStartEmptyDeeper() throws Exception
{    cache = newTreeCacheWithListeners(client, "/test/foo/bar");    cache.start();    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.create().creatingParentsIfNeeded().forPath("/test/foo");    assertNoMoreEvents();    client.create().forPath("/test/foo/bar");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo/bar");    assertNoMoreEvents();}
19997e6ab88c3624ba5bfcaa6b09b3ce28991d30c55690da6d822e0cd0b73f96
testDepth0
public void testDepth0() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/1", "one".getBytes());    client.create().forPath("/test/2", "two".getBytes());    client.create().forPath("/test/3", "three".getBytes());    client.create().forPath("/test/2/sub", "two-sub".getBytes());    cache = buildWithListeners(TreeCache.newBuilder(client, "/test").setMaxDepth(0));    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of());    Assert.assertNull(cache.getCurrentData("/test/1"));    Assert.assertNull(cache.getCurrentChildren("/test/1"));    Assert.assertNull(cache.getCurrentData("/test/non_exist"));}
d3336e89a7f11f50967ae209fbb57ec3c0a4f61fc40ad1aff842d30e6220d2a5
testDepth1
public void testDepth1() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/1", "one".getBytes());    client.create().forPath("/test/2", "two".getBytes());    client.create().forPath("/test/3", "three".getBytes());    client.create().forPath("/test/2/sub", "two-sub".getBytes());    cache = buildWithListeners(TreeCache.newBuilder(client, "/test").setMaxDepth(1));    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/1", "one".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/2", "two".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/3", "three".getBytes());    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of("1", "2", "3"));    Assert.assertEquals(cache.getCurrentChildren("/test/1").keySet(), ImmutableSet.of());    Assert.assertEquals(cache.getCurrentChildren("/test/2").keySet(), ImmutableSet.of());    Assert.assertNull(cache.getCurrentData("/test/2/sub"));    Assert.assertNull(cache.getCurrentChildren("/test/2/sub"));    Assert.assertNull(cache.getCurrentChildren("/test/non_exist"));}
8b39f6580f64a3aa58f354cb458c4613a794711959f92827ed7c38e314df2af4
testDepth1Deeper
public void testDepth1Deeper() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/foo");    client.create().forPath("/test/foo/bar");    client.create().forPath("/test/foo/bar/1", "one".getBytes());    client.create().forPath("/test/foo/bar/2", "two".getBytes());    client.create().forPath("/test/foo/bar/3", "three".getBytes());    client.create().forPath("/test/foo/bar/2/sub", "two-sub".getBytes());    cache = buildWithListeners(TreeCache.newBuilder(client, "/test/foo/bar").setMaxDepth(1));    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo/bar");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo/bar/1", "one".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo/bar/2", "two".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo/bar/3", "three".getBytes());    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();}
92342813cce1e277dba674ae90f7b54424620b0fcfd77eaf53d884023a18551a
testAsyncInitialPopulation
public void testAsyncInitialPopulation() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/one", "hey there".getBytes());    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();}
7a9630a917e68c1120f3bbcee9f50086429b09a135cb5e5686d8151a446de756
testFromRoot
public void testFromRoot() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/one", "hey there".getBytes());    cache = newTreeCacheWithListeners(client, "/");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertTrue(cache.getCurrentChildren("/").keySet().contains("test"));    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of("one"));    Assert.assertEquals(cache.getCurrentChildren("/test/one").keySet(), ImmutableSet.of());    Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "hey there");}
c7a339c9a3467025975553bb485edfcce3b3b0c25e82abb92fd31cf49a25b4a3
testFromRootWithDepth
public void testFromRootWithDepth() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/one", "hey there".getBytes());    cache = buildWithListeners(TreeCache.newBuilder(client, "/").setMaxDepth(1));    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertTrue(cache.getCurrentChildren("/").keySet().contains("test"));    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of());    Assert.assertNull(cache.getCurrentData("/test/one"));    Assert.assertNull(cache.getCurrentChildren("/test/one"));}
b7fe4c4498bd40571d4924cef6afaf6f3e4e688754f5b9e2a6c8bef2ea59ce9d
testWithNamespace
public void testWithNamespace() throws Exception
{    client.create().forPath("/outer");    client.create().forPath("/outer/foo");    client.create().forPath("/outer/test");    client.create().forPath("/outer/test/one", "hey there".getBytes());    cache = newTreeCacheWithListeners(client.usingNamespace("outer"), "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of("one"));    Assert.assertEquals(cache.getCurrentChildren("/test/one").keySet(), ImmutableSet.of());    Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "hey there");}
8442f29b26cd3006086a019b004428874076572596a6f123c7f66f241f85af87
testWithNamespaceAtRoot
public void testWithNamespaceAtRoot() throws Exception
{    client.create().forPath("/outer");    client.create().forPath("/outer/foo");    client.create().forPath("/outer/test");    client.create().forPath("/outer/test/one", "hey there".getBytes());    cache = newTreeCacheWithListeners(client.usingNamespace("outer"), "/");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/foo");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();    Assert.assertEquals(cache.getCurrentChildren("/").keySet(), ImmutableSet.of("foo", "test"));    Assert.assertEquals(cache.getCurrentChildren("/foo").keySet(), ImmutableSet.of());    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of("one"));    Assert.assertEquals(cache.getCurrentChildren("/test/one").keySet(), ImmutableSet.of());    Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "hey there");}
1c771cf05180a4b5fadad88b10559d90a6ed1b96bc73a9588f4e87b321aa488f
testSyncInitialPopulation
public void testSyncInitialPopulation() throws Exception
{    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.create().forPath("/test");    client.create().forPath("/test/one", "hey there".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");    assertNoMoreEvents();}
0c35fe000d285ae052344b21b246096e8ebf53281cfa00b93c4684b1e6bd477b
testChildrenInitialized
public void testChildrenInitialized() throws Exception
{    client.create().forPath("/test", "".getBytes());    client.create().forPath("/test/1", "1".getBytes());    client.create().forPath("/test/2", "2".getBytes());    client.create().forPath("/test/3", "3".getBytes());    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/1");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/2");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/3");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    assertNoMoreEvents();}
aeac80bebe2c0224580b6bfb841576632a40dc7f0243822008bd65208277a26f
testUpdateWhenNotCachingData
public void testUpdateWhenNotCachingData() throws Exception
{    client.create().forPath("/test");    cache = buildWithListeners(TreeCache.newBuilder(client, "/test").setCacheData(false));    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.create().forPath("/test/foo", "first".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo");    client.setData().forPath("/test/foo", "something new".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_UPDATED, "/test/foo");    assertNoMoreEvents();    Assert.assertNotNull(cache.getCurrentData("/test/foo"));        Assert.assertNull(cache.getCurrentData("/test/foo").getData());}
1c993f97815108a4b0b777614fe8e13a9e373f555db217b8dd1d9e6987112a08
testDeleteThenCreate
public void testDeleteThenCreate() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/foo", "one".getBytes());    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.delete().forPath("/test/foo");    assertEvent(TreeCacheEvent.Type.NODE_REMOVED, "/test/foo", "one".getBytes());    client.create().forPath("/test/foo", "two".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo");    client.delete().forPath("/test/foo");    assertEvent(TreeCacheEvent.Type.NODE_REMOVED, "/test/foo", "two".getBytes());    client.create().forPath("/test/foo", "two".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo");    assertNoMoreEvents();}
2b42c29deaab2a4fc4d942330a304c3f897bb0b2e57c8943e1d91f60c4ea345d
testDeleteThenCreateRoot
public void testDeleteThenCreateRoot() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/foo", "one".getBytes());    cache = newTreeCacheWithListeners(client, "/test/foo");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.delete().forPath("/test/foo");    assertEvent(TreeCacheEvent.Type.NODE_REMOVED, "/test/foo");    client.create().forPath("/test/foo", "two".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo");    client.delete().forPath("/test/foo");    assertEvent(TreeCacheEvent.Type.NODE_REMOVED, "/test/foo");    client.create().forPath("/test/foo", "two".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo");    assertNoMoreEvents();}
936fa9edcb8fd2ba6b5b9ef1ce09b39676da41bf85aa3cbdd99e3a1d444edcde
testKilledSession
public void testKilledSession() throws Exception
{    client.create().forPath("/test");    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.create().forPath("/test/foo", "foo".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/foo");    client.create().withMode(CreateMode.EPHEMERAL).forPath("/test/me", "data".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/me");    Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());    assertEvent(TreeCacheEvent.Type.NODE_REMOVED, "/test/me", "data".getBytes(), true);    assertEvent(TreeCacheEvent.Type.INITIALIZED, null, null, true);    assertNoMoreEvents();}
c7a00a749ec37d419bb105a770af2763d5fcf8d56782795615b23e4402333b9b
testBasics
public void testBasics() throws Exception
{    client.create().forPath("/test");    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of());    Assert.assertNull(cache.getCurrentChildren("/t"));    Assert.assertNull(cache.getCurrentChildren("/testing"));    client.create().forPath("/test/one", "hey there".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of("one"));    Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "hey there");    Assert.assertEquals(cache.getCurrentChildren("/test/one").keySet(), ImmutableSet.of());    Assert.assertNull(cache.getCurrentChildren("/test/o"));    Assert.assertNull(cache.getCurrentChildren("/test/onely"));    client.setData().forPath("/test/one", "sup!".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_UPDATED, "/test/one");    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of("one"));    Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "sup!");    client.delete().forPath("/test/one");    assertEvent(TreeCacheEvent.Type.NODE_REMOVED, "/test/one", "sup!".getBytes());    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of());    assertNoMoreEvents();}
9cf99b6b84678e7328c73012c7c8ad20e76bfe5a4113f184a19b85d6ae18a2d2
testBasicsWithNoZkWatches
public void testBasicsWithNoZkWatches() throws Exception
{    client.create().forPath("/test");    client.create().forPath("/test/one", "hey there".getBytes());    cache = buildWithListeners(TreeCache.newBuilder(client, "/test").disableZkWatches(true));    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    Assert.assertEquals(cache.getCurrentChildren("/test").keySet(), ImmutableSet.of("one"));    Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "hey there");    Assert.assertEquals(cache.getCurrentChildren("/test/one").keySet(), ImmutableSet.of());    Assert.assertNull(cache.getCurrentChildren("/test/o"));    Assert.assertNull(cache.getCurrentChildren("/test/onely"));    Assert.assertNull(cache.getCurrentChildren("/t"));    Assert.assertNull(cache.getCurrentChildren("/testing"));    assertNoMoreEvents();}
7042bada31ba3673a6f51b0eeade82095493667dae6c3ded5be7455d0edb03ba
testBasicsOnTwoCaches
public void testBasicsOnTwoCaches() throws Exception
{    TreeCache cache2 = newTreeCacheWithListeners(client, "/test");        cache2.getListenable().removeListener(eventListener);        final Semaphore semaphore = new Semaphore(0);    cache2.getListenable().addListener(new TreeCacheListener() {        @Override        public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception {            semaphore.release();        }    });    try {        client.create().forPath("/test");        cache = newTreeCacheWithListeners(client, "/test");        cache.start();        cache2.start();        assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");        assertEvent(TreeCacheEvent.Type.INITIALIZED);        semaphore.acquire(2);        client.create().forPath("/test/one", "hey there".getBytes());        assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");        Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "hey there");        semaphore.acquire();        Assert.assertEquals(new String(cache2.getCurrentData("/test/one").getData()), "hey there");        client.setData().forPath("/test/one", "sup!".getBytes());        assertEvent(TreeCacheEvent.Type.NODE_UPDATED, "/test/one");        Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "sup!");        semaphore.acquire();        Assert.assertEquals(new String(cache2.getCurrentData("/test/one").getData()), "sup!");        client.delete().forPath("/test/one");        assertEvent(TreeCacheEvent.Type.NODE_REMOVED, "/test/one", "sup!".getBytes());        Assert.assertNull(cache.getCurrentData("/test/one"));        semaphore.acquire();        Assert.assertNull(cache2.getCurrentData("/test/one"));        assertNoMoreEvents();        Assert.assertEquals(semaphore.availablePermits(), 0);    } finally {        CloseableUtils.closeQuietly(cache2);    }}
34e4997ab63acd7237bdfdebf2fc71e9d6d6126197060970008dd8f81cdd0288
childEvent
public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception
{    semaphore.release();}
f3514485d96a505aae18321fc276f69cb27425df9512ba593f1f99082219f68c
testDeleteNodeAfterCloseDoesntCallExecutor
public void testDeleteNodeAfterCloseDoesntCallExecutor() throws Exception
{    client.create().forPath("/test");    cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.create().forPath("/test/one", "hey there".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test/one");    Assert.assertEquals(new String(cache.getCurrentData("/test/one").getData()), "hey there");    cache.close();    assertNoMoreEvents();    client.delete().forPath("/test/one");    assertNoMoreEvents();}
7496659325a1bffee1f767e785383cfc71177e127599115508c6f790362befaf
testServerNotStartedYet
public void testServerNotStartedYet() throws Exception
{        server.stop();        client.close();    initCuratorFramework();        cache = newTreeCacheWithListeners(client, "/test");    cache.start();    assertNoMoreEvents();        server.restart();    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.create().forPath("/test");    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertNoMoreEvents();}
7f1fb39687574648b87ecc430a2537fc33da81f945a21c037812ab07141c3466
testErrorListener
public void testErrorListener() throws Exception
{    client.create().forPath("/test");    cache = buildWithListeners(TreeCache.newBuilder(client, "/test"));        cache.getListenable().addListener(new TreeCacheListener() {        @Override        public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception {            if (event.getType() == Type.NODE_UPDATED) {                throw new RuntimeException("Test Exception");            }        }    });    cache.getUnhandledErrorListenable().removeListener(errorListener);    final AtomicBoolean isProcessed = new AtomicBoolean(false);    cache.getUnhandledErrorListenable().addListener(new UnhandledErrorListener() {        @Override        public void unhandledError(String message, Throwable e) {            Assert.assertFalse(isProcessed.compareAndSet(false, true));        }    });    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/test");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    client.setData().forPath("/test", "hey there".getBytes());    assertEvent(TreeCacheEvent.Type.NODE_UPDATED, "/test");    assertNoMoreEvents();}
34e4997ab63acd7237bdfdebf2fc71e9d6d6126197060970008dd8f81cdd0288
childEvent
public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception
{    if (event.getType() == Type.NODE_UPDATED) {        throw new RuntimeException("Test Exception");    }}
221ba1c9d4a2fdcc828fc4f3549df182bc257ecbc2aca5ee2533f97d06bdf4d9
unhandledError
public void unhandledError(String message, Throwable e)
{    Assert.assertFalse(isProcessed.compareAndSet(false, true));}
93eab3b5982d30e5b149d254f30fc376b06708aba02343206d13048f6e612951
getActualQty
protected int getActualQty(TreeCache cache)
{    return cache.getCurrentChildren("/root").size();}
44bb9817c2cbd799ec2e192059618542de835e2dff033bd79e43b57115096ac3
newCache
protected TreeCache newCache(CuratorFramework client, String path, final BlockingQueue<Event> events) throws Exception
{    TreeCache cache = new TreeCache(client, path);    TreeCacheListener listener = new TreeCacheListener() {        @Override        public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception {            if ((event.getData() != null) && (event.getData().getPath().startsWith("/root/"))) {                if (event.getType() == TreeCacheEvent.Type.NODE_ADDED) {                    events.add(new Event(EventType.ADDED, event.getData().getPath()));                }                if (event.getType() == TreeCacheEvent.Type.NODE_REMOVED) {                    events.add(new Event(EventType.DELETED, event.getData().getPath()));                }            }        }    };    cache.getListenable().addListener(listener);    cache.start();    return cache;}
34e4997ab63acd7237bdfdebf2fc71e9d6d6126197060970008dd8f81cdd0288
childEvent
public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception
{    if ((event.getData() != null) && (event.getData().getPath().startsWith("/root/"))) {        if (event.getType() == TreeCacheEvent.Type.NODE_ADDED) {            events.add(new Event(EventType.ADDED, event.getData().getPath()));        }        if (event.getType() == TreeCacheEvent.Type.NODE_REMOVED) {            events.add(new Event(EventType.DELETED, event.getData().getPath()));        }    }}
0fa766ce523b620717d8c9740f0ee3f980111cb14529370b450cf7bc23a61ff6
testGiantRandomDeepTree
public void testGiantRandomDeepTree() throws Exception
{    doTestGiantRandomDeepTree();}
5751d4cfd84588d58a9dd8cc7d6e584930fa55a6ea0aca7246d863836b7df7cd
testGiantRandomDeepTreeWithDepth
public void testGiantRandomDeepTreeWithDepth() throws Exception
{    withDepth = true;    doTestGiantRandomDeepTree();}
b8ebcf05b6aae36ddb00ee73aa5c1a4dfd8d1ed9345035fc53688bb26c6a529e
doTestGiantRandomDeepTree
private void doTestGiantRandomDeepTree() throws Exception
{    client.create().forPath("/tree", null);    CuratorFramework cl = client.usingNamespace("tree");    if (withDepth) {        cache = buildWithListeners(TreeCache.newBuilder(cl, "/").setMaxDepth(TEST_DEPTH));    } else {        cache = newTreeCacheWithListeners(cl, "/");    }    cache.start();    assertEvent(TreeCacheEvent.Type.NODE_ADDED, "/");    assertEvent(TreeCacheEvent.Type.INITIALIZED);    TestNode root = new TestNode("/", null);    int maxDepth = 0;    int adds = 0;    int removals = 0;    int updates = 0;    for (int i = 0; i < ITERATIONS; ++i) {                int depth = 0;        TestNode last = null;        TestNode node = root;        while (!node.children.isEmpty() && random.nextDouble() < DIVE_CHANCE) {                        last = node;            node = Iterables.get(node.children.values(), random.nextInt(node.children.size()));            ++depth;        }        maxDepth = Math.max(depth, maxDepth);                switch(random.nextInt(3)) {            case 0:                                if (node != root && node.children.isEmpty()) {                                        TestNode removed = last.children.remove(ZKPaths.getNodeFromPath(node.fullPath));                    Assert.assertSame(node, removed);                                        cl.delete().forPath(node.fullPath);                                        if (shouldSeeEventAt(node.fullPath)) {                        assertEvent(TreeCacheEvent.Type.NODE_REMOVED, node.fullPath);                    }                    ++removals;                }                break;            case 1:                                byte[] newData = new byte[10];                random.nextBytes(newData);                if (Arrays.equals(node.data, newData)) {                                        continue;                }                                node.data = newData;                                cl.setData().forPath(node.fullPath, node.data);                                if (shouldSeeEventAt(node.fullPath)) {                    assertEvent(TreeCacheEvent.Type.NODE_UPDATED, node.fullPath, node.data);                }                ++updates;                break;            case 2:                                String name = Long.toHexString(random.nextLong());                if (node.children.containsKey(name)) {                                        continue;                }                                byte[] data = new byte[10];                random.nextBytes(data);                TestNode child = new TestNode(ZKPaths.makePath(node.fullPath, name), data);                node.children.put(name, child);                                cl.create().forPath(child.fullPath, child.data);                                if (shouldSeeEventAt(child.fullPath)) {                    assertEvent(TreeCacheEvent.Type.NODE_ADDED, child.fullPath, child.data);                }                ++adds;                break;        }                assertNodeEquals(cache.getCurrentData("/"), root);        assertTreeEquals(cache, root, 0);    }            System.out.println(String.format("maxDepth: %s, adds: %s, removals: %s, updates: %s", maxDepth, adds, removals, updates));    assertNoMoreEvents();}
7373d8b23b4c6e1d7a8489fecdac79ce1d887180d378cf9829de2823ca4bcfbc
shouldSeeEventAt
private boolean shouldSeeEventAt(String fullPath)
{    return !withDepth || ZKPaths.split(fullPath).size() <= TEST_DEPTH;}
b6aec000a71ed489fc1caa167939296ed5a11ea061937ce0e61ccc6b4205d673
assertTreeEquals
private void assertTreeEquals(TreeCache cache, TestNode expectedNode, int depth)
{    String path = expectedNode.fullPath;    Map<String, ChildData> cacheChildren = cache.getCurrentChildren(path);    Assert.assertNotNull(cacheChildren, path);    if (withDepth && depth == TEST_DEPTH) {        return;    }    Assert.assertEquals(cacheChildren.keySet(), expectedNode.children.keySet(), path);    for (Map.Entry<String, TestNode> entry : expectedNode.children.entrySet()) {        String nodeName = entry.getKey();        ChildData childData = cacheChildren.get(nodeName);        TestNode expectedChild = entry.getValue();        assertNodeEquals(childData, expectedChild);        assertTreeEquals(cache, expectedChild, depth + 1);    }}
daf28e712df7ac23ce2ba41459d91ee1c7629d69b3ef9d0bbc02a1446663df71
assertNodeEquals
private static void assertNodeEquals(ChildData actualChild, TestNode expectedNode)
{    String path = expectedNode.fullPath;    Assert.assertNotNull(actualChild, path);    Assert.assertEquals(actualChild.getData(), expectedNode.data, path);}
bb02d45ee3ff64f41c75e13596c5ec5d6a329b3ff4b89fe331f99747818e8715
startup
public void startup(ZooKeeperServer zks) throws IOException, InterruptedException
{    super.startup(new ChaosMonkeyZookeeperServer(zks));}
559a27c6383c42ec285b3fa60e1e5af9ad25c09289ba07859ec737ea63846807
startup
public void startup()
{    super.startup();    if (zks instanceof TestingZooKeeperMain.TestZooKeeperServer) {        ((TestingZooKeeperMain.TestZooKeeperServer) zks).noteStartup();    } else {        throw new RuntimeException("Unknown ZooKeeperServer: " + zks.getClass());    }}
05c91e8f4b123110aab2a85a840c8de16dd95b0bf4d4b293177674c9c960a81d
submitRequest
public void submitRequest(Request si)
{    long remaining = firstError != 0 ? LOCKOUT_DURATION_MS - (System.currentTimeMillis() - firstError) : 0;    if (si.type != ZooDefs.OpCode.createSession && si.type != ZooDefs.OpCode.sync && si.type != ZooDefs.OpCode.ping && firstError != 0 && remaining > 0) {        log.debug("Rejected : " + si.toString());                log.debug("Still not ready for " + remaining + "ms");        ((NIOServerCnxn) si.cnxn).close();        return;    }        log.debug("Applied : " + si.toString());    super.submitRequest(si);        if ((si.type == ZooDefs.OpCode.create) || (si.type == ZooDefs.OpCode.create2)) {        CreateRequest createRequest = new CreateRequest();        try {            ByteBuffer duplicate = si.request.duplicate();            duplicate.rewind();            ByteBufferInputStream.byteBuffer2Record(duplicate, createRequest);            if (createRequest.getPath().startsWith(CHAOS_ZNODE_PREFIX) && firstError == 0) {                firstError = System.currentTimeMillis();                                log.warn("Closing connection right after " + createRequest.getPath() + " creation");                ((NIOServerCnxn) si.cnxn).close();            }        } catch (Exception e) {                        ((NIOServerCnxn) si.cnxn).close();        }    }}
f5d8ecc9ad2357246574ff8dd777bca3ee67ca187dea97da74f420160bd89a2c
testAclErrorWithLeader
public void testAclErrorWithLeader() throws Exception
{    ACLProvider provider = new ACLProvider() {        @Override        public List<ACL> getDefaultAcl() {            return ZooDefs.Ids.OPEN_ACL_UNSAFE;        }        @Override        public List<ACL> getAclForPath(String path) {            if (path.equals("/base")) {                try {                    String testDigest = DigestAuthenticationProvider.generateDigest("test:test");                    return Collections.singletonList(new ACL(ZooDefs.Perms.ALL, new Id("digest", testDigest)));                } catch (NoSuchAlgorithmException e) {                    e.printStackTrace();                }            }            return getDefaultAcl();        }    };    RetryPolicy retryPolicy = new ExponentialBackoffRetry(timing.milliseconds(), 3);    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(retryPolicy).aclProvider(provider).authorization("digest", "test:test".getBytes());    CuratorFramework client = builder.build();    LeaderLatch latch = null;    try {        client.start();        latch = new LeaderLatch(client, "/base");        latch.start();        Assert.assertTrue(latch.await(timing.forWaiting().seconds(), TimeUnit.SECONDS));        latch.close();        latch = null;        CuratorFramework noAuthClient = CuratorFrameworkFactory.newClient(server.getConnectString(), retryPolicy);        try {            noAuthClient.start();            final CountDownLatch noAuthLatch = new CountDownLatch(1);            UnhandledErrorListener listener = new UnhandledErrorListener() {                @Override                public void unhandledError(String message, Throwable e) {                    if (e instanceof KeeperException.NoAuthException) {                        noAuthLatch.countDown();                    }                }            };            noAuthClient.getUnhandledErrorListenable().addListener(listener);                                    latch = new LeaderLatch(noAuthClient, "/base/second");            latch.start();            Assert.assertTrue(timing.awaitLatch(noAuthLatch));        } finally {            CloseableUtils.closeQuietly(noAuthClient);        }    } finally {        CloseableUtils.closeQuietly(latch);        CloseableUtils.closeQuietly(client);    }}
608c4250279b9160905e4962b77bc1d258c8a726d186d1875dd0e18be5e9bcbb
getDefaultAcl
public List<ACL> getDefaultAcl()
{    return ZooDefs.Ids.OPEN_ACL_UNSAFE;}
948e924ac3cf12487fcf7f5ccc3b514ae7fc4b9d602a2962739b070d41126b34
getAclForPath
public List<ACL> getAclForPath(String path)
{    if (path.equals("/base")) {        try {            String testDigest = DigestAuthenticationProvider.generateDigest("test:test");            return Collections.singletonList(new ACL(ZooDefs.Perms.ALL, new Id("digest", testDigest)));        } catch (NoSuchAlgorithmException e) {            e.printStackTrace();        }    }    return getDefaultAcl();}
221ba1c9d4a2fdcc828fc4f3549df182bc257ecbc2aca5ee2533f97d06bdf4d9
unhandledError
public void unhandledError(String message, Throwable e)
{    if (e instanceof KeeperException.NoAuthException) {        noAuthLatch.countDown();    }}
a80dcefdefa515a24128a4b275157de12c5263cdc4f63e0686fafb2848599711
testWithCircuitBreaker
public void testWithCircuitBreaker() throws Exception
{    final int threadQty = 5;    ExecutorService executorService = Executors.newFixedThreadPool(threadQty);    List<Holder> holders = Collections.emptyList();    Timing2 timing = new Timing2();    ConnectionStateListenerManagerFactory managerFactory = ConnectionStateListenerManagerFactory.circuitBreaking(new RetryForever(timing.multiple(2).milliseconds()));    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).connectionStateListenerManagerFactory(managerFactory).connectionTimeoutMs(timing.connection()).sessionTimeoutMs(timing.session()).build();    try {        client.start();        client.create().forPath("/hey");        Semaphore lostSemaphore = new Semaphore(0);        ConnectionStateListener unProxiedListener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    lostSemaphore.release();                }            }            @Override            public boolean doNotProxy() {                return true;            }        };        client.getConnectionStateListenable().addListener(unProxiedListener);        holders = IntStream.range(0, threadQty).mapToObj(index -> {            Holder holder = new Holder();            holder.latch = new LeaderLatch(client, "/foo/bar/" + index) {                @Override                protected void handleStateChange(ConnectionState newState) {                    holder.stateChanges.offer(newState);                    super.handleStateChange(newState);                }            };            return holder;        }).collect(Collectors.toList());        holders.forEach(holder -> {            executorService.submit(() -> {                holder.latch.start();                Assert.assertTrue(holder.latch.await(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS));                holder.isLockedLatch.countDown();                return null;            });            timing.awaitLatch(holder.isLockedLatch);        });        for (        int i = 0;         i < 4;         ++i) {            server.stop();            Assert.assertTrue(timing.acquireSemaphore(lostSemaphore));            server.restart();            timing.sleepABit();        }        for (Holder holder : holders) {            Assert.assertTrue(holder.latch.await(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS));            Assert.assertEquals(timing.takeFromQueue(holder.stateChanges), ConnectionState.SUSPENDED);            Assert.assertEquals(timing.takeFromQueue(holder.stateChanges), ConnectionState.LOST);            Assert.assertEquals(timing.takeFromQueue(holder.stateChanges), ConnectionState.RECONNECTED);        }    } finally {        holders.forEach(holder -> CloseableUtils.closeQuietly(holder.latch));        CloseableUtils.closeQuietly(client);        executorService.shutdownNow();    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        lostSemaphore.release();    }}
052fb1fa9dd744184daf95bc1b6fa794f18fa4939ad19b228ea3af7ce10e066f
doNotProxy
public boolean doNotProxy()
{    return true;}
0b14149ab076fe69681b1eb7701980c464fd3bab3ddd4e305914519de05167a3
handleStateChange
protected void handleStateChange(ConnectionState newState)
{    holder.stateChanges.offer(newState);    super.handleStateChange(newState);}
bc38f7ed7db8cce67add09931024529aff546dd960b71f21132f30ee26a652eb
testUncreatedPathGetLeader
public void testUncreatedPathGetLeader() throws Exception
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        LeaderLatch latch = new LeaderLatch(client, "/foo/bar");                latch.getLeader();    }}
413718becf36b815f09f2b186fcccaf623cc6206a63beabdcaac036b706a4859
testWatchedNodeDeletedOnReconnect
public void testWatchedNodeDeletedOnReconnect() throws Exception
{    final String latchPath = "/foo/bar";    Timing2 timing = new Timing2();    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1))) {        client.start();        LeaderLatch latch1 = new LeaderLatch(client, latchPath, "1");        try (LeaderLatch latch2 = new LeaderLatch(client, latchPath, "2")) {            latch1.start();            latch1.await();                        latch2.start();            timing.sleepABit();            latch2.debugCheckLeaderShipLatch = new CountDownLatch(1);                        latch1.close();            latch1 = null;                        timing.sleepABit();                        latch2.reset();                        latch2.debugCheckLeaderShipLatch.countDown();            Assert.assertTrue(latch2.await(timing.forSessionSleep().forWaiting().milliseconds(), TimeUnit.MILLISECONDS));            timing.sleepABit();            Assert.assertEquals(client.getChildren().forPath(latchPath).size(), 1);        } finally {            CloseableUtils.closeQuietly(latch1);        }    }}
0a60827d256e229e6099b4025e9e0160edc0d13469df404eb0070ec20e1f5a4c
testSessionErrorPolicy
public void testSessionErrorPolicy() throws Exception
{    Timing timing = new Timing();    LeaderLatch latch = null;    CuratorFramework client = null;    for (int i = 0; i < 2; ++i) {        boolean isSessionIteration = (i == 0);        try {            client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).connectionTimeoutMs(10000).sessionTimeoutMs(60000).retryPolicy(new RetryOneTime(1)).connectionStateErrorPolicy(isSessionIteration ? new SessionConnectionStateErrorPolicy() : new StandardConnectionStateErrorPolicy()).build();            final BlockingQueue<String> states = Queues.newLinkedBlockingQueue();            ConnectionStateListener stateListener = new ConnectionStateListener() {                @Override                public void stateChanged(CuratorFramework client, ConnectionState newState) {                    states.add(newState.name());                }            };            client.getConnectionStateListenable().addListener(stateListener);            client.start();            latch = new LeaderLatch(client, "/test");            LeaderLatchListener listener = new LeaderLatchListener() {                @Override                public void isLeader() {                    states.add("true");                }                @Override                public void notLeader() {                    states.add("false");                }            };            latch.addListener(listener);            latch.start();            Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED.name());            Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), "true");            server.stop();            if (isSessionIteration) {                Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED.name());                server.restart();                Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.RECONNECTED.name());                Assert.assertNull(states.poll(timing.milliseconds(), TimeUnit.MILLISECONDS));            } else {                String s = states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS);                Assert.assertTrue("false".equals(s) || ConnectionState.SUSPENDED.name().equals(s));                s = states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS);                Assert.assertTrue("false".equals(s) || ConnectionState.SUSPENDED.name().equals(s));                server.restart();                Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.RECONNECTED.name());                Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), "true");            }        } finally {            CloseableUtils.closeQuietly(latch);            CloseableUtils.closeQuietly(client);        }    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    states.add(newState.name());}
161f2b20fcb60bb29fa4dd2a2de4c5bd28f8ea5b6a88f6601db69778560262ec
isLeader
public void isLeader()
{    states.add("true");}
7309ee5a376f42d6463d9f23a9cface128ecba20f10d327fca13beb4c4b92859
notLeader
public void notLeader()
{    states.add("false");}
c6e0a8a17eb41349bb1882547dbe938e8b4a53d1ae890fb78331cc2dd3351a61
testErrorPolicies
public void testErrorPolicies() throws Exception
{    Timing2 timing = new Timing2();    LeaderLatch latch = null;    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).connectionTimeoutMs(1000).sessionTimeoutMs(timing.session()).retryPolicy(new RetryOneTime(1)).connectionStateErrorPolicy(new StandardConnectionStateErrorPolicy()).build();    try {        final BlockingQueue<String> states = Queues.newLinkedBlockingQueue();        ConnectionStateListener stateListener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                states.add(newState.name());            }        };        client.getConnectionStateListenable().addListener(stateListener);        client.start();        latch = new LeaderLatch(client, "/test");        LeaderLatchListener listener = new LeaderLatchListener() {            @Override            public void isLeader() {                states.add("true");            }            @Override            public void notLeader() {                states.add("false");            }        };        latch.addListener(listener);        latch.start();        Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED.name());        Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), "true");        server.close();        List<String> next = Lists.newArrayList();        next.add(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS));        next.add(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS));        Assert.assertTrue(next.equals(Arrays.asList(ConnectionState.SUSPENDED.name(), "false")) || next.equals(Arrays.asList("false", ConnectionState.SUSPENDED.name())), next.toString());        Assert.assertEquals(states.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST.name());        latch.close();        client.close();        timing.sleepABit();        states.clear();        server = new TestingServer();        client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).connectionTimeoutMs(1000).sessionTimeoutMs(timing.session()).retryPolicy(new RetryOneTime(1)).connectionStateErrorPolicy(new SessionConnectionStateErrorPolicy()).build();        client.getConnectionStateListenable().addListener(stateListener);        client.start();        latch = new LeaderLatch(client, "/test");        latch.addListener(listener);        latch.start();        Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED.name());        Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), "true");        server.close();        Assert.assertEquals(states.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED.name());        next = Lists.newArrayList();        next.add(states.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS));        next.add(states.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS));        Assert.assertTrue(next.equals(Arrays.asList(ConnectionState.LOST.name(), "false")) || next.equals(Arrays.asList("false", ConnectionState.LOST.name())), next.toString());    } finally {        CloseableUtils.closeQuietly(latch);        CloseableUtils.closeQuietly(client);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    states.add(newState.name());}
161f2b20fcb60bb29fa4dd2a2de4c5bd28f8ea5b6a88f6601db69778560262ec
isLeader
public void isLeader()
{    states.add("true");}
7309ee5a376f42d6463d9f23a9cface128ecba20f10d327fca13beb4c4b92859
notLeader
public void notLeader()
{    states.add("false");}
ae709d7444abdef37d06dd496478016efb17ba66abc45750b1314944440b611e
testProperCloseWithoutConnectionEstablished
public void testProperCloseWithoutConnectionEstablished() throws Exception
{    server.stop();    Timing timing = new Timing();    LeaderLatch latch = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final AtomicBoolean resetCalled = new AtomicBoolean(false);        final CountDownLatch cancelStartTaskLatch = new CountDownLatch(1);        latch = new LeaderLatch(client, PATH_NAME) {            @Override            void reset() throws Exception {                resetCalled.set(true);                super.reset();            }            @Override            protected boolean cancelStartTask() {                if (super.cancelStartTask()) {                    cancelStartTaskLatch.countDown();                    return true;                }                return false;            }        };        latch.start();        latch.close();        latch = null;        Assert.assertTrue(timing.awaitLatch(cancelStartTaskLatch));        Assert.assertFalse(resetCalled.get());    } finally {        CloseableUtils.closeQuietly(latch);        TestCleanState.closeAndTestClean(client);    }}
922a27998ffa2d361afe12609da246c21073c9ed1662bab9de7bb303c29ab236
reset
 void reset() throws Exception
{    resetCalled.set(true);    super.reset();}
d2fc38a68fc298ff7f5574735d7007394f37a3fb13b846bdffa5dcdc2e7beca0
cancelStartTask
protected boolean cancelStartTask()
{    if (super.cancelStartTask()) {        cancelStartTaskLatch.countDown();        return true;    }    return false;}
8550812e8b0a05d0ed6844df1ba03d962dd27c62c44e83ff855ab2eb3696a5c9
testResetRace
public void testResetRace() throws Exception
{    Timing timing = new Timing();    LeaderLatch latch = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        latch = new LeaderLatch(client, PATH_NAME);        latch.debugResetWaitLatch = new CountDownLatch(1);                latch.start();                latch.reset();        timing.sleepABit();        latch.debugResetWaitLatch.countDown();        timing.sleepABit();        Assert.assertEquals(client.getChildren().forPath(PATH_NAME).size(), 1);    } finally {        CloseableUtils.closeQuietly(latch);        TestCleanState.closeAndTestClean(client);    }}
28ada92ea1f085ee37165a595eb95b77b98710f1e12fcccc89ef8bbaabce1bd5
testCreateDeleteRace
public void testCreateDeleteRace() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().creatingParentsIfNeeded().forPath(PATH_NAME);        LeaderLatch latch = new LeaderLatch(client, PATH_NAME);        latch.debugResetWaitLatch = new CountDownLatch(1);        latch.start();        latch.close();        timing.sleepABit();        latch.debugResetWaitLatch.countDown();        timing.sleepABit();        Assert.assertEquals(client.getChildren().forPath(PATH_NAME).size(), 0);    } finally {        TestCleanState.closeAndTestClean(client);    }}
9e133f27399eb81ce72a290f53ed6152b572a3819a5126115b820f8025eaec97
testLostConnection
public void testLostConnection() throws Exception
{    final int PARTICIPANT_QTY = 10;    List<LeaderLatch> latches = Lists.newArrayList();    final Timing timing = new Timing();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final CountDownLatch countDownLatch = new CountDownLatch(1);        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    countDownLatch.countDown();                }            }        });        for (int i = 0; i < PARTICIPANT_QTY; ++i) {            LeaderLatch latch = new LeaderLatch(client, PATH_NAME);            latch.start();            latches.add(latch);        }        waitForALeader(latches, timing);        server.stop();        Assert.assertTrue(timing.awaitLatch(countDownLatch));        timing.forWaiting().sleepABit();        Assert.assertEquals(getLeaders(latches).size(), 0);        server.restart();                Assert.assertEquals(waitForALeader(latches, timing).size(), 1);    } finally {        for (LeaderLatch latch : latches) {            CloseableUtils.closeQuietly(latch);        }        TestCleanState.closeAndTestClean(client);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        countDownLatch.countDown();    }}
3732416e10762bf31bc40593044e398fabcda0bdb99e92397efb76b86a83bc4a
testCorrectWatching
public void testCorrectWatching() throws Exception
{    final int PARTICIPANT_QTY = 10;    final int PARTICIPANT_ID = 2;    List<LeaderLatch> latches = Lists.newArrayList();    final Timing timing = new Timing();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        for (int i = 0; i < PARTICIPANT_QTY; ++i) {            LeaderLatch latch = new LeaderLatch(client, PATH_NAME);            latch.start();            latches.add(latch);            waitForALeader(latches, timing);        }                latches.get(PARTICIPANT_ID).close();                        Assert.assertTrue(!latches.get(PARTICIPANT_ID - 1).hasLeadership());    } finally {                latches.remove(PARTICIPANT_ID);        for (LeaderLatch latch : latches) {            CloseableUtils.closeQuietly(latch);        }        TestCleanState.closeAndTestClean(client);    }}
f3095f239701567d85850b4d4b291d39b54be46294f42e6f6c3569c5c8249d2b
testWaiting
public void testWaiting() throws Exception
{    final int LOOPS = 10;    for (int i = 0; i < LOOPS; ++i) {        System.out.println("TRY #" + i);        internalTestWaitingOnce();        Thread.sleep(10);    }}
4a4d8fcf96061a8c77fb8e3d667c0fd812c0e68f4e32da394959adc170e99237
internalTestWaitingOnce
private void internalTestWaitingOnce() throws Exception
{    final int PARTICIPANT_QTY = 10;    ExecutorService executorService = Executors.newFixedThreadPool(PARTICIPANT_QTY);    ExecutorCompletionService<Void> service = new ExecutorCompletionService<Void>(executorService);    final Timing timing = new Timing();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final AtomicBoolean thereIsALeader = new AtomicBoolean(false);        for (int i = 0; i < PARTICIPANT_QTY; ++i) {            service.submit(new Callable<Void>() {                @Override                public Void call() throws Exception {                    LeaderLatch latch = new LeaderLatch(client, PATH_NAME);                    try {                        latch.start();                        Assert.assertTrue(latch.await(timing.forWaiting().seconds(), TimeUnit.SECONDS));                        Assert.assertTrue(thereIsALeader.compareAndSet(false, true));                        Thread.sleep((int) (10 * Math.random()));                        thereIsALeader.set(false);                    } finally {                        latch.close();                    }                    return null;                }            });        }        for (int i = 0; i < PARTICIPANT_QTY; ++i) {            service.take().get();        }    } finally {        executorService.shutdownNow();        TestCleanState.closeAndTestClean(client);    }}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    LeaderLatch latch = new LeaderLatch(client, PATH_NAME);    try {        latch.start();        Assert.assertTrue(latch.await(timing.forWaiting().seconds(), TimeUnit.SECONDS));        Assert.assertTrue(thereIsALeader.compareAndSet(false, true));        Thread.sleep((int) (10 * Math.random()));        thereIsALeader.set(false);    } finally {        latch.close();    }    return null;}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    basic(Mode.START_IMMEDIATELY);}
4f1f7d7cec674c6e18dc5430b9f3fac4cd86b899ab2fd4de9e2cc777ff8fc5ca
testBasicAlt
public void testBasicAlt() throws Exception
{    basic(Mode.START_IN_THREADS);}
03743a55fb69e8ea1d95052740d29d5c5e4df890daeeb0371d05d0a4cad0aab0
testCallbackSanity
public void testCallbackSanity() throws Exception
{    final int PARTICIPANT_QTY = 10;    final CountDownLatch timesSquare = new CountDownLatch(PARTICIPANT_QTY);    final AtomicLong masterCounter = new AtomicLong(0);    final AtomicLong notLeaderCounter = new AtomicLong(0);    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    ExecutorService exec = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setDaemon(true).setNameFormat("callbackSanity-%s").build());    List<LeaderLatch> latches = Lists.newArrayList();    for (int i = 0; i < PARTICIPANT_QTY; ++i) {        final LeaderLatch latch = new LeaderLatch(client, PATH_NAME);        latch.addListener(new LeaderLatchListener() {            boolean beenLeader = false;            @Override            public void isLeader() {                if (!beenLeader) {                    masterCounter.incrementAndGet();                    beenLeader = true;                    try {                        latch.reset();                    } catch (Exception e) {                        throw Throwables.propagate(e);                    }                } else {                    masterCounter.incrementAndGet();                    CloseableUtils.closeQuietly(latch);                    timesSquare.countDown();                }            }            @Override            public void notLeader() {                notLeaderCounter.incrementAndGet();            }        }, exec);        latches.add(latch);    }    try {        client.start();        for (LeaderLatch latch : latches) {            latch.start();        }        timesSquare.await();        Assert.assertEquals(masterCounter.get(), PARTICIPANT_QTY * 2);        Assert.assertEquals(notLeaderCounter.get(), PARTICIPANT_QTY);        for (LeaderLatch latch : latches) {            Assert.assertEquals(latch.getState(), LeaderLatch.State.CLOSED);        }    } finally {        for (LeaderLatch latch : latches) {            if (latch.getState() != LeaderLatch.State.CLOSED) {                CloseableUtils.closeQuietly(latch);            }        }        TestCleanState.closeAndTestClean(client);    }}
161f2b20fcb60bb29fa4dd2a2de4c5bd28f8ea5b6a88f6601db69778560262ec
isLeader
public void isLeader()
{    if (!beenLeader) {        masterCounter.incrementAndGet();        beenLeader = true;        try {            latch.reset();        } catch (Exception e) {            throw Throwables.propagate(e);        }    } else {        masterCounter.incrementAndGet();        CloseableUtils.closeQuietly(latch);        timesSquare.countDown();    }}
7309ee5a376f42d6463d9f23a9cface128ecba20f10d327fca13beb4c4b92859
notLeader
public void notLeader()
{    notLeaderCounter.incrementAndGet();}
2081e7da240b79a52ca880882d39d881a68949c10801464e25232ee1b6bfdcbd
testCallbackNotifyLeader
public void testCallbackNotifyLeader() throws Exception
{    final int PARTICIPANT_QTY = 10;    final int SILENT_QTY = 3;    final CountDownLatch timesSquare = new CountDownLatch(PARTICIPANT_QTY);    final AtomicLong masterCounter = new AtomicLong(0);    final AtomicLong notLeaderCounter = new AtomicLong(0);    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    ExecutorService exec = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setDaemon(true).setNameFormat("callbackNotifyLeader-%s").build());    List<LeaderLatch> latches = Lists.newArrayList();    for (int i = 0; i < PARTICIPANT_QTY; ++i) {        LeaderLatch.CloseMode closeMode = i < SILENT_QTY ? LeaderLatch.CloseMode.SILENT : LeaderLatch.CloseMode.NOTIFY_LEADER;        final LeaderLatch latch = new LeaderLatch(client, PATH_NAME, "", closeMode);        latch.addListener(new LeaderLatchListener() {            boolean beenLeader = false;            @Override            public void isLeader() {                if (!beenLeader) {                    masterCounter.incrementAndGet();                    beenLeader = true;                    try {                        latch.reset();                    } catch (Exception e) {                        throw Throwables.propagate(e);                    }                } else {                    masterCounter.incrementAndGet();                    CloseableUtils.closeQuietly(latch);                    timesSquare.countDown();                }            }            @Override            public void notLeader() {                notLeaderCounter.incrementAndGet();            }        }, exec);        latches.add(latch);    }    try {        client.start();        for (LeaderLatch latch : latches) {            latch.start();        }        timesSquare.await();        Assert.assertEquals(masterCounter.get(), PARTICIPANT_QTY * 2);        Assert.assertEquals(notLeaderCounter.get(), PARTICIPANT_QTY * 2 - SILENT_QTY);        for (LeaderLatch latch : latches) {            Assert.assertEquals(latch.getState(), LeaderLatch.State.CLOSED);        }    } finally {        for (LeaderLatch latch : latches) {            if (latch.getState() != LeaderLatch.State.CLOSED) {                CloseableUtils.closeQuietly(latch);            }        }        TestCleanState.closeAndTestClean(client);    }}
161f2b20fcb60bb29fa4dd2a2de4c5bd28f8ea5b6a88f6601db69778560262ec
isLeader
public void isLeader()
{    if (!beenLeader) {        masterCounter.incrementAndGet();        beenLeader = true;        try {            latch.reset();        } catch (Exception e) {            throw Throwables.propagate(e);        }    } else {        masterCounter.incrementAndGet();        CloseableUtils.closeQuietly(latch);        timesSquare.countDown();    }}
7309ee5a376f42d6463d9f23a9cface128ecba20f10d327fca13beb4c4b92859
notLeader
public void notLeader()
{    notLeaderCounter.incrementAndGet();}
3bf66459208e527df86ea4a452092836802c92ce96fb2f46e8834151b37eabff
testCallbackDontNotify
public void testCallbackDontNotify() throws Exception
{    final AtomicLong masterCounter = new AtomicLong(0);    final AtomicLong notLeaderCounter = new AtomicLong(0);    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    final LeaderLatch leader = new LeaderLatch(client, PATH_NAME);    final LeaderLatch notifiedLeader = new LeaderLatch(client, PATH_NAME, "", LeaderLatch.CloseMode.NOTIFY_LEADER);    leader.addListener(new LeaderLatchListener() {        @Override        public void isLeader() {        }        @Override        public void notLeader() {            masterCounter.incrementAndGet();        }    });    notifiedLeader.addListener(new LeaderLatchListener() {        @Override        public void isLeader() {        }        @Override        public void notLeader() {            notLeaderCounter.incrementAndGet();        }    });    try {        client.start();        leader.start();        timing.sleepABit();        notifiedLeader.start();        timing.sleepABit();        notifiedLeader.close();        timing.sleepABit();                leader.close(LeaderLatch.CloseMode.NOTIFY_LEADER);        Assert.assertEquals(leader.getState(), LeaderLatch.State.CLOSED);        Assert.assertEquals(notifiedLeader.getState(), LeaderLatch.State.CLOSED);        Assert.assertEquals(masterCounter.get(), 1);        Assert.assertEquals(notLeaderCounter.get(), 0);    } finally {        if (leader.getState() != LeaderLatch.State.CLOSED) {            CloseableUtils.closeQuietly(leader);        }        if (notifiedLeader.getState() != LeaderLatch.State.CLOSED) {            CloseableUtils.closeQuietly(notifiedLeader);        }        TestCleanState.closeAndTestClean(client);    }}
161f2b20fcb60bb29fa4dd2a2de4c5bd28f8ea5b6a88f6601db69778560262ec
isLeader
public void isLeader()
{}
7309ee5a376f42d6463d9f23a9cface128ecba20f10d327fca13beb4c4b92859
notLeader
public void notLeader()
{    masterCounter.incrementAndGet();}
161f2b20fcb60bb29fa4dd2a2de4c5bd28f8ea5b6a88f6601db69778560262ec
isLeader
public void isLeader()
{}
7309ee5a376f42d6463d9f23a9cface128ecba20f10d327fca13beb4c4b92859
notLeader
public void notLeader()
{    notLeaderCounter.incrementAndGet();}
ce058c37cbc92667d1fa9c76dd7a52ccae44f1278c3aaa286fb083a754df5cba
testNoServerAtStart
public void testNoServerAtStart()
{    CloseableUtils.closeQuietly(server);    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryNTimes(5, 1000));    client.start();    final LeaderLatch leader = new LeaderLatch(client, PATH_NAME);    final CountDownLatch leaderCounter = new CountDownLatch(1);    final AtomicInteger leaderCount = new AtomicInteger(0);    final AtomicInteger notLeaderCount = new AtomicInteger(0);    leader.addListener(new LeaderLatchListener() {        @Override        public void isLeader() {            leaderCounter.countDown();            leaderCount.incrementAndGet();        }        @Override        public void notLeader() {            notLeaderCount.incrementAndGet();        }    });    try {        leader.start();        timing.sleepABit();                server = new TestingServer(server.getPort(), server.getTempDirectory());        Assert.assertTrue(timing.awaitLatch(leaderCounter), "Not elected leader");        Assert.assertEquals(leaderCount.get(), 1, "Elected too many times");        Assert.assertEquals(notLeaderCount.get(), 0, "Unelected too many times");    } catch (Exception e) {        Assert.fail("Unexpected exception", e);    } finally {        CloseableUtils.closeQuietly(leader);        TestCleanState.closeAndTestClean(client);        CloseableUtils.closeQuietly(server);    }}
161f2b20fcb60bb29fa4dd2a2de4c5bd28f8ea5b6a88f6601db69778560262ec
isLeader
public void isLeader()
{    leaderCounter.countDown();    leaderCount.incrementAndGet();}
7309ee5a376f42d6463d9f23a9cface128ecba20f10d327fca13beb4c4b92859
notLeader
public void notLeader()
{    notLeaderCount.incrementAndGet();}
977a5a355d7e47fd16f6c91bee0c4eef6a62b61c86d7d015f97d1870253c0f68
basic
private void basic(Mode mode) throws Exception
{        final int PARTICIPANT_QTY = 1;    List<LeaderLatch> latches = Lists.newArrayList();    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        for (int i = 0; i < PARTICIPANT_QTY; ++i) {            LeaderLatch latch = new LeaderLatch(client, PATH_NAME);            if (mode == Mode.START_IMMEDIATELY) {                latch.start();            }            latches.add(latch);        }        if (mode == Mode.START_IN_THREADS) {            ExecutorService service = Executors.newFixedThreadPool(latches.size());            for (final LeaderLatch latch : latches) {                service.submit(new Callable<Object>() {                    @Override                    public Object call() throws Exception {                        Thread.sleep((int) (100 * Math.random()));                        latch.start();                        return null;                    }                });            }            service.shutdown();        }        while (latches.size() > 0) {            List<LeaderLatch> leaders = waitForALeader(latches, timing);                        Assert.assertEquals(leaders.size(), 1);            LeaderLatch theLeader = leaders.get(0);            if (mode == Mode.START_IMMEDIATELY) {                                Assert.assertEquals(latches.indexOf(theLeader), 0);            }            theLeader.close();            latches.remove(theLeader);        }    } finally {        for (LeaderLatch latch : latches) {            CloseableUtils.closeQuietly(latch);        }        TestCleanState.closeAndTestClean(client);    }}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    Thread.sleep((int) (100 * Math.random()));    latch.start();    return null;}
99779c2dcbbf29fd27ccef11905be5a7c41ce70410cb3e88e976dc2b0e92842e
waitForALeader
private List<LeaderLatch> waitForALeader(List<LeaderLatch> latches, Timing timing) throws InterruptedException
{    for (int i = 0; i < MAX_LOOPS; ++i) {        List<LeaderLatch> leaders = getLeaders(latches);        if (leaders.size() != 0) {            return leaders;        }        timing.sleepABit();    }    return Lists.newArrayList();}
c49d9d8a430a314bb25122468326712574f7227071ad0fa37dc52f96b41f4611
getLeaders
private List<LeaderLatch> getLeaders(Collection<LeaderLatch> latches)
{    List<LeaderLatch> leaders = Lists.newArrayList();    for (LeaderLatch latch : latches) {        if (latch.hasLeadership()) {            leaders.add(latch);        }    }    return leaders;}
6b757b0ae123070a62d51e127252dc5ecbeb179a5e2c5fb2ebaf3763bd904366
testRelativePath
public void testRelativePath() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    new LeaderLatch(client, "parent");}
3a619f5b2a8c51ea027044be42e4bea61c19661477e3bcfb0f1adef09889020b
testInCluster
public void testInCluster() throws Exception
{    final int PARTICIPANT_QTY = 3;    List<ClientAndLatch> clients = Lists.newArrayList();    Timing timing = new Timing();    TestingCluster cluster = new TestingCluster(PARTICIPANT_QTY);    try {        cluster.start();        List<InstanceSpec> instances = Lists.newArrayList(cluster.getInstances());        for (int i = 0; i < PARTICIPANT_QTY; ++i) {            CuratorFramework client = CuratorFrameworkFactory.newClient(instances.get(i).getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));            LeaderLatch latch = new LeaderLatch(client, "/latch");            clients.add(new ClientAndLatch(client, latch, i));            client.start();            latch.start();        }        ClientAndLatch leader = waitForALeader(clients, timing);        Assert.assertNotNull(leader);        cluster.killServer(instances.get(leader.index));        Thread.sleep(timing.multiple(2).session());        leader = waitForALeader(clients, timing);        Assert.assertNotNull(leader);        Assert.assertEquals(getLeaders(clients).size(), 1);    } finally {        for (ClientAndLatch client : clients) {            CloseableUtils.closeQuietly(client.latch);            CloseableUtils.closeQuietly(client.client);        }        CloseableUtils.closeQuietly(cluster);    }}
1aeca02cbeb65bb145410d24dacfdbd73db8b535a7ac10dfc53373ad7ef9ec74
waitForALeader
private ClientAndLatch waitForALeader(List<ClientAndLatch> latches, Timing timing) throws InterruptedException
{    for (int i = 0; i < MAX_LOOPS; ++i) {        List<ClientAndLatch> leaders = getLeaders(latches);        if (leaders.size() != 0) {            return leaders.get(0);        }        timing.sleepABit();    }    return null;}
2b73539ff3008be141022d8a7705f977664bb598f825af0d2d3b6a790426d017
getLeaders
private List<ClientAndLatch> getLeaders(Collection<ClientAndLatch> latches)
{    List<ClientAndLatch> leaders = Lists.newArrayList();    for (ClientAndLatch clientAndLatch : latches) {        if (clientAndLatch.latch.hasLeadership()) {            leaders.add(clientAndLatch);        }    }    return leaders;}
0e55446611d1e72d29c9f0198226a6010da4d94dd0d8a0a257a617ec8e5ed317
testInterruption
public void testInterruption() throws Exception
{    Timing2 timing = new Timing2();    LeaderSelector selector = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        CountDownLatch exitLatch = new CountDownLatch(1);        BlockingQueue<Thread> threadExchange = new ArrayBlockingQueue<>(1);        LeaderSelectorListener listener = new LeaderSelectorListenerAdapter() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                threadExchange.put(Thread.currentThread());                try {                    Thread.currentThread().join();                } finally {                    exitLatch.countDown();                }            }        };        selector = new LeaderSelector(client, PATH_NAME, listener);        selector.failedMutexReleaseCount = new AtomicInteger();        selector.start();        Thread leaderThread = timing.takeFromQueue(threadExchange);        leaderThread.interrupt();        Assert.assertTrue(timing.awaitLatch(exitLatch));                timing.sleepABit();        Assert.assertEquals(0, selector.failedMutexReleaseCount.get());    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
572980c734fcdd22464cc98d1931013f84abfc71246389b062e7e113e357572e
takeLeadership
public void takeLeadership(CuratorFramework client) throws Exception
{    threadExchange.put(Thread.currentThread());    try {        Thread.currentThread().join();    } finally {        exitLatch.countDown();    }}
c6e0a8a17eb41349bb1882547dbe938e8b4a53d1ae890fb78331cc2dd3351a61
testErrorPolicies
public void testErrorPolicies() throws Exception
{    Timing2 timing = new Timing2();    LeaderSelector selector = null;    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).connectionTimeoutMs(timing.connection()).sessionTimeoutMs(timing.session()).retryPolicy(new RetryOneTime(1)).connectionStateErrorPolicy(new StandardConnectionStateErrorPolicy()).build();    try {        final BlockingQueue<String> changes = Queues.newLinkedBlockingQueue();        ConnectionStateListener stateListener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                changes.add(newState.name());            }        };        client.getConnectionStateListenable().addListener(stateListener);        client.start();        LeaderSelectorListener listener = new LeaderSelectorListenerAdapter() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                changes.add("leader");                try {                    Thread.currentThread().join();                } catch (InterruptedException e) {                    changes.add("release");                    Thread.currentThread().interrupt();                }            }        };        selector = new LeaderSelector(client, "/test", listener);        selector.start();        Assert.assertEquals(changes.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED.name());        Assert.assertEquals(changes.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), "leader");        server.close();        List<String> next = Lists.newArrayList();        next.add(changes.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS));        next.add(changes.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS));        Assert.assertTrue(next.equals(Arrays.asList(ConnectionState.SUSPENDED.name(), "release")) || next.equals(Arrays.asList("release", ConnectionState.SUSPENDED.name())), next.toString());        Assert.assertEquals(changes.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.LOST.name());        selector.close();        client.close();        timing.sleepABit();        changes.clear();        server = new TestingServer();        client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).connectionTimeoutMs(timing.connection()).sessionTimeoutMs(timing.session()).retryPolicy(new RetryOneTime(1)).connectionStateErrorPolicy(new SessionConnectionStateErrorPolicy()).build();        client.getConnectionStateListenable().addListener(stateListener);        client.start();        selector = new LeaderSelector(client, "/test", listener);        selector.start();        Assert.assertEquals(changes.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.CONNECTED.name());        Assert.assertEquals(changes.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), "leader");        server.stop();        Assert.assertEquals(changes.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), ConnectionState.SUSPENDED.name());        next = Lists.newArrayList();        next.add(changes.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS));        next.add(changes.poll(timing.forSessionSleep().milliseconds(), TimeUnit.MILLISECONDS));        Assert.assertTrue(next.equals(Arrays.asList(ConnectionState.LOST.name(), "release")) || next.equals(Arrays.asList("release", ConnectionState.LOST.name())), next.toString());    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    changes.add(newState.name());}
572980c734fcdd22464cc98d1931013f84abfc71246389b062e7e113e357572e
takeLeadership
public void takeLeadership(CuratorFramework client) throws Exception
{    changes.add("leader");    try {        Thread.currentThread().join();    } catch (InterruptedException e) {        changes.add("release");        Thread.currentThread().interrupt();    }}
56aa2aaaa429d33a50ba9ed8e3d1c24c7132e61127c6680ed8c10f38f281a893
testLeaderNodeDeleteOnInterrupt
public void testLeaderNodeDeleteOnInterrupt() throws Exception
{    Timing2 timing = new Timing2();    LeaderSelector selector = null;    CuratorFramework client = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        final CountDownLatch reconnectedLatch = new CountDownLatch(1);        ConnectionStateListener connectionStateListener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.RECONNECTED) {                    reconnectedLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(connectionStateListener);        client.start();        final BlockingQueue<Thread> queue = new ArrayBlockingQueue<Thread>(1);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                queue.add(Thread.currentThread());                try {                    Thread.currentThread().join();                } catch (InterruptedException e) {                    Thread.currentThread().interrupt();                }            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        selector = new LeaderSelector(client, "/leader", listener);        selector.start();        Thread leaderThread = timing.takeFromQueue(queue);        server.stop();        leaderThread.interrupt();        server.restart();        Assert.assertTrue(timing.awaitLatch(reconnectedLatch));        timing.sleepABit();        Assert.assertEquals(client.getChildren().forPath("/leader").size(), 0);    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.RECONNECTED) {        reconnectedLatch.countDown();    }}
572980c734fcdd22464cc98d1931013f84abfc71246389b062e7e113e357572e
takeLeadership
public void takeLeadership(CuratorFramework client) throws Exception
{    queue.add(Thread.currentThread());    try {        Thread.currentThread().join();    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
09f42845dcfc88d7884937f7ae1377aa6fe96777eafe1af56027908535d0cdaa
testInterruptLeadershipWithRequeue
public void testInterruptLeadershipWithRequeue() throws Exception
{    Timing timing = new Timing();    LeaderSelector selector = null;    CuratorFramework client = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        final Semaphore semaphore = new Semaphore(0);        LeaderSelectorListener listener = new LeaderSelectorListenerAdapter() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                semaphore.release();                Thread.currentThread().join();            }        };        selector = new LeaderSelector(client, "/leader", listener);        selector.autoRequeue();        selector.start();        Assert.assertTrue(timing.acquireSemaphore(semaphore));        selector.interruptLeadership();        Assert.assertTrue(timing.acquireSemaphore(semaphore));    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
572980c734fcdd22464cc98d1931013f84abfc71246389b062e7e113e357572e
takeLeadership
public void takeLeadership(CuratorFramework client) throws Exception
{    semaphore.release();    Thread.currentThread().join();}
ca6827fb7a167d552af811913d34cb1d038a573235dcfc1e281e01db19f836fe
testInterruptLeadership
public void testInterruptLeadership() throws Exception
{    LeaderSelector selector = null;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final CountDownLatch isLeaderLatch = new CountDownLatch(1);        final CountDownLatch losingLeaderLatch = new CountDownLatch(1);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                isLeaderLatch.countDown();                try {                    Thread.currentThread().join();                } finally {                    losingLeaderLatch.countDown();                }            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        selector = new LeaderSelector(client, "/leader", listener);        selector.start();        Assert.assertTrue(timing.awaitLatch(isLeaderLatch));        selector.interruptLeadership();        Assert.assertTrue(timing.awaitLatch(losingLeaderLatch));    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
572980c734fcdd22464cc98d1931013f84abfc71246389b062e7e113e357572e
takeLeadership
public void takeLeadership(CuratorFramework client) throws Exception
{    isLeaderLatch.countDown();    try {        Thread.currentThread().join();    } finally {        losingLeaderLatch.countDown();    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
6070cf244fa75dd6e7ffa6e0d9d3e9888d1c6fc4e84a3805e303dce29fced0a3
testRaceAtStateChanged
public void testRaceAtStateChanged() throws Exception
{    LeaderSelector selector = null;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final CountDownLatch takeLeadershipLatch = new CountDownLatch(1);        final CountDownLatch lostLatch = new CountDownLatch(1);        final CountDownLatch reconnectedLatch = new CountDownLatch(1);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                                takeLeadershipLatch.countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.RECONNECTED) {                    reconnectedLatch.countDown();                } else if (newState == ConnectionState.LOST) {                    lostLatch.countDown();                    throw new CancelLeadershipException();                }            }        };        selector = new LeaderSelector(client, "/leader", listener);        CountDownLatch debugLeadershipLatch = new CountDownLatch(1);        CountDownLatch debugLeadershipWaitLatch = new CountDownLatch(1);        selector.debugLeadershipLatch = debugLeadershipLatch;        selector.debugLeadershipWaitLatch = debugLeadershipWaitLatch;        selector.start();        Assert.assertTrue(timing.awaitLatch(debugLeadershipLatch));        server.stop();        Assert.assertTrue(timing.awaitLatch(lostLatch));        timing.sleepABit();        debugLeadershipWaitLatch.countDown();        server.restart();        Assert.assertTrue(timing.awaitLatch(reconnectedLatch));        Assert.assertFalse(takeLeadershipLatch.await(3, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
572980c734fcdd22464cc98d1931013f84abfc71246389b062e7e113e357572e
takeLeadership
public void takeLeadership(CuratorFramework client) throws Exception
{        takeLeadershipLatch.countDown();}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.RECONNECTED) {        reconnectedLatch.countDown();    } else if (newState == ConnectionState.LOST) {        lostLatch.countDown();        throw new CancelLeadershipException();    }}
2dc1c77cd6f438035267e3f9c595449d9927cc0a5b7c587cc1fe45378986bbed
testAutoRequeue
public void testAutoRequeue() throws Exception
{    Timing timing = new Timing();    LeaderSelector selector = null;    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).sessionTimeoutMs(timing.session()).build();    try {        client.start();        final Semaphore semaphore = new Semaphore(0);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                Thread.sleep(10);                semaphore.release();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        selector = new LeaderSelector(client, "/leader", listener);        selector.autoRequeue();        selector.start();        Assert.assertTrue(timing.acquireSemaphore(semaphore, 2));    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
572980c734fcdd22464cc98d1931013f84abfc71246389b062e7e113e357572e
takeLeadership
public void takeLeadership(CuratorFramework client) throws Exception
{    Thread.sleep(10);    semaphore.release();}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
62e2902658a0c9eb2eaf2610738bb9e3d958d6e3639ee64b7c6beba6fc2da22b
testServerDying
public void testServerDying() throws Exception
{    Timing timing = new Timing();    LeaderSelector selector = null;    CuratorFramework client = CuratorFrameworkFactory.builder().connectionTimeoutMs(timing.connection()).connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).sessionTimeoutMs(timing.session()).build();    client.start();    try {        final Semaphore semaphore = new Semaphore(0);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                semaphore.release();                Thread.sleep(Integer.MAX_VALUE);            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    semaphore.release();                }            }        };        selector = new LeaderSelector(client, "/leader", listener);        selector.start();        timing.acquireSemaphore(semaphore);        server.close();        timing.acquireSemaphore(semaphore);    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
572980c734fcdd22464cc98d1931013f84abfc71246389b062e7e113e357572e
takeLeadership
public void takeLeadership(CuratorFramework client) throws Exception
{    semaphore.release();    Thread.sleep(Integer.MAX_VALUE);}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        semaphore.release();    }}
9c31d31a79cc75f5dc578fc1174c3d0f6e4b8d2352d2e9341c77277ee85d40da
testKillSessionThenCloseShouldElectNewLeader
public void testKillSessionThenCloseShouldElectNewLeader() throws Exception
{    final Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final Semaphore semaphore = new Semaphore(0);        final CountDownLatch interruptedLatch = new CountDownLatch(1);        final AtomicInteger leaderCount = new AtomicInteger(0);        LeaderSelectorListener listener = new LeaderSelectorListenerAdapter() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                leaderCount.incrementAndGet();                try {                    semaphore.release();                    try {                        Thread.currentThread().join();                    } catch (InterruptedException e) {                        Thread.currentThread().interrupt();                        interruptedLatch.countDown();                    }                } finally {                    leaderCount.decrementAndGet();                }            }        };        LeaderSelector leaderSelector1 = new LeaderSelector(client, PATH_NAME, listener);        LeaderSelector leaderSelector2 = new LeaderSelector(client, PATH_NAME, listener);        boolean leaderSelector1Closed = false;        boolean leaderSelector2Closed = false;        leaderSelector1.start();        leaderSelector2.start();        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        Assert.assertTrue(timing.awaitLatch(interruptedLatch));        timing.sleepABit();        boolean requeued1 = leaderSelector1.requeue();        boolean requeued2 = leaderSelector2.requeue();        Assert.assertTrue(requeued1);        Assert.assertTrue(requeued2);        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        Assert.assertEquals(leaderCount.get(), 1);        if (leaderSelector1.hasLeadership()) {            leaderSelector1.close();            leaderSelector1Closed = true;        } else if (leaderSelector2.hasLeadership()) {            leaderSelector2.close();            leaderSelector2Closed = true;        } else {            fail("No leaderselector has leadership!");        }                Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        Assert.assertEquals(leaderCount.get(), 1);        if (!leaderSelector1Closed) {            leaderSelector1.close();        }        if (!leaderSelector2Closed) {            leaderSelector2.close();        }    } finally {        client.close();    }}
572980c734fcdd22464cc98d1931013f84abfc71246389b062e7e113e357572e
takeLeadership
public void takeLeadership(CuratorFramework client) throws Exception
{    leaderCount.incrementAndGet();    try {        semaphore.release();        try {            Thread.currentThread().join();        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            interruptedLatch.countDown();        }    } finally {        leaderCount.decrementAndGet();    }}
71d9a3b629d3c414d58f8633d5241b6706362c7e698bb8feb637c1418dd5d235
testKillServerThenCloseShouldElectNewLeader
public void testKillServerThenCloseShouldElectNewLeader() throws Exception
{    final Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final Semaphore semaphore = new Semaphore(0);        final CountDownLatch interruptedLatch = new CountDownLatch(1);        final AtomicInteger leaderCount = new AtomicInteger(0);        LeaderSelectorListener listener = new LeaderSelectorListenerAdapter() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                leaderCount.incrementAndGet();                try {                    semaphore.release();                    try {                        Thread.currentThread().join();                    } catch (InterruptedException e) {                        Thread.currentThread().interrupt();                        interruptedLatch.countDown();                    }                } finally {                    leaderCount.decrementAndGet();                }            }        };        LeaderSelector leaderSelector1 = new LeaderSelector(client, PATH_NAME, listener);        LeaderSelector leaderSelector2 = new LeaderSelector(client, PATH_NAME, listener);        boolean leaderSelector1Closed = false;        boolean leaderSelector2Closed = false;        leaderSelector1.autoRequeue();        leaderSelector2.autoRequeue();        leaderSelector1.start();        leaderSelector2.start();        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        int port = server.getPort();        server.stop();        timing.sleepABit();        server = new TestingServer(port);        Assert.assertTrue(timing.awaitLatch(interruptedLatch));        timing.sleepABit();        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        Assert.assertEquals(leaderCount.get(), 1);        if (leaderSelector1.hasLeadership()) {            leaderSelector1.close();            leaderSelector1Closed = true;        } else if (leaderSelector2.hasLeadership()) {            leaderSelector2.close();            leaderSelector2Closed = true;        } else {            fail("No leaderselector has leadership!");        }                Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        Assert.assertEquals(leaderCount.get(), 1);        if (!leaderSelector1Closed) {            leaderSelector1.close();        }        if (!leaderSelector2Closed) {            leaderSelector2.close();        }    } finally {        client.close();    }}
572980c734fcdd22464cc98d1931013f84abfc71246389b062e7e113e357572e
takeLeadership
public void takeLeadership(CuratorFramework client) throws Exception
{    leaderCount.incrementAndGet();    try {        semaphore.release();        try {            Thread.currentThread().join();        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            interruptedLatch.countDown();        }    } finally {        leaderCount.decrementAndGet();    }}
65492e96c4a0d50a8dff1432e1ee64d831257b5306907a4b0ed35b06f89eabdf
testClosing
public void testClosing() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch latch = new CountDownLatch(1);        LeaderSelector leaderSelector1 = new LeaderSelector(client, PATH_NAME, new LeaderSelectorListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                latch.await(10, TimeUnit.SECONDS);            }        });        LeaderSelector leaderSelector2 = new LeaderSelector(client, PATH_NAME, new LeaderSelectorListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                latch.await(10, TimeUnit.SECONDS);            }        });        leaderSelector1.start();        leaderSelector2.start();        while (!leaderSelector1.hasLeadership() && !leaderSelector2.hasLeadership()) {            Thread.sleep(1000);        }        Assert.assertNotSame(leaderSelector1.hasLeadership(), leaderSelector2.hasLeadership());        LeaderSelector positiveLeader;        LeaderSelector negativeLeader;        if (leaderSelector1.hasLeadership()) {            positiveLeader = leaderSelector1;            negativeLeader = leaderSelector2;        } else {            positiveLeader = leaderSelector2;            negativeLeader = leaderSelector1;        }        negativeLeader.close();        Thread.sleep(1000);        Assert.assertNotSame(positiveLeader.hasLeadership(), negativeLeader.hasLeadership());        Assert.assertTrue(positiveLeader.hasLeadership());        positiveLeader.close();        Thread.sleep(1000);        Assert.assertFalse(positiveLeader.hasLeadership());    } finally {        client.close();    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
572980c734fcdd22464cc98d1931013f84abfc71246389b062e7e113e357572e
takeLeadership
public void takeLeadership(CuratorFramework client) throws Exception
{    latch.await(10, TimeUnit.SECONDS);}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
572980c734fcdd22464cc98d1931013f84abfc71246389b062e7e113e357572e
takeLeadership
public void takeLeadership(CuratorFramework client) throws Exception
{    latch.await(10, TimeUnit.SECONDS);}
73bde4f7fd1a55a776c969a245d1d6cde58dc55a0fddbb2e8b5efcdfeabea2e6
testRotatingLeadership
public void testRotatingLeadership() throws Exception
{    final int LEADER_QTY = 5;    final int REPEAT_QTY = 3;    final Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final BlockingQueue<Integer> leaderList = new LinkedBlockingQueue<Integer>();        List<LeaderSelector> selectors = Lists.newArrayList();        for (int i = 0; i < LEADER_QTY; ++i) {            final int ourIndex = i;            LeaderSelector leaderSelector = new LeaderSelector(client, PATH_NAME, new LeaderSelectorListener() {                @Override                public void takeLeadership(CuratorFramework client) throws Exception {                    timing.sleepABit();                    leaderList.add(ourIndex);                }                @Override                public void stateChanged(CuratorFramework client, ConnectionState newState) {                }            });            selectors.add(leaderSelector);        }        List<Integer> localLeaderList = Lists.newArrayList();        for (int i = 1; i <= REPEAT_QTY; ++i) {            for (LeaderSelector leaderSelector : selectors) {                if (i > 1) {                    leaderSelector.requeue();                } else {                    leaderSelector.start();                }            }            while (localLeaderList.size() != (i * selectors.size())) {                Integer polledIndex = leaderList.poll(10, TimeUnit.SECONDS);                Assert.assertNotNull(polledIndex);                localLeaderList.add(polledIndex);            }            timing.sleepABit();        }        for (LeaderSelector leaderSelector : selectors) {            leaderSelector.close();        }        System.out.println(localLeaderList);        for (int i = 0; i < REPEAT_QTY; ++i) {            Set<Integer> uniques = Sets.newHashSet();            for (int j = 0; j < selectors.size(); ++j) {                Assert.assertTrue(localLeaderList.size() > 0);                int thisIndex = localLeaderList.remove(0);                Assert.assertFalse(uniques.contains(thisIndex));                uniques.add(thisIndex);            }        }    } finally {        client.close();    }}
572980c734fcdd22464cc98d1931013f84abfc71246389b062e7e113e357572e
takeLeadership
public void takeLeadership(CuratorFramework client) throws Exception
{    timing.sleepABit();    leaderList.add(ourIndex);}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
38c8a8453c199de1a8e82d5aa54502b34c7355e8b5dd8a414d992f9ba7ef0154
testRestart
public void testRestart() throws Exception
{    final Timing timing = new Timing();    CuratorFramework client = null;    TestingCluster cluster = new TestingCluster(3);    cluster.start();    try {        client = CuratorFrameworkFactory.newClient(cluster.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        final Semaphore semaphore = new Semaphore(0);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                List<String> names = client.getChildren().forPath("/leader");                Assert.assertTrue(names.size() > 0);                semaphore.release();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        LeaderSelector selector = new LeaderSelector(client, "/leader", listener);        selector.autoRequeue();        selector.start();        Assert.assertTrue(timing.acquireSemaphore(semaphore));        InstanceSpec connectionInstance = cluster.findConnectionInstance(client.getZookeeperClient().getZooKeeper());        cluster.killServer(connectionInstance);        Assert.assertTrue(timing.multiple(4).acquireSemaphore(semaphore));    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(cluster);    }}
572980c734fcdd22464cc98d1931013f84abfc71246389b062e7e113e357572e
takeLeadership
public void takeLeadership(CuratorFramework client) throws Exception
{    List<String> names = client.getChildren().forPath("/leader");    Assert.assertTrue(names.size() > 0);    semaphore.release();}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
b947df1400f0041dc3bd45fe245a8bd6bc03501713817a241cffd17a1ff7dcdd
testLostRestart
public void testLostRestart() throws Exception
{    final Timing timing = new Timing();    CuratorFramework client = null;    TestingCluster cluster = new TestingCluster(3);    cluster.start();    try {        client = CuratorFrameworkFactory.newClient(cluster.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        client.sync().forPath("/");        final AtomicReference<Exception> error = new AtomicReference<Exception>(null);        final AtomicReference<String> lockNode = new AtomicReference<String>(null);        final Semaphore semaphore = new Semaphore(0);        final CountDownLatch lostLatch = new CountDownLatch(1);        final CountDownLatch internalLostLatch = new CountDownLatch(1);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                try {                    List<String> names = client.getChildren().forPath("/leader");                    if (names.size() != 1) {                        semaphore.release();                        Exception exception = new Exception("Names size isn't 1: " + names.size());                        error.set(exception);                        return;                    }                    lockNode.set(names.get(0));                    semaphore.release();                    if (!timing.multiple(4).awaitLatch(internalLostLatch)) {                        error.set(new Exception("internalLostLatch await failed"));                    }                } finally {                    lostLatch.countDown();                }            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    internalLostLatch.countDown();                }            }        };        LeaderSelector selector = new LeaderSelector(client, "/leader", listener);        selector.start();        Assert.assertTrue(timing.multiple(4).acquireSemaphore(semaphore));        if (error.get() != null) {            throw new AssertionError(error.get());        }        Collection<InstanceSpec> instances = cluster.getInstances();        cluster.stop();        Assert.assertTrue(timing.multiple(4).awaitLatch(lostLatch));        timing.sleepABit();        Assert.assertFalse(selector.hasLeadership());        Assert.assertNotNull(lockNode.get());        cluster = new TestingCluster(instances.toArray(new InstanceSpec[instances.size()]));        cluster.start();        try {                        client.delete().forPath(ZKPaths.makePath("/leader", lockNode.get()));        } catch (Exception ignore) {                }        Assert.assertTrue(semaphore.availablePermits() == 0);        Assert.assertFalse(selector.hasLeadership());        selector.requeue();        Assert.assertTrue(timing.multiple(4).acquireSemaphore(semaphore));    } finally {        CloseableUtils.closeQuietly(client);        CloseableUtils.closeQuietly(cluster);    }}
572980c734fcdd22464cc98d1931013f84abfc71246389b062e7e113e357572e
takeLeadership
public void takeLeadership(CuratorFramework client) throws Exception
{    try {        List<String> names = client.getChildren().forPath("/leader");        if (names.size() != 1) {            semaphore.release();            Exception exception = new Exception("Names size isn't 1: " + names.size());            error.set(exception);            return;        }        lockNode.set(names.get(0));        semaphore.release();        if (!timing.multiple(4).awaitLatch(internalLostLatch)) {            error.set(new Exception("internalLostLatch await failed"));        }    } finally {        lostLatch.countDown();    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        internalLostLatch.countDown();    }}
4ddf2ea67fac7b0af18515000ee3ae86c81293152f5ff1ce2728613a44e3efe1
setCNXFactory
public static void setCNXFactory()
{    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, ChaosMonkeyCnxnFactory.class.getName());}
3af5b719f1f665caae66a3a9ee60ae2221d7df646c406e7c3c05bf362510aabc
resetCNXFactory
public static void resetCNXFactory()
{    System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);}
d06cb56c2afcfb45c354273ebe82b70fd610aea2134934a810a67db4a8b9a9b9
flappingTest
public void flappingTest() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryNTimes(1, 500)).sessionTimeoutMs(30000).build();    final TestLeaderSelectorListener listener = new TestLeaderSelectorListener();    LeaderSelector leaderSelector1 = new LeaderSelector(client, ChaosMonkeyCnxnFactory.CHAOS_ZNODE, listener);    LeaderSelector leaderSelector2 = null;    client.start();    try {        client.create().forPath(ChaosMonkeyCnxnFactory.CHAOS_ZNODE);        leaderSelector1.start();                        Assert.assertTrue(listener.reconnected.await(10, TimeUnit.SECONDS), "Connection has not been lost");                Assert.assertEquals(listener.takeLeadership.getCount(), 1);                Thread.sleep(ChaosMonkeyCnxnFactory.LOCKOUT_DURATION_MS * 2);                final int children = client.getChildren().forPath(ChaosMonkeyCnxnFactory.CHAOS_ZNODE).size();        Assert.assertEquals(children, 0, "Still " + children + " znodes under " + ChaosMonkeyCnxnFactory.CHAOS_ZNODE + " lock");                leaderSelector2 = new LeaderSelector(client, ChaosMonkeyCnxnFactory.CHAOS_ZNODE, listener);        leaderSelector2.start();        Assert.assertTrue(listener.takeLeadership.await(1, TimeUnit.SECONDS));    } finally {        try {            leaderSelector1.close();        } catch (IllegalStateException e) {            Assert.fail(e.getMessage());        }        try {            if (leaderSelector2 != null) {                leaderSelector2.close();            }        } catch (IllegalStateException e) {            Assert.fail(e.getMessage());        }        client.close();    }}
572980c734fcdd22464cc98d1931013f84abfc71246389b062e7e113e357572e
takeLeadership
public void takeLeadership(CuratorFramework client) throws Exception
{    log.info("-->takeLeadership({})", client.toString());    takeLeadership.countDown();    log.info("<--takeLeadership({})", client.toString());}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.RECONNECTED) {        reconnected.countDown();    }}
93c84d4e5ae1ecf3570541e070a47f16f5feb78fd44525f1e363ca98effd91f2
createProtectedNodeInBackgroundTest
public void createProtectedNodeInBackgroundTest() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryNTimes(2, 100)).connectionTimeoutMs(1000).sessionTimeoutMs(60000).build();    final CountDownLatch latch = new CountDownLatch(1);    client.start();    try {        client.create().forPath(ChaosMonkeyCnxnFactory.CHAOS_ZNODE);        client.create().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).inBackground(new BackgroundCallback() {            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                log.info("Receive event {}", event.toString());                if (event.getResultCode() == KeeperException.Code.CONNECTIONLOSS.intValue()) {                    latch.countDown();                }            }        }).forPath(ChaosMonkeyCnxnFactory.CHAOS_ZNODE_PREFIX + "foo-");        Assert.assertTrue(latch.await(30, TimeUnit.SECONDS), "Callback has not been called");                Thread.sleep(ChaosMonkeyCnxnFactory.LOCKOUT_DURATION_MS * 2);                final int children = client.getChildren().forPath(ChaosMonkeyCnxnFactory.CHAOS_ZNODE).size();        Assert.assertEquals(children, 0, "Still " + children + " znodes under " + ChaosMonkeyCnxnFactory.CHAOS_ZNODE + " lock");    } finally {        client.close();    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    log.info("Receive event {}", event.toString());    if (event.getResultCode() == KeeperException.Code.CONNECTIONLOSS.intValue()) {        latch.countDown();    }}
b14be96242fa555c52e1974d2c7729b0bd14a7c0bf6eff44c9f7f7b761812ab0
createProtectedNodeInBackgroundTestNoRetry
public void createProtectedNodeInBackgroundTestNoRetry() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryNTimes(0, 0)).connectionTimeoutMs(1000).sessionTimeoutMs(60000).build();    final CountDownLatch latch = new CountDownLatch(1);    client.start();    try {        client.create().forPath(ChaosMonkeyCnxnFactory.CHAOS_ZNODE);        client.create().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).inBackground(new BackgroundCallback() {            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                log.info("Receive event {}", event.toString());                if (event.getResultCode() == KeeperException.Code.CONNECTIONLOSS.intValue()) {                    latch.countDown();                }            }        }).forPath(ChaosMonkeyCnxnFactory.CHAOS_ZNODE_PREFIX + "foo-");        Assert.assertTrue(latch.await(30, TimeUnit.SECONDS), "Callback has not been called");                Thread.sleep(ChaosMonkeyCnxnFactory.LOCKOUT_DURATION_MS * 2);                final int children = client.getChildren().forPath(ChaosMonkeyCnxnFactory.CHAOS_ZNODE).size();        Assert.assertEquals(children, 0, "Still " + children + " znodes under " + ChaosMonkeyCnxnFactory.CHAOS_ZNODE + " lock");    } finally {        client.close();    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    log.info("Receive event {}", event.toString());    if (event.getResultCode() == KeeperException.Code.CONNECTIONLOSS.intValue()) {        latch.countDown();    }}
2689dd89a7ef425da0d0796674d50029436fd426ad96b7eba8ed047a066bec68
testId
public void testId() throws Exception
{    LeaderSelector selector = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                latch.countDown();                Thread.currentThread().join();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        selector = new LeaderSelector(client, "/ls", listener);        selector.setId("A is A");        selector.start();        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        Participant leader = selector.getLeader();        Assert.assertTrue(leader.isLeader());        Assert.assertEquals(leader.getId(), "A is A");        Collection<Participant> participants = selector.getParticipants();        Assert.assertEquals(participants.size(), 1);        Assert.assertEquals(participants.iterator().next().getId(), "A is A");        Assert.assertEquals(participants.iterator().next().getId(), selector.getId());    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
572980c734fcdd22464cc98d1931013f84abfc71246389b062e7e113e357572e
takeLeadership
public void takeLeadership(CuratorFramework client) throws Exception
{    latch.countDown();    Thread.currentThread().join();}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    final int SELECTOR_QTY = 10;    List<LeaderSelector> selectors = Lists.newArrayList();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final CountDownLatch leaderLatch = new CountDownLatch(1);        final CountDownLatch workingLatch = new CountDownLatch(SELECTOR_QTY);        LeaderSelectorListener listener = new LeaderSelectorListener() {            @Override            public void takeLeadership(CuratorFramework client) throws Exception {                leaderLatch.countDown();                Thread.currentThread().join();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        for (int i = 0; i < SELECTOR_QTY; ++i) {            LeaderSelector selector = new LeaderSelector(client, "/ls", listener) {                @Override                void doWork() throws Exception {                    workingLatch.countDown();                    super.doWork();                }            };            selector.setId(Integer.toString(i));            selectors.add(selector);        }        for (LeaderSelector selector : selectors) {            selector.start();        }        Assert.assertTrue(leaderLatch.await(10, TimeUnit.SECONDS));        Assert.assertTrue(workingLatch.await(10, TimeUnit.SECONDS));                Thread.sleep(1000);        Collection<Participant> participants = selectors.get(0).getParticipants();        for (int i = 1; i < selectors.size(); ++i) {            Assert.assertEquals(participants, selectors.get(i).getParticipants());        }        Set<String> ids = Sets.newHashSet();        int leaderCount = 0;        for (Participant participant : participants) {            if (participant.isLeader()) {                ++leaderCount;            }            Assert.assertFalse(ids.contains(participant.getId()));            ids.add(participant.getId());        }        Assert.assertEquals(leaderCount, 1);        Set<String> expectedIds = Sets.newHashSet();        for (int i = 0; i < SELECTOR_QTY; ++i) {            expectedIds.add(Integer.toString(i));        }        Assert.assertEquals(expectedIds, ids);    } finally {        for (LeaderSelector selector : selectors) {            CloseableUtils.closeQuietly(selector);        }        CloseableUtils.closeQuietly(client);    }}
572980c734fcdd22464cc98d1931013f84abfc71246389b062e7e113e357572e
takeLeadership
public void takeLeadership(CuratorFramework client) throws Exception
{    leaderLatch.countDown();    Thread.currentThread().join();}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
3d9630e49e039b490dece26c5d4a508f269fa7ac3149d590725076afdc8ce37d
doWork
 void doWork() throws Exception
{    workingLatch.countDown();    super.doWork();}
ced3637227837bc8935023b279f6d11e541ba2dd6bbaff26ba3afa81b2fd1240
test
public void test() throws Exception
{    Timing timing = new Timing();    LeaderSelector leaderSelector = null;    CuratorFramework client = CuratorFrameworkFactory.builder().retryPolicy(new ExponentialBackoffRetry(100, 3)).connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).build();    try {        client.start();        MyLeaderSelectorListener listener = new MyLeaderSelectorListener();        ExecutorService executorPool = Executors.newFixedThreadPool(20);        leaderSelector = new LeaderSelector(client, "/test", threadFactory, executorPool, listener);        leaderSelector.autoRequeue();        leaderSelector.start();        timing.sleepABit();        Assert.assertEquals(listener.getLeaderCount(), 1);    } finally {        CloseableUtils.closeQuietly(leaderSelector);        CloseableUtils.closeQuietly(client);    }}
ed22e117c96197f63c8ac75d59c84a6f58000c9855e62073a4e7f4495a79fd7f
getLeaderCount
public int getLeaderCount()
{    return leaderCount.get();}
b9507395d5fd5bec8b3ce94935b7896b16e34de788db29440e3953b2e28dd4a2
takeLeadership
public void takeLeadership(CuratorFramework curatorFramework) throws Exception
{    ourThread = Thread.currentThread();    try {        leaderCount.incrementAndGet();        while (!Thread.currentThread().isInterrupted()) {            Thread.sleep(1000);        }    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    } finally {        leaderCount.decrementAndGet();    }}
44a89b0956c73905bda78d9d80661cb244325eac2a246eb9f259fce50749cabf
stateChanged
public void stateChanged(CuratorFramework curatorFramework, ConnectionState newState)
{    if ((newState == ConnectionState.LOST) || (newState == ConnectionState.SUSPENDED)) {        if (ourThread != null) {            ourThread.interrupt();        }    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    shouldRun = false;}
11aacd89f6961bea2144f3d02a70bfbc037f1e7e00e6e56eac46c219741df3c4
hasAcquired
 boolean hasAcquired()
{    return hasAcquired;}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    hasAcquired = false;}
92c36a1a42485220dbc1fc03a5bb2f5b4af726304d880903a319078a49d914e1
getActiveClient
 static SemaphoreClient getActiveClient()
{    return activeClient.get();}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    shouldRun = true;    client.getConnectionStateListenable().addListener(this);    try {        while (shouldRun) {            try {                acquireAndRun();            } catch (InterruptedException e) {                Thread.currentThread().interrupt();                                throw e;            } catch (Exception e) {                Thread.sleep(CLIENT_EXCEPTION_HANDLER_SLEEP_TIME_SECS * 1000L);            }        }    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    } finally {        CloseableUtils.closeQuietly(client);    }    return null;}
2925c00f23c715791176653645f08d5c935f38bcc8ce5b9d8725101e697ee3b9
acquireAndRun
private void acquireAndRun() throws Exception
{    InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, semaphorePath, MAX_SEMAPHORE_LEASES);    Lease lease = semaphore.acquire();    try {        hasAcquired = true;        if (activeClient.compareAndSet(null, this)) {            throw new Exception("Multiple acquirers");        }        try {            while (hasAcquired && shouldRun) {                operation.call();            }        } finally {            if (activeClient.compareAndSet(this, null)) {                                throw new Exception("Bad release");            }        }    } finally {        semaphore.returnLease(lease);    }}
4fd37dc94bf74a67614d85ff079dcd66338a4d23a5fe97bd9ddd2761020efe08
await
 synchronized void await() throws InterruptedException
{    while (available == 0) {        wait();    }    --available;    notifyAll();}
5b8a77a672e59f9715d6a602eda26eac3ebb305390a4cfef7a504b193795844a
countDown
 synchronized void countDown(int qty)
{    available += qty;    notifyAll();}
c856787a9234394d4726178730459c5705bb5ce3d7268e20890fdf8aeccd7790
testMaxChildren
public void testMaxChildren() throws Exception
{    server.close();    final int LARGE_QTY = 10000;    System.setProperty("jute.maxbuffer", "" + LARGE_QTY);    server = new TestingServer();    try {        Timing timing = new Timing();        ChildReaper reaper = null;        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));        try {            client.start();            for (int i = 0; i < LARGE_QTY; ++i) {                if ((i % 1000) == 0) {                    System.out.println(i);                }                client.create().creatingParentsIfNeeded().forPath("/big/node-" + i);            }            try {                client.getChildren().forPath("/big");                Assert.fail("Should have been a connection loss");            } catch (KeeperException.ConnectionLossException e) {                        }            final CountDownLatch latch = new CountDownLatch(1);            reaper = new ChildReaper(client, "/big", Reaper.Mode.REAP_UNTIL_DELETE, 1) {                @Override                protected void warnMaxChildren(String path, Stat stat) {                    latch.countDown();                    super.warnMaxChildren(path, stat);                }            };            reaper.setMaxChildren(100);            reaper.start();            Assert.assertTrue(timing.awaitLatch(latch));        } finally {            CloseableUtils.closeQuietly(reaper);            CloseableUtils.closeQuietly(client);        }    } finally {        System.clearProperty("jute.maxbuffer");    }}
b2d3fe2ef189346bd0fb917b0edb79d2b9756abbf21bf1f506e5275adf58097c
warnMaxChildren
protected void warnMaxChildren(String path, Stat stat)
{    latch.countDown();    super.warnMaxChildren(path, stat);}
62a981cd55b95a471fbea864369c294f23b9c98897a4ff9dd334a6b3e9b241ff
testLargeNodes
public void testLargeNodes() throws Exception
{    server.close();    final int LARGE_QTY = 10000;    final int SMALL_QTY = 100;    System.setProperty("jute.maxbuffer", "" + LARGE_QTY);    server = new TestingServer();    try {        Timing timing = new Timing();        ChildReaper reaper = null;        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));        try {            client.start();            for (int i = 0; i < LARGE_QTY; ++i) {                if ((i % 1000) == 0) {                    System.out.println(i);                }                client.create().creatingParentsIfNeeded().forPath("/big/node-" + i);                if (i < SMALL_QTY) {                    client.create().creatingParentsIfNeeded().forPath("/small/node-" + i);                }            }            reaper = new ChildReaper(client, "/foo", Reaper.Mode.REAP_UNTIL_DELETE, 1);            reaper.start();            reaper.addPath("/big");            reaper.addPath("/small");            int count = -1;            for (int i = 0; (i < 10) && (count != 0); ++i) {                timing.sleepABit();                count = client.checkExists().forPath("/small").getNumChildren();            }            Assert.assertEquals(count, 0);        } finally {            CloseableUtils.closeQuietly(reaper);            CloseableUtils.closeQuietly(client);        }    } finally {        System.clearProperty("jute.maxbuffer");    }}
7ef99a2a5e60fc38cd9a78ef348c52aa0effa5862fb621ae0c222c989d72f6f8
testSomeNodes
public void testSomeNodes() throws Exception
{    Timing timing = new Timing();    ChildReaper reaper = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        Random r = new Random();        int nonEmptyNodes = 0;        for (int i = 0; i < 10; ++i) {            client.create().creatingParentsIfNeeded().forPath("/test/" + Integer.toString(i));            if (r.nextBoolean()) {                client.create().forPath("/test/" + Integer.toString(i) + "/foo");                ++nonEmptyNodes;            }        }        reaper = new ChildReaper(client, "/test", Reaper.Mode.REAP_UNTIL_DELETE, 1);        reaper.start();        timing.forWaiting().sleepABit();        Stat stat = client.checkExists().forPath("/test");        Assert.assertEquals(stat.getNumChildren(), nonEmptyNodes);    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
7e6ef9a15f502c76aa39b9e99c40c2704757556d14668cef0634754950c971d9
testSimple
public void testSimple() throws Exception
{    Timing timing = new Timing();    ChildReaper reaper = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        for (int i = 0; i < 10; ++i) {            client.create().creatingParentsIfNeeded().forPath("/test/" + Integer.toString(i));        }        reaper = new ChildReaper(client, "/test", Reaper.Mode.REAP_UNTIL_DELETE, 1);        reaper.start();        timing.forWaiting().sleepABit();        Stat stat = client.checkExists().forPath("/test");        Assert.assertEquals(stat.getNumChildren(), 0);    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
9217700b623119c1f197f89e66a879c98102f49bfcbeaf2b1a3f8e1d8552b375
testLeaderElection
public void testLeaderElection() throws Exception
{    Timing timing = new Timing();    ChildReaper reaper = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    LeaderLatch otherLeader = null;    try {        client.start();        for (int i = 0; i < 10; ++i) {            client.create().creatingParentsIfNeeded().forPath("/test/" + Integer.toString(i));        }        otherLeader = new LeaderLatch(client, "/test-leader");        otherLeader.start();        otherLeader.await();        reaper = new ChildReaper(client, "/test", Reaper.Mode.REAP_UNTIL_DELETE, ChildReaper.newExecutorService(), 1, "/test-leader");        reaper.start();        timing.forWaiting().sleepABit();                Stat stat = client.checkExists().forPath("/test");        Assert.assertEquals(stat.getNumChildren(), 10);        CloseableUtils.closeQuietly(otherLeader);        timing.forWaiting().sleepABit();        stat = client.checkExists().forPath("/test");        Assert.assertEquals(stat.getNumChildren(), 0);    } finally {        CloseableUtils.closeQuietly(reaper);        if (otherLeader != null && otherLeader.getState() == LeaderLatch.State.STARTED) {            CloseableUtils.closeQuietly(otherLeader);        }        CloseableUtils.closeQuietly(client);    }}
a24c9d5ef744a4b77c10e10bedf31e0543641e1e7653ab5602312c91c1dfc17a
testMultiPath
public void testMultiPath() throws Exception
{    Timing timing = new Timing();    ChildReaper reaper = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        for (int i = 0; i < 10; ++i) {            client.create().creatingParentsIfNeeded().forPath("/test1/" + Integer.toString(i));            client.create().creatingParentsIfNeeded().forPath("/test2/" + Integer.toString(i));            client.create().creatingParentsIfNeeded().forPath("/test3/" + Integer.toString(i));        }        reaper = new ChildReaper(client, "/test2", Reaper.Mode.REAP_UNTIL_DELETE, 1);        reaper.start();        reaper.addPath("/test1");        timing.forWaiting().sleepABit();        Stat stat = client.checkExists().forPath("/test1");        Assert.assertEquals(stat.getNumChildren(), 0);        stat = client.checkExists().forPath("/test2");        Assert.assertEquals(stat.getNumChildren(), 0);        stat = client.checkExists().forPath("/test3");        Assert.assertEquals(stat.getNumChildren(), 10);    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
59e0a32a550326f899edb7a0544309735f1d15d04012ece82e219b78969df6bf
testNamespace
public void testNamespace() throws Exception
{    Timing timing = new Timing();    ChildReaper reaper = null;    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new RetryOneTime(1)).namespace("foo").build();    try {        client.start();        for (int i = 0; i < 10; ++i) {            client.create().creatingParentsIfNeeded().forPath("/test/" + Integer.toString(i));        }        reaper = new ChildReaper(client, "/test", Reaper.Mode.REAP_UNTIL_DELETE, 1);        reaper.start();        timing.forWaiting().sleepABit();        Stat stat = client.checkExists().forPath("/test");        Assert.assertEquals(stat.getNumChildren(), 0);        stat = client.usingNamespace(null).checkExists().forPath("/foo/test");        Assert.assertNotNull(stat);        Assert.assertEquals(stat.getNumChildren(), 0);    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
7c6d2c86d7dc6449d777fb8d10a2f98a63a18a480cc43050915955c4e3d16963
makeLock
protected InterProcessLock makeLock(CuratorFramework client)
{    return new InterProcessMultiLock(client, Arrays.asList(LOCK_PATH_1, LOCK_PATH_2));}
2c22cab9e58a078c3f379d98c4ea313e337d5991817b07bb23e282df46de2edd
testSomeReleasesFail
public void testSomeReleasesFail() throws IOException
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        InterProcessLock goodLock = new InterProcessMutex(client, LOCK_PATH_1);        final InterProcessLock otherGoodLock = new InterProcessMutex(client, LOCK_PATH_2);        InterProcessLock badLock = new InterProcessLock() {            @Override            public void acquire() throws Exception {                otherGoodLock.acquire();            }            @Override            public boolean acquire(long time, TimeUnit unit) throws Exception {                return otherGoodLock.acquire(time, unit);            }            @Override            public void release() throws Exception {                throw new Exception("foo");            }            @Override            public boolean isAcquiredInThisProcess() {                return otherGoodLock.isAcquiredInThisProcess();            }        };        InterProcessMultiLock lock = new InterProcessMultiLock(Arrays.asList(goodLock, badLock));        try {            lock.acquire();            lock.release();            Assert.fail();        } catch (Exception e) {                }        Assert.assertFalse(goodLock.isAcquiredInThisProcess());        Assert.assertTrue(otherGoodLock.isAcquiredInThisProcess());    } finally {        TestCleanState.closeAndTestClean(client);    }}
6ed01f514324c2abdcf4abfde4f82ec6a096b3dc9765c28e667f9ae924b4ecba
acquire
public void acquire() throws Exception
{    otherGoodLock.acquire();}
e84db03b70d95fa516f1561b83f3738c78a129a52a8adede3d11a5b2bbfd3a21
acquire
public boolean acquire(long time, TimeUnit unit) throws Exception
{    return otherGoodLock.acquire(time, unit);}
416a94a1896246da1af92845d0098abfbff6e67323e4afe5a7de2f1dccecf83a
release
public void release() throws Exception
{    throw new Exception("foo");}
745d135b8331357b385fbaa7e0423401f2ab75f33e409e679d1ef190a299a7e1
isAcquiredInThisProcess
public boolean isAcquiredInThisProcess()
{    return otherGoodLock.isAcquiredInThisProcess();}
5ff73cec24d60cac11557b5ddc00358d9827a5eaae5bd54fe47728aca7c5313b
testSomeLocksFailToLock
public void testSomeLocksFailToLock() throws IOException
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final AtomicBoolean goodLockWasLocked = new AtomicBoolean(false);        final InterProcessLock goodLock = new InterProcessMutex(client, LOCK_PATH_1);        InterProcessLock badLock = new InterProcessLock() {            @Override            public void acquire() throws Exception {                if (goodLock.isAcquiredInThisProcess()) {                    goodLockWasLocked.set(true);                }                throw new Exception("foo");            }            @Override            public boolean acquire(long time, TimeUnit unit) throws Exception {                throw new Exception("foo");            }            @Override            public void release() throws Exception {                throw new Exception("foo");            }            @Override            public boolean isAcquiredInThisProcess() {                return false;            }        };        InterProcessMultiLock lock = new InterProcessMultiLock(Arrays.asList(goodLock, badLock));        try {            lock.acquire();            Assert.fail();        } catch (Exception e) {                }        Assert.assertFalse(goodLock.isAcquiredInThisProcess());        Assert.assertTrue(goodLockWasLocked.get());    } finally {        TestCleanState.closeAndTestClean(client);    }}
6ed01f514324c2abdcf4abfde4f82ec6a096b3dc9765c28e667f9ae924b4ecba
acquire
public void acquire() throws Exception
{    if (goodLock.isAcquiredInThisProcess()) {        goodLockWasLocked.set(true);    }    throw new Exception("foo");}
e84db03b70d95fa516f1561b83f3738c78a129a52a8adede3d11a5b2bbfd3a21
acquire
public boolean acquire(long time, TimeUnit unit) throws Exception
{    throw new Exception("foo");}
416a94a1896246da1af92845d0098abfbff6e67323e4afe5a7de2f1dccecf83a
release
public void release() throws Exception
{    throw new Exception("foo");}
745d135b8331357b385fbaa7e0423401f2ab75f33e409e679d1ef190a299a7e1
isAcquiredInThisProcess
public boolean isAcquiredInThisProcess()
{    return false;}
7c6d2c86d7dc6449d777fb8d10a2f98a63a18a480cc43050915955c4e3d16963
makeLock
protected InterProcessLock makeLock(CuratorFramework client)
{    return new InterProcessMutex(client, LOCK_PATH);}
e3b5422b750a6946f6cff4c879edffc5eef6f7ccc8be385b29911e06164d331e
testWithSchema
public void testWithSchema() throws Exception
{    Schema schemaRoot = Schema.builderForRecipeParent("/foo").name("root").build();    Schema schemaLocks = Schema.builderForRecipe("/foo").name("locks").build();    SchemaSet schemaSet = new SchemaSet(Lists.newArrayList(schemaRoot, schemaLocks), false);    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).schemaSet(schemaSet).build();    try {        client.start();        InterProcessMutex lock = new InterProcessMutex(client, "/foo");        lock.acquire();        lock.release();    } finally {        CloseableUtils.closeQuietly(client);    }}
2216d610c607c2d5205ca61febcd8cb8e7c62c7efd0c16e0fadc9e539ccdca10
testRevoking
public void testRevoking() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final InterProcessMutex lock = new InterProcessMutex(client, LOCK_PATH);        ExecutorService executorService = Executors.newCachedThreadPool();        final CountDownLatch revokeLatch = new CountDownLatch(1);        final CountDownLatch lockLatch = new CountDownLatch(1);        Future<Void> f1 = executorService.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                RevocationListener<InterProcessMutex> listener = new RevocationListener<InterProcessMutex>() {                    @Override                    public void revocationRequested(InterProcessMutex lock) {                        revokeLatch.countDown();                    }                };                lock.makeRevocable(listener);                lock.acquire();                lockLatch.countDown();                revokeLatch.await();                lock.release();                return null;            }        });        Future<Void> f2 = executorService.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                Assert.assertTrue(lockLatch.await(10, TimeUnit.SECONDS));                Collection<String> nodes = lock.getParticipantNodes();                Assert.assertEquals(nodes.size(), 1);                Revoker.attemptRevoke(client, nodes.iterator().next());                InterProcessMutex l2 = new InterProcessMutex(client, LOCK_PATH);                Assert.assertTrue(l2.acquire(5, TimeUnit.SECONDS));                l2.release();                return null;            }        });        f2.get();        f1.get();    } finally {        TestCleanState.closeAndTestClean(client);    }}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    RevocationListener<InterProcessMutex> listener = new RevocationListener<InterProcessMutex>() {        @Override        public void revocationRequested(InterProcessMutex lock) {            revokeLatch.countDown();        }    };    lock.makeRevocable(listener);    lock.acquire();    lockLatch.countDown();    revokeLatch.await();    lock.release();    return null;}
b9e37c63b46c88b4a9d9450591b31ab7d86401524d7140586a98a71be8c0eb70
revocationRequested
public void revocationRequested(InterProcessMutex lock)
{    revokeLatch.countDown();}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    Assert.assertTrue(lockLatch.await(10, TimeUnit.SECONDS));    Collection<String> nodes = lock.getParticipantNodes();    Assert.assertEquals(nodes.size(), 1);    Revoker.attemptRevoke(client, nodes.iterator().next());    InterProcessMutex l2 = new InterProcessMutex(client, LOCK_PATH);    Assert.assertTrue(l2.acquire(5, TimeUnit.SECONDS));    l2.release();    return null;}
dffcaabe061bcab378c69bea0e8c29506508cdd0ee549b1312d2fed56e69de88
testPersistentLock
public void testPersistentLock() throws Exception
{    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final InterProcessMutex lock = new InterProcessMutex(client, LOCK_PATH, new StandardLockInternalsDriver() {            @Override            public String createsTheLock(CuratorFramework client, String path, byte[] lockNodeBytes) throws Exception {                String ourPath;                if (lockNodeBytes != null) {                    ourPath = client.create().creatingParentsIfNeeded().withProtection().withMode(CreateMode.PERSISTENT).forPath(path, lockNodeBytes);                } else {                    ourPath = client.create().creatingParentsIfNeeded().withProtection().withMode(CreateMode.PERSISTENT).forPath(path);                }                return ourPath;            }        });                lock.acquire(10, TimeUnit.SECONDS);        Assert.assertTrue(lock.isAcquiredInThisProcess());                Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        Assert.assertNotNull(client.checkExists().forPath(LOCK_PATH));                String actualLockPath = lock.getLockPath();        lock.release();        Assert.assertNull(client.checkExists().forPath(actualLockPath));    } finally {        TestCleanState.closeAndTestClean(client);    }}
506f093807b1e716e8c815826020fe70fc150d32d4c5dfb49b6facdacb32c4bf
createsTheLock
public String createsTheLock(CuratorFramework client, String path, byte[] lockNodeBytes) throws Exception
{    String ourPath;    if (lockNodeBytes != null) {        ourPath = client.create().creatingParentsIfNeeded().withProtection().withMode(CreateMode.PERSISTENT).forPath(path, lockNodeBytes);    } else {        ourPath = client.create().creatingParentsIfNeeded().withProtection().withMode(CreateMode.PERSISTENT).forPath(path);    }    return ourPath;}
23f8cf827a0136bbc37cfe9a50ddf6c2835dd03acdce174de0bdada2478c0744
testLocker
public void testLocker() throws Exception
{    final Timing timing = new Timing();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));    try {        client.start();        InterProcessLock lock = makeLock(client);        try (Locker locker = new Locker(lock, timing.milliseconds(), TimeUnit.MILLISECONDS)) {            Assert.assertTrue(lock.isAcquiredInThisProcess());        }        Assert.assertFalse(lock.isAcquiredInThisProcess());    } finally {        CloseableUtils.closeQuietly(client);    }}
c222102d251957ed2faacb3529a94eaa59567be8d80007794599e643831f16f8
testWaitingProcessKilledServer
public void testWaitingProcessKilledServer() throws Exception
{    final Timing timing = new Timing();    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));    try {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (!newState.isConnected()) {                    latch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        final AtomicBoolean isFirst = new AtomicBoolean(true);        final Object result = new Object();        ExecutorCompletionService<Object> service = new ExecutorCompletionService<Object>(Executors.newFixedThreadPool(2));        for (int i = 0; i < 2; ++i) {            service.submit(new Callable<Object>() {                @Override                public Object call() throws Exception {                    InterProcessLock lock = makeLock(client);                    lock.acquire();                    try {                        if (isFirst.compareAndSet(true, false)) {                            timing.sleepABit();                            server.stop();                            Assert.assertTrue(timing.forWaiting().awaitLatch(latch));                            server.restart();                        }                    } finally {                        try {                            lock.release();                        } catch (KeeperException.SessionExpiredException dummy) {                                                }                    }                    return result;                }            });        }        for (int i = 0; i < 2; ++i) {            Assert.assertEquals(service.take().get(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS), result);        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (!newState.isConnected()) {        latch.countDown();    }}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    InterProcessLock lock = makeLock(client);    lock.acquire();    try {        if (isFirst.compareAndSet(true, false)) {            timing.sleepABit();            server.stop();            Assert.assertTrue(timing.forWaiting().awaitLatch(latch));            server.restart();        }    } finally {        try {            lock.release();        } catch (KeeperException.SessionExpiredException dummy) {                }    }    return result;}
936fa9edcb8fd2ba6b5b9ef1ce09b39676da41bf85aa3cbdd99e3a1d444edcde
testKilledSession
public void testKilledSession() throws Exception
{    final Timing2 timing = new Timing2();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));    client.start();    try {        final InterProcessLock mutex1 = makeLock(client);        final InterProcessLock mutex2 = makeLock(client);        final Semaphore semaphore = new Semaphore(0);        ExecutorCompletionService<Object> service = new ExecutorCompletionService<Object>(Executors.newFixedThreadPool(2));        service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                mutex1.acquire();                semaphore.release();                Thread.sleep(1000000);                return null;            }        });        service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                mutex2.acquire();                semaphore.release();                Thread.sleep(1000000);                return null;            }        });        Assert.assertTrue(timing.acquireSemaphore(semaphore, 1));        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        Assert.assertTrue(timing.forSessionSleep().acquireSemaphore(semaphore, 1));    } finally {        client.close();    }}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    mutex1.acquire();    semaphore.release();    Thread.sleep(1000000);    return null;}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    mutex2.acquire();    semaphore.release();    Thread.sleep(1000000);    return null;}
81adc7896eb368ea7567f76999b21b2904c4c3769f44e0f51f6a7a1580d670e7
testContainerCleanup
public void testContainerCleanup() throws Exception
{    if (!ZKPaths.hasContainerSupport()) {        System.out.println("ZooKeeper version does not support Containers. Skipping test");        return;    }    server.close();    System.setProperty("znode.container.checkIntervalMs", "10");    try {        server = new TestingServer();        final int THREAD_QTY = 10;        ExecutorService service = null;        final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(100, 3));        try {            client.start();            List<Future<Object>> threads = Lists.newArrayList();            service = Executors.newCachedThreadPool();            for (int i = 0; i < THREAD_QTY; ++i) {                Future<Object> t = service.submit(new Callable<Object>() {                    @Override                    public Object call() throws Exception {                        InterProcessLock lock = makeLock(client);                        lock.acquire();                        try {                            Thread.sleep(10);                        } finally {                            lock.release();                        }                        return null;                    }                });                threads.add(t);            }            for (Future<Object> t : threads) {                t.get();            }            new Timing().sleepABit();            Assert.assertNull(client.checkExists().forPath(LOCK_BASE_PATH));        } finally {            if (service != null) {                service.shutdownNow();            }            CloseableUtils.closeQuietly(client);        }    } finally {        System.clearProperty("znode.container.checkIntervalMs");    }}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    InterProcessLock lock = makeLock(client);    lock.acquire();    try {        Thread.sleep(10);    } finally {        lock.release();    }    return null;}
b7fe4c4498bd40571d4924cef6afaf6f3e4e688754f5b9e2a6c8bef2ea59ce9d
testWithNamespace
public void testWithNamespace() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new ExponentialBackoffRetry(100, 3)).namespace("test").build();    client.start();    try {        InterProcessLock mutex = makeLock(client);        mutex.acquire(10, TimeUnit.SECONDS);        Thread.sleep(100);        mutex.release();    } finally {        TestCleanState.closeAndTestClean(client);    }}
6791b2a71edec5704181ffed3f59d11f3c819836fe637145cc0bd5893d6673e7
testReentrantSingleLock
public void testReentrantSingleLock() throws Exception
{    final int THREAD_QTY = 10;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(100, 3));    client.start();    try {        final AtomicBoolean hasLock = new AtomicBoolean(false);        final AtomicBoolean isFirst = new AtomicBoolean(true);        final Semaphore semaphore = new Semaphore(1);        final InterProcessLock mutex = makeLock(client);        List<Future<Object>> threads = Lists.newArrayList();        ExecutorService service = Executors.newCachedThreadPool();        for (int i = 0; i < THREAD_QTY; ++i) {            Future<Object> t = service.submit(new Callable<Object>() {                @Override                public Object call() throws Exception {                    semaphore.acquire();                    mutex.acquire();                    Assert.assertTrue(hasLock.compareAndSet(false, true));                    try {                        if (isFirst.compareAndSet(true, false)) {                            semaphore.release(THREAD_QTY - 1);                            while (semaphore.availablePermits() > 0) {                                Thread.sleep(100);                            }                        } else {                            Thread.sleep(100);                        }                    } finally {                        mutex.release();                        hasLock.set(false);                    }                    return null;                }            });            threads.add(t);        }        for (Future<Object> t : threads) {            t.get();        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    semaphore.acquire();    mutex.acquire();    Assert.assertTrue(hasLock.compareAndSet(false, true));    try {        if (isFirst.compareAndSet(true, false)) {            semaphore.release(THREAD_QTY - 1);            while (semaphore.availablePermits() > 0) {                Thread.sleep(100);            }        } else {            Thread.sleep(100);        }    } finally {        mutex.release();        hasLock.set(false);    }    return null;}
36f971cb710070b9cab7065886b2f93d29b2b5713f9d617c81ce5452b9abbdb7
testReentrant2Threads
public void testReentrant2Threads() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(100, 3));    client.start();    try {        waitLatchForBar = new CountDownLatch(1);        countLatchForBar = new CountDownLatch(1);        final InterProcessLock mutex = makeLock(client);        Executors.newSingleThreadExecutor().submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                Assert.assertTrue(countLatchForBar.await(10, TimeUnit.SECONDS));                try {                    mutex.acquire(10, TimeUnit.SECONDS);                    Assert.fail();                } catch (Exception e) {                                } finally {                    waitLatchForBar.countDown();                }                return null;            }        });        foo(mutex);        Assert.assertFalse(mutex.isAcquiredInThisProcess());    } finally {        TestCleanState.closeAndTestClean(client);    }}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    Assert.assertTrue(countLatchForBar.await(10, TimeUnit.SECONDS));    try {        mutex.acquire(10, TimeUnit.SECONDS);        Assert.fail();    } catch (Exception e) {        } finally {        waitLatchForBar.countDown();    }    return null;}
27a475b269e8dfd7d7ac298e0028a496134382a6cb15c8189ec9d4e831bfc222
testReentrant
public void testReentrant() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(100, 3));    client.start();    try {        InterProcessLock mutex = makeLock(client);        foo(mutex);        Assert.assertFalse(mutex.isAcquiredInThisProcess());    } finally {        TestCleanState.closeAndTestClean(client);    }}
3492ad2656bd7b5819f7d6bb6eb8da5bfa9e2030965dbed66c13f87687f9465a
foo
private void foo(InterProcessLock mutex) throws Exception
{    mutex.acquire(10, TimeUnit.SECONDS);    Assert.assertTrue(mutex.isAcquiredInThisProcess());    bar(mutex);    Assert.assertTrue(mutex.isAcquiredInThisProcess());    mutex.release();}
d7d7b3e13ae03bb8bc63f57c72499af7dcab789e42e2901afa79bb74fb70f9c7
bar
private void bar(InterProcessLock mutex) throws Exception
{    mutex.acquire(10, TimeUnit.SECONDS);    Assert.assertTrue(mutex.isAcquiredInThisProcess());    if (countLatchForBar != null) {        countLatchForBar.countDown();        waitLatchForBar.await(10, TimeUnit.SECONDS);    }    snafu(mutex);    Assert.assertTrue(mutex.isAcquiredInThisProcess());    mutex.release();}
4099f9b1b93bd2cebc1de61a6d7aae5e222b24e7985ece0876265d991a0abc53
snafu
private void snafu(InterProcessLock mutex) throws Exception
{    mutex.acquire(10, TimeUnit.SECONDS);    Assert.assertTrue(mutex.isAcquiredInThisProcess());    mutex.release();    Assert.assertTrue(mutex.isAcquiredInThisProcess());}
c5f40337bde16a8cba65ba14797b1575f717c7824b93b232a2f062ad4dd27f5f
test2Clients
public void test2Clients() throws Exception
{    CuratorFramework client1 = null;    CuratorFramework client2 = null;    try {        client1 = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(100, 3));        client2 = CuratorFrameworkFactory.newClient(server.getConnectString(), new ExponentialBackoffRetry(100, 3));        client1.start();        client2.start();        final InterProcessLock mutexForClient1 = makeLock(client1);        final InterProcessLock mutexForClient2 = makeLock(client2);        final CountDownLatch latchForClient1 = new CountDownLatch(1);        final CountDownLatch latchForClient2 = new CountDownLatch(1);        final CountDownLatch acquiredLatchForClient1 = new CountDownLatch(1);        final CountDownLatch acquiredLatchForClient2 = new CountDownLatch(1);        final AtomicReference<Exception> exceptionRef = new AtomicReference<Exception>();        ExecutorService service = Executors.newCachedThreadPool();        Future<Object> future1 = service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                try {                    mutexForClient1.acquire(10, TimeUnit.SECONDS);                    acquiredLatchForClient1.countDown();                    latchForClient1.await(10, TimeUnit.SECONDS);                    mutexForClient1.release();                } catch (Exception e) {                    exceptionRef.set(e);                }                return null;            }        });        Future<Object> future2 = service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                try {                    mutexForClient2.acquire(10, TimeUnit.SECONDS);                    acquiredLatchForClient2.countDown();                    latchForClient2.await(10, TimeUnit.SECONDS);                    mutexForClient2.release();                } catch (Exception e) {                    exceptionRef.set(e);                }                return null;            }        });        while (!mutexForClient1.isAcquiredInThisProcess() && !mutexForClient2.isAcquiredInThisProcess()) {            Thread.sleep(1000);            Assert.assertFalse(future1.isDone() && future2.isDone());        }        Assert.assertTrue(mutexForClient1.isAcquiredInThisProcess() != mutexForClient2.isAcquiredInThisProcess());        Thread.sleep(1000);        Assert.assertTrue(mutexForClient1.isAcquiredInThisProcess() || mutexForClient2.isAcquiredInThisProcess());        Assert.assertTrue(mutexForClient1.isAcquiredInThisProcess() != mutexForClient2.isAcquiredInThisProcess());        Exception exception = exceptionRef.get();        if (exception != null) {            throw exception;        }        if (mutexForClient1.isAcquiredInThisProcess()) {            latchForClient1.countDown();            Assert.assertTrue(acquiredLatchForClient2.await(10, TimeUnit.SECONDS));            Assert.assertTrue(mutexForClient2.isAcquiredInThisProcess());        } else {            latchForClient2.countDown();            Assert.assertTrue(acquiredLatchForClient1.await(10, TimeUnit.SECONDS));            Assert.assertTrue(mutexForClient1.isAcquiredInThisProcess());        }        future1.get();        future2.get();    } finally {        TestCleanState.closeAndTestClean(client1);        TestCleanState.closeAndTestClean(client2);    }}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    try {        mutexForClient1.acquire(10, TimeUnit.SECONDS);        acquiredLatchForClient1.countDown();        latchForClient1.await(10, TimeUnit.SECONDS);        mutexForClient1.release();    } catch (Exception e) {        exceptionRef.set(e);    }    return null;}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    try {        mutexForClient2.acquire(10, TimeUnit.SECONDS);        acquiredLatchForClient2.countDown();        latchForClient2.await(10, TimeUnit.SECONDS);        mutexForClient2.release();    } catch (Exception e) {        exceptionRef.set(e);    }    return null;}
b9753e7851c289b18c42838e0963de4c103eacedad5f08c274fa7927150f59e7
testGetParticipantNodes
public void testGetParticipantNodes() throws Exception
{    final int READERS = 20;    final int WRITERS = 8;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final CountDownLatch latch = new CountDownLatch(READERS + WRITERS);        final CountDownLatch readLatch = new CountDownLatch(READERS);        final InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/lock");        final CountDownLatch exitLatch = new CountDownLatch(1);        ExecutorCompletionService<Void> service = new ExecutorCompletionService<Void>(Executors.newCachedThreadPool());        for (int i = 0; i < READERS; ++i) {            service.submit(new Callable<Void>() {                @Override                public Void call() throws Exception {                    lock.readLock().acquire();                    try {                        latch.countDown();                        readLatch.countDown();                        exitLatch.await();                    } finally {                        lock.readLock().release();                    }                    return null;                }            });        }        for (int i = 0; i < WRITERS; ++i) {            service.submit(new Callable<Void>() {                @Override                public Void call() throws Exception {                    Assert.assertTrue(readLatch.await(10, TimeUnit.SECONDS));                                        latch.countDown();                    lock.writeLock().acquire();                    try {                        exitLatch.await();                    } finally {                        lock.writeLock().release();                    }                    return null;                }            });        }        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        Collection<String> readers = lock.readLock().getParticipantNodes();        Collection<String> writers = lock.writeLock().getParticipantNodes();        Assert.assertEquals(readers.size(), READERS);        Assert.assertEquals(writers.size(), WRITERS);        exitLatch.countDown();        for (int i = 0; i < (READERS + WRITERS); ++i) {            service.take().get();        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    lock.readLock().acquire();    try {        latch.countDown();        readLatch.countDown();        exitLatch.await();    } finally {        lock.readLock().release();    }    return null;}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    Assert.assertTrue(readLatch.await(10, TimeUnit.SECONDS));        latch.countDown();    lock.writeLock().acquire();    try {        exitLatch.await();    } finally {        lock.writeLock().release();    }    return null;}
a702718af3965d5791275a0cebb5763beadb564c6abd44a0a5f1f78d565e3970
testThatUpgradingIsDisallowed
public void testThatUpgradingIsDisallowed() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/lock");        lock.readLock().acquire();        Assert.assertFalse(lock.writeLock().acquire(5, TimeUnit.SECONDS));        lock.readLock().release();    } finally {        TestCleanState.closeAndTestClean(client);    }}
e5e0e8fad17cb164ae940368bfe3c4a3206168e61c9d6dffc1350157a2be6714
testThatDowngradingRespectsThreads
public void testThatDowngradingRespectsThreads() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/lock");        ExecutorService t1 = Executors.newSingleThreadExecutor();        ExecutorService t2 = Executors.newSingleThreadExecutor();        final CountDownLatch latch = new CountDownLatch(1);        final CountDownLatch releaseLatch = new CountDownLatch(1);        Future<Object> f1 = t1.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                lock.writeLock().acquire();                latch.countDown();                try {                    releaseLatch.await();                } finally {                    lock.writeLock().release();                }                return null;            }        });        Future<Object> f2 = t2.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));                Assert.assertFalse(lock.readLock().acquire(5, TimeUnit.SECONDS));                return null;            }        });        f2.get();        releaseLatch.countDown();        f1.get();    } finally {        TestCleanState.closeAndTestClean(client);    }}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    lock.writeLock().acquire();    latch.countDown();    try {        releaseLatch.await();    } finally {        lock.writeLock().release();    }    return null;}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    Assert.assertFalse(lock.readLock().acquire(5, TimeUnit.SECONDS));    return null;}
db0ae9401be00dd8586fba53b1db17ce0b14fc047970902ac36a82b2faf32042
testDowngrading
public void testDowngrading() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/lock");        lock.writeLock().acquire();        Assert.assertTrue(lock.readLock().acquire(5, TimeUnit.SECONDS));        lock.writeLock().release();        lock.readLock().release();    } finally {        TestCleanState.closeAndTestClean(client);    }}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    final int CONCURRENCY = 8;    final int ITERATIONS = 100;    final Random random = new Random();    final AtomicInteger concurrentCount = new AtomicInteger(0);    final AtomicInteger maxConcurrentCount = new AtomicInteger(0);    final AtomicInteger writeCount = new AtomicInteger(0);    final AtomicInteger readCount = new AtomicInteger(0);    List<Future<Void>> futures = Lists.newArrayList();    ExecutorService service = Executors.newCachedThreadPool();    for (int i = 0; i < CONCURRENCY; ++i) {        Future<Void> future = service.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));                client.start();                try {                    InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/lock");                    for (int i = 0; i < ITERATIONS; ++i) {                        if (random.nextInt(100) < 10) {                            doLocking(lock.writeLock(), concurrentCount, maxConcurrentCount, random, 1);                            writeCount.incrementAndGet();                        } else {                            doLocking(lock.readLock(), concurrentCount, maxConcurrentCount, random, Integer.MAX_VALUE);                            readCount.incrementAndGet();                        }                    }                } finally {                    TestCleanState.closeAndTestClean(client);                }                return null;            }        });        futures.add(future);    }    for (Future<Void> future : futures) {        future.get();    }    System.out.println("Writes: " + writeCount.get() + " - Reads: " + readCount.get() + " - Max Reads: " + maxConcurrentCount.get());    Assert.assertTrue(writeCount.get() > 0);    Assert.assertTrue(readCount.get() > 0);    Assert.assertTrue(maxConcurrentCount.get() > 1);}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/lock");        for (int i = 0; i < ITERATIONS; ++i) {            if (random.nextInt(100) < 10) {                doLocking(lock.writeLock(), concurrentCount, maxConcurrentCount, random, 1);                writeCount.incrementAndGet();            } else {                doLocking(lock.readLock(), concurrentCount, maxConcurrentCount, random, Integer.MAX_VALUE);                readCount.incrementAndGet();            }        }    } finally {        TestCleanState.closeAndTestClean(client);    }    return null;}
cb2ac17d259e2c509ab62ffc9ee9dd605a9f4f99c7b52e167023de3a200b43f3
testSetNodeData
public void testSetNodeData() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        final byte[] nodeData = new byte[] { 1, 2, 3, 4 };        InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/lock", nodeData);                nodeData[0] = 5;        lock.writeLock().acquire();        List<String> children = client.getChildren().forPath("/lock");        Assert.assertEquals(1, children.size());        byte[] dataInZk = client.getData().forPath("/lock/" + children.get(0));        Assert.assertNotNull(dataInZk);        Assert.assertEquals(new byte[] { 1, 2, 3, 4 }, dataInZk);        lock.writeLock().release();    } finally {        TestCleanState.closeAndTestClean(client);    }}
7641beecaa49f6406255f83eac6b62ed31117fa8988f45526189bdae7411b356
doLocking
private void doLocking(InterProcessLock lock, AtomicInteger concurrentCount, AtomicInteger maxConcurrentCount, Random random, int maxAllowed) throws Exception
{    try {        Assert.assertTrue(lock.acquire(10, TimeUnit.SECONDS));        int localConcurrentCount;        synchronized (this) {            localConcurrentCount = concurrentCount.incrementAndGet();            if (localConcurrentCount > maxConcurrentCount.get()) {                maxConcurrentCount.set(localConcurrentCount);            }        }        Assert.assertTrue(localConcurrentCount <= maxAllowed, "" + localConcurrentCount);        Thread.sleep(random.nextInt(9) + 1);    } finally {        synchronized (this) {            concurrentCount.decrementAndGet();            lock.release();        }    }}
d9598594d0e6272e7fbeb01487be40fae8d79cb9e80ccd1b1a38cd2134a90868
testAcquireAfterLostServer
public void testAcquireAfterLostServer() throws Exception
{        final String SEMAPHORE_PATH = "/test";    final int MAX_SEMAPHORES = 1;    final int NUM_CLIENTS = 10;    ExecutorService executor = Executors.newFixedThreadPool(NUM_CLIENTS);    final Timing timing = new Timing();        final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.forWaiting().milliseconds(), timing.connection(), new RetryOneTime(1));    try {        client.start();                InterProcessSemaphoreV2.debugAcquireLatch = new CountDownLatch(1);                InterProcessSemaphoreV2.debugFailedGetChildrenLatch = new CountDownLatch(1);        final CountDownLatch isReadyLatch = new CountDownLatch(NUM_CLIENTS);        final BlockingQueue<Boolean> acquiredQueue = Queues.newLinkedBlockingQueue();        Runnable runner = new Runnable() {            @Override            public void run() {                while (!Thread.currentThread().isInterrupted()) {                    InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, SEMAPHORE_PATH, MAX_SEMAPHORES);                    Lease lease = null;                    try {                        isReadyLatch.countDown();                        lease = semaphore.acquire();                        acquiredQueue.add(true);                        timing.sleepABit();                    } catch (InterruptedException e) {                        Thread.currentThread().interrupt();                        break;                    } catch (KeeperException e) {                        try {                            timing.sleepABit();                        } catch (InterruptedException e2) {                            Thread.currentThread().interrupt();                            break;                        }                    } catch (Exception ignore) {                                        } finally {                        if (lease != null) {                            semaphore.returnLease(lease);                        }                    }                }            }        };        for (int i = 0; i < NUM_CLIENTS; ++i) {            executor.execute(runner);        }        Assert.assertTrue(timing.awaitLatch(isReadyLatch));        timing.sleepABit();        final CountDownLatch lostLatch = new CountDownLatch(1);        final CountDownLatch restartedLatch = new CountDownLatch(1);        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    lostLatch.countDown();                } else if (newState == ConnectionState.RECONNECTED) {                    restartedLatch.countDown();                }            }        });        server.stop();        Assert.assertTrue(timing.multiple(1.25).awaitLatch(lostLatch));                InterProcessSemaphoreV2.debugAcquireLatch.countDown();                Assert.assertTrue(timing.awaitLatch(InterProcessSemaphoreV2.debugFailedGetChildrenLatch));        server.restart();        Assert.assertTrue(timing.awaitLatch(restartedLatch));        for (int i = 0; i < NUM_CLIENTS; ++i) {                        Boolean polled = acquiredQueue.poll(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS);            if ((polled == null) || !polled) {                Assert.fail("Semaphores not reacquired after restart");            }        }    } finally {        executor.shutdownNow();        CloseableUtils.closeQuietly(client);    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    while (!Thread.currentThread().isInterrupted()) {        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, SEMAPHORE_PATH, MAX_SEMAPHORES);        Lease lease = null;        try {            isReadyLatch.countDown();            lease = semaphore.acquire();            acquiredQueue.add(true);            timing.sleepABit();        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            break;        } catch (KeeperException e) {            try {                timing.sleepABit();            } catch (InterruptedException e2) {                Thread.currentThread().interrupt();                break;            }        } catch (Exception ignore) {                } finally {            if (lease != null) {                semaphore.returnLease(lease);            }        }    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        lostLatch.countDown();    } else if (newState == ConnectionState.RECONNECTED) {        restartedLatch.countDown();    }}
82fbe507b46b7ada52269e7f0fe7e9acd41f10a0d03945732c8147fd2d8c58e5
testThreadedLeaseIncrease
public void testThreadedLeaseIncrease() throws Exception
{    final Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final SharedCount count = new SharedCount(client, "/foo/count", 1);        count.start();        final InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", count);        ExecutorService service = Executors.newCachedThreadPool();        final CountDownLatch latch1 = new CountDownLatch(1);        final CountDownLatch latch2 = new CountDownLatch(1);        Future<Object> future1 = service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                Lease lease = semaphore.acquire(timing.seconds(), TimeUnit.SECONDS);                Assert.assertNotNull(lease);                latch1.countDown();                lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);                Assert.assertNotNull(lease);                latch2.countDown();                return null;            }        });        Future<Object> future2 = service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                Assert.assertTrue(latch1.await(timing.forWaiting().seconds(), TimeUnit.SECONDS));                                timing.sleepABit();                Assert.assertTrue(count.trySetCount(2));                                timing.sleepABit();                Assert.assertTrue(latch2.await(0, TimeUnit.SECONDS));                return null;            }        });        future1.get();        future2.get();        count.close();    } finally {        TestCleanState.closeAndTestClean(client);    }}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    Lease lease = semaphore.acquire(timing.seconds(), TimeUnit.SECONDS);    Assert.assertNotNull(lease);    latch1.countDown();    lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);    Assert.assertNotNull(lease);    latch2.countDown();    return null;}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    Assert.assertTrue(latch1.await(timing.forWaiting().seconds(), TimeUnit.SECONDS));        timing.sleepABit();    Assert.assertTrue(count.trySetCount(2));        timing.sleepABit();    Assert.assertTrue(latch2.await(0, TimeUnit.SECONDS));    return null;}
9a412bb2a445ce4d188d6f5abe459ef5852bb06ae2c40c1986983a8dc102860f
testClientClose
public void testClientClose() throws Exception
{    final Timing timing = new Timing();    CuratorFramework client1 = null;    CuratorFramework client2 = null;    InterProcessSemaphoreV2 semaphore1;    InterProcessSemaphoreV2 semaphore2;    try {        client1 = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client2 = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client1.start();        client2.start();        semaphore1 = new InterProcessSemaphoreV2(client1, "/test", 1);        semaphore2 = new InterProcessSemaphoreV2(client2, "/test", 1);        Lease lease = semaphore2.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertNotNull(lease);        lease.close();        lease = semaphore1.acquire(10, TimeUnit.SECONDS);        Assert.assertNotNull(lease);                client1.close();        client1 = null;        Assert.assertNotNull(semaphore2.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        TestCleanState.closeAndTestClean(client1);        TestCleanState.closeAndTestClean(client2);    }}
9d7276ecf91c21078d99ae4f7190f9fa8141ff9ab68ddf5199fe2817a8885db1
testMaxPerSession
public void testMaxPerSession() throws Exception
{    final int CLIENT_QTY = 10;    final int LOOP_QTY = 100;    final Random random = new Random();    final int SESSION_MAX = random.nextInt(75) + 25;    final Timing timing = new Timing();    List<Future<Object>> futures = Lists.newArrayList();    ExecutorService service = Executors.newCachedThreadPool();    final Counter counter = new Counter();    final AtomicInteger available = new AtomicInteger(SESSION_MAX);    for (int i = 0; i < CLIENT_QTY; ++i) {        futures.add(service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));                client.start();                try {                    InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", SESSION_MAX);                    for (int i = 0; i < LOOP_QTY; ++i) {                        long start = System.currentTimeMillis();                        int thisQty;                        synchronized (available) {                            if ((System.currentTimeMillis() - start) > 10000) {                                throw new TimeoutException();                            }                            while (available.get() == 0) {                                available.wait(timing.forWaiting().milliseconds());                            }                            thisQty = (available.get() > 1) ? (random.nextInt(available.get()) + 1) : 1;                            available.addAndGet(-1 * thisQty);                            Assert.assertTrue(available.get() >= 0);                        }                        Collection<Lease> leases = semaphore.acquire(thisQty, timing.forWaiting().seconds(), TimeUnit.SECONDS);                        Assert.assertNotNull(leases);                        try {                            synchronized (counter) {                                counter.currentCount += thisQty;                                if (counter.currentCount > counter.maxCount) {                                    counter.maxCount = counter.currentCount;                                }                            }                            Thread.sleep(random.nextInt(25));                        } finally {                            synchronized (counter) {                                counter.currentCount -= thisQty;                            }                            semaphore.returnAll(leases);                            synchronized (available) {                                available.addAndGet(thisQty);                                available.notifyAll();                            }                        }                    }                } finally {                    TestCleanState.closeAndTestClean(client);                }                return null;            }        }));    }    for (Future<Object> f : futures) {        f.get();    }    synchronized (counter) {        Assert.assertTrue(counter.currentCount == 0);        Assert.assertTrue(counter.maxCount > 0);        Assert.assertTrue(counter.maxCount <= SESSION_MAX);        System.out.println(counter.maxCount);    }}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", SESSION_MAX);        for (int i = 0; i < LOOP_QTY; ++i) {            long start = System.currentTimeMillis();            int thisQty;            synchronized (available) {                if ((System.currentTimeMillis() - start) > 10000) {                    throw new TimeoutException();                }                while (available.get() == 0) {                    available.wait(timing.forWaiting().milliseconds());                }                thisQty = (available.get() > 1) ? (random.nextInt(available.get()) + 1) : 1;                available.addAndGet(-1 * thisQty);                Assert.assertTrue(available.get() >= 0);            }            Collection<Lease> leases = semaphore.acquire(thisQty, timing.forWaiting().seconds(), TimeUnit.SECONDS);            Assert.assertNotNull(leases);            try {                synchronized (counter) {                    counter.currentCount += thisQty;                    if (counter.currentCount > counter.maxCount) {                        counter.maxCount = counter.currentCount;                    }                }                Thread.sleep(random.nextInt(25));            } finally {                synchronized (counter) {                    counter.currentCount -= thisQty;                }                semaphore.returnAll(leases);                synchronized (available) {                    available.addAndGet(thisQty);                    available.notifyAll();                }            }        }    } finally {        TestCleanState.closeAndTestClean(client);    }    return null;}
586d49c474c130fa26b8d67b8cc01a7b58e75163f06e2f1df110561d58afed38
testRelease1AtATime
public void testRelease1AtATime() throws Exception
{    final Timing timing = new Timing();    final int CLIENT_QTY = 10;    final int MAX = CLIENT_QTY / 2;    final AtomicInteger maxLeases = new AtomicInteger(0);    final AtomicInteger activeQty = new AtomicInteger(0);    final AtomicInteger uses = new AtomicInteger(0);    List<Future<Object>> futures = Lists.newArrayList();    ExecutorService service = Executors.newFixedThreadPool(CLIENT_QTY);    for (int i = 0; i < CLIENT_QTY; ++i) {        Future<Object> f = service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));                client.start();                try {                    InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", MAX);                    Lease lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);                    Assert.assertNotNull(lease);                    uses.incrementAndGet();                    try {                        synchronized (maxLeases) {                            int qty = activeQty.incrementAndGet();                            if (qty > maxLeases.get()) {                                maxLeases.set(qty);                            }                        }                        timing.sleepABit();                    } finally {                        activeQty.decrementAndGet();                        lease.close();                    }                } finally {                    TestCleanState.closeAndTestClean(client);                }                return null;            }        });        futures.add(f);    }    for (Future<Object> f : futures) {        f.get();    }    Assert.assertEquals(uses.get(), CLIENT_QTY);    Assert.assertEquals(maxLeases.get(), MAX);}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", MAX);        Lease lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertNotNull(lease);        uses.incrementAndGet();        try {            synchronized (maxLeases) {                int qty = activeQty.incrementAndGet();                if (qty > maxLeases.get()) {                    maxLeases.set(qty);                }            }            timing.sleepABit();        } finally {            activeQty.decrementAndGet();            lease.close();        }    } finally {        TestCleanState.closeAndTestClean(client);    }    return null;}
53b4871ca474facc45d55bd01dd9a775e07aa63cee3490870d3445b8c2f9a138
testReleaseInChunks
public void testReleaseInChunks() throws Exception
{    final Timing timing = new Timing();    final int MAX_LEASES = 11;    final int THREADS = 100;    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final Stepper latch = new Stepper();        final Random random = new Random();        final Counter counter = new Counter();        ExecutorService service = Executors.newCachedThreadPool();        ExecutorCompletionService<Object> completionService = new ExecutorCompletionService<Object>(service);        for (int i = 0; i < THREADS; ++i) {            completionService.submit(new Callable<Object>() {                @Override                public Object call() throws Exception {                    InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", MAX_LEASES);                    Lease lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);                    if (lease == null) {                        throw new Exception("timed out");                    }                    try {                        synchronized (counter) {                            ++counter.currentCount;                            if (counter.currentCount > counter.maxCount) {                                counter.maxCount = counter.currentCount;                            }                            counter.notifyAll();                        }                        latch.await();                    } finally {                        synchronized (counter) {                            --counter.currentCount;                        }                        semaphore.returnLease(lease);                    }                    return null;                }            });        }        int remaining = THREADS;        while (remaining > 0) {            int times = Math.min(random.nextInt(5) + 1, remaining);            latch.countDown(times);            remaining -= times;            Thread.sleep(random.nextInt(100) + 1);        }        for (int i = 0; i < THREADS; ++i) {            completionService.take();        }        timing.sleepABit();        synchronized (counter) {            Assert.assertTrue(counter.currentCount == 0);            Assert.assertTrue(counter.maxCount > 0);            Assert.assertTrue(counter.maxCount <= MAX_LEASES);            System.out.println(counter.maxCount);        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", MAX_LEASES);    Lease lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);    if (lease == null) {        throw new Exception("timed out");    }    try {        synchronized (counter) {            ++counter.currentCount;            if (counter.currentCount > counter.maxCount) {                counter.maxCount = counter.currentCount;            }            counter.notifyAll();        }        latch.await();    } finally {        synchronized (counter) {            --counter.currentCount;        }        semaphore.returnLease(lease);    }    return null;}
0bdaa74ebb1a3a98f8aa86dd3d390ccc09f82a97341944a9ca00dba68397c63a
testThreads
public void testThreads() throws Exception
{    final int THREAD_QTY = 10;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", 1);        ExecutorService service = Executors.newFixedThreadPool(THREAD_QTY);        for (int i = 0; i < THREAD_QTY; ++i) {            service.submit(new Callable<Object>() {                @Override                public Object call() throws Exception {                    Lease lease = semaphore.acquire();                    try {                        Thread.sleep(1);                    } finally {                        lease.close();                    }                    return null;                }            });        }        service.shutdown();        Assert.assertTrue(service.awaitTermination(10, TimeUnit.SECONDS));    } finally {        TestCleanState.closeAndTestClean(client);    }}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    Lease lease = semaphore.acquire();    try {        Thread.sleep(1);    } finally {        lease.close();    }    return null;}
7e6ef9a15f502c76aa39b9e99c40c2704757556d14668cef0634754950c971d9
testSimple
public void testSimple() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", 1);        Assert.assertNotNull(semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS));        Assert.assertNull(semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        TestCleanState.closeAndTestClean(client);    }}
52461e743d94261a4ffef2a3463f39529386aff54785763d30cbeead789e6e11
testSimple2
public void testSimple2() throws Exception
{    final int MAX_LEASES = 3;    Timing timing = new Timing();    List<Lease> leases = Lists.newArrayList();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        for (int i = 0; i < MAX_LEASES; ++i) {            InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", MAX_LEASES);            Lease lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);            Assert.assertNotNull(lease);            leases.add(lease);        }        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", MAX_LEASES);        Lease lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertNull(lease);        leases.remove(0).close();        Assert.assertNotNull(semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        for (Lease l : leases) {            CloseableUtils.closeQuietly(l);        }        TestCleanState.closeAndTestClean(client);    }}
b9753e7851c289b18c42838e0963de4c103eacedad5f08c274fa7927150f59e7
testGetParticipantNodes
public void testGetParticipantNodes() throws Exception
{    final int LEASES = 3;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    List<Lease> leases = Lists.newArrayList();    client.start();    try {        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", LEASES);        for (int i = 0; i < LEASES; ++i) {            leases.add(semaphore.acquire());        }        Assert.assertEquals(semaphore.getParticipantNodes().size(), LEASES);    } finally {        for (Lease l : leases) {            CloseableUtils.closeQuietly(l);        }        TestCleanState.closeAndTestClean(client);    }}
2b6a4124a1e81ea9be23d22dc8e9bbe8926e739ac9ac2a02b9f16a2534beb4ee
testChildReaperCleansUpLockNodes
public void testChildReaperCleansUpLockNodes() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    ChildReaper childReaper = null;    try {        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test/lock", 1);        semaphore.returnLease(semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS));        Assert.assertTrue(client.getChildren().forPath("/test").size() > 0);        childReaper = new ChildReaper(client, "/test", Reaper.Mode.REAP_UNTIL_GONE, ChildReaper.newExecutorService(), 1, "/test-leader", InterProcessSemaphoreV2.LOCK_SCHEMA);        childReaper.start();        timing.forWaiting().sleepABit();        try {            List<String> children = client.getChildren().forPath("/test");            Assert.assertEquals(children.size(), 0, "All children of /test should have been reaped");        } catch (KeeperException.NoNodeException ok) {                }    } finally {        CloseableUtils.closeQuietly(childReaper);        CloseableUtils.closeQuietly(client);    }}
546937a4917429d32871457ae723ad6625d36d795c58fa5dd8afe9c079404723
testNoOrphanedNodes
public void testNoOrphanedNodes() throws Exception
{    final Timing timing = new Timing();    final ExecutorService executor = Executors.newFixedThreadPool(1);    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, "/test", 1);        Lease lease = semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertNotNull(lease);        final List<String> childNodes = client.getChildren().forPath("/test/leases");        Assert.assertEquals(childNodes.size(), 1);        final CountDownLatch nodeCreatedLatch = new CountDownLatch(1);        client.getChildren().usingWatcher(new CuratorWatcher() {            @Override            public void process(WatchedEvent event) throws Exception {                if (event.getType() == Watcher.Event.EventType.NodeCreated) {                    nodeCreatedLatch.countDown();                }            }        }).forPath("/test/leases");        final Future<Lease> leaseFuture = executor.submit(new Callable<Lease>() {            @Override            public Lease call() throws Exception {                return semaphore.acquire(timing.forWaiting().multiple(2).seconds(), TimeUnit.SECONDS);            }        });                timing.awaitLatch(nodeCreatedLatch);        String newNode = null;        for (String c : client.getChildren().forPath("/test/leases")) {            if (!childNodes.contains(c)) {                newNode = c;            }        }        Assert.assertNotNull(newNode);                client.delete().forPath("/test/leases/" + newNode);                lease.close();        lease = leaseFuture.get();        Assert.assertNotNull(lease);        lease.close();        Assert.assertEquals(client.getChildren().forPath("/test/leases").size(), 0);                Assert.assertNotNull(semaphore.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        executor.shutdownNow();        TestCleanState.closeAndTestClean(client);    }}
a4803fca4797306b4f772a40c997680043dc08b35469407056bd5b28cf26096b
process
public void process(WatchedEvent event) throws Exception
{    if (event.getType() == Watcher.Event.EventType.NodeCreated) {        nodeCreatedLatch.countDown();    }}
b128b8402c00066f11c07eac6411bcd26bfa151da9211fbbc884f6e02aab824a
call
public Lease call() throws Exception
{    return semaphore.acquire(timing.forWaiting().multiple(2).seconds(), TimeUnit.SECONDS);}
1a330dd7a08a8dfde1ce2f6af789e03cdc15aac8e9f77a71c7272af310d2cafc
testInterruptAcquire
public void testInterruptAcquire() throws Exception
{        final Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final InterProcessSemaphoreV2 s1 = new InterProcessSemaphoreV2(client, "/test", 1);        final InterProcessSemaphoreV2 s2 = new InterProcessSemaphoreV2(client, "/test", 1);        final InterProcessSemaphoreV2 s3 = new InterProcessSemaphoreV2(client, "/test", 1);        final CountDownLatch debugWaitLatch = s2.debugWaitLatch = new CountDownLatch(1);                Lease lease = s1.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertNotNull(lease);                Future<Object> handle = Executors.newSingleThreadExecutor().submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                s2.acquire();                return null;            }        });                Assert.assertTrue(timing.awaitLatch(debugWaitLatch));                handle.cancel(true);                timing.sleepABit();        Assert.assertEquals(client.getChildren().forPath("/test/leases").size(), 1);                s1.returnLease(lease);        Assert.assertNotNull(s3.acquire(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        TestCleanState.closeAndTestClean(client);    }}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    s2.acquire();    return null;}
aa16e365ab8ffd192335c5771ffaeedfa0fcde92c4612e67bd0f572225df263d
testKilledServerWithEnsembleProvider
public void testKilledServerWithEnsembleProvider() throws Exception
{    final int CLIENT_QTY = 10;    final Timing timing = new Timing();    final String PATH = "/foo/bar/lock";    ExecutorService executorService = Executors.newFixedThreadPool(CLIENT_QTY);    ExecutorCompletionService<Void> completionService = new ExecutorCompletionService<Void>(executorService);    TestingCluster cluster = new TestingCluster(3);    try {        cluster.start();        final AtomicReference<String> connectionString = new AtomicReference<String>(cluster.getConnectString());        final EnsembleProvider provider = new EnsembleProvider() {            @Override            public void setConnectionString(String connectionString) {            }            @Override            public boolean updateServerListEnabled() {                return false;            }            @Override            public void start() throws Exception {            }            @Override            public String getConnectionString() {                return connectionString.get();            }            @Override            public void close() throws IOException {            }        };        final Semaphore acquiredSemaphore = new Semaphore(0);        final AtomicInteger acquireCount = new AtomicInteger(0);        final CountDownLatch suspendedLatch = new CountDownLatch(CLIENT_QTY);        for (int i = 0; i < CLIENT_QTY; ++i) {            completionService.submit(new Callable<Void>() {                @Override                public Void call() throws Exception {                    CuratorFramework client = CuratorFrameworkFactory.builder().ensembleProvider(provider).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new ExponentialBackoffRetry(100, 3)).build();                    try {                        final Semaphore suspendedSemaphore = new Semaphore(0);                        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {                            @Override                            public void stateChanged(CuratorFramework client, ConnectionState newState) {                                if ((newState == ConnectionState.SUSPENDED) || (newState == ConnectionState.LOST)) {                                    suspendedLatch.countDown();                                    suspendedSemaphore.release();                                }                            }                        });                        client.start();                        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, PATH, 1);                        while (!Thread.currentThread().isInterrupted()) {                            Lease lease = null;                            try {                                lease = semaphore.acquire();                                acquiredSemaphore.release();                                acquireCount.incrementAndGet();                                suspendedSemaphore.acquire();                            } catch (Exception e) {                                                        } finally {                                if (lease != null) {                                    acquireCount.decrementAndGet();                                    CloseableUtils.closeQuietly(lease);                                }                            }                        }                    } finally {                        TestCleanState.closeAndTestClean(client);                    }                    return null;                }            });        }        Assert.assertTrue(timing.acquireSemaphore(acquiredSemaphore));        Assert.assertEquals(1, acquireCount.get());        cluster.close();        timing.awaitLatch(suspendedLatch);        timing.forWaiting().sleepABit();        Assert.assertEquals(0, acquireCount.get());        cluster = new TestingCluster(3);        cluster.start();        connectionString.set(cluster.getConnectString());        timing.forWaiting().sleepABit();        Assert.assertTrue(timing.acquireSemaphore(acquiredSemaphore));        timing.forWaiting().sleepABit();        Assert.assertEquals(1, acquireCount.get());    } finally {        executorService.shutdown();        executorService.awaitTermination(10, TimeUnit.SECONDS);        executorService.shutdownNow();        CloseableUtils.closeQuietly(cluster);    }}
8288ce4403dd68ee31bc3e4125518f3f79dd8811760a6c6877cce621be05ce5a
setConnectionString
public void setConnectionString(String connectionString)
{}
4d8f8c3644e8bcf9c25bb24a5c68147d454045b529f3acc5b3ab9f472ebbed35
updateServerListEnabled
public boolean updateServerListEnabled()
{    return false;}
90ba0dddc593bd95e2a0c0c039c523b81bfb91f87814ebcb222c3914ca772ead
start
public void start() throws Exception
{}
3a15ca2ed8208cd07404b01c15089fa841a6e5aecf12a07cc9d92b33a3adb8ac
getConnectionString
public String getConnectionString()
{    return connectionString.get();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.builder().ensembleProvider(provider).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new ExponentialBackoffRetry(100, 3)).build();    try {        final Semaphore suspendedSemaphore = new Semaphore(0);        client.getConnectionStateListenable().addListener(new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if ((newState == ConnectionState.SUSPENDED) || (newState == ConnectionState.LOST)) {                    suspendedLatch.countDown();                    suspendedSemaphore.release();                }            }        });        client.start();        InterProcessSemaphoreV2 semaphore = new InterProcessSemaphoreV2(client, PATH, 1);        while (!Thread.currentThread().isInterrupted()) {            Lease lease = null;            try {                lease = semaphore.acquire();                acquiredSemaphore.release();                acquireCount.incrementAndGet();                suspendedSemaphore.acquire();            } catch (Exception e) {                        } finally {                if (lease != null) {                    acquireCount.decrementAndGet();                    CloseableUtils.closeQuietly(lease);                }            }        }    } finally {        TestCleanState.closeAndTestClean(client);    }    return null;}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if ((newState == ConnectionState.SUSPENDED) || (newState == ConnectionState.LOST)) {        suspendedLatch.countDown();        suspendedSemaphore.release();    }}
be5944792254ef21883d472900be6adadba1ef7ebff90bf2d5c8e57283076cbb
testCluster
public void testCluster() throws Exception
{    final int QTY = 20;    final int OPERATION_TIME_MS = 1000;    final String PATH = "/foo/bar/lock";    ExecutorService executorService = Executors.newFixedThreadPool(QTY);    ExecutorCompletionService<Void> completionService = new ExecutorCompletionService<Void>(executorService);    final Timing timing = new Timing();    TestingCluster cluster = new TestingCluster(3);    List<SemaphoreClient> semaphoreClients = Lists.newArrayList();    try {        cluster.start();        final AtomicInteger opCount = new AtomicInteger(0);        for (int i = 0; i < QTY; ++i) {            SemaphoreClient semaphoreClient = new SemaphoreClient(cluster.getConnectString(), PATH, new Callable<Void>() {                @Override                public Void call() throws Exception {                    opCount.incrementAndGet();                    Thread.sleep(OPERATION_TIME_MS);                    return null;                }            });            completionService.submit(semaphoreClient);            semaphoreClients.add(semaphoreClient);        }        timing.forWaiting().sleepABit();        Assert.assertNotNull(SemaphoreClient.getActiveClient());        final CountDownLatch latch = new CountDownLatch(1);        CuratorFramework client = CuratorFrameworkFactory.newClient(cluster.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.LOST) {                    latch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        client.start();        try {            client.getZookeeperClient().blockUntilConnectedOrTimedOut();            cluster.stop();            latch.await();        } finally {            CloseableUtils.closeQuietly(client);        }        long startTicks = System.currentTimeMillis();        for (; ; ) {            int thisOpCount = opCount.get();            Thread.sleep(2 * OPERATION_TIME_MS);            if (thisOpCount == opCount.get()) {                                break;            }            Assert.assertTrue((System.currentTimeMillis() - startTicks) < timing.forWaiting().milliseconds());        }        int thisOpCount = opCount.get();        Iterator<InstanceSpec> iterator = cluster.getInstances().iterator();        cluster = new TestingCluster(iterator.next(), iterator.next());        cluster.start();        timing.forWaiting().sleepABit();        startTicks = System.currentTimeMillis();        for (; ; ) {            Thread.sleep(2 * OPERATION_TIME_MS);            if (opCount.get() > thisOpCount) {                                break;            }            Assert.assertTrue((System.currentTimeMillis() - startTicks) < timing.forWaiting().milliseconds());        }    } finally {        for (SemaphoreClient semaphoreClient : semaphoreClients) {            CloseableUtils.closeQuietly(semaphoreClient);        }        CloseableUtils.closeQuietly(cluster);        executorService.shutdownNow();    }}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    opCount.incrementAndGet();    Thread.sleep(OPERATION_TIME_MS);    return null;}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.LOST) {        latch.countDown();    }}
1e6e993e76d7a86ee1db3b2326cb9cabb2f70cc3f4639219020c8cb5a3c5e569
testReentrant
public void testReentrant()
{}
52ed13a51724ede1924d8c17299fc30fb872a9db8b902f3139b68dc0d2546100
testReentrant2Threads
public void testReentrant2Threads()
{}
194d5f59c4681182481fe55bd7db48a76a19b1e4e62db38ba87ff5b345d8eb6f
testReentrantSingleLock
public void testReentrantSingleLock()
{}
7c6d2c86d7dc6449d777fb8d10a2f98a63a18a480cc43050915955c4e3d16963
makeLock
protected InterProcessLock makeLock(CuratorFramework client)
{    return new InterProcessSemaphoreMutex(client, LOCK_PATH);}
ba7da9bc2933d3214413074d477ef37f7f7d168663c38c0c83603bf726b41b3a
createClient
private CuratorFramework createClient(ACLProvider provider) throws Exception
{    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);    CuratorFramework client = CuratorFrameworkFactory.builder().namespace("ns").connectString(server.getConnectString()).retryPolicy(retryPolicy).aclProvider(provider).build();    client.start();    return client;}
6c5956e3e0646584984e26495e2eb06bdccff37dfdc0b2035a878f1cf02b5cdf
testLockACLs
public void testLockACLs() throws Exception
{    CuratorFramework client = createClient(new TestLockACLsProvider());    try {        client.create().forPath("/foo");        Assert.assertNotNull(client.checkExists().forPath("/foo"));        Assert.assertEquals(ZooDefs.Perms.ALL, client.getACL().forPath("/foo").get(0).getPerms());        Assert.assertEquals("ip", client.getACL().forPath("/foo").get(0).getId().getScheme());        Assert.assertEquals("127.0.0.1", client.getACL().forPath("/foo").get(0).getId().getId());        InterProcessReadWriteLock lock = new InterProcessReadWriteLock(client, "/bar");        InterProcessMutex writeLock = lock.writeLock();        writeLock.acquire();        Assert.assertNotNull(client.checkExists().forPath("/bar"));        Assert.assertEquals(ZooDefs.Perms.ALL, client.getACL().forPath("/bar").get(0).getPerms());        Assert.assertEquals("ip", client.getACL().forPath("/bar").get(0).getId().getScheme());        Assert.assertEquals("127.0.0.1", client.getACL().forPath("/bar").get(0).getId().getId());    } finally {        TestCleanState.closeAndTestClean(client);    }}
6e3f484bf3425c72751ef80878e64412d33b3e632c8f4047b21df4814d653513
testACLsCreatingParents
public void testACLsCreatingParents() throws Exception
{    CuratorFramework client = createClient(new TestACLsCreatingParentsProvider());    try {        client.create().creatingParentsIfNeeded().forPath("/parent/foo");        Assert.assertEquals(ZooDefs.Perms.CREATE | ZooDefs.Perms.READ, client.getACL().forPath("/parent").get(0).getPerms());        Assert.assertEquals(ZooDefs.Perms.ALL, client.getACL().forPath("/parent/foo").get(0).getPerms());    } finally {        CloseableUtils.closeQuietly(client);    }}
608c4250279b9160905e4962b77bc1d258c8a726d186d1875dd0e18be5e9bcbb
getDefaultAcl
public List<ACL> getDefaultAcl()
{    return ACLS1;}
948e924ac3cf12487fcf7f5ccc3b514ae7fc4b9d602a2962739b070d41126b34
getAclForPath
public List<ACL> getAclForPath(String path)
{    if (path.equals("/ns/parent")) {        return ACLS2;    }    return ACLS1;}
608c4250279b9160905e4962b77bc1d258c8a726d186d1875dd0e18be5e9bcbb
getDefaultAcl
public List<ACL> getDefaultAcl()
{    return ACLS1;}
948e924ac3cf12487fcf7f5ccc3b514ae7fc4b9d602a2962739b070d41126b34
getAclForPath
public List<ACL> getAclForPath(String path)
{    return ACLS1;}
c104472d361bdb7cf2a50a909753c7b5517ba1ec90024a8e52e47ed05a708b57
testNodeDeleted
public void testNodeDeleted() throws Exception
{    final String PATH = "/foo/bar";    CuratorFramework client = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryNTimes(0, 0));        client.start();        client.create().creatingParentsIfNeeded().forPath(PATH);        Assert.assertEquals(client.checkExists().forPath(PATH).getNumChildren(), 0);        LockInternals internals = new LockInternals(client, new StandardLockInternalsDriver(), PATH, "lock-", 1) {            @Override            List<String> getSortedChildren() throws Exception {                throw new KeeperException.NoNodeException();            }        };        try {            internals.attemptLock(0, null, null);            Assert.fail();        } catch (KeeperException.NoNodeException dummy) {                }                Assert.assertEquals(client.checkExists().forPath(PATH).getNumChildren(), 0);    } finally {        TestCleanState.closeAndTestClean(client);    }}
df57bbeb0ea69c55a1df19798331577ed3313a93873a7f030dcdfa9a629ab454
getSortedChildren
 List<String> getSortedChildren() throws Exception
{    throw new KeeperException.NoNodeException();}
e2dd61447115e6dc0a6f525dae18a9f6ecf5382ca17060de2b8fda61ada7910c
testUsingLeaderPath
public void testUsingLeaderPath() throws Exception
{    final Timing timing = new Timing();    CuratorFramework client = makeClient(timing, null);    Reaper reaper1 = null;    Reaper reaper2 = null;    try {        final AtomicInteger reaper1Count = new AtomicInteger();        reaper1 = new Reaper(client, Reaper.newExecutorService(), 1, "/reaper/leader") {            @Override            protected void reap(PathHolder holder) {                reaper1Count.incrementAndGet();                super.reap(holder);            }        };        final AtomicInteger reaper2Count = new AtomicInteger();        reaper2 = new Reaper(client, Reaper.newExecutorService(), 1, "/reaper/leader") {            @Override            protected void reap(PathHolder holder) {                reaper2Count.incrementAndGet();                super.reap(holder);            }        };        client.start();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        reaper1.start();        reaper2.start();        reaper1.addPath("/one/two/three");        reaper2.addPath("/one/two/three");        timing.sleepABit();        Assert.assertTrue((reaper1Count.get() == 0) || (reaper2Count.get() == 0));        Assert.assertTrue((reaper1Count.get() > 0) || (reaper2Count.get() > 0));        Reaper activeReaper;        AtomicInteger inActiveReaperCount;        if (reaper1Count.get() > 0) {            activeReaper = reaper1;            inActiveReaperCount = reaper2Count;        } else {            activeReaper = reaper2;            inActiveReaperCount = reaper1Count;        }        Assert.assertEquals(inActiveReaperCount.get(), 0);        activeReaper.close();        timing.sleepABit();        Assert.assertTrue(inActiveReaperCount.get() > 0);    } finally {        CloseableUtils.closeQuietly(reaper1);        CloseableUtils.closeQuietly(reaper2);        CloseableUtils.closeQuietly(client);    }}
9e50df4f707ec4adc5d6f0dac3145a6659eacc62aba48f2d5b5fad507868b9e3
reap
protected void reap(PathHolder holder)
{    reaper1Count.incrementAndGet();    super.reap(holder);}
9e50df4f707ec4adc5d6f0dac3145a6659eacc62aba48f2d5b5fad507868b9e3
reap
protected void reap(PathHolder holder)
{    reaper2Count.incrementAndGet();    super.reap(holder);}
e16ae2514ad58f8df516d820a4f94aea66d165d38a1efc06fbb68add9f02b38e
testUsingLeaderLatch
public void testUsingLeaderLatch() throws Exception
{    final Timing timing = new Timing();    CuratorFramework client = makeClient(timing, null);    Reaper reaper1 = null;    Reaper reaper2 = null;    LeaderLatch leaderLatch1 = null;    LeaderLatch leaderLatch2 = null;    try {        final AtomicInteger reaper1Count = new AtomicInteger();        leaderLatch1 = new LeaderLatch(client, "/reaper/leader");        reaper1 = new Reaper(client, Reaper.newExecutorService(), 1, leaderLatch1) {            @Override            protected void reap(PathHolder holder) {                reaper1Count.incrementAndGet();                super.reap(holder);            }        };        final AtomicInteger reaper2Count = new AtomicInteger();        leaderLatch2 = new LeaderLatch(client, "/reaper/leader");        reaper2 = new Reaper(client, Reaper.newExecutorService(), 1, leaderLatch2) {            @Override            protected void reap(PathHolder holder) {                reaper2Count.incrementAndGet();                super.reap(holder);            }        };        client.start();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        leaderLatch1.start();        leaderLatch2.start();        reaper1.start();        reaper2.start();        reaper1.addPath("/one/two/three");        reaper2.addPath("/one/two/three");        timing.sleepABit();        Assert.assertTrue((reaper1Count.get() == 0) || (reaper2Count.get() == 0));        Assert.assertTrue((reaper1Count.get() > 0) || (reaper2Count.get() > 0));        Reaper activeReaper;        LeaderLatch activeLeaderLeatch;        AtomicInteger inActiveReaperCount;        if (reaper1Count.get() > 0) {            activeReaper = reaper1;            activeLeaderLeatch = leaderLatch1;            inActiveReaperCount = reaper2Count;        } else {            activeReaper = reaper2;            activeLeaderLeatch = leaderLatch2;            inActiveReaperCount = reaper1Count;        }        Assert.assertEquals(inActiveReaperCount.get(), 0);        activeReaper.close();        activeLeaderLeatch.close();        timing.sleepABit();        Assert.assertTrue(inActiveReaperCount.get() > 0);    } finally {        CloseableUtils.closeQuietly(reaper1);        CloseableUtils.closeQuietly(reaper2);        if (leaderLatch1 != null && LeaderLatch.State.STARTED == leaderLatch1.getState()) {            CloseableUtils.closeQuietly(leaderLatch1);        }        if (leaderLatch2 != null && LeaderLatch.State.STARTED == leaderLatch2.getState()) {            CloseableUtils.closeQuietly(leaderLatch2);        }        CloseableUtils.closeQuietly(client);    }}
9e50df4f707ec4adc5d6f0dac3145a6659eacc62aba48f2d5b5fad507868b9e3
reap
protected void reap(PathHolder holder)
{    reaper1Count.incrementAndGet();    super.reap(holder);}
9e50df4f707ec4adc5d6f0dac3145a6659eacc62aba48f2d5b5fad507868b9e3
reap
protected void reap(PathHolder holder)
{    reaper2Count.incrementAndGet();    super.reap(holder);}
428327d54fdbd5e0ee678ed2c0057e09bcf9e940fdd91e932f9be6fc3e563eb9
testUsingManualLeader
public void testUsingManualLeader() throws Exception
{    final Timing timing = new Timing();    final CuratorFramework client = makeClient(timing, null);    final CountDownLatch latch = new CountDownLatch(1);    LeaderSelectorListener listener = new LeaderSelectorListener() {        @Override        public void takeLeadership(CuratorFramework client) throws Exception {            Reaper reaper = new Reaper(client, 1);            try {                reaper.addPath("/one/two/three", Reaper.Mode.REAP_UNTIL_DELETE);                reaper.start();                timing.sleepABit();                latch.countDown();            } finally {                CloseableUtils.closeQuietly(reaper);            }        }        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {        }    };    LeaderSelector selector = new LeaderSelector(client, "/leader", listener);    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        selector.start();        timing.awaitLatch(latch);        Assert.assertNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(selector);        CloseableUtils.closeQuietly(client);    }}
572980c734fcdd22464cc98d1931013f84abfc71246389b062e7e113e357572e
takeLeadership
public void takeLeadership(CuratorFramework client) throws Exception
{    Reaper reaper = new Reaper(client, 1);    try {        reaper.addPath("/one/two/three", Reaper.Mode.REAP_UNTIL_DELETE);        reaper.start();        timing.sleepABit();        latch.countDown();    } finally {        CloseableUtils.closeQuietly(reaper);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
26c8c9df5a0cad0fac2fd203edd285cb2c43ea7f3ae872c96d9810b427bf4ee8
testSparseUseNoReap
public void testSparseUseNoReap() throws Exception
{    final int THRESHOLD = 3000;    Timing timing = new Timing();    Reaper reaper = null;    CuratorFramework client = makeClient(timing, null);    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        final Queue<Reaper.PathHolder> holders = new ConcurrentLinkedQueue<Reaper.PathHolder>();        final ExecutorService pool = Executors.newCachedThreadPool();        ScheduledExecutorService service = new ScheduledThreadPoolExecutor(1);        reaper = new Reaper(client, service, THRESHOLD) {            @Override            protected Future<Void> schedule(final PathHolder pathHolder, int reapingThresholdMs) {                holders.add(pathHolder);                final Future<?> f = super.schedule(pathHolder, reapingThresholdMs);                pool.submit(new Callable<Void>() {                    @Override                    public Void call() throws Exception {                        f.get();                        holders.remove(pathHolder);                        return null;                    }                });                return null;            }        };        reaper.start();        reaper.addPath("/one/two/three");        long start = System.currentTimeMillis();        boolean emptyCountIsCorrect = false;        while (        ((System.currentTimeMillis() - start) < timing.forWaiting().milliseconds()) && !emptyCountIsCorrect) {            for (Reaper.PathHolder holder : holders) {                if (holder.path.endsWith("/one/two/three")) {                    emptyCountIsCorrect = (holder.emptyCount > 0);                    break;                }            }            Thread.sleep(1);        }        Assert.assertTrue(emptyCountIsCorrect);        client.create().forPath("/one/two/three/foo");        Thread.sleep(2 * (THRESHOLD / Reaper.EMPTY_COUNT_THRESHOLD));        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        client.delete().forPath("/one/two/three/foo");        Thread.sleep(THRESHOLD);        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
e7992908abb48ca7edae673d11d39e1dbc9998bdd8967901e54ea1ec9efde449
schedule
protected Future<Void> schedule(final PathHolder pathHolder, int reapingThresholdMs)
{    holders.add(pathHolder);    final Future<?> f = super.schedule(pathHolder, reapingThresholdMs);    pool.submit(new Callable<Void>() {        @Override        public Void call() throws Exception {            f.get();            holders.remove(pathHolder);            return null;        }    });    return null;}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    f.get();    holders.remove(pathHolder);    return null;}
19964a1e7397a47180c09fc225440a6cc3302c93e46bacb459a65dd5f9343d3c
testReapUntilDelete
public void testReapUntilDelete() throws Exception
{    testReapUntilDelete(null);}
57ce41133263ac5be27de7c7392d9bd478cdb8d48f847cf2bfb2c0427b8e5e37
testReapUntilDeleteNamespace
public void testReapUntilDeleteNamespace() throws Exception
{    testReapUntilDelete("test");}
a405cec3f82ef703a66726de0057c90574bf70ad62449da3c5a2dea55852160a
testReapUntilGone
public void testReapUntilGone() throws Exception
{    testReapUntilGone(null);}
2270f3774537a5e41f967b2b9a6ec8dfbf55130e890785e5dd36ef703752180f
testReapUntilGoneNamespace
public void testReapUntilGoneNamespace() throws Exception
{    testReapUntilGone("test");}
82997a565e242baaa9f70110beae5694aa51aa6713124002c52cb10b61538c5f
testRemove
public void testRemove() throws Exception
{    testRemove(null);}
498c2bd7ad38444ed6d18fbf862fecfeb836f412a02af7cbaa2afd236626be28
testRemoveNamespace
public void testRemoveNamespace() throws Exception
{    testRemove("test");}
2ef8f42758df70d8709b388eff35080e9e13c3b96d2b52307cbdb85f5f30b07a
testSimulationWithLocks
public void testSimulationWithLocks() throws Exception
{    testSimulationWithLocks(null);}
3268bc20c694b618239383843d28c32ce1f8d8c286013c4bfb317058dc358488
testSimulationWithLocksNamespace
public void testSimulationWithLocksNamespace() throws Exception
{    testSimulationWithLocks("test");}
aec7c89692fa55da7af126a209cdab962357473887f67b789fa6fd0f15d1604d
testWithEphemerals
public void testWithEphemerals() throws Exception
{    testWithEphemerals(null);}
2cd5911a8b787d0ea01571ee58e48312f0d1c5db832e8c3ea005652411b8e404
testWithEphemeralsNamespace
public void testWithEphemeralsNamespace() throws Exception
{    testWithEphemerals("test");}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    testBasic(null);}
ee9271a15515dc38610ceea758ab61052c61ff8f3be9e5bd510e6ffce0f9fdfe
testBasicNamespace
public void testBasicNamespace() throws Exception
{    testBasic("test");}
21a0503ac414a9023152c3c4a0ab7789dd2234102c2b7cf8b43496f95c60bf1d
testReapUntilDelete
private void testReapUntilDelete(String namespace) throws Exception
{    Timing timing = new Timing();    Reaper reaper = null;    CuratorFramework client = makeClient(timing, namespace);    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        reaper = new Reaper(client, 100);        reaper.start();        reaper.addPath("/one/two/three", Reaper.Mode.REAP_UNTIL_DELETE);        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/one/two/three"));        client.create().forPath("/one/two/three");        timing.sleepABit();        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
4d975a8c7f47133164f1b9a2b55ac3c884f2f8afadd3167fea275a856bbcd611
testReapUntilGone
private void testReapUntilGone(String namespace) throws Exception
{    Timing timing = new Timing();    Reaper reaper = null;    CuratorFramework client = makeClient(timing, namespace);    try {        client.start();        reaper = new Reaper(client, 100);        reaper.start();        reaper.addPath("/one/two/three", Reaper.Mode.REAP_UNTIL_GONE);        timing.sleepABit();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        reaper.addPath("/one/two/three", Reaper.Mode.REAP_UNTIL_GONE);        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
11fb2d00ec1a6428c3b29b74571de9f64ebe6d2704eb339b1cceefa992522421
makeClient
private CuratorFramework makeClient(Timing timing, String namespace) throws IOException
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder().connectionTimeoutMs(timing.connection()).sessionTimeoutMs(timing.session()).connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1));    if (namespace != null) {        builder = builder.namespace(namespace);    }    return builder.build();}
58aaea415627bcd5f8d4337858dc621944efb2db85a2dbbbf2b4d0d6cfe816ad
testRemove
private void testRemove(String namespace) throws Exception
{    Timing timing = new Timing();    Reaper reaper = null;    CuratorFramework client = makeClient(timing, namespace);    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        reaper = new Reaper(client, 100);        reaper.start();        reaper.addPath("/one/two/three");        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/one/two/three"));        Assert.assertTrue(reaper.removePath("/one/two/three"));        client.create().forPath("/one/two/three");        timing.sleepABit();        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
aea9f2f87708f6c1b72911510caaea8dce12d4124906d996bec9afc061534d74
testSimulationWithLocks
private void testSimulationWithLocks(String namespace) throws Exception
{    final int LOCK_CLIENTS = 10;    final int ITERATIONS = 250;    final int MAX_WAIT_MS = 10;    ExecutorService service = Executors.newFixedThreadPool(LOCK_CLIENTS);    ExecutorCompletionService<Object> completionService = new ExecutorCompletionService<Object>(service);    Timing timing = new Timing();    Reaper reaper = null;    final CuratorFramework client = makeClient(timing, namespace);    try {        client.start();        reaper = new Reaper(client, MAX_WAIT_MS / 2);        reaper.start();        reaper.addPath("/a/b");        for (int i = 0; i < LOCK_CLIENTS; ++i) {            completionService.submit(new Callable<Object>() {                @Override                public Object call() throws Exception {                    final InterProcessMutex lock = new InterProcessMutex(client, "/a/b");                    for (int i = 0; i < ITERATIONS; ++i) {                        lock.acquire();                        try {                            Thread.sleep((int) (Math.random() * MAX_WAIT_MS));                        } finally {                            lock.release();                        }                    }                    return null;                }            });        }        for (int i = 0; i < LOCK_CLIENTS; ++i) {            completionService.take().get();        }        Thread.sleep(timing.session());        timing.sleepABit();        Stat stat = client.checkExists().forPath("/a/b");        Assert.assertNull(stat, "Child qty: " + ((stat != null) ? stat.getNumChildren() : 0));    } finally {        service.shutdownNow();        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    final InterProcessMutex lock = new InterProcessMutex(client, "/a/b");    for (int i = 0; i < ITERATIONS; ++i) {        lock.acquire();        try {            Thread.sleep((int) (Math.random() * MAX_WAIT_MS));        } finally {            lock.release();        }    }    return null;}
ab931d0e833cae31a7081bb31e5e85810dd636a0c878fad599ca15cc518686e6
testWithEphemerals
private void testWithEphemerals(String namespace) throws Exception
{    Timing timing = new Timing();    Reaper reaper = null;    CuratorFramework client2 = null;    CuratorFramework client = makeClient(timing, namespace);    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        client2 = makeClient(timing, namespace);        client2.start();        for (int i = 0; i < 10; ++i) {            client2.create().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath("/one/two/three/foo-");        }        reaper = new Reaper(client, 100);        reaper.start();        reaper.addPath("/one/two/three");        timing.sleepABit();        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));                client2.close();        client2 = null;        Thread.sleep(timing.session());        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client2);        CloseableUtils.closeQuietly(client);    }}
7511353903913d7a13c119fd26ddfc760b9d10bcfe9632c17a5aa5800d5484e9
testBasic
private void testBasic(String namespace) throws Exception
{    Timing timing = new Timing();    Reaper reaper = null;    CuratorFramework client = makeClient(timing, namespace);    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/one/two/three");        Assert.assertNotNull(client.checkExists().forPath("/one/two/three"));        reaper = new Reaper(client, 100);        reaper.start();        reaper.addPath("/one/two/three");        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/one/two/three"));    } finally {        CloseableUtils.closeQuietly(reaper);        CloseableUtils.closeQuietly(client);    }}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    Timing timing = new Timing();    GroupMember groupMember1 = null;    GroupMember groupMember2 = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        groupMember1 = new GroupMember(client, "/member", "1");        Assert.assertTrue(groupMember1.getCurrentMembers().containsKey("1"));        groupMember1.start();        groupMember2 = new GroupMember(client, "/member", "2");        groupMember2.start();        timing.sleepABit();        Map<String, byte[]> currentMembers1 = groupMember1.getCurrentMembers();        Map<String, byte[]> currentMembers2 = groupMember2.getCurrentMembers();        Map<String, String> convertMembers1 = Maps.transformValues(currentMembers1, new Function<byte[], String>() {            @Override            public String apply(byte[] input) {                return new String(input);            }        });        Map<String, String> convertMembers2 = Maps.transformValues(currentMembers1, new Function<byte[], String>() {            @Override            public String apply(byte[] input) {                return new String(input);            }        });        Assert.assertEquals(convertMembers1.size(), 2);        Assert.assertEquals(convertMembers2.size(), 2);        Assert.assertEquals(convertMembers1, convertMembers2);        Assert.assertTrue(convertMembers1.containsKey("1"));        Assert.assertTrue(convertMembers1.containsKey("2"));        groupMember2.close();        timing.sleepABit();        currentMembers1 = groupMember1.getCurrentMembers();        Assert.assertEquals(currentMembers1.size(), 1);        Assert.assertTrue(currentMembers1.containsKey("1"));        Assert.assertFalse(currentMembers1.containsKey("2"));        groupMember1.setThisData("something".getBytes());        timing.sleepABit();        currentMembers1 = groupMember1.getCurrentMembers();        Assert.assertTrue(currentMembers1.containsKey("1"));        Assert.assertEquals(currentMembers1.get("1"), "something".getBytes());    } finally {        CloseableUtils.closeQuietly(groupMember1);        CloseableUtils.closeQuietly(groupMember2);        CloseableUtils.closeQuietly(client);    }}
03b83369f11c3a1f10053f2d4801ddcd4b1d604b71c3529edbd6347e3e9a33ef
apply
public String apply(byte[] input)
{    return new String(input);}
03b83369f11c3a1f10053f2d4801ddcd4b1d604b71c3529edbd6347e3e9a33ef
apply
public String apply(byte[] input)
{    return new String(input);}
7c529460b940c419ef707bd1846a5575ea1bfc48c129127836c31f0184c1d8fb
teardown
public void teardown() throws Exception
{    try {        for (PersistentEphemeralNode node : createdNodes) {            CloseableUtils.closeQuietly(node);        }        for (CuratorFramework curator : curatorInstances) {            TestCleanState.closeAndTestClean(curator);        }    } finally {        super.teardown();    }}
49278453b80be03a05ca0ba3569f670d4a030a9f753c503e34562f4b4ccfeaed
testListenersReconnectedIsFast
public void testListenersReconnectedIsFast() throws Exception
{    server.stop();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        try (PersistentEphemeralNode node = new PersistentEphemeralNode(client, PersistentEphemeralNode.Mode.EPHEMERAL, "/abc/node", "hello".getBytes())) {            node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());            node.start();            final CountDownLatch connectedLatch = new CountDownLatch(1);            final CountDownLatch reconnectedLatch = new CountDownLatch(1);            ConnectionStateListener listener = new ConnectionStateListener() {                @Override                public void stateChanged(CuratorFramework client, ConnectionState newState) {                    if (newState == ConnectionState.CONNECTED) {                        connectedLatch.countDown();                    }                    if (newState == ConnectionState.RECONNECTED) {                        reconnectedLatch.countDown();                    }                }            };            client.getConnectionStateListenable().addListener(listener);            timing.sleepABit();            server.restart();            Assert.assertTrue(timing.awaitLatch(connectedLatch));            timing.sleepABit();            Assert.assertTrue(node.waitForInitialCreate(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS));            server.stop();            timing.sleepABit();            server.restart();            timing.sleepABit();            Assert.assertTrue(timing.awaitLatch(reconnectedLatch));        }    } finally {        TestCleanState.closeAndTestClean(client);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    }    if (newState == ConnectionState.RECONNECTED) {        reconnectedLatch.countDown();    }}
72be669c1e54d46ae4905cfdb575b4076656189932209a1e4da23d5665de95f6
testNoServerAtStart
public void testNoServerAtStart() throws Exception
{    server.stop();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    PersistentEphemeralNode node = null;    try {        client.start();        node = new PersistentEphemeralNode(client, PersistentEphemeralNode.Mode.EPHEMERAL, "/abc/node", "hello".getBytes());        node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        node.start();        final CountDownLatch connectedLatch = new CountDownLatch(1);        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                if (newState == ConnectionState.CONNECTED) {                    connectedLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        timing.sleepABit();        server.restart();        Assert.assertTrue(timing.awaitLatch(connectedLatch));        timing.sleepABit();        Assert.assertTrue(node.waitForInitialCreate(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS));    } finally {        CloseableUtils.closeQuietly(node);        TestCleanState.closeAndTestClean(client);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    }}
77a92d907eb489e76fa5a7f6cc3d4b42122725f31b2b3b2cdc98391637bada0a
testNullCurator
public void testNullCurator() throws Exception
{    new PersistentEphemeralNode(null, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);}
661edd93ab8e7e2ed834bcdd134f4a61059e386c25778fd534cb2c9562fed3d1
testNullPath
public void testNullPath() throws Exception
{    CuratorFramework curator = newCurator();    new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, null, new byte[0]);}
7c9125584179bef919d7043289c799d9754f19912a0d28c1c46858afe798bd41
testNullData
public void testNullData() throws Exception
{    CuratorFramework curator = newCurator();    new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, null);}
a85d9297ee456cf4b71345d3a3a82cad15dd1a994df80ec9e49aafcfc21b5c41
testNullMode
public void testNullMode() throws Exception
{    CuratorFramework curator = newCurator();    new PersistentEphemeralNode(curator, null, PATH, new byte[0]);}
5d2e1cde1e27ab74416f2c5c0e7686ec718d96b8aca39618c075e49e658468fe
testSettingDataSequential
public void testSettingDataSequential() throws Exception
{    setDataTest(PersistentEphemeralNode.Mode.EPHEMERAL_SEQUENTIAL);}
2fda81dacc89e972c50dc487cdbb4b1c96e7386a4239da08685d1e959db7c1b9
testSettingData
public void testSettingData() throws Exception
{    setDataTest(PersistentEphemeralNode.Mode.EPHEMERAL);}
390536f70ff0d1f11bd21f78afc5c76d3972e3794eeff7c2655943f54dd5e427
setDataTest
protected void setDataTest(PersistentEphemeralNode.Mode mode) throws Exception
{    PersistentEphemeralNode node = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        node = new PersistentEphemeralNode(client, mode, PATH, "a".getBytes());        node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        node.start();        Assert.assertTrue(node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS));        Assert.assertEquals(client.getData().forPath(node.getActualPath()), "a".getBytes());        final Semaphore semaphore = new Semaphore(0);        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent arg0) {                semaphore.release();            }        };        client.checkExists().usingWatcher(watcher).forPath(node.getActualPath());        node.setData("b".getBytes());        Assert.assertTrue(timing.acquireSemaphore(semaphore));        Assert.assertEquals(node.getActualPath(), node.getActualPath());        Assert.assertEquals(client.getData().usingWatcher(watcher).forPath(node.getActualPath()), "b".getBytes());        node.setData("c".getBytes());        Assert.assertTrue(timing.acquireSemaphore(semaphore));        Assert.assertEquals(node.getActualPath(), node.getActualPath());        Assert.assertEquals(client.getData().usingWatcher(watcher).forPath(node.getActualPath()), "c".getBytes());        node.close();        Assert.assertTrue(timing.acquireSemaphore(semaphore));    } finally {        CloseableUtils.closeQuietly(node);        TestCleanState.closeAndTestClean(client);    }}
a07e595dd7639c6feffeff6eb1b9fc0b799ec0d544d2cbc9601421c17057a2b5
process
public void process(WatchedEvent arg0)
{    semaphore.release();}
85fdf25e0bbf3abbdc961839ddaeffdc46d3ece120a72dd64d2062e77779fd1c
testDeletesNodeWhenClosed
public void testDeletesNodeWhenClosed() throws Exception
{    CuratorFramework curator = newCurator();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    node.start();    String path = null;    try {        node.waitForInitialCreate(5, TimeUnit.SECONDS);        path = node.getActualPath();        assertNodeExists(curator, path);    } finally {        CloseableUtils.closeQuietly(node);    }    assertNodeDoesNotExist(curator, path);}
2effed282616a907999317b8de627fc5d7807ae7b0b8ed35fa2aec60b057178d
testClosingMultipleTimes
public void testClosingMultipleTimes() throws Exception
{    CuratorFramework curator = newCurator();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    node.start();    node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);    String path = node.getActualPath();    node.close();    assertNodeDoesNotExist(curator, path);    node.close();    assertNodeDoesNotExist(curator, path);}
a72b287d8893b0eb1387c199c1e589d2e1e886f9fe85ddaa6ae38005b907d09b
testDeletesNodeWhenSessionDisconnects
public void testDeletesNodeWhenSessionDisconnects() throws Exception
{    CuratorFramework curator = newCurator();    CuratorFramework observer = newCurator();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    try {        node.start();        node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        assertNodeExists(observer, node.getActualPath());                Trigger deletedTrigger = Trigger.deletedOrSetData();        observer.checkExists().usingWatcher(deletedTrigger).forPath(node.getActualPath());        node.debugCreateNodeLatch = new CountDownLatch(1);        Compatibility.injectSessionExpiration(curator.getZookeeperClient().getZooKeeper());                assertTrue(deletedTrigger.firedWithin(timing.forSessionSleep().seconds(), TimeUnit.SECONDS));        node.debugCreateNodeLatch.countDown();    } finally {        CloseableUtils.closeQuietly(node);    }}
3bff078b9e1a73efc88853e86fa50ff297d3a645a9e288ba31ae0f90411b05bf
testRecreatesNodeWhenSessionReconnects
public void testRecreatesNodeWhenSessionReconnects() throws Exception
{    CuratorFramework curator = newCurator();    CuratorFramework observer = newCurator();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    try {        node.start();        node.waitForInitialCreate(5, TimeUnit.SECONDS);        assertNodeExists(observer, node.getActualPath());        Trigger deletedTrigger = Trigger.deletedOrSetData();        observer.checkExists().usingWatcher(deletedTrigger).forPath(node.getActualPath());        node.debugCreateNodeLatch = new CountDownLatch(1);        Compatibility.injectSessionExpiration(curator.getZookeeperClient().getZooKeeper());                assertTrue(deletedTrigger.firedWithin(timing.forSessionSleep().seconds(), TimeUnit.SECONDS));        node.debugCreateNodeLatch.countDown();                Trigger createdTrigger = Trigger.created();        Stat stat = observer.checkExists().usingWatcher(createdTrigger).forPath(node.getActualPath());        assertTrue(stat != null || createdTrigger.firedWithin(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(node);    }}
ef083224f77b6cf01930bd5d69a3a192e1a86209a7bc591daa13264a63628deb
testRecreatesNodeWhenSessionReconnectsMultipleTimes
public void testRecreatesNodeWhenSessionReconnectsMultipleTimes() throws Exception
{    CuratorFramework curator = newCurator();    CuratorFramework observer = newCurator();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    try {        node.start();        node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        String path = node.getActualPath();        assertNodeExists(observer, path);                for (int i = 0; i < 5; i++) {            Trigger deletionTrigger = Trigger.deletedOrSetData();            Stat stat = observer.checkExists().usingWatcher(deletionTrigger).forPath(path);            Assert.assertNotNull(stat, "node should exist: " + path);            node.debugCreateNodeLatch = new CountDownLatch(1);                        Compatibility.injectSessionExpiration(curator.getZookeeperClient().getZooKeeper());                        assertTrue(deletionTrigger.firedWithin(timing.multiple(1.5).forSessionSleep().seconds(), TimeUnit.SECONDS));            node.debugCreateNodeLatch.countDown();                        Trigger creationTrigger = Trigger.created();            stat = observer.checkExists().usingWatcher(creationTrigger).forPath(path);            assertTrue(stat != null || creationTrigger.firedWithin(timing.forWaiting().seconds(), TimeUnit.SECONDS));        }    } finally {        CloseableUtils.closeQuietly(node);    }}
f05bf030c1b93fca7d4b7ba5b1a55e5800238674e7ca5ad0bb76af88197a8066
testRecreatesNodeWhenEphemeralOwnerSessionExpires
public void testRecreatesNodeWhenEphemeralOwnerSessionExpires() throws Exception
{    CuratorFramework curator = newCurator();    CuratorFramework nodeCreator = newCurator();    CuratorFramework observer = newCurator();    nodeCreator.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(PATH, new byte[0]);    Trigger dataChangedTrigger = Trigger.dataChanged();    observer.getData().usingWatcher(dataChangedTrigger).forPath(PATH);    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    node.start();    try {        node.waitForInitialCreate(5, TimeUnit.SECONDS);        assertNodeExists(observer, node.getActualPath());        assertTrue(dataChangedTrigger.firedWithin(timing.forWaiting().seconds(), TimeUnit.SECONDS));        Trigger deletedTrigger = Trigger.deletedOrSetData();        observer.checkExists().usingWatcher(deletedTrigger).forPath(node.getActualPath());        Compatibility.injectSessionExpiration(nodeCreator.getZookeeperClient().getZooKeeper());                assertTrue(deletedTrigger.firedWithin(timing.forWaiting().seconds(), TimeUnit.SECONDS));                Trigger createdTrigger = Trigger.created();        Stat stat = observer.checkExists().usingWatcher(createdTrigger).forPath(node.getActualPath());        assertTrue(stat != null || createdTrigger.firedWithin(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        node.close();    }}
dbb3c13018f0053bf9ef1ef78541d18127a48c9cfa17ac38f486ca41cbdf8079
testRecreatesNodeWhenItGetsDeleted
public void testRecreatesNodeWhenItGetsDeleted() throws Exception
{    CuratorFramework curator = newCurator();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    try {        node.start();        node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        String originalNode = node.getActualPath();        assertNodeExists(curator, originalNode);                curator.delete().forPath(originalNode);                        Trigger createdWatchTrigger = Trigger.created();        Stat stat = curator.checkExists().usingWatcher(createdWatchTrigger).forPath(originalNode);        assertTrue(stat != null || createdWatchTrigger.firedWithin(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(node);    }}
685b0612b6cfca14568c8e207a6cc82e1d272c2a0fb4085843861f8892420f24
testNodesCreateUniquePaths
public void testNodesCreateUniquePaths() throws Exception
{    CuratorFramework curator = newCurator();    try (PersistentEphemeralNode node1 = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL_SEQUENTIAL, PATH, new byte[0])) {        node1.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        node1.start();        node1.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        String path1 = node1.getActualPath();        PersistentEphemeralNode node2 = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL_SEQUENTIAL, PATH, new byte[0]);        node2.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        node2.start();        try {            node2.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);            String path2 = node2.getActualPath();            assertFalse(path1.equals(path2));        } finally {            node2.close();        }    }}
d24c45d6ac608b43db8a574fb59306c24b4a3f91542e4621f56dfc3b6b0f7c74
testData
public void testData() throws Exception
{    CuratorFramework curator = newCurator();    byte[] data = "Hello World".getBytes();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, data);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    try {        node.start();        node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        assertTrue(Arrays.equals(curator.getData().forPath(node.getActualPath()), data));    } finally {        CloseableUtils.closeQuietly(node);    }}
d6ec419a2820fb4269c879102051087983f0b1633bd026bb7b74457f01bd7137
testSetDataWhenNodeExists
public void testSetDataWhenNodeExists() throws Exception
{    CuratorFramework curator = newCurator();    curator.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(PATH, "InitialData".getBytes());    byte[] data = "Hello World".getBytes();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, data);    node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());    try {        node.start();        node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        assertTrue(Arrays.equals(curator.getData().forPath(node.getActualPath()), data));    } finally {        CloseableUtils.closeQuietly(node);    }}
aa63a545915904e93b45a98c18f835b4429bfd1355518759fa8fc16c22359667
testSetDataWhenDisconnected
public void testSetDataWhenDisconnected() throws Exception
{    CuratorFramework curator = newCurator();    byte[] initialData = "Hello World".getBytes();    byte[] updatedData = "Updated".getBytes();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, initialData);    try {        node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        node.start();        node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        assertTrue(Arrays.equals(curator.getData().forPath(node.getActualPath()), initialData));        server.stop();        final CountDownLatch dataUpdateLatch = new CountDownLatch(1);        Watcher watcher = new Watcher() {            @Override            public void process(WatchedEvent event) {                if (event.getType() == EventType.NodeDataChanged) {                    dataUpdateLatch.countDown();                }            }        };        curator.getData().usingWatcher(watcher).inBackground().forPath(node.getActualPath());        node.setData(updatedData);        server.restart();        assertTrue(timing.awaitLatch(dataUpdateLatch));        assertTrue(Arrays.equals(curator.getData().forPath(node.getActualPath()), updatedData));    } finally {        CloseableUtils.closeQuietly(node);    }}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (event.getType() == EventType.NodeDataChanged) {        dataUpdateLatch.countDown();    }}
cd2e9f823a6d1cbdbd97c5814d7854c5edca95018726924408c9f5257b8544e6
testSetUpdatedDataWhenReconnected
public void testSetUpdatedDataWhenReconnected() throws Exception
{    CuratorFramework curator = newCurator();    byte[] initialData = "Hello World".getBytes();    byte[] updatedData = "Updated".getBytes();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, initialData);    try {        node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        node.start();        node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        assertTrue(Arrays.equals(curator.getData().forPath(node.getActualPath()), initialData));        node.setData(updatedData);        assertTrue(Arrays.equals(curator.getData().forPath(node.getActualPath()), updatedData));        server.restart();        final CountDownLatch dataUpdateLatch = new CountDownLatch(1);        curator.getData().inBackground(new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                dataUpdateLatch.countDown();            }        }).forPath(node.getActualPath());        assertTrue(timing.awaitLatch(dataUpdateLatch));        assertTrue(Arrays.equals(curator.getData().forPath(node.getActualPath()), updatedData));    } finally {        CloseableUtils.closeQuietly(node);    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    dataUpdateLatch.countDown();}
4f79b1917530916bec4c556d4e10d1a604b6e999851d0e62a18fce0f6caac2ed
testProtected
public void testProtected() throws Exception
{    CuratorFramework curator = newCurator();    PersistentEphemeralNode node = new PersistentEphemeralNode(curator, PersistentEphemeralNode.Mode.PROTECTED_EPHEMERAL, PATH, new byte[0]);    try {        node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        node.start();        node.waitForInitialCreate(timing.forWaiting().seconds(), TimeUnit.SECONDS);        assertNodeExists(curator, node.getActualPath());        server.restart();        curator.blockUntilConnected(5, TimeUnit.SECONDS);        assertNodeExists(curator, node.getActualPath());                List<String> children = curator.getChildren().forPath(DIR);        assertFalse(children == null);        assertEquals(children.size(), 1);    } finally {        CloseableUtils.closeQuietly(node);    }}
6e56a61eb5e86c9b5c8360fa6ba983bcc4468d6fe1636969b2f00f9f11b58a72
testNoCreatePermission
public void testNoCreatePermission() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).authorization("digest", "me1:pass1".getBytes()).retryPolicy(new RetryOneTime(1)).build();    PersistentEphemeralNode node = null;    try {        client.start();        ACL acl = new ACL(ZooDefs.Perms.WRITE, ZooDefs.Ids.AUTH_IDS);        List<ACL> aclList = Lists.newArrayList(acl);        client.create().withACL(aclList).forPath(DIR, new byte[0]);        client.close();                client = newCurator();        node = new PersistentEphemeralNode(client, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);        node.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        node.start();        node.waitForInitialCreate(timing.seconds(), TimeUnit.SECONDS);        assertNodeDoesNotExist(client, PATH);        assertTrue(node.isAuthFailure());    } finally {        CloseableUtils.closeQuietly(node);        CloseableUtils.closeQuietly(client);    }}
5839866b7dc9b16a2dd62a6e41cfb6d0530f6df124a47693a0f2fe49491143cf
testNoWritePermission
public void testNoWritePermission() throws Exception
{    final ACLProvider aclProvider = new ACLProvider() {        final ACL acl = new ACL(ZooDefs.Perms.READ | ZooDefs.Perms.CREATE | ZooDefs.Perms.DELETE, ZooDefs.Ids.ANYONE_ID_UNSAFE);        final List<ACL> aclList = Collections.singletonList(acl);        @Override        public List<ACL> getDefaultAcl() {            return aclList;        }        @Override        public List<ACL> getAclForPath(String path) {            return aclList;        }    };    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).aclProvider(aclProvider).retryPolicy(new RetryOneTime(1)).build();    PersistentEphemeralNode node = null;    try {        client.start();        node = new PersistentEphemeralNode(client, PersistentEphemeralNode.Mode.EPHEMERAL, PATH, new byte[0]);        node.start();        assertTrue(node.waitForInitialCreate(timing.seconds(), TimeUnit.SECONDS), "Node not created");        assertNodeExists(client, PATH);        assertFalse(node.isAuthFailure(), "AuthFailure when creating node.");        byte[] NEW_DATA = "NEW_DATA".getBytes();        node.setData(NEW_DATA);        timing.sleepABit();        byte[] read_data = client.getData().forPath(PATH);        assertNotEquals(read_data, NEW_DATA, "Data matches - write went through.");        assertTrue(node.isAuthFailure(), "AuthFailure response not received.");    } finally {        CloseableUtils.closeQuietly(node);        CloseableUtils.closeQuietly(client);    }}
608c4250279b9160905e4962b77bc1d258c8a726d186d1875dd0e18be5e9bcbb
getDefaultAcl
public List<ACL> getDefaultAcl()
{    return aclList;}
948e924ac3cf12487fcf7f5ccc3b514ae7fc4b9d602a2962739b070d41126b34
getAclForPath
public List<ACL> getAclForPath(String path)
{    return aclList;}
0c96c374c3153d268eb104e577d2743119bd2915544c593af96f8570dae38138
assertNodeExists
private void assertNodeExists(CuratorFramework curator, String path) throws Exception
{    assertNotNull(path);    assertTrue(curator.checkExists().forPath(path) != null);}
5dbfd2eee13cd4592522266669a4e815f84dd7273dc94949d00badacb7b037a7
assertNodeDoesNotExist
private void assertNodeDoesNotExist(CuratorFramework curator, String path) throws Exception
{    assertTrue(curator.checkExists().forPath(path) == null);}
f825a47f4051cd0d091eb6807180d231d54f5704ebf08b45bf2c4fcff3c2470f
newCurator
private CuratorFramework newCurator() throws IOException
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    curatorInstances.add(client);    return client;}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    if (types.contains(event.getType())) {        latch.countDown();    } else if (event.getType() != EventType.None) {        log.warn("Unexpected watcher event: " + event);    }}
ab29f6d0452b3c673dd3a4f32e0d4017f260656084553c383014a69a2406a923
firedWithin
public boolean firedWithin(long duration, TimeUnit unit)
{    try {        return latch.await(duration, unit);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();        throw Throwables.propagate(e);    }}
6a716a4a2fc9663a39948967e5cda993d0e68114a9b8a3c0dff9d3f3913564de
created
private static Trigger created()
{    return new Trigger(Event.EventType.NodeCreated);}
3decf8502dc648c48c14d6986a59162cdb088c41adeb52de0a1c4b848092bc29
deletedOrSetData
private static Trigger deletedOrSetData()
{    return new Trigger(Event.EventType.NodeDeleted, EventType.NodeDataChanged);}
2004b5ae48b9447da8e291339bc7094be4beea8da7227c0e4f5adf66b01bb988
dataChanged
private static Trigger dataChanged()
{    return new Trigger(EventType.NodeDataChanged);}
0e0b6a90addcb5140d7b61d5cb35de4050d85bbc964b7ec1a6f129377daa2f00
testListenersReconnectedIsOK
public void testListenersReconnectedIsOK() throws Exception
{    server.stop();    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        PersistentEphemeralNode node = new PersistentEphemeralNode(client, PersistentEphemeralNode.Mode.EPHEMERAL, "/abc/node", "hello".getBytes());        node.start();        final CountDownLatch connectedLatch = new CountDownLatch(1);        final CountDownLatch reconnectedLatch = new CountDownLatch(1);        final AtomicReference<ConnectionState> lastState = new AtomicReference<ConnectionState>();        ConnectionStateListener listener = new ConnectionStateListener() {            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                lastState.set(newState);                if (newState == ConnectionState.CONNECTED) {                    connectedLatch.countDown();                }                if (newState == ConnectionState.RECONNECTED) {                    reconnectedLatch.countDown();                }            }        };        client.getConnectionStateListenable().addListener(listener);        timing.sleepABit();        server.restart();        Assert.assertTrue(timing.awaitLatch(connectedLatch));        timing.sleepABit();        Assert.assertTrue(node.waitForInitialCreate(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS));        server.restart();        timing.sleepABit();        Assert.assertTrue(timing.awaitLatch(reconnectedLatch));        timing.sleepABit();        Assert.assertEquals(lastState.get(), ConnectionState.RECONNECTED);    } finally {        CloseableUtils.closeQuietly(client);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    lastState.set(newState);    if (newState == ConnectionState.CONNECTED) {        connectedLatch.countDown();    }    if (newState == ConnectionState.RECONNECTED) {        reconnectedLatch.countDown();    }}
313d6e96898644f30e57201a67388a0b5d635d8b5d8608e31b9930a69fc358e2
testQuickSetData
public void testQuickSetData() throws Exception
{    final byte[] TEST_DATA = "hey".getBytes();    final byte[] ALT_TEST_DATA = "there".getBytes();    Timing timing = new Timing();    PersistentNode pen = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        pen = new PersistentNode(client, CreateMode.PERSISTENT, false, "/test", TEST_DATA);        pen.start();        try {            pen.setData(ALT_TEST_DATA);            Assert.fail("IllegalStateException should have been thrown");        } catch (IllegalStateException dummy) {                }    } finally {        CloseableUtils.closeQuietly(pen);        CloseableUtils.closeQuietly(client);    }}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    final byte[] TEST_DATA = "hey".getBytes();    Timing2 timing = new Timing2();    PersistentNode pen = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        pen = new PersistentNode(client, CreateMode.PERSISTENT, false, "/test", TEST_DATA);        pen.debugWaitMsForBackgroundBeforeClose.set(timing.forSleepingABit().milliseconds());        pen.start();        Assert.assertTrue(pen.waitForInitialCreate(timing.milliseconds(), TimeUnit.MILLISECONDS));                client.close();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        byte[] bytes = client.getData().forPath("/test");        Assert.assertEquals(bytes, TEST_DATA);    } finally {        CloseableUtils.closeQuietly(pen);        CloseableUtils.closeQuietly(client);    }}
e6bc86dd3253b2c539cbadb3d62bda38543a1a63bf291a9a8930e653ad30ec76
testQuickClose
public void testQuickClose() throws Exception
{    Timing timing = new Timing();    PersistentNode pen = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        pen = new PersistentNode(client, CreateMode.PERSISTENT, false, "/test/one/two", new byte[0]);        pen.start();        pen.close();        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/test/one/two"));    } finally {        CloseableUtils.closeQuietly(pen);        CloseableUtils.closeQuietly(client);    }}
128395e6d1b609c15f77141d2c0757fe1f1e5fc03134233bc6527060fe3f4ac6
testQuickCloseNodeExists
public void testQuickCloseNodeExists() throws Exception
{    Timing timing = new Timing();    PersistentNode pen = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/test/one/two");        pen = new PersistentNode(client, CreateMode.PERSISTENT, false, "/test/one/two", new byte[0]);        pen.start();        pen.close();        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/test/one/two"));    } finally {        CloseableUtils.closeQuietly(pen);        CloseableUtils.closeQuietly(client);    }}
b632cc0ca682716a31191b62438382cd3a81dc03075b61c60bc4f2c35ce6e23e
testEphemeralSequentialWithProtectionReconnection
public void testEphemeralSequentialWithProtectionReconnection() throws Exception
{    Timing timing = new Timing();    PersistentNode pen = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().creatingParentsIfNeeded().forPath("/test/one");        pen = new PersistentNode(client, CreateMode.EPHEMERAL_SEQUENTIAL, true, "/test/one/two", new byte[0]);        pen.start();        List<String> children = client.getChildren().forPath("/test/one");        System.out.println("children before restart: " + children);        Assert.assertEquals(1, children.size());        server.stop();        timing.sleepABit();        server.restart();        timing.sleepABit();        List<String> childrenAfter = client.getChildren().forPath("/test/one");        System.out.println("children after restart: " + childrenAfter);        Assert.assertEquals(children, childrenAfter, "unexpected znodes: " + childrenAfter);    } finally {        CloseableUtils.closeQuietly(pen);        CloseableUtils.closeQuietly(client);    }}
a80321659a99b352c8cc43cf7a4af27cfb9d2bc91b4f60096aee3b259fe65fe6
setUpClass
public static void setUpClass()
{    System.setProperty("zookeeper.extendedTypesEnabled", "true");}
27681e68ec2a1eb903f955680ebe003ceb3707295c8aad884b692d378c6e37cf
setup
public void setup() throws Exception
{    System.setProperty("znode.container.checkIntervalMs", "1");    super.setup();}
7c529460b940c419ef707bd1846a5575ea1bfc48c129127836c31f0184c1d8fb
teardown
public void teardown() throws Exception
{    System.clearProperty("znode.container.checkIntervalMs");    super.teardown();}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        try (PersistentTtlNode node = new PersistentTtlNode(client, "/test", ttlMs, new byte[0])) {            node.start();            Assert.assertTrue(node.waitForInitialCreate(timing.session(), TimeUnit.MILLISECONDS));            for (int i = 0; i < 5; ++i) {                                Thread.sleep(ttlMs + (ttlMs / 2));                Assert.assertNotNull(client.checkExists().forPath("/test"));            }        }        Assert.assertNotNull(client.checkExists().forPath("/test"));        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/test"));    }}
de448cd3a2389da52e885e4aacdc2947e7f158dc105510ebdc3c35c47471275b
testForcedDeleteOfTouchNode
public void testForcedDeleteOfTouchNode() throws Exception
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        try (PersistentTtlNode node = new PersistentTtlNode(client, "/test", ttlMs, new byte[0])) {            node.start();            Assert.assertTrue(node.waitForInitialCreate(timing.session(), TimeUnit.MILLISECONDS));            for (int i = 0; i < 5; ++i) {                Thread.sleep(ttlMs);                client.delete().quietly().forPath(ZKPaths.makePath("test", PersistentTtlNode.DEFAULT_CHILD_NODE_NAME));            }            timing.sleepABit();            Assert.assertNotNull(client.checkExists().forPath("/test"));        }    }}
9f56faa8114c1086bfa03af67b33aed64ee6abb84f12670f57a007c3da16b7df
testEventsOnParent
public void testEventsOnParent() throws Exception
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        try (PersistentTtlNode node = new PersistentTtlNode(client, "/test", ttlMs, new byte[0])) {            try (PathChildrenCache cache = new PathChildrenCache(client, "/", true)) {                final Semaphore changes = new Semaphore(0);                PathChildrenCacheListener listener = new PathChildrenCacheListener() {                    @Override                    public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                        if ((event.getType() == PathChildrenCacheEvent.Type.CHILD_UPDATED) && "/test".equals(event.getData().getPath())) {                            changes.release();                        }                    }                };                cache.getListenable().addListener(listener);                node.start();                Assert.assertTrue(node.waitForInitialCreate(timing.session(), TimeUnit.MILLISECONDS));                cache.start(BUILD_INITIAL_CACHE);                Assert.assertEquals(changes.availablePermits(), 0);                timing.sleepABit();                Assert.assertEquals(changes.availablePermits(), 0);                client.setData().forPath("/test", "changed".getBytes());                Assert.assertTrue(timing.acquireSemaphore(changes));                timing.sleepABit();                Assert.assertEquals(changes.availablePermits(), 0);            }        }        timing.sleepABit();        Assert.assertNull(client.checkExists().forPath("/test"));    }}
d6477cd5e4da923bd9799bbf8d4db46d7d153fc78458c819b2b186c1ddff908e
childEvent
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    if ((event.getType() == PathChildrenCacheEvent.Type.CHILD_UPDATED) && "/test".equals(event.getData().getPath())) {        changes.release();    }}
fb9459b6e4c891de0e6e18e5fce4df07b3d0bb48f5464459644fbbc8cb903ad4
serialize
public byte[] serialize(TestQueueItem item)
{    return item.str.getBytes();}
8b3426cf24292052823547bfe54319a13e96f564260729835ad03bc77d55ea0a
deserialize
public TestQueueItem deserialize(byte[] bytes)
{    return new TestQueueItem(new String(bytes));}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    int count = 0;    while (!Thread.currentThread().isInterrupted() && (count < itemQty)) {        queue.put(new TestQueueItem(Integer.toString(count + startIndex)));        ++count;    }    return null;}
34e47cbbe9cb7c3c3ecbcb02c6e689241b40228323e58bc498e380593f770d40
serialize
public byte[] serialize(String item)
{    return item.getBytes();}
413066ec61309fb5a0a3f13b5c508fe2f562e0c8ed07c4b23d1f926a48617b3a
deserialize
public String deserialize(byte[] bytes)
{    return new String(bytes);}
88eb518cdeb089aca428f017b47a175a0194c174298672b1b20db431dfb7b0bb
testMulti
public void testMulti() throws Exception
{    final String PATH = "/queue";    final int CLIENT_QTY = 4;    final int MAX_ITEMS = 10;    final int ADD_ITEMS = MAX_ITEMS * 100;    final QueueConsumer<String> consumer = new QueueConsumer<String>() {        @Override        public void consumeMessage(String message) throws Exception {            Thread.sleep(10);        }        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {        }    };    final Timing timing = new Timing();    final ExecutorService executor = Executors.newCachedThreadPool();    ExecutorCompletionService<Void> completionService = new ExecutorCompletionService<Void>(executor);    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        client.create().forPath(PATH);        final CountDownLatch isWaitingLatch = new CountDownLatch(1);        final AtomicBoolean isDone = new AtomicBoolean(false);        final List<Integer> counts = new CopyOnWriteArrayList<Integer>();        final Object lock = new Object();        executor.submit(new Callable<Void>() {            @Override            public Void call() throws Exception {                Watcher watcher = new Watcher() {                    @Override                    public void process(WatchedEvent event) {                        synchronized (lock) {                            lock.notifyAll();                        }                    }                };                while (!Thread.currentThread().isInterrupted() && client.getState() == CuratorFrameworkState.STARTED && !isDone.get()) {                    synchronized (lock) {                        int size = client.getChildren().usingWatcher(watcher).forPath(PATH).size();                        counts.add(size);                        isWaitingLatch.countDown();                        lock.wait();                    }                }                return null;            }        });        isWaitingLatch.await();        for (int i = 0; i < CLIENT_QTY; ++i) {            final int index = i;            completionService.submit(new Callable<Void>() {                @Override                public Void call() throws Exception {                    CuratorFramework client = null;                    DistributedQueue<String> queue = null;                    try {                        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));                        client.start();                        queue = QueueBuilder.builder(client, consumer, serializer, PATH).executor(executor).maxItems(MAX_ITEMS).putInBackground(false).lockPath("/locks").buildQueue();                        queue.start();                        for (int i = 0; i < ADD_ITEMS; ++i) {                            queue.put("" + index + "-" + i);                        }                    } finally {                        CloseableUtils.closeQuietly(queue);                        CloseableUtils.closeQuietly(client);                    }                    return null;                }            });        }        for (int i = 0; i < CLIENT_QTY; ++i) {            completionService.take().get();        }        isDone.set(true);        synchronized (lock) {            lock.notifyAll();        }        for (int count : counts) {            Assert.assertTrue(count <= (MAX_ITEMS * CLIENT_QTY), counts.toString());        }    } finally {        executor.shutdownNow();        CloseableUtils.closeQuietly(client);    }}
38d99404d86d7d232b944bfa8389dd79ca18cb52112e41e5d62364668bd53a3b
consumeMessage
public void consumeMessage(String message) throws Exception
{    Thread.sleep(10);}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    Watcher watcher = new Watcher() {        @Override        public void process(WatchedEvent event) {            synchronized (lock) {                lock.notifyAll();            }        }    };    while (!Thread.currentThread().isInterrupted() && client.getState() == CuratorFrameworkState.STARTED && !isDone.get()) {        synchronized (lock) {            int size = client.getChildren().usingWatcher(watcher).forPath(PATH).size();            counts.add(size);            isWaitingLatch.countDown();            lock.wait();        }    }    return null;}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    synchronized (lock) {        lock.notifyAll();    }}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    CuratorFramework client = null;    DistributedQueue<String> queue = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        queue = QueueBuilder.builder(client, consumer, serializer, PATH).executor(executor).maxItems(MAX_ITEMS).putInBackground(false).lockPath("/locks").buildQueue();        queue.start();        for (int i = 0; i < ADD_ITEMS; ++i) {            queue.put("" + index + "-" + i);        }    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }    return null;}
7e6ef9a15f502c76aa39b9e99c40c2704757556d14668cef0634754950c971d9
testSimple
public void testSimple() throws Exception
{    Timing timing = new Timing();    DistributedQueue<String> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    try {        client.start();        final List<String> messages = new CopyOnWriteArrayList<String>();        final CountDownLatch latch = new CountDownLatch(2);        final Semaphore semaphore = new Semaphore(0);        QueueConsumer<String> consumer = new QueueConsumer<String>() {            @Override            public void consumeMessage(String message) throws Exception {                messages.add(message);                semaphore.acquire();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        queue = QueueBuilder.builder(client, consumer, serializer, "/queue").executor(Executors.newSingleThreadExecutor()).maxItems(1).buildQueue();        queue.start();        QueuePutListener<String> listener = new QueuePutListener<String>() {            @Override            public void putCompleted(String item) {                latch.countDown();            }            @Override            public void putMultiCompleted(MultiItem<String> items) {            }        };        queue.getPutListenerContainer().addListener(listener);                Assert.assertTrue(queue.put("1", timing.milliseconds(), TimeUnit.MILLISECONDS));                Assert.assertTrue(queue.put("2", timing.milliseconds(), TimeUnit.MILLISECONDS));        Assert.assertTrue(timing.awaitLatch(latch));        timing.sleepABit();        Assert.assertFalse(queue.put("3", timing.multiple(.5).milliseconds(), TimeUnit.MILLISECONDS));        semaphore.release(100);        Assert.assertTrue(queue.put("3", timing.milliseconds(), TimeUnit.MILLISECONDS));        Assert.assertTrue(queue.put("4", timing.milliseconds(), TimeUnit.MILLISECONDS));        Assert.assertTrue(queue.put("5", timing.milliseconds(), TimeUnit.MILLISECONDS));        for (int i = 0; i < 5; ++i) {            if (messages.size() == 3) {                break;            }            timing.sleepABit();        }        timing.sleepABit();        Assert.assertEquals(messages, Arrays.asList("1", "2", "3", "4", "5"));    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
38d99404d86d7d232b944bfa8389dd79ca18cb52112e41e5d62364668bd53a3b
consumeMessage
public void consumeMessage(String message) throws Exception
{    messages.add(message);    semaphore.acquire();}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
ef057055b0126b8e0aa114f60700b3965cd2c4474f99590a01959d0f296baca6
putCompleted
public void putCompleted(String item)
{    latch.countDown();}
0c1bbbd6fb53c4ace9f6dea1a062a1d4dbc8f30cfbd696726012b2a020dc8c80
putMultiCompleted
public void putMultiCompleted(MultiItem<String> items)
{}
a243f0a474cab1171b53e96bbb12c828d69fc6ebd47a809d3b7088f6a3b7aa4e
testLateAddition
public void testLateAddition() throws Exception
{    Timing timing = new Timing();    DistributedDelayQueue<Long> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        BlockingQueueConsumer<Long> consumer = new BlockingQueueConsumer<Long>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, new LongSerializer(), "/test").buildDelayQueue();        queue.start();                queue.put(1L, System.currentTimeMillis() + Integer.MAX_VALUE);        Long value = consumer.take(1, TimeUnit.SECONDS);        Assert.assertNull(value);        queue.put(2L, System.currentTimeMillis());        value = consumer.take(timing.seconds(), TimeUnit.SECONDS);        Assert.assertEquals(value, Long.valueOf(2));        value = consumer.take(1, TimeUnit.SECONDS);        Assert.assertNull(value);    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    Timing timing = new Timing();    DistributedDelayQueue<Long> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        BlockingQueueConsumer<Long> consumer = new BlockingQueueConsumer<Long>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, new LongSerializer(), "/test").buildDelayQueue();        queue.start();        queue.put(1L, System.currentTimeMillis() + 1000);        Thread.sleep(100);                Assert.assertEquals(consumer.size(), 0);        Long value = consumer.take(timing.forWaiting().seconds(), TimeUnit.SECONDS);        Assert.assertEquals(value, Long.valueOf(1));    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
7e6ef9a15f502c76aa39b9e99c40c2704757556d14668cef0634754950c971d9
testSimple
public void testSimple() throws Exception
{    final int QTY = 10;    Timing timing = new Timing();    DistributedDelayQueue<Long> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        BlockingQueueConsumer<Long> consumer = new BlockingQueueConsumer<Long>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, new LongSerializer(), "/test").buildDelayQueue();        queue.start();        Random random = new Random();        for (int i = 0; i < QTY; ++i) {            long delay = System.currentTimeMillis() + random.nextInt(100);            queue.put(delay, delay);        }        long lastValue = -1;        for (int i = 0; i < QTY; ++i) {            Long value = consumer.take(timing.forWaiting().seconds(), TimeUnit.SECONDS);            Assert.assertNotNull(value);            Assert.assertTrue(value >= lastValue);            lastValue = value;        }    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
1c5c0cd235db1f995384a1b9fe0e3ffbafad7d84cef83b7558bd76e6249f849f
testSorting
public void testSorting() throws Exception
{    Timing timing = new Timing();        final int QTY = 1000;    final int DELAY_MS = timing.multiple(.1).milliseconds();    DistributedDelayQueue<Long> putQueue = null;    DistributedDelayQueue<Long> getQueue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        putQueue = QueueBuilder.builder(client, null, new LongSerializer(), "/test2").putInBackground(false).buildDelayQueue();        putQueue.start();        Map<Long, Long> data = new HashMap<Long, Long>();                                        long delay = System.currentTimeMillis() + DELAY_MS;        for (long i = 0; i < QTY; ++i) {            data.put(delay, i);                        delay += 1;        }                List<Long> keys = new ArrayList<Long>(data.keySet());        Collections.shuffle(keys);                for (Long key : keys) {            putQueue.put(data.get(key), key);        }        BlockingQueueConsumer<Long> consumer = new BlockingQueueConsumer<Long>(Mockito.mock(ConnectionStateListener.class));        getQueue = QueueBuilder.builder(client, consumer, new LongSerializer(), "/test2").putInBackground(false).buildDelayQueue();        getQueue.start();        long lastValue = -1;        for (int i = 0; i < QTY; ++i) {            Long value = consumer.take(DELAY_MS * 2, TimeUnit.MILLISECONDS);            Assert.assertNotNull(value);            Assert.assertEquals(value, new Long(lastValue + 1));            lastValue = value;        }    } finally {        CloseableUtils.closeQuietly(putQueue);        CloseableUtils.closeQuietly(getQueue);        CloseableUtils.closeQuietly(client);    }}
be9fc29c5bbe28613bc7792e2f8d74e410be2f8c3c68835099fac5ae6a850e10
serialize
public byte[] serialize(Long item)
{    return Long.toString(item).getBytes();}
a919d7668eb812a117fd4089b5d8935b04080a42cdbb0a6260c3d08163df0ece
deserialize
public Long deserialize(byte[] bytes)
{    return Long.parseLong(new String(bytes));}
57693d5a3c704c292c8e3f1d02dcf798b4882a294432d78dc07adb95bf1bfe73
testDeletingWithLock
public void testDeletingWithLock() throws Exception
{    DistributedIdQueue<TestQueueItem> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch consumingLatch = new CountDownLatch(1);        final CountDownLatch waitLatch = new CountDownLatch(1);        QueueConsumer<TestQueueItem> consumer = new QueueConsumer<TestQueueItem>() {            @Override            public void consumeMessage(TestQueueItem message) throws Exception {                consumingLatch.countDown();                waitLatch.await();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).lockPath("/locks").buildIdQueue();        queue.start();        queue.put(new TestQueueItem("test"), "id");                Assert.assertTrue(consumingLatch.await(10, TimeUnit.SECONDS));        Assert.assertEquals(queue.remove("id"), 0);        waitLatch.countDown();    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
7759f19137ded9e75f9794e5d77c240b5c642f37d3d6d063f8a824f1f4945933
consumeMessage
public void consumeMessage(TestQueueItem message) throws Exception
{    consumingLatch.countDown();    waitLatch.await();}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
e941e25a4bc02316d68ee14d64643dbc013e40979189114e45f6474bef7a9ec2
testOrdering
public void testOrdering() throws Exception
{    final int ITEM_QTY = 100;    DistributedIdQueue<TestQueueItem> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        BlockingQueueConsumer<TestQueueItem> consumer = new BlockingQueueConsumer<TestQueueItem>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).buildIdQueue();        queue.start();        List<String> ids = Lists.newArrayList();        for (int i = 0; i < ITEM_QTY; ++i) {            String id = Double.toString(Math.random());            ids.add(id);            queue.put(new TestQueueItem(id), id);        }        int iteration = 0;        while (consumer.size() < ITEM_QTY) {            Assert.assertTrue(++iteration < ITEM_QTY);            Thread.sleep(1000);        }        int i = 0;        for (TestQueueItem item : consumer.getItems()) {            Assert.assertEquals(item.str, ids.get(i++));        }    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
229d31484a6c17d7761f0912848e5d9f0d3f4cad488790608c39fb1733f4fcee
testRequeuingWithLock
public void testRequeuingWithLock() throws Exception
{    DistributedIdQueue<TestQueueItem> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch consumingLatch = new CountDownLatch(1);        QueueConsumer<TestQueueItem> consumer = new QueueConsumer<TestQueueItem>() {            @Override            public void consumeMessage(TestQueueItem message) throws Exception {                consumingLatch.countDown();                                throw new Exception("Consumer failed");            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).lockPath("/locks").buildIdQueue();        queue.start();        queue.put(new TestQueueItem("test"), "id");                Assert.assertTrue(consumingLatch.await(10, TimeUnit.SECONDS));                Thread.sleep(1000);        Assert.assertTrue(queue.debugIsQueued("id"));    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
7759f19137ded9e75f9794e5d77c240b5c642f37d3d6d063f8a824f1f4945933
consumeMessage
public void consumeMessage(TestQueueItem message) throws Exception
{    consumingLatch.countDown();        throw new Exception("Consumer failed");}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
882d0933815f7c582555efedf8df0c7f2e58a71cb859c8d7d23947988ed10c02
testMinItemsBeforeRefresh
public void testMinItemsBeforeRefresh() throws Exception
{    DistributedPriorityQueue<Integer> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final int minItemsBeforeRefresh = 3;        BlockingQueueConsumer<Integer> consumer = new BlockingQueueConsumer<Integer>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, new IntSerializer(), "/test").buildPriorityQueue(minItemsBeforeRefresh);        queue.start();        for (int i = 0; i < 10; ++i) {            queue.put(i, 10 + i);        }        Assert.assertEquals(consumer.take(1, TimeUnit.SECONDS), new Integer(0));                queue.put(1000, 1);        int count = 0;        while (consumer.take(1, TimeUnit.SECONDS) < 1000) {            ++count;        }                Assert.assertTrue(Math.abs(minItemsBeforeRefresh - count) < minItemsBeforeRefresh, String.format("Diff: %d - min: %d", Math.abs(minItemsBeforeRefresh - count), minItemsBeforeRefresh));    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
1c55e254b6cf32d3bf9ed9bd8eb1bf082b56a95b8e63e7a691b2490d0051d21c
testSortingWhileTaking
public void testSortingWhileTaking() throws Exception
{    Timing timing = new Timing();    DistributedPriorityQueue<Integer> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final BlockingQueue<Integer> blockingQueue = new SynchronousQueue<Integer>();        QueueConsumer<Integer> consumer = new QueueConsumer<Integer>() {            @Override            public void consumeMessage(Integer message) throws Exception {                blockingQueue.put(message);            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        queue = QueueBuilder.builder(client, consumer, new IntSerializer(), "/test").buildPriorityQueue(0);        queue.start();        for (int i = 0; i < 10; ++i) {            queue.put(i, 10);        }        Assert.assertEquals(blockingQueue.poll(timing.seconds(), TimeUnit.SECONDS), new Integer(0));        timing.sleepABit();                queue.put(1000, 1);        timing.sleepABit();                Assert.assertEquals(blockingQueue.poll(timing.seconds(), TimeUnit.SECONDS), new Integer(1));        Assert.assertEquals(blockingQueue.poll(timing.seconds(), TimeUnit.SECONDS), new Integer(1000));    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
47a980dcd4abed7900ca5268c040500ddf0a7e556f92f3c55ece63a7e363f281
consumeMessage
public void consumeMessage(Integer message) throws Exception
{    blockingQueue.put(message);}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
32b335adbdd2fb9506f4906de1c2fa06e44d7eaaa33640f9c3db7d3336786cb3
testAdditions
public void testAdditions() throws Exception
{    DistributedPriorityQueue<Integer> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch latch = new CountDownLatch(1);        QueueSerializer<Integer> serializer = new IntSerializer() {            @Override            public Integer deserialize(byte[] bytes) {                                try {                    latch.await();                } catch (InterruptedException e) {                                }                return super.deserialize(bytes);            }        };        BlockingQueueConsumer<Integer> consumer = new BlockingQueueConsumer<Integer>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, serializer, "/test").buildPriorityQueue(1);        queue.start();        for (int i = 0; i < 10; ++i) {            queue.put(10, 10);            if (i == 0) {                queue.put(1, 1);                latch.countDown();            }        }        assertOrdering(consumer, 10);    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
b3004ea0168448fa65a3e83f02f71d352d03ee6b3f35823da1f10dac453bb577
deserialize
public Integer deserialize(byte[] bytes)
{        try {        latch.await();    } catch (InterruptedException e) {        }    return super.deserialize(bytes);}
7e6ef9a15f502c76aa39b9e99c40c2704757556d14668cef0634754950c971d9
testSimple
public void testSimple() throws Exception
{    List<Integer> nums = new ArrayList<Integer>();    Timing timing = new Timing();    DistributedPriorityQueue<Integer> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch hasConsumedLatch = new CountDownLatch(1);        final CountDownLatch okToConsumeLatch = new CountDownLatch(1);        BlockingQueueConsumer<Integer> consumer = new BlockingQueueConsumer<Integer>(Mockito.mock(ConnectionStateListener.class)) {            @Override            public void consumeMessage(Integer message) throws Exception {                hasConsumedLatch.countDown();                okToConsumeLatch.await();                super.consumeMessage(message);            }        };        queue = QueueBuilder.builder(client, consumer, new IntSerializer(), "/test").buildPriorityQueue(0);        queue.start();        nums.add(Integer.MIN_VALUE);                queue.put(Integer.MIN_VALUE, Integer.MIN_VALUE);        Assert.assertTrue(timing.awaitLatch(hasConsumedLatch));        Random random = new Random();        for (int i = 0; i < 100; ++i) {            int priority = random.nextInt();            nums.add(priority);            queue.put(priority, priority);        }        while (        queue.getCache().getData().children.size() < (nums.size() - 1)) {                        timing.sleepABit();        }        okToConsumeLatch.countDown();        assertOrdering(consumer, nums.size());    } catch (AssertionError e) {        StringBuilder message = new StringBuilder(e.getMessage());        for (int i : nums) {            message.append(i).append("\t").append(DistributedPriorityQueue.priorityToString(i)).append("\n");        }        Assert.fail(message.toString());    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
47a980dcd4abed7900ca5268c040500ddf0a7e556f92f3c55ece63a7e363f281
consumeMessage
public void consumeMessage(Integer message) throws Exception
{    hasConsumedLatch.countDown();    okToConsumeLatch.await();    super.consumeMessage(message);}
f2dc87a32fb91c495377f53767f1ef463da3f1b8dfaff833873668a164f02b3d
assertOrdering
private void assertOrdering(BlockingQueueConsumer<Integer> consumer, int qty) throws Exception
{    int previous = 0;    for (int i = 0; i < qty; ++i) {        Integer value = consumer.take(10, TimeUnit.SECONDS);        Assert.assertNotNull(value);        if (i > 0) {            Assert.assertTrue(value >= previous, String.format("Value: (%d:%s) Previous: (%d:%s)", value, DistributedPriorityQueue.priorityToString(value), previous, DistributedPriorityQueue.priorityToString(previous)));        }        previous = value;    }}
0d017937cf4ffaa8a0e8ea3764ca4e5fc4789f04da45d3968dde4f96698da2ab
serialize
public byte[] serialize(Integer item)
{    return Integer.toString(item).getBytes();}
b3004ea0168448fa65a3e83f02f71d352d03ee6b3f35823da1f10dac453bb577
deserialize
public Integer deserialize(byte[] bytes)
{    return Integer.parseInt(new String(bytes));}
b1182b72a201922e402baa8e93be861138418973b5703f4d13f2fa6b155f86c8
testRetryAfterFailure_Curator56
public void testRetryAfterFailure_Curator56() throws Exception
{    /*            https://issues.apache.org/jira/browse/CURATOR-56            This tests against ever growing node name bug         */    DistributedQueue<TestQueueItem> queue = null;    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final int RETRY_COUNT = 1;        final CountDownLatch retryCounter = new CountDownLatch(RETRY_COUNT + 1);        final List<String> names = new ArrayList<String>();        QueueConsumer<TestQueueItem> consumer = new QueueConsumer<TestQueueItem>() {            @Override            public void consumeMessage(TestQueueItem messsage) throws Exception {                List<String> queueItems = client.getChildren().forPath(QUEUE_PATH);                names.add(queueItems.get(0));                if (retryCounter.getCount() > 1) {                    retryCounter.countDown();                    throw new Exception("Something went wrong");                } else {                    retryCounter.countDown();                }            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).lockPath("/lock").buildQueue();        queue.start();        queue.put(new TestQueueItem("test"));        retryCounter.await(10, TimeUnit.SECONDS);        Assert.assertEquals(retryCounter.getCount(), 0, "Queue item was not consumed. Retry counter is " + retryCounter.getCount());        Assert.assertEquals(names.size(), 2);        Assert.assertEquals(names.get(0).length(), names.get(1).length(), "name1: " + names.get(0) + " - " + "name2: " + names.get(1));    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
8bcae432e638f71159b6939168075f36515793114c852e0a6c31ae792cdff282
consumeMessage
public void consumeMessage(TestQueueItem messsage) throws Exception
{    List<String> queueItems = client.getChildren().forPath(QUEUE_PATH);    names.add(queueItems.get(0));    if (retryCounter.getCount() > 1) {        retryCounter.countDown();        throw new Exception("Something went wrong");    } else {        retryCounter.countDown();    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
18bd56983c2792b9e523c15aab9774f7c1e2404e8bc259c4b58fc1b331d607cb
testCustomExecutor
public void testCustomExecutor() throws Exception
{    final int ITERATIONS = 1000;    Timing timing = new Timing();    DistributedQueue<String> queue = null;    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final CountDownLatch latch = new CountDownLatch(ITERATIONS);        QueueConsumer<String> consumer = new QueueConsumer<String>() {            @Override            public void consumeMessage(String message) throws Exception {                latch.countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        QueueSerializer<String> serializer = new QueueSerializer<String>() {            @Override            public byte[] serialize(String item) {                return item.getBytes();            }            @Override            public String deserialize(byte[] bytes) {                return new String(bytes);            }        };        Executor executor = Executors.newCachedThreadPool();        final Set<String> used = Sets.newHashSet();        final Set<String> doubleUsed = Sets.newHashSet();        queue = new DistributedQueue<String>(client, consumer, serializer, QUEUE_PATH, QueueBuilder.defaultThreadFactory, executor, Integer.MAX_VALUE, false, "/lock", QueueBuilder.NOT_SET, true, timing.milliseconds()) {            @SuppressWarnings("SimplifiableConditionalExpression")            @Override            protected boolean processWithLockSafety(String itemNode, DistributedQueue.ProcessType type) throws Exception {                if (used.contains(itemNode)) {                    doubleUsed.add(itemNode);                } else {                    used.add(itemNode);                }                return (client.getState() == CuratorFrameworkState.STARTED) ? super.processWithLockSafety(itemNode, type) : false;            }        };        queue.start();        for (int i = 0; i < ITERATIONS; ++i) {            queue.put(Integer.toString(i));        }        Assert.assertTrue(timing.awaitLatch(latch));        Assert.assertTrue(doubleUsed.size() == 0, doubleUsed.toString());    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
38d99404d86d7d232b944bfa8389dd79ca18cb52112e41e5d62364668bd53a3b
consumeMessage
public void consumeMessage(String message) throws Exception
{    latch.countDown();}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
34e47cbbe9cb7c3c3ecbcb02c6e689241b40228323e58bc498e380593f770d40
serialize
public byte[] serialize(String item)
{    return item.getBytes();}
413066ec61309fb5a0a3f13b5c508fe2f562e0c8ed07c4b23d1f926a48617b3a
deserialize
public String deserialize(byte[] bytes)
{    return new String(bytes);}
c6cbe0a5712ae52a87b7d319a47cc59c7438f44b98d99a4c77f88ef64388e124
processWithLockSafety
protected boolean processWithLockSafety(String itemNode, DistributedQueue.ProcessType type) throws Exception
{    if (used.contains(itemNode)) {        doubleUsed.add(itemNode);    } else {        used.add(itemNode);    }    return (client.getState() == CuratorFrameworkState.STARTED) ? super.processWithLockSafety(itemNode, type) : false;}
c1597ac0a1de3e55b55a857d2123e05b01d2f9a94ac20e648d8700a131cb756c
testPutListener
public void testPutListener() throws Exception
{    final int itemQty = 10;    DistributedQueue<TestQueueItem> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        BlockingQueueConsumer<TestQueueItem> consumer = new BlockingQueueConsumer<TestQueueItem>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).buildQueue();        queue.start();        QueueTestProducer producer = new QueueTestProducer(queue, itemQty, 0);        final AtomicInteger listenerCalls = new AtomicInteger(0);        QueuePutListener<TestQueueItem> listener = new QueuePutListener<TestQueueItem>() {            @Override            public void putCompleted(TestQueueItem item) {                listenerCalls.incrementAndGet();            }            @Override            public void putMultiCompleted(MultiItem<TestQueueItem> items) {            }        };        queue.getPutListenerContainer().addListener(listener);        ExecutorService service = Executors.newCachedThreadPool();        service.submit(producer);        int iteration = 0;        while (consumer.size() < itemQty) {            Assert.assertTrue(++iteration < 10);            Thread.sleep(1000);        }        int i = 0;        for (TestQueueItem item : consumer.getItems()) {            Assert.assertEquals(item.str, Integer.toString(i++));        }        Assert.assertEquals(listenerCalls.get(), itemQty);    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
3344cd0095a91c1e8ea556da5d0391bd0bbcf90772b0e32a63a890648655c8a4
putCompleted
public void putCompleted(TestQueueItem item)
{    listenerCalls.incrementAndGet();}
467cb109a860bd101ac7d90239b8b407059ff765c84326395c1979aea61263e3
putMultiCompleted
public void putMultiCompleted(MultiItem<TestQueueItem> items)
{}
26d10c6d89a8cba942d7358df4bd62ade509defcace2b26eaeadc4ccc8049008
testErrorMode
public void testErrorMode() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final AtomicReference<CountDownLatch> latch = new AtomicReference<CountDownLatch>(new CountDownLatch(1));        final AtomicInteger count = new AtomicInteger(0);        QueueConsumer<TestQueueItem> consumer = new QueueConsumer<TestQueueItem>() {            @Override            public void consumeMessage(TestQueueItem message) throws Exception {                if (count.incrementAndGet() < 2) {                    throw new Exception();                }                latch.get().countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        DistributedQueue<TestQueueItem> queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).lockPath("/locks").buildQueue();        try {            queue.start();            TestQueueItem item = new TestQueueItem("1");            queue.put(item);            Assert.assertTrue(timing.awaitLatch(latch.get()));            Assert.assertEquals(count.get(), 2);            queue.setErrorMode(ErrorMode.DELETE);            count.set(0);            latch.set(new CountDownLatch(1));            item = new TestQueueItem("1");            queue.put(item);                        Assert.assertFalse(latch.get().await(5, TimeUnit.SECONDS));            Assert.assertEquals(count.get(), 1);        } finally {            queue.close();        }    } finally {        client.close();    }}
7759f19137ded9e75f9794e5d77c240b5c642f37d3d6d063f8a824f1f4945933
consumeMessage
public void consumeMessage(TestQueueItem message) throws Exception
{    if (count.incrementAndGet() < 2) {        throw new Exception();    }    latch.get().countDown();}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
2f9c93a36c75638bed1abfc98f8545d9ebe163315ad68816a2cbc01f868d5113
testNoDuplicateProcessing
public void testNoDuplicateProcessing() throws Exception
{    final int itemQty = 1000;    final int consumerQty = 4;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new ExponentialBackoffRetry(100, 3));    client.start();    try {        DistributedQueue<TestQueueItem> producerQueue = QueueBuilder.builder(client, null, serializer, QUEUE_PATH).buildQueue();        try {            producerQueue.start();            for (int i = 0; i < itemQty; ++i) {                TestQueueItem item = new TestQueueItem(Integer.toString(i));                producerQueue.put(item);            }            producerQueue.flushPuts(timing.multiple(2).seconds(), TimeUnit.SECONDS);        } finally {            producerQueue.close();        }    } finally {        client.close();    }    final Set<String> consumedMessages = Sets.newHashSet();    final Set<String> duplicateMessages = Sets.newHashSet();    final CountDownLatch latch = new CountDownLatch(itemQty);    List<DistributedQueue<TestQueueItem>> consumers = Lists.newArrayList();    List<CuratorFramework> consumerClients = Lists.newArrayList();    try {        final QueueConsumer<TestQueueItem> ourQueue = new QueueConsumer<TestQueueItem>() {            @Override            public void consumeMessage(TestQueueItem message) {                synchronized (consumedMessages) {                    if (consumedMessages.contains(message.str)) {                        duplicateMessages.add(message.str);                    }                    consumedMessages.add(message.str);                }                latch.countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        for (int i = 0; i < consumerQty; ++i) {            CuratorFramework thisClient = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            consumerClients.add(thisClient);            thisClient.start();            DistributedQueue<TestQueueItem> thisConsumer = QueueBuilder.builder(thisClient, ourQueue, serializer, QUEUE_PATH).lockPath("/a/locks").buildQueue();            consumers.add(thisConsumer);        }        for (DistributedQueue<TestQueueItem> consumer : consumers) {            consumer.start();        }        timing.awaitLatch(latch);        Assert.assertTrue(duplicateMessages.size() == 0, duplicateMessages.toString());    } finally {        for (DistributedQueue<TestQueueItem> consumer : consumers) {            CloseableUtils.closeQuietly(consumer);        }        for (CuratorFramework curatorFramework : consumerClients) {            CloseableUtils.closeQuietly(curatorFramework);        }    }}
e75f5a7894317d4aa4487b01c86ac86fe4461cb7d0308d13e92b6943c279c962
consumeMessage
public void consumeMessage(TestQueueItem message)
{    synchronized (consumedMessages) {        if (consumedMessages.contains(message.str)) {            duplicateMessages.add(message.str);        }        consumedMessages.add(message.str);    }    latch.countDown();}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
6a7dd591f145784777551084df85d6f62fd4520b0339289a8927d940cc6f63c0
testSafetyWithCrash
public void testSafetyWithCrash() throws Exception
{    final int itemQty = 100;    DistributedQueue<TestQueueItem> producerQueue = null;    DistributedQueue<TestQueueItem> consumerQueue1 = null;    DistributedQueue<TestQueueItem> consumerQueue2 = null;    CuratorFramework producerClient = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    CuratorFramework consumerClient1 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    CuratorFramework consumerClient2 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        producerClient.start();        consumerClient1.start();        consumerClient2.start();        ExecutorService service = Executors.newCachedThreadPool();                {            producerQueue = QueueBuilder.builder(producerClient, null, serializer, QUEUE_PATH).buildQueue();            producerQueue.start();            QueueTestProducer producer = new QueueTestProducer(producerQueue, itemQty, 0);            service.submit(producer);        }        final Set<TestQueueItem> takenItems = Sets.newTreeSet();        final Set<TestQueueItem> takenItemsForConsumer1 = Sets.newTreeSet();        final Set<TestQueueItem> takenItemsForConsumer2 = Sets.newTreeSet();        final AtomicReference<TestQueueItem> thrownItemFromConsumer1 = new AtomicReference<TestQueueItem>(null);                {            final QueueConsumer<TestQueueItem> ourQueue = new QueueConsumer<TestQueueItem>() {                @Override                public void consumeMessage(TestQueueItem message) throws Exception {                    synchronized (takenItems) {                        if (takenItems.size() > 10) {                            thrownItemFromConsumer1.set(message);                                                        throw new Exception("dummy");                        }                    }                    addToTakenItems(message, takenItems, itemQty);                    synchronized (takenItemsForConsumer1) {                        takenItemsForConsumer1.add(message);                    }                    Thread.sleep((long) (Math.random() * 5));                }                @Override                public void stateChanged(CuratorFramework client, ConnectionState newState) {                }            };            consumerQueue1 = QueueBuilder.builder(consumerClient1, ourQueue, serializer, QUEUE_PATH).lockPath("/a/locks").buildQueue();            consumerQueue1.start();        }                {            final QueueConsumer<TestQueueItem> ourQueue = new QueueConsumer<TestQueueItem>() {                @Override                public void consumeMessage(TestQueueItem message) throws Exception {                    addToTakenItems(message, takenItems, itemQty);                    synchronized (takenItemsForConsumer2) {                        takenItemsForConsumer2.add(message);                    }                    Thread.sleep((long) (Math.random() * 5));                }                @Override                public void stateChanged(CuratorFramework client, ConnectionState newState) {                }            };            consumerQueue2 = QueueBuilder.builder(consumerClient2, ourQueue, serializer, QUEUE_PATH).lockPath("/a/locks").buildQueue();            consumerQueue2.start();        }        synchronized (takenItems) {            while (takenItems.size() < itemQty) {                takenItems.wait(1000);            }        }        int i = 0;        for (TestQueueItem item : takenItems) {            Assert.assertEquals(item.str, Integer.toString(i++));        }        Assert.assertNotNull(thrownItemFromConsumer1.get());        Assert.assertTrue((takenItemsForConsumer2.contains(thrownItemFromConsumer1.get())));        Assert.assertTrue(Sets.intersection(takenItemsForConsumer1, takenItemsForConsumer2).size() == 0);    } finally {        CloseableUtils.closeQuietly(producerQueue);        CloseableUtils.closeQuietly(consumerQueue1);        CloseableUtils.closeQuietly(consumerQueue2);        CloseableUtils.closeQuietly(producerClient);        CloseableUtils.closeQuietly(consumerClient1);        CloseableUtils.closeQuietly(consumerClient2);    }}
7759f19137ded9e75f9794e5d77c240b5c642f37d3d6d063f8a824f1f4945933
consumeMessage
public void consumeMessage(TestQueueItem message) throws Exception
{    synchronized (takenItems) {        if (takenItems.size() > 10) {            thrownItemFromConsumer1.set(message);                        throw new Exception("dummy");        }    }    addToTakenItems(message, takenItems, itemQty);    synchronized (takenItemsForConsumer1) {        takenItemsForConsumer1.add(message);    }    Thread.sleep((long) (Math.random() * 5));}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
7759f19137ded9e75f9794e5d77c240b5c642f37d3d6d063f8a824f1f4945933
consumeMessage
public void consumeMessage(TestQueueItem message) throws Exception
{    addToTakenItems(message, takenItems, itemQty);    synchronized (takenItemsForConsumer2) {        takenItemsForConsumer2.add(message);    }    Thread.sleep((long) (Math.random() * 5));}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
84bdca3a34fd64bc431b2f769610109b5b26dc4b0ec0ceaaadfeed864afa8062
addToTakenItems
private void addToTakenItems(TestQueueItem message, Set<TestQueueItem> takenItems, int itemQty)
{    synchronized (takenItems) {        takenItems.add(message);        if (takenItems.size() > itemQty) {            takenItems.notifyAll();        }    }}
509d5960f77a6692ecfb7dde59671801676b89d2993bcd8614fee54c368bdc7a
testSafetyBasic
public void testSafetyBasic() throws Exception
{    final int itemQty = 10;    DistributedQueue<TestQueueItem> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        final BlockingQueueConsumer<TestQueueItem> consumer = new BlockingQueueConsumer<TestQueueItem>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).lockPath("/a/locks").buildQueue();        queue.start();        QueueTestProducer producer = new QueueTestProducer(queue, itemQty, 0);        ExecutorService service = Executors.newCachedThreadPool();        service.submit(producer);        final CountDownLatch latch = new CountDownLatch(1);        service.submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                for (int i = 0; i < itemQty; ++i) {                    TestQueueItem item = consumer.take();                    Assert.assertEquals(item.str, Integer.toString(i));                }                latch.countDown();                return null;            }        });        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    for (int i = 0; i < itemQty; ++i) {        TestQueueItem item = consumer.take();        Assert.assertEquals(item.str, Integer.toString(i));    }    latch.countDown();    return null;}
14635102933661044d53cc777df52b5daccb68880f165a72e38bf4303a146904
testPutMulti
public void testPutMulti() throws Exception
{    final int itemQty = 100;    DistributedQueue<TestQueueItem> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        BlockingQueueConsumer<TestQueueItem> consumer = new BlockingQueueConsumer<TestQueueItem>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).buildQueue();        queue.start();        MultiItem<TestQueueItem> items = new MultiItem<TestQueueItem>() {            private int index = 0;            @Override            public TestQueueItem nextItem() throws Exception {                if (index >= itemQty) {                    return null;                }                return new TestQueueItem(Integer.toString(index++));            }        };        queue.putMulti(items);        for (int i = 0; i < itemQty; ++i) {            TestQueueItem queueItem = consumer.take(1, TimeUnit.SECONDS);            Assert.assertNotNull(queueItem);            Assert.assertEquals(queueItem, new TestQueueItem(Integer.toString(i)));        }    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
3a6b69319389e6992dc07d1f1b44949232edfcbbb07b098941f5b1de61a40bf3
nextItem
public TestQueueItem nextItem() throws Exception
{    if (index >= itemQty) {        return null;    }    return new TestQueueItem(Integer.toString(index++));}
3e192ed7fb6ef236d2d199cbbeb3c8695d5a4fe94cfdb3cab6e3153b396393de
testMultiPutterSingleGetter
public void testMultiPutterSingleGetter() throws Exception
{    final int itemQty = 100;    DistributedQueue<TestQueueItem> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        BlockingQueueConsumer<TestQueueItem> consumer = new BlockingQueueConsumer<TestQueueItem>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).buildQueue();        queue.start();        QueueTestProducer producer1 = new QueueTestProducer(queue, itemQty / 2, 0);        QueueTestProducer producer2 = new QueueTestProducer(queue, ((itemQty + 1) / 2), itemQty / 2);        ExecutorService service = Executors.newCachedThreadPool();        service.submit(producer1);        service.submit(producer2);        int iteration = 0;        while (consumer.size() < itemQty) {            Assert.assertTrue(++iteration < 10);            Thread.sleep(1000);        }        List<TestQueueItem> items = consumer.getItems();                Assert.assertEquals(com.google.common.collect.Sets.<TestQueueItem>newHashSet(items).size(), items.size());    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
0760ba24d344de6ca403849bbfe47180c03a8e92af2bcb4dcf5323208a64e190
testFlush
public void testFlush() throws Exception
{    final Timing timing = new Timing();    final CountDownLatch latch = new CountDownLatch(1);    DistributedQueue<TestQueueItem> queue = null;    final CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    client.start();    try {        final AtomicBoolean firstTime = new AtomicBoolean(true);        queue = new DistributedQueue<TestQueueItem>(client, null, serializer, "/test", new ThreadFactoryBuilder().build(), MoreExecutors.directExecutor(), 10, true, null, QueueBuilder.NOT_SET, true, 0) {            @Override            void internalCreateNode(final String path, final byte[] bytes, final BackgroundCallback callback) throws Exception {                if (firstTime.compareAndSet(true, false)) {                    Executors.newSingleThreadExecutor().submit(new Callable<Object>() {                        @Override                        public Object call() throws Exception {                            latch.await();                            timing.sleepABit();                            client.create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).inBackground(callback).forPath(path, bytes);                            return null;                        }                    });                } else {                    super.internalCreateNode(path, bytes, callback);                }            }        };        queue.start();        queue.put(new TestQueueItem("1"));        Assert.assertFalse(queue.flushPuts(timing.forWaiting().seconds(), TimeUnit.SECONDS));        latch.countDown();        Assert.assertTrue(queue.flushPuts(timing.forWaiting().seconds(), TimeUnit.SECONDS));    } finally {        if (latch.getCount() > 0) {            latch.countDown();        }        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
816771565ecc43e5151296c1e3cfabd257d89fe197799de0b533a1e33d069eab
internalCreateNode
 void internalCreateNode(final String path, final byte[] bytes, final BackgroundCallback callback) throws Exception
{    if (firstTime.compareAndSet(true, false)) {        Executors.newSingleThreadExecutor().submit(new Callable<Object>() {            @Override            public Object call() throws Exception {                latch.await();                timing.sleepABit();                client.create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).inBackground(callback).forPath(path, bytes);                return null;            }        });    } else {        super.internalCreateNode(path, bytes, callback);    }}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    latch.await();    timing.sleepABit();    client.create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).inBackground(callback).forPath(path, bytes);    return null;}
7e6ef9a15f502c76aa39b9e99c40c2704757556d14668cef0634754950c971d9
testSimple
public void testSimple() throws Exception
{    final int itemQty = 10;    DistributedQueue<TestQueueItem> queue = null;    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        BlockingQueueConsumer<TestQueueItem> consumer = new BlockingQueueConsumer<TestQueueItem>(Mockito.mock(ConnectionStateListener.class));        queue = QueueBuilder.builder(client, consumer, serializer, QUEUE_PATH).buildQueue();        queue.start();        QueueTestProducer producer = new QueueTestProducer(queue, itemQty, 0);        ExecutorService service = Executors.newCachedThreadPool();        service.submit(producer);        int iteration = 0;        while (consumer.size() < itemQty) {            Assert.assertTrue(++iteration < 10);            Thread.sleep(1000);        }        int i = 0;        for (TestQueueItem item : consumer.getItems()) {            Assert.assertEquals(item.str, Integer.toString(i++));        }    } finally {        CloseableUtils.closeQuietly(queue);        CloseableUtils.closeQuietly(client);    }}
b332327d63b7f6da33be104b3b76157a8818bea6bbb3564d87b7e242a2800992
compareTo
public int compareTo(TestQueueItem rhs)
{    if (this == rhs) {        return 0;    }    int val = Integer.parseInt(str);    int rhsVal = Integer.parseInt(rhs.str);    int diff = val - rhsVal;    return (diff < 0) ? -1 : ((diff > 0) ? 1 : 0);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    TestQueueItem that = (TestQueueItem) o;    return str.equals(that.str);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return str.hashCode();}
1dd3b1ae8fd751b2110d87143cb59a1f406c1c970a698bfa05051f5b3235fbfd
testDistribution
public void testDistribution() throws Exception
{    final int threshold = 100;    final int factor = 10;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    QueueSharder<String, DistributedQueue<String>> sharder = null;    try {        client.start();        final CountDownLatch latch = new CountDownLatch(1);        QueueConsumer<String> consumer = new QueueConsumer<String>() {            @Override            public void consumeMessage(String message) throws Exception {                latch.await();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        QueueAllocator<String, DistributedQueue<String>> distributedQueueAllocator = makeAllocator(consumer);        QueueSharderPolicies policies = QueueSharderPolicies.builder().newQueueThreshold(threshold).thresholdCheckMs(1).build();        sharder = new QueueSharder<String, DistributedQueue<String>>(client, distributedQueueAllocator, "/queues", "/leader", policies);        sharder.start();        for (int i = 0; i < (factor * threshold); ++i) {            sharder.getQueue().put(Integer.toString(i));            Thread.sleep(5);        }        timing.forWaiting().sleepABit();        SummaryStatistics statistics = new SummaryStatistics();        for (String path : sharder.getQueuePaths()) {            int numChildren = client.checkExists().forPath(path).getNumChildren();            Assert.assertTrue(numChildren > 0);            Assert.assertTrue(numChildren >= (threshold * .1));            statistics.addValue(numChildren);        }        latch.countDown();        Assert.assertTrue(statistics.getMean() >= (threshold * .9));    } finally {                timing.sleepABit();        CloseableUtils.closeQuietly(sharder);        CloseableUtils.closeQuietly(client);    }}
38d99404d86d7d232b944bfa8389dd79ca18cb52112e41e5d62364668bd53a3b
consumeMessage
public void consumeMessage(String message) throws Exception
{    latch.await();}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
091cd1a0ca9f7929091124ea2825d80ed3057cb528b84d4a091f03fb88258944
testSharderWatchSync
public void testSharderWatchSync() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    final BlockingQueueConsumer<String> consumer = makeConsumer(null);    QueueAllocator<String, DistributedQueue<String>> distributedQueueAllocator = makeAllocator(consumer);    QueueSharderPolicies policies = QueueSharderPolicies.builder().newQueueThreshold(2).thresholdCheckMs(1).build();    QueueSharder<String, DistributedQueue<String>> sharder1 = new QueueSharder<String, DistributedQueue<String>>(client, distributedQueueAllocator, "/queues", "/leader", policies);    QueueSharder<String, DistributedQueue<String>> sharder2 = new QueueSharder<String, DistributedQueue<String>>(client, distributedQueueAllocator, "/queues", "/leader", policies);    try {        client.start();        sharder1.start();        sharder2.start();        for (int i = 0; i < 20; ++i) {            sharder1.getQueue().put(Integer.toString(i));        }        timing.sleepABit();        Assert.assertTrue((sharder1.getShardQty() > 1) || (sharder2.getShardQty() > 1));        timing.forWaiting().sleepABit();        Assert.assertEquals(sharder1.getShardQty(), sharder2.getShardQty());    } finally {                timing.sleepABit();        CloseableUtils.closeQuietly(sharder1);        CloseableUtils.closeQuietly(sharder2);        CloseableUtils.closeQuietly(client);    }}
4e1e6b6b3d643f9d8ecb77ad04dc33a7beb87215b4ccd016b16f290191d18daf
testSimpleDistributedQueue
public void testSimpleDistributedQueue() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    final CountDownLatch latch = new CountDownLatch(1);    final BlockingQueueConsumer<String> consumer = makeConsumer(latch);    QueueAllocator<String, DistributedQueue<String>> distributedQueueAllocator = makeAllocator(consumer);    QueueSharderPolicies policies = QueueSharderPolicies.builder().newQueueThreshold(2).thresholdCheckMs(1).build();    QueueSharder<String, DistributedQueue<String>> sharder = new QueueSharder<String, DistributedQueue<String>>(client, distributedQueueAllocator, "/queues", "/leader", policies);    try {        client.start();        sharder.start();        sharder.getQueue().put("one");        sharder.getQueue().put("two");        sharder.getQueue().put("three");        sharder.getQueue().put("four");        latch.countDown();        timing.sleepABit();        sharder.getQueue().put("five");        sharder.getQueue().put("six");        sharder.getQueue().put("seven");        sharder.getQueue().put("eight");        timing.sleepABit();        Assert.assertTrue(sharder.getShardQty() > 1);        Set<String> consumed = Sets.newHashSet();        for (int i = 0; i < 8; ++i) {            String s = consumer.take(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS);            Assert.assertNotNull(s);            consumed.add(s);        }        Assert.assertEquals(consumed, Sets.newHashSet("one", "two", "three", "four", "five", "six", "seven", "eight"));        int shardQty = sharder.getShardQty();        sharder.close();                sharder = new QueueSharder<String, DistributedQueue<String>>(client, distributedQueueAllocator, "/queues", "/leader", policies);        sharder.start();        Assert.assertEquals(sharder.getShardQty(), shardQty);    } finally {        CloseableUtils.closeQuietly(sharder);        CloseableUtils.closeQuietly(client);    }}
9fe76466f6458f41fc6208b9a53e0fe3c3eaf3c2684b83a748249515b44dc476
makeAllocator
private QueueAllocator<String, DistributedQueue<String>> makeAllocator(final QueueConsumer<String> consumer)
{    final QueueSerializer<String> serializer = new QueueSerializer<String>() {        @Override        public byte[] serialize(String item) {            return item.getBytes();        }        @Override        public String deserialize(byte[] bytes) {            return new String(bytes);        }    };    return new QueueAllocator<String, DistributedQueue<String>>() {        @Override        public DistributedQueue<String> allocateQueue(CuratorFramework client, String queuePath) {            return QueueBuilder.<String>builder(client, consumer, serializer, queuePath).buildQueue();        }    };}
34e47cbbe9cb7c3c3ecbcb02c6e689241b40228323e58bc498e380593f770d40
serialize
public byte[] serialize(String item)
{    return item.getBytes();}
413066ec61309fb5a0a3f13b5c508fe2f562e0c8ed07c4b23d1f926a48617b3a
deserialize
public String deserialize(byte[] bytes)
{    return new String(bytes);}
8af6d48526ae83ae5980c9e9a72b4f8e9f4de47f8c1845781110f74fdac9c75e
allocateQueue
public DistributedQueue<String> allocateQueue(CuratorFramework client, String queuePath)
{    return QueueBuilder.<String>builder(client, consumer, serializer, queuePath).buildQueue();}
ab32f316f28dda02e4d2a51a2f8aff338928ff3ecd3bad7f8f0d11dddf0a74c0
makeConsumer
private BlockingQueueConsumer<String> makeConsumer(final CountDownLatch latch)
{    ConnectionStateListener connectionStateListener = new ConnectionStateListener() {        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {        }    };    return new BlockingQueueConsumer<String>(connectionStateListener) {        @Override        public void consumeMessage(String message) throws Exception {            if (latch != null) {                latch.await();            }            super.consumeMessage(message);        }    };}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
38d99404d86d7d232b944bfa8389dd79ca18cb52112e41e5d62364668bd53a3b
consumeMessage
public void consumeMessage(String message) throws Exception
{    if (latch != null) {        latch.await();    }    super.consumeMessage(message);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        for (int i = 0; i < ITEM_COUNT; i++) {            processItem(i);            Thread.sleep(sleepMillis);        }    } catch (Exception e) {        throw new RuntimeException(e);    }}
3a4880ecaf9c7082514f481a6b19ba4e9eadec52be7c1a0aff3c460328bd1bee
testHangFromContainerLoss
public void testHangFromContainerLoss() throws Exception
{        server.close();    System.setProperty("znode.container.checkIntervalMs", "100");    server = new TestingServer();    Timing timing = new Timing().multiple(.1);    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        ExecutorService executor = Executors.newFixedThreadPool(2);        executor.execute(new QueueUser(client, timing.milliseconds()) {            @Override            protected void processItem(int itemNumber) throws Exception {                System.out.println("Offering item");                queue.offer(new byte[] { (byte) itemNumber });            }        });        executor.execute(new QueueUser(client, timing.multiple(.5).milliseconds()) {            @Override            protected void processItem(int itemNumber) throws Exception {                System.out.println("Taking item " + itemNumber);                byte[] item = queue.take();                if (item == null) {                    throw new IllegalStateException("Null result for item " + itemNumber);                }                System.out.println("Got item " + item[0]);            }        });        executor.shutdown();        Assert.assertTrue(executor.awaitTermination((QueueUser.ITEM_COUNT * 2) * timing.milliseconds(), TimeUnit.MILLISECONDS));    } finally {        CloseableUtils.closeQuietly(client);        System.clearProperty("znode.container.checkIntervalMs");    }}
b849c0dd656dd3b6462997468cd350a8137526e87d8b8980f5df06b283b318bd
processItem
protected void processItem(int itemNumber) throws Exception
{    System.out.println("Offering item");    queue.offer(new byte[] { (byte) itemNumber });}
b849c0dd656dd3b6462997468cd350a8137526e87d8b8980f5df06b283b318bd
processItem
protected void processItem(int itemNumber) throws Exception
{    System.out.println("Taking item " + itemNumber);    byte[] item = queue.take();    if (item == null) {        throw new IllegalStateException("Null result for item " + itemNumber);    }    System.out.println("Got item " + item[0]);}
b86b4faf71aa3083ee0b1355a17d73cfc18145670a9d005b4965f54bb37b91a5
testPollWithTimeout
public void testPollWithTimeout() throws Exception
{    CuratorFramework[] clients = null;    try {        String dir = "/testOffer1";        final int num_clients = 1;        clients = new CuratorFramework[num_clients];        SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];        for (int i = 0; i < clients.length; i++) {            clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            clients[i].start();            queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);        }        Assert.assertNull(queueHandles[0].poll(3, TimeUnit.SECONDS));    } finally {        closeAll(clients);    }}
fb86be436b12b823a95c55b585cf574b8b4a55d9e1984b04c1c2e976a03a610a
testOffer1
public void testOffer1() throws Exception
{    CuratorFramework[] clients = null;    try {        String dir = "/testOffer1";        String testString = "Hello World";        final int num_clients = 1;        clients = new CuratorFramework[num_clients];        SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];        for (int i = 0; i < clients.length; i++) {            clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            clients[i].start();            queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);        }        queueHandles[0].offer(testString.getBytes());        byte[] dequeuedBytes = queueHandles[0].remove();        assertEquals(new String(dequeuedBytes), testString);    } finally {        closeAll(clients);    }}
bac5623698b42fbef2040445f7bd0af3f6a1c6566bbe0ec076a42f1338b050c0
testOffer2
public void testOffer2() throws Exception
{    CuratorFramework[] clients = null;    try {        String dir = "/testOffer2";        String testString = "Hello World";        final int num_clients = 2;        clients = new CuratorFramework[num_clients];        SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];        for (int i = 0; i < clients.length; i++) {            clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            clients[i].start();            queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);        }        queueHandles[0].offer(testString.getBytes());        byte[] dequeuedBytes = queueHandles[1].remove();        assertEquals(new String(dequeuedBytes), testString);    } finally {        closeAll(clients);    }}
75139bde671c668e118079835fe428ed266aa5def22fcb8eeae18b7ec1d4cc47
testTake1
public void testTake1() throws Exception
{    CuratorFramework[] clients = null;    try {        String dir = "/testTake1";        String testString = "Hello World";        final int num_clients = 1;        clients = new CuratorFramework[num_clients];        SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];        for (int i = 0; i < clients.length; i++) {            clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            clients[i].start();            queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);        }        queueHandles[0].offer(testString.getBytes());        byte[] dequeuedBytes = queueHandles[0].take();        assertEquals(new String(dequeuedBytes), testString);    } finally {        closeAll(clients);    }}
2457ecc20a8b3d45a3fdbb5d560b090f4718247c819cfb771a6e8b081253d08c
testRemova1
public void testRemova1() throws Exception
{    CuratorFramework[] clients = null;    try {        String dir = "/testRemove1";        final int num_clients = 1;        clients = new CuratorFramework[num_clients];        SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];        for (int i = 0; i < clients.length; i++) {            clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            clients[i].start();            queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);        }        try {            queueHandles[0].remove();        } catch (NoSuchElementException e) {            return;        }        assertTrue(false);    } finally {        closeAll(clients);    }}
4a6b6dd0fd1889739a23cf4d6596d4667a55978e690ab64fd88c0e5fdded3c38
createNremoveMtest
public void createNremoveMtest(String dir, int n, int m) throws Exception
{    CuratorFramework[] clients = null;    try {        String testString = "Hello World";        final int num_clients = 2;        clients = new CuratorFramework[num_clients];        SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];        for (int i = 0; i < clients.length; i++) {            clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            clients[i].start();            queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);        }        for (int i = 0; i < n; i++) {            String offerString = testString + i;            queueHandles[0].offer(offerString.getBytes());        }        byte[] data = null;        for (int i = 0; i < m; i++) {            data = queueHandles[1].remove();        }        assertEquals(new String(data), testString + (m - 1));    } finally {        closeAll(clients);    }}
83eee548f0511390c9d51d6fafbb328ac06e2d082de471add7800e7443f702a8
testRemove2
public void testRemove2() throws Exception
{    createNremoveMtest("/testRemove2", 10, 2);}
97d3dfb67858cc6fc0494128346588bd90d114e9558173bad1fb61d537aac673
testRemove3
public void testRemove3() throws Exception
{    createNremoveMtest("/testRemove3", 1000, 1000);}
4c7ad0d0c360216216aba9c3b438650b8c9b4fcb249163080cac4b5c20272009
createNremoveMelementTest
public void createNremoveMelementTest(String dir, int n, int m) throws Exception
{    CuratorFramework[] clients = null;    try {        String testString = "Hello World";        final int num_clients = 2;        clients = new CuratorFramework[num_clients];        SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];        for (int i = 0; i < clients.length; i++) {            clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            clients[i].start();            queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);        }        for (int i = 0; i < n; i++) {            String offerString = testString + i;            queueHandles[0].offer(offerString.getBytes());        }        for (int i = 0; i < m; i++) {            queueHandles[1].remove();        }        assertEquals(new String(queueHandles[1].element()), testString + m);    } finally {        closeAll(clients);    }}
23f62eb695b2d32bfe1bd46e8d13976bf37d3c22cff01f0a48f893cccd83cb5f
testElement1
public void testElement1() throws Exception
{    createNremoveMelementTest("/testElement1", 1, 0);}
98bcc95168f917296effb390a62e8f8c860ea1ff8c7c97add84f47b001b1eff9
testElement2
public void testElement2() throws Exception
{    createNremoveMelementTest("/testElement2", 10, 2);}
4276f9a3cef633175204a1b8ef19eb901188b8a8944b6afd9aff2804f1cbed7d
testElement3
public void testElement3() throws Exception
{    createNremoveMelementTest("/testElement3", 1000, 500);}
eceb3bc1c88705cde8cf68d7691dd5853fb93c00061d71cf04d5ba912c0f6370
testElement4
public void testElement4() throws Exception
{    createNremoveMelementTest("/testElement4", 1000, 1000 - 1);}
e57ce4880554172a7afef03b840ae898977c2c86ae4da50cea1d7198d7bf23ea
testTakeWait1
public void testTakeWait1() throws Exception
{    CuratorFramework[] clients = null;    try {        String dir = "/testTakeWait1";        final String testString = "Hello World";        final int num_clients = 1;        clients = new CuratorFramework[num_clients];        final SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];        for (int i = 0; i < clients.length; i++) {            clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));            clients[i].start();            queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);        }        final byte[][] takeResult = new byte[1][];        Thread takeThread = new Thread() {            public void run() {                try {                    takeResult[0] = queueHandles[0].take();                } catch (Exception e) {                                }            }        };        takeThread.start();        Thread.sleep(1000);        Thread offerThread = new Thread() {            public void run() {                try {                    queueHandles[0].offer(testString.getBytes());                } catch (Exception e) {                                }            }        };        offerThread.start();        offerThread.join();        takeThread.join();        assertTrue(takeResult[0] != null);        assertEquals(new String(takeResult[0]), testString);    } finally {        closeAll(clients);    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        takeResult[0] = queueHandles[0].take();    } catch (Exception e) {        }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        queueHandles[0].offer(testString.getBytes());    } catch (Exception e) {        }}
99691e7d085adf6350ba7d6cc5d1821aae3bfb5279063236544512639ea8dbf9
testTakeWait2
public void testTakeWait2() throws Exception
{    String dir = "/testTakeWait2";    final String testString = "Hello World";    final int num_clients = 1;    final CuratorFramework[] clients = new CuratorFramework[num_clients];    final SimpleDistributedQueue[] queueHandles = new SimpleDistributedQueue[num_clients];    for (int i = 0; i < clients.length; i++) {        clients[i] = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        clients[i].start();        queueHandles[i] = new SimpleDistributedQueue(clients[i], dir);    }    int num_attempts = 2;    for (int i = 0; i < num_attempts; i++) {        final byte[][] takeResult = new byte[1][];        final String threadTestString = testString + i;        Thread takeThread = new Thread() {            public void run() {                try {                    takeResult[0] = queueHandles[0].take();                } catch (Exception e) {                                }            }        };        takeThread.start();        Thread.sleep(1000);        Thread offerThread = new Thread() {            public void run() {                try {                    queueHandles[0].offer(threadTestString.getBytes());                } catch (Exception e) {                                }            }        };        offerThread.start();        offerThread.join();        takeThread.join();        assertTrue(takeResult[0] != null);        assertEquals(new String(takeResult[0]), threadTestString);    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        takeResult[0] = queueHandles[0].take();    } catch (Exception e) {        }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        queueHandles[0].offer(threadTestString.getBytes());    } catch (Exception e) {        }}
1d2b39a393537c9ae41620f997d7ddd7c4389ec745e66f7740479301b40e859d
closeAll
private void closeAll(CuratorFramework[] clients)
{    if (clients != null) {        for (CuratorFramework c : clients) {            CloseableUtils.closeQuietly(c);        }    }}
89162f1899817695695f7c127a7aa0b16124a6d708fa01e36866e30ea60a6f43
testMultiClients
public void testMultiClients() throws Exception
{    final int CLIENT_QTY = 5;    List<Future<List<Integer>>> futures = Lists.newArrayList();    final List<CuratorFramework> clients = new CopyOnWriteArrayList<CuratorFramework>();    final List<SharedCount> counts = new CopyOnWriteArrayList<SharedCount>();    try {        final CountDownLatch startLatch = new CountDownLatch(CLIENT_QTY);        final Semaphore semaphore = new Semaphore(0);        ExecutorService service = Executors.newCachedThreadPool(new ThreadFactoryBuilder().setNameFormat("Test-%d").build());        for (int i = 0; i < CLIENT_QTY; ++i) {            Future<List<Integer>> future = service.submit(new Callable<List<Integer>>() {                @Override                public List<Integer> call() throws Exception {                    final List<Integer> countList = Lists.newArrayList();                    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));                    clients.add(client);                    client.start();                                        client.checkExists().forPath("/");                    SharedCount count = new SharedCount(client, "/count", 10);                    counts.add(count);                    final CountDownLatch latch = new CountDownLatch(1);                    count.addListener(new SharedCountListener() {                        @Override                        public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception {                            if (newCount < 0) {                                latch.countDown();                            } else {                                countList.add(newCount);                            }                            semaphore.release();                        }                        @Override                        public void stateChanged(CuratorFramework client, ConnectionState newState) {                        }                    });                    count.start();                    startLatch.countDown();                    latch.await();                    return countList;                }            });            futures.add(future);        }        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        clients.add(client);        client.start();                client.checkExists().forPath("/");        Assert.assertTrue(startLatch.await(10, TimeUnit.SECONDS));        SharedCount count = new SharedCount(client, "/count", 10);        counts.add(count);        count.start();        List<Integer> countList = Lists.newArrayList();        Random random = new Random();        for (int i = 0; i < 100; ++i) {            Thread.sleep(random.nextInt(10));            int next = random.nextInt(100);            countList.add(next);            count.setCount(next);            Assert.assertTrue(semaphore.tryAcquire(CLIENT_QTY, 10, TimeUnit.SECONDS));        }        count.setCount(-1);        for (Future<List<Integer>> future : futures) {            List<Integer> thisCountList = future.get();            Assert.assertEquals(thisCountList, countList);        }    } finally {        for (SharedCount count : counts) {            CloseableUtils.closeQuietly(count);        }        for (CuratorFramework client : clients) {            TestCleanState.closeAndTestClean(client);        }    }}
8856f58b06dfa5379097228e2a35bd8381aa164825bef9c4c6fe9b0191114961
call
public List<Integer> call() throws Exception
{    final List<Integer> countList = Lists.newArrayList();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    clients.add(client);    client.start();        client.checkExists().forPath("/");    SharedCount count = new SharedCount(client, "/count", 10);    counts.add(count);    final CountDownLatch latch = new CountDownLatch(1);    count.addListener(new SharedCountListener() {        @Override        public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception {            if (newCount < 0) {                latch.countDown();            } else {                countList.add(newCount);            }            semaphore.release();        }        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {        }    });    count.start();    startLatch.countDown();    latch.await();    return countList;}
6cb5a4c33a23ad3a87a85d3f5e1c50afe030ad793b4527cb8e6e4c65c96a7900
countHasChanged
public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception
{    if (newCount < 0) {        latch.countDown();    } else {        countList.add(newCount);    }    semaphore.release();}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
7e6ef9a15f502c76aa39b9e99c40c2704757556d14668cef0634754950c971d9
testSimple
public void testSimple() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    SharedCount count = new SharedCount(client, "/count", 0);    try {        client.start();        count.start();        final CountDownLatch setLatch = new CountDownLatch(3);        SharedCountListener listener = new SharedCountListener() {            @Override            public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception {                setLatch.countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                        }        };        count.addListener(listener);        Assert.assertTrue(count.trySetCount(1));        timing.sleepABit();        Assert.assertTrue(count.trySetCount(2));        timing.sleepABit();        Assert.assertTrue(count.trySetCount(10));        timing.sleepABit();        Assert.assertEquals(count.getCount(), 10);        Assert.assertTrue(new Timing().awaitLatch(setLatch));    } finally {        CloseableUtils.closeQuietly(count);        TestCleanState.closeAndTestClean(client);    }}
6cb5a4c33a23ad3a87a85d3f5e1c50afe030ad793b4527cb8e6e4c65c96a7900
countHasChanged
public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception
{    setLatch.countDown();}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
e6ab8c91af1ef379a7943662349e23883ddc6275ad12e9cfcdb1d716a021dfd9
testSimpleVersioned
public void testSimpleVersioned() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    SharedCount count = new SharedCount(client, "/count", 0);    client.start();    try {        count.start();        VersionedValue<Integer> current = count.getVersionedValue();        Assert.assertEquals(current.getVersion(), 0);        Assert.assertTrue(count.trySetCount(current, 1));        current = count.getVersionedValue();        Assert.assertEquals(current.getVersion(), 1);        Assert.assertEquals(count.getCount(), 1);        Assert.assertTrue(count.trySetCount(current, 5));        current = count.getVersionedValue();        Assert.assertEquals(current.getVersion(), 2);        Assert.assertEquals(count.getCount(), 5);        Assert.assertTrue(count.trySetCount(current, 10));        current = count.getVersionedValue();        Assert.assertEquals(current.getVersion(), 3);        Assert.assertEquals(count.getCount(), 10);                Assert.assertFalse(count.trySetCount(new VersionedValue<Integer>(3, 20), 7));                Assert.assertFalse(count.trySetCount(new VersionedValue<Integer>(10, 10), 7));                client.setData().forPath("/count", SharedCount.toBytes(88));        Assert.assertFalse(count.trySetCount(current, 234));    } finally {        CloseableUtils.closeQuietly(count);        TestCleanState.closeAndTestClean(client);    }}
503c9e104b593e38bcba239a958936e7d95a1aab8d7bd446c791abea85649d22
testMultiClientVersioned
public void testMultiClientVersioned() throws Exception
{    Timing timing = new Timing();    CuratorFramework client1 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    CuratorFramework client2 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    SharedCount count1 = new SharedCount(client1, "/count", 0);    SharedCount count2 = new SharedCount(client2, "/count", 0);    try {        client1.start();        client2.start();        count1.start();        count2.start();        VersionedValue<Integer> versionedValue = count1.getVersionedValue();        Assert.assertTrue(count1.trySetCount(versionedValue, 10));        timing.sleepABit();        versionedValue = count2.getVersionedValue();        Assert.assertTrue(count2.trySetCount(versionedValue, 20));        timing.sleepABit();        final CountDownLatch setLatch = new CountDownLatch(2);        SharedCountListener listener = new SharedCountListener() {            @Override            public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception {                setLatch.countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                        }        };        count1.addListener(listener);        VersionedValue<Integer> versionedValue1 = count1.getVersionedValue();        VersionedValue<Integer> versionedValue2 = count2.getVersionedValue();        Assert.assertTrue(count2.trySetCount(versionedValue2, 30));        Assert.assertFalse(count1.trySetCount(versionedValue1, 40));        versionedValue1 = count1.getVersionedValue();        Assert.assertTrue(count1.trySetCount(versionedValue1, 40));        Assert.assertTrue(timing.awaitLatch(setLatch));    } finally {        CloseableUtils.closeQuietly(count2);        CloseableUtils.closeQuietly(count1);        TestCleanState.closeAndTestClean(client2);        TestCleanState.closeAndTestClean(client1);    }}
6cb5a4c33a23ad3a87a85d3f5e1c50afe030ad793b4527cb8e6e4c65c96a7900
countHasChanged
public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception
{    setLatch.countDown();}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
122408a48a7c085a316acde4b3042d7a9951a8dec8b6550c37edca16932c853b
testMultiClientDifferentSeed
public void testMultiClientDifferentSeed() throws Exception
{    CuratorFramework client1 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    CuratorFramework client2 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    SharedCount count1 = new SharedCount(client1, "/count", 10);    SharedCount count2 = new SharedCount(client2, "/count", 20);    try {        client1.start();        client2.start();        count1.start();        count2.start();        Assert.assertEquals(count1.getCount(), 10);        Assert.assertEquals(count2.getCount(), 10);    } finally {        CloseableUtils.closeQuietly(count2);        CloseableUtils.closeQuietly(count1);        CloseableUtils.closeQuietly(client2);        CloseableUtils.closeQuietly(client1);    }}
932328a18e751e79aa0e87955f46d3857f40bb3cb3e8c1875142032511669640
testDisconnectEventOnWatcherDoesNotRetry
public void testDisconnectEventOnWatcherDoesNotRetry() throws Exception
{    final CountDownLatch gotSuspendEvent = new CountDownLatch(1);    CuratorFramework curatorFramework = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryNTimes(10, 1000));    curatorFramework.start();    curatorFramework.blockUntilConnected();    SharedCount sharedCount = new SharedCount(curatorFramework, "/count", 10);    sharedCount.start();    curatorFramework.getConnectionStateListenable().addListener(new ConnectionStateListener() {        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {            if (newState == ConnectionState.SUSPENDED) {                gotSuspendEvent.countDown();            }        }    });    try {        server.stop();                Assert.assertTrue(gotSuspendEvent.await(5, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(sharedCount);        TestCleanState.closeAndTestClean(curatorFramework);    }}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.SUSPENDED) {        gotSuspendEvent.countDown();    }}
5a03e27b933d44f37029c9a5581d4df270998caf1453240a7dccf7eab84c8f8d
testDisconnectReconnectEventDoesNotFireValueWatcher
public void testDisconnectReconnectEventDoesNotFireValueWatcher() throws Exception
{    final CountDownLatch gotSuspendEvent = new CountDownLatch(1);    final CountDownLatch gotChangeEvent = new CountDownLatch(1);    final CountDownLatch getReconnectEvent = new CountDownLatch(1);    final AtomicInteger numChangeEvents = new AtomicInteger(0);    CuratorFramework curatorFramework = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryNTimes(10, 500));    curatorFramework.start();    curatorFramework.blockUntilConnected();    SharedCount sharedCount = new SharedCount(curatorFramework, "/count", 10);    sharedCount.addListener(new SharedCountListener() {        @Override        public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception {            numChangeEvents.incrementAndGet();            gotChangeEvent.countDown();        }        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {            if (newState == ConnectionState.SUSPENDED) {                gotSuspendEvent.countDown();            } else if (newState == ConnectionState.RECONNECTED) {                getReconnectEvent.countDown();            }        }    });    sharedCount.start();    try {        sharedCount.setCount(11);        Assert.assertTrue(gotChangeEvent.await(2, TimeUnit.SECONDS));        server.stop();        Assert.assertTrue(gotSuspendEvent.await(2, TimeUnit.SECONDS));        server.restart();        Assert.assertTrue(getReconnectEvent.await(2, TimeUnit.SECONDS));        Assert.assertEquals(numChangeEvents.get(), 1);        sharedCount.trySetCount(sharedCount.getVersionedValue(), 12);                final CountDownLatch flushDone = new CountDownLatch(1);        curatorFramework.getData().inBackground(new BackgroundCallback() {            @Override            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception {                flushDone.countDown();            }        }).forPath("/count");        flushDone.await(5, TimeUnit.SECONDS);                        Assert.assertEquals(numChangeEvents.get(), 3);    } finally {        CloseableUtils.closeQuietly(sharedCount);        TestCleanState.closeAndTestClean(curatorFramework);    }}
6cb5a4c33a23ad3a87a85d3f5e1c50afe030ad793b4527cb8e6e4c65c96a7900
countHasChanged
public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception
{    numChangeEvents.incrementAndGet();    gotChangeEvent.countDown();}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.SUSPENDED) {        gotSuspendEvent.countDown();    } else if (newState == ConnectionState.RECONNECTED) {        getReconnectEvent.countDown();    }}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    flushDone.countDown();}
88f922cde1f5bf5e667c80e46e248664fb2b0101f468ac40ea56b40953add295
testDisconnectReconnectWithMultipleClients
public void testDisconnectReconnectWithMultipleClients() throws Exception
{    Timing timing = new Timing();    CuratorFramework curatorFramework1 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryNTimes(10, 500));    CuratorFramework curatorFramework2 = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryNTimes(10, 500));    curatorFramework1.start();        curatorFramework1.checkExists().forPath("/");    curatorFramework2.start();        curatorFramework2.checkExists().forPath("/");    final String sharedCountPath = "/count";    final int initialCount = 10;    SharedCount sharedCount1 = new SharedCount(curatorFramework1, sharedCountPath, initialCount);    SharedCount sharedCountWithFaultyWatcher = createSharedCountWithFaultyWatcher(curatorFramework2, sharedCountPath, initialCount);    class MySharedCountListener implements SharedCountListener {        final public Phaser gotSuspendEvent = new Phaser(1);        final public Phaser gotChangeEvent = new Phaser(1);        final public Phaser getReconnectEvent = new Phaser(1);        final public AtomicInteger numChangeEvents = new AtomicInteger(0);        @Override        public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception {            numChangeEvents.incrementAndGet();            gotChangeEvent.arrive();        }        @Override        public void stateChanged(CuratorFramework client, ConnectionState newState) {            if (newState == ConnectionState.SUSPENDED) {                gotSuspendEvent.arrive();            } else if (newState == ConnectionState.RECONNECTED) {                getReconnectEvent.arrive();            }        }    }    MySharedCountListener listener1 = new MySharedCountListener();    sharedCount1.addListener(listener1);    sharedCount1.start();    MySharedCountListener listener2 = new MySharedCountListener();    sharedCountWithFaultyWatcher.addListener(listener2);    try {        sharedCount1.setCount(12);        Assert.assertEquals(listener1.gotChangeEvent.awaitAdvanceInterruptibly(0, timing.seconds(), TimeUnit.SECONDS), 1);        Assert.assertEquals(sharedCount1.getCount(), 12);        Assert.assertEquals(sharedCountWithFaultyWatcher.getCount(), 10);                sharedCountWithFaultyWatcher.start();        for (int i = 0; i < 10; i++) {            sharedCount1.setCount(13 + i);            Assert.assertEquals(sharedCount1.getCount(), 13 + i);            server.restart();            Assert.assertEquals(listener2.getReconnectEvent.awaitAdvanceInterruptibly(i, timing.forWaiting().seconds(), TimeUnit.SECONDS), i + 1);                                    Assert.assertEquals(listener2.gotChangeEvent.awaitAdvanceInterruptibly(i, timing.forWaiting().seconds(), TimeUnit.SECONDS), i + 1);            Assert.assertEquals(sharedCountWithFaultyWatcher.getCount(), 13 + i);        }    } finally {        CloseableUtils.closeQuietly(sharedCount1);        CloseableUtils.closeQuietly(curatorFramework1);        CloseableUtils.closeQuietly(sharedCountWithFaultyWatcher);        CloseableUtils.closeQuietly(curatorFramework2);    }}
6cb5a4c33a23ad3a87a85d3f5e1c50afe030ad793b4527cb8e6e4c65c96a7900
countHasChanged
public void countHasChanged(SharedCountReader sharedCount, int newCount) throws Exception
{    numChangeEvents.incrementAndGet();    gotChangeEvent.arrive();}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if (newState == ConnectionState.SUSPENDED) {        gotSuspendEvent.arrive();    } else if (newState == ConnectionState.RECONNECTED) {        getReconnectEvent.arrive();    }}
448b82936123552604f258f089284f8119c184eed75f73d8b341a61aba659142
createSharedCountWithFaultyWatcher
private SharedCount createSharedCountWithFaultyWatcher(CuratorFramework curatorFramework, String path, int val)
{    final CuratorWatcher faultyWatcher = new CuratorWatcher() {        @Override        public void process(WatchedEvent event) throws Exception {                }    };    class FaultySharedValue extends SharedValue {        public FaultySharedValue(CuratorFramework client, String path, byte[] seedValue) {            super(client.newWatcherRemoveCuratorFramework(), path, seedValue, faultyWatcher);        }    }    ;    final SharedValue faultySharedValue = new FaultySharedValue(curatorFramework, path, SharedCount.toBytes(val));    class FaultySharedCount extends SharedCount {        public FaultySharedCount(CuratorFramework client, String path, int val) {            super(client, path, faultySharedValue);        }    }    ;    return new FaultySharedCount(curatorFramework, path, val);}
a4803fca4797306b4f772a40c997680043dc08b35469407056bd5b28cf26096b
process
public void process(WatchedEvent event) throws Exception
{}
556b077bcd52e77d6c75695a7a942caf7eccf839863fe91cf1cd1338c496789f
beforeSuite
public void beforeSuite(ITestContext context)
{    IInvokedMethodListener2 methodListener2 = new IInvokedMethodListener2() {        @Override        public void beforeInvocation(IInvokedMethod method, ITestResult testResult) {            method.getTestMethod().setRetryAnalyzer(BaseClassForTests.this::retry);        }        @Override        public void beforeInvocation(IInvokedMethod method, ITestResult testResult, ITestContext context) {            beforeInvocation(method, testResult);        }        @Override        public void afterInvocation(IInvokedMethod method, ITestResult testResult, ITestContext context) {                }        @Override        public void afterInvocation(IInvokedMethod method, ITestResult testResult) {                }    };    context.getSuite().addListener(methodListener2);}
5f6a9c8574286b58c1c3e427f8ed08118e9c38600ab92772cd2616164b388ec3
beforeInvocation
public void beforeInvocation(IInvokedMethod method, ITestResult testResult)
{    method.getTestMethod().setRetryAnalyzer(BaseClassForTests.this::retry);}
765bba532f8df710f470c36ec3ac5dea8567a69bb1c3811906eee782c424e593
beforeInvocation
public void beforeInvocation(IInvokedMethod method, ITestResult testResult, ITestContext context)
{    beforeInvocation(method, testResult);}
976df2aadaa9bf7ca4ff4b5ddea84f908a1203a9ac860edc90ae04bdf5d9e843
afterInvocation
public void afterInvocation(IInvokedMethod method, ITestResult testResult, ITestContext context)
{}
0efbc88aed8b8a00b1c66ea0819112d949463c07be01bdc468b5a6c841415d6f
afterInvocation
public void afterInvocation(IInvokedMethod method, ITestResult testResult)
{}
27681e68ec2a1eb903f955680ebe003ceb3707295c8aad884b692d378c6e37cf
setup
public void setup() throws Exception
{    if (INTERNAL_PROPERTY_DONT_LOG_CONNECTION_ISSUES != null) {        System.setProperty(INTERNAL_PROPERTY_DONT_LOG_CONNECTION_ISSUES, "true");    }    System.setProperty(INTERNAL_PROPERTY_REMOVE_WATCHERS_IN_FOREGROUND, "true");    System.setProperty(INTERNAL_PROPERTY_VALIDATE_NAMESPACE_WATCHER_MAP_EMPTY, "true");    createServer();}
1406dfd71462b2fdd6019a36acc306c73e06589bbfd9b1cf36ee6f19ef0d691f
createServer
protected void createServer() throws Exception
{    while (server == null) {        try {            server = new TestingServer();        } catch (BindException e) {            System.err.println("Getting bind exception - retrying to allocate server");            server = null;        }    }}
7c529460b940c419ef707bd1846a5575ea1bfc48c129127836c31f0184c1d8fb
teardown
public void teardown() throws Exception
{    System.clearProperty(INTERNAL_PROPERTY_VALIDATE_NAMESPACE_WATCHER_MAP_EMPTY);    System.clearProperty(INTERNAL_PROPERTY_REMOVE_WATCHERS_IN_FOREGROUND);    if (server != null) {        try {            server.close();        } catch (IOException e) {            e.printStackTrace();        } finally {            server = null;        }    }}
d9e3ff7011829b124ae7bbcb8f2f9a49b13c888574699609dc9729fe787fa89b
retry
private boolean retry(ITestResult result)
{    if (result.isSuccess() || isRetrying.get()) {        isRetrying.set(false);        return false;    }    result.setStatus(ITestResult.SKIP);    if (result.getThrowable() != null) {        log.error("Retrying 1 time", result.getThrowable());    } else {        log.error("Retrying 1 time");    }    isRetrying.set(true);    return true;}
933ff911f832ff2a798c905d29dbaad2046d43daf6534c7488979bcf6271bf14
milliseconds
public int milliseconds()
{    return (int) TimeUnit.MILLISECONDS.convert(value, unit);}
4efa9e8bc922415586b665bf0245bf7f2d852fa6e4d20625d333659a70003e07
seconds
public int seconds()
{    return (int) value;}
dca00bb967d7e4c411c0c08e0ed2240324c8276e1c656522569a82317a44844d
awaitLatch
public boolean awaitLatch(CountDownLatch latch)
{    Timing2 m = forWaiting();    try {        return latch.await(m.value, m.unit);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }    return false;}
f8aeb37e67eb9d1407295c60428c858fa3a36e068695b09bfe3d4370a3b89454
takeFromQueue
public T takeFromQueue(BlockingQueue<T> queue) throws Exception
{    Timing2 m = forWaiting();    try {        T value = queue.poll(m.value, m.unit);        if (value == null) {            throw new TimeoutException("Timed out trying to take from queue");        }        return value;    } catch (InterruptedException e) {        Thread.currentThread().interrupt();        throw e;    }}
2d8805601cd0e6a96f0fb884420e3f976b1e0ad5bb85421d6c93f8f2d6803699
acquireSemaphore
public boolean acquireSemaphore(Semaphore semaphore)
{    Timing2 m = forWaiting();    try {        return semaphore.tryAcquire(m.value, m.unit);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }    return false;}
cd3995ffaacb2de6a77450887360fcff4f17d4be72e46633c3e59a1d9415e6c6
acquireSemaphore
public boolean acquireSemaphore(Semaphore semaphore, int n)
{    Timing2 m = forWaiting();    try {        return semaphore.tryAcquire(n, m.value, m.unit);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }    return false;}
8ad449212ad9e50bee488990378e1b73905e3efb577f25f38d960c8798ee35a3
multiple
public Timing2 multiple(double n)
{    return new Timing2((int) (value * n), unit);}
6d280d9e57cacc2d582d4e57155fced18f14e605c3d7f96a54a56760f850376e
multiple
public Timing2 multiple(double n, int waitingMultiple)
{    return new Timing2((int) (value * n), unit, waitingMultiple);}
8ed2c7c37559a75c8131ebcb825fc946007f6b4608c7e477684c2b99c37beed0
forWaiting
public Timing2 forWaiting()
{    return multiple(waitingMultiple);}
9bbe0d8a3765311620b957fc6c06e7e13a0bf9951e2e72e94d9866ebb97e636e
forSessionSleep
public Timing2 forSessionSleep()
{    return multiple(SESSION_SLEEP_MULTIPLE, 1);}
763c3f4ff52537ace440460d2bed119dd4a8476ca27ea09d6376caffb882b910
forSleepingABit
public Timing2 forSleepingABit()
{    return multiple(.25);}
41dd61dad03ccee9f9f896db8c133233a1e84a63caa31bdf12a40bc81e6afad0
sleepABit
public void sleepABit() throws InterruptedException
{    forSleepingABit().sleep();}
32c17180a48fc3cf1b00298f345b254d4c931c60c46763ed3514b9845c3660c3
sleep
public void sleep() throws InterruptedException
{    unit.sleep(value);}
ba4a961ef4b59b305d9d60282a3415f8e5788db8c52d12c7b578476c2d827c5f
session
public int session()
{    return multiple(SESSION_MULTIPLE).milliseconds();}
42e5f2cef2315723574724e0377df70b17bc6b41ea83375115511ebd786d6143
connection
public int connection()
{    return milliseconds();}
96a4163060b91d0f42c61283e1a938322805cd24ad782187261d66a68bfa910d
getWaitingMultiple
private static Integer getWaitingMultiple()
{    return Integer.getInteger("timing-waiting-multiple", DEFAULT_WAITING_MULTIPLE);}
82def45654685b2e728abd6dcec2d7fbeae3e979bf09f3d74a7ae99266e9f94e
intercept
public List<IMethodInstance> intercept(List<IMethodInstance> methods, ITestContext context)
{    if (!Compatibility.isZK34()) {        return methods;    }    List<IMethodInstance> filteredMethods = new ArrayList<>();    for (IMethodInstance method : methods) {        if (!isInGroup(method.getMethod().getGroups())) {            filteredMethods.add(method);        }    }    return filteredMethods;}
b37db7a8b624b4d76c1d8e56ee6caadf1c6ef638b1e8b37b306724e0faef20be
isInGroup
private boolean isInGroup(String[] groups)
{    return (groups != null) && Arrays.asList(groups).contains(zk35Group);}
e9c3caf379dc3b6867a9679539193c6c41da3f10e6c996d4e258fca7f548ec5c
isZK34
public static boolean isZK34()
{    return false;}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    delegate.shutdown();}
4c45ee4d9eb054ebd067dd5874751b7bfc3a2cf2eb45214279db5bb2815019b3
shutdownNow
public List<Runnable> shutdownNow()
{    return delegate.shutdownNow();}
de15ce9b0ad9865c54a52f6c64043391e5b29feda58b57b6926cb3d5b0e7aeb8
isShutdown
public boolean isShutdown()
{    return delegate.isShutdown();}
a7705ddf21784ead75c5c8f226430ffc5611289fd8b0395c0e703726e9e0c05f
isTerminated
public boolean isTerminated()
{    return delegate.isTerminated();}
0914a9f004463fdc403eb8812a27433de347d542e24b38c16435c5081f5e4e41
awaitTermination
public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException
{    return delegate.awaitTermination(timeout, unit);}
0c9a2082d04366d5173651e3ee908cf5d09e3fa1d265b153da1f2006a1515398
submit
public Future<T> submit(Callable<T> task)
{    return delegate.submit(task);}
ef7c9b83668b995908c09d87c68f0079c04c722951c05789aa091f1710cdfa46
submit
public Future<T> submit(Runnable task, T result)
{    return delegate.submit(task, result);}
c396ff386382681638e60c72135a572c6c403a789206b179996c80813af791ee
submit
public Future<?> submit(Runnable task)
{    return delegate.submit(task);}
727fb861e00e7f6bc0f268daf107d6616666b1ddf184b1bae2ce9384d51b53a4
invokeAll
public List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException
{    return delegate.invokeAll(tasks);}
93a68fb322a325de7997c2f638866bb16e3bf30c29e3711c441e497b2bc6aa97
invokeAll
public List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException
{    return delegate.invokeAll(tasks, timeout, unit);}
1ad70e4ec92dd23735e8d3575755adbfe269e14b8a2d7b90af971ba52718045d
invokeAny
public T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException
{    return delegate.invokeAny(tasks);}
98ee1f153c90d828d49a12b93ea148d5b0cd12a1e30f7f7a0e966d462387d201
invokeAny
public T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException
{    return delegate.invokeAny(tasks, timeout, unit);}
ad84c13a4b48a71ac9cc53c212690071850fba3a6bebe8ae99378f76de235551
execute
public void execute(Runnable command)
{    delegate.execute(command);}
03a6d3c2ce3bba2636d22ceeb5961a6bcb370a07dfd4b928af14fe416bc1f4eb
deleteRecursively
public static void deleteRecursively(File file) throws IOException
{    if (file.isDirectory()) {        deleteDirectoryContents(file);    }    if (!file.delete()) {        log.error("Failed to delete " + file);    }}
5c3028ce7fd47517fa75f0660cf0a8745da9540d5396eec68e2191eeb786d994
deleteDirectoryContents
public static void deleteDirectoryContents(File directory) throws IOException
{    Preconditions.checkArgument(directory.isDirectory(), "Not a directory: %s", directory);    File[] files = directory.listFiles();    if (files == null) {        log.warn("directory.listFiles() returned null for: " + directory);        return;    }    for (File file : files) {        deleteRecursively(file);    }}
8e7da54307031e0736f6b18ed02c5c6d9323d4d92f9e77d2bcbcddd08287839e
execute
public synchronized void execute(Runnable command)
{    executeCalled = true;    super.execute(command);}
410f1f9e4db9a9c00ed0f1118d6d795144344823ec48812c620152bc7b458f54
isExecuteCalled
public synchronized boolean isExecuteCalled()
{    return executeCalled;}
104ffca64738f11b759e062cc2a788edf21ac103d61f1a011721b0279da959bc
setExecuteCalled
public synchronized void setExecuteCalled(boolean executeCalled)
{    this.executeCalled = executeCalled;}
8b14883896e9dbd16e433d8992a7e3362db19048b3a1baf1298796fbe5db7f6d
reset
public static void reset()
{    nextServerId.set(1);}
4956763aafdd7f1eb836c1d40cedadca82a821c66455f8ed25875bec8b56d62b
newInstanceSpec
public static InstanceSpec newInstanceSpec()
{    return new InstanceSpec(null, -1, -1, -1, true, -1, -1, -1);}
6649214dd3caaac0a4635a597c79990423ebe3d95ef5bf6def9a217283e509e3
getRandomPort
public static int getRandomPort()
{    ServerSocket server = null;    try {        server = new ServerSocket(0);        return server.getLocalPort();    } catch (IOException e) {        throw new Error(e);    } finally {        if (server != null) {            try {                server.close();            } catch (IOException ignore) {                        }        }    }}
f2db77df2a60720035a8211d757d0443bdc24bdc61d9a64a8dc597a0396302b7
getServerId
public int getServerId()
{    return serverId;}
0c6f852848d96284139eae5591d6adcfa3c5255734f907730dc7bf936bdc9364
getDataDirectory
public File getDataDirectory()
{    return dataDirectory;}
eedb587f68470407e820d49bf6bb9be573d78555382d32a0743e8fea8ced15d6
getPort
public int getPort()
{    return port;}
3624ce633146fb20859deefb93010183e99b5d513b6b0c2303dbc367c9ca4ff1
getElectionPort
public int getElectionPort()
{    return electionPort;}
7fd52bac9e2aac02c274f92dd7cb0d5d34a6829a68775abb9a23fe22254d735e
getQuorumPort
public int getQuorumPort()
{    return quorumPort;}
d3e6eb9a0d8bc55e5a7a67cb50bc193600cea2e68478ce0daf2fac60142e695c
getConnectString
public String getConnectString()
{    return hostname + ":" + port;}
0c1e3a3900aef8e229a93ff4a534370dc4ab7e27d93c425cedecd9d316faab0f
getTickTime
public int getTickTime()
{    return tickTime;}
e1bdc6adf813fb8e32ea311d72e069682199fd33de94a8a2e7ac4918c58a4ffc
getMaxClientCnxns
public int getMaxClientCnxns()
{    return maxClientCnxns;}
440d43a3b03b6af8c3a3d50e03f38ee00086bc8dbf2ff9a888525da3b7f0389f
deleteDataDirectoryOnClose
public boolean deleteDataDirectoryOnClose()
{    return deleteDataDirectoryOnClose;}
8401c92594fe05c92b10511f0e710785db236834b8ed5a2f9dee10548b2083cc
getCustomProperties
public Map<String, Object> getCustomProperties()
{    return customProperties;}
27236935fc56b50befbdcf980df4df93fc1cb38744897e3c4ee05c744e513e94
getHostname
public String getHostname()
{    return hostname;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "InstanceSpec{" + "dataDirectory=" + dataDirectory + ", port=" + port + ", electionPort=" + electionPort + ", quorumPort=" + quorumPort + ", deleteDataDirectoryOnClose=" + deleteDataDirectoryOnClose + ", serverId=" + serverId + ", tickTime=" + tickTime + ", maxClientCnxns=" + maxClientCnxns + ", customProperties=" + customProperties + ", hostname=" + hostname + "} " + super.toString();}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    InstanceSpec that = (InstanceSpec) o;    return hostname.equals(that.getHostname()) && port == that.port;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return hostname.hashCode() + port;}
9963e0da5515e538d6138ae6063bdbd30346e736b5e42983ffcecdf03746c8f7
kill
public static void kill(ZooKeeper client)
{    client.getTestable().injectSessionExpiration();}
6f1c66ecabfaafacb9a959a6f39e9941e1de7635d5bae59efa48efe18bde9223
kill
public static void kill(ZooKeeper client, String connectString) throws Exception
{    kill(client);}
3388de115fe1edf74fa2a64ed776cabe7db55db98267a19fd5f1660344f517cb
kill
public static void kill(ZooKeeper client, String connectString, int maxMs) throws Exception
{    kill(client);}
638d3920bcf47e282c221545b0ad8110d80e901d4650d93ebe81491be912ae98
isFromRandom
public boolean isFromRandom()
{    return fromRandom;}
5ad9068ab4d282edcc82a9d909d2d0ab6fdd24b7bac03df923ba66528dbc0d59
buildConfig
public QuorumPeerConfig buildConfig() throws Exception
{    return buildConfig(0);}
628d9b0c0637cb621f182833526bab1c633be153a5e639c7a8c537afd5b3b03c
getInstanceSpec
public InstanceSpec getInstanceSpec(int index)
{    return instanceSpecs.get(index);}
450508200719b5aa55ec2a5ab2c082c768aa5392f38061df284aad04395104d3
getInstanceSpecs
public List<InstanceSpec> getInstanceSpecs()
{    return instanceSpecs;}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return instanceSpecs.size();}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    if (fakeConfigFile != null) {                fakeConfigFile.delete();    }}
554850316c754725e9b92c9daca74071c63065d9a286dfde17e6f04af905b87e
buildConfig
public QuorumPeerConfig buildConfig(int instanceIndex) throws Exception
{    boolean isCluster = (instanceSpecs.size() > 1);    InstanceSpec spec = instanceSpecs.get(instanceIndex);    if (isCluster) {        Files.write(Integer.toString(spec.getServerId()).getBytes(), new File(spec.getDataDirectory(), "myid"));    }    Properties properties = new Properties();    properties.setProperty("initLimit", "10");    properties.setProperty("syncLimit", "5");    properties.setProperty("dataDir", spec.getDataDirectory().getCanonicalPath());    properties.setProperty("clientPort", Integer.toString(spec.getPort()));    int tickTime = spec.getTickTime();    if (tickTime >= 0) {        properties.setProperty("tickTime", Integer.toString(tickTime));    }    int maxClientCnxns = spec.getMaxClientCnxns();    if (maxClientCnxns >= 0) {        properties.setProperty("maxClientCnxns", Integer.toString(maxClientCnxns));    }    if (isCluster) {        for (InstanceSpec thisSpec : instanceSpecs) {            properties.setProperty("server." + thisSpec.getServerId(), String.format("%s:%d:%d;%s:%d", thisSpec.getHostname(), thisSpec.getQuorumPort(), thisSpec.getElectionPort(), thisSpec.getHostname(), thisSpec.getPort()));        }    }    Map<String, Object> customProperties = spec.getCustomProperties();    if (customProperties != null) {        for (Map.Entry<String, Object> property : customProperties.entrySet()) {            properties.put(property.getKey(), property.getValue());        }    }    QuorumPeerConfig config = new QuorumPeerConfig() {        {            if (fakeConfigFile != null) {                configFileStr = fakeConfigFile.getPath();            }        }    };    config.parseProperties(properties);    return config;}
a3d8ee65a21afbda3f7f63352325a56dd2a044ba93fd85a9cac808634f061320
makeFactory
 static Object makeFactory(ZooKeeperServer server, int port) throws Exception
{    Object factory;    if (nioServerCnxn != null) {        factory = nioServerCnxn.constructor.newInstance(new InetSocketAddress(port));        if (server != null) {            nioServerCnxn.startupMethod.invoke(factory, server);        }    } else {        factory = serverCnxnFactoryMethods.constructor.newInstance();        serverCnxnFactoryMethods.configureMethod.invoke(factory, new InetSocketAddress(port), 0);        if (server != null) {            serverCnxnFactoryMethods.startupMethod.invoke(factory, server);        }    }    return factory;}
9d70e8057170ff42f095525fda68a9c0eb1dcbccab9af1d7a33336d562d8b728
shutdownFactory
 static void shutdownFactory(Object factory)
{    try {        if (nioServerCnxn != null) {            nioServerCnxn.shutdownMethod.invoke(factory);        } else {            serverCnxnFactoryMethods.shutdownMethod.invoke(factory);        }    } catch (Exception e) {        e.printStackTrace();        throw new Error(e);    }}
dd7dd727963844870889d9972c304f9889388a525cb8f3e2f5449c9f59cb8d1a
getInstances
public Collection<InstanceSpec> getInstances()
{    Iterable<InstanceSpec> transformed = Iterables.transform(servers, new Function<TestingZooKeeperServer, InstanceSpec>() {        @Override        public InstanceSpec apply(TestingZooKeeperServer server) {            return server.getInstanceSpec();        }    });    return Lists.newArrayList(transformed);}
d025012d766ec351b91bb57ee976a438ce0c213435e925d26d6d40f8de5c3222
apply
public InstanceSpec apply(TestingZooKeeperServer server)
{    return server.getInstanceSpec();}
39cec8bfc711f920877419841a4ca3db34faeb3f416274cab368180e4486c5bf
getServers
public List<TestingZooKeeperServer> getServers()
{    return Lists.newArrayList(servers);}
d3e6eb9a0d8bc55e5a7a67cb50bc193600cea2e68478ce0daf2fac60142e695c
getConnectString
public String getConnectString()
{    StringBuilder str = new StringBuilder();    for (InstanceSpec spec : getInstances()) {        if (str.length() > 0) {            str.append(",");        }        str.append(spec.getConnectString());    }    return str.toString();}
90ba0dddc593bd95e2a0c0c039c523b81bfb91f87814ebcb222c3914ca772ead
start
public void start() throws Exception
{    for (TestingZooKeeperServer server : servers) {        server.start();    }}
e431b2172904a46f506a2c97ba44a3df72e0057d82ce8f9714a53e2efce2a010
stop
public void stop() throws IOException
{    for (TestingZooKeeperServer server : servers) {        server.stop();    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    for (TestingZooKeeperServer server : servers) {        server.close();    }}
501770e38d5fd40f1c97dd6249d9a34cabb65739fe41712e339841eca71337cc
killServer
public boolean killServer(InstanceSpec instance) throws Exception
{    for (TestingZooKeeperServer server : servers) {        if (server.getInstanceSpec().equals(instance)) {            server.kill();            return true;        }    }    return false;}
b2506403dd2b3c3b8f9bd47bc9f52c1cf5b617ab7761387cbb296c61e585b552
restartServer
public boolean restartServer(InstanceSpec instance) throws Exception
{    for (TestingZooKeeperServer server : servers) {        if (server.getInstanceSpec().equals(instance)) {            server.restart();            return true;        }    }    return false;}
6cce941c47b20b9252afd52a374fb95d0d51516d38c0fc109d3ac7896a4ade38
findConnectionInstance
public InstanceSpec findConnectionInstance(ZooKeeper client) throws Exception
{    Method m = client.getClass().getDeclaredMethod("testableRemoteSocketAddress");    m.setAccessible(true);    InetSocketAddress address = (InetSocketAddress) m.invoke(client);    if (address != null) {        for (TestingZooKeeperServer server : servers) {            if (server.getInstanceSpec().getPort() == address.getPort()) {                return server.getInstanceSpec();            }        }    }    return null;}
e01d3abd60ed736e9598f38af6955b56c7f833da3078deba58e72cd09f72b564
makeSpecs
public static Map<InstanceSpec, Collection<InstanceSpec>> makeSpecs(int instanceQty)
{    return makeSpecs(instanceQty, true);}
386106e77fd535262280a4a430982a0bc3c804accb40866294e39a8aabd7d6aa
makeSpecs
public static Map<InstanceSpec, Collection<InstanceSpec>> makeSpecs(int instanceQty, boolean resetServerIds)
{    if (resetServerIds) {        InstanceSpec.reset();    }    ImmutableList.Builder<InstanceSpec> builder = ImmutableList.builder();    for (int i = 0; i < instanceQty; ++i) {        builder.add(InstanceSpec.newInstanceSpec());    }    return listToMap(builder.build());}
514f0c408204315685a89a3882293a11ab6369c74579f4911648f203375836ef
listToMap
private static Map<InstanceSpec, Collection<InstanceSpec>> listToMap(Collection<InstanceSpec> list)
{    ImmutableMap.Builder<InstanceSpec, Collection<InstanceSpec>> mapBuilder = ImmutableMap.builder();    for (InstanceSpec spec : list) {        mapBuilder.put(spec, list);    }    return mapBuilder.build();}
57ef494784286a4733dde2fdbd3b64194a16b5018f929129eca79f84300b3872
kill
public void kill()
{    try {        if (quorumPeer != null) {            Field cnxnFactoryField = QuorumPeer.class.getDeclaredField("cnxnFactory");            cnxnFactoryField.setAccessible(true);            ServerCnxnFactory cnxnFactory = (ServerCnxnFactory) cnxnFactoryField.get(quorumPeer);            cnxnFactory.closeAll();            Field ssField = cnxnFactory.getClass().getDeclaredField("ss");            ssField.setAccessible(true);            ServerSocketChannel ss = (ServerSocketChannel) ssField.get(cnxnFactory);            ss.close();        }        close();    } catch (Exception e) {        e.printStackTrace();    }}
749b625a699802733b14bcb46d804bdd6480a07b05b82df50820b3a318c33f0e
getTestingQuorumPeer
public QuorumPeer getTestingQuorumPeer()
{    return quorumPeer;}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    if ((quorumPeer != null) && !isClosed) {        isClosed = true;        quorumPeer.shutdown();    }}
48f74e0c164b06474a0e65f11cf1c7d867a36c4a03ea81e69bf698a61eccd859
blockUntilStarted
public void blockUntilStarted() throws Exception
{    long startTime = System.currentTimeMillis();    while ((quorumPeer == null) && ((System.currentTimeMillis() - startTime) <= TestingZooKeeperMain.MAX_WAIT_MS)) {        try {            Thread.sleep(10);        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            break;        }    }    if (quorumPeer == null) {        throw new Exception("quorumPeer never got set");    }}
eedb587f68470407e820d49bf6bb9be573d78555382d32a0743e8fea8ced15d6
getPort
public int getPort()
{    return spec.getPort();}
ebadb4394063fdc0b46f0061f4f0a8ad9162bbe0e36b05b7e5efc4bdb9174cb8
getTempDirectory
public File getTempDirectory()
{    return spec.getDataDirectory();}
90ba0dddc593bd95e2a0c0c039c523b81bfb91f87814ebcb222c3914ca772ead
start
public void start() throws Exception
{    testingZooKeeperServer.start();}
e431b2172904a46f506a2c97ba44a3df72e0057d82ce8f9714a53e2efce2a010
stop
public void stop() throws IOException
{    testingZooKeeperServer.stop();}
90bc2970313b1e80e06a8ff9e68430342162de6a44a83841a9d562ec33279ea3
restart
public void restart() throws Exception
{    testingZooKeeperServer.restart();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    testingZooKeeperServer.close();}
d3e6eb9a0d8bc55e5a7a67cb50bc193600cea2e68478ce0daf2fac60142e695c
getConnectString
public String getConnectString()
{    return spec.getConnectString();}
57ef494784286a4733dde2fdbd3b64194a16b5018f929129eca79f84300b3872
kill
public void kill()
{    try {        if (cnxnFactory != null) {            cnxnFactory.closeAll();            Field ssField = cnxnFactory.getClass().getDeclaredField("ss");            ssField.setAccessible(true);            ServerSocketChannel ss = (ServerSocketChannel) ssField.get(cnxnFactory);            ss.close();        }        close();    } catch (Exception e) {                e.printStackTrace();    }}
7fb011255cc6b1aa056d62b31b4aa03ce6bcaed05514791004c2f4573bf159fb
runFromConfig
public void runFromConfig(QuorumPeerConfig config) throws Exception
{    try {        Field instance = MBeanRegistry.class.getDeclaredField("instance");        instance.setAccessible(true);        MBeanRegistry nopMBeanRegistry = new MBeanRegistry() {            @Override            public void register(ZKMBeanInfo bean, ZKMBeanInfo parent) throws JMException {                        }            @Override            public void unregister(ZKMBeanInfo bean) {                        }        };        instance.set(null, nopMBeanRegistry);    } catch (Exception e) {        log.error("Could not fix MBeanRegistry");    }    ServerConfig serverConfig = new ServerConfig();    serverConfig.readFrom(config);    try {        internalRunFromConfig(serverConfig);    } catch (IOException e) {        startingException.set(e);        throw e;    }}
941c095abfdb711bc7c9342f949cd27a846b273c541e9f6bbfdad290c3dfaf9a
register
public void register(ZKMBeanInfo bean, ZKMBeanInfo parent) throws JMException
{}
3ef02c3c7a889b4038e716e194cd70f1d18a5d5932351af6058cb9904a11ce0c
unregister
public void unregister(ZKMBeanInfo bean)
{}
48f74e0c164b06474a0e65f11cf1c7d867a36c4a03ea81e69bf698a61eccd859
blockUntilStarted
public void blockUntilStarted() throws Exception
{    if (!timing.awaitLatch(latch))        throw new IllegalStateException("Timed out waiting for watch removal");    if (zkServer != null) {                synchronized (zkServer) {            while (!zkServer.isRunning()) {                zkServer.wait();            }        }    } else {        throw new Exception("No zkServer.");    }    Exception exception = startingException.get();    if (exception != null) {        throw exception;    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    try {        cnxnFactory.shutdown();    } catch (Throwable e) {                e.printStackTrace();    } finally {        cnxnFactory = null;    }    if (containerManager != null) {        containerManager.stop();        containerManager = null;    }    try {        if (zkServer != null) {            zkServer.shutdown();            ZKDatabase zkDb = zkServer.getZKDatabase();            if (zkDb != null) {                                zkDb.close();            }        }    } catch (Throwable e) {                e.printStackTrace();    } finally {        zkServer = null;    }}
d1605484b1480fe1e9ad4ec08224567d8e856847df31d60b4e9006808ef4ea22
internalRunFromConfig
private void internalRunFromConfig(ServerConfig config) throws IOException
{    log.info("Starting server");    FileTxnSnapLog txnLog = null;    try {                                        txnLog = new FileTxnSnapLog(config.getDataLogDir(), config.getDataDir());        zkServer = new TestZooKeeperServer(txnLog, config);        try {            cnxnFactory = ServerCnxnFactory.createFactory();            cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns());        } catch (IOException e) {            log.info("Could not start server. Waiting and trying one more time.", e);            timing.sleepABit();            cnxnFactory = ServerCnxnFactory.createFactory();            cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns());        }        cnxnFactory.startup(zkServer);        containerManager = new ContainerManager(zkServer.getZKDatabase(), zkServer.getFirstProcessor(), Integer.getInteger("znode.container.checkIntervalMs", (int) TimeUnit.MINUTES.toMillis(1L)), Integer.getInteger("znode.container.maxPerMinute", 10000));        containerManager.start();        latch.countDown();        cnxnFactory.join();        if ((zkServer != null) && zkServer.isRunning()) {            zkServer.shutdown();        }    } catch (InterruptedException e) {                Thread.currentThread().interrupt();        log.warn("Server interrupted", e);    } finally {        if (txnLog != null) {            txnLog.close();        }    }}
c2aa01c5677c02c8bfa86c3cbc31deb8b6c5cce04c006159d023cd40f413a536
getFirstProcessor
public RequestProcessor getFirstProcessor()
{    return firstProcessor;}
c1fb0acefc598c56ec326dc3b4778c056ac59608c9aca70ed1d136ac1a0cc817
setState
protected void setState(State state)
{    this.state = state;}
e6f3bb16f7c86279ca0b0f6bdfc4ca1bbf019bd9710ded3d2320084bbedcc6a2
registerJMX
protected void registerJMX()
{}
85e7e25a941f134236cd570c8e63b18ce60539fbd1cc088cec570f9a426f4eb3
unregisterJMX
protected void unregisterJMX()
{}
1cd1b470351cc164620985e84951745a66160c6782dec39e46562afc0eaa2246
isRunning
public boolean isRunning()
{    return isRunning.get() || super.isRunning();}
4c075b2cb2f2dba696a982e41bf413bf0fe8b2e9763d6a14648a224353a753f5
noteStartup
public void noteStartup()
{    synchronized (this) {        isRunning.set(true);        this.notifyAll();    }}
674df294540477d348a80461bee077fcb0a3a6e674022c8e7127ae24e501cdc9
isCluster
private boolean isCluster()
{    return configBuilder.size() > 1;}
bab3e52c6319455ddb7465a819a61e39c427c0edc37d5d62a9272023aa570be3
getQuorumPeer
public QuorumPeer getQuorumPeer()
{    if (isCluster()) {        return ((TestingQuorumPeerMain) main).getTestingQuorumPeer();    }    throw new UnsupportedOperationException();}
b94b1e862a20dba129ac6c768c1817a3c61c029ef6961d00bd07f9d1ea4aab06
getInstanceSpecs
public Collection<InstanceSpec> getInstanceSpecs()
{    return configBuilder.getInstanceSpecs();}
57ef494784286a4733dde2fdbd3b64194a16b5018f929129eca79f84300b3872
kill
public void kill()
{    main.kill();    state.set(State.STOPPED);}
90bc2970313b1e80e06a8ff9e68430342162de6a44a83841a9d562ec33279ea3
restart
public void restart() throws Exception
{        if (state.get() == State.CLOSED) {        throw new IllegalStateException("Cannot restart a closed instance");    }        if (state.get() == State.STARTED) {        stop();    }        state.set(State.LATENT);    main = isCluster() ? new TestingQuorumPeerMain() : new TestingZooKeeperMain();    start();}
e431b2172904a46f506a2c97ba44a3df72e0057d82ce8f9714a53e2efce2a010
stop
public void stop() throws IOException
{    if (state.compareAndSet(State.STARTED, State.STOPPED)) {        main.close();    }}
345eb4c22994b360132da768fda6293f4a3fb4ccbb5f0173aa9afcee262de727
getInstanceSpec
public InstanceSpec getInstanceSpec()
{    return configBuilder.getInstanceSpec(thisInstanceIndex);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    stop();    if (state.compareAndSet(State.STOPPED, State.CLOSED)) {        configBuilder.close();        InstanceSpec spec = getInstanceSpec();        if (spec.deleteDataDirectoryOnClose()) {            DirectoryUtils.deleteRecursively(spec.getDataDirectory());        }    }}
90ba0dddc593bd95e2a0c0c039c523b81bfb91f87814ebcb222c3914ca772ead
start
public void start() throws Exception
{    if (!state.compareAndSet(State.LATENT, State.STARTED)) {        return;    }    new Thread(new Runnable() {        public void run() {            try {                QuorumPeerConfig config = configBuilder.buildConfig(thisInstanceIndex);                main.runFromConfig(config);            } catch (Exception e) {                logger.error(String.format("From testing server (random state: %s) for instance: %s", String.valueOf(configBuilder.isFromRandom()), getInstanceSpec()), e);            }        }    }).start();    main.blockUntilStarted();}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        QuorumPeerConfig config = configBuilder.buildConfig(thisInstanceIndex);        main.runFromConfig(config);    } catch (Exception e) {        logger.error(String.format("From testing server (random state: %s) for instance: %s", String.valueOf(configBuilder.isFromRandom()), getInstanceSpec()), e);    }}
933ff911f832ff2a798c905d29dbaad2046d43daf6534c7488979bcf6271bf14
milliseconds
public int milliseconds()
{    return (int) TimeUnit.MILLISECONDS.convert(value, unit);}
4efa9e8bc922415586b665bf0245bf7f2d852fa6e4d20625d333659a70003e07
seconds
public int seconds()
{    return (int) value;}
dca00bb967d7e4c411c0c08e0ed2240324c8276e1c656522569a82317a44844d
awaitLatch
public boolean awaitLatch(CountDownLatch latch)
{    Timing m = forWaiting();    try {        return latch.await(m.value, m.unit);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }    return false;}
2d8805601cd0e6a96f0fb884420e3f976b1e0ad5bb85421d6c93f8f2d6803699
acquireSemaphore
public boolean acquireSemaphore(Semaphore semaphore)
{    Timing m = forWaiting();    try {        return semaphore.tryAcquire(m.value, m.unit);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }    return false;}
cd3995ffaacb2de6a77450887360fcff4f17d4be72e46633c3e59a1d9415e6c6
acquireSemaphore
public boolean acquireSemaphore(Semaphore semaphore, int n)
{    Timing m = forWaiting();    try {        return semaphore.tryAcquire(n, m.value, m.unit);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }    return false;}
c47f55f9c8e9232b6c9a73ddacf92b27e6175cda6dc2bce78e7bd84fed6eadbf
multiple
public Timing multiple(double n)
{    return new Timing((int) (value * n), unit);}
a7e9e63a1e56ce72926fda294bfd62a9bead350623b46c1915cb7026d931f968
forWaiting
public Timing forWaiting()
{    return multiple(waitingMultiple);}
41dd61dad03ccee9f9f896db8c133233a1e84a63caa31bdf12a40bc81e6afad0
sleepABit
public void sleepABit() throws InterruptedException
{    unit.sleep(value / 4);}
ba4a961ef4b59b305d9d60282a3415f8e5788db8c52d12c7b578476c2d827c5f
session
public int session()
{    return multiple(SESSION_MULTIPLE).milliseconds();}
42e5f2cef2315723574724e0377df70b17bc6b41ea83375115511ebd786d6143
connection
public int connection()
{    return milliseconds();}
96a4163060b91d0f42c61283e1a938322805cd24ad782187261d66a68bfa910d
getWaitingMultiple
private static Integer getWaitingMultiple()
{    return Integer.getInteger("timing-waiting-multiple", DEFAULT_WAITING_MULTIPLE);}
4a5cc3062dd1f5ff71ae0ec01bd24f0881a477390047fe827b1639b24e2d0382
getDataWatches
public static List<String> getDataWatches(ZooKeeper zooKeeper)
{    return callMethod(zooKeeper, WatchersDebug.getDataWatches);}
d536d7d94ee71ab0b5a842de8f18547a5e60dbc9c9824875126d64b3e86dd6e4
getExistWatches
public static List<String> getExistWatches(ZooKeeper zooKeeper)
{    return callMethod(zooKeeper, getExistWatches);}
9c3d30b6f1c4cb075f7c0d46a520a156c1c9548a8f0adf2a3bb3928badfc58a6
getChildWatches
public static List<String> getChildWatches(ZooKeeper zooKeeper)
{    return callMethod(zooKeeper, getChildWatches);}
0bf5277af72b0ce9afe8b5fae8cf593db30b285f57623891d8abffe55deec196
getMethod
private static Method getMethod(String name) throws NoSuchMethodException
{    Method m = ZooKeeper.class.getDeclaredMethod(name);    m.setAccessible(true);    return m;}
d6cd67f81a222e74eaa96518a8b19e623e13c7caa8f1b9266aad2aeaeeda987d
callMethod
private static List<String> callMethod(ZooKeeper zooKeeper, Method method)
{    if (zooKeeper == null) {        return null;    }    try {                return (List<String>) method.invoke(zooKeeper);    } catch (Exception e) {        throw new RuntimeException(e);    }}
5442613caa63e855bf15b3dd61e7cbd52de6b5b4d112674dd699a96a242f0b7d
testCustomProperties
public void testCustomProperties() throws Exception
{    Map<String, Object> customProperties = new HashMap<String, Object>();    customProperties.put("authProvider.1", "org.apache.zookeeper.server.auth.SASLAuthenticationProvider");    customProperties.put("kerberos.removeHostFromPrincipal", "true");    customProperties.put("kerberos.removeRealmFromPrincipal", "true");    InstanceSpec spec = new InstanceSpec(null, -1, -1, -1, true, 1, -1, -1, customProperties);    TestingServer server = new TestingServer(spec, true);    try {        assertEquals("org.apache.zookeeper.server.auth.SASLAuthenticationProvider", System.getProperty("zookeeper.authProvider.1"));        assertEquals("true", System.getProperty("zookeeper.kerberos.removeHostFromPrincipal"));        assertEquals("true", System.getProperty("zookeeper.kerberos.removeRealmFromPrincipal"));    } finally {        server.close();    }}
e9c3caf379dc3b6867a9679539193c6c41da3f10e6c996d4e258fca7f548ec5c
isZK34
public static boolean isZK34()
{    return true;}
c77e7f887aba48f59f89821ef79724ced5893aadbdabaa06255280be479af7ae
testAutoState
public void testAutoState()
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    Assert.assertTrue(client.isZk34CompatibilityMode());}
a1db362bad44683ba0f9768b2cacc3df12afb208fa587c0a512b96a503407842
testTtl
public void testTtl() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().withTtl(100).forPath("/foo");    } finally {        CloseableUtils.closeQuietly(client);    }}
6565daf098b9e4d644437d96666f638134fadf3ecfccf7270ff89b34c1fef400
testReconfig
public void testReconfig() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.reconfig().withNewMembers("a", "b");    } finally {        CloseableUtils.closeQuietly(client);    }}
6e88ef57b1703e77159293f68bfa19854728209815211941bdfcaf54ffedb736
testGetConfig
public void testGetConfig() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.getConfig().forEnsemble();    } finally {        CloseableUtils.closeQuietly(client);    }}
27e11a8a7a6e24c8f2c0f6dcbefa1f95583196006e0ef8826228a47868bc9e67
testRemoveWatches
public void testRemoveWatches() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.watches().removeAll();    } finally {        CloseableUtils.closeQuietly(client);    }}
6c8d4210cbb62db922bfcb29852caac6f2b32ecd50ad2cb8e4dba3058550694b
wrap
 static AsyncCuratorFramework wrap(CuratorFramework client)
{    return new AsyncCuratorFrameworkImpl(client);}
bf9da30c3be67f703627e0a0f426f9510bce32ad68d4feea11332a14275cb96b
of
 static CompletionStage<AsyncResult<T>> of(AsyncStage<T> stage)
{    return stage.handle((value, ex) -> {        if (ex != null) {            if (ex instanceof KeeperException) {                return new AsyncResultImpl<T>(((KeeperException) ex).code());            }            return new AsyncResultImpl<T>(ex);        }        return new AsyncResultImpl<T>(value);    });}
c83f265887a0c77aaf07794e48ff73fcca1e9a015aac24eccbd29ab5c83014cf
childrenWithData
public static CompletionStage<Map<String, byte[]>> childrenWithData(AsyncCuratorFramework client, String path)
{    return childrenWithData(client, path, false);}
8ac4636cd815c7d19082fc8d5eae660200d25b21593afdc45b047bc3ecc5043c
childrenWithData
public static CompletionStage<Map<String, byte[]>> childrenWithData(AsyncCuratorFramework client, String path, boolean isCompressed)
{    CompletableFuture<Map<String, byte[]>> future = new CompletableFuture<>();    client.getChildren().forPath(path).handle((children, e) -> {        if (e != null) {            if (Throwables.getRootCause(e) instanceof KeeperException.NoNodeException) {                future.complete(Maps.newHashMap());            } else {                future.completeExceptionally(e);            }        } else {            completeChildren(client, future, path, children, isCompressed);        }        return null;    });    return future;}
89cde140ab2d12b1ed04aad37159d72c3f8dbf46a5198aacef0aa1fb0fa3e12f
asyncEnsureParents
public static CompletionStage<Void> asyncEnsureParents(AsyncCuratorFramework client, String path)
{    return ensure(client, path, ExistsOption.createParentsIfNeeded);}
ef66bf56c01527a710f2b8ff3e700bed4053fd74d16a664a27f4a1cb75eae642
asyncEnsureContainers
public static CompletionStage<Void> asyncEnsureContainers(AsyncCuratorFramework client, String path)
{    return ensure(client, path, ExistsOption.createParentsAsContainers);}
21f7dc5b0b8ab5ec331e081318a37391aaffa8158a4eb4e56c7cbec21f75cc39
lockAsync
public static CompletionStage<Void> lockAsync(InterProcessLock lock, long timeout, TimeUnit unit, Executor executor)
{    CompletableFuture<Void> future = new CompletableFuture<>();    if (executor == null) {        CompletableFuture.runAsync(() -> lock(future, lock, timeout, unit));    } else {        CompletableFuture.runAsync(() -> lock(future, lock, timeout, unit), executor);    }    return future;}
00fa77d5ade60ddb99351f89760ba976d13321a3734bf5125d301e1c8485b24c
lockAsyncIf
public static CompletionStage<Boolean> lockAsyncIf(InterProcessLock lock, long timeout, TimeUnit unit, Executor executor)
{    CompletableFuture<Boolean> future = new CompletableFuture<>();    if (executor == null) {        CompletableFuture.runAsync(() -> lockIf(future, lock, timeout, unit));    } else {        CompletableFuture.runAsync(() -> lockIf(future, lock, timeout, unit), executor);    }    return future;}
370eff4f40e39199f9a7fddaa6b7b37a0fec18e0a517608ef9de23a2f3ce33a1
lockAsync
public static CompletionStage<Void> lockAsync(InterProcessLock lock, Executor executor)
{    return lockAsync(lock, 0, null, executor);}
b9b6fcfb2d4f2a6d8aba40aa187e5c76c5580e2cb09d7216446662dc44556248
lockAsync
public static CompletionStage<Void> lockAsync(InterProcessLock lock, long timeout, TimeUnit unit)
{    return lockAsync(lock, timeout, unit, null);}
530650af9b1c047f281936a0289666b6fd075736833bb1ccf81af3bf0d41db8c
lockAsyncIf
public static CompletionStage<Boolean> lockAsyncIf(InterProcessLock lock, long timeout, TimeUnit unit)
{    return lockAsyncIf(lock, timeout, unit, null);}
a77e1caaaf557df2e767785eb95f1a4dd8f5f2484d997a1e800a89498a597a97
lockAsync
public static CompletionStage<Void> lockAsync(InterProcessLock lock)
{    return lockAsync(lock, 0, null, null);}
4b99ce3dd80dc020a0efbe06efd7c22a6d606baef3a97ede605f977d17e00600
release
public static void release(InterProcessLock lock)
{    release(lock, true);}
407e6f42d8b64d1b0a8d7011e35e574bf40e73e69931c9b291f05463523beb70
release
public static void release(InterProcessLock lock, boolean ignoreNoLockExceptions)
{    try {        lock.release();    } catch (IllegalStateException e) {        if (!ignoreNoLockExceptions) {            throw new RuntimeException(e);        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new RuntimeException(e);    }}
40faf8097d0de744029547a7e3e06cbc0646a3ea117420f7daf96f2d2d554fce
lockIf
private static void lockIf(CompletableFuture<Boolean> future, InterProcessLock lock, long timeout, TimeUnit unit)
{    try {        future.complete(lock.acquire(timeout, unit));    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        future.completeExceptionally(e);    }}
13fdd42652c0b039a4faa41b82e7572132e431a997868ff12de61ed57a325935
lock
private static void lock(CompletableFuture<Void> future, InterProcessLock lock, long timeout, TimeUnit unit)
{    try {        if (unit != null) {            if (lock.acquire(timeout, unit)) {                future.complete(null);            } else {                future.completeExceptionally(new TimeoutException());            }        } else {            lock.acquire();            future.complete(null);        }    } catch (Throwable e) {        ThreadUtils.checkInterrupted(e);        future.completeExceptionally(e);    }}
041327c688489c35a90aa8ba5264bc4e61c70c4d8c70f86e3cabab0852751d3d
completeChildren
private static void completeChildren(AsyncCuratorFramework client, CompletableFuture<Map<String, byte[]>> future, String parentPath, List<String> children, boolean isCompressed)
{    Map<String, byte[]> nodes = Maps.newHashMap();    if (children.size() == 0) {        future.complete(nodes);        return;    }    children.forEach(node -> {        String path = ZKPaths.makePath(parentPath, node);        AsyncStage<byte[]> stage = isCompressed ? client.getData().decompressed().forPath(path) : client.getData().forPath(path);        stage.handle((data, e) -> {            if (e != null) {                future.completeExceptionally(e);            } else {                nodes.put(path, data);                if (nodes.size() == children.size()) {                    future.complete(nodes);                }            }            return null;        });    });}
2df3ceaf93b32fd5407a56ab0ecbcba04074484e57c6efff0bacfcb55ad2eff3
ensure
private static CompletionStage<Void> ensure(AsyncCuratorFramework client, String path, ExistsOption option)
{    String localPath = ZKPaths.makePath(path, "foo");    return client.checkExists().withOptions(Collections.singleton(option)).forPath(localPath).thenApply(__ -> null);}
4b90ef17a18fc53c3a5073a8379a7a04c9a3e6a01707e03149038a63305a7314
storingStatIn
public AsyncPathAndBytesable<AsyncStage<String>> storingStatIn(Stat stat)
{    this.stat = stat;    return this;}
fd8bf7402061c5b8dc8c3139ae7b42215c256584338c088034372de993d1b838
withMode
public AsyncPathAndBytesable<AsyncStage<String>> withMode(CreateMode createMode)
{    this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");    return this;}
6b204b0a14eb8a85835010dfb7feac8e10d0115cf9006803fcc8e6a4807aebde
withACL
public AsyncPathAndBytesable<AsyncStage<String>> withACL(List<ACL> aclList)
{    this.aclList = aclList;    return this;}
81c3d6f2d5a4feaefaf7076c7f46d284701e6da8b293758092d9d87c3d658c43
withTtl
public AsyncPathAndBytesable<AsyncStage<String>> withTtl(long ttl)
{    this.ttl = ttl;    return this;}
5de667c72a56c5b36aabfd5b88cd3bd55f86c370a40dcf309d24cb6ba9ce31f2
withSetDataVersion
public AsyncPathAndBytesable<AsyncStage<String>> withSetDataVersion(int version)
{    this.setDataVersion = version;    return this;}
918df26a2081176ac7206cf68ff43e9fa7385c61c9c8833c8cb2e0c2f4f14db1
withOptions
public AsyncPathAndBytesable<AsyncStage<String>> withOptions(Set<CreateOption> options)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    return this;}
0df3e8f8db8e69dd3e8a66f7c86243f9b16dd92f6436ab092419103dc6d41d67
withOptions
public AsyncPathAndBytesable<AsyncStage<String>> withOptions(Set<CreateOption> options, List<ACL> aclList)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.aclList = aclList;    return this;}
bc5007cc055fc7fde7761d7c424795b4e6973558132cfdf73891c224e02650a4
withOptions
public AsyncPathAndBytesable<AsyncStage<String>> withOptions(Set<CreateOption> options, CreateMode createMode, List<ACL> aclList)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.aclList = aclList;    this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");    return this;}
8c0e46c001e740e812a69dd9461b79e8cb29c7842157ea8e22c9f290da4ee802
withOptions
public AsyncPathAndBytesable<AsyncStage<String>> withOptions(Set<CreateOption> options, CreateMode createMode)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");    return this;}
566abe3292f6f08b6a039e464708651bcb37eb1bea50e5eb0ef87e62a3124c67
withOptions
public AsyncPathAndBytesable<AsyncStage<String>> withOptions(Set<CreateOption> options, CreateMode createMode, List<ACL> aclList, Stat stat)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.aclList = aclList;    this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");    this.stat = stat;    return this;}
bf48ee255379a55ae3b8decf8f1b442b19ed27c13de26575991c319c48ff2ded
withOptions
public AsyncPathAndBytesable<AsyncStage<String>> withOptions(Set<CreateOption> options, CreateMode createMode, List<ACL> aclList, Stat stat, long ttl)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.aclList = aclList;    this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");    this.stat = stat;    this.ttl = ttl;    return this;}
83401401671311288a7d16698a63a8d0cf1ff2df6f54324e9f5f5ddc574d9deb
withOptions
public AsyncPathAndBytesable<AsyncStage<String>> withOptions(Set<CreateOption> options, CreateMode createMode, List<ACL> aclList, Stat stat, long ttl, int setDataVersion)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.aclList = aclList;    this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");    this.stat = stat;    this.ttl = ttl;    this.setDataVersion = setDataVersion;    return this;}
a44c266b4903730269a1c75d3864fed6a7f26d4a3da1ff00d61b4b0e5ac31152
forPath
public AsyncStage<String> forPath(String path)
{    return internalForPath(path, null, false);}
44e727eb1e083e42b00fafbc452954593d763321bc336ccae7727e09a33c84a1
forPath
public AsyncStage<String> forPath(String path, byte[] data)
{    return internalForPath(path, data, true);}
9f2e30c0e8cb823bd2e22a07315603582a791bdd375abfdb098c390421ff674a
internalForPath
private AsyncStage<String> internalForPath(String path, byte[] data, boolean useData)
{    BuilderCommon<String> common = new BuilderCommon<>(filters, nameProc);    CreateBuilderImpl builder = new CreateBuilderImpl(client, createMode, common.backgrounding, options.contains(CreateOption.createParentsIfNeeded) || options.contains(CreateOption.createParentsAsContainers), options.contains(CreateOption.createParentsAsContainers), options.contains(CreateOption.doProtected), options.contains(CreateOption.compress), options.contains(CreateOption.setDataIfExists), aclList, stat, ttl);    builder.setSetDataIfExistsVersion(setDataVersion);    return safeCall(common.internalCallback, () -> useData ? builder.forPath(path, data) : builder.forPath(path));}
12cd4bfde43d978bc557d8b2d55b1a8b9c66b932c799620218388ba1e1d6f22a
reveal
private static CuratorFrameworkImpl reveal(CuratorFramework client)
{    try {        return (CuratorFrameworkImpl) Objects.requireNonNull(client, "client cannot be null");    } catch (Exception e) {        throw new IllegalArgumentException("Only Curator clients created through CuratorFrameworkFactory are supported: " + client.getClass().getName());    }}
dfb0a0771b62412f86351d774d4471d7cf9dbc75c095a1ca8ca0cc7f98bd7360
create
public AsyncCreateBuilder create()
{    return new AsyncCreateBuilderImpl(client, filters);}
e1fbf3339b9d70859440f4c96ef4eecbcfbbc17590d7d94be73f82317ef77161
delete
public AsyncDeleteBuilder delete()
{    return new AsyncDeleteBuilderImpl(client, filters);}
e43f7480b95cd9359cf73b71652e0812f069336f17cf262d38041aefae381316
setData
public AsyncSetDataBuilder setData()
{    return new AsyncSetDataBuilderImpl(client, filters);}
736efe0f43b6aae1eddafacb922576cbeace5421caf83954fde5851f0bcecf95
getACL
public AsyncGetACLBuilder getACL()
{    return new AsyncGetACLBuilder() {        private Stat stat = null;        @Override        public AsyncPathable<AsyncStage<List<ACL>>> storingStatIn(Stat stat) {            this.stat = stat;            return this;        }        @Override        public AsyncStage<List<ACL>> forPath(String path) {            BuilderCommon<List<ACL>> common = new BuilderCommon<>(filters, aclProc);            GetACLBuilderImpl builder = new GetACLBuilderImpl(client, common.backgrounding, stat);            return safeCall(common.internalCallback, () -> builder.forPath(path));        }    };}
78bfe3f0ce0c764ad338c6cdf9867afc5d9694eb8d4a3d28a8a298bf0fddd8b8
storingStatIn
public AsyncPathable<AsyncStage<List<ACL>>> storingStatIn(Stat stat)
{    this.stat = stat;    return this;}
7e0fee744ba149598d7084f61f971abe31504e306651d70d10c85ca58f728418
forPath
public AsyncStage<List<ACL>> forPath(String path)
{    BuilderCommon<List<ACL>> common = new BuilderCommon<>(filters, aclProc);    GetACLBuilderImpl builder = new GetACLBuilderImpl(client, common.backgrounding, stat);    return safeCall(common.internalCallback, () -> builder.forPath(path));}
de5a68ac5fc389c8c4f1e079f86e40ea241203baaf501070ea713784422b05fb
setACL
public AsyncSetACLBuilder setACL()
{    return new AsyncSetACLBuilderImpl(client, filters);}
67e4035064de1ef12aabe5a5fae0036756ba3671b3445827c561f75ab32fb6af
reconfig
public AsyncReconfigBuilder reconfig()
{    return new AsyncReconfigBuilderImpl(client, filters);}
3014387c3e2c7ef6abfe90f82a54a13596c8198f0113732a8542d798c5237e17
transaction
public AsyncMultiTransaction transaction()
{    return operations -> {        BuilderCommon<List<CuratorTransactionResult>> common = new BuilderCommon<>(filters, opResultsProc);        CuratorMultiTransactionImpl builder = new CuratorMultiTransactionImpl(client, common.backgrounding);        return safeCall(common.internalCallback, () -> builder.forOperations(operations));    };}
7349f075363c77907a9c071fe68f9e931a4a55db1b674e36ff23e36c3798287d
sync
public AsyncSyncBuilder sync()
{    return path -> {        BuilderCommon<Void> common = new BuilderCommon<>(filters, ignoredProc);        SyncBuilderImpl builder = new SyncBuilderImpl(client, common.backgrounding);        return safeCall(common.internalCallback, () -> builder.forPath(path));    };}
6e31e91f9ada9229fe87d075346b7782cb4407ecbda457d72f812ae530eb1762
removeWatches
public AsyncRemoveWatchesBuilder removeWatches()
{    return new AsyncRemoveWatchesBuilderImpl(client, filters);}
7ef01853575d5055924b8b1f508a82e8fdc85c8ff0412e835eb7688c3feb6642
unwrap
public CuratorFramework unwrap()
{    return client;}
771b47a6a5b6dd6dff4e17eef0d3a419fc6cde4bcac357f46778361eb62a681e
watched
public WatchableAsyncCuratorFramework watched()
{    return new AsyncCuratorFrameworkImpl(client, filters, watchMode, true);}
bab85f114edd904be7103817aaa57e1ad9631956e8c33b4e1213a39c8567ca5f
with
public AsyncCuratorFrameworkDsl with(WatchMode mode)
{    return new AsyncCuratorFrameworkImpl(client, filters, mode, watched);}
e3d267e34814bc0f78bf902efe7fc3788228a706a809c0fca9be24f298840184
with
public AsyncCuratorFrameworkDsl with(WatchMode mode, UnhandledErrorListener listener, UnaryOperator<CuratorEvent> resultFilter, UnaryOperator<WatchedEvent> watcherFilter)
{    return new AsyncCuratorFrameworkImpl(client, new Filters(listener, filters.getResultFilter(), filters.getWatcherFilter()), mode, watched);}
549fb97827bda9f382b59ed7eeb315f7d4200e56c545f09d45368dabceb69216
with
public AsyncCuratorFrameworkDsl with(UnhandledErrorListener listener)
{    return new AsyncCuratorFrameworkImpl(client, new Filters(listener, filters.getResultFilter(), filters.getWatcherFilter()), watchMode, watched);}
f8902185ce584754013b1f3b8cb8cfe7f71209cabb5ae696942dae541e64c773
with
public AsyncCuratorFrameworkDsl with(UnaryOperator<CuratorEvent> resultFilter, UnaryOperator<WatchedEvent> watcherFilter)
{    return new AsyncCuratorFrameworkImpl(client, new Filters(filters.getListener(), resultFilter, watcherFilter), watchMode, watched);}
8cb5a1aabeee2a41f5b9eabe6d53a7327f8b49ae88f5739dd627d4adc64ff06a
with
public AsyncCuratorFrameworkDsl with(UnhandledErrorListener listener, UnaryOperator<CuratorEvent> resultFilter, UnaryOperator<WatchedEvent> watcherFilter)
{    return new AsyncCuratorFrameworkImpl(client, new Filters(listener, resultFilter, watcherFilter), watchMode, watched);}
77006ce42b0b8e9c46257032cd94d2229dcf2c6006f918b6696bd8ca10960548
transactionOp
public AsyncTransactionOp transactionOp()
{    return new AsyncTransactionOpImpl(client);}
d5313061a89180a2c94d918e00eccca322d8577af0b1d1e3c71b9378a95065f7
checkExists
public AsyncExistsBuilder checkExists()
{    return new AsyncExistsBuilderImpl(client, filters, getBuilderWatchMode());}
94a3217ec5f9412bc0442b36cf0500ff7a7ac1a68b87931c85f0b93d820a4fd6
getData
public AsyncGetDataBuilder getData()
{    return new AsyncGetDataBuilderImpl(client, filters, getBuilderWatchMode());}
46d40f29adfbfa3791eeaef53dbfbd55101ebbc7b42b503d2bc2d6cfff6aa7fa
getChildren
public AsyncGetChildrenBuilder getChildren()
{    return new AsyncGetChildrenBuilderImpl(client, filters, getBuilderWatchMode());}
246b96c66045dc32bb539cae4364896daee963e7f2be0e3032267562dc77b78d
getConfig
public AsyncGetConfigBuilder getConfig()
{    return new AsyncGetConfigBuilderImpl(client, filters, getBuilderWatchMode());}
82bd13ca62b60d787ab6f81bece420a9311fc322919762795a95e120794db7e6
getBuilderWatchMode
private WatchMode getBuilderWatchMode()
{    return watched ? watchMode : null;}
2bfbb19e387305a0988e953d12411f5b8ed03b1594bf2610c7894c5b94218202
withOptions
public AsyncPathable<AsyncStage<Void>> withOptions(Set<DeleteOption> options)
{    return withOptionsAndVersion(options, -1);}
46bdbd4b51d350d55c12001f61109863dcce24fb63daa897bc2173d3ab927b8f
withOptionsAndVersion
public AsyncPathable<AsyncStage<Void>> withOptionsAndVersion(Set<DeleteOption> options, int version)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.version = version;    return this;}
4f6e035f2e274bed0f76f88457ab0e981f64d734118dd5ccad5812f5edb20714
withVersion
public AsyncPathable<AsyncStage<Void>> withVersion(int version)
{    this.version = version;    return this;}
f62fad027c9a256adbf40d1b6b8d3a9d9331394b8923c25db91180f542d0b964
forPath
public AsyncStage<Void> forPath(String path)
{    BuilderCommon<Void> common = new BuilderCommon<>(filters, ignoredProc);    DeleteBuilderImpl builder = new DeleteBuilderImpl(client, version, common.backgrounding, options.contains(DeleteOption.deletingChildrenIfNeeded), options.contains(DeleteOption.guaranteed), options.contains(DeleteOption.quietly));    return safeCall(common.internalCallback, () -> builder.forPath(path));}
caaa2d502da51d64e96e66fd257b54ff3038140a42bd2bdaf3fbf31f062ae854
withOptions
public AsyncPathable<AsyncStage<Stat>> withOptions(Set<ExistsOption> options)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    return this;}
20dc2c55e9fba24d783c97c9f4534087c92e1508b8680155a2ab7a46f471e0af
forPath
public AsyncStage<Stat> forPath(String path)
{    BuilderCommon<Stat> common = new BuilderCommon<>(filters, watchMode, safeStatProc);    ExistsBuilderImpl builder = new ExistsBuilderImpl(client, common.backgrounding, common.watcher, options.contains(ExistsOption.createParentsIfNeeded), options.contains(ExistsOption.createParentsAsContainers));    return safeCall(common.internalCallback, () -> builder.forPath(path));}
f967e1358528eb87946fdfa77f4fd3c250367017e4c3fb633a968b6df9e89a1b
forPath
public AsyncStage<List<String>> forPath(String path)
{    BuilderCommon<List<String>> common = new BuilderCommon<>(filters, watchMode, childrenProc);    GetChildrenBuilderImpl builder = new GetChildrenBuilderImpl(client, common.watcher, common.backgrounding, stat);    return safeCall(common.internalCallback, () -> builder.forPath(path));}
7a2ff7d264257b20d5f090e0c63eed46d9c5e9db84d31eb928c03a31d67807de
storingStatIn
public AsyncPathable<AsyncStage<List<String>>> storingStatIn(Stat stat)
{    this.stat = stat;    return this;}
9bb86cb67938060bd9900c027bf1be4f4f4fea7fbdd34d7eb6d7a32b64220f88
storingStatIn
public AsyncEnsemblable<AsyncStage<byte[]>> storingStatIn(Stat stat)
{    this.stat = stat;    return this;}
357a941088e85ea7e542ae2401574970e84c274dc0008ae1336250e090248960
forEnsemble
public AsyncStage<byte[]> forEnsemble()
{    BuilderCommon<byte[]> common = new BuilderCommon<>(filters, watchMode, dataProc);    GetConfigBuilderImpl builder = new GetConfigBuilderImpl(client, common.backgrounding, common.watcher, stat);    return safeCall(common.internalCallback, builder::forEnsemble);}
79dbae66f8cfca811d025a5cf8d2b8a7c8511e5ddd18532ba1da5b964109c77a
decompressed
public AsyncPathable<AsyncStage<byte[]>> decompressed()
{    decompressed = true;    return this;}
cac0130927a666c83572675909a5dc6209b35ef9097ebb1d73d8b5a4bd3ddb67
storingStatIn
public AsyncPathable<AsyncStage<byte[]>> storingStatIn(Stat stat)
{    this.stat = stat;    return this;}
1d12310f80d6282eb0d0326a2b3e2f539a6163d4ca680d0a15cbf6a5b56b7b70
decompressedStoringStatIn
public AsyncPathable<AsyncStage<byte[]>> decompressedStoringStatIn(Stat stat)
{    decompressed = true;    this.stat = stat;    return this;}
14685c3d104b8b91242259ea39565e2b8805643849eb3620954e1d3db79e0e83
forPath
public AsyncStage<byte[]> forPath(String path)
{    BuilderCommon<byte[]> common = new BuilderCommon<>(filters, watchMode, dataProc);    GetDataBuilderImpl builder = new GetDataBuilderImpl(client, stat, common.watcher, common.backgrounding, decompressed);    return safeCall(common.internalCallback, () -> builder.forPath(path));}
fb28e912ef8d2399f8df0a32be5872f1e766698a1cbb09fb768dc8b36e4c01db
withNewMembers
public AsyncEnsemblable<AsyncStage<Void>> withNewMembers(List<String> servers)
{    this.newMembers = servers;    return this;}
460e35f275a2b2bf52baa0fb3b8a7bc87a18a8ca19e65c169ffb53d0952bb700
withJoiningAndLeaving
public AsyncEnsemblable<AsyncStage<Void>> withJoiningAndLeaving(List<String> joining, List<String> leaving)
{    this.joining = joining;    this.leaving = leaving;    return this;}
4c44f1ddd373f99b339c61412440ca99994406fd6e0c051e2252ea25835981f3
withNewMembers
public AsyncEnsemblable<AsyncStage<Void>> withNewMembers(List<String> servers, Stat stat)
{    this.newMembers = servers;    this.stat = stat;    return this;}
e5067e6a3784783b73de5311ea88eb1769959f94512dccdbf8c94481111a6086
withJoiningAndLeaving
public AsyncEnsemblable<AsyncStage<Void>> withJoiningAndLeaving(List<String> joining, List<String> leaving, Stat stat)
{    this.joining = joining;    this.leaving = leaving;    return this;}
1b0a864c18731972b38c889abc5ea3fb3bbd18baa38e6efde123ddd397b5b0a3
withNewMembers
public AsyncEnsemblable<AsyncStage<Void>> withNewMembers(List<String> servers, Stat stat, long fromConfig)
{    this.newMembers = servers;    this.stat = stat;    this.fromConfig = fromConfig;    return this;}
83a9255cefe984906e93de322605e0c2c0695685503a7621f88d534edadc0cef
withJoiningAndLeaving
public AsyncEnsemblable<AsyncStage<Void>> withJoiningAndLeaving(List<String> joining, List<String> leaving, Stat stat, long fromConfig)
{    this.joining = joining;    this.leaving = leaving;    this.stat = stat;    this.fromConfig = fromConfig;    return this;}
0230d7dddbb0e040c4ef5b6a31f06fbcde36cebd2425eecfb1807a68ddcf7b8c
withNewMembers
public AsyncEnsemblable<AsyncStage<Void>> withNewMembers(List<String> servers, long fromConfig)
{    this.newMembers = servers;    this.fromConfig = fromConfig;    return this;}
e2cdd46acc02dff75e9377fdb221dffd924caeb3be2273407c596bc66e239954
withJoiningAndLeaving
public AsyncEnsemblable<AsyncStage<Void>> withJoiningAndLeaving(List<String> joining, List<String> leaving, long fromConfig)
{    this.joining = joining;    this.leaving = leaving;    this.fromConfig = fromConfig;    return this;}
0643cb4b3fab89019a1e12a5b803e4414d2c0c17ce2c414628f76c12ccaa4b7f
forEnsemble
public AsyncStage<Void> forEnsemble()
{    BuilderCommon<Void> common = new BuilderCommon<>(filters, ignoredProc);    ReconfigBuilderImpl builder = new ReconfigBuilderImpl(client, common.backgrounding, stat, fromConfig, newMembers, joining, leaving);    return safeCall(common.internalCallback, () -> {        builder.forEnsemble();        return null;    });}
94fe1b0634b09539b55c33ef46730e4162b277d2ca63714ba72cd783eca3d76a
removing
public AsyncPathable<AsyncStage<Void>> removing(Watcher watcher)
{    this.watcher = Objects.requireNonNull(watcher, "watcher cannot be null");    this.curatorWatcher = null;    return this;}
8351f42da17fc5570fc93748bdb7b6bed56753735fc57404948b4fa4976c2fc7
removing
public AsyncPathable<AsyncStage<Void>> removing(CuratorWatcher watcher)
{    this.curatorWatcher = Objects.requireNonNull(watcher, "watcher cannot be null");    this.watcher = null;    return this;}
bbcf29ee055f88fa393f3e908f7f090ff915ed5697f7fb2bd1378ed46c8d5534
removingAll
public AsyncPathable<AsyncStage<Void>> removingAll()
{    this.curatorWatcher = null;    this.watcher = null;    return this;}
4752670a90112030eef6696096becfd3e9624836e50467f91bf0babf2530a6a3
removing
public AsyncPathable<AsyncStage<Void>> removing(Watcher watcher, Set<RemoveWatcherOption> options)
{    this.watcher = Objects.requireNonNull(watcher, "watcher cannot be null");    this.options = Objects.requireNonNull(options, "options cannot be null");    this.curatorWatcher = null;    return this;}
91369dbe33bc08ac8f96e13ae3c24b4fecb481717e34ba70a0a697a0434cd6d2
removing
public AsyncPathable<AsyncStage<Void>> removing(CuratorWatcher watcher, Set<RemoveWatcherOption> options)
{    this.curatorWatcher = Objects.requireNonNull(watcher, "watcher cannot be null");    this.options = Objects.requireNonNull(options, "options cannot be null");    this.watcher = null;    return this;}
82fb5c95f3cf3f826b67f42f53eebf848e35b93167f2ca527d78fe935654ac18
removingAll
public AsyncPathable<AsyncStage<Void>> removingAll(Set<RemoveWatcherOption> options)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.curatorWatcher = null;    this.watcher = null;    return this;}
12da659844d9293cde370b50ea888e111e1e2cef223b4dc7d8d759150b87beab
removing
public AsyncPathable<AsyncStage<Void>> removing(Watcher watcher, Watcher.WatcherType watcherType, Set<RemoveWatcherOption> options)
{    this.watcher = Objects.requireNonNull(watcher, "watcher cannot be null");    this.options = Objects.requireNonNull(options, "options cannot be null");    this.watcherType = Objects.requireNonNull(watcherType, "watcherType cannot be null");    this.curatorWatcher = null;    return this;}
7a407619a91bd8bcd279777678243696a5500889473b417624239aecf9391697
removing
public AsyncPathable<AsyncStage<Void>> removing(CuratorWatcher watcher, Watcher.WatcherType watcherType, Set<RemoveWatcherOption> options)
{    this.curatorWatcher = Objects.requireNonNull(watcher, "watcher cannot be null");    this.options = Objects.requireNonNull(options, "options cannot be null");    this.watcherType = Objects.requireNonNull(watcherType, "watcherType cannot be null");    this.watcher = null;    return this;}
fc3983e4a518708cdf407fcd4262820cf28a429f185840db0b3c406ffd066870
removingAll
public AsyncPathable<AsyncStage<Void>> removingAll(Watcher.WatcherType watcherType, Set<RemoveWatcherOption> options)
{    this.options = Objects.requireNonNull(options, "options cannot be null");    this.watcherType = Objects.requireNonNull(watcherType, "watcherType cannot be null");    this.curatorWatcher = null;    this.watcher = null;    return this;}
0803b81f7ff0763e97923ea2d6c59c83158d75243512fe01eb1e52f713bf8483
removing
public AsyncPathable<AsyncStage<Void>> removing(Watcher watcher, Watcher.WatcherType watcherType)
{    this.watcher = Objects.requireNonNull(watcher, "watcher cannot be null");    this.watcherType = Objects.requireNonNull(watcherType, "watcherType cannot be null");    this.curatorWatcher = null;    return this;}
f40d05aed59bbe5f57401d1dc578b754196d8a7b9896b6f8284f6a37752d0418
removing
public AsyncPathable<AsyncStage<Void>> removing(CuratorWatcher watcher, Watcher.WatcherType watcherType)
{    this.curatorWatcher = Objects.requireNonNull(watcher, "watcher cannot be null");    this.watcherType = Objects.requireNonNull(watcherType, "watcherType cannot be null");    this.watcher = null;    return this;}
5edc9bed1dcbf32e6d4fdf716fbc3d535263079c4dc35a32f8507fb65bcc18c2
removingAll
public AsyncPathable<AsyncStage<Void>> removingAll(Watcher.WatcherType watcherType)
{    this.watcherType = Objects.requireNonNull(watcherType, "watcherType cannot be null");    this.curatorWatcher = null;    this.watcher = null;    return this;}
f62fad027c9a256adbf40d1b6b8d3a9d9331394b8923c25db91180f542d0b964
forPath
public AsyncStage<Void> forPath(String path)
{    BuilderCommon<Void> common = new BuilderCommon<>(filters, ignoredProc);    RemoveWatchesBuilderImpl builder = new RemoveWatchesBuilderImpl(client, watcher, curatorWatcher, watcherType, options.contains(RemoveWatcherOption.guaranteed), options.contains(RemoveWatcherOption.local), options.contains(RemoveWatcherOption.guaranteed), common.backgrounding);    return safeCall(common.internalCallback, () -> builder.forPath(path));}
06c68e297f5015fc3a9e4651614221a21f996f0e26e800015ddfa55f25c20bb4
getRawValue
public T getRawValue()
{    return value;}
c5095d311c6db7d5a401405ba2e93da6ecd69aa080c75e930fd2878dec6f8e07
getValue
public Optional<T> getValue()
{    return Optional.ofNullable(value);}
3db652a792d57df350300ea006337c6d4faa797baec728c655879030106f19d6
getCode
public KeeperException.Code getCode()
{    return code;}
be6550b037fe78328bf97841b92d287b9a5a1e8480cc453a3c61d62829c89ecb
getRawException
public Throwable getRawException()
{    return exception;}
db0ffc942e596008ba9aafff0ef815298f203469b5524cc1a3b06126a21c00de
getException
public Optional<Throwable> getException()
{    return Optional.ofNullable(exception);}
7cc594ab1a03a209da28d97115bef67621a48119c1189566469e055eaa19ee82
checkException
public void checkException()
{    if (exception != null) {        throw new RuntimeException(exception);    }}
5357c96c01c22731380b1af28eed0af01255f21d9e2c63f3836ed45b87b4f9a8
checkError
public void checkError()
{    checkException();    if (code != KeeperException.Code.OK) {        throw new RuntimeException(KeeperException.create(code));    }}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    AsyncResultImpl<?> that = (AsyncResultImpl<?>) o;    if (value != null ? !value.equals(that.value) : that.value != null) {        return false;    }        if (code != that.code) {        return false;    }    return exception != null ? exception.equals(that.exception) : that.exception == null;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = value != null ? value.hashCode() : 0;    result = 31 * result + code.hashCode();    result = 31 * result + (exception != null ? exception.hashCode() : 0);    return result;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "AsyncResult{" + "value=" + value + ", code=" + code + ", exception=" + exception + '}';}
232d190fde658609c6129106d7d097ec09f8a7df5fec9116a84337d76ba360c7
withACL
public AsyncPathable<AsyncStage<Stat>> withACL(List<ACL> aclList)
{    this.aclList = aclList;    return this;}
456a2e24a736bb8c8f68a684d6189a5259e3db801dcd5a7522d4e6288b295068
withACL
public AsyncPathable<AsyncStage<Stat>> withACL(List<ACL> aclList, int version)
{    this.aclList = aclList;    this.version = version;    return this;}
20dc2c55e9fba24d783c97c9f4534087c92e1508b8680155a2ab7a46f471e0af
forPath
public AsyncStage<Stat> forPath(String path)
{    BuilderCommon<Stat> common = new BuilderCommon<>(filters, statProc);    SetACLBuilderImpl builder = new SetACLBuilderImpl(client, common.backgrounding, aclList, version);    return safeCall(common.internalCallback, () -> builder.forPath(path));}
20dc2c55e9fba24d783c97c9f4534087c92e1508b8680155a2ab7a46f471e0af
forPath
public AsyncStage<Stat> forPath(String path)
{    return internalForPath(path, null, false);}
dac6e84fe7c4f90313c51537bea550b83d419d81221a3599de57aec94be9485e
forPath
public AsyncStage<Stat> forPath(String path, byte[] data)
{    return internalForPath(path, data, true);}
8ae427da5116bb71eb4809eda2ff2015b79ea4b0b61d607ba67d9ed4dcf43160
compressed
public AsyncPathAndBytesable<AsyncStage<Stat>> compressed()
{    compressed = true;    return this;}
9dd0e4aea18fdd09329e35f39577bb618440ffcf7d78e522ed80dd556ce0cb0e
compressedWithVersion
public AsyncPathAndBytesable<AsyncStage<Stat>> compressedWithVersion(int version)
{    compressed = true;    this.version = version;    return this;}
a762a9416521c360545fd5720d2f05c2b7d92a7a36b9cf2b044faf3fed6ed5a8
withVersion
public AsyncPathAndBytesable<AsyncStage<Stat>> withVersion(int version)
{    this.version = version;    return this;}
c39f6c6aef8c7f800540e4d9ab7dea0f94651cae002146bf35d22bfa8b829b1a
internalForPath
private AsyncStage<Stat> internalForPath(String path, byte[] data, boolean useData)
{    BuilderCommon<Stat> common = new BuilderCommon<>(filters, statProc);    SetDataBuilderImpl builder = new SetDataBuilderImpl(client, common.backgrounding, version, compressed);    return safeCall(common.internalCallback, () -> useData ? builder.forPath(path, data) : builder.forPath(path));}
6f3df26eb5f15afe848779475fa1d375d80e8f2bb7d554988c10b976d8121736
create
public AsyncTransactionCreateBuilder create()
{    return new AsyncTransactionCreateBuilder() {        private List<ACL> aclList = null;        private CreateMode createMode = CreateMode.PERSISTENT;        private boolean compressed = false;        private long ttl = -1;        @Override        public AsyncPathAndBytesable<CuratorOp> withMode(CreateMode createMode) {            this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");            return this;        }        @Override        public AsyncPathAndBytesable<CuratorOp> withACL(List<ACL> aclList) {            this.aclList = aclList;            return this;        }        @Override        public AsyncPathAndBytesable<CuratorOp> compressed() {            compressed = true;            return this;        }        @Override        public AsyncPathAndBytesable<CuratorOp> withTtl(long ttl) {            this.ttl = ttl;            return this;        }        @Override        public AsyncPathAndBytesable<CuratorOp> withOptions(CreateMode createMode, List<ACL> aclList, boolean compressed) {            return withOptions(createMode, aclList, compressed, ttl);        }        @Override        public AsyncPathAndBytesable<CuratorOp> withOptions(CreateMode createMode, List<ACL> aclList, boolean compressed, long ttl) {            this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");            this.aclList = aclList;            this.compressed = compressed;            this.ttl = ttl;            return this;        }        @Override        public CuratorOp forPath(String path, byte[] data) {            return internalForPath(path, data, true);        }        @Override        public CuratorOp forPath(String path) {            return internalForPath(path, null, false);        }        private CuratorOp internalForPath(String path, byte[] data, boolean useData) {            TransactionCreateBuilder2<CuratorOp> builder1 = (ttl > 0) ? client.transactionOp().create().withTtl(ttl) : client.transactionOp().create();            ACLPathAndBytesable<CuratorOp> builder2 = compressed ? builder1.compressed().withMode(createMode) : builder1.withMode(createMode);            PathAndBytesable<CuratorOp> builder3 = builder2.withACL(aclList);            try {                return useData ? builder3.forPath(path, data) : builder3.forPath(path);            } catch (Exception e) {                                throw new RuntimeException(e);            }        }    };}
221f63a36e4bbeda04dffe8e780e28dadcb7bf3d207de18331f3cd39b7c0798a
withMode
public AsyncPathAndBytesable<CuratorOp> withMode(CreateMode createMode)
{    this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");    return this;}
29243b36a9b114ae4c9c97193f78b87ceb7767c2b442091ca7ecc0f53985b653
withACL
public AsyncPathAndBytesable<CuratorOp> withACL(List<ACL> aclList)
{    this.aclList = aclList;    return this;}
59358f42ad6d6e3a4a90ab388a0620074bb207bc2c41d349b149810c0c913c7f
compressed
public AsyncPathAndBytesable<CuratorOp> compressed()
{    compressed = true;    return this;}
5a36793beed0a116cf5f9e24271a1344ad919def59efd0d178612a4d7d818577
withTtl
public AsyncPathAndBytesable<CuratorOp> withTtl(long ttl)
{    this.ttl = ttl;    return this;}
10402b491e61ea64b90b3c3c91fd2fe5fdee8672e49a129d5d60e889ff6edb07
withOptions
public AsyncPathAndBytesable<CuratorOp> withOptions(CreateMode createMode, List<ACL> aclList, boolean compressed)
{    return withOptions(createMode, aclList, compressed, ttl);}
c383dc7b973979f5d2aa680a6ef4c398d15045eac649fb9d188353e488e1f8aa
withOptions
public AsyncPathAndBytesable<CuratorOp> withOptions(CreateMode createMode, List<ACL> aclList, boolean compressed, long ttl)
{    this.createMode = Objects.requireNonNull(createMode, "createMode cannot be null");    this.aclList = aclList;    this.compressed = compressed;    this.ttl = ttl;    return this;}
23cbc9457fbcd8c1b86fd903e11add92656f0d7dacc71b423f599f7cb070fab7
forPath
public CuratorOp forPath(String path, byte[] data)
{    return internalForPath(path, data, true);}
d7aa0a479cb4742f4ab9111a1e9b501850b01b8143a01f4f6b45151a300e0cbd
forPath
public CuratorOp forPath(String path)
{    return internalForPath(path, null, false);}
27511aae035cf68f8ec07ca3b05bc7c032894e2bd61dc86513ec70a7a9507386
internalForPath
private CuratorOp internalForPath(String path, byte[] data, boolean useData)
{    TransactionCreateBuilder2<CuratorOp> builder1 = (ttl > 0) ? client.transactionOp().create().withTtl(ttl) : client.transactionOp().create();    ACLPathAndBytesable<CuratorOp> builder2 = compressed ? builder1.compressed().withMode(createMode) : builder1.withMode(createMode);    PathAndBytesable<CuratorOp> builder3 = builder2.withACL(aclList);    try {        return useData ? builder3.forPath(path, data) : builder3.forPath(path);    } catch (Exception e) {                throw new RuntimeException(e);    }}
32c9c416662dc85fffc063acbc4315fc7d50c8ab48eb1b292bbd7f4d9e8b081c
delete
public AsyncTransactionDeleteBuilder delete()
{    return new AsyncTransactionDeleteBuilder() {        private int version = -1;        @Override        public AsyncPathable<CuratorOp> withVersion(int version) {            this.version = version;            return this;        }        @Override        public CuratorOp forPath(String path) {            try {                return client.transactionOp().delete().withVersion(version).forPath(path);            } catch (Exception e) {                                throw new RuntimeException(e);            }        }    };}
695d36f3d6a98a557d079ea9687d4085d66502e7363ea9f50df8bbfd83232bc2
withVersion
public AsyncPathable<CuratorOp> withVersion(int version)
{    this.version = version;    return this;}
d7aa0a479cb4742f4ab9111a1e9b501850b01b8143a01f4f6b45151a300e0cbd
forPath
public CuratorOp forPath(String path)
{    try {        return client.transactionOp().delete().withVersion(version).forPath(path);    } catch (Exception e) {                throw new RuntimeException(e);    }}
e5627905f707f856e1caf63d55cc5996d9065d5e07ce92427a2290898a340cc4
setData
public AsyncTransactionSetDataBuilder setData()
{    return new AsyncTransactionSetDataBuilder() {        private int version = -1;        private boolean compressed = false;        @Override        public AsyncPathAndBytesable<CuratorOp> withVersion(int version) {            this.version = version;            return this;        }        @Override        public AsyncPathAndBytesable<CuratorOp> compressed() {            compressed = true;            return this;        }        @Override        public AsyncPathAndBytesable<CuratorOp> withVersionCompressed(int version) {            this.version = version;            compressed = true;            return this;        }        @Override        public CuratorOp forPath(String path, byte[] data) {            return internalForPath(path, data, true);        }        @Override        public CuratorOp forPath(String path) {            return internalForPath(path, null, false);        }        private CuratorOp internalForPath(String path, byte[] data, boolean useData) {            TransactionSetDataBuilder<CuratorOp> builder1 = client.transactionOp().setData();            VersionPathAndBytesable<CuratorOp> builder2 = compressed ? builder1.compressed() : builder1;            PathAndBytesable<CuratorOp> builder3 = builder2.withVersion(version);            try {                return useData ? builder3.forPath(path, data) : builder3.forPath(path);            } catch (Exception e) {                                throw new RuntimeException(e);            }        }    };}
e3db155860f54151b1dd69772c262402d94c9b5c888f5c05528c62c34b8b5338
withVersion
public AsyncPathAndBytesable<CuratorOp> withVersion(int version)
{    this.version = version;    return this;}
59358f42ad6d6e3a4a90ab388a0620074bb207bc2c41d349b149810c0c913c7f
compressed
public AsyncPathAndBytesable<CuratorOp> compressed()
{    compressed = true;    return this;}
006d8bd50c52cac1b6fd07f1b2538765a92c1b9ced9e46e9f91c8ac1e20838cd
withVersionCompressed
public AsyncPathAndBytesable<CuratorOp> withVersionCompressed(int version)
{    this.version = version;    compressed = true;    return this;}
23cbc9457fbcd8c1b86fd903e11add92656f0d7dacc71b423f599f7cb070fab7
forPath
public CuratorOp forPath(String path, byte[] data)
{    return internalForPath(path, data, true);}
d7aa0a479cb4742f4ab9111a1e9b501850b01b8143a01f4f6b45151a300e0cbd
forPath
public CuratorOp forPath(String path)
{    return internalForPath(path, null, false);}
27511aae035cf68f8ec07ca3b05bc7c032894e2bd61dc86513ec70a7a9507386
internalForPath
private CuratorOp internalForPath(String path, byte[] data, boolean useData)
{    TransactionSetDataBuilder<CuratorOp> builder1 = client.transactionOp().setData();    VersionPathAndBytesable<CuratorOp> builder2 = compressed ? builder1.compressed() : builder1;    PathAndBytesable<CuratorOp> builder3 = builder2.withVersion(version);    try {        return useData ? builder3.forPath(path, data) : builder3.forPath(path);    } catch (Exception e) {                throw new RuntimeException(e);    }}
4305a65291f08258c7886bd2f04a2ff72f0421b91cbaef98b988aa1c04e60a83
check
public AsyncTransactionCheckBuilder check()
{    return new AsyncTransactionCheckBuilder() {        private int version = -1;        @Override        public AsyncPathable<CuratorOp> withVersion(int version) {            this.version = version;            return this;        }        @Override        public CuratorOp forPath(String path) {            try {                return client.transactionOp().check().withVersion(version).forPath(path);            } catch (Exception e) {                                throw new RuntimeException(e);            }        }    };}
695d36f3d6a98a557d079ea9687d4085d66502e7363ea9f50df8bbfd83232bc2
withVersion
public AsyncPathable<CuratorOp> withVersion(int version)
{    this.version = version;    return this;}
d7aa0a479cb4742f4ab9111a1e9b501850b01b8143a01f4f6b45151a300e0cbd
forPath
public CuratorOp forPath(String path)
{    try {        return client.transactionOp().check().withVersion(version).forPath(path);    } catch (Exception e) {                throw new RuntimeException(e);    }}
075550fe17db6e89665942e823eb32a51fcad075b08c5e70789cda558bd5c6c2
makeProc
 static BackgroundProc<T> makeProc(Function<CuratorEvent, T> proc)
{    return (event, future) -> {        if (event.getResultCode() == 0) {            future.complete(proc.apply(event));        } else {            future.completeExceptionally(KeeperException.create(KeeperException.Code.get(event.getResultCode()), event.getPath()));        }        return null;    };}
b5d60f9ee9807235ee04d1821b8345275b52e498bb923fed1ae6116668955b67
safeCall
 static InternalCallback<T> safeCall(InternalCallback<T> callback, Callable<?> proc)
{    try {        proc.call();    } catch (Exception e) {        callback.toCompletableFuture().completeExceptionally(e);    }    return callback;}
300c2380eeee5147dbb81ab2f317b975ec366c289d0312714068c0c71700bc34
getListener
public UnhandledErrorListener getListener()
{    return listener;}
eef628f564f492a37f60dcd7dc9129d6aad2793a78677c688566ca691bebfeda
getResultFilter
public UnaryOperator<CuratorEvent> getResultFilter()
{    return resultFilter;}
b27c7633691d04b24d9a8b6583075edbf6ce71401d1369b063ff7c472b843805
getWatcherFilter
public UnaryOperator<WatchedEvent> getWatcherFilter()
{    return watcherFilter;}
014f61054f1a84eaca98854504ec47ef670544bd20af0d6c9b69adc5800ca5e5
event
public CompletionStage<WatchedEvent> event()
{    return (watcher != null) ? watcher.getFuture() : null;}
b15db2206745a2e048aecb00f5e17c1f2122669bec5b5561a85daa3def7e8295
processResult
public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
{    event = (resultFilter != null) ? resultFilter.apply(event) : event;    resultFunction.apply(event, this);}
95719dc5c73b53579980b18a85f53154deeb30b5d2632cd3da983395be29dec5
getFuture
 CompletableFuture<WatchedEvent> getFuture()
{    return future;}
2770860b795b2ad33dfdd3b58d4ea43558859c568c7f0eaceafd485db76124d0
process
public void process(WatchedEvent event)
{    final WatchedEvent localEvent = (watcherFilter != null) ? watcherFilter.apply(event) : event;    switch(localEvent.getState()) {        default:            {                if ((watchMode != WatchMode.stateChangeOnly) && (localEvent.getType() != Event.EventType.None)) {                    if (!future.complete(localEvent)) {                        future.obtrudeValue(localEvent);                    }                }                break;            }        case Disconnected:        case AuthFailed:        case Expired:            {                if (watchMode != WatchMode.successOnly) {                    AsyncEventException exception = new AsyncEventException() {                        private final AtomicBoolean isReset = new AtomicBoolean(false);                        @Override                        public Event.KeeperState getKeeperState() {                            return localEvent.getState();                        }                        @Override                        public CompletionStage<WatchedEvent> reset() {                            Preconditions.checkState(isReset.compareAndSet(false, true), "Already reset");                            future = new CompletableFuture<>();                            return future;                        }                    };                    future.completeExceptionally(exception);                }                break;            }    }}
4d7eeeee136ea2cd8244a1ff3a410633569c32704829728797518f26a18f1e47
getKeeperState
public Event.KeeperState getKeeperState()
{    return localEvent.getState();}
c804105434c56890209a249d598729a731b7b2965271bfe78e3256a65f1e291d
reset
public CompletionStage<WatchedEvent> reset()
{    Preconditions.checkState(isReset.compareAndSet(false, true), "Already reset");    future = new CompletableFuture<>();    return future;}
c4f2fee394ca8abf57e25b60ed3a5febf3e2144435ea025f159725012fcba41e
getMigrationId
public String getMigrationId()
{    return migrationId;}
a39ac25f6eb5266c57ad25d1f6199a1f8b940338eb60c8fadfc654e2ea591593
migrate
public CompletionStage<Void> migrate(MigrationSet set)
{    InterProcessLock lock = new InterProcessSemaphoreMutex(client.unwrap(), ZKPaths.makePath(lockPath, set.id()));    CompletionStage<Void> lockStage = lockAsync(lock, lockMax.toMillis(), TimeUnit.MILLISECONDS, executor);    return lockStage.thenCompose(__ -> runMigrationInLock(lock, set));}
3d4d00e4f306c62bb04a31949137c96138fcfcb7fd35e6f2e8a42854019b528b
filter
protected List<Migration> filter(MigrationSet set, List<byte[]> operationHashesInOrder) throws MigrationException
{    if (operationHashesInOrder.size() > set.migrations().size()) {        throw new MigrationException(set.id(), String.format("More metadata than migrations. Migration ID: %s", set.id()));    }    int compareSize = Math.min(set.migrations().size(), operationHashesInOrder.size());    for (int i = 0; i < compareSize; ++i) {        byte[] setHash = hash(set.migrations().get(i).operations());        if (!Arrays.equals(setHash, operationHashesInOrder.get(i))) {            throw new MigrationException(set.id(), String.format("Metadata mismatch. Migration ID: %s", set.id()));        }    }    return set.migrations().subList(operationHashesInOrder.size(), set.migrations().size());}
3e89836c7465d059f5ff54879982af24b3d374c21f45daaee6467d30ba0f7782
hash
private byte[] hash(List<CuratorOp> operations)
{    MessageDigest digest;    try {        digest = MessageDigest.getInstance("SHA-256");    } catch (NoSuchAlgorithmException e) {        throw new RuntimeException(e);    }    operations.forEach(op -> {        if (op instanceof ExtractingCuratorOp) {            ((ExtractingCuratorOp) op).addToDigest(digest);        } else {            digest.update(op.toString().getBytes());        }    });    return digest.digest();}
228e9320838f1810af775d6b77eacd3d83304c092d6e82db6c56692e648c82dd
runMigrationInLock
private CompletionStage<Void> runMigrationInLock(InterProcessLock lock, MigrationSet set)
{    String thisMetaDataPath = ZKPaths.makePath(metaDataPath, set.id());    return childrenWithData(client, thisMetaDataPath).thenCompose(metaData -> applyMetaData(set, metaData, thisMetaDataPath)).handle((v, e) -> {        release(lock, true);        if (e != null) {            Throwables.propagate(e);        }        return v;    });}
54f8de5ffdb5fec9eec04bc6dc0d265d72de72beb4ae34e912725d71c94bd28a
applyMetaData
private CompletionStage<Void> applyMetaData(MigrationSet set, Map<String, byte[]> metaData, String thisMetaDataPath)
{    List<byte[]> sortedMetaData = metaData.keySet().stream().sorted(Comparator.naturalOrder()).map(metaData::get).collect(Collectors.toList());    List<Migration> toBeApplied;    try {        toBeApplied = filter(set, sortedMetaData);    } catch (MigrationException e) {        CompletableFuture<Void> future = new CompletableFuture<>();        future.completeExceptionally(e);        return future;    }    if (toBeApplied.size() == 0) {        return CompletableFuture.completedFuture(null);    }    return asyncEnsureContainers(client, thisMetaDataPath).thenCompose(__ -> applyMetaDataAfterEnsure(toBeApplied, thisMetaDataPath));}
3f31e01ecc82a2f92e1d4ca9bc72f2277b8cfe0d04b920bb2bdf839a47b65952
applyMetaDataAfterEnsure
private CompletionStage<Void> applyMetaDataAfterEnsure(List<Migration> toBeApplied, String thisMetaDataPath)
{    if (debugCount != null) {        debugCount.incrementAndGet();    }    List<CuratorOp> operations = new ArrayList<>();    String metaDataBasePath = ZKPaths.makePath(thisMetaDataPath, META_DATA_NODE_NAME);    toBeApplied.forEach(migration -> {        List<CuratorOp> thisMigrationOperations = migration.operations();        operations.addAll(thisMigrationOperations);        operations.add(client.transactionOp().create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath(metaDataBasePath, hash(thisMigrationOperations)));    });    return client.transaction().forOperations(operations).thenApply(__ -> null);}
ce65457dc09c7035b942805e4d1c767005e7db9c1a75038469fe95a04ed1df2f
build
 static MigrationSet build(String id, List<Migration> migrations)
{    Objects.requireNonNull(id, "id cannot be null");    final List<Migration> migrationsCopy = ImmutableList.copyOf(migrations);    return new MigrationSet() {        @Override        public String id() {            return id;        }        @Override        public List<Migration> migrations() {            return migrationsCopy;        }    };}
726b8178a99f285885e5d815cd322858d3b648329701168df677a9c461bade67
id
public String id()
{    return id;}
5444465f015511b08e7787c1fafa586e74a970e3209efc329a0bae525ff22c7e
migrations
public List<Migration> migrations()
{    return migrationsCopy;}
bbc71eb53c1eaf9a312138c161eaf9494b5342697da0b029b2efdd3c951a8c4c
initialized
 void initialized()
{}
9baf81cfb233c1873d2cbfb8b93f140c4f51e0fb4ca39a3e5b9f5e69c00f33e4
handleException
 void handleException(Exception e)
{    LoggerFactory.getLogger(getClass()).error("Could not process cache message", e);}
19e0fa5c57589e6ea62f8a980a42ddb38c8dc46c7ec04260b095b539e7e8de68
postInitializedOnly
 ModeledCacheListener<T> postInitializedOnly()
{    return new ModeledCacheListener<T>() {        private volatile boolean isInitialized = false;        @Override        public void accept(Type type, ZPath path, Stat stat, T model) {            if (isInitialized) {                ModeledCacheListener.this.accept(type, path, stat, model);            }        }        @Override        public void initialized() {            isInitialized = true;            ModeledCacheListener.this.initialized();        }    };}
7fb1613103f60afb16275ce04006b1e3b11263f5b3f4c61628eb6a90f8cbebe5
accept
public void accept(Type type, ZPath path, Stat stat, T model)
{    if (isInitialized) {        ModeledCacheListener.this.accept(type, path, stat, model);    }}
75f656a9432478e668854233def1cc480a0f570f5d310312c55a6033b540a1ae
initialized
public void initialized()
{    isInitialized = true;    ModeledCacheListener.this.initialized();}
981921588e1774b803e198710cd766476083fa3b930c6ba58b7cf1ff000482c9
cache
public ModeledCache<T> cache()
{    return cache;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    cache.start();}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    cache.close();}
ea903fd3d6ab6b40cdfda6aa5dac412bfab68ca8eeeb9a711eed4d57120a4095
listenable
public Listenable<ModeledCacheListener<T>> listenable()
{    return cache.listenable();}
18673c78778f7004109083ac87d421ed3782e5f77db4c2b4aaf787fe33422497
cached
public CachedModeledFramework<T> cached()
{    throw new UnsupportedOperationException("Already a cached instance");}
3bd32eafce53b3c816cebf19c70e109e37c14d3435e89f4658e243bec8003800
cached
public CachedModeledFramework<T> cached(ExecutorService executor)
{    throw new UnsupportedOperationException("Already a cached instance");}
2d5f0a173ecfba8ee92b1c15d3587536298045f51ea9ee60faab80fe058c0074
versioned
public VersionedModeledFramework<T> versioned()
{    return new VersionedModeledFrameworkImpl<>(this);}
cdbdb872dc1800c61c18010cec3a7039d1846c25d2e6b9b04309b96c98d35a61
unwrap
public AsyncCuratorFramework unwrap()
{    return client.unwrap();}
5140aa9a2982f310a162fe67d40ee3c224dbb5759b1f17360a443ba51015f91a
modelSpec
public ModelSpec<T> modelSpec()
{    return client.modelSpec();}
a883ea993f9fd41a988fbfa915ce0728c245837036bd6eb7d0e5ff8cbfe18137
child
public CachedModeledFramework<T> child(Object child)
{    return new CachedModeledFrameworkImpl<>(client.child(child), cache, executor);}
85dae45aa36937b7e8c30d170d859771212810ba19aa23f08462d41693e4fac9
parent
public ModeledFramework<T> parent()
{    throw new UnsupportedOperationException("Not supported for CachedModeledFramework. Instead, call parent() on the ModeledFramework before calling cached()");}
e9a307cc0c08506e588da16d9642abd44fcf5c110a4a2387c4ac9c8b2591688c
withPath
public CachedModeledFramework<T> withPath(ZPath path)
{    return new CachedModeledFrameworkImpl<>(client.withPath(path), cache, executor);}
9fbb3319059a8cd235a769cb2d3ef52f805ebdde4189f1b42e8eaa59978508b7
set
public AsyncStage<String> set(T model)
{    return client.set(model);}
25f5ad36e766163dd2ba09915fd6d020e3bf62c01d7e7312c6c5b6220e093c80
set
public AsyncStage<String> set(T model, Stat storingStatIn)
{    return client.set(model, storingStatIn);}
ae09cc4dc0f4877ffc1aae654f33cf2a77ff4b622b8b951eac38934888f761b2
set
public AsyncStage<String> set(T model, Stat storingStatIn, int version)
{    return client.set(model, storingStatIn, version);}
2804c6c06e9b135ddd127925cf452cb918cb3b5b2e58675ee229400feb425e54
set
public AsyncStage<String> set(T model, int version)
{    return client.set(model, version);}
e8c81619f926bae2e7870466abe60fa775addfecd14cf0ccdfee4d6a98a29267
read
public AsyncStage<T> read()
{    return internalRead(ZNode::model, this::exceptionally);}
63829db1477b5ec7f8bfd96080b4cb73546c1ece0c36ed1710bdbd08eff9833b
read
public AsyncStage<T> read(Stat storingStatIn)
{    return internalRead(n -> {        if (storingStatIn != null) {            DataTree.copyStat(n.stat(), storingStatIn);        }        return n.model();    }, this::exceptionally);}
413e6166284afd6d62cd14cff1d5ce88084497802a6df9b92d676bdc941ea3de
readAsZNode
public AsyncStage<ZNode<T>> readAsZNode()
{    return internalRead(Function.identity(), this::exceptionally);}
5aad46863f7f374e5a38521876a2fdca01e71638e1c060294a5895e4fa08c631
readThrough
public AsyncStage<T> readThrough()
{    return internalRead(ZNode::model, client::read);}
bc5211866532fe4588444a31812256bc80d5817e11bee18a2cd58e03c5a9aedf
readThrough
public AsyncStage<T> readThrough(Stat storingStatIn)
{    return internalRead(ZNode::model, () -> client.read(storingStatIn));}
98c79ebacb20edccdef1c55f73483693ca32bbf21069d2b2a54649b34816098c
readThroughAsZNode
public AsyncStage<ZNode<T>> readThroughAsZNode()
{    return internalRead(Function.identity(), client::readAsZNode);}
453bacf8a805c8fe20274d3e7c415af6a804ec919046d28f8e20fe37b1c9672c
list
public AsyncStage<List<T>> list()
{    List<T> children = cache.currentChildren().values().stream().map(ZNode::model).collect(Collectors.toList());    return ModelStage.completed(children);}
91e82669691b52f47edadc441b4c5076730c1b396a2f2153eca7709576e13ab9
update
public AsyncStage<Stat> update(T model)
{    return client.update(model);}
364479a41f90eb00a6832d5908ff4332d02998f848987fd25bd8929f1e2c6b6a
update
public AsyncStage<Stat> update(T model, int version)
{    return client.update(model, version);}
444fedae440eb128ab6aef204ac938e01e0c0f2b8115defc3f94aa2672b1eca3
delete
public AsyncStage<Void> delete()
{    return client.delete();}
b2155ff91482db16e86a0443bb0d55fc776fd26ed3edad3a439866d1b89358f9
delete
public AsyncStage<Void> delete(int version)
{    return client.delete(version);}
0b81052e59cd29589868f941dbf6c747b842c42ee818698dc33fb61810489383
checkExists
public AsyncStage<Stat> checkExists()
{    ZPath path = client.modelSpec().path();    Optional<ZNode<T>> data = cache.currentData(path);    return data.map(node -> completed(node.stat())).orElseGet(() -> completed(null));}
6a93733456117b41e4a91eccf295bb0ee57fc51d633f2388adc10226baf60ee9
children
public AsyncStage<List<ZPath>> children()
{    List<ZPath> paths = cache.currentChildren(client.modelSpec().path()).keySet().stream().filter(path -> !path.isRoot() && path.parent().equals(client.modelSpec().path())).collect(Collectors.toList());    return completed(paths);}
45d0dae654796176bebcc490d47167244ad1ea3fb30b52fb5d369a9eabfe228a
childrenAsZNodes
public AsyncStage<List<ZNode<T>>> childrenAsZNodes()
{    List<ZNode<T>> nodes = cache.currentChildren(client.modelSpec().path()).entrySet().stream().filter(e -> !e.getKey().isRoot() && e.getKey().parent().equals(client.modelSpec().path())).map(Map.Entry::getValue).collect(Collectors.toList());    return completed(nodes);}
2d9379690fef7a484d3feb4da93f5a707906b31c7f01c21e0bc015b2fa18861c
createOp
public CuratorOp createOp(T model)
{    return client.createOp(model);}
34e604d69fe27acbf6e82e14104e3710be8e01f97bbe5d8c673527b20d64e481
updateOp
public CuratorOp updateOp(T model)
{    return client.updateOp(model);}
05627489629781bd8c0c7fc02a80b23f28cd2401e9c227dcf24bb41e5703d461
updateOp
public CuratorOp updateOp(T model, int version)
{    return client.updateOp(model, version);}
aa9903903d0d1d56d0a64d90726081def6346e48cbb86ef05f6865624da15a01
deleteOp
public CuratorOp deleteOp()
{    return client.deleteOp();}
701cb63007e2ab6b5ac67a73dfcb0f94d2b70837f80ae7b0d359f58b8d534208
deleteOp
public CuratorOp deleteOp(int version)
{    return client.deleteOp(version);}
f968a18560779ae55e301eb89c48660b2608cafe5d7265f9395754d2c02a05ac
checkExistsOp
public CuratorOp checkExistsOp()
{    return client.checkExistsOp();}
de0d6301e174d97182c004c22b3dc8bd43363d866e996fcee43879f37fca453d
checkExistsOp
public CuratorOp checkExistsOp(int version)
{    return client.checkExistsOp(version);}
d02478cb74e67e465d63612dbfa209185c10f00bd30a2d196ac18d19be47056a
inTransaction
public AsyncStage<List<CuratorTransactionResult>> inTransaction(List<CuratorOp> operations)
{    return client.inTransaction(operations);}
ef8a07b5bb1e99ec4548c88f61688f06cd562a2a28e0d65ca9056089297ffcfd
completed
private AsyncStage<U> completed(U value)
{    return ModelStage.completed(value);}
79bac0e11a4c97efc84e10c3ea2d611d4d8c795c664e14454510fdc50189625c
exceptionally
private AsyncStage<U> exceptionally()
{    KeeperException.NoNodeException exception = new KeeperException.NoNodeException(client.modelSpec().path().fullPath());    return ModelStage.exceptionally(exception);}
b29e8789d55f641b0d799ed43ee26293180594c92f0447a6e941e5a0c474f422
internalRead
private AsyncStage<U> internalRead(Function<ZNode<T>, U> resolver, Supplier<AsyncStage<U>> elseProc)
{    ZPath path = client.modelSpec().path();    Optional<ZNode<T>> data = cache.currentData(path);    return data.map(node -> completed(resolver.apply(node))).orElseGet(elseProc);}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    try {        cache.getListenable().addListener(this);        cache.start();    } catch (Exception e) {        throw new RuntimeException(e);    }}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    cache.getListenable().removeListener(this);    cache.close();    entries.clear();}
2f19853f0c2088cb5bb69b018c47c29ea090c0cedc5c276fb22006f37a3bd333
currentData
public Optional<ZNode<T>> currentData(ZPath path)
{    Entry<T> entry = entries.remove(path);    if (entry != null) {        return Optional.of(new ZNodeImpl<>(path, entry.stat, entry.model));    }    return Optional.empty();}
126d539877002e79843a347632e950c8cda0a559b039534cb5e0976c1d304a7d
basePath
 ZPath basePath()
{    return basePath;}
814811bc92c4df74a826bf678727db44a56bced320a34e7a4e3a3f6e12a43119
currentChildren
 Map<ZPath, ZNode<T>> currentChildren()
{    return currentChildren(basePath);}
9d63be2b92aeb76f172519fe3a824630dcf918ddd0d42acf3486aaf010f23cef
currentChildren
public Map<ZPath, ZNode<T>> currentChildren(ZPath path)
{    return entries.entrySet().stream().filter(entry -> entry.getKey().startsWith(path)).map(entry -> new AbstractMap.SimpleEntry<>(entry.getKey(), new ZNodeImpl<>(entry.getKey(), entry.getValue().stat, entry.getValue().model))).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));}
ea903fd3d6ab6b40cdfda6aa5dac412bfab68ca8eeeb9a711eed4d57120a4095
listenable
public Listenable<ModeledCacheListener<T>> listenable()
{    return listenerContainer;}
6932058e62f507d91a4a8ad0adbb31479bc531a4c3ba7a5b3e6f445da98270bf
childEvent
public void childEvent(CuratorFramework client, TreeCacheEvent event)
{    try {        internalChildEvent(event);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        listenerContainer.forEach(l -> {            l.handleException(e);            return null;        });    }}
4067ec8d9406365ec8a9976f50e1355fcbeca63d2ce2b4b4d4116689711947b4
internalChildEvent
private void internalChildEvent(TreeCacheEvent event) throws Exception
{    switch(event.getType()) {        case NODE_ADDED:        case NODE_UPDATED:            {                ZPath path = ZPath.parse(event.getData().getPath());                if (!path.equals(basePath)) {                    byte[] bytes = event.getData().getData();                    if (                    (bytes != null) && (bytes.length > 0)) {                        T model = serializer.deserialize(bytes);                        entries.put(path, new Entry<>(event.getData().getStat(), model));                        ModeledCacheListener.Type type = (event.getType() == TreeCacheEvent.Type.NODE_ADDED) ? ModeledCacheListener.Type.NODE_ADDED : ModeledCacheListener.Type.NODE_UPDATED;                        accept(type, path, event.getData().getStat(), model);                    }                }                break;            }        case NODE_REMOVED:            {                ZPath path = ZPath.parse(event.getData().getPath());                if (!path.equals(basePath)) {                    Entry<T> entry = entries.remove(path);                    T model = (entry != null) ? entry.model : serializer.deserialize(event.getData().getData());                    Stat stat = (entry != null) ? entry.stat : event.getData().getStat();                    accept(ModeledCacheListener.Type.NODE_REMOVED, path, stat, model);                }                break;            }        case INITIALIZED:            {                listenerContainer.forEach(l -> {                    l.initialized();                    return null;                });                break;            }        default:                        break;    }}
fc4b2492421a5372235dc9af2245f5bfc1eb010246edfff568380ff86d1d8b5f
accept
private void accept(ModeledCacheListener.Type type, ZPath path, Stat stat, T model)
{    listenerContainer.forEach(l -> {        l.accept(type, path, stat, model);        return null;    });}
80941379ef79ef8166da88be6d6c3a5d64cc3452c8f73f482e41b3f86e49d005
build
public static ModeledFrameworkImpl<T> build(AsyncCuratorFramework client, ModelSpec<T> model, WatchMode watchMode, UnaryOperator<WatchedEvent> watcherFilter, UnhandledErrorListener unhandledErrorListener, UnaryOperator<CuratorEvent> resultFilter, Set<ModeledOptions> modeledOptions)
{    boolean isWatched = (watchMode != null);    Objects.requireNonNull(client, "client cannot be null");    Objects.requireNonNull(model, "model cannot be null");    modeledOptions = ImmutableSet.copyOf(Objects.requireNonNull(modeledOptions, "modeledOptions cannot be null"));    watchMode = (watchMode != null) ? watchMode : WatchMode.stateChangeAndSuccess;    AsyncCuratorFrameworkDsl dslClient = client.with(watchMode, unhandledErrorListener, resultFilter, watcherFilter);    WatchableAsyncCuratorFramework watchableClient = isWatched ? dslClient.watched() : dslClient;    return new ModeledFrameworkImpl<>(client, dslClient, watchableClient, model, watchMode, watcherFilter, unhandledErrorListener, resultFilter, isWatched, modeledOptions);}
18673c78778f7004109083ac87d421ed3782e5f77db4c2b4aaf787fe33422497
cached
public CachedModeledFramework<T> cached()
{    return cached(ThreadUtils.newSingleThreadExecutor("CachedModeledFramework"));}
3bd32eafce53b3c816cebf19c70e109e37c14d3435e89f4658e243bec8003800
cached
public CachedModeledFramework<T> cached(ExecutorService executor)
{    Preconditions.checkState(!isWatched, "CachedModeledFramework cannot be used with watched instances as the internal cache would bypass the watchers.");    return new CachedModeledFrameworkImpl<>(this, Objects.requireNonNull(executor, "executor cannot be null"));}
2d5f0a173ecfba8ee92b1c15d3587536298045f51ea9ee60faab80fe058c0074
versioned
public VersionedModeledFramework<T> versioned()
{    return new VersionedModeledFrameworkImpl<>(this);}
5140aa9a2982f310a162fe67d40ee3c224dbb5759b1f17360a443ba51015f91a
modelSpec
public ModelSpec<T> modelSpec()
{    return modelSpec;}
cdbdb872dc1800c61c18010cec3a7039d1846c25d2e6b9b04309b96c98d35a61
unwrap
public AsyncCuratorFramework unwrap()
{    return client;}
5cd7dfa04e0ef6b47104ea61bd69da37a1ff489dbc4fa82bf5d4b59875b9e0ae
set
public AsyncStage<String> set(T item)
{    return set(item, null, -1);}
11e71b97f53d61d6917a62dc514917445623ef615c6b3a269d8a872ada0adb7b
set
public AsyncStage<String> set(T item, Stat storingStatIn)
{    return set(item, storingStatIn, -1);}
e6d79b824c25fccefcd9e68c016d7a8d0e5723d2012dc7547cb910727ec376b4
set
public AsyncStage<String> set(T item, int version)
{    return set(item, null, version);}
9c05acfcdee74e041a713391fb74f2393787b9aca4629200957f825007b32fb2
set
public AsyncStage<String> set(T item, Stat storingStatIn, int version)
{    try {        byte[] bytes = modelSpec.serializer().serialize(item);        return dslClient.create().withOptions(modelSpec.createOptions(), modelSpec.createMode(), fixAclList(modelSpec.aclList()), storingStatIn, modelSpec.ttl(), version).forPath(resolveForSet(item), bytes);    } catch (Exception e) {        return ModelStage.exceptionally(e);    }}
e8c81619f926bae2e7870466abe60fa775addfecd14cf0ccdfee4d6a98a29267
read
public AsyncStage<T> read()
{    return internalRead(ZNode::model, null);}
63829db1477b5ec7f8bfd96080b4cb73546c1ece0c36ed1710bdbd08eff9833b
read
public AsyncStage<T> read(Stat storingStatIn)
{    return internalRead(ZNode::model, storingStatIn);}
413e6166284afd6d62cd14cff1d5ce88084497802a6df9b92d676bdc941ea3de
readAsZNode
public AsyncStage<ZNode<T>> readAsZNode()
{    return internalRead(Function.identity(), null);}
ed588a469b5a9aa0f1e67432f6e6d0e453429c36df06b62a973ed205772ff6b8
update
public AsyncStage<Stat> update(T item)
{    return update(item, -1);}
f530fad03e640264ddb48a1c2f9b1d71111d45cf8e8d54775355c139784e4e66
update
public AsyncStage<Stat> update(T item, int version)
{    try {        byte[] bytes = modelSpec.serializer().serialize(item);        AsyncPathAndBytesable<AsyncStage<Stat>> next = isCompressed() ? dslClient.setData().compressedWithVersion(version) : dslClient.setData();        return next.forPath(resolveForSet(item), bytes);    } catch (Exception e) {        return ModelStage.exceptionally(e);    }}
0b81052e59cd29589868f941dbf6c747b842c42ee818698dc33fb61810489383
checkExists
public AsyncStage<Stat> checkExists()
{    return watchableClient.checkExists().forPath(modelSpec.path().fullPath());}
444fedae440eb128ab6aef204ac938e01e0c0f2b8115defc3f94aa2672b1eca3
delete
public AsyncStage<Void> delete()
{    return delete(-1);}
b2155ff91482db16e86a0443bb0d55fc776fd26ed3edad3a439866d1b89358f9
delete
public AsyncStage<Void> delete(int version)
{    return dslClient.delete().withVersion(version).forPath(modelSpec.path().fullPath());}
6a93733456117b41e4a91eccf295bb0ee57fc51d633f2388adc10226baf60ee9
children
public AsyncStage<List<ZPath>> children()
{    return internalGetChildren(modelSpec.path());}
45d0dae654796176bebcc490d47167244ad1ea3fb30b52fb5d369a9eabfe228a
childrenAsZNodes
public AsyncStage<List<ZNode<T>>> childrenAsZNodes()
{    ModelStage<List<ZNode<T>>> modelStage = ModelStage.make();    Preconditions.checkState(!isWatched, "childrenAsZNodes() cannot be used with watched instances.");    children().handle((children, e) -> {        if (e != null) {            modelStage.completeExceptionally(e);        } else {            completeChildrenAsZNodes(modelStage, children);        }        return null;    });    return modelStage;}
d5c2764dc40369100ef33416cc76eff2d4787bf283d712f9a14ccefbc9f6d247
completeChildrenAsZNodes
private void completeChildrenAsZNodes(ModelStage<List<ZNode<T>>> modelStage, List<ZPath> children)
{    List<ZNode<T>> nodes = Lists.newArrayList();    if (children.size() == 0) {        modelStage.complete(nodes);        return;    }    children.forEach(path -> withPath(path).readAsZNode().handle((node, e) -> {        if (e != null) {            modelStage.completeExceptionally(e);        } else {            nodes.add(node);            if (nodes.size() == children.size()) {                modelStage.complete(nodes);            }        }        return null;    }));}
f3a6213e0f9e4763f9a596bed300f0f1be6fb51978ac9d7ea1401ea2c60b973c
internalGetChildren
private AsyncStage<List<ZPath>> internalGetChildren(ZPath path)
{    AsyncStage<List<String>> asyncStage = watchableClient.getChildren().forPath(path.fullPath());    ModelStage<List<ZPath>> modelStage = ModelStage.make(asyncStage.event());    asyncStage.whenComplete((children, e) -> {        if (e != null) {            if (modeledOptions.contains(ModeledOptions.ignoreMissingNodesForChildren) && (Throwables.getRootCause(e) instanceof KeeperException.NoNodeException)) {                modelStage.complete(Collections.emptyList());            } else {                modelStage.completeExceptionally(e);            }        } else {            modelStage.complete(children.stream().map(path::child).collect(Collectors.toList()));        }    });    return modelStage;}
85dae45aa36937b7e8c30d170d859771212810ba19aa23f08462d41693e4fac9
parent
public ModeledFramework<T> parent()
{    ModelSpec<T> newModelSpec = modelSpec.parent();    return new ModeledFrameworkImpl<>(client, dslClient, watchableClient, newModelSpec, watchMode, watcherFilter, unhandledErrorListener, resultFilter, isWatched, modeledOptions);}
5ba5cc663121215f43d2862a32a86792bca7fb67c2d26355d136fe35795089a5
child
public ModeledFramework<T> child(Object child)
{    ModelSpec<T> newModelSpec = modelSpec.child(child);    return new ModeledFrameworkImpl<>(client, dslClient, watchableClient, newModelSpec, watchMode, watcherFilter, unhandledErrorListener, resultFilter, isWatched, modeledOptions);}
57bfcc0b902f5c4a15f55a141cdd80881b28bd29e9a215b1ed4c2434d3e31a8a
withPath
public ModeledFramework<T> withPath(ZPath path)
{    ModelSpec<T> newModelSpec = modelSpec.withPath(path);    return new ModeledFrameworkImpl<>(client, dslClient, watchableClient, newModelSpec, watchMode, watcherFilter, unhandledErrorListener, resultFilter, isWatched, modeledOptions);}
c2b9d34d353adfde7978abd0ef8832314ae0c31c0968466132216f2ca1e3dbd2
isCompressed
public static boolean isCompressed(Set<CreateOption> createOptions)
{    return createOptions.contains(CreateOption.compress);}
2d9379690fef7a484d3feb4da93f5a707906b31c7f01c21e0bc015b2fa18861c
createOp
public CuratorOp createOp(T model)
{    return client.transactionOp().create().withOptions(modelSpec.createMode(), fixAclList(modelSpec.aclList()), modelSpec.createOptions().contains(CreateOption.compress), modelSpec.ttl()).forPath(resolveForSet(model), modelSpec.serializer().serialize(model));}
34e604d69fe27acbf6e82e14104e3710be8e01f97bbe5d8c673527b20d64e481
updateOp
public CuratorOp updateOp(T model)
{    return updateOp(model, -1);}
05627489629781bd8c0c7fc02a80b23f28cd2401e9c227dcf24bb41e5703d461
updateOp
public CuratorOp updateOp(T model, int version)
{    AsyncTransactionSetDataBuilder builder = client.transactionOp().setData();    if (isCompressed()) {        return builder.withVersionCompressed(version).forPath(resolveForSet(model), modelSpec.serializer().serialize(model));    }    return builder.withVersion(version).forPath(resolveForSet(model), modelSpec.serializer().serialize(model));}
aa9903903d0d1d56d0a64d90726081def6346e48cbb86ef05f6865624da15a01
deleteOp
public CuratorOp deleteOp()
{    return deleteOp(-1);}
701cb63007e2ab6b5ac67a73dfcb0f94d2b70837f80ae7b0d359f58b8d534208
deleteOp
public CuratorOp deleteOp(int version)
{    return client.transactionOp().delete().withVersion(version).forPath(modelSpec.path().fullPath());}
f968a18560779ae55e301eb89c48660b2608cafe5d7265f9395754d2c02a05ac
checkExistsOp
public CuratorOp checkExistsOp()
{    return checkExistsOp(-1);}
de0d6301e174d97182c004c22b3dc8bd43363d866e996fcee43879f37fca453d
checkExistsOp
public CuratorOp checkExistsOp(int version)
{    return client.transactionOp().check().withVersion(version).forPath(modelSpec.path().fullPath());}
d02478cb74e67e465d63612dbfa209185c10f00bd30a2d196ac18d19be47056a
inTransaction
public AsyncStage<List<CuratorTransactionResult>> inTransaction(List<CuratorOp> operations)
{    return client.transaction().forOperations(operations);}
6372607e5370c3a5717b5e0b5cc89f5281f43fac16018aa0c728631f63440ed1
isCompressed
private boolean isCompressed()
{    return modelSpec.createOptions().contains(CreateOption.compress);}
0b19c05bf5a412f50cb614d0fa0dc8cfd53e40ac7213e77cecc3666dc2460665
internalRead
private ModelStage<U> internalRead(Function<ZNode<T>, U> resolver, Stat storingStatIn)
{    Stat stat = (storingStatIn != null) ? storingStatIn : new Stat();    AsyncPathable<AsyncStage<byte[]>> next = isCompressed() ? watchableClient.getData().decompressedStoringStatIn(stat) : watchableClient.getData().storingStatIn(stat);    AsyncStage<byte[]> asyncStage = next.forPath(modelSpec.path().fullPath());    ModelStage<U> modelStage = ModelStage.make(asyncStage.event());    asyncStage.whenComplete((value, e) -> {        if (e != null) {            modelStage.completeExceptionally(e);        } else {            try {                ZNode<T> node = new ZNodeImpl<>(modelSpec.path(), stat, modelSpec.serializer().deserialize(value));                modelStage.complete(resolver.apply(node));            } catch (Exception deserializeException) {                modelStage.completeExceptionally(deserializeException);            }        }    });    return modelStage;}
cc0d1ec5fbf640f80110134dc556bbf3659422192002eb13c1084e4300b66ac1
resolveForSet
private String resolveForSet(T model)
{    if (modelSpec.path().isResolved()) {        return modelSpec.path().fullPath();    }    return modelSpec.path().resolved(model).fullPath();}
5bcf6ba7fce7c05bf9262ed571b13090f1ce91bdda480a29f35e7e90b857b2a2
fixAclList
private List<ACL> fixAclList(List<ACL> aclList)
{        return (aclList.size() > 0) ? aclList : null;}
a739ed6060c8b9ed551fed81eee38a7c8a3f695cf4e6d1a395f93fcf76db8c1e
child
public ModelSpec<T> child(Object child)
{    return withPath(path.child(child));}
9203d157fa4fc7122ea22a9c7575bd2fa4cae2caccd3fc20bc20c7d28ce1cb77
parent
public ModelSpec<T> parent()
{    return withPath(path.parent());}
9e4d50fe1e42dadb2f5543382085b3fd02cc0e0d3a6f80de17894afebb2bddcb
resolved
public ModelSpec<T> resolved(Object... parameters)
{    return withPath(path.resolved(parameters));}
3e125c442a9a8e8c7bf8d4b0ba96ed8c770bd46e64169c021ec1b5378badef0c
resolved
public ModelSpec<T> resolved(List<Object> parameters)
{    return withPath(path.resolved(parameters));}
75c477b50434f9fe60eb6037fdc2c140a3ca2c9c21a813d8589be765689d72a2
withPath
public ModelSpec<T> withPath(ZPath newPath)
{    return new ModelSpecImpl<>(newPath, serializer, createMode, aclList, createOptions, deleteOptions, ttl);}
77701749211a8e2508273b60fc35507724cb4654967897ec05b630b4916257be
path
public ZPath path()
{    return path;}
decf76b2489f3e716a4af71dce4aacfc125f0848d24de7d6c5f2ccd19f7a9d32
serializer
public ModelSerializer<T> serializer()
{    return serializer;}
94d54bb89486b91c2266fc685362b3783ac34e3e1e5eae0e23c8cb01a5a40254
createMode
public CreateMode createMode()
{    return createMode;}
9aa24c950a5e8148658b4dd9a1d7ec9bba638444a640453c2760546534f9f9b4
aclList
public List<ACL> aclList()
{    return aclList;}
67795d86e98d4d2a66c42cf9ed7b1105a2468b3f96e58c07d2eb2171f899a4d7
createOptions
public Set<CreateOption> createOptions()
{    return createOptions;}
79608f644815eee017fca23183cdc17ff7823ccec6ebe7dc8a9e5d611f3614c5
deleteOptions
public Set<DeleteOption> deleteOptions()
{    return deleteOptions;}
bc564c4832b67ad95256833fe1303b5d432ae5a93edef922e972bac4e9b59d7a
ttl
public long ttl()
{    return ttl;}
c52dad28bb284c1b557b01c79e8d70d378e1f5f78fa5aa60eba6515bed5959ab
schema
public Schema schema()
{    if (schema == null) {        schema = Schema.builder(path.toSchemaPathPattern()).dataValidator(this).ephemeral(createMode.isEphemeral() ? Schema.Allowance.MUST : Schema.Allowance.CANNOT).canBeDeleted(true).sequential(createMode.isSequential() ? Schema.Allowance.MUST : Schema.Allowance.CANNOT).watched(Schema.Allowance.CAN).build();    }    return schema;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    ModelSpecImpl<?> modelSpec = (ModelSpecImpl<?>) o;    if (ttl != modelSpec.ttl) {        return false;    }    if (!path.equals(modelSpec.path)) {        return false;    }    if (!serializer.equals(modelSpec.serializer)) {        return false;    }    if (createMode != modelSpec.createMode) {        return false;    }    if (!aclList.equals(modelSpec.aclList)) {        return false;    }    if (!createOptions.equals(modelSpec.createOptions)) {        return false;    }        if (!deleteOptions.equals(modelSpec.deleteOptions)) {        return false;    }    return schema.equals(modelSpec.schema);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = path.hashCode();    result = 31 * result + serializer.hashCode();    result = 31 * result + createMode.hashCode();    result = 31 * result + aclList.hashCode();    result = 31 * result + createOptions.hashCode();    result = 31 * result + deleteOptions.hashCode();    result = 31 * result + (int) (ttl ^ (ttl >>> 32));    result = 31 * result + schema.hashCode();    return result;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "ModelSpecImpl{" + "path=" + path + ", serializer=" + serializer + ", createMode=" + createMode + ", aclList=" + aclList + ", createOptions=" + createOptions + ", deleteOptions=" + deleteOptions + ", ttl=" + ttl + ", schema=" + schema + '}';}
4dd27bc0255a4567b42d9dab830ee2af76cde5f11beb92791531b3ae8d93b00f
isValid
public boolean isValid(Schema schema, String path, byte[] data, List<ACL> acl)
{    if (acl != null) {        List<ACL> localAclList = (aclList.size() > 0) ? aclList : ZooDefs.Ids.OPEN_ACL_UNSAFE;        if (!acl.equals(localAclList)) {            throw new SchemaViolation(schema, new SchemaViolation.ViolatorData(path, data, acl), "ACLs do not match model ACLs");        }    }    if (data != null) {        try {            serializer.deserialize(data);        } catch (RuntimeException e) {            throw new SchemaViolation(schema, new SchemaViolation.ViolatorData(path, data, acl), "Data cannot be deserialized into a model");        }    }    return true;}
64af1cdfd0d1a049f3c6736d281c352417700362955910686675cf76a676c1ff
make
 static ModelStage<U> make()
{    return new ModelStage<>(null);}
32f0629fa69d9d11f80c41e4ae3dfe2fef4c8a5a57f930122715642bde1ce900
make
 static ModelStage<U> make(CompletionStage<WatchedEvent> event)
{    return new ModelStage<>(event);}
8ea4e778278c7b7b620454f464f4708a1643a185f17bcc2c5d11699b98060a7e
completed
 static ModelStage<U> completed(U value)
{    ModelStage<U> stage = new ModelStage<>(null);    stage.complete(value);    return stage;}
f2e7d1be1d865c0b8c85895a5004255bb9d41813c5f4635b59896a0bf25dd6d7
exceptionally
 static ModelStage<U> exceptionally(Exception e)
{    ModelStage<U> stage = new ModelStage<>(null);    stage.completeExceptionally(e);    return stage;}
4804a8e4191157e8b3cccfbcf69ad6c6d50d5a0b8579b1f4d0c099306229524b
async
 static ModelStage<U> async(Executor executor)
{    return new AsyncModelStage<>(executor);}
0c1df73545e240c6653767d2f76860eaf1bddc92c6b19241a344163c10682300
asyncCompleted
 static ModelStage<U> asyncCompleted(U value, Executor executor)
{    ModelStage<U> stage = new AsyncModelStage<>(executor);    stage.complete(value);    return stage;}
f2cf5f00f1c78a155fa00da136774b625e1970d0b936b96e9191da9856c4dcca
asyncExceptionally
 static ModelStage<U> asyncExceptionally(Exception e, Executor executor)
{    ModelStage<U> stage = new AsyncModelStage<>(executor);    stage.completeExceptionally(e);    return stage;}
014f61054f1a84eaca98854504ec47ef670544bd20af0d6c9b69adc5800ca5e5
event
public CompletionStage<WatchedEvent> event()
{    return event;}
3ffc809a681b12bc3bf4f6c5ecba971204b01b322eeb175c3ef07ef9c4317a16
thenApplyAsync
public CompletableFuture<U1> thenApplyAsync(Function<? super U, ? extends U1> fn)
{    return super.thenApplyAsync(fn, executor);}
b4f394e504fa03517a789e6a858a40fdabf16d5c4118e7c3e473a72416d9c6c0
thenAcceptAsync
public CompletableFuture<Void> thenAcceptAsync(Consumer<? super U> action)
{    return super.thenAcceptAsync(action, executor);}
c4ef7a67f68d10f1d11fda18f6474ffd077afcf85741ef2c963e6999db782af6
thenRunAsync
public CompletableFuture<Void> thenRunAsync(Runnable action)
{    return super.thenRunAsync(action, executor);}
acdb29fa8cd318fb016facf655b0c47ea5e9a2a347299f82f44fc2bdef88d6a7
thenCombineAsync
public CompletableFuture<V> thenCombineAsync(CompletionStage<? extends U1> other, BiFunction<? super U, ? super U1, ? extends V> fn)
{    return super.thenCombineAsync(other, fn, executor);}
1fa5bc7ba8b5ad5428e53a0301ed5469694c2decf6c41b85669f3fef713b2fa2
thenAcceptBothAsync
public CompletableFuture<Void> thenAcceptBothAsync(CompletionStage<? extends U1> other, BiConsumer<? super U, ? super U1> action)
{    return super.thenAcceptBothAsync(other, action, executor);}
0feeb90a27920abfd08054b08f907ce098716586ee400eb3cfb30cb29f5520aa
runAfterBothAsync
public CompletableFuture<Void> runAfterBothAsync(CompletionStage<?> other, Runnable action)
{    return super.runAfterBothAsync(other, action, executor);}
f0764b0bf50b807c80b8bf4c84e22938b0e74ab2f6e1f44a832ccb6e76283682
applyToEitherAsync
public CompletableFuture<U1> applyToEitherAsync(CompletionStage<? extends U> other, Function<? super U, U1> fn)
{    return super.applyToEitherAsync(other, fn, executor);}
667982bd433761aa1466aaab1447963f29df8f5cef8d86b64deca9b519e6717f
acceptEitherAsync
public CompletableFuture<Void> acceptEitherAsync(CompletionStage<? extends U> other, Consumer<? super U> action)
{    return super.acceptEitherAsync(other, action, executor);}
20d77e20c49278e38871119893e4f0f18b0bcaed0594398b901e158ad3c00ba2
runAfterEitherAsync
public CompletableFuture<Void> runAfterEitherAsync(CompletionStage<?> other, Runnable action)
{    return super.runAfterEitherAsync(other, action, executor);}
2839cc018fa64818730f085ac29720055cc8790877904a93d5eee1a636eaa91a
thenComposeAsync
public CompletableFuture<U1> thenComposeAsync(Function<? super U, ? extends CompletionStage<U1>> fn)
{    return super.thenComposeAsync(fn, executor);}
90d95d57716c2d32e67a23f6247929db5d7b94326b9667a78f49f58a4f5f6ab4
whenCompleteAsync
public CompletableFuture<U> whenCompleteAsync(BiConsumer<? super U, ? super Throwable> action)
{    return super.whenCompleteAsync(action, executor);}
711bd338afb0635cd6c8d3793c08e20407bdc6d20823debcea0d3ff61c042b7f
handleAsync
public CompletableFuture<U1> handleAsync(BiFunction<? super U, Throwable, ? extends U1> fn)
{    return super.handleAsync(fn, executor);}
b3df1d4bbf08dd6997a62e4aab9082fadb746e28958457956f63af0712480557
set
public AsyncStage<String> set(Versioned<T> model)
{    return client.set(model.model(), model.version());}
e85ab3adea085b1a6955b429b2bbf338ab55e0e68485c50d85603e8197813f14
set
public AsyncStage<String> set(Versioned<T> model, Stat storingStatIn)
{    return client.set(model.model(), storingStatIn, model.version());}
d72d90f0798efbeb2cb2f458dac7564ae2c3b4c5017ccbf88f617356abb21853
read
public AsyncStage<Versioned<T>> read()
{    return read(null);}
50e498b1e94da5591839bda2774226b357026ff72626b5d1d608ac57f1c23701
read
public AsyncStage<Versioned<T>> read(Stat storingStatIn)
{    Stat localStat = (storingStatIn != null) ? storingStatIn : new Stat();    AsyncStage<T> stage = client.read(localStat);    ModelStage<Versioned<T>> modelStage = ModelStage.make(stage.event());    stage.whenComplete((model, e) -> {        if (e != null) {            modelStage.completeExceptionally(e);        } else {            modelStage.complete(Versioned.from(model, localStat.getVersion()));        }    });    return modelStage;}
13f64ee9771dc2ad9df7f3797ac25ce5f89a456e83343ae38cd024ca2947e4c5
update
public AsyncStage<Stat> update(Versioned<T> model)
{    return client.update(model.model(), model.version());}
501b668e36872dd4d9440b16e510c18723b0a44ee8c4ea45b077f3411150981a
updateOp
public CuratorOp updateOp(Versioned<T> model)
{    return client.updateOp(model.model(), model.version());}
77701749211a8e2508273b60fc35507724cb4654967897ec05b630b4916257be
path
public ZPath path()
{    return path;}
d74d659de4bc1a638b6313f182da375e1bc314372ee360868421613a5faf36b6
stat
public Stat stat()
{    return stat;}
3a8a3e52167a8b671221410ff01a4be735c647be2331097ef783e651f9451c53
model
public T model()
{    return model;}
4dd01101a4f98877f37cf3a0a5acc0c25ae10818fe46f5842c9cab7782018289
parse
public static ZPath parse(String fullPath, UnaryOperator<String> nameFilter)
{    return parseInternal(fullPath, nameFilter);}
db5474473e8091da83cfc4df3e8e38701fd5a90b344e142ea45fe19e5f48a8c0
parseInternal
private static ZPathImpl parseInternal(String fullPath, UnaryOperator<String> nameFilter)
{    List<String> nodes = ImmutableList.<String>builder().add(PATH_SEPARATOR).addAll(Splitter.on(PATH_SEPARATOR).omitEmptyStrings().splitToList(fullPath).stream().map(nameFilter).collect(Collectors.toList())).build();    nodes.forEach(ZPathImpl::validate);    return new ZPathImpl(nodes, null);}
800e8a0a62c150996210a2c26b0e756cc2754846ec470180c880c8982544beea
from
public static ZPath from(String[] names)
{    return from(null, Arrays.asList(names));}
7bbb953b27743f5008876a14fa466bf8766b7a98a2f50614ac35331bf495e8a9
from
public static ZPath from(List<String> names)
{    return from(null, names);}
aed95e48b48ac5e8cb298d90a041b0c961849f5e4b13c85df81a713f73828a02
from
public static ZPath from(ZPath base, String[] names)
{    return from(base, Arrays.asList(names));}
f65bb1ce1bbe185caa8cf720de39fd602bb8560d3853d2c73b4de1226b7fe88e
from
public static ZPath from(ZPath base, List<String> names)
{    names = Objects.requireNonNull(names, "names cannot be null");    names.forEach(ZPathImpl::validate);    ImmutableList.Builder<String> builder = ImmutableList.builder();    if (base != null) {        if (base instanceof ZPathImpl) {            builder.addAll(((ZPathImpl) base).nodes);        } else {            builder.addAll(Splitter.on(PATH_SEPARATOR).omitEmptyStrings().splitToList(base.fullPath()));        }    } else {        builder.add(PATH_SEPARATOR);    }    List<String> nodes = builder.addAll(names).build();    return new ZPathImpl(nodes, null);}
1d9e876387185ee3add6f2dec0746e7bb7a9276192f33cf8494dd1406d6e77cd
child
public ZPath child(Object child)
{    return new ZPathImpl(nodes, NodeName.nameFrom(child));}
b037ddcc34cb4a37e8ac20b22ee4865942f3dea885195a4d0f1da86674c65952
parent
public ZPath parent()
{    checkRootAccess();    if (parent == null) {        parent = new ZPathImpl(nodes.subList(0, nodes.size() - 1), null);    }    return parent;}
655dc46d4e3f4c9f9f9659b5145b2ea56dfb6d560d157ef33ffa3c1813f2a0fa
isRoot
public boolean isRoot()
{    return nodes.size() == 1;}
044d789af19e6f890c2b9ceb70770e56333d5847d63cad12b56d53d8e462d546
startsWith
public boolean startsWith(ZPath path)
{    ZPathImpl rhs;    if (path instanceof ZPathImpl) {        rhs = (ZPathImpl) path;    } else {        rhs = parseInternal(path.fullPath(), s -> s);    }    return (nodes.size() >= rhs.nodes.size()) && nodes.subList(0, rhs.nodes.size()).equals(rhs.nodes);}
98bd3e5a5f822cf46ce53145be15ff82c3c4e637f30f6f717c203f50018466bb
toSchemaPathPattern
public Pattern toSchemaPathPattern()
{    if (schema == null) {        schema = Pattern.compile(buildFullPath(s -> isParameter(s) ? ".*" : s));    }    return schema;}
ca56aa4fc6f9d190252c4128905154be0c568ee05f6663433e05f81a6092733d
fullPath
public String fullPath()
{    checkResolved();    if (fullPath == null) {        fullPath = buildFullPath(s -> s);    }    return fullPath;}
6df6555f68d39768e223ec04511b3e80c37a296912e147a95680e6a0c17047c8
nodeName
public String nodeName()
{    return nodes.get(nodes.size() - 1);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    ZPathImpl zPaths = (ZPathImpl) o;    return nodes.equals(zPaths.nodes);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return nodes.hashCode();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return nodes.subList(1, nodes.size()).stream().map(name -> isParameter(name) ? name.substring(1) : name).collect(Collectors.joining(PATH_SEPARATOR, PATH_SEPARATOR, ""));}
88c26d5a58413f483b6ec1fc97fa370a2a4b235ef28b298320902cb58ee186c0
resolved
public ZPath resolved(List<Object> parameters)
{    Iterator<Object> iterator = parameters.iterator();    List<String> nodeNames = nodes.stream().map(name -> {        if (isParameter(name) && iterator.hasNext()) {            return NodeName.nameFrom(iterator.next());        }        return name;    }).collect(Collectors.toList());    return new ZPathImpl(nodeNames, null);}
2fa99a8aa2d293aadf123d8cbc90fb9b630a79bcc950706530654a9eec5b5162
isResolved
public boolean isResolved()
{    return isResolved;}
d7ed798d2f3d88760a1b1ca7d60117a6791331c3aa12e43e3f0e44f845136812
isParameter
private static boolean isParameter(String name)
{    return (name.length() > 1) && name.startsWith(PATH_SEPARATOR);}
f8d069d045665348eab0189555e94e4159ff8ba9769a5a39ed5b9a2bc0c2be37
checkRootAccess
private void checkRootAccess()
{    if (isRoot()) {        throw new NoSuchElementException("The root has no parent");    }}
60377eba8848ad0822ba61eab9057d2c695a040db371c84681c05a572878f4f0
checkResolved
private void checkResolved()
{    if (!isResolved) {        throw new IllegalStateException("This ZPath has not been resolved: " + toString());    }}
d22b9cee0ac065dd62dd577353368c710e229c5b7c3ed1202bf31f21aa8bc0f6
validate
private static void validate(String nodeName)
{    if (isParameter(Objects.requireNonNull(nodeName, "nodeName cannot be null"))) {        return;    }    if (nodeName.equals(PATH_SEPARATOR)) {        return;    }    PathUtils.validatePath(PATH_SEPARATOR + nodeName);}
12ff58bb003fbcd16c9b82d7bbd8aa4c9876c5e606fe81e9dd0f1ea1f0fb85ae
buildFullPath
private String buildFullPath(UnaryOperator<String> filter)
{    boolean addSeparator = false;    StringBuilder str = new StringBuilder();    int size = nodes.size();    int parameterIndex = 0;    for (int i = 0; i < size; ++i) {        if (i > 1) {            str.append(PATH_SEPARATOR);        }        str.append(filter.apply(nodes.get(i)));    }    return str.toString();}
482fa2015f4ac0c4e637e5c88d362caadfa814813f3ca0c37eec7eb875087925
build
public static JacksonModelSerializer<T> build(Class<T> modelClass)
{    return new JacksonModelSerializer<>(modelClass);}
304538e4e166a156fd23fc68714c7ec900a9864224fd13cd17c82d50f0fc365a
build
public static JacksonModelSerializer<T> build(JavaType type)
{    return new JacksonModelSerializer<>(type);}
720366f0b8a150dc3b40f01ae3e087ea6e9bc24a6e431bb7a383229968a77061
build
public static JacksonModelSerializer<T> build(TypeReference type)
{    return new JacksonModelSerializer<>(type);}
76284db4455179a07e3d097423c8d4ececf7716c502ad2c0a54651e04261ec38
serialize
public byte[] serialize(T model)
{    try {        return writer.writeValueAsBytes(model);    } catch (JsonProcessingException e) {        throw new RuntimeException(String.format("Could not serialize value: %s", model), e);    }}
91b0982581f64b18e1b763d25d1ec6fdc402cc3b7930e4dfe33f68281152ac61
deserialize
public T deserialize(byte[] bytes)
{    try {        return reader.readValue(bytes);    } catch (IOException e) {        throw new RuntimeException(String.format("Could not deserialize value: %s", Arrays.toString(bytes)), e);    }}
9aa6775481d5e82d769728ac5e3c92a5f2fe50b2941ef2ee27e5c3b0c956326a
wrap
 static ModeledFramework<T> wrap(AsyncCuratorFramework client, ModelSpec<T> model)
{    return builder(client, model).build();}
bfd23091c1707e57a4fa5d572404d6c3b1ec864b11231de9089fa551725c69a5
builder
 static ModeledFrameworkBuilder<T> builder(AsyncCuratorFramework client, ModelSpec<T> model)
{    return new ModeledFrameworkBuilder<>(client, model);}
b8566b8d67a7d2cf77f895c358219ceae7737adcf72b55b22f6c73ebe8f81cff
builder
 static ModeledFrameworkBuilder<T> builder()
{    return new ModeledFrameworkBuilder<>();}
eb8236af1d84951fc0351d6378370a551ac6838ca31796301109a47d5fb0cdf7
build
public ModeledFramework<T> build()
{    return ModeledFrameworkImpl.build(client, modelSpec, watchMode, watcherFilter, unhandledErrorListener, resultFilter, modeledOptions);}
6974f5d27291caa80797a67400690fd49e5124d3c7d6b658c63b10bdac0e2002
watched
public ModeledFrameworkBuilder<T> watched()
{    this.watchMode = WatchMode.stateChangeAndSuccess;    return this;}
5b4c546e87e4c76eeccf70597c430874bcfc232e184310b4094427f9662f2afd
watched
public ModeledFrameworkBuilder<T> watched(WatchMode watchMode)
{    this.watchMode = watchMode;    return this;}
b7862d2bd30fc646f24d994ec3edbdad51a8cbda0c8322110dc4d68ce85020fe
watched
public ModeledFrameworkBuilder<T> watched(WatchMode watchMode, UnaryOperator<WatchedEvent> watcherFilter)
{    this.watchMode = watchMode;    this.watcherFilter = watcherFilter;    return this;}
603baeb6ed5c4c1a56ab8986b94c47a57b22e0df015b0cf6c58ce2b36e0f96ab
withUnhandledErrorListener
public ModeledFrameworkBuilder<T> withUnhandledErrorListener(UnhandledErrorListener unhandledErrorListener)
{    this.unhandledErrorListener = unhandledErrorListener;    return this;}
df03d313fb0c3edd7757aa982c0825040f5e1fdb6b7b768540400cabd06fba21
withResultFilter
public ModeledFrameworkBuilder<T> withResultFilter(UnaryOperator<CuratorEvent> resultFilter)
{    this.resultFilter = resultFilter;    return this;}
f1f91b443da4128742d41464c4c29f92b413e0ca20fbdd3142177ca671bc99ab
withModelSpec
public ModeledFrameworkBuilder<T> withModelSpec(ModelSpec<T> modelSpec)
{    this.modelSpec = Objects.requireNonNull(modelSpec, "modelSpec cannot be null");    return this;}
7e97abcfa82355729e6beed82f1acbf9ec149829c14bea1c85e8fe9765370f93
withClient
public ModeledFrameworkBuilder<T> withClient(AsyncCuratorFramework client)
{    this.client = Objects.requireNonNull(client, "client cannot be null");    return this;}
405bc3b353f731d403385422b7fd1e873b0a576d6278ac75a8a4cebadc9f5203
withOptions
public ModeledFrameworkBuilder<T> withOptions(Set<ModeledOptions> modeledOptions)
{    this.modeledOptions = ImmutableSet.copyOf(Objects.requireNonNull(modeledOptions, "client cannot be null"));    return this;}
ab18e467bacc4bc8f1b67eaa5838f543090f2b31d9691273ecb7f7d15a506bfc
serialize
public byte[] serialize(byte[] model)
{    return model;}
0019bc7915e95c37fb4ec6bf10ab2d14cc8dfa108926f087ba5f61cc1519156a
deserialize
public byte[] deserialize(byte[] bytes)
{    return bytes;}
4ad34be8307025a69513b4a21f0d2aa24d54a26a3d140710bd815deaa3ec0836
builder
 static ModelSpecBuilder<T> builder(ZPath path, ModelSerializer<T> serializer)
{    return new ModelSpecBuilder<>(path, serializer).withCreateOptions(defaultCreateOptions).withDeleteOptions(defaultDeleteOptions);}
2b11f63baa74219a72aea5936a42daa0a6dccbb4bab10baf1293587e6be16656
builder
 static ModelSpecBuilder<T> builder(ModelSerializer<T> serializer)
{    return new ModelSpecBuilder<>(serializer).withCreateOptions(defaultCreateOptions).withDeleteOptions(defaultDeleteOptions);}
a1becf3f1967c25ab443dd697badb28a360e5c6d3f7136ebdb3faac4e468ffaa
build
public ModelSpec<T> build()
{    return new ModelSpecImpl<>(path, serializer, createMode, aclList, createOptions, deleteOptions, ttl);}
17330c6d6f94be443ed92a337b5bed5329f70cf44fb7e7d941666183ff3cafb4
withCreateMode
public ModelSpecBuilder<T> withCreateMode(CreateMode createMode)
{    this.createMode = createMode;    return this;}
c2952bb2ee0e4e83a645323ec805e0ee1e738eff39b9a82dafa4d22b7ca88455
withTtl
public ModelSpecBuilder<T> withTtl(long ttl)
{    this.ttl = ttl;    return this;}
8cbc588762e2ee829451045793da6abd60f25b71ec52992c23806bbb6a48d540
withAclList
public ModelSpecBuilder<T> withAclList(List<ACL> aclList)
{    this.aclList = aclList;    return this;}
0f717976101c96a6b8486a7b163661046d3465e3d335c5efc055eb57742a40dc
withCreateOptions
public ModelSpecBuilder<T> withCreateOptions(Set<CreateOption> createOptions)
{    this.createOptions = (createOptions != null) ? ImmutableSet.copyOf(createOptions) : null;    return this;}
09c520bd128b48f07f2281f16d20829f12db33c69f56293893e572d24b7af272
withDeleteOptions
public ModelSpecBuilder<T> withDeleteOptions(Set<DeleteOption> deleteOptions)
{    this.deleteOptions = (deleteOptions != null) ? ImmutableSet.copyOf(deleteOptions) : null;    return this;}
1be85c6a6e1ae73b8811c5b6bffc26c379bf5cc577cd9fc9bedb6a90f39df37e
withPath
public ModelSpecBuilder<T> withPath(ZPath path)
{    this.path = Objects.requireNonNull(path, "path cannot be null");    return this;}
6b7c1e93440a7738676a7b14f5df7b8d5b19b8cda7b1f7ee2d768bb1daf48430
nameFrom
 static String nameFrom(Object obj)
{    if (obj instanceof NodeName) {        return ((NodeName) obj).nodeName();    }    return String.valueOf(obj);}
ab80d9fa3dc5683c92d56465c9bc9c4350d9e4bb5af8f74ebd1770f1912cf462
resolved
 Object resolved(Object... parameters)
{    return resolved(Arrays.asList(parameters));}
4a61179b80e2e5f697ef0c6f0a5d23f652a0ce5541d24a63ef8fe16189f931c6
from
 static TypedModeledFramework<M, P1> from(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec<M, P1> modelSpec)
{    return (client, p1) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1)).build();}
8881a8b549d3654f2772556e170e2a1c38dd15756db41355c94c2292275aadfc
from
 static TypedModeledFramework<M, P1> from(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec<M, P1> typedModelSpec = TypedModelSpec.from(modelSpecBuilder, pathWithIds);    return (client, p1) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1)).build();}
6ee3976ac208687a6802c543b5d5345ded45c3eb67cb558ef89977474fbc7a97
from
 static TypedModeledFramework0<M> from(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec0<M> modelSpec)
{    return (client) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved()).build();}
5cb9d4ecdeefb9fe63e6fddbb3757f906a1e7485a5a25c057d181dd383ca5397
from
 static TypedModeledFramework0<M> from(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec0<M> typedModelSpec = TypedModelSpec0.from(modelSpecBuilder, pathWithIds);    return (client) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved()).build();}
8d32d5e61d5923f348db2dc6228c82bf5671cd95c19144b6fd40dfe6881c7dee
from
 static TypedModeledFramework10<M, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> from(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec10<M, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> modelSpec)
{    return (client, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)).build();}
c3502c5131cfb47c85ec0e2cffcb650cdc53fde35590b513adebb6f64cb67ca2
from
 static TypedModeledFramework10<M, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> from(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec10<M, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> typedModelSpec = TypedModelSpec10.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)).build();}
9f55a3f9dca9f0edf7cdadea854b426f0cd44cc57e26744309b37449458c2aab
from
 static TypedModeledFramework2<M, P1, P2> from(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec2<M, P1, P2> modelSpec)
{    return (client, p1, p2) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2)).build();}
b9a24987cff8e79b5159cbdb62ff792db552e08d355e72edf3aeb45ece237860
from
 static TypedModeledFramework2<M, P1, P2> from(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec2<M, P1, P2> typedModelSpec = TypedModelSpec2.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2)).build();}
13ec6685ecdbcb167dbe8c9724a8b3cf48cd6a66ada8e2ee976b9c971bcb8503
from
 static TypedModeledFramework3<M, P1, P2, P3> from(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec3<M, P1, P2, P3> modelSpec)
{    return (client, p1, p2, p3) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2, p3)).build();}
81839b05c5f49c6bf712e4ab87d3177d7e4049004126dac3e2cb0f963ac6dbf9
from
 static TypedModeledFramework3<M, P1, P2, P3> from(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec3<M, P1, P2, P3> typedModelSpec = TypedModelSpec3.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2, p3) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2, p3)).build();}
e9ed6f43cd25bc5712681bf6a1b39cfb78f235a470878b2e77c182d2ced6a88e
from
 static TypedModeledFramework4<M, P1, P2, P3, P4> from(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec4<M, P1, P2, P3, P4> modelSpec)
{    return (client, p1, p2, p3, p4) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2, p3, p4)).build();}
8f92552ac6a18077a9b5eaac45cf380896664ecaed85fd15c6915198daf0e5b7
from
 static TypedModeledFramework4<M, P1, P2, P3, P4> from(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec4<M, P1, P2, P3, P4> typedModelSpec = TypedModelSpec4.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2, p3, p4) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2, p3, p4)).build();}
c1c11367f8de53d85de9d9f795786d71d80976765919d645c687eaa49b1b4136
from
 static TypedModeledFramework5<M, P1, P2, P3, P4, P5> from(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec5<M, P1, P2, P3, P4, P5> modelSpec)
{    return (client, p1, p2, p3, p4, p5) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2, p3, p4, p5)).build();}
ea28220e14440a240f10833ef2d1529840fd7304dd4cff7fbc586e07bc5e74dd
from
 static TypedModeledFramework5<M, P1, P2, P3, P4, P5> from(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec5<M, P1, P2, P3, P4, P5> typedModelSpec = TypedModelSpec5.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2, p3, p4, p5) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2, p3, p4, p5)).build();}
3d23aae7e010a0124da213dcd73da04b24ab5e545ac21106e0b2a37f92dbb412
from
 static TypedModeledFramework6<M, P1, P2, P3, P4, P5, P6> from(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec6<M, P1, P2, P3, P4, P5, P6> modelSpec)
{    return (client, p1, p2, p3, p4, p5, p6) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2, p3, p4, p5, p6)).build();}
297ab3ef21ce6b25078841292267d6538128a3952c94b1a7ab45559681cd2bc3
from
 static TypedModeledFramework6<M, P1, P2, P3, P4, P5, P6> from(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec6<M, P1, P2, P3, P4, P5, P6> typedModelSpec = TypedModelSpec6.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2, p3, p4, p5, p6) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2, p3, p4, p5, p6)).build();}
26c3400a914843b611476b8f6a4b36a243bfe849bb5c353fc07c89fdd6a399a9
from
 static TypedModeledFramework7<M, P1, P2, P3, P4, P5, P6, P7> from(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec7<M, P1, P2, P3, P4, P5, P6, P7> modelSpec)
{    return (client, p1, p2, p3, p4, p5, p6, p7) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2, p3, p4, p5, p6, p7)).build();}
4c992a27c1f7e202e16b3b585e970807ca870ef42e35cb2df59a24755f931b58
from
 static TypedModeledFramework7<M, P1, P2, P3, P4, P5, P6, P7> from(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec7<M, P1, P2, P3, P4, P5, P6, P7> typedModelSpec = TypedModelSpec7.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2, p3, p4, p5, p6, p7) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2, p3, p4, p5, p6, p7)).build();}
7f3532c9167c0e73470581bef432eb348d7adaeeda9918c85f0b5192c715f0c1
from
 static TypedModeledFramework8<M, P1, P2, P3, P4, P5, P6, P7, P8> from(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec8<M, P1, P2, P3, P4, P5, P6, P7, P8> modelSpec)
{    return (client, p1, p2, p3, p4, p5, p6, p7, p8) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2, p3, p4, p5, p6, p7, p8)).build();}
824af47cb1b6aba607c8dad31a3063b34fd7fde0f6d1fdc2359b3d7cfb9e96af
from
 static TypedModeledFramework8<M, P1, P2, P3, P4, P5, P6, P7, P8> from(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec8<M, P1, P2, P3, P4, P5, P6, P7, P8> typedModelSpec = TypedModelSpec8.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2, p3, p4, p5, p6, p7, p8) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2, p3, p4, p5, p6, p7, p8)).build();}
6c83b60dff3202fdaf40596201d87d9e734711b8aa24d07f4d8e24a6fa56e708
from
 static TypedModeledFramework9<M, P1, P2, P3, P4, P5, P6, P7, P8, P9> from(ModeledFrameworkBuilder<M> frameworkBuilder, TypedModelSpec9<M, P1, P2, P3, P4, P5, P6, P7, P8, P9> modelSpec)
{    return (client, p1, p2, p3, p4, p5, p6, p7, p8, p9) -> frameworkBuilder.withClient(client).withModelSpec(modelSpec.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9)).build();}
71f5e7e5fda26fb87addc52bf1e62b5724b30e4947db98ced528f23a35c06cf3
from
 static TypedModeledFramework9<M, P1, P2, P3, P4, P5, P6, P7, P8, P9> from(ModeledFrameworkBuilder<M> frameworkBuilder, ModelSpecBuilder<M> modelSpecBuilder, String pathWithIds)
{    TypedModelSpec9<M, P1, P2, P3, P4, P5, P6, P7, P8, P9> typedModelSpec = TypedModelSpec9.from(modelSpecBuilder, pathWithIds);    return (client, p1, p2, p3, p4, p5, p6, p7, p8, p9) -> frameworkBuilder.withClient(client).withModelSpec(typedModelSpec.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9)).build();}
3c48ae64283d2f14bfb76a7c23ff0a61cd4f05086309464c8b42cf6d76cae237
from
 static TypedModelSpec<M, P1> from(ModelSpecBuilder<M> builder, TypedZPath<P1> path)
{    return p1 -> builder.withPath(path.resolved(p1)).build();}
67c93732301faa1f9f72d4e7a2fdf61b1b4840983ed7a0f11bc2fd289d2e6d2b
from
 static TypedModelSpec<M, P1> from(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath<P1> zPath = TypedZPath.from(pathWithIds);    return p1 -> builder.withPath(zPath.resolved(p1)).build();}
8e83f81e7e4acc554b5604ea5fefd547ca24808722c1dbe0ab61e2faa4aeb358
from
 static TypedModelSpec0<M> from(ModelSpecBuilder<M> builder, TypedZPath0 path)
{    return () -> builder.withPath(path.resolved()).build();}
5df4a9cea77e76c76e880b69aab04f1e87b0457eff89389a99b589f04093256b
from
 static TypedModelSpec0<M> from(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath0 zPath = TypedZPath0.from(pathWithIds);    return () -> builder.withPath(zPath.resolved()).build();}
1d5fe7a4af1265301f704777a38bfb66aeaf573c51303ed414cfcd0c36bd51b7
from
 static TypedModelSpec10<M, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> from(ModelSpecBuilder<M> builder, TypedZPath10<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> path)
{    return (p1, p2, p3, p4, p5, p6, p7, p8, p9, p10) -> builder.withPath(path.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)).build();}
362bff1b8b9209989e0e7a732847b97a2b0c104bf780e3eeb15059ece6fef6cd
from
 static TypedModelSpec10<M, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> from(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath10<P1, P2, P3, P4, P5, P6, P7, P8, P9, P10> zPath = TypedZPath10.from(pathWithIds);    return (p1, p2, p3, p4, p5, p6, p7, p8, p9, p10) -> builder.withPath(zPath.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)).build();}
42a3dac1047c71a3e2b29d332d897dd2d12853c107431a60a581a175cf8d097a
from
 static TypedModelSpec2<M, P1, P2> from(ModelSpecBuilder<M> builder, TypedZPath2<P1, P2> path)
{    return (p1, p2) -> builder.withPath(path.resolved(p1, p2)).build();}
db1eb92869a55909fdf112d65fcb7e76a81f9ccec6643ef9b8061072f6a51f53
from
 static TypedModelSpec2<M, P1, P2> from(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath2<P1, P2> zPath = TypedZPath2.from(pathWithIds);    return (p1, p2) -> builder.withPath(zPath.resolved(p1, p2)).build();}
3bedcc65f95050d04f03efa640ef8b29daca2acc46f948fe274cff1bc933f2e0
from
 static TypedModelSpec3<M, P1, P2, P3> from(ModelSpecBuilder<M> builder, TypedZPath3<P1, P2, P3> path)
{    return (p1, p2, p3) -> builder.withPath(path.resolved(p1, p2, p3)).build();}
5c3e13d5c74e84d08b08774c389f074a64752d166b4408e7d398c9bc166a084f
from
 static TypedModelSpec3<M, P1, P2, P3> from(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath3<P1, P2, P3> zPath = TypedZPath3.from(pathWithIds);    return (p1, p2, p3) -> builder.withPath(zPath.resolved(p1, p2, p3)).build();}
13944e2a31a5844039247aa820d54fbac4ff3c94273b384ab3f3d1f7891ba6db
from
 static TypedModelSpec4<M, P1, P2, P3, P4> from(ModelSpecBuilder<M> builder, TypedZPath4<P1, P2, P3, P4> path)
{    return (p1, p2, p3, p4) -> builder.withPath(path.resolved(p1, p2, p3, p4)).build();}
1d657843738fc21c0ff5d6101e20d80740ea89d900ac78eaf4fba78b748a810c
from
 static TypedModelSpec4<M, P1, P2, P3, P4> from(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath4<P1, P2, P3, P4> zPath = TypedZPath4.from(pathWithIds);    return (p1, p2, p3, p4) -> builder.withPath(zPath.resolved(p1, p2, p3, p4)).build();}
c4036562a776208a74acf09646f6f8e43e826486c16c69c3eac99971e00b977e
from
 static TypedModelSpec5<M, P1, P2, P3, P4, P5> from(ModelSpecBuilder<M> builder, TypedZPath5<P1, P2, P3, P4, P5> path)
{    return (p1, p2, p3, p4, p5) -> builder.withPath(path.resolved(p1, p2, p3, p4, p5)).build();}
9fe6d93b140d6327b0393091bb24613f5e286c77d2f88b79f8ad76f85dfa1e06
from
 static TypedModelSpec5<M, P1, P2, P3, P4, P5> from(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath5<P1, P2, P3, P4, P5> zPath = TypedZPath5.from(pathWithIds);    return (p1, p2, p3, p4, p5) -> builder.withPath(zPath.resolved(p1, p2, p3, p4, p5)).build();}
99cd79982585cd0b9f47b486ac96a97c3594ba5c1031725741a10005cc6b55d4
from
 static TypedModelSpec6<M, P1, P2, P3, P4, P5, P6> from(ModelSpecBuilder<M> builder, TypedZPath6<P1, P2, P3, P4, P5, P6> path)
{    return (p1, p2, p3, p4, p5, p6) -> builder.withPath(path.resolved(p1, p2, p3, p4, p5, p6)).build();}
8ba829a2be33d4a0afcc51d4b9bf6e3b25f0c9ae86b394b2693c658229b7f7e7
from
 static TypedModelSpec6<M, P1, P2, P3, P4, P5, P6> from(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath6<P1, P2, P3, P4, P5, P6> zPath = TypedZPath6.from(pathWithIds);    return (p1, p2, p3, p4, p5, p6) -> builder.withPath(zPath.resolved(p1, p2, p3, p4, p5, p6)).build();}
625f566be6b63dc6548a032328adf3f96704835b8f9e4745429bdea5082057a8
from
 static TypedModelSpec7<M, P1, P2, P3, P4, P5, P6, P7> from(ModelSpecBuilder<M> builder, TypedZPath7<P1, P2, P3, P4, P5, P6, P7> path)
{    return (p1, p2, p3, p4, p5, p6, p7) -> builder.withPath(path.resolved(p1, p2, p3, p4, p5, p6, p7)).build();}
7fd475a94698b2d1e6731ad848b244f31b3b4b312b37208a6089008fa1576781
from
 static TypedModelSpec7<M, P1, P2, P3, P4, P5, P6, P7> from(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath7<P1, P2, P3, P4, P5, P6, P7> zPath = TypedZPath7.from(pathWithIds);    return (p1, p2, p3, p4, p5, p6, p7) -> builder.withPath(zPath.resolved(p1, p2, p3, p4, p5, p6, p7)).build();}
a4ea6879f457b886ec75bfaf435f9c11197d4170dbe140411f6ad1ea3ff33726
from
 static TypedModelSpec8<M, P1, P2, P3, P4, P5, P6, P7, P8> from(ModelSpecBuilder<M> builder, TypedZPath8<P1, P2, P3, P4, P5, P6, P7, P8> path)
{    return (p1, p2, p3, p4, p5, p6, p7, p8) -> builder.withPath(path.resolved(p1, p2, p3, p4, p5, p6, p7, p8)).build();}
d901f66214f4b0fe66b8485cfb23387fdcfbda2270cfc14c1210d6bfc22598b0
from
 static TypedModelSpec8<M, P1, P2, P3, P4, P5, P6, P7, P8> from(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath8<P1, P2, P3, P4, P5, P6, P7, P8> zPath = TypedZPath8.from(pathWithIds);    return (p1, p2, p3, p4, p5, p6, p7, p8) -> builder.withPath(zPath.resolved(p1, p2, p3, p4, p5, p6, p7, p8)).build();}
d0fb50775f90ce45d79f83c83f02d84bbbdeddfe5b1c8d00bf4481fee3a30da4
from
 static TypedModelSpec9<M, P1, P2, P3, P4, P5, P6, P7, P8, P9> from(ModelSpecBuilder<M> builder, TypedZPath9<P1, P2, P3, P4, P5, P6, P7, P8, P9> path)
{    return (p1, p2, p3, p4, p5, p6, p7, p8, p9) -> builder.withPath(path.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9)).build();}
3796581642683cf084cc3c736fc7802b93724971856af9fc72de16f1798098d6
from
 static TypedModelSpec9<M, P1, P2, P3, P4, P5, P6, P7, P8, P9> from(ModelSpecBuilder<M> builder, String pathWithIds)
{    TypedZPath9<P1, P2, P3, P4, P5, P6, P7, P8, P9> zPath = TypedZPath9.from(pathWithIds);    return (p1, p2, p3, p4, p5, p6, p7, p8, p9) -> builder.withPath(zPath.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9)).build();}
342363d6c632eb39fa2f5d300e18f647ae40a3a0c1aca62d3b6abfc86d98c6d0
from
 static TypedZPath<T> from(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
c26a7552fb2a78e6132e494f7cb9e87d9b4c570d5d57eebc4983010875a5bb1b
from
 static TypedZPath<T> from(ZPath path)
{    return path::resolved;}
2630ab32fee43d973194b682156aa5f8cca4e3dcfe9394c84360c4260bfa6c39
from
 static TypedZPath0 from(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
5220b55e07aa2b7b92ddad8aef63d25faef45fd6ccad8a0a54f348d25013fdd1
from
 static TypedZPath0 from(ZPath path)
{    return path::resolved;}
1a08cdbedbe398d4f4dd73cbea3d48bbc2f8b2c79c411853420b90227f694497
from
 static TypedZPath10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> from(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
588e27d2b896f191e63e18e583f1d2814d4e901408765986b07b28c79fbeefe9
from
 static TypedZPath10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> from(ZPath path)
{    return (p1, p2, p3, p4, p5, p6, p7, p8, p9, p10) -> path.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10);}
0794709cf9a30ee29d33b738493e4a5560c2157f794c40fff772e0965e26860c
from
 static TypedZPath2<T1, T2> from(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
7d12db92798d6b8205a4caeab62a6431dedcee4e6a5b9ead8b4c7afb4bcf17f0
from
 static TypedZPath2<T1, T2> from(ZPath path)
{    return (p1, p2) -> path.resolved(p1, p2);}
63c5730082e8f3a056fafdaf67d76e912ee959368f8bd5a65981d5c1746348d2
from
 static TypedZPath3<T1, T2, T3> from(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
887aea2fcef4ad55f3fb6788ae35451a8277d13f4412ac03e8f286f0deb87a1e
from
 static TypedZPath3<T1, T2, T3> from(ZPath path)
{    return (p1, p2, p3) -> path.resolved(p1, p2, p3);}
fde791052766126331b88912d33e48ceca01c79498c9ff4f0e00f32a71686cda
from
 static TypedZPath4<T1, T2, T3, T4> from(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
9ac9ab0c87717ee4c399a887a6ae4db246dcb8d4b162586d17169321d1830286
from
 static TypedZPath4<T1, T2, T3, T4> from(ZPath path)
{    return (p1, p2, p3, p4) -> path.resolved(p1, p2, p3, p4);}
9508056f0ceeb6f275dbc380efa2c697f93614f364273a99ac5af8dc1dd6f24c
from
 static TypedZPath5<T1, T2, T3, T4, T5> from(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
818cd722d85a28ea368fdc37bd52ecb0b526bde7fc6a721d6844f0214c42f308
from
 static TypedZPath5<T1, T2, T3, T4, T5> from(ZPath path)
{    return (p1, p2, p3, p4, p5) -> path.resolved(p1, p2, p3, p4, p5);}
362260d929126194f1dadf14e5849c2db632800ff078f9926430f3c68ef38ab5
from
 static TypedZPath6<T1, T2, T3, T4, T5, T6> from(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
a073f137ded94d7b4a3bab82a1fb9c77b2859a3eddacedf25c493621b4f5e790
from
 static TypedZPath6<T1, T2, T3, T4, T5, T6> from(ZPath path)
{    return (p1, p2, p3, p4, p5, p6) -> path.resolved(p1, p2, p3, p4, p5, p6);}
f599544d52fa7bbdb82c02f28adaa08af2401eb7b9ef35fc97697ad93a512df0
from
 static TypedZPath7<T1, T2, T3, T4, T5, T6, T7> from(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
f219157deac252066ffebe1b90e3bd5fc2d1fb85c94d1915e4c657cf246f4418
from
 static TypedZPath7<T1, T2, T3, T4, T5, T6, T7> from(ZPath path)
{    return (p1, p2, p3, p4, p5, p6, p7) -> path.resolved(p1, p2, p3, p4, p5, p6, p7);}
dc35ae31d8d60638c2d267e3a63f4a9382460653ef03b06d880c2b06d3db131b
from
 static TypedZPath8<T1, T2, T3, T4, T5, T6, T7, T8> from(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
9579d63007733b4254dfa736dcc6d121657c998dd60ecb0dc60b86bb6cc64264
from
 static TypedZPath8<T1, T2, T3, T4, T5, T6, T7, T8> from(ZPath path)
{    return (p1, p2, p3, p4, p5, p6, p7, p8) -> path.resolved(p1, p2, p3, p4, p5, p6, p7, p8);}
5d0bd12ab54ed4eda07ad029702bc2592a2ee2a3e17b1095ab736b52d208826f
from
 static TypedZPath9<T1, T2, T3, T4, T5, T6, T7, T8, T9> from(String pathWithIds)
{    return from(ZPath.parseWithIds(pathWithIds));}
57a38819da20cd2c632cbbedbb9564b6124a30835200d7a64108aaecb247922a
from
 static TypedZPath9<T1, T2, T3, T4, T5, T6, T7, T8, T9> from(ZPath path)
{    return (p1, p2, p3, p4, p5, p6, p7, p8, p9) -> path.resolved(p1, p2, p3, p4, p5, p6, p7, p8, p9);}
f29bff6d477b51b3ba6bd47e42b4fd6dc3c432a3ec0c00921cab66f797637c20
version
 int version()
{    return -1;}
e1f48a951aea123db179f5803cd74279e590f99c3570137da47f114844ad9a0e
from
 static Versioned<T> from(T model, int version)
{    return new Versioned<T>() {        @Override        public int version() {            return version;        }        @Override        public T model() {            return model;        }    };}
8a6d5113ce2e14ea0414147296e05906c372f49a99ac713e8ddbe22680e385b2
version
public int version()
{    return version;}
3a8a3e52167a8b671221410ff01a4be735c647be2331097ef783e651f9451c53
model
public T model()
{    return model;}
16dac8e513391e5de0a514b596d6afc683ebe34b9b022afb85f547725fdc247c
models
 static CompletionStage<List<T>> models(AsyncStage<List<ZNode<T>>> from)
{    return from.thenApply(nodes -> nodes.stream().map(ZNode::model).collect(Collectors.toList()));}
06bdf57a13d1e782de25605e4c8036fef8036f16cbc62b019065223aa9c399c2
model
 static CompletionStage<T> model(AsyncStage<ZNode<T>> from)
{    return from.thenApply(ZNode::model);}
8dd183ad83095be4ebe7cc0d8d0ddff80b568e3ca8347b3b98cb878a51df04a3
parameter
 static String parameter()
{    return parameter("id");}
83ee541d29ef9b8a8b9813be5688523cbc4e4c4dba83a4ab350e0dd9c470acf0
parameter
 static String parameter(String name)
{    return PATH_SEPARATOR + "{" + name + "}";}
a397ad2580ce7bfdef3ec5f01ffd3f2bc2c05629fe06c4a49d94c3b5d92def6e
parse
 static ZPath parse(String fullPath)
{    return ZPathImpl.parse(fullPath, s -> s);}
8a0288936b465cc17995f5e74af42f81c32b4fe27cc874d6c57248154cbb537c
parseWithIds
 static ZPath parseWithIds(String fullPath)
{        return ZPathImpl.parse(fullPath, s -> isId(s) ? (PATH_SEPARATOR + s) : s);}
56c907709c3f07baea538d9dd0dc127326502ecc2bbc20d521b2667c1bc01cf3
isId
 static boolean isId(String s)
{    return s.startsWith("{") && s.endsWith("}");}
8618207453bfb48bcb7906c8a7c5418f0d90ed7cf39eb1491f19f44138279393
parse
 static ZPath parse(String fullPath, UnaryOperator<String> nameFilter)
{    return ZPathImpl.parse(fullPath, nameFilter);}
e4c0b30772898edfbede1e1400f1c750b97a0423437619152875ea81787d8051
from
 static ZPath from(String... names)
{    return ZPathImpl.from(names);}
0e32a95fccaec55c18aec7ddfe728ba170653b43b2e3becca26470da51fdfa4e
from
 static ZPath from(List<String> names)
{    return ZPathImpl.from(names);}
115aa381b1911444a3bd66347cba0da12c4df144b46b7506dbd5fdaf4a69cfd9
from
 static ZPath from(ZPath base, String... names)
{    return ZPathImpl.from(base, names);}
3bcc5b37d3004dbef5f19b4b8f74ffd1e4d61463f34b20a90d012506d0869b66
from
 static ZPath from(ZPath base, List<String> names)
{    return ZPathImpl.from(base, names);}
59cd67fb93599b3c9095fcee55befffe78683e4d1bad65d461fa33dccbb774ff
resolved
 ZPath resolved(Object... parameters)
{    return resolved(Arrays.asList(parameters));}
27681e68ec2a1eb903f955680ebe003ceb3707295c8aad884b692d378c6e37cf
setup
public void setup() throws Exception
{    System.setProperty("znode.container.checkIntervalMs", "1000");    super.setup();}
7c529460b940c419ef707bd1846a5575ea1bfc48c129127836c31f0184c1d8fb
teardown
public void teardown() throws Exception
{    System.clearProperty("znode.container.checkIntervalMs");    super.teardown();}
3540d895af45dbd440c9ff37f642ddb1d8d5ec4856c98b18c3be6a49fce318c3
testQuietDelete
public void testQuietDelete() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.delete().withOptions(EnumSet.of(DeleteOption.quietly)).forPath("/foo/bar");        final BlockingQueue<Integer> rc = new LinkedBlockingQueue<>();        BackgroundCallback backgroundCallback = (client1, event) -> rc.add(event.getResultCode());        async.delete().withOptions(EnumSet.of(DeleteOption.quietly)).forPath("/foo/bar/hey").handle((v, e) -> {            if (e == null) {                rc.add(KeeperException.Code.OK.intValue());            } else {                rc.add(((KeeperException) e).code().intValue());            }            return null;        });        Integer code = rc.poll(new Timing().milliseconds(), TimeUnit.MILLISECONDS);        Assert.assertNotNull(code);        Assert.assertEquals(code.intValue(), KeeperException.Code.OK.intValue());    } finally {        CloseableUtils.closeQuietly(client);    }}
3dde1eb790d57617bc9a8a1cc93da9a7f217b15221b030f585c14a5bd07eec54
testNamespaceWithWatcher
public void testNamespaceWithWatcher() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).namespace("aisa").retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        BlockingQueue<String> queue = new LinkedBlockingQueue<String>();        async.create().forPath("/base").thenRun(() -> async.watched().getChildren().forPath("/base").event().handle((event, x) -> {            try {                queue.put(event.getPath());            } catch (InterruptedException e) {                throw new Error(e);            }            return null;        })).thenRun(() -> async.create().forPath("/base/child"));        String path = queue.take();        Assert.assertEquals(path, "/base");    } finally {        CloseableUtils.closeQuietly(client);    }}
f3c6aec4239e1ab5832a00263623aed6d78c356e92f6e518a9882eee6d01748d
testCreateACLSingleAuth
public void testCreateACLSingleAuth() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).authorization("digest", "me1:pass1".getBytes()).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        ACL acl = new ACL(ZooDefs.Perms.WRITE, ZooDefs.Ids.AUTH_IDS);        List<ACL> aclList = Lists.newArrayList(acl);        client.create().withACL(aclList).forPath("/test", "test".getBytes());        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "me1:pass1".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);            async.setData().forPath("/test", "test".getBytes()).toCompletableFuture().get();        } catch (ExecutionException e) {            Assert.fail("Auth failed");        }        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "something:else".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);            async.setData().forPath("/test", "test".getBytes()).toCompletableFuture().get();            Assert.fail("Should have failed with auth exception");        } catch (ExecutionException e) {                }    } finally {        CloseableUtils.closeQuietly(client);    }}
acf2b34ac3f45c02e841180a38327d25139350d5b14fd594bdf966d6e5015cf7
testCreateACLMultipleAuths
public void testCreateACLMultipleAuths() throws Exception
{        List<AuthInfo> authInfos = new ArrayList<AuthInfo>();    authInfos.add(new AuthInfo("digest", "me1:pass1".getBytes()));    authInfos.add(new AuthInfo("digest", "me2:pass2".getBytes()));    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).authorization(authInfos).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        ACL acl = new ACL(ZooDefs.Perms.WRITE, ZooDefs.Ids.AUTH_IDS);        List<ACL> aclList = Lists.newArrayList(acl);        client.create().withACL(aclList).forPath("/test", "test".getBytes());        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "me1:pass1".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);            async.setData().forPath("/test", "test".getBytes()).toCompletableFuture().get();        } catch (ExecutionException e) {            Assert.fail("Auth failed");        }        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "me2:pass2".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);            async.setData().forPath("/test", "test".getBytes()).toCompletableFuture().get();        } catch (ExecutionException e) {            Assert.fail("Auth failed");        }        client.close();                client = builder.connectString(server.getConnectString()).authorization("digest", "something:else".getBytes()).retryPolicy(new RetryOneTime(1)).build();        client.start();        try {            AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);            async.setData().forPath("/test", "test".getBytes()).toCompletableFuture().get();            Assert.fail("Should have failed with auth exception");        } catch (ExecutionException e) {                }    } finally {        CloseableUtils.closeQuietly(client);    }}
59e3713ee5f73d8681e44b532dc66e22c16f22aeef102a672e123793c79af6b9
testCreateACLWithReset
public void testCreateACLWithReset() throws Exception
{    Timing timing = new Timing();    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).authorization("digest", "me:pass".getBytes()).retryPolicy(new ExponentialBackoffRetry(100, 5)).build();    client.start();    try {        final CountDownLatch lostLatch = new CountDownLatch(1);        ConnectionStateListener listener = (client1, newState) -> {            if (newState == ConnectionState.LOST) {                lostLatch.countDown();            }        };        client.getConnectionStateListenable().addListener(listener);        ACL acl = new ACL(ZooDefs.Perms.WRITE, ZooDefs.Ids.AUTH_IDS);        List<ACL> aclList = Lists.newArrayList(acl);        client.create().withACL(aclList).forPath("/test", "test".getBytes());        server.stop();        Assert.assertTrue(timing.awaitLatch(lostLatch));        try {            AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);            async.checkExists().forPath("/").toCompletableFuture().get();            Assert.fail("Connection should be down");        } catch (ExecutionException e) {                }        server.restart();        try {            AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);            async.setData().forPath("/test", "test".getBytes()).toCompletableFuture().get();        } catch (ExecutionException e) {            Assert.fail("Auth failed", e);        }    } finally {        CloseableUtils.closeQuietly(client);    }}
caba90133d27da25374d789c0091f2f81c52e334063767c0b3b5f45f34124329
testCreateParents
public void testCreateParents() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.create().withOptions(EnumSet.of(CreateOption.createParentsIfNeeded)).forPath("/one/two/three", "foo".getBytes()).toCompletableFuture().get();        byte[] data = async.getData().forPath("/one/two/three").toCompletableFuture().get();        Assert.assertEquals(data, "foo".getBytes());        async.create().withOptions(EnumSet.of(CreateOption.createParentsIfNeeded)).forPath("/one/two/another", "bar".getBytes());        data = async.getData().forPath("/one/two/another").toCompletableFuture().get();        Assert.assertEquals(data, "bar".getBytes());    } finally {        CloseableUtils.closeQuietly(client);    }}
ab8dd35b09234632f16034d94cad1562cf6db4d875be8d3d96991e8185caaed1
testCreateParentContainers
public void testCreateParentContainers() throws Exception
{    if (!checkForContainers()) {        return;    }    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    try {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.create().withOptions(EnumSet.of(CreateOption.createParentsAsContainers)).forPath("/one/two/three", "foo".getBytes()).toCompletableFuture().get();        byte[] data = async.getData().forPath("/one/two/three").toCompletableFuture().get();        Assert.assertEquals(data, "foo".getBytes());        async.delete().forPath("/one/two/three").toCompletableFuture().get();        new Timing().sleepABit();        Assert.assertNull(async.checkExists().forPath("/one/two").toCompletableFuture().get());        new Timing().sleepABit();        Assert.assertNull(async.checkExists().forPath("/one").toCompletableFuture().get());    } finally {        CloseableUtils.closeQuietly(client);    }}
412797f974f007eaedc12dc7c05efe15869cea866a231aafcda8ea60172ac816
testCreateWithProtection
public void testCreateWithProtection() throws ExecutionException, InterruptedException
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        String path = async.create().withOptions(Collections.singleton(CreateOption.doProtected)).forPath("/yo").toCompletableFuture().get();        String node = ZKPaths.getNodeFromPath(path);        Assert.assertTrue(node.startsWith(CreateBuilderImpl.PROTECTED_PREFIX), node);                        int expectedProtectedIdLength = 36;                int delimeterLength = 1;        int expectedNodeLength = CreateBuilderImpl.PROTECTED_PREFIX.length() + expectedProtectedIdLength + delimeterLength + "yo".length();        Assert.assertEquals(node.length(), expectedNodeLength);        int uuidStart = CreateBuilderImpl.PROTECTED_PREFIX.length();        String protectedId = node.substring(uuidStart, uuidStart + expectedProtectedIdLength);                UUID.fromString(protectedId);    } finally {        CloseableUtils.closeQuietly(client);    }}
e1648d823b54cca25a9328f7b965961dc52080b8ca5472adeb50e9af61556638
checkForContainers
private boolean checkForContainers()
{    if (ZKPaths.getContainerCreateMode() == CreateMode.PERSISTENT) {        System.out.println("Not using CreateMode.CONTAINER enabled version of ZooKeeper");        return false;    }    return true;}
821e611866b72b1a13969b1951b3b21f7e7809e603389a986feb72d4f43d9564
testCreatingParentsTheSame
public void testCreatingParentsTheSame() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        Assert.assertNull(client.checkExists().forPath("/one/two"));        async.create().withOptions(EnumSet.of(CreateOption.createParentsAsContainers)).forPath("/one/two/three").toCompletableFuture().get();        Assert.assertNotNull(async.checkExists().forPath("/one/two").toCompletableFuture().get());        async.delete().withOptions(EnumSet.of(DeleteOption.deletingChildrenIfNeeded)).forPath("/one").toCompletableFuture().get();        Assert.assertNull(client.checkExists().forPath("/one"));        Assert.assertNull(async.checkExists().forPath("/one/two").toCompletableFuture().get());        async.checkExists().withOptions(EnumSet.of(ExistsOption.createParentsAsContainers)).forPath("/one/two/three").toCompletableFuture().get();        Assert.assertNotNull(async.checkExists().forPath("/one/two").toCompletableFuture().get());        Assert.assertNull(async.checkExists().forPath("/one/two/three").toCompletableFuture().get());    } finally {        CloseableUtils.closeQuietly(client);    }}
3d1d19624ef0a2aa0c3c6c8ac2e6dee35caa9eb96633f67e4763dc5c7b3f2f39
testExistsCreatingParents
public void testExistsCreatingParents() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    try {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        Assert.assertNull(async.checkExists().forPath("/one/two").toCompletableFuture().get());        async.checkExists().withOptions(EnumSet.of(ExistsOption.createParentsAsContainers)).forPath("/one/two/three").toCompletableFuture().get();        Assert.assertNotNull(async.checkExists().forPath("/one/two").toCompletableFuture().get());        Assert.assertNull(async.checkExists().forPath("/one/two/three").toCompletableFuture().get());        Assert.assertNull(async.checkExists().withOptions(EnumSet.of(ExistsOption.createParentsAsContainers)).forPath("/one/two/three").toCompletableFuture().get());    } finally {        CloseableUtils.closeQuietly(client);    }}
17ec4e6b2a36eab222d7f6d50783463968a82ae293f838aea6d5bc91f8ef14e8
testSyncNew
public void testSyncNew() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.create().forPath("/head");        Assert.assertNotNull(client.checkExists().forPath("/head"));        final CountDownLatch latch = new CountDownLatch(1);        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.sync().forPath("/head").handle((v, e) -> {            Assert.assertNull(v);            Assert.assertNull(e);            latch.countDown();            return null;        });        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));    } finally {        CloseableUtils.closeQuietly(client);    }}
a2b46b3e072d359e82c6539e8d67a2aca37366ce8863b8c80aa3231749c52bfd
testBackgroundDelete
public void testBackgroundDelete() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        CountDownLatch latch = new CountDownLatch(1);        async.create().forPath("/head").thenRun(() -> async.delete().forPath("/head").handle((v, e) -> {            Assert.assertNull(v);            Assert.assertNull(e);            latch.countDown();            return null;        }));        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        Assert.assertNull(client.checkExists().forPath("/head"));    } finally {        CloseableUtils.closeQuietly(client);    }}
f2bb01cbd8c1671805cd0bbbabe20d349fa5ca74a4db74e863fc3754e173b557
testBackgroundDeleteWithChildren
public void testBackgroundDeleteWithChildren() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        client.getCuratorListenable().addListener((client1, event) -> {            if (event.getType() == CuratorEventType.DELETE) {                Assert.assertEquals(event.getPath(), "/one/two");                ((CountDownLatch) event.getContext()).countDown();            }        });        CountDownLatch latch = new CountDownLatch(1);        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.create().withOptions(EnumSet.of(CreateOption.createParentsIfNeeded)).forPath("/one/two/three/four").thenRun(() -> async.delete().withOptions(EnumSet.of(DeleteOption.deletingChildrenIfNeeded)).forPath("/one/two").handle((v, e) -> {            Assert.assertNull(v);            Assert.assertNull(e);            latch.countDown();            return null;        }));        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        Assert.assertNull(client.checkExists().forPath("/one/two"));    } finally {        CloseableUtils.closeQuietly(client);    }}
ddfdd96807b66ba54111d400ce1027cc8ab772b8d6258bdfd6cf80d6eb0696d2
testDeleteGuaranteedWithChildren
public void testDeleteGuaranteedWithChildren() throws Exception
{    CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder();    CuratorFramework client = builder.connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).build();    client.start();    try {        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.create().withOptions(EnumSet.of(CreateOption.createParentsIfNeeded)).forPath("/one/two/three/four/five/six", "foo".getBytes()).toCompletableFuture().get();        async.delete().withOptions(EnumSet.of(DeleteOption.guaranteed, DeleteOption.deletingChildrenIfNeeded)).forPath("/one/two/three/four/five").toCompletableFuture().get();        Assert.assertNull(async.checkExists().forPath("/one/two/three/four/five").toCompletableFuture().get());        async.delete().withOptions(EnumSet.of(DeleteOption.guaranteed, DeleteOption.deletingChildrenIfNeeded)).forPath("/one/two").toCompletableFuture().get();        Assert.assertNull(async.checkExists().forPath("/one/two").toCompletableFuture().get());    } finally {        CloseableUtils.closeQuietly(client);    }}
7390795dc40492f531274662e1ef013c0a3d590187d9c70c36ab78f49a4638d0
testGetSequentialChildren
public void testGetSequentialChildren() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        Semaphore semaphore = new Semaphore(0);        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.create().forPath("/head").thenRun(() -> {            for (int i = 0; i < 10; ++i) {                async.create().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath("/head/child").thenRun(semaphore::release);            }        });        Assert.assertTrue(new Timing().acquireSemaphore(semaphore, 10));        List<String> children = async.getChildren().forPath("/head").toCompletableFuture().get();        Assert.assertEquals(children.size(), 10);    } finally {        CloseableUtils.closeQuietly(client);    }}
7cbfd46f72595c544cdd150b0300e9bc50d498c94adf816cdb5f8a12a97c4359
testBackgroundGetDataWithWatch
public void testBackgroundGetDataWithWatch() throws Exception
{    final byte[] data1 = { 1, 2, 3 };    final byte[] data2 = { 4, 5, 6, 7 };    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    client.start();    try {        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        async.create().forPath("/test", data1).toCompletableFuture().get();        CountDownLatch watchedLatch = new CountDownLatch(1);        CountDownLatch backgroundLatch = new CountDownLatch(1);        AsyncStage<byte[]> stage = async.watched().getData().forPath("/test");        stage.event().handle((event, x) -> {            Assert.assertEquals(event.getPath(), "/test");            watchedLatch.countDown();            return null;        });        stage.handle((d, x) -> {            Assert.assertEquals(d, data1);            backgroundLatch.countDown();            return null;        });        Assert.assertTrue(backgroundLatch.await(10, TimeUnit.SECONDS));        async.setData().forPath("/test", data2);        Assert.assertTrue(watchedLatch.await(10, TimeUnit.SECONDS));        byte[] checkData = async.getData().forPath("/test").toCompletableFuture().get();        Assert.assertEquals(checkData, data2);    } finally {        CloseableUtils.closeQuietly(client);    }}
7f1fb39687574648b87ecc430a2537fc33da81f945a21c037812ab07141c3466
testErrorListener
public void testErrorListener() throws Exception
{                final AtomicBoolean aclProviderCalled = new AtomicBoolean(false);    ACLProvider badAclProvider = new ACLProvider() {        @Override        public List<ACL> getDefaultAcl() {            if (aclProviderCalled.getAndSet(true)) {                throw new UnsupportedOperationException();            } else {                return new ArrayList<>();            }        }        @Override        public List<ACL> getAclForPath(String path) {            if (aclProviderCalled.getAndSet(true)) {                throw new UnsupportedOperationException();            } else {                return new ArrayList<>();            }        }    };    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).aclProvider(badAclProvider).build();    try {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        final CountDownLatch errorLatch = new CountDownLatch(1);        UnhandledErrorListener listener = (message, e) -> {            if (e instanceof UnsupportedOperationException) {                errorLatch.countDown();            }        };        async.with(listener).create().forPath("/foo");        Assert.assertTrue(new Timing().awaitLatch(errorLatch));    } finally {        CloseableUtils.closeQuietly(client);    }}
608c4250279b9160905e4962b77bc1d258c8a726d186d1875dd0e18be5e9bcbb
getDefaultAcl
public List<ACL> getDefaultAcl()
{    if (aclProviderCalled.getAndSet(true)) {        throw new UnsupportedOperationException();    } else {        return new ArrayList<>();    }}
948e924ac3cf12487fcf7f5ccc3b514ae7fc4b9d602a2962739b070d41126b34
getAclForPath
public List<ACL> getAclForPath(String path)
{    if (aclProviderCalled.getAndSet(true)) {        throw new UnsupportedOperationException();    } else {        return new ArrayList<>();    }}
a407e35b86348e1b9174727207e1463bf7e188c181a9c372860e16ffbf203656
testListenerConnectedAtStart
public void testListenerConnectedAtStart() throws Exception
{    server.stop();    Timing timing = new Timing(2);    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryNTimes(0, 0));    try {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        final CountDownLatch connectedLatch = new CountDownLatch(1);        final AtomicBoolean firstListenerAction = new AtomicBoolean(true);        final AtomicReference<ConnectionState> firstListenerState = new AtomicReference<>();        ConnectionStateListener listener = (client1, newState) -> {            if (firstListenerAction.compareAndSet(true, false)) {                firstListenerState.set(newState);                System.out.println("First listener state is " + newState);            }            if (newState == ConnectionState.CONNECTED) {                connectedLatch.countDown();            }        };        client.getConnectionStateListenable().addListener(listener);                async.create().forPath("/foo");        server.restart();        Assert.assertTrue(timing.awaitLatch(connectedLatch));        Assert.assertFalse(firstListenerAction.get());        ConnectionState firstconnectionState = firstListenerState.get();        Assert.assertEquals(firstconnectionState, ConnectionState.CONNECTED, "First listener state MUST BE CONNECTED but is " + firstconnectionState);    } finally {        CloseableUtils.closeQuietly(client);    }}
d3c96a008163c9ce24e62dede800abca66090c52ee686b6ae2f0e3a5f15b518b
testRetries
public void testRetries() throws Exception
{    final int SLEEP = 1000;    final int TIMES = 5;    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryNTimes(TIMES, SLEEP));    try {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        client.getZookeeperClient().blockUntilConnectedOrTimedOut();        final CountDownLatch latch = new CountDownLatch(TIMES);        final List<Long> times = Lists.newArrayList();        final AtomicLong start = new AtomicLong(System.currentTimeMillis());        ((CuratorFrameworkImpl) client).debugListener = data -> {            if (data.getOperation().getClass().getName().contains("CreateBuilderImpl")) {                long now = System.currentTimeMillis();                times.add(now - start.get());                start.set(now);                latch.countDown();            }        };        server.stop();        async.create().forPath("/one");        latch.await();        for (        long elapsed :         times.subList(1, times.size())) {            Assert.assertTrue(elapsed >= SLEEP, elapsed + ": " + times);        }    } finally {        CloseableUtils.closeQuietly(client);    }}
abf484428a0c119774a0c70ff237380e71c5914e3ebc6d7fcc083568ddc04d23
testCuratorCallbackOnError
public void testCuratorCallbackOnError() throws Exception
{    Timing timing = new Timing();    final CountDownLatch latch = new CountDownLatch(1);    try (CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new RetryOneTime(1000)).build()) {        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);                server.stop();                async.getChildren().forPath("/").handle((children, e) -> {            if (e instanceof KeeperException.ConnectionLossException) {                latch.countDown();            }            return null;        });                Assert.assertTrue(timing.awaitLatch(latch), "Callback has not been called by curator !");    }}
659b4ca410a3c5e577ee7b133a343a7ff41a06e4bca46289075d3f4c02f9e208
testShutdown
public void testShutdown() throws Exception
{    Timing timing = new Timing();    CuratorFramework client = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(timing.session()).connectionTimeoutMs(timing.connection()).retryPolicy(new RetryOneTime(1)).maxCloseWaitMs(timing.forWaiting().milliseconds()).build();    try {        final AtomicBoolean hadIllegalStateException = new AtomicBoolean(false);        ((CuratorFrameworkImpl) client).debugUnhandledErrorListener = (message, e) -> {            if (e instanceof IllegalStateException) {                hadIllegalStateException.set(true);            }        };        client.start();        AsyncCuratorFramework async = AsyncCuratorFramework.wrap(client);        final CountDownLatch operationReadyLatch = new CountDownLatch(1);        ((CuratorFrameworkImpl) client).debugListener = data -> {            try {                operationReadyLatch.await();            } catch (InterruptedException e) {                Thread.currentThread().interrupt();            }        };                async.create().forPath("/hey");        timing.sleepABit();                client.close();                operationReadyLatch.countDown();        timing.sleepABit();                Assert.assertFalse(hadIllegalStateException.get());    } finally {        CloseableUtils.closeQuietly(client);    }}
b92ef1e0a6e4338be45813dcecc5d9005ae5aefbc8dd96ec8cd0f3e68b144b4a
complete
protected void complete(CompletionStage<T> stage)
{    complete(stage, (v, e) -> {        if (e != null) {            Throwables.propagate(e);        }    });}
363dbef7ff9b1b6d0258d48ae13d9431eb5223ef8f2376f518d334b9ca3a80e2
complete
protected void complete(CompletionStage<T> stage, BiConsumer<? super T, Throwable> handler)
{    try {        stage.handle((v, e) -> {            handler.accept(v, e);            return null;        }).toCompletableFuture().get(timing.forWaiting().milliseconds(), TimeUnit.MILLISECONDS);    } catch (InterruptedException e) {        Thread.interrupted();    } catch (ExecutionException e) {        if (e.getCause() instanceof AssertionError) {            throw (AssertionError) e.getCause();        }        Assert.fail("get() failed", e);    } catch (TimeoutException e) {        Assert.fail("get() timed out");    }}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
91498b3411d692695c2e082303a572def4cc3c0654fd16134aa70866f88b4e0a
getAge
public int getAge()
{    return age;}
8223619f9a48a7734c9a4c93ce2235de22a170c3460a0f79334223e6044061d3
getFirstName
public String getFirstName()
{    return firstName;}
2af394af8443aef69d5e1f7c628a00b49a5fb1d708eab1dd2a3a28ed60033c8c
getLastName
public String getLastName()
{    return lastName;}
91498b3411d692695c2e082303a572def4cc3c0654fd16134aa70866f88b4e0a
getAge
public int getAge()
{    return age;}
27681e68ec2a1eb903f955680ebe003ceb3707295c8aad884b692d378c6e37cf
setup
public void setup() throws Exception
{    super.setup();    filterIsSetLatch = new CountDownLatch(1);    CuratorFramework rawClient = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(100));    rawClient.start();    this.client = AsyncCuratorFramework.wrap(rawClient);    ZPath modelPath = ZPath.parse("/test/it");    v1Spec = ModelSpec.builder(modelPath, JacksonModelSerializer.build(ModelV1.class)).build();    v2Spec = ModelSpec.builder(modelPath, JacksonModelSerializer.build(ModelV2.class)).build();    v3Spec = ModelSpec.builder(modelPath, JacksonModelSerializer.build(ModelV3.class)).build();    v1opA = client.unwrap().transactionOp().create().forPath(v1Spec.path().parent().fullPath());    v1opB = ModeledFramework.wrap(client, v1Spec).createOp(new ModelV1("Test"));    v2op = ModeledFramework.wrap(client, v2Spec).updateOp(new ModelV2("Test 2", 10));    v3op = ModeledFramework.wrap(client, v3Spec).updateOp(new ModelV3("One", "Two", 30));    executor = Executors.newCachedThreadPool();    manager = new MigrationManager(client, LOCK_PATH, META_DATA_PATH, executor, Duration.ofMinutes(10)) {        @Override        protected List<Migration> filter(MigrationSet set, List<byte[]> operationHashesInOrder) throws MigrationException {            CountDownLatch localLatch = filterLatch.getAndSet(null);            if (localLatch != null) {                filterIsSetLatch.countDown();                try {                    localLatch.await();                } catch (InterruptedException e) {                    Thread.currentThread().interrupt();                    Throwables.propagate(e);                }            }            return super.filter(set, operationHashesInOrder);        }    };    manager.debugCount = new AtomicInteger();}
3d4d00e4f306c62bb04a31949137c96138fcfcb7fd35e6f2e8a42854019b528b
filter
protected List<Migration> filter(MigrationSet set, List<byte[]> operationHashesInOrder) throws MigrationException
{    CountDownLatch localLatch = filterLatch.getAndSet(null);    if (localLatch != null) {        filterIsSetLatch.countDown();        try {            localLatch.await();        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            Throwables.propagate(e);        }    }    return super.filter(set, operationHashesInOrder);}
7c529460b940c419ef707bd1846a5575ea1bfc48c129127836c31f0184c1d8fb
teardown
public void teardown() throws Exception
{    CloseableUtils.closeQuietly(client.unwrap());    executor.shutdownNow();    super.teardown();}
0e0411efe5e7868378f7f03580d84579275f5762c392b06dea78c574fd2c1d57
testBasic
public void testBasic()
{    Migration m1 = () -> Arrays.asList(v1opA, v1opB);    Migration m2 = () -> Collections.singletonList(v2op);    Migration m3 = () -> Collections.singletonList(v3op);    MigrationSet migrationSet = MigrationSet.build("1", Arrays.asList(m1, m2, m3));    complete(manager.migrate(migrationSet));    ModeledFramework<ModelV3> v3Client = ModeledFramework.wrap(client, v3Spec);    complete(v3Client.read(), (m, e) -> {        Assert.assertEquals(m.getAge(), 30);        Assert.assertEquals(m.getFirstName(), "One");        Assert.assertEquals(m.getLastName(), "Two");    });    int count = manager.debugCount.get();    complete(manager.migrate(migrationSet));        Assert.assertEquals(manager.debugCount.get(), count);}
4ea9fe01b5a1b63e19381457caab27df04730a9fb19dec11cba667b41b13df04
testStaged
public void testStaged()
{    Migration m1 = () -> Arrays.asList(v1opA, v1opB);    MigrationSet migrationSet = MigrationSet.build("1", Collections.singletonList(m1));    complete(manager.migrate(migrationSet));    ModeledFramework<ModelV1> v1Client = ModeledFramework.wrap(client, v1Spec);    complete(v1Client.read(), (m, e) -> Assert.assertEquals(m.getName(), "Test"));    Migration m2 = () -> Collections.singletonList(v2op);    migrationSet = MigrationSet.build("1", Arrays.asList(m1, m2));    complete(manager.migrate(migrationSet));    ModeledFramework<ModelV2> v2Client = ModeledFramework.wrap(client, v2Spec);    complete(v2Client.read(), (m, e) -> {        Assert.assertEquals(m.getName(), "Test 2");        Assert.assertEquals(m.getAge(), 10);    });    Migration m3 = () -> Collections.singletonList(v3op);    migrationSet = MigrationSet.build("1", Arrays.asList(m1, m2, m3));    complete(manager.migrate(migrationSet));    ModeledFramework<ModelV3> v3Client = ModeledFramework.wrap(client, v3Spec);    complete(v3Client.read(), (m, e) -> {        Assert.assertEquals(m.getAge(), 30);        Assert.assertEquals(m.getFirstName(), "One");        Assert.assertEquals(m.getLastName(), "Two");    });}
b42beda4b0e895ee6beb1e9f5fd5c9bdc90c83156dacd9bb0d4d168a63a1e64b
testDocExample
public void testDocExample() throws Exception
{    CuratorOp op1 = client.transactionOp().create().forPath("/parent");    CuratorOp op2 = client.transactionOp().create().forPath("/parent/one");    CuratorOp op3 = client.transactionOp().create().forPath("/parent/two");    CuratorOp op4 = client.transactionOp().create().forPath("/parent/three");    CuratorOp op5 = client.transactionOp().create().forPath("/main", "hey".getBytes());    Migration initialMigration = () -> Arrays.asList(op1, op2, op3, op4, op5);    MigrationSet migrationSet = MigrationSet.build("main", Collections.singletonList(initialMigration));    complete(manager.migrate(migrationSet));    Assert.assertNotNull(client.unwrap().checkExists().forPath("/parent/three"));    Assert.assertEquals(client.unwrap().getData().forPath("/main"), "hey".getBytes());    CuratorOp newOp1 = client.transactionOp().create().forPath("/new");        CuratorOp newOp2 = client.transactionOp().delete().forPath("/main");    Migration newMigration = () -> Arrays.asList(newOp1, newOp2);    migrationSet = MigrationSet.build("main", Arrays.asList(initialMigration, newMigration));    complete(manager.migrate(migrationSet));    Assert.assertNull(client.unwrap().checkExists().forPath("/main"));}
c52061ea7b458f0580435e6e2c53329fd178cbddb053d2d650b5738fc149c45c
testChecksumDataError
public void testChecksumDataError()
{    CuratorOp op1 = client.transactionOp().create().forPath("/test");    CuratorOp op2 = client.transactionOp().create().forPath("/test/bar", "first".getBytes());    Migration migration = () -> Arrays.asList(op1, op2);    MigrationSet migrationSet = MigrationSet.build("1", Collections.singletonList(migration));    complete(manager.migrate(migrationSet));    CuratorOp op2Changed = client.transactionOp().create().forPath("/test/bar", "second".getBytes());    migration = () -> Arrays.asList(op1, op2Changed);    migrationSet = MigrationSet.build("1", Collections.singletonList(migration));    try {        complete(manager.migrate(migrationSet));        Assert.fail("Should throw");    } catch (Throwable e) {        Assert.assertTrue(Throwables.getRootCause(e) instanceof MigrationException);    }}
5fbc6f7cab9fc4a57fa6e4a5e776afdd5fdbb79b282a7a7ee7f5301e02b919cb
testChecksumPathError
public void testChecksumPathError()
{    CuratorOp op1 = client.transactionOp().create().forPath("/test2");    CuratorOp op2 = client.transactionOp().create().forPath("/test2/bar");    Migration migration = () -> Arrays.asList(op1, op2);    MigrationSet migrationSet = MigrationSet.build("1", Collections.singletonList(migration));    complete(manager.migrate(migrationSet));    CuratorOp op2Changed = client.transactionOp().create().forPath("/test/bar");    migration = () -> Arrays.asList(op1, op2Changed);    migrationSet = MigrationSet.build("1", Collections.singletonList(migration));    try {        complete(manager.migrate(migrationSet));        Assert.fail("Should throw");    } catch (Throwable e) {        Assert.assertTrue(Throwables.getRootCause(e) instanceof MigrationException);    }}
2b2106e310f5d0e1acfad6c2e41010451c720839e217875efb1b3ca323e15f50
testPartialApplyForBadOps
public void testPartialApplyForBadOps() throws Exception
{    CuratorOp op1 = client.transactionOp().create().forPath("/test", "something".getBytes());    CuratorOp op2 = client.transactionOp().create().forPath("/a/b/c");    Migration m1 = () -> Collections.singletonList(op1);    Migration m2 = () -> Collections.singletonList(op2);    MigrationSet migrationSet = MigrationSet.build("1", Arrays.asList(m1, m2));    try {        complete(manager.migrate(migrationSet));        Assert.fail("Should throw");    } catch (Throwable e) {        Assert.assertTrue(Throwables.getRootCause(e) instanceof KeeperException.NoNodeException);    }        Assert.assertNull(client.unwrap().checkExists().forPath("/test"));}
f3e0c44ae415f579e0e41198fe41580320fe2e3dcc4e07bb1f30a46515738b3e
testTransactionForBadOps
public void testTransactionForBadOps() throws Exception
{    CuratorOp op1 = client.transactionOp().create().forPath("/test2", "something".getBytes());    CuratorOp op2 = client.transactionOp().create().forPath("/a/b/c/d");    Migration migration = () -> Arrays.asList(op1, op2);    MigrationSet migrationSet = MigrationSet.build("1", Collections.singletonList(migration));    try {        complete(manager.migrate(migrationSet));        Assert.fail("Should throw");    } catch (Throwable e) {        Assert.assertTrue(Throwables.getRootCause(e) instanceof KeeperException.NoNodeException);    }    Assert.assertNull(client.unwrap().checkExists().forPath("/test"));}
f45bf4f1ec10814881c80924cf479f33feb1a9719e1bb65487019513f3ee66af
testConcurrency1
public void testConcurrency1() throws Exception
{    CuratorOp op1 = client.transactionOp().create().forPath("/test");    CuratorOp op2 = client.transactionOp().create().forPath("/test/bar", "first".getBytes());    Migration migration = () -> Arrays.asList(op1, op2);    MigrationSet migrationSet = MigrationSet.build("1", Collections.singletonList(migration));    CountDownLatch latch = new CountDownLatch(1);    filterLatch.set(latch);    CompletionStage<Void> first = manager.migrate(migrationSet);    Assert.assertTrue(timing.awaitLatch(filterIsSetLatch));    MigrationManager manager2 = new MigrationManager(client, LOCK_PATH, META_DATA_PATH, executor, Duration.ofMillis(timing.forSleepingABit().milliseconds()));    try {        complete(manager2.migrate(migrationSet));        Assert.fail("Should throw");    } catch (Throwable e) {        Assert.assertTrue(Throwables.getRootCause(e) instanceof AsyncWrappers.TimeoutException, "Should throw AsyncWrappers.TimeoutException, was: " + Throwables.getStackTraceAsString(Throwables.getRootCause(e)));    }    latch.countDown();    complete(first);    Assert.assertEquals(client.unwrap().getData().forPath("/test/bar"), "first".getBytes());}
62fe375d51eb184ce470474e3dff60b5f23f812246709c331b8173f775f988ed
testConcurrency2
public void testConcurrency2() throws Exception
{    CuratorOp op1 = client.transactionOp().create().forPath("/test");    CuratorOp op2 = client.transactionOp().create().forPath("/test/bar", "first".getBytes());    Migration migration = () -> Arrays.asList(op1, op2);    MigrationSet migrationSet = MigrationSet.build("1", Collections.singletonList(migration));    CountDownLatch latch = new CountDownLatch(1);    filterLatch.set(latch);    CompletionStage<Void> first = manager.migrate(migrationSet);    Assert.assertTrue(timing.awaitLatch(filterIsSetLatch));    CompletionStage<Void> second = manager.migrate(migrationSet);    try {        second.toCompletableFuture().get(timing.forSleepingABit().milliseconds(), TimeUnit.MILLISECONDS);        Assert.fail("Should throw");    } catch (Throwable e) {        Assert.assertTrue(Throwables.getRootCause(e) instanceof TimeoutException, "Should throw TimeoutException, was: " + Throwables.getStackTraceAsString(Throwables.getRootCause(e)));    }    latch.countDown();    complete(first);    Assert.assertEquals(client.unwrap().getData().forPath("/test/bar"), "first".getBytes());    complete(second);    Assert.assertEquals(manager.debugCount.get(), 1);}
8223619f9a48a7734c9a4c93ce2235de22a170c3460a0f79334223e6044061d3
getFirstName
public String getFirstName()
{    return firstName;}
2af394af8443aef69d5e1f7c628a00b49a5fb1d708eab1dd2a3a28ed60033c8c
getLastName
public String getLastName()
{    return lastName;}
08700efb8256487e686f7e38a61ccb0500f997abc6bd894e3acb149ec03d933b
getAddress
public String getAddress()
{    return address;}
91498b3411d692695c2e082303a572def4cc3c0654fd16134aa70866f88b4e0a
getAge
public int getAge()
{    return age;}
204c54c87aa017ee6749d98e32468ba2de18d136581cc53208dcac12961f29c9
getSalary
public BigInteger getSalary()
{    return salary;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    TestModel testModel = (TestModel) o;    if (age != testModel.age) {        return false;    }    if (!firstName.equals(testModel.firstName)) {        return false;    }    if (!lastName.equals(testModel.lastName)) {        return false;    }        if (!address.equals(testModel.address)) {        return false;    }    return salary.equals(testModel.salary);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = firstName.hashCode();    result = 31 * result + lastName.hashCode();    result = 31 * result + address.hashCode();    result = 31 * result + age;    result = 31 * result + salary.hashCode();    return result;}
8223619f9a48a7734c9a4c93ce2235de22a170c3460a0f79334223e6044061d3
getFirstName
public String getFirstName()
{    return firstName;}
2af394af8443aef69d5e1f7c628a00b49a5fb1d708eab1dd2a3a28ed60033c8c
getLastName
public String getLastName()
{    return lastName;}
08700efb8256487e686f7e38a61ccb0500f997abc6bd894e3acb149ec03d933b
getAddress
public String getAddress()
{    return address;}
91498b3411d692695c2e082303a572def4cc3c0654fd16134aa70866f88b4e0a
getAge
public int getAge()
{    return age;}
204c54c87aa017ee6749d98e32468ba2de18d136581cc53208dcac12961f29c9
getSalary
public BigInteger getSalary()
{    return salary;}
2808e6364f8462c863e4740f1cead59acc3e99d1f8b00318eaf9ed35ad68e48b
getNewField
public long getNewField()
{    return newField;}
38f865041c80af3333d0d6d3de6324b5e25c826d5da716b0e170786f2b2f9ca8
equalsOld
public boolean equalsOld(TestModel model)
{    return firstName.equals(model.getFirstName()) && lastName.equals(model.getLastName()) && address.equals(model.getAddress()) && salary.equals(model.getSalary()) && age == model.getAge();}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    TestNewerModel that = (TestNewerModel) o;    if (age != that.age) {        return false;    }    if (newField != that.newField) {        return false;    }    if (!firstName.equals(that.firstName)) {        return false;    }    if (!lastName.equals(that.lastName)) {        return false;    }        if (!address.equals(that.address)) {        return false;    }    return salary.equals(that.salary);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = firstName.hashCode();    result = 31 * result + lastName.hashCode();    result = 31 * result + address.hashCode();    result = 31 * result + age;    result = 31 * result + salary.hashCode();    result = 31 * result + (int) (newField ^ (newField >>> 32));    return result;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
91498b3411d692695c2e082303a572def4cc3c0654fd16134aa70866f88b4e0a
getAge
public int getAge()
{    return age;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    TestSimpleModel that = (TestSimpleModel) o;        if (age != that.age) {        return false;    }    return name.equals(that.name);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = name.hashCode();    result = 31 * result + age;    return result;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "TestSimpleModel{" + "name='" + name + '\'' + ", age=" + age + '}';}
16789cc37c4a1586a2ed554e7035063a30cd5232741cc71a0fde4cb7952a39d3
testDownServer
public void testDownServer() throws IOException
{    Timing timing = new Timing();    TestModel model = new TestModel("a", "b", "c", 1, BigInteger.ONE);    CachedModeledFramework<TestModel> client = ModeledFramework.wrap(async, modelSpec).cached();    Semaphore semaphore = new Semaphore(0);    client.listenable().addListener((t, p, s, m) -> semaphore.release());    client.start();    try {        client.child(model).set(model);        Assert.assertTrue(timing.acquireSemaphore(semaphore));        CountDownLatch latch = new CountDownLatch(1);        rawClient.getConnectionStateListenable().addListener((__, state) -> {            if (state == ConnectionState.LOST) {                latch.countDown();            }        });        server.stop();        Assert.assertTrue(timing.awaitLatch(latch));        complete(client.child(model).read().whenComplete((value, e) -> {            Assert.assertNotNull(value);            Assert.assertNull(e);        }));    } finally {        client.close();    }}
e594536416200faba4c97cef02a72610d9e84338085d516d721508e854a671f9
testPostInitializedFilter
public void testPostInitializedFilter()
{    TestModel model1 = new TestModel("a", "b", "c", 1, BigInteger.ONE);    TestModel model2 = new TestModel("d", "e", "f", 1, BigInteger.ONE);    CachedModeledFramework<TestModel> client = ModeledFramework.wrap(async, modelSpec).cached();    Semaphore semaphore = new Semaphore(0);    ModeledCacheListener<TestModel> listener = (t, p, s, m) -> semaphore.release();    client.listenable().addListener(listener.postInitializedOnly());        complete(client.child("1").set(model1));    client.start();    try {        Assert.assertFalse(timing.forSleepingABit().acquireSemaphore(semaphore));                client.child("2").set(model2);        Assert.assertTrue(timing.acquireSemaphore(semaphore));    } finally {        client.close();    }}
c9e618a3093bcbdaf93fb9355f8ddc563240d3e20f4dd456efcc0cbc7a481388
testChildren
public void testChildren()
{    TestModel parent = new TestModel("a", "b", "c", 20, BigInteger.ONE);    TestModel child1 = new TestModel("d", "e", "f", 1, BigInteger.ONE);    TestModel child2 = new TestModel("g", "h", "i", 1, BigInteger.ONE);    TestModel grandChild1 = new TestModel("j", "k", "l", 10, BigInteger.ONE);    TestModel grandChild2 = new TestModel("m", "n", "0", 5, BigInteger.ONE);    try (CachedModeledFramework<TestModel> client = ModeledFramework.wrap(async, modelSpec).cached()) {        CountDownLatch latch = new CountDownLatch(5);        client.listenable().addListener((t, p, s, m) -> latch.countDown());        client.start();        complete(client.child("p").set(parent));        complete(client.child("p").child("c1").set(child1));        complete(client.child("p").child("c2").set(child2));        complete(client.child("p").child("c1").child("g1").set(grandChild1));        complete(client.child("p").child("c2").child("g2").set(grandChild2));        Assert.assertTrue(timing.awaitLatch(latch));        complete(client.child("p").children(), (v, e) -> {            List<ZPath> paths = Arrays.asList(client.child("p").child("c1").modelSpec().path(), client.child("p").child("c2").modelSpec().path());            Assert.assertEquals(v, paths);        });        complete(client.child("p").childrenAsZNodes(), (v, e) -> {            Set<TestModel> cachedModels = toSet(v.stream(), ZNode::model);            Assert.assertEquals(cachedModels, Sets.newHashSet(child1, child2));                        complete(ModeledFramework.wrap(async, modelSpec).child("p").childrenAsZNodes(), (v2, e2) -> {                Set<TestModel> uncachedModels = toSet(v2.stream(), ZNode::model);                Assert.assertEquals(cachedModels, uncachedModels);            });        });        complete(client.child("p").child("c1").childrenAsZNodes(), (v, e) -> {            Assert.assertEquals(toSet(v.stream(), ZNode::model), Sets.newHashSet(grandChild1));        });        complete(client.child("p").child("c2").childrenAsZNodes(), (v, e) -> {            Assert.assertEquals(toSet(v.stream(), ZNode::model), Sets.newHashSet(grandChild2));        });    }}
ee71942d9234a66f0f71ac71670914560d4289cfbfc7dfd8a77bea197490550c
toSet
private Set<R> toSet(Stream<T> stream, Function<? super T, ? extends R> mapper)
{    return stream.map(mapper).collect(Collectors.toSet());}
f6e7de432fd6da1d1dcc17e93b56324a9cb5a2b616122c80cf1cc4ccba510f5a
testCrud
public void testCrud()
{    TestModel rawModel = new TestModel("John", "Galt", "1 Galt's Gulch", 42, BigInteger.valueOf(1));    TestModel rawModel2 = new TestModel("Wayne", "Rooney", "Old Trafford", 10, BigInteger.valueOf(1));    ModeledFramework<TestModel> client = ModeledFramework.wrap(async, modelSpec);    AsyncStage<String> stage = client.set(rawModel);    Assert.assertNull(stage.event());    complete(stage, (s, e) -> Assert.assertNotNull(s));    complete(client.read(), (model, e) -> Assert.assertEquals(model, rawModel));    complete(client.update(rawModel2));    complete(client.read(), (model, e) -> Assert.assertEquals(model, rawModel2));    complete(client.delete());    complete(client.checkExists(), (stat, e) -> Assert.assertNull(stat));}
b18daf987c9a2a4bb6128f5a5147f424ca2816c0f038e06b0e7681dd0a70ce23
testBackwardCompatibility
public void testBackwardCompatibility()
{    TestNewerModel rawNewModel = new TestNewerModel("John", "Galt", "1 Galt's Gulch", 42, BigInteger.valueOf(1), 100);    ModeledFramework<TestNewerModel> clientForNew = ModeledFramework.wrap(async, newModelSpec);    complete(clientForNew.set(rawNewModel), (s, e) -> Assert.assertNotNull(s));    ModeledFramework<TestModel> clientForOld = ModeledFramework.wrap(async, modelSpec);    complete(clientForOld.read(), (model, e) -> Assert.assertTrue(rawNewModel.equalsOld(model)));}
dcdf9babe14c227d5b8c4bcd81cd23531c3a55401e63f242792f03e99044cf07
testWatched
public void testWatched() throws InterruptedException
{    CountDownLatch latch = new CountDownLatch(1);    ModeledFramework<TestModel> client = ModeledFramework.builder(async, modelSpec).watched().build();    client.checkExists().event().whenComplete((event, ex) -> latch.countDown());    timing.sleepABit();    Assert.assertEquals(latch.getCount(), 1);    client.set(new TestModel());    Assert.assertTrue(timing.awaitLatch(latch));}
71ec98df8a9108edc087cee6cfc976da9d301594455dbc1d8a8dc8ef6bd649ff
testGetChildren
public void testGetChildren()
{    TestModel model = new TestModel("John", "Galt", "1 Galt's Gulch", 42, BigInteger.valueOf(1));    ModeledFramework<TestModel> client = ModeledFramework.builder(async, modelSpec).build();    complete(client.child("one").set(model));    complete(client.child("two").set(model));    complete(client.child("three").set(model));    Set<ZPath> expected = Sets.newHashSet(path.child("one"), path.child("two"), path.child("three"));    complete(client.children(), (children, e) -> Assert.assertEquals(Sets.newHashSet(children), expected));}
701d851515d9c777fb030480fa21dc9a4f545b849f719ef45369e7bc0a264558
testBadNode
public void testBadNode()
{    complete(async.create().forPath(modelSpec.path().fullPath(), "fubar".getBytes()), (v, e) -> {    });        ModeledFramework<TestModel> client = ModeledFramework.builder(async, modelSpec).watched().build();    complete(client.read(), (model, e) -> Assert.assertTrue(e instanceof KeeperException.NoNodeException));}
5120131afe63ee665544c15b0b36cdf6d81341b69c6516740426e0b1d157f762
testSchema
public void testSchema() throws Exception
{    Schema schema = modelSpec.schema();    try (CuratorFramework schemaClient = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).schemaSet(new SchemaSet(Collections.singletonList(schema), false)).build()) {        schemaClient.start();        try {            schemaClient.create().forPath(modelSpec.path().fullPath(), "asflasfas".getBytes());            Assert.fail("Should've thrown SchemaViolation");        } catch (SchemaViolation dummy) {                }        ModeledFramework<TestModel> modeledSchemaClient = ModeledFramework.wrap(AsyncCuratorFramework.wrap(schemaClient), modelSpec);        complete(modeledSchemaClient.set(new TestModel("one", "two", "three", 4, BigInteger.ONE)), (dummy, e) -> Assert.assertNull(e));    }}
1b124fbc77b1b9148db4c30dfc330b4897bfe622fcbfa1236e6c5642d02cf30e
testVersioned
public void testVersioned()
{    ModeledFramework<TestModel> client = ModeledFramework.wrap(async, modelSpec);    TestModel model = new TestModel("John", "Galt", "Galt's Gulch", 21, BigInteger.valueOf(1010101));    complete(client.set(model));        complete(client.set(model));    VersionedModeledFramework<TestModel> versioned = client.versioned();    complete(versioned.read().whenComplete((v, e) -> {        Assert.assertNull(e);        Assert.assertTrue(v.version() > 0);    }).thenCompose(versioned::set),     (s, e) -> Assert.assertNull(e));    Versioned<TestModel> badVersion = Versioned.from(model, 100000);    complete(versioned.set(badVersion), (v, e) -> Assert.assertTrue(e instanceof KeeperException.BadVersionException));    final Stat stat = new Stat();    complete(client.read(stat));        complete(client.delete(stat.getVersion() + 1), (v, e) -> Assert.assertTrue(e instanceof KeeperException.BadVersionException));        complete(client.delete(stat.getVersion()));}
b63a24d960c2fd4676a020e41a98e2474d797418d2c4fc3f0d3a5e2e1e93a568
testAcl
public void testAcl() throws NoSuchAlgorithmException
{    List<ACL> aclList = Collections.singletonList(new ACL(ZooDefs.Perms.WRITE, new Id("digest", DigestAuthenticationProvider.generateDigest("test:test"))));    ModelSpec<TestModel> aclModelSpec = ModelSpec.builder(modelSpec.path(), modelSpec.serializer()).withAclList(aclList).build();    ModeledFramework<TestModel> client = ModeledFramework.wrap(async, aclModelSpec);    complete(client.set(new TestModel("John", "Galt", "Galt's Gulch", 21, BigInteger.valueOf(1010101))));    complete(client.update(new TestModel("John", "Galt", "Galt's Gulch", 54, BigInteger.valueOf(88))), (__, e) -> Assert.assertNotNull(e, "Should've gotten an auth failure"));    try (CuratorFramework authCurator = CuratorFrameworkFactory.builder().connectString(server.getConnectString()).retryPolicy(new RetryOneTime(1)).authorization("digest", "test:test".getBytes()).build()) {        authCurator.start();        ModeledFramework<TestModel> authClient = ModeledFramework.wrap(AsyncCuratorFramework.wrap(authCurator), aclModelSpec);        complete(authClient.update(new TestModel("John", "Galt", "Galt's Gulch", 42, BigInteger.valueOf(66))), (__, e) -> Assert.assertNull(e, "Should've succeeded"));    }}
27681e68ec2a1eb903f955680ebe003ceb3707295c8aad884b692d378c6e37cf
setup
public void setup() throws Exception
{    super.setup();    rawClient = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));    rawClient.start();    async = AsyncCuratorFramework.wrap(rawClient);    JacksonModelSerializer<TestModel> serializer = JacksonModelSerializer.build(TestModel.class);    JacksonModelSerializer<TestNewerModel> newSerializer = JacksonModelSerializer.build(TestNewerModel.class);    modelSpec = ModelSpec.builder(path, serializer).build();    newModelSpec = ModelSpec.builder(path, newSerializer).build();}
7c529460b940c419ef707bd1846a5575ea1bfc48c129127836c31f0184c1d8fb
teardown
public void teardown() throws Exception
{    CloseableUtils.closeQuietly(rawClient);    super.teardown();}
1a98365eee71abd9e096af1503c418b900659cfc8143a3f0876f6870a1fbc683
testRoot
public void testRoot()
{    Assert.assertEquals(ZPath.root.nodeName(), ZKPaths.PATH_SEPARATOR);    Assert.assertEquals(ZPath.root, ZPathImpl.root);    Assert.assertTrue(ZPath.root.isRoot());    Assert.assertEquals(ZPath.root.child("foo").parent(), ZPath.root);    Assert.assertTrue(ZPath.root.child("foo").parent().isRoot());}
0e0411efe5e7868378f7f03580d84579275f5762c392b06dea78c574fd2c1d57
testBasic
public void testBasic()
{    ZPath path = ZPath.root.child("one").child("two");    Assert.assertFalse(path.isRoot());    Assert.assertEquals(path, ZPath.root.child("one").child("two"));    Assert.assertNotEquals(path, ZPath.root.child("onex").child("two"));    Assert.assertEquals(path.nodeName(), "two");    Assert.assertEquals(path.fullPath(), "/one/two");    Assert.assertEquals(path.parent().fullPath(), "/one");        Assert.assertEquals(path.fullPath(), "/one/two");        Assert.assertEquals(path.parent().fullPath(), "/one");    Assert.assertTrue(path.startsWith(ZPath.root.child("one")));    Assert.assertFalse(path.startsWith(ZPath.root.child("two")));    ZPath checkIdLike = ZPath.parse("/one/{two}/three");    Assert.assertTrue(checkIdLike.isResolved());    checkIdLike = ZPath.parse("/one/" + ZPath.parameter() + "/three");    Assert.assertTrue(checkIdLike.isResolved());    checkIdLike = ZPath.parse("/one/" + ZPath.parameter("others") + "/three");    Assert.assertTrue(checkIdLike.isResolved());}
2d88d573244567ac0a31d747fae28a6fb20fb760581f8602108e5aa02bacb887
testParsing
public void testParsing()
{    Assert.assertEquals(ZPath.parse("/"), ZPath.root);    Assert.assertEquals(ZPath.parse("/one/two/three"), ZPath.root.child("one").child("two").child("three"));    Assert.assertEquals(ZPath.parse("/one/two/three"), ZPath.from("one", "two", "three"));    Assert.assertEquals(ZPath.parseWithIds("/one/{id}/two/{id}"), ZPath.from("one", parameter(), "two", parameter()));}
12c0fea70182fa4d321818a64ab5cd17170d6a67f5d93bd1eade57ccd9876398
testUnresolvedPath
public void testUnresolvedPath()
{    ZPath path = ZPath.from("one", parameter(), "two");    path.fullPath();}
a8e34d51bbbde6b8b4f566729a40acdbb4f726d45e3ae63df53db673e65788ce
testResolvedPath
public void testResolvedPath()
{    ZPath path = ZPath.from("one", parameter(), "two", parameter());    Assert.assertEquals(path.resolved("a", "b"), ZPath.from("one", "a", "two", "b"));}
1aca96105510472967528a9c2eca094f717f052dd61eba38822e75be822619b9
testSchema
public void testSchema()
{    ZPath path = ZPath.from("one", parameter(), "two", parameter());    Assert.assertEquals(path.toSchemaPathPattern().toString(), "/one/.*/two/.*");    path = ZPath.parse("/one/two/three");    Assert.assertEquals(path.toSchemaPathPattern().toString(), "/one/two/three");    path = ZPath.parseWithIds("/one/{id}/three");    Assert.assertEquals(path.toSchemaPathPattern().toString(), "/one/.*/three");    path = ZPath.parseWithIds("/{id}/{id}/three");    Assert.assertEquals(path.toSchemaPathPattern().toString(), "/.*/.*/three");}
de3932c90de60fb7ef0812ed00974a1ee1863c5e07933eb4983e884eeab94534
testCustomIds
public void testCustomIds()
{    Assert.assertEquals(ZPath.parseWithIds("/a/{a}/bee/{bee}/c/{c}").toString(), "/a/{a}/bee/{bee}/c/{c}");    Assert.assertEquals(ZPath.from("a", parameter(), "b", parameter()).toString(), "/a/{id}/b/{id}");    Assert.assertEquals(ZPath.from("a", parameter("foo"), "b", parameter("bar")).toString(), "/a/{foo}/b/{bar}");}
0221e187be92aff34ac68489171b2d681c71941200f06eedc66e868fc88c9daf
testPartialResolution
public void testPartialResolution()
{    ZPath path = ZPath.parseWithIds("/one/{1}/two/{2}");    Assert.assertFalse(path.parent().isResolved());    Assert.assertFalse(path.parent().parent().isResolved());    Assert.assertTrue(path.parent().parent().parent().isResolved());    Assert.assertFalse(path.isResolved());    path = path.resolved("p1");    Assert.assertFalse(path.isResolved());    Assert.assertTrue(path.parent().isResolved());    Assert.assertEquals(path.toString(), "/one/p1/two/{2}");    path = path.resolved("p2");    Assert.assertTrue(path.isResolved());    Assert.assertEquals(path.toString(), "/one/p1/two/p2");}
0e0411efe5e7868378f7f03580d84579275f5762c392b06dea78c574fd2c1d57
testBasic
public void testBasic()
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        InterProcessMutex lock = new InterProcessMutex(client, "/one/two");        complete(AsyncWrappers.lockAsync(lock), (__, e) -> {            Assert.assertNull(e);            AsyncWrappers.release(lock);        });    }}
44cc5fbf6248b18155cd65a28b458ffe79eee342a3614ba55c6a910267bbb812
testContention
public void testContention() throws Exception
{    try (CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1))) {        client.start();        InterProcessMutex lock1 = new InterProcessMutex(client, "/one/two");        InterProcessMutex lock2 = new InterProcessMutex(client, "/one/two");        CountDownLatch latch = new CountDownLatch(1);        AsyncWrappers.lockAsync(lock1).thenAccept(__ -> {                        latch.countDown();        });        Assert.assertTrue(timing.awaitLatch(latch));        CountDownLatch latch2 = new CountDownLatch(1);        AsyncWrappers.lockAsync(lock2, timing.forSleepingABit().milliseconds(), TimeUnit.MILLISECONDS).exceptionally(e -> {            if (e instanceof AsyncWrappers.TimeoutException) {                                latch2.countDown();            }            return null;        });        Assert.assertTrue(timing.awaitLatch(latch2));    }}
27681e68ec2a1eb903f955680ebe003ceb3707295c8aad884b692d378c6e37cf
setup
public void setup() throws Exception
{    super.setup();    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(timing.forSleepingABit().milliseconds()));    client.start();    this.client = AsyncCuratorFramework.wrap(client);}
7c529460b940c419ef707bd1846a5575ea1bfc48c129127836c31f0184c1d8fb
teardown
public void teardown() throws Exception
{    CloseableUtils.closeQuietly(client.unwrap());    super.teardown();}
2ed5687ef2381e211630138ee5a0c912ead5c2f2d609353b2c1c43d1f1cfddba
testCreateTransactionWithMode
public void testCreateTransactionWithMode() throws Exception
{    complete(AsyncWrappers.asyncEnsureContainers(client, "/test"));    CuratorOp op1 = client.transactionOp().create().withMode(PERSISTENT_SEQUENTIAL).forPath("/test/node-");    CuratorOp op2 = client.transactionOp().create().withMode(PERSISTENT_SEQUENTIAL).forPath("/test/node-");    complete(client.transaction().forOperations(Arrays.asList(op1, op2)));    Assert.assertEquals(client.unwrap().getChildren().forPath("/test").size(), 2);}
f6e7de432fd6da1d1dcc17e93b56324a9cb5a2b616122c80cf1cc4ccba510f5a
testCrud
public void testCrud()
{    AsyncStage<String> createStage = client.create().forPath("/test", "one".getBytes());    complete(createStage, (path, e) -> Assert.assertEquals(path, "/test"));    AsyncStage<byte[]> getStage = client.getData().forPath("/test");    complete(getStage, (data, e) -> Assert.assertEquals(data, "one".getBytes()));    CompletionStage<byte[]> combinedStage = client.setData().forPath("/test", "new".getBytes()).thenCompose(__ -> client.getData().forPath("/test"));    complete(combinedStage, (data, e) -> Assert.assertEquals(data, "new".getBytes()));    CompletionStage<Void> combinedDelete = client.create().withMode(EPHEMERAL_SEQUENTIAL).forPath("/deleteme").thenCompose(path -> client.delete().forPath(path));    complete(combinedDelete, (v, e) -> Assert.assertNull(e));    CompletionStage<byte[]> setDataIfStage = client.create().withOptions(of(compress, setDataIfExists)).forPath("/test", "last".getBytes()).thenCompose(__ -> client.getData().decompressed().forPath("/test"));    complete(setDataIfStage, (data, e) -> Assert.assertEquals(data, "last".getBytes()));}
f6c1429a0ac4a2ae6b1df471786c4360b00800440955d5a2082fbb63f8f90f2e
testException
public void testException()
{    CountDownLatch latch = new CountDownLatch(1);    client.getData().forPath("/woop").exceptionally(e -> {        Assert.assertTrue(e instanceof KeeperException);        Assert.assertEquals(((KeeperException) e).code(), KeeperException.Code.NONODE);        latch.countDown();        return null;    });    Assert.assertTrue(timing.awaitLatch(latch));}
6f6838ee44ee252358ee8723a5b5abf475b35333035d57bd12ba9add3d92e64f
testWatching
public void testWatching()
{    CountDownLatch latch = new CountDownLatch(1);    client.watched().checkExists().forPath("/test").event().whenComplete((event, exception) -> {        Assert.assertNull(exception);        Assert.assertEquals(event.getType(), Watcher.Event.EventType.NodeCreated);        latch.countDown();    });    client.create().forPath("/test");    Assert.assertTrue(timing.awaitLatch(latch));}
b4b91e32b6958cfbd33221e3eb2320354ec54c7c6fd40059eb0d9807eedc68d1
testWatchingWithServerLoss
public void testWatchingWithServerLoss() throws Exception
{    AsyncStage<Stat> stage = client.watched().checkExists().forPath("/test");    stage.thenRun(() -> {        try {            server.stop();        } catch (IOException e) {                }    });    CountDownLatch latch = new CountDownLatch(1);    complete(stage.event(), (v, e) -> {        Assert.assertTrue(e instanceof AsyncEventException);        Assert.assertEquals(((AsyncEventException) e).getKeeperState(), Watcher.Event.KeeperState.Disconnected);        ((AsyncEventException) e).reset().thenRun(latch::countDown);    });    server.restart();    client.create().forPath("/test");    Assert.assertTrue(timing.awaitLatch(latch));}
0eaedac8587972d95942ab5d950957840888f3c2c3944ca2a53feb9cad482aa5
testResultWrapper
public void testResultWrapper() throws Exception
{    CompletionStage<AsyncResult<String>> resultStage = AsyncResult.of(client.create().forPath("/first"));    complete(resultStage, (v, e) -> {        Assert.assertNull(e);        Assert.assertEquals(v.getRawValue(), "/first");        Assert.assertNull(v.getRawException());        Assert.assertEquals(v.getCode(), KeeperException.Code.OK);    });    resultStage = AsyncResult.of(client.create().forPath("/foo/bar"));    complete(resultStage, (v, e) -> {        Assert.assertNull(e);        Assert.assertNull(v.getRawValue());        Assert.assertNull(v.getRawException());        Assert.assertEquals(v.getCode(), KeeperException.Code.NONODE);    });    resultStage = AsyncResult.of(client.create().forPath("illegal path"));    complete(resultStage, (v, e) -> {        Assert.assertNull(e);        Assert.assertNull(v.getRawValue());        Assert.assertNotNull(v.getRawException());        Assert.assertTrue(v.getRawException() instanceof IllegalArgumentException);        Assert.assertEquals(v.getCode(), KeeperException.Code.SYSTEMERROR);    });    server.stop();    resultStage = AsyncResult.of(client.create().forPath("/second"));    complete(resultStage, (v, e) -> {        Assert.assertNull(e);        Assert.assertNull(v.getRawValue());        Assert.assertNull(v.getRawException());        Assert.assertEquals(v.getCode(), KeeperException.Code.CONNECTIONLOSS);    });}
72a13db50bca277f51e584648dd66a56075f64e07368443e04c2447cee33f5cb
testGetDataWithStat
public void testGetDataWithStat()
{    complete(client.create().forPath("/test", "hey".getBytes()));    Stat stat = new Stat();    complete(client.getData().storingStatIn(stat).forPath("/test"));    Assert.assertEquals(stat.getDataLength(), "hey".length());}
affff1841c42cb931ace6fc9913e6082bed5d820bb75e5bbd8812284db0c365f
add
 void add(ServiceInstance<?> instance)
{    purge();    Status newStatus = new Status();    Status oldStatus = statuses.putIfAbsent(instance, newStatus);    Status useStatus = (oldStatus != null) ? oldStatus : newStatus;    useStatus.errorCount.incrementAndGet();}
91c500d11b107150555e4abc700f4540c64332087bb8937cd815a3595c198f70
apply
public boolean apply(ServiceInstance<T> instance)
{    purge();    Status status = statuses.get(instance);    return (status == null) || (status.errorCount.get() < downInstancePolicy.getErrorThreshold());}
776c44d2a48d4e649b2da185ca368dfaefb8c3a2f180de32f0e45aa9377c327f
purge
private void purge()
{    long localLastPurge = lastPurge.get();    long ticksSinceLastPurge = System.currentTimeMillis() - localLastPurge;    if (ticksSinceLastPurge < (downInstancePolicy.getTimeoutMs() / 2)) {        return;    }    if (!lastPurge.compareAndSet(localLastPurge, System.currentTimeMillis())) {        return;    }    Iterator<Entry<ServiceInstance<?>, Status>> it = statuses.entrySet().iterator();    while (it.hasNext()) {        Entry<ServiceInstance<?>, Status> entry = it.next();        long elapsedMs = System.currentTimeMillis() - entry.getValue().startMs;        if (elapsedMs >= downInstancePolicy.getTimeoutMs()) {            it.remove();        }    }}
d03b954d1a484c07551c598b65e9544d0a76ba99f03b8c1e54645e022c669257
getInstances
public List<ServiceInstance<T>> getInstances() throws Exception
{    Iterable<ServiceInstance<T>> filtered = Iterables.filter(instanceProvider.getInstances(), predicates);    return ImmutableList.copyOf(filtered);}
1050e91e9dfda02f7219b02762ae30fe7b27bca0e63ab7f9e1b8668c747b0863
deserialize
public ServiceInstance<T> deserialize(byte[] bytes) throws Exception
{    ServiceInstance rawServiceInstance = mapper.readValue(bytes, type);        payloadClass.cast(rawServiceInstance.getPayload());    return (ServiceInstance<T>) rawServiceInstance;}
11f136899b5ebaa6951041ac76931b603effb0bb867fef70f8f73b659c0f9658
serialize
public byte[] serialize(ServiceInstance<T> instance) throws Exception
{    if (compatibleSerializationMode) {        OldServiceInstance<T> compatible = new OldServiceInstance<T>(instance.getName(), instance.getId(), instance.getAddress(), instance.getPort(), instance.getSslPort(), instance.getPayload(), instance.getRegistrationTimeUTC(), instance.getServiceType(), instance.getUriSpec());        return mapper.writeValueAsBytes(compatible);    }    return mapper.writeValueAsBytes(instance);}
89f5239394db923549d33e0921f76bed02390bed235706ce5ed581da42df62c2
set
 synchronized void set()
{    laden = true;    notifyAll();}
4fd37dc94bf74a67614d85ff079dcd66338a4d23a5fe97bd9ddd2761020efe08
await
 synchronized void await() throws InterruptedException
{    while (!laden) {        wait();    }    laden = false;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
09e8f13a9a603d31d64bb498b77d15572483824d843d0e82a570643192f62186
getId
public String getId()
{    return id;}
08700efb8256487e686f7e38a61ccb0500f997abc6bd894e3acb149ec03d933b
getAddress
public String getAddress()
{    return address;}
286ac11a7c0c169929d6406e0293873a24296d28a94301df226e0d8700dcead6
getPort
public Integer getPort()
{    return port;}
7a28e92bfd350898412d279c1bd2c299670f0a1cfb66a864639d0f6d9f70a45f
getSslPort
public Integer getSslPort()
{    return sslPort;}
51556ec87a6e3a239ccb0b3de9d1dff54c284250b0c7fdd45d032a2b636c753e
getPayload
public T getPayload()
{    return payload;}
009350e825a7e30318ac5c626961698af44549d639846bb7e89fd3f4bf3d5d2e
getRegistrationTimeUTC
public long getRegistrationTimeUTC()
{    return registrationTimeUTC;}
8bfb90797c3b6ae0301e7316f0fb1c3a208afc08634daf6c2570412d86d86b08
getServiceType
public ServiceType getServiceType()
{    return serviceType;}
9144812940555009d09073e127645713262436d6231024301c0dd157e9cf79e4
getUriSpec
public UriSpec getUriSpec()
{    return uriSpec;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    OldServiceInstance that = (OldServiceInstance) o;    if (registrationTimeUTC != that.registrationTimeUTC) {        return false;    }    if (address != null ? !address.equals(that.address) : that.address != null) {        return false;    }    if (id != null ? !id.equals(that.id) : that.id != null) {        return false;    }    if (name != null ? !name.equals(that.name) : that.name != null) {        return false;    }    if (payload != null ? !payload.equals(that.payload) : that.payload != null) {        return false;    }    if (port != null ? !port.equals(that.port) : that.port != null) {        return false;    }    if (serviceType != that.serviceType) {        return false;    }    if (sslPort != null ? !sslPort.equals(that.sslPort) : that.sslPort != null) {        return false;    }    if (uriSpec != null ? !uriSpec.equals(that.uriSpec) : that.uriSpec != null) {        return false;    }    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = name != null ? name.hashCode() : 0;    result = 31 * result + (id != null ? id.hashCode() : 0);    result = 31 * result + (address != null ? address.hashCode() : 0);    result = 31 * result + (port != null ? port.hashCode() : 0);    result = 31 * result + (sslPort != null ? sslPort.hashCode() : 0);    result = 31 * result + (payload != null ? payload.hashCode() : 0);    result = 31 * result + (int) (registrationTimeUTC ^ (registrationTimeUTC >>> 32));    result = 31 * result + (serviceType != null ? serviceType.hashCode() : 0);    result = 31 * result + (uriSpec != null ? uriSpec.hashCode() : 0);    return result;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "ServiceInstance{" + "name='" + name + '\'' + ", id='" + id + '\'' + ", address='" + address + '\'' + ", port=" + port + ", sslPort=" + sslPort + ", payload=" + payload + ", registrationTimeUTC=" + registrationTimeUTC + ", serviceType=" + serviceType + ", uriSpec=" + uriSpec + '}';}
68ddd722647ee18d1bc0cabf5417eb28e3507e634e0ac4163ce2b888089936ae
build
public ServiceCache<T> build()
{    if (executorService != null) {        return new ServiceCacheImpl<T>(discovery, name, executorService);    } else {        return new ServiceCacheImpl<T>(discovery, name, threadFactory);    }}
d00f9aad463d1a83572a53a4e4f5fcc920fc534bf7dbfc948404a233689ed47b
name
public ServiceCacheBuilder<T> name(String name)
{    this.name = name;    return this;}
5e8339b44b2ef4d7d669792a678858eb702bc5daa028cf9588283cd31b90155e
threadFactory
public ServiceCacheBuilder<T> threadFactory(ThreadFactory threadFactory)
{    this.threadFactory = threadFactory;    this.executorService = null;    return this;}
9a398df02b0337c1d8c401f7dab13a6821134a17cc13e363a9f5acea4d85615a
executorService
public ServiceCacheBuilder<T> executorService(ExecutorService executorService)
{    this.executorService = new CloseableExecutorService(executorService);    this.threadFactory = null;    return this;}
7709c8296eaedc8dee54437cf15e0d8a004b3955e0d9d6ca2b24cd098b4721b6
executorService
public ServiceCacheBuilder<T> executorService(CloseableExecutorService executorService)
{    this.executorService = executorService;    this.threadFactory = null;    return this;}
65c91f2ece9a95b0feed15919eafa43566bc1e207573a95a84fc98950f892e63
convertThreadFactory
private static CloseableExecutorService convertThreadFactory(ThreadFactory threadFactory)
{    Preconditions.checkNotNull(threadFactory, "threadFactory cannot be null");    return new CloseableExecutorService(Executors.newSingleThreadExecutor(threadFactory));}
f48afa8b53b9b6f2d163e9d0f894c5175ce43693af043ceb3ae67c75d991e30c
getInstances
public List<ServiceInstance<T>> getInstances()
{    return Lists.newArrayList(instances.values());}
90ba0dddc593bd95e2a0c0c039c523b81bfb91f87814ebcb222c3914ca772ead
start
public void start() throws Exception
{    Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");    cache.start(true);    if (debugStartLatch != null) {        debugStartLatch.countDown();        debugStartLatch = null;    }    if (debugStartWaitLatch != null) {        debugStartWaitLatch.await();        debugStartWaitLatch = null;    }    for (ChildData childData : cache.getCurrentData()) {        if (        childData.getData() != null) {            addInstance(childData, true);        }    }    discovery.cacheOpened(this);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    Preconditions.checkState(state.compareAndSet(State.STARTED, State.STOPPED), "Already closed or has not been started");    listenerContainer.forEach(new Function<ServiceCacheListener, Void>() {        @Override        public Void apply(ServiceCacheListener listener) {            discovery.getClient().getConnectionStateListenable().removeListener(listener);            return null;        }    });    listenerContainer.clear();    CloseableUtils.closeQuietly(cache);    discovery.cacheClosed(this);}
e1a98b24e8ec7ba63c75b69b5d0a76444981d4543a99e7861348e5f024b17d1d
apply
public Void apply(ServiceCacheListener listener)
{    discovery.getClient().getConnectionStateListenable().removeListener(listener);    return null;}
b371ebf9a2a76429cd20585bd7dafbf4706941f7b17e194027e8853c911550de
addListener
public void addListener(ServiceCacheListener listener)
{    listenerContainer.addListener(listener);    discovery.getClient().getConnectionStateListenable().addListener(listener);}
ef0e23429f63de49ef8bca0c89a7d73f3c6e83a78cf7d1f4b511a1fcb785c292
addListener
public void addListener(ServiceCacheListener listener, Executor executor)
{    listenerContainer.addListener(listener, executor);    discovery.getClient().getConnectionStateListenable().addListener(listener, executor);}
da7f0a00ad64b3a59b266f17e5114c35f78c21a4ed5242c3a739068e98ccc578
removeListener
public void removeListener(ServiceCacheListener listener)
{    listenerContainer.removeListener(listener);    discovery.getClient().getConnectionStateListenable().removeListener(listener);}
d6477cd5e4da923bd9799bbf8d4db46d7d153fc78458c819b2b186c1ddff908e
childEvent
public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception
{    boolean notifyListeners = false;    switch(event.getType()) {        case CHILD_ADDED:        case CHILD_UPDATED:            {                addInstance(event.getData(), false);                notifyListeners = true;                break;            }        case CHILD_REMOVED:            {                instances.remove(instanceIdFromData(event.getData()));                notifyListeners = true;                break;            }    }    if (notifyListeners) {        listenerContainer.forEach(new Function<ServiceCacheListener, Void>() {            @Override            public Void apply(ServiceCacheListener listener) {                listener.cacheChanged();                return null;            }        });    }}
e1a98b24e8ec7ba63c75b69b5d0a76444981d4543a99e7861348e5f024b17d1d
apply
public Void apply(ServiceCacheListener listener)
{    listener.cacheChanged();    return null;}
2871cfb0975391463af8e482284d7e3dc73ddbf24bc2f15a779de08658ac1a50
instanceIdFromData
private String instanceIdFromData(ChildData childData)
{    return ZKPaths.getNodeFromPath(childData.getPath());}
3be1d16be0833749404be53354082536bdcb121cbf22660149f029f04b96350a
addInstance
private void addInstance(ChildData childData, boolean onlyIfAbsent) throws Exception
{    String instanceId = instanceIdFromData(childData);    ServiceInstance<T> serviceInstance = discovery.getSerializer().deserialize(childData.getData());    if (onlyIfAbsent) {        instances.putIfAbsent(instanceId, serviceInstance);    } else {        instances.put(instanceId, serviceInstance);    }    cache.clearDataBytes(childData.getPath(), childData.getStat().getVersion());}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{    if ((newState == ConnectionState.RECONNECTED) || (newState == ConnectionState.CONNECTED)) {        try {            log.debug("Re-registering due to reconnection");            reRegisterServices();        } catch (InterruptedException ex) {            Thread.currentThread().interrupt();        } catch (Exception e) {            log.error("Could not re-register instances after reconnection", e);        }    }}
90ba0dddc593bd95e2a0c0c039c523b81bfb91f87814ebcb222c3914ca772ead
start
public void start() throws Exception
{    try {        reRegisterServices();    } catch (KeeperException e) {        log.error("Could not register instances - will try again later", e);    }    client.getConnectionStateListenable().addListener(connectionStateListener);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    ExceptionAccumulator accumulator = new ExceptionAccumulator();    for (ServiceProvider<T> provider : Lists.newArrayList(providers)) {        CloseableUtils.closeQuietly(provider);    }    for (Entry<T> entry : services.values()) {        try {            internalUnregisterService(entry);        } catch (KeeperException.NoNodeException ignore) {                } catch (Exception e) {            accumulator.add(e);            log.error("Could not unregister instance: " + entry.service.getName(), e);        }    }    client.getConnectionStateListenable().removeListener(connectionStateListener);    accumulator.propagate();}
66942a8e3fd15aad2a715cd2a7a8c5b635a65acacf3fdfecd49116102ce5ee93
registerService
public void registerService(ServiceInstance<T> service) throws Exception
{    Entry<T> newEntry = new Entry<T>(service);    Entry<T> oldEntry = services.putIfAbsent(service.getId(), newEntry);    Entry<T> useEntry = (oldEntry != null) ? oldEntry : newEntry;    synchronized (useEntry) {        if (        useEntry == newEntry) {            useEntry.cache = makeNodeCache(service);        }        internalRegisterService(service);    }}
a773babaa1776fe52f0c8b7cb5b32391b74c666d4fbc7f7819446308051eb442
updateService
public void updateService(final ServiceInstance<T> service) throws Exception
{    Entry<T> entry = services.get(service.getId());    if (entry == null) {        throw new Exception("Service not registered: " + service);    }    synchronized (entry) {        entry.service = service;        byte[] bytes = serializer.serialize(service);        String path = pathForInstance(service.getName(), service.getId());        client.setData().forPath(path, bytes);    }}
9fb5bc42fa810cdca54f12bad8d3ed72180b49211abf827421a182c4a2cd4d24
internalRegisterService
protected void internalRegisterService(ServiceInstance<T> service) throws Exception
{    byte[] bytes = serializer.serialize(service);    String path = pathForInstance(service.getName(), service.getId());    final int MAX_TRIES = 2;    boolean isDone = false;    for (int i = 0; !isDone && (i < MAX_TRIES); ++i) {        try {            CreateMode mode;            switch(service.getServiceType()) {                case DYNAMIC:                    mode = CreateMode.EPHEMERAL;                    break;                case DYNAMIC_SEQUENTIAL:                    mode = CreateMode.EPHEMERAL_SEQUENTIAL;                    break;                default:                    mode = CreateMode.PERSISTENT;                    break;            }            client.create().creatingParentContainersIfNeeded().withMode(mode).forPath(path, bytes);            isDone = true;        } catch (KeeperException.NodeExistsException e) {                        client.delete().forPath(path);        }    }}
cadc4a9593f13a46b5adb06c7609bd86855337568741f9d3bd8170829b81ebae
unregisterService
public void unregisterService(ServiceInstance<T> service) throws Exception
{    Entry<T> entry = services.remove(service.getId());    internalUnregisterService(entry);}
1bece2951f9e1317b9eb58d06f588c94616d2b54d84dcbc08a56a2e17d208ba4
serviceProviderBuilder
public ServiceProviderBuilder<T> serviceProviderBuilder()
{    return new ServiceProviderBuilderImpl<T>(this).providerStrategy(new RoundRobinStrategy<T>()).threadFactory(ThreadUtils.newThreadFactory("ServiceProvider"));}
0caba5dd24a8035d87c37c9a501bfa57f2b0e5c74a956a9a5d831c8d7183b239
serviceCacheBuilder
public ServiceCacheBuilder<T> serviceCacheBuilder()
{    return new ServiceCacheBuilderImpl<T>(this).threadFactory(ThreadUtils.newThreadFactory("ServiceCache"));}
65ee31b653af58958daf3b3cfe65f0047395aec73b443190873e73fa8c71fc48
queryForNames
public Collection<String> queryForNames() throws Exception
{    List<String> names = client.getChildren().forPath(basePath);    return ImmutableList.copyOf(names);}
578666e0ec617b379b224635648909a60ed851fa3b405631adebd8924a6473f5
queryForInstances
public Collection<ServiceInstance<T>> queryForInstances(String name) throws Exception
{    return queryForInstances(name, null);}
e276d0f482bb370c4de8117a7df1d69dd7ae011faab6400e468199fd3d17355f
queryForInstance
public ServiceInstance<T> queryForInstance(String name, String id) throws Exception
{    String path = pathForInstance(name, id);    try {        byte[] bytes = client.getData().forPath(path);        return serializer.deserialize(bytes);    } catch (KeeperException.NoNodeException ignore) {        }    return null;}
748e33a5fffdb660d0934959a25da7fde6bdff7b9d092c36722712d3ba078acc
cacheOpened
 void cacheOpened(ServiceCache<T> cache)
{    caches.add(cache);}
de73fa8c1f82f584300407795ca5d26f65a56411c49704af92058023ad23ce08
cacheClosed
 void cacheClosed(ServiceCache<T> cache)
{    caches.remove(cache);}
d9ae4c5419de5ffdf7ff58bd1530d69d756e5f8f31548aceb00002ac71ffb1e3
providerOpened
 void providerOpened(ServiceProvider<T> provider)
{    providers.add(provider);}
ed936239a60f99f03774116fffcf425c548cb540e79e760810196ebe7d42803b
providerClosed
 void providerClosed(ServiceProvider<T> cache)
{    providers.remove(cache);}
85ccbd5af870f9e622dece9448bbae07346a4c1cee08145eb1b325830b7ad326
getClient
 CuratorFramework getClient()
{    return client;}
732cd98147e5c42b04aa34ef1cc77dd8f5dbc06d1833fe327a72fa1eb2965a78
pathForName
 String pathForName(String name)
{    return ZKPaths.makePath(basePath, name);}
39f3a157f55191ce5bffcd2f7401fb303c5339022d7d0a47784b3cae04252cc3
getSerializer
 InstanceSerializer<T> getSerializer()
{    return serializer;}
8830df550e470b534db319eb9ce7514f6c0b618a26067b2aad6d37492301faa0
queryForInstances
 List<ServiceInstance<T>> queryForInstances(String name, Watcher watcher) throws Exception
{    ImmutableList.Builder<ServiceInstance<T>> builder = ImmutableList.builder();    String path = pathForName(name);    List<String> instanceIds;    if (watcher != null) {        instanceIds = getChildrenWatched(path, watcher, true);    } else {        try {            instanceIds = client.getChildren().forPath(path);        } catch (KeeperException.NoNodeException e) {            instanceIds = Lists.newArrayList();        }    }    for (String id : instanceIds) {        ServiceInstance<T> instance = queryForInstance(name, id);        if (instance != null) {            builder.add(instance);        }    }    return builder.build();}
9ec69bd46c2e59b9518987fd9558cdec54a088b77fbd7fc4266f5c3d842b60e8
debugServicesQty
 int debugServicesQty()
{    return services.size();}
2be308de068609fd0b5d5db8ed02d4ad2f89a9d8a499837ff0dd72308e0a275c
getChildrenWatched
private List<String> getChildrenWatched(String path, Watcher watcher, boolean recurse) throws Exception
{    List<String> instanceIds;    try {        instanceIds = client.getChildren().usingWatcher(watcher).forPath(path);    } catch (KeeperException.NoNodeException e) {        if (recurse) {            try {                client.create().creatingParentContainersIfNeeded().forPath(path);            } catch (KeeperException.NodeExistsException ignore) {                        }            instanceIds = getChildrenWatched(path, watcher, false);        } else {            throw e;        }    }    return instanceIds;}
66300c03d8c123a277db006dbc82dee87ef9cdc7354b27aaae96668f8dec026f
pathForInstance
 String pathForInstance(String name, String id)
{    return ZKPaths.makePath(pathForName(name), id);}
6c3f69c374dec73eebc2418bced0e9624aae98f901af31e84ceda6b7e1761f7f
getRegisteredService
 ServiceInstance<T> getRegisteredService(String id)
{    Entry<T> entry = services.get(id);    return (entry != null) ? entry.service : null;}
bbf558be9396cea4864bba89728eecaf416f617796c09447774ab77df7e71e73
reRegisterServices
private void reRegisterServices() throws Exception
{    for (final Entry<T> entry : services.values()) {        synchronized (entry) {            internalRegisterService(entry.service);        }    }}
0b195ebe96e593e6bf301160a0a4f2cc8e9eb313df6ff1a7766fef9ed7ebd9fd
makeNodeCache
private NodeCache makeNodeCache(final ServiceInstance<T> instance)
{    if (!watchInstances) {        return null;    }    final NodeCache nodeCache = new NodeCache(client, pathForInstance(instance.getName(), instance.getId()));    try {        nodeCache.start(true);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();        return null;    } catch (Exception e) {        log.error("Could not start node cache for: " + instance, e);    }    NodeCacheListener listener = new NodeCacheListener() {        @Override        public void nodeChanged() throws Exception {            if (nodeCache.getCurrentData() != null) {                ServiceInstance<T> newInstance = serializer.deserialize(nodeCache.getCurrentData().getData());                Entry<T> entry = services.get(newInstance.getId());                if (entry != null) {                    synchronized (entry) {                        entry.service = newInstance;                    }                }            } else {                log.warn("Instance data has been deleted for: " + instance);            }        }    };    nodeCache.getListenable().addListener(listener);    return nodeCache;}
95a1d12a17566499008636423784493306962712fbc4daf5f8810e4e38689b3c
nodeChanged
public void nodeChanged() throws Exception
{    if (nodeCache.getCurrentData() != null) {        ServiceInstance<T> newInstance = serializer.deserialize(nodeCache.getCurrentData().getData());        Entry<T> entry = services.get(newInstance.getId());        if (entry != null) {            synchronized (entry) {                entry.service = newInstance;            }        }    } else {        log.warn("Instance data has been deleted for: " + instance);    }}
fc87ff1a23a15c671cd9972611dd9e695d09983e00524bfe8368188fe70ce00c
internalUnregisterService
private void internalUnregisterService(final Entry<T> entry) throws Exception
{    if (entry != null) {        synchronized (entry) {            if (entry.cache != null) {                CloseableUtils.closeQuietly(entry.cache);                entry.cache = null;            }            String path = pathForInstance(entry.service.getName(), entry.service.getId());            try {                client.delete().guaranteed().forPath(path);            } catch (KeeperException.NoNodeException ignore) {                        }        }    }}
b1b02f2801ef2c213adc32f91e75e7757889f3ea4a9e8eeb85ca3b1f7910e799
build
public ServiceProvider<T> build()
{    return new ServiceProviderImpl<T>(discovery, serviceName, providerStrategy, threadFactory, filters, downInstancePolicy);}
7bde7e2ebd4b31d681ec3865b82fbbebd6a64116659f67d54669007e7a4356dd
serviceName
public ServiceProviderBuilder<T> serviceName(String serviceName)
{    this.serviceName = serviceName;    return this;}
6675f1f55dd06958456323a4a153d4e93479e66e01028559461eaa7c4bb05eae
providerStrategy
public ServiceProviderBuilder<T> providerStrategy(ProviderStrategy<T> providerStrategy)
{    this.providerStrategy = providerStrategy;    return this;}
2c792d442d34846647db813590928ecd086d6c1643c8d65a2618d9082b7c1962
threadFactory
public ServiceProviderBuilder<T> threadFactory(ThreadFactory threadFactory)
{    this.threadFactory = threadFactory;    return this;}
87b66eb9afc92f25795fc80fd6ac334082d5f65add314ba1079d6ec69323054a
downInstancePolicy
public ServiceProviderBuilder<T> downInstancePolicy(DownInstancePolicy downInstancePolicy)
{    this.downInstancePolicy = downInstancePolicy;    return this;}
3c6eb1bd2ba949f1f1cc30fe7802438cce6ab4d20e436a88b489101f9fb7ff40
additionalFilter
public ServiceProviderBuilder<T> additionalFilter(InstanceFilter<T> filter)
{    filters.add(filter);    return this;}
91c500d11b107150555e4abc700f4540c64332087bb8937cd815a3595c198f70
apply
public boolean apply(ServiceInstance<T> instance)
{    return instance.isEnabled();}
90ba0dddc593bd95e2a0c0c039c523b81bfb91f87814ebcb222c3914ca772ead
start
public void start() throws Exception
{    cache.start();    discovery.providerOpened(this);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    discovery.providerClosed(this);    cache.close();}
1d0b61f0d1fb981f4e5f4266423427198463d3104609854e6b70dbd271c69dd9
getAllInstances
public Collection<ServiceInstance<T>> getAllInstances() throws Exception
{    return instanceProvider.getInstances();}
696c8889284120eee9dfe31cdd3520f1d432bdf60029d02412672f598e65ed38
getInstance
public ServiceInstance<T> getInstance() throws Exception
{    return providerStrategy.getInstance(instanceProvider);}
a937ba1f2fdb3a736eab0687778575ae1d7f252b268503b8bea70262208033d0
noteError
public void noteError(ServiceInstance<T> instance)
{    downInstanceManager.add(instance);}
2d948e910632d8f03ff65f6a335f7410b23a42c428dac75e24fc67c5a224e445
getTimeoutMs
public long getTimeoutMs()
{    return timeoutMs;}
94296a1856df6619bbfc2cc358d770a07bea1fef28bd38989b27413e03b0fa14
getErrorThreshold
public int getErrorThreshold()
{    return errorThreshold;}
5b632aa9ae744ff1ccbb6b5c4796f3d76ef7a41dcb44023b2c8fabf1cf956b08
builder
public static ServiceDiscoveryBuilder<T> builder(Class<T> payloadClass)
{    return new ServiceDiscoveryBuilder<T>(payloadClass);}
6496eb7a734144ae6c4855d55c415df0148e78e9b4735c49920387aa8e16bcdd
build
public ServiceDiscovery<T> build()
{    if (serializer == null) {        serializer(new JsonInstanceSerializer<T>(payloadClass));    }    return new ServiceDiscoveryImpl<T>(client, basePath, serializer, thisInstance, watchInstances);}
86d64ac751cd81318f4b9bcaec2683f97896324feb8a1077f17e8a796242f6f0
client
public ServiceDiscoveryBuilder<T> client(CuratorFramework client)
{    this.client = client;    return this;}
616308f070739cc0b3f15e72875cce641a14575f56255482186a290e98ce8c63
basePath
public ServiceDiscoveryBuilder<T> basePath(String basePath)
{    this.basePath = basePath;    return this;}
d2be3f4f8b88da954f64cde1f35c5f9109ae7323a374dc19c6cc88a85e458e59
serializer
public ServiceDiscoveryBuilder<T> serializer(InstanceSerializer<T> serializer)
{    this.serializer = serializer;    return this;}
d4dbb10a703055ee8b9cec92f22692aab5412b5e9a589bf2b74584bf34aef48d
thisInstance
public ServiceDiscoveryBuilder<T> thisInstance(ServiceInstance<T> thisInstance)
{    this.thisInstance = thisInstance;    return this;}
24d3dcb64fb1a2482015f84d87dd15b3a358068450ce22a30cec1a90d94832af
watchInstances
public ServiceDiscoveryBuilder<T> watchInstances(boolean watchInstances)
{    this.watchInstances = watchInstances;    return this;}
2841158d62f6d4ba3e698be1a2890b20159d05446a90907f9849d7961088b906
builder
public static ServiceInstanceBuilder<T> builder() throws Exception
{    String address = null;    Collection<InetAddress> ips = ServiceInstanceBuilder.getAllLocalIPs();    if (ips.size() > 0) {                address = ips.iterator().next().getHostAddress();    }    String id = UUID.randomUUID().toString();    return new ServiceInstanceBuilder<T>().address(address).id(id).registrationTimeUTC(System.currentTimeMillis());}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
09e8f13a9a603d31d64bb498b77d15572483824d843d0e82a570643192f62186
getId
public String getId()
{    return id;}
08700efb8256487e686f7e38a61ccb0500f997abc6bd894e3acb149ec03d933b
getAddress
public String getAddress()
{    return address;}
286ac11a7c0c169929d6406e0293873a24296d28a94301df226e0d8700dcead6
getPort
public Integer getPort()
{    return port;}
7a28e92bfd350898412d279c1bd2c299670f0a1cfb66a864639d0f6d9f70a45f
getSslPort
public Integer getSslPort()
{    return sslPort;}
51556ec87a6e3a239ccb0b3de9d1dff54c284250b0c7fdd45d032a2b636c753e
getPayload
public T getPayload()
{    return payload;}
009350e825a7e30318ac5c626961698af44549d639846bb7e89fd3f4bf3d5d2e
getRegistrationTimeUTC
public long getRegistrationTimeUTC()
{    return registrationTimeUTC;}
8bfb90797c3b6ae0301e7316f0fb1c3a208afc08634daf6c2570412d86d86b08
getServiceType
public ServiceType getServiceType()
{    return serviceType;}
9144812940555009d09073e127645713262436d6231024301c0dd157e9cf79e4
getUriSpec
public UriSpec getUriSpec()
{    return uriSpec;}
3d48e803344c7a7e8e54f2ff2765c17f83485a126437f578afd50ad0c851ac27
isEnabled
public boolean isEnabled()
{    return enabled;}
5c8cf8e50410d73992b3e225479ef42f76184e86d8a6ca7010010051be7e9d00
buildUriSpec
public String buildUriSpec()
{    return buildUriSpec(Maps.<String, Object>newHashMap());}
47bac2da4424c0620b4b5ed4226f84f1c8e030cc08c04543da35f1879ff7428d
buildUriSpec
public String buildUriSpec(Map<String, Object> variables)
{    return (uriSpec != null) ? uriSpec.build(this, variables) : "";}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    ServiceInstance that = (ServiceInstance) o;    if (registrationTimeUTC != that.registrationTimeUTC) {        return false;    }    if (address != null ? !address.equals(that.address) : that.address != null) {        return false;    }    if (id != null ? !id.equals(that.id) : that.id != null) {        return false;    }    if (name != null ? !name.equals(that.name) : that.name != null) {        return false;    }    if (payload != null ? !payload.equals(that.payload) : that.payload != null) {        return false;    }    if (port != null ? !port.equals(that.port) : that.port != null) {        return false;    }    if (serviceType != that.serviceType) {        return false;    }    if (sslPort != null ? !sslPort.equals(that.sslPort) : that.sslPort != null) {        return false;    }    if (uriSpec != null ? !uriSpec.equals(that.uriSpec) : that.uriSpec != null) {        return false;    }    if (enabled != that.enabled) {        return false;    }    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = name != null ? name.hashCode() : 0;    result = 31 * result + (id != null ? id.hashCode() : 0);    result = 31 * result + (address != null ? address.hashCode() : 0);    result = 31 * result + (port != null ? port.hashCode() : 0);    result = 31 * result + (sslPort != null ? sslPort.hashCode() : 0);    result = 31 * result + (payload != null ? payload.hashCode() : 0);    result = 31 * result + (int) (registrationTimeUTC ^ (registrationTimeUTC >>> 32));    result = 31 * result + (serviceType != null ? serviceType.hashCode() : 0);    result = 31 * result + (uriSpec != null ? uriSpec.hashCode() : 0);    result = 31 * result + (enabled ? 1 : 0);    return result;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "ServiceInstance{" + "name='" + name + '\'' + ", id='" + id + '\'' + ", address='" + address + '\'' + ", port=" + port + ", sslPort=" + sslPort + ", payload=" + payload + ", registrationTimeUTC=" + registrationTimeUTC + ", serviceType=" + serviceType + ", uriSpec=" + uriSpec + ", enabled=" + enabled + '}';}
c910ee21507cdcea0ccc6e6162e2f9e4eb15a930c66eb9ceaf36bf1c73e7b920
use
public boolean use(NetworkInterface nif, InetAddress adr) throws SocketException
{    return (adr != null) && !adr.isLoopbackAddress() && (nif.isPointToPoint() || !adr.isLinkLocalAddress());}
b594cfbbe5f4bc34beb7dd18d8137ef5bd61efd433d42ecb83c67643866e916e
setLocalIpFilter
public static void setLocalIpFilter(LocalIpFilter newLocalIpFilter)
{    localIpFilter.set(newLocalIpFilter);}
24336937b892f2b9de823738c837b9f6e4fa38f53c49cbeb72dc88f0b5db2856
getLocalIpFilter
public static LocalIpFilter getLocalIpFilter()
{    return localIpFilter.get();}
5e5789487a033861206e43eed26932bfa7e21bf6a0a69fb3972322ea5926362b
build
public ServiceInstance<T> build()
{    return new ServiceInstance<T>(name, id, address, port, sslPort, payload, registrationTimeUTC, serviceType, uriSpec, enabled);}
bd5ed401ee98862644b663de445e146b4976921e43d2a60dd52ddc3f418dcf94
name
public ServiceInstanceBuilder<T> name(String name)
{    this.name = name;    return this;}
18e549d781e06d25cb546155dea1850a7f4b345cbf3344576a9cac5914fb6ab3
address
public ServiceInstanceBuilder<T> address(String address)
{    this.address = address;    return this;}
7c36f5ca344da0a9a2591afd66aa5c77ba893a0b73a225d352a7b86b6fd9294a
id
public ServiceInstanceBuilder<T> id(String id)
{    this.id = id;    return this;}
60041b07d70425076cf110a03c97be353ed01f6142c65ca420f88313b0529a78
port
public ServiceInstanceBuilder<T> port(int port)
{    this.port = port;    return this;}
13bdd1445d83b45a11f493f2d658e3d64916914e0e000e287d43d82c00c1ad77
sslPort
public ServiceInstanceBuilder<T> sslPort(int port)
{    this.sslPort = port;    return this;}
32237933c917e127be65d91849e5e6a36ffc96035da23cc2b27aafecba913e52
payload
public ServiceInstanceBuilder<T> payload(T payload)
{    this.payload = payload;    return this;}
5f6a883b5ef49b6e14572d6e215feb34613ae2b0ca3188b37e2bcaa2183c3979
serviceType
public ServiceInstanceBuilder<T> serviceType(ServiceType serviceType)
{    this.serviceType = serviceType;    return this;}
e23605fe10aa6b0ee5f9749913871748cb693a34ae079d8c094f5f67befb04d3
registrationTimeUTC
public ServiceInstanceBuilder<T> registrationTimeUTC(long registrationTimeUTC)
{    this.registrationTimeUTC = registrationTimeUTC;    return this;}
8efe064c2a0a3b9b308822b35ca4e616a5b264228ba709335c3b00fca1e7cf11
uriSpec
public ServiceInstanceBuilder<T> uriSpec(UriSpec uriSpec)
{    this.uriSpec = uriSpec;    return this;}
8bbb5c609e9a4fb956f55395cf409f8ac49b7afdbdced61fbb020d08dfbb1989
enabled
public ServiceInstanceBuilder<T> enabled(boolean enabled)
{    this.enabled = enabled;    return this;}
abe24a9ba85d9ca1f2b469244547a57d9bb36aee9f39bd27844b33304fe141a2
getAllLocalIPs
public static Collection<InetAddress> getAllLocalIPs() throws SocketException
{    List<InetAddress> listAdr = Lists.newArrayList();    Enumeration<NetworkInterface> nifs = NetworkInterface.getNetworkInterfaces();    if (nifs == null)        return listAdr;    while (nifs.hasMoreElements()) {        NetworkInterface nif = nifs.nextElement();                Enumeration<InetAddress> adrs = nif.getInetAddresses();        while (adrs.hasMoreElements()) {            InetAddress adr = adrs.nextElement();            if (localIpFilter.get().use(nif, adr)) {                listAdr.add(adr);            }        }    }    return listAdr;}
8c8672606b89fbdfaaef7f44ad10ab4cd6ef3975b60c01e04b05f18051cb5de0
isDynamic
public boolean isDynamic()
{    return this == DYNAMIC || this == DYNAMIC_SEQUENTIAL;}
cde1f970a180f4243da9f4243bd4d786116707fcf441a4557d854a46d6dcb3bb
getInstance
public ServiceInstance<T> getInstance(InstanceProvider<T> instanceProvider) throws Exception
{    List<ServiceInstance<T>> instances = instanceProvider.getInstances();    if (instances.size() == 0) {        return null;    }    int thisIndex = random.nextInt(instances.size());    return instances.get(thisIndex);}
cde1f970a180f4243da9f4243bd4d786116707fcf441a4557d854a46d6dcb3bb
getInstance
public ServiceInstance<T> getInstance(InstanceProvider<T> instanceProvider) throws Exception
{    List<ServiceInstance<T>> instances = instanceProvider.getInstances();    if (instances.size() == 0) {        return null;    }    int thisIndex = Math.abs(index.getAndIncrement());    return instances.get(thisIndex % instances.size());}
cde1f970a180f4243da9f4243bd4d786116707fcf441a4557d854a46d6dcb3bb
getInstance
public ServiceInstance<T> getInstance(InstanceProvider<T> instanceProvider) throws Exception
{    final List<ServiceInstance<T>> instances = instanceProvider.getInstances();    {        ServiceInstance<T> localOurInstance = ourInstance.get();        if (!instances.contains(localOurInstance)) {            ourInstance.compareAndSet(localOurInstance, null);        }    }    if (ourInstance.get() == null) {        ServiceInstance<T> instance = masterStrategy.getInstance(new InstanceProvider<T>() {            @Override            public List<ServiceInstance<T>> getInstances() throws Exception {                return instances;            }        });        if (ourInstance.compareAndSet(null, instance)) {            instanceNumber.incrementAndGet();        }    }    return ourInstance.get();}
d03b954d1a484c07551c598b65e9544d0a76ba99f03b8c1e54645e022c669257
getInstances
public List<ServiceInstance<T>> getInstances() throws Exception
{    return instances;}
4ce14d9c85f5dbc7691be5fb08fc3f8cae53cdb0e9786761c46dddade3117014
getInstanceNumber
public int getInstanceNumber()
{    return instanceNumber.get();}
3ffb3c74afa5355644c1f0bfdb5098954de2d3a057f971596bdb7110ccb67b1b
getValue
public String getValue()
{    return value;}
8f546dc4bce6516efd69add530860596049170110e9828897626aede4012cb2b
isVariable
public boolean isVariable()
{    return variable;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    Part part = (Part) o;    if (variable != part.variable) {        return false;    }    if (!value.equals(part.value)) {        return false;    }    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = value.hashCode();    result = 31 * result + (variable ? 1 : 0);    return result;}
2c716444a560d736f47bbf56827be3f9df40e47f29195b2bd4ac008307dfc2d6
build
public String build()
{    return build(null, Maps.<String, Object>newHashMap());}
81793d7cd45df6a2c028990cb3505a3fc6f4d9ceb9bd3f6f24d2dd4a5570c074
build
public String build(ServiceInstance<?> serviceInstance)
{    return build(serviceInstance, Maps.<String, Object>newHashMap());}
29d01d872966902b7f86eff94573ca170f76b9766973a1992682dd1ac6f2249b
build
public String build(Map<String, Object> variables)
{    return build(null, variables);}
d080ecee780ce39283ef974d0f82db0c713fa5c859dce85c8dccf39dfd4e90ab
build
public String build(ServiceInstance<?> serviceInstance, Map<String, Object> variables)
{    Map<String, Object> localVariables = Maps.newHashMap();    localVariables.put(FIELD_OPEN_BRACE, "{");    localVariables.put(FIELD_CLOSE_BRACE, "}");    localVariables.put(FIELD_SCHEME, "http");    if (serviceInstance != null) {        localVariables.put(FIELD_NAME, nullCheck(serviceInstance.getName()));        localVariables.put(FIELD_ID, nullCheck(serviceInstance.getId()));        localVariables.put(FIELD_ADDRESS, nullCheck(serviceInstance.getAddress()));        localVariables.put(FIELD_PORT, nullCheck(serviceInstance.getPort()));        localVariables.put(FIELD_SSL_PORT, nullCheck(serviceInstance.getSslPort()));        localVariables.put(FIELD_REGISTRATION_TIME_UTC, nullCheck(serviceInstance.getRegistrationTimeUTC()));        localVariables.put(FIELD_SERVICE_TYPE, (serviceInstance.getServiceType() != null) ? serviceInstance.getServiceType().name().toLowerCase() : "");        if (serviceInstance.getSslPort() != null) {            localVariables.put(FIELD_SCHEME, "https");        }    }    localVariables.putAll(variables);    StringBuilder str = new StringBuilder();    for (Part p : parts) {        if (p.isVariable()) {            Object value = localVariables.get(p.getValue());            if (value == null) {                log.debug("Variable not found: " + p.getValue());            } else {                str.append(value);            }        } else {            str.append(p.getValue());        }    }    return str.toString();}
85dfdfe3ca0d529a8a28fb6c1df355e8455bdbc9d70f589c98b4eb482e9a4764
iterator
public Iterator<Part> iterator()
{    return Iterators.unmodifiableIterator(parts.iterator());}
5013bb3baa429e4798269c250504192902b83bb345b72450dd71ddbbb5cc4194
getParts
public List<Part> getParts()
{    return ImmutableList.copyOf(parts);}
df65978bacb123cb85a6a21a8411e3c108115652568e3eaa1af68969ca5eba74
add
public void add(Part part)
{    parts.add(part);}
5b657a2fb2aa58cee804ec47e7fc1e4d63cc0d5ef42f9e95555e1a7240bee686
remove
public void remove(Part part)
{    parts.remove(part);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    UriSpec spec = (UriSpec) o;    if (!parts.equals(spec.parts)) {        return false;    }    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return parts.hashCode();}
967c661b381d414244be6736ba79efbb3dc8d4a792ed1d4807587499371c32b3
nullCheck
private Object nullCheck(Object o)
{    return (o != null) ? o : "";}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    ServiceInstance<Void> instance1 = ServiceInstance.<Void>builder().name("hey").id("1").build();    ServiceInstance<Void> instance2 = ServiceInstance.<Void>builder().name("hey").id("2").build();    DownInstanceManager<Void> downInstanceManager = new DownInstanceManager<Void>(debugDownInstancePolicy);    Assert.assertTrue(downInstanceManager.apply(instance1));    Assert.assertTrue(downInstanceManager.apply(instance2));    downInstanceManager.add(instance1);    Assert.assertFalse(downInstanceManager.apply(instance1));    Assert.assertTrue(downInstanceManager.apply(instance2));}
cbb4a052a35e2555eaab207da2e28b1427cfdc9fdccc989c99187f8d188ea5b9
testThreshold
public void testThreshold() throws Exception
{    ServiceInstance<Void> instance1 = ServiceInstance.<Void>builder().name("hey").id("1").build();    ServiceInstance<Void> instance2 = ServiceInstance.<Void>builder().name("hey").id("2").build();    DownInstanceManager<Void> downInstanceManager = new DownInstanceManager<Void>(debugMultiDownInstancePolicy);    Assert.assertTrue(downInstanceManager.apply(instance1));    Assert.assertTrue(downInstanceManager.apply(instance2));    downInstanceManager.add(instance1);    Assert.assertTrue(downInstanceManager.apply(instance1));    Assert.assertTrue(downInstanceManager.apply(instance2));    downInstanceManager.add(instance1);    Assert.assertFalse(downInstanceManager.apply(instance1));    Assert.assertTrue(downInstanceManager.apply(instance2));}
29a13533a2172a5cb9411fbe2a54ba0683f652c63b284222172e3f578660aac1
testExpiration
public void testExpiration() throws Exception
{    ServiceInstance<Void> instance1 = ServiceInstance.<Void>builder().name("hey").id("1").build();    ServiceInstance<Void> instance2 = ServiceInstance.<Void>builder().name("hey").id("2").build();    DownInstanceManager<Void> downInstanceManager = new DownInstanceManager<Void>(debugDownInstancePolicy);    downInstanceManager.add(instance1);    Assert.assertFalse(downInstanceManager.apply(instance1));    Assert.assertTrue(downInstanceManager.apply(instance2));    Thread.sleep(debugDownInstancePolicy.getTimeoutMs());    Assert.assertTrue(downInstanceManager.apply(instance1));    Assert.assertTrue(downInstanceManager.apply(instance2));}
a16161a20e758486790ab893c450db3b00fdee69619e7a44856cd6c3053b0cdb
testCompatibilityMode
public void testCompatibilityMode() throws Exception
{    JsonInstanceSerializer<TestJsonInstanceSerializer.Payload> serializer = new JsonInstanceSerializer<TestJsonInstanceSerializer.Payload>(TestJsonInstanceSerializer.Payload.class, true, true);    ServiceInstance<TestJsonInstanceSerializer.Payload> instance = new ServiceInstance<TestJsonInstanceSerializer.Payload>("name", "id", "address", 10, 20, new TestJsonInstanceSerializer.Payload("test"), 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), true);    byte[] bytes = serializer.serialize(instance);    OldServiceInstance<TestJsonInstanceSerializer.Payload> oldInstance = new OldServiceInstance<TestJsonInstanceSerializer.Payload>("name", "id", "address", 10, 20, new TestJsonInstanceSerializer.Payload("test"), 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"));    ObjectMapper mapper = new ObjectMapper();    byte[] oldBytes = mapper.writeValueAsBytes(oldInstance);    Assert.assertEquals(bytes, oldBytes, String.format("%s vs %s", new String(bytes), new String(oldBytes)));}
1096fd28e5f859f404dc5f5d5619e40411fad05544ca2558375dcbb697cdf320
testBackwardCompatibility
public void testBackwardCompatibility() throws Exception
{    JsonInstanceSerializer<TestJsonInstanceSerializer.Payload> serializer = new JsonInstanceSerializer<TestJsonInstanceSerializer.Payload>(TestJsonInstanceSerializer.Payload.class, true, true);    ServiceInstance<TestJsonInstanceSerializer.Payload> instance = new ServiceInstance<TestJsonInstanceSerializer.Payload>("name", "id", "address", 10, 20, new TestJsonInstanceSerializer.Payload("test"), 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), false);    byte[] bytes = serializer.serialize(instance);    instance = serializer.deserialize(bytes);        Assert.assertTrue(instance.isEnabled());    ObjectMapper mapper = new ObjectMapper();    JavaType type = mapper.getTypeFactory().constructType(OldServiceInstance.class);    OldServiceInstance rawServiceInstance = mapper.readValue(bytes, type);        TestJsonInstanceSerializer.Payload.class.cast(rawServiceInstance.getPayload());        OldServiceInstance<TestJsonInstanceSerializer.Payload> check = (OldServiceInstance<TestJsonInstanceSerializer.Payload>) rawServiceInstance;    Assert.assertEquals(check.getName(), instance.getName());    Assert.assertEquals(check.getId(), instance.getId());    Assert.assertEquals(check.getAddress(), instance.getAddress());    Assert.assertEquals(check.getPort(), instance.getPort());    Assert.assertEquals(check.getSslPort(), instance.getSslPort());    Assert.assertEquals(check.getPayload(), instance.getPayload());    Assert.assertEquals(check.getRegistrationTimeUTC(), instance.getRegistrationTimeUTC());    Assert.assertEquals(check.getServiceType(), instance.getServiceType());    Assert.assertEquals(check.getUriSpec(), instance.getUriSpec());}
cbfe406a8843b79a021e24e18f0e65ebbf65d1827f278ee13ee645ab2b4b47d2
testForwardCompatibility
public void testForwardCompatibility() throws Exception
{    OldServiceInstance<TestJsonInstanceSerializer.Payload> oldInstance = new OldServiceInstance<TestJsonInstanceSerializer.Payload>("name", "id", "address", 10, 20, new TestJsonInstanceSerializer.Payload("test"), 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"));    ObjectMapper mapper = new ObjectMapper();    byte[] oldJson = mapper.writeValueAsBytes(oldInstance);    JsonInstanceSerializer<TestJsonInstanceSerializer.Payload> serializer = new JsonInstanceSerializer<TestJsonInstanceSerializer.Payload>(TestJsonInstanceSerializer.Payload.class);    ServiceInstance<TestJsonInstanceSerializer.Payload> instance = serializer.deserialize(oldJson);    Assert.assertEquals(oldInstance.getName(), instance.getName());    Assert.assertEquals(oldInstance.getId(), instance.getId());    Assert.assertEquals(oldInstance.getAddress(), instance.getAddress());    Assert.assertEquals(oldInstance.getPort(), instance.getPort());    Assert.assertEquals(oldInstance.getSslPort(), instance.getSslPort());    Assert.assertEquals(oldInstance.getPayload(), instance.getPayload());    Assert.assertEquals(oldInstance.getRegistrationTimeUTC(), instance.getRegistrationTimeUTC());    Assert.assertEquals(oldInstance.getServiceType(), instance.getServiceType());    Assert.assertEquals(oldInstance.getUriSpec(), instance.getUriSpec());    Assert.assertTrue(instance.isEnabled());}
028d05153aa6d8dde89956875b65951aeb27f60ef5e1e44f0c0680350c14c3a7
testFutureChanges
public void testFutureChanges() throws Exception
{    TestNewServiceInstance<String> newInstance = new TestNewServiceInstance<String>("name", "id", "address", 10, 20, "hey", 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), false, "what", 10101L, new Date(), new URI("http://hey"));    byte[] newInstanceBytes = new ObjectMapper().writeValueAsBytes(newInstance);    JsonInstanceSerializer<String> serializer = new JsonInstanceSerializer<String>(String.class);    ServiceInstance<String> instance = serializer.deserialize(newInstanceBytes);    Assert.assertEquals(instance.getName(), "name");    Assert.assertEquals(instance.getPayload(), "hey");    Assert.assertEquals(instance.isEnabled(), false);}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
09e8f13a9a603d31d64bb498b77d15572483824d843d0e82a570643192f62186
getId
public String getId()
{    return id;}
08700efb8256487e686f7e38a61ccb0500f997abc6bd894e3acb149ec03d933b
getAddress
public String getAddress()
{    return address;}
286ac11a7c0c169929d6406e0293873a24296d28a94301df226e0d8700dcead6
getPort
public Integer getPort()
{    return port;}
7a28e92bfd350898412d279c1bd2c299670f0a1cfb66a864639d0f6d9f70a45f
getSslPort
public Integer getSslPort()
{    return sslPort;}
51556ec87a6e3a239ccb0b3de9d1dff54c284250b0c7fdd45d032a2b636c753e
getPayload
public T getPayload()
{    return payload;}
009350e825a7e30318ac5c626961698af44549d639846bb7e89fd3f4bf3d5d2e
getRegistrationTimeUTC
public long getRegistrationTimeUTC()
{    return registrationTimeUTC;}
8bfb90797c3b6ae0301e7316f0fb1c3a208afc08634daf6c2570412d86d86b08
getServiceType
public ServiceType getServiceType()
{    return serviceType;}
9144812940555009d09073e127645713262436d6231024301c0dd157e9cf79e4
getUriSpec
public UriSpec getUriSpec()
{    return uriSpec;}
3d48e803344c7a7e8e54f2ff2765c17f83485a126437f578afd50ad0c851ac27
isEnabled
public boolean isEnabled()
{    return enabled;}
c28d59854669a7045c30cbb332a18113fd1233917e135c15d5dbc13a4b0df724
getNew1
public String getNew1()
{    return new1;}
119637bbc07fccdf3e15a9fc3fca1e79419ecc2ff25fe34b7e9dc6c3d7516293
getNew2
public Long getNew2()
{    return new2;}
98e6b2fe0492148fb0f67b7dfa0bf78e7814c9d29c835368ff68ebaf541af6ed
getNew3
public Date getNew3()
{    return new3;}
4d4720f21d493ebab8e3c8ede0d44e230500607f2166892e4ab77f2dfb9b770a
getNew4
public URI getNew4()
{    return new4;}
3bfa5ea48c54d9144647b82cec72fe9c5a09fa5576eb0daa79714fb092f2e0bc
testRaceOnInitialLoad
public void testRaceOnInitialLoad() throws Exception
{    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/discovery").client(client).build();        closeables.add(discovery);        discovery.start();        CountDownLatch cacheStartLatch = new CountDownLatch(1);        CountDownLatch cacheWaitLatch = new CountDownLatch(1);        final ServiceCache<String> cache = discovery.serviceCacheBuilder().name("test").build();        closeables.add(cache);                ((ServiceCacheImpl) cache).debugStartLatch = cacheStartLatch;                ((ServiceCacheImpl) cache).debugStartWaitLatch = cacheWaitLatch;        ServiceInstance<String> instance1 = ServiceInstance.<String>builder().payload("test").name("test").port(10064).build();        discovery.registerService(instance1);        CloseableExecutorService closeableExecutorService = new CloseableExecutorService(Executors.newSingleThreadExecutor());        closeables.add(closeableExecutorService);        final CountDownLatch startCompletedLatch = new CountDownLatch(1);        Runnable proc = new Runnable() {            @Override            public void run() {                try {                    cache.start();                    startCompletedLatch.countDown();                } catch (Exception e) {                    LoggerFactory.getLogger(getClass()).error("Start failed", e);                    throw new RuntimeException(e);                }            }        };        closeableExecutorService.submit(proc);                Assert.assertTrue(timing.awaitLatch(cacheStartLatch));        final CountDownLatch cacheChangedLatch = new CountDownLatch(1);        ServiceCacheListener listener = new ServiceCacheListener() {            @Override            public void cacheChanged() {                cacheChangedLatch.countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {                        }        };        cache.addListener(listener);        ServiceInstance<String> instance2 = ServiceInstance.<String>builder().payload("test").name("test").port(10065).build();                discovery.registerService(instance2);        Assert.assertTrue(timing.awaitLatch(cacheChangedLatch));        cacheWaitLatch.countDown();        Assert.assertTrue(timing.awaitLatch(startCompletedLatch));    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        cache.start();        startCompletedLatch.countDown();    } catch (Exception e) {        LoggerFactory.getLogger(getClass()).error("Start failed", e);        throw new RuntimeException(e);    }}
687c36bfaa7d559f1c63ed0b1da46041439ff4566a304ff7eabd27ea52eebedf
cacheChanged
public void cacheChanged()
{    cacheChangedLatch.countDown();}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
2bb7c3759e748603b8496b4f17c4a8cacccb9bcc8d8aa02c575175dc0cd8c001
compare
public int compare(ServiceInstance<Void> o1, ServiceInstance<Void> o2)
{    return o1.getId().compareTo(o2.getId());}
7c5c1c01135afa2a966f82946920436aac203f916ad519d7e2a63f648cdcbbf3
testCrashedServerMultiInstances
public void testCrashedServerMultiInstances() throws Exception
{    CuratorFramework client = null;    ServiceDiscovery<String> discovery = null;    try {        Timing timing = new Timing();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        final Semaphore semaphore = new Semaphore(0);        ServiceInstance<String> instance1 = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        ServiceInstance<String> instance2 = ServiceInstance.<String>builder().payload("thing").name("test").port(10065).build();        discovery = new ServiceDiscoveryImpl<String>(client, "/test", new JsonInstanceSerializer<String>(String.class), instance1, false) {            @Override            protected void internalRegisterService(ServiceInstance<String> service) throws Exception {                super.internalRegisterService(service);                semaphore.release();            }        };        discovery.start();        discovery.registerService(instance2);        timing.acquireSemaphore(semaphore, 2);        Assert.assertEquals(discovery.queryForInstances("test").size(), 2);        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        server.stop();        server.restart();        timing.acquireSemaphore(semaphore, 2);        Assert.assertEquals(discovery.queryForInstances("test").size(), 2);    } finally {        CloseableUtils.closeQuietly(discovery);        CloseableUtils.closeQuietly(client);    }}
d4a649df389adc98537f9cf497d92ce86f797e0d3a1d55105f5264b1a6e77f49
internalRegisterService
protected void internalRegisterService(ServiceInstance<String> service) throws Exception
{    super.internalRegisterService(service);    semaphore.release();}
41299d9cc717c47d4b8f8f415019184cb004df251535c9c5f3c2cc8fdfe54a78
testCrashedServer
public void testCrashedServer() throws Exception
{    CuratorFramework client = null;    ServiceDiscovery<String> discovery = null;    try {        Timing timing = new Timing();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        final Semaphore semaphore = new Semaphore(0);        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        discovery = new ServiceDiscoveryImpl<String>(client, "/test", new JsonInstanceSerializer<String>(String.class), instance, false) {            @Override            protected void internalRegisterService(ServiceInstance<String> service) throws Exception {                super.internalRegisterService(service);                semaphore.release();            }        };        discovery.start();        timing.acquireSemaphore(semaphore);        Assert.assertEquals(discovery.queryForInstances("test").size(), 1);        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        server.stop();        server.restart();        timing.acquireSemaphore(semaphore);        Assert.assertEquals(discovery.queryForInstances("test").size(), 1);    } finally {        CloseableUtils.closeQuietly(discovery);        CloseableUtils.closeQuietly(client);    }}
d4a649df389adc98537f9cf497d92ce86f797e0d3a1d55105f5264b1a6e77f49
internalRegisterService
protected void internalRegisterService(ServiceInstance<String> service) throws Exception
{    super.internalRegisterService(service);    semaphore.release();}
c1a9d069d8eb2c5bf5b1caa0edbdd41e7d40ea2e28a59777291bf97602729cf0
testCrashedInstance
public void testCrashedInstance() throws Exception
{    CuratorFramework client = null;    ServiceDiscovery<String> discovery = null;    try {        Timing timing = new Timing();        client = CuratorFrameworkFactory.newClient(server.getConnectString(), timing.session(), timing.connection(), new RetryOneTime(1));        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        discovery = new ServiceDiscoveryImpl<String>(client, "/test", new JsonInstanceSerializer<String>(String.class), instance, false);        discovery.start();        Assert.assertEquals(discovery.queryForInstances("test").size(), 1);        Compatibility.injectSessionExpiration(client.getZookeeperClient().getZooKeeper());        Thread.sleep(timing.multiple(1.5).session());        Assert.assertEquals(discovery.queryForInstances("test").size(), 1);    } finally {        CloseableUtils.closeQuietly(discovery);        CloseableUtils.closeQuietly(client);    }}
0fecb17a5c27341221813b6de9e56754067d08dc793f52db4ab1d91ff5a916c0
testMultipleInstances
public void testMultipleInstances() throws Exception
{    final String SERVICE_ONE = "one";    final String SERVICE_TWO = "two";    CuratorFramework client = null;    ServiceDiscovery<Void> discovery = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        ServiceInstance<Void> s1_i1 = ServiceInstance.<Void>builder().name(SERVICE_ONE).build();        ServiceInstance<Void> s1_i2 = ServiceInstance.<Void>builder().name(SERVICE_ONE).build();        ServiceInstance<Void> s2_i1 = ServiceInstance.<Void>builder().name(SERVICE_TWO).build();        ServiceInstance<Void> s2_i2 = ServiceInstance.<Void>builder().name(SERVICE_TWO).build();        discovery = ServiceDiscoveryBuilder.builder(Void.class).client(client).basePath("/test").build();        discovery.start();        discovery.registerService(s1_i1);        discovery.registerService(s1_i2);        discovery.registerService(s2_i1);        discovery.registerService(s2_i2);        Assert.assertEquals(Sets.newHashSet(discovery.queryForNames()), Sets.newHashSet(SERVICE_ONE, SERVICE_TWO));        List<ServiceInstance<Void>> list = Lists.newArrayList();        list.add(s1_i1);        list.add(s1_i2);        Collections.sort(list, comparator);        List<ServiceInstance<Void>> queriedInstances = Lists.newArrayList(discovery.queryForInstances(SERVICE_ONE));        Collections.sort(queriedInstances, comparator);        Assert.assertEquals(queriedInstances, list, String.format("Not equal l: %s - d: %s", list, queriedInstances));        list.clear();        list.add(s2_i1);        list.add(s2_i2);        Collections.sort(list, comparator);        queriedInstances = Lists.newArrayList(discovery.queryForInstances(SERVICE_TWO));        Collections.sort(queriedInstances, comparator);        Assert.assertEquals(queriedInstances, list, String.format("Not equal 2: %s - d: %s", list, queriedInstances));    } finally {        CloseableUtils.closeQuietly(discovery);        CloseableUtils.closeQuietly(client);    }}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    CuratorFramework client = null;    ServiceDiscovery<String> discovery = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/test").client(client).thisInstance(instance).build();        discovery.start();        Assert.assertEquals(discovery.queryForNames(), Collections.singletonList("test"));        List<ServiceInstance<String>> list = Lists.newArrayList();        list.add(instance);        Assert.assertEquals(discovery.queryForInstances("test"), list);    } finally {        CloseableUtils.closeQuietly(discovery);        CloseableUtils.closeQuietly(client);    }}
3dbbf388c2707773bf3ecd62ed28bcc350e3645fe7d931b26019d2172ee0f6e6
testNoServerOnStart
public void testNoServerOnStart() throws Exception
{    Timing timing = new Timing();    server.stop();    CuratorFramework client = null;    ServiceDiscovery<String> discovery = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/test").client(client).thisInstance(instance).build();        discovery.start();        server.restart();        timing.sleepABit();        Assert.assertEquals(discovery.queryForNames(), Collections.singletonList("test"));        List<ServiceInstance<String>> list = Lists.newArrayList();        list.add(instance);        Assert.assertEquals(discovery.queryForInstances("test"), list);    } finally {        CloseableUtils.closeQuietly(discovery);        CloseableUtils.closeQuietly(client);    }}
0999220510bdd41ac62ef0d4571560e5ce538b97170b106442bd67b77c21cd93
testUnregisterService
public void testUnregisterService() throws Exception
{    final String name = "name";    final CountDownLatch restartLatch = new CountDownLatch(1);    InstanceSerializer<String> slowSerializer = new JsonInstanceSerializer<String>(String.class) {        private boolean first = true;        @Override        public byte[] serialize(ServiceInstance<String> instance) throws Exception {            if (first) {                System.out.println("Serializer first registration.");                first = false;            } else {                System.out.println("Waiting for reconnect to finish.");                                                restartLatch.await();            }            return super.serialize(instance);        }    };    CuratorFramework client = null;    ServiceDiscovery<String> discovery = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name(name).port(10064).build();        discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/test").client(client).thisInstance(instance).serializer(slowSerializer).watchInstances(true).build();        discovery.start();        Assert.assertFalse(discovery.queryForInstances(name).isEmpty(), "Service should start registered.");        server.stop();        server.restart();        discovery.unregisterService(instance);        restartLatch.countDown();                new Timing().sleepABit();        Assert.assertTrue(discovery.queryForInstances(name).isEmpty(), "Service should have unregistered.");    } finally {        CloseableUtils.closeQuietly(discovery);        CloseableUtils.closeQuietly(client);    }}
f8a36909bafc8276d371720dc48d3caa7c53081fd3247f8e9b73449360cb016d
serialize
public byte[] serialize(ServiceInstance<String> instance) throws Exception
{    if (first) {        System.out.println("Serializer first registration.");        first = false;    } else {        System.out.println("Waiting for reconnect to finish.");                        restartLatch.await();    }    return super.serialize(instance);}
0c789a7d45bc05fc524f33e9e79275657c70af8f7d76c950494874998e95cb3b
testCleaning
public void testCleaning() throws Exception
{    CuratorFramework client = null;    ServiceDiscovery<String> discovery = null;    try {        client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/test").client(client).thisInstance(instance).build();        discovery.start();        discovery.unregisterService(instance);        Assert.assertEquals(((ServiceDiscoveryImpl) discovery).debugServicesQty(), 0);    } finally {        CloseableUtils.closeQuietly(discovery);        CloseableUtils.closeQuietly(client);    }}
eadf0f08e571c79d70cc5b224c1144717a454580ed1a9efabb469c6c46446573
testDefaultSerializer
public void testDefaultSerializer() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    ServiceDiscoveryBuilder<Object> builder = ServiceDiscoveryBuilder.builder(Object.class).client(client);    ServiceDiscoveryImpl<?> discovery = (ServiceDiscoveryImpl<?>) builder.basePath("/path").build();    Assert.assertNotNull(discovery.getSerializer(), "default serializer not set");    Assert.assertTrue(discovery.getSerializer() instanceof JsonInstanceSerializer, "default serializer not JSON");}
888f6066560549f0ec33ef039b07f67d8147a0114d5b32c040a570f422b2ee5e
testSetSerializer
public void testSetSerializer() throws Exception
{    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));    ServiceDiscoveryBuilder<Object> builder = ServiceDiscoveryBuilder.builder(Object.class).client(client);    builder.serializer(new InstanceSerializer<Object>() {        @Override        public byte[] serialize(ServiceInstance<Object> instance) {            return null;        }        @Override        public ServiceInstance<Object> deserialize(byte[] bytes) {            return null;        }    });    ServiceDiscoveryImpl<?> discovery = (ServiceDiscoveryImpl<?>) builder.basePath("/path").build();    Assert.assertNotNull(discovery.getSerializer(), "default serializer not set");    Assert.assertFalse(discovery.getSerializer() instanceof JsonInstanceSerializer, "set serializer is JSON");}
6fd8f35aee88de35b60ad483ee5a1967782fa13485ed38b87c96ac0c34fe75fa
serialize
public byte[] serialize(ServiceInstance<Object> instance)
{    return null;}
04d865026f0d2fc8383ccaf8905c2b0f447bd9ddf712ff7294410feaed278a1e
deserialize
public ServiceInstance<Object> deserialize(byte[] bytes)
{    return null;}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/test").client(client).thisInstance(instance).build();        closeables.add(discovery);        discovery.start();        ServiceProvider<String> provider = discovery.serviceProviderBuilder().serviceName("test").build();        closeables.add(provider);        provider.start();        Assert.assertEquals(provider.getInstance(), instance);        List<ServiceInstance<String>> list = Lists.newArrayList();        list.add(instance);        Assert.assertEquals(provider.getAllInstances(), list);    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
9d771441c26c1b77ed8d12e37c057ade5b790dcac9e44e6ba9ad7b0ca60273d5
testDisabledInstance
public void testDisabledInstance() throws Exception
{    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).enabled(false).build();        InstanceSerializer<String> serializer = new JsonInstanceSerializer<>(String.class, false);        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).serializer(serializer).basePath("/test").client(client).thisInstance(instance).build();        closeables.add(discovery);        discovery.start();        ServiceProvider<String> provider = discovery.serviceProviderBuilder().serviceName("test").build();        closeables.add(provider);        provider.start();        Assert.assertEquals(provider.getInstance(), null);        Assert.assertTrue(provider.getAllInstances().isEmpty(), "Disabled instance still appears available via service provider");    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
49149c129611c1727064acc0ed592d7b1eb32039965fb271ba3181ba9f538840
testWatchedInstances
public void testWatchedInstances() throws Exception
{    Timing timing = new Timing();    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/test").client(client).thisInstance(instance).watchInstances(true).build();        closeables.add(discovery);        discovery.start();        Assert.assertEquals(discovery.queryForNames(), Arrays.asList("test"));        List<ServiceInstance<String>> list = Lists.newArrayList();        list.add(instance);        Assert.assertEquals(discovery.queryForInstances("test"), list);        ServiceDiscoveryImpl<String> discoveryImpl = (ServiceDiscoveryImpl<String>) discovery;        ServiceInstance<String> changedInstance = ServiceInstance.<String>builder().id(instance.getId()).address(instance.getAddress()).payload("different").name(instance.getName()).port(instance.getPort()).build();        String path = discoveryImpl.pathForInstance("test", instance.getId());        byte[] bytes = discoveryImpl.getSerializer().serialize(changedInstance);        client.setData().forPath(path, bytes);        timing.sleepABit();        ServiceInstance<String> registeredService = discoveryImpl.getRegisteredService(instance.getId());        Assert.assertNotNull(registeredService);        Assert.assertEquals(registeredService.getPayload(), "different");    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    TestingServer testingServer = new TestingServer();    final CuratorFramework curatorFramework = CuratorFrameworkFactory.newClient(testingServer.getConnectString(), new RetryOneTime(1));    try {        curatorFramework.start();        doWork(curatorFramework);        System.gc();        System.out.println("Done - get dump");        Thread.currentThread().join();    } finally {        CloseableUtils.closeQuietly(curatorFramework);        CloseableUtils.closeQuietly(testingServer);    }}
324e8d67e3d2fb2650dc55ae0340cdd074a728cede617a87f4cdf14ef3b0e985
doWork
private static void doWork(CuratorFramework curatorFramework) throws Exception
{    ServiceInstance<Void> thisInstance = ServiceInstance.<Void>builder().name("myservice").build();    final ServiceDiscovery<Void> serviceDiscovery = ServiceDiscoveryBuilder.builder(Void.class).client(curatorFramework.usingNamespace("dev")).basePath("/instances").thisInstance(thisInstance).build();    serviceDiscovery.start();    for (int i = 0; i < 100000; i++) {        final ServiceProvider<Void> s = serviceProvider(serviceDiscovery, "myservice");        s.start();        try {            s.getInstance().buildUriSpec();        } finally {            s.close();        }    }}
2ff13efc80736caa3c6a1e795ae79a86cf960aa31941fd0a12c4ffc66a26a7a2
serviceProvider
private static ServiceProvider<Void> serviceProvider(ServiceDiscovery<Void> serviceDiscovery, String name) throws Exception
{    return serviceDiscovery.serviceProviderBuilder().serviceName(name).providerStrategy(new RandomStrategy<Void>()).build();}
374f30b9565fa26944e766e4b0405ecb054a03175df55727b3e28dc9fd8468ac
testBasic
public void testBasic() throws Exception
{    JsonInstanceSerializer<String> serializer = new JsonInstanceSerializer<String>(String.class);    ServiceInstance<String> instance = new ServiceInstance<String>("name", "id", "address", 10, 20, "payload", 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), true);    byte[] bytes = serializer.serialize(instance);    ServiceInstance<String> rhs = serializer.deserialize(bytes);    Assert.assertEquals(instance, rhs);    Assert.assertEquals(instance.getId(), rhs.getId());    Assert.assertEquals(instance.getName(), rhs.getName());    Assert.assertEquals(instance.getPayload(), rhs.getPayload());    Assert.assertEquals(instance.getAddress(), rhs.getAddress());    Assert.assertEquals(instance.getPort(), rhs.getPort());    Assert.assertEquals(instance.getSslPort(), rhs.getSslPort());    Assert.assertEquals(instance.getUriSpec(), rhs.getUriSpec());    Assert.assertEquals(instance.isEnabled(), rhs.isEnabled());}
5c930923b9e6dcfac2b6e547523882f34d321e613f1deaa53ae316ef4a6ac392
testWrongPayloadType
public void testWrongPayloadType() throws Exception
{    JsonInstanceSerializer<String> stringSerializer = new JsonInstanceSerializer<String>(String.class);    JsonInstanceSerializer<Double> doubleSerializer = new JsonInstanceSerializer<Double>(Double.class);    byte[] bytes = stringSerializer.serialize(new ServiceInstance<String>("name", "id", "address", 10, 20, "payload", 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), true));    try {        doubleSerializer.deserialize(bytes);        Assert.fail();    } catch (ClassCastException e) {        }}
f4b0ab2065eca6cbabee6657123cb54fa8472614e0f1ea6e91fc2d3978cd4734
testNoPayload
public void testNoPayload() throws Exception
{    JsonInstanceSerializer<Void> serializer = new JsonInstanceSerializer<Void>(Void.class);    ServiceInstance<Void> instance = new ServiceInstance<Void>("name", "id", "address", 10, 20, null, 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), true);    byte[] bytes = serializer.serialize(instance);    ServiceInstance<Void> rhs = serializer.deserialize(bytes);    Assert.assertEquals(instance, rhs);    Assert.assertEquals(instance.getId(), rhs.getId());    Assert.assertEquals(instance.getName(), rhs.getName());    Assert.assertEquals(instance.getPayload(), rhs.getPayload());    Assert.assertEquals(instance.getAddress(), rhs.getAddress());    Assert.assertEquals(instance.getPort(), rhs.getPort());    Assert.assertEquals(instance.getSslPort(), rhs.getSslPort());    Assert.assertEquals(instance.getUriSpec(), rhs.getUriSpec());    Assert.assertEquals(instance.isEnabled(), rhs.isEnabled());}
ef8e6c8bd1c4fee39a29d981adbc593be0334688f450a756b1ac3f3f650c6ce6
testNoEnabledState
public void testNoEnabledState() throws Exception
{    JsonInstanceSerializer<Void> serializer = new JsonInstanceSerializer<Void>(Void.class);    byte[] bytes = "{}".getBytes("utf-8");    ServiceInstance<Void> instance = serializer.deserialize(bytes);    Assert.assertTrue(instance.isEnabled(), "Instance that has no 'enabled' should be assumed enabled");}
ae72e809dffd69683593be174b652bc86ae8fa0c6630343df05238dcb9fbbf3c
testPayloadAsList
public void testPayloadAsList() throws Exception
{    JsonInstanceSerializer<Object> serializer = new JsonInstanceSerializer<Object>(Object.class, false);    List<String> payload = new ArrayList<String>();    payload.add("Test value 1");    payload.add("Test value 2");    ServiceInstance<Object> instance = new ServiceInstance<Object>("name", "id", "address", 10, 20, payload, 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), false);    byte[] bytes = serializer.serialize(instance);    ServiceInstance<Object> rhs = serializer.deserialize(bytes);    Assert.assertEquals(instance, rhs);    Assert.assertEquals(instance.getId(), rhs.getId());    Assert.assertEquals(instance.getName(), rhs.getName());    Assert.assertEquals(instance.getPayload(), rhs.getPayload());    Assert.assertEquals(instance.getAddress(), rhs.getAddress());    Assert.assertEquals(instance.getPort(), rhs.getPort());    Assert.assertEquals(instance.getSslPort(), rhs.getSslPort());    Assert.assertEquals(instance.getUriSpec(), rhs.getUriSpec());    Assert.assertEquals(instance.isEnabled(), rhs.isEnabled());}
05a0a48668a79356dca25708014b7c2ba096b5d137674f403f14710f6c6eba96
testPayloadAsMap
public void testPayloadAsMap() throws Exception
{    JsonInstanceSerializer<Object> serializer = new JsonInstanceSerializer<Object>(Object.class, false);    Map<String, String> payload = new HashMap<String, String>();    payload.put("1", "Test value 1");    payload.put("2", "Test value 2");    ServiceInstance<Object> instance = new ServiceInstance<Object>("name", "id", "address", 10, 20, payload, 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), false);    byte[] bytes = serializer.serialize(instance);    ServiceInstance<Object> rhs = serializer.deserialize(bytes);    Assert.assertEquals(instance, rhs);    Assert.assertEquals(instance.getId(), rhs.getId());    Assert.assertEquals(instance.getName(), rhs.getName());    Assert.assertEquals(instance.getPayload(), rhs.getPayload());    Assert.assertEquals(instance.getAddress(), rhs.getAddress());    Assert.assertEquals(instance.getPort(), rhs.getPort());    Assert.assertEquals(instance.getSslPort(), rhs.getSslPort());    Assert.assertEquals(instance.getUriSpec(), rhs.getUriSpec());    Assert.assertEquals(instance.isEnabled(), rhs.isEnabled());}
63d6c8601a4c9cb3f236dbbc433e0418466c45017b3b7feb084ee6a2a5243037
testPayloadClass
public void testPayloadClass() throws Exception
{    JsonInstanceSerializer<Payload> serializer = new JsonInstanceSerializer<Payload>(Payload.class);    Payload payload = new Payload();    payload.setVal("Test value");    ServiceInstance<Payload> instance = new ServiceInstance<Payload>("name", "id", "address", 10, 20, payload, 0, ServiceType.DYNAMIC, new UriSpec("{a}/b/{c}"), true);    byte[] bytes = serializer.serialize(instance);    ServiceInstance<Payload> rhs = serializer.deserialize(bytes);    Assert.assertEquals(instance, rhs);    Assert.assertEquals(instance.getId(), rhs.getId());    Assert.assertEquals(instance.getName(), rhs.getName());    Assert.assertEquals(instance.getPayload(), rhs.getPayload());    Assert.assertEquals(instance.getAddress(), rhs.getAddress());    Assert.assertEquals(instance.getPort(), rhs.getPort());    Assert.assertEquals(instance.getSslPort(), rhs.getSslPort());    Assert.assertEquals(instance.getUriSpec(), rhs.getUriSpec());    Assert.assertEquals(instance.isEnabled(), rhs.isEnabled());}
66a8a7c4e7979bc48046fd94c03ece1991eac660e36d0711d4ccd211659348a6
getVal
public String getVal()
{    return val;}
cd21b5e45ddbe8ff280030f34ea320746a3db4b579bcce811fd7bf550ee12636
setVal
public void setVal(String val)
{    this.val = val;}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    if (other == null || !(other instanceof Payload))        return false;    String otherVal = ((Payload) other).getVal();    if (val == null)        return val == otherVal;    return val.equals(otherVal);}
db832e32e124f3a5857890a0ec564d6daf8cd68b38db0baa3534fb185f1c1573
testFilterEverything
public void testFilterEverything() throws SocketException
{    LocalIpFilter localIpFilter = ServiceInstanceBuilder.getLocalIpFilter();    try {        ServiceInstanceBuilder.setLocalIpFilter(new LocalIpFilter() {            @Override            public boolean use(NetworkInterface networkInterface, InetAddress address) throws SocketException {                return false;            }        });        List<InetAddress> allLocalIPs = Lists.newArrayList(ServiceInstanceBuilder.getAllLocalIPs());        Assert.assertEquals(allLocalIPs.size(), 0);    } finally {        ServiceInstanceBuilder.setLocalIpFilter(localIpFilter);    }    List<InetAddress> allLocalIPs = Lists.newArrayList(ServiceInstanceBuilder.getAllLocalIPs());    Assert.assertTrue(allLocalIPs.size() > 0);}
2091e4a43345e6d8de8a95cb6387379e4f296bfd54c479d1e43a7c5d8ea77a21
use
public boolean use(NetworkInterface networkInterface, InetAddress address) throws SocketException
{    return false;}
0731ad244fd8fc2ac9cda3603109dcb6ecf94abf33b29ea4542f8e44fb664d71
testInitialLoad
public void testInitialLoad() throws Exception
{    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/discovery").client(client).build();        closeables.add(discovery);        discovery.start();        ServiceCache<String> cache = discovery.serviceCacheBuilder().name("test").build();        closeables.add(cache);        final CountDownLatch latch = new CountDownLatch(3);        ServiceCacheListener listener = new ServiceCacheListener() {            @Override            public void cacheChanged() {                latch.countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        cache.addListener(listener);        cache.start();        ServiceInstance<String> instance1 = ServiceInstance.<String>builder().payload("test").name("test").port(10064).build();        ServiceInstance<String> instance2 = ServiceInstance.<String>builder().payload("test").name("test").port(10065).build();        ServiceInstance<String> instance3 = ServiceInstance.<String>builder().payload("test").name("test").port(10066).build();        discovery.registerService(instance1);        discovery.registerService(instance2);        discovery.registerService(instance3);        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        ServiceCache<String> cache2 = discovery.serviceCacheBuilder().name("test").build();        closeables.add(cache2);        cache2.start();        Assert.assertEquals(cache2.getInstances().size(), 3);    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
687c36bfaa7d559f1c63ed0b1da46041439ff4566a304ff7eabd27ea52eebedf
cacheChanged
public void cacheChanged()
{    latch.countDown();}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
59ce9426cefd790289c95b36af9372ec41d28ea95707f8a8593271ac0dd709b6
testViaProvider
public void testViaProvider() throws Exception
{    Timing timing = new Timing();    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/discovery").client(client).build();        closeables.add(discovery);        discovery.start();        ServiceProvider<String> serviceProvider = discovery.serviceProviderBuilder().serviceName("test").build();        closeables.add(serviceProvider);        serviceProvider.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        discovery.registerService(instance);        int count = 0;        ServiceInstance<String> foundInstance = null;        while (foundInstance == null) {            Assert.assertTrue(count++ < 5);            foundInstance = serviceProvider.getInstance();            timing.sleepABit();        }        Assert.assertEquals(foundInstance, instance);        ServiceInstance<String> instance2 = ServiceInstance.<String>builder().address("foo").payload("thing").name("test").port(10064).build();        discovery.registerService(instance2);        timing.sleepABit();        Collection<ServiceInstance<String>> allInstances = serviceProvider.getAllInstances();        Assert.assertEquals(allInstances.size(), 2);    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
d19d650ea423ef8019fbbc8f9516cd0600011e7a0086944eae56ec60e0a765af
testUpdate
public void testUpdate() throws Exception
{    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceInstance<String> instance = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/test").client(client).thisInstance(instance).build();        closeables.add(discovery);        discovery.start();        final CountDownLatch latch = new CountDownLatch(1);        ServiceCache<String> cache = discovery.serviceCacheBuilder().name("test").build();        closeables.add(cache);        ServiceCacheListener listener = new ServiceCacheListener() {            @Override            public void cacheChanged() {                latch.countDown();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        cache.addListener(listener);        cache.start();        instance = ServiceInstance.<String>builder().payload("changed").name("test").port(10064).id(instance.getId()).build();        discovery.updateService(instance);        Assert.assertTrue(latch.await(10, TimeUnit.SECONDS));        Assert.assertEquals(cache.getInstances().size(), 1);        Assert.assertEquals(cache.getInstances().get(0).getPayload(), instance.getPayload());    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
687c36bfaa7d559f1c63ed0b1da46041439ff4566a304ff7eabd27ea52eebedf
cacheChanged
public void cacheChanged()
{    latch.countDown();}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
262162e24300eabe1c6b7a6f8527138d5f66f6dc70a8c47816da86ae3e964667
testCache
public void testCache() throws Exception
{    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/discovery").client(client).build();        closeables.add(discovery);        discovery.start();        ServiceCache<String> cache = discovery.serviceCacheBuilder().name("test").build();        closeables.add(cache);        cache.start();        final Semaphore semaphore = new Semaphore(0);        ServiceCacheListener listener = new ServiceCacheListener() {            @Override            public void cacheChanged() {                semaphore.release();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        cache.addListener(listener);        ServiceInstance<String> instance1 = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        ServiceInstance<String> instance2 = ServiceInstance.<String>builder().payload("thing").name("test").port(10065).build();        discovery.registerService(instance1);        Assert.assertTrue(semaphore.tryAcquire(10, TimeUnit.SECONDS));        discovery.registerService(instance2);        Assert.assertTrue(semaphore.tryAcquire(3, TimeUnit.SECONDS));        ServiceInstance<String> instance3 = ServiceInstance.<String>builder().payload("thing").name("another").port(10064).build();        discovery.registerService(instance3);                Assert.assertFalse(semaphore.tryAcquire(3, TimeUnit.SECONDS));    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
687c36bfaa7d559f1c63ed0b1da46041439ff4566a304ff7eabd27ea52eebedf
cacheChanged
public void cacheChanged()
{    semaphore.release();}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
1c138b2b7aa596cd33cd25725cccc2b4efa8d8df1e2acc4838864e753afdbb07
testExecutorServiceIsInvoked
public void testExecutorServiceIsInvoked() throws Exception
{    List<Closeable> closeables = Lists.newArrayList();    try {        CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), new RetryOneTime(1));        closeables.add(client);        client.start();        ServiceDiscovery<String> discovery = ServiceDiscoveryBuilder.builder(String.class).basePath("/discovery").client(client).build();        closeables.add(discovery);        discovery.start();        ExecuteCalledWatchingExecutorService exec = new ExecuteCalledWatchingExecutorService(Executors.newSingleThreadExecutor());        Assert.assertFalse(exec.isExecuteCalled());        ServiceCache<String> cache = discovery.serviceCacheBuilder().name("test").executorService(exec).build();        closeables.add(cache);        cache.start();        final Semaphore semaphore = new Semaphore(0);        ServiceCacheListener listener = new ServiceCacheListener() {            @Override            public void cacheChanged() {                semaphore.release();            }            @Override            public void stateChanged(CuratorFramework client, ConnectionState newState) {            }        };        cache.addListener(listener);        ServiceInstance<String> instance1 = ServiceInstance.<String>builder().payload("thing").name("test").port(10064).build();        discovery.registerService(instance1);        Assert.assertTrue(semaphore.tryAcquire(10, TimeUnit.SECONDS));        Assert.assertTrue(exec.isExecuteCalled());    } finally {        Collections.reverse(closeables);        for (Closeable c : closeables) {            CloseableUtils.closeQuietly(c);        }    }}
687c36bfaa7d559f1c63ed0b1da46041439ff4566a304ff7eabd27ea52eebedf
cacheChanged
public void cacheChanged()
{    semaphore.release();}
c5923a2e05aaebfefa9b8ddd3c261e56f7816ab4af3e6da16bd6b9cdcf37e484
stateChanged
public void stateChanged(CuratorFramework client, ConnectionState newState)
{}
b66957cdeff4c787ac5d80b3fc2bd7dcaa64d1ecf9e322b9e4c8387a3720f4eb
getInstances
public List<ServiceInstance<Void>> getInstances() throws Exception
{    return instances;}
104c11f0ee3f9faff611e8c5386cdae4b2d2eec0a753b660b04698c7d99017ee
testRandom
public void testRandom() throws Exception
{    final int QTY = 10;    final int ITERATIONS = 1000;    TestInstanceProvider instanceProvider = new TestInstanceProvider(QTY, 0);    ProviderStrategy<Void> strategy = new RandomStrategy<Void>();    long[] counts = new long[QTY];    for (int i = 0; i < ITERATIONS; ++i) {        ServiceInstance<Void> instance = strategy.getInstance(instanceProvider);        int id = Integer.parseInt(instance.getId());        counts[id]++;    }    SummaryStatistics statistic = new SummaryStatistics();    for (int i = 0; i < QTY; ++i) {        statistic.addValue(counts[i]);    }        Assert.assertTrue(statistic.getStandardDeviation() <= (QTY * 2), "" + statistic.getStandardDeviation());}
b8ee559cdaba469ccd2f9023e6a4be09a96e0bc28ea3320bef0e17ff632c1ae9
testRoundRobin
public void testRoundRobin() throws Exception
{    final int QTY = 10;    TestInstanceProvider instanceProvider = new TestInstanceProvider(QTY);    ProviderStrategy<Void> strategy = new RoundRobinStrategy<Void>();    for (int i = 0; i < QTY; ++i) {        ServiceInstance<Void> instance = strategy.getInstance(instanceProvider);        Assert.assertEquals(instance.getId(), Integer.toString(i));    }    for (int i = 0; i < (1234 * QTY); ++i) {        ServiceInstance<Void> instance = strategy.getInstance(instanceProvider);        Assert.assertEquals(instance.getId(), Integer.toString(i % QTY));    }}
8e0d8549a93d577ff5e63a2b14c35b732b5f7ab73cda184606184f8114f4fa9e
testSticky
public void testSticky() throws Exception
{    final int QTY = 10;    TestInstanceProvider instanceProvider = new TestInstanceProvider(QTY);    StickyStrategy<Void> strategy = new StickyStrategy<Void>(new RandomStrategy<Void>());    ServiceInstance<Void> theInstance = strategy.getInstance(instanceProvider);    int instanceNumber = strategy.getInstanceNumber();    for (int i = 0; i < 1000; ++i) {        Assert.assertEquals(strategy.getInstance(instanceProvider), theInstance);    }        instanceProvider = new TestInstanceProvider(QTY, QTY);    Assert.assertFalse(strategy.getInstance(instanceProvider).equals(theInstance));    Assert.assertFalse(instanceNumber == strategy.getInstanceNumber());    theInstance = strategy.getInstance(instanceProvider);    for (int i = 0; i < 1000; ++i) {        Assert.assertEquals(strategy.getInstance(instanceProvider), theInstance);    }}
7e65dbccc835e8352ec6e327bdf21af7f13ed2efe8f703027469deb577ff5808
testScheme
public void testScheme()
{    UriSpec spec = new UriSpec("{scheme}://foo.com");    ServiceInstanceBuilder<Void> builder = new ServiceInstanceBuilder<Void>();    builder.id("x");    builder.name("foo");    builder.port(5);    ServiceInstance<Void> instance = builder.build();    Assert.assertEquals(spec.build(instance), "http://foo.com");    builder.sslPort(5);    instance = builder.build();    Assert.assertEquals(spec.build(instance), "https://foo.com");}
a0aa51adb72b56444d26eb8421c4e22db64e665f7ba5927b8e006c90e8773d51
testFromInstance
public void testFromInstance()
{    ServiceInstanceBuilder<Void> builder = new ServiceInstanceBuilder<Void>();    builder.address("1.2.3.4");    builder.name("foo");    builder.id("bar");    builder.port(5);    builder.sslPort(6);    builder.registrationTimeUTC(789);    builder.serviceType(ServiceType.PERMANENT);    ServiceInstance<Void> instance = builder.build();    UriSpec spec = new UriSpec("{scheme}://{address}:{port}:{ssl-port}/{name}/{id}/{registration-time-utc}/{service-type}");    Map<String, Object> m = Maps.newHashMap();    m.put("scheme", "test");    Assert.assertEquals(spec.build(instance, m), "test://1.2.3.4:5:6/foo/bar/789/permanent");}
299f57d2ad2e6aa2132833492bc880e3b99b07ea6b188e5243b677a8aeef52c8
testEscapes
public void testEscapes()
{    UriSpec spec = new UriSpec("{one}two-three-{[}four{]}-five{six}");    Iterator<UriSpec.Part> iterator = spec.iterator();    checkPart(iterator.next(), "one", true);    checkPart(iterator.next(), "two-three-", false);    checkPart(iterator.next(), "[", true);    checkPart(iterator.next(), "four", false);    checkPart(iterator.next(), "]", true);    checkPart(iterator.next(), "-five", false);    checkPart(iterator.next(), "six", true);    Map<String, Object> m = Maps.newHashMap();    m.put("one", 1);    m.put("six", 6);    Assert.assertEquals(spec.build(m), "1two-three-{four}-five6");}
0e0411efe5e7868378f7f03580d84579275f5762c392b06dea78c574fd2c1d57
testBasic
public void testBasic()
{    UriSpec spec = new UriSpec("{one}{two}three-four-five{six}seven{eight}");    Iterator<UriSpec.Part> iterator = spec.iterator();    checkPart(iterator.next(), "one", true);    checkPart(iterator.next(), "two", true);    checkPart(iterator.next(), "three-four-five", false);    checkPart(iterator.next(), "six", true);    checkPart(iterator.next(), "seven", false);    checkPart(iterator.next(), "eight", true);}
a7d5db0fe5b1ad103ab2d7e7cc9effdb24e5645182173035ce42c7937d592f34
checkPart
private void checkPart(UriSpec.Part p, String value, boolean isVariable)
{    Assert.assertEquals(p.getValue(), value);    Assert.assertEquals(p.isVariable(), isVariable);}
fa93656261e957dcb1e2f59ee306e147b26f18e625f6a65d7f6dfef867097538
getProviderStrategy
public ProviderStrategy<T> getProviderStrategy()
{    return providerStrategy;}
98f45ba0715ecbe6fe5fa127a5ede72ce162d68cc9d930586640f1e54e4cc8d9
getInstanceRefreshMs
public int getInstanceRefreshMs()
{    return instanceRefreshMs;}
8a47f7f8fc16dfd775211e06ff47ce3cc73f12c349f27f857db7fc6d022c3f67
getServiceDiscovery
public ServiceDiscovery<T> getServiceDiscovery()
{    return serviceDiscovery;}
895a9807351df4f85c817e299810a4ffc58427e05d3a7b9c8235c00ebd320ee8
marshallJson
public void marshallJson(ObjectNode node, String fieldName, T payload) throws Exception
{    if (payload == null) {                payload = (T) payloadType.getRawType().newInstance();    }    node.putPOJO(fieldName, payload);}
3b2ab881b8d0640780e2277e6670c28b98cedefb9c6c45ded2ccc28a02622132
unMarshallJson
public T unMarshallJson(JsonNode node) throws Exception
{    T payload;    ObjectMapper mapper = new ObjectMapper();        payload = (T) mapper.readValue(node.toString(), payloadType.getRawType());    return payload;}
ae071f081259499ba35d4d227f258b18827223d5a1c6019783c1fa2ad9b945c2
getContext
public DiscoveryContext<T> getContext(Class<?> type)
{    return this;}
08fccae21ac5e39f704e0da1296993375b94ea16e378d60e8dfb5748d02a11cf
getProviderStrategy
public ProviderStrategy<Integer> getProviderStrategy()
{    return providerStrategy;}
98f45ba0715ecbe6fe5fa127a5ede72ce162d68cc9d930586640f1e54e4cc8d9
getInstanceRefreshMs
public int getInstanceRefreshMs()
{    return instanceRefreshMs;}
c41d72cd44b1a9733e0c3568d9a3fd1d9014605f91fba2ebb9699a9dfff14bbd
getServiceDiscovery
public ServiceDiscovery<Integer> getServiceDiscovery()
{    return serviceDiscovery;}
067ead7cf6be4ccfee154f54bcf6fc5ee4c310f237eec6c570e688d094e8175e
marshallJson
public void marshallJson(ObjectNode node, String fieldName, Integer payload) throws Exception
{    if (payload != null) {        node.put(fieldName, payload.toString());    }}
f40012b87cd6d39c72aa6f515327ff1bdcef5a0bdc8fa98798f1b6509e9cec59
unMarshallJson
public Integer unMarshallJson(JsonNode node) throws Exception
{    if (node != null) {        return Integer.parseInt(node.asText());    }    return null;}
a389f72edd06e8d8b9e506d3db38dc0b2bd75c60ae6845becd89beca3045d0fa
getContext
public DiscoveryContext<Integer> getContext(Class<?> type)
{    return this;}
764b192412a25828143969476b6cf311231b29d1003f06986a3130889bd4aebb
getProviderStrategy
public ProviderStrategy<String> getProviderStrategy()
{    return providerStrategy;}
98f45ba0715ecbe6fe5fa127a5ede72ce162d68cc9d930586640f1e54e4cc8d9
getInstanceRefreshMs
public int getInstanceRefreshMs()
{    return instanceRefreshMs;}
5c6466c40c914f5bdc215ddabffd3363488f1d5572379a8539f989893a24cbc2
getServiceDiscovery
public ServiceDiscovery<String> getServiceDiscovery()
{    return serviceDiscovery;}
ba74121cd06307eb0ad44eaa0d44185174695310db89166d4bc86008ed1e3375
marshallJson
public void marshallJson(ObjectNode node, String fieldName, String payload) throws Exception
{    if (payload != null) {        node.put(fieldName, payload);    }}
411b525aba37aee0215ed18b410cf8a12e5c1fcf241ef7f963b147f2b4b85bbb
unMarshallJson
public String unMarshallJson(JsonNode node) throws Exception
{    return (node != null) ? node.asText() : null;}
93b71f0ec0f9b1475fc028c853241f89034844c64556c21552ba1a58cce03fd9
getContext
public DiscoveryContext<String> getContext(Class<?> type)
{    return this;}
43d62cd70cfa69fd33363837cb57cb3dc37c54ef5b90d1f46c5abde892194607
readInstance
 static ServiceInstance<T> readInstance(JsonNode node, DiscoveryContext<T> context) throws Exception
{    ServiceInstanceBuilder<T> builder = ServiceInstance.builder();    builder.name(node.get("name").asText());    builder.id(node.get("id").asText());    builder.address(node.get("address").asText());    builder.registrationTimeUTC(node.get("registrationTimeUTC").asLong());    builder.serviceType(ServiceType.valueOf(node.get("serviceType").asText()));    builder.payload(context.unMarshallJson(node.get("payload")));    Integer port = getInteger(node, "port");    Integer sslPort = getInteger(node, "sslPort");    if (port != null) {        builder.port(port);    }    if (sslPort != null) {        builder.sslPort(sslPort);    }    return builder.build();}
f157f5afa4b5a6887f14fd32760886c5586758dd6e6520311692b6f37c02951f
writeInstance
 static ObjectNode writeInstance(ObjectMapper mapper, ServiceInstance<T> instance, DiscoveryContext<T> context)
{    ObjectNode node = mapper.createObjectNode();    node.put("name", instance.getName());    node.put("id", instance.getId());    node.put("address", instance.getAddress());    putInteger(node, "port", instance.getPort());    putInteger(node, "sslPort", instance.getSslPort());    node.put("registrationTimeUTC", instance.getRegistrationTimeUTC());    node.put("serviceType", instance.getServiceType().name());    try {        context.marshallJson(node, "payload", instance.getPayload());    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new WebApplicationException(e);    }    return node;}
e819c6c4b2ee96c3e33a3971841a67c184cb5acc4be3df08278c42f2b9738153
getInteger
private static Integer getInteger(JsonNode node, String fieldName)
{    JsonNode intNode = node.get(fieldName);    return (intNode != null) ? intNode.asInt() : null;}
c55f0c7b74c5992a29d4b3ea1fc3b4e78f498a0a830d7482e6df9484d2e64822
putInteger
private static void putInteger(ObjectNode node, String fieldName, Integer value)
{    if (value != null) {        node.put(fieldName, value);    }}
8601847fb4ccf98299f7b6e830b2341301e79931eaeb2384b56221550108c340
isReadable
public boolean isReadable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return isWriteable(type, genericType, annotations, mediaType);}
639b805b4c683337113c5542c718a000c034946fb88af3718509be6da06ad085
isWriteable
public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return ServiceInstance.class.isAssignableFrom(type) && mediaType.equals(MediaType.APPLICATION_JSON_TYPE);}
14417d3d7cf885fb48b82776c9b0de28526e1c845602227b4ac32dea9beeaf90
getSize
public long getSize(ServiceInstance<T> serviceInstance, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return -1;}
d8c0033089fd411091de94f1d877dbe88accff7009d836fc01766f8b9e9fdebf
readFrom
public ServiceInstance<T> readFrom(Class<ServiceInstance<T>> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, String> httpHeaders, InputStream entityStream) throws IOException, WebApplicationException
{    try {        ObjectMapper mapper = new ObjectMapper();        JsonNode node = mapper.reader().readTree(entityStream);        return readInstance(node, context);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new WebApplicationException(e);    }}
f20a7e113cb6f5460ddfc233a7a2620ac764f31650d402831eb2dbd06f15ecb7
writeTo
public void writeTo(ServiceInstance<T> serviceInstance, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException
{    ObjectMapper mapper = new ObjectMapper();    ObjectNode node = writeInstance(mapper, serviceInstance, context);    mapper.writer().writeValue(entityStream, node);}
8601847fb4ccf98299f7b6e830b2341301e79931eaeb2384b56221550108c340
isReadable
public boolean isReadable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return isWriteable(type, genericType, annotations, mediaType);}
639b805b4c683337113c5542c718a000c034946fb88af3718509be6da06ad085
isWriteable
public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return ServiceInstances.class.isAssignableFrom(type) && mediaType.equals(MediaType.APPLICATION_JSON_TYPE);}
b19223685bb674c0ae07aacb336de8852999ca51c9e1b39df8f9a7b6c431831c
getSize
public long getSize(ServiceInstances<T> serviceInstances, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return -1;}
e083a3f4b485317b1c7e681a3f54e4507ef4f5380b7f637d0989ab1937377bc1
readFrom
public ServiceInstances<T> readFrom(Class<ServiceInstances<T>> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, String> httpHeaders, InputStream entityStream) throws IOException, WebApplicationException
{    try {        List<ServiceInstance<T>> instances = Lists.newArrayList();        ObjectMapper mapper = new ObjectMapper();        JsonNode tree = mapper.reader().readTree(entityStream);        for (int i = 0; i < tree.size(); ++i) {            JsonNode node = tree.get(i);            ServiceInstance<T> instance = JsonServiceInstanceMarshaller.readInstance(node, context);            instances.add(instance);        }        return new ServiceInstances<T>(instances);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        throw new WebApplicationException(e);    }}
d844f1a003a17fba201063dec57c277495e7276ded90ceab2a640b3e5c455354
writeTo
public void writeTo(ServiceInstances<T> serviceInstances, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException
{    ObjectMapper mapper = new ObjectMapper();    ArrayNode arrayNode = mapper.createArrayNode();    List<? extends ServiceInstance<T>> instanceList = serviceInstances.getServices();    for (ServiceInstance<T> instance : instanceList) {        ObjectNode node = JsonServiceInstanceMarshaller.writeInstance(mapper, instance, context);        arrayNode.add(node);    }    mapper.writer().writeValue(entityStream, arrayNode);}
8601847fb4ccf98299f7b6e830b2341301e79931eaeb2384b56221550108c340
isReadable
public boolean isReadable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return allow(type, mediaType);}
ee2580fa1ba2df63b57e0bf8fa27ce2081528f15ee90f5461240aa985a4ed3b6
readFrom
public ServiceNames readFrom(Class<ServiceNames> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, String> httpHeaders, InputStream entityStream) throws IOException, WebApplicationException
{    List<String> names = Lists.newArrayList();    ObjectMapper mapper = new ObjectMapper();    JsonNode tree = mapper.reader().readTree(entityStream);    for (int i = 0; i < tree.size(); ++i) {        JsonNode node = tree.get(i);        names.add(node.get("name").asText());    }    return new ServiceNames(names);}
639b805b4c683337113c5542c718a000c034946fb88af3718509be6da06ad085
isWriteable
public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return allow(type, mediaType);}
ad3dc04102b880f536ee44f56aafef2fc5846f045807dda3f0e42d4bd1e40e07
getSize
public long getSize(ServiceNames serviceNames, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return -1;}
19f152ac2b1dffb3037f8c6e520854f3e2fcef9907fac1e0906362da938145fb
writeTo
public void writeTo(ServiceNames serviceNames, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream) throws IOException, WebApplicationException
{    ObjectMapper mapper = new ObjectMapper();    ArrayNode arrayNode = mapper.createArrayNode();    for (String name : serviceNames.getNames()) {        ObjectNode node = mapper.createObjectNode();        node.put("name", name);        arrayNode.add(node);    }    mapper.writer().writeValue(entityStream, arrayNode);}
d24e3bbafa3a378601ce2b3a293ec3fad76001ff17c43a4dc5f27077be5eade3
allow
private static boolean allow(Class<?> type, MediaType mediaType)
{    return ServiceNames.class.isAssignableFrom(type) && mediaType.equals(MediaType.APPLICATION_JSON_TYPE);}
21b4a1b05072412706a7d26b302e41e97c5c65b66f353364617764c1ba29c3c2
getServices
public List<ServiceInstance<T>> getServices()
{    return ImmutableList.copyOf(services);}
62f66a619ffe2e47ab088b93bf6c76d970a616a9942963db35be2496b64b2f25
getNames
public List<String> getNames()
{    return ImmutableList.copyOf(names);}
eb4d834fa1b279ae59e1763c58900f3df1e9f5732e77e4bd24bd7d394968bd34
putService
public Response putService(ServiceInstance<T> instance, @PathParam("name") String name, @PathParam("id") String id)
{    if (!instance.getId().equals(id) || !instance.getName().equals(name)) {        log.info("Request where path id and/or name doesn't match entity");        return Response.status(Response.Status.BAD_REQUEST).build();    }    if (instance.getServiceType().isDynamic()) {        log.info("Service type cannot be dynamic");        return Response.status(Response.Status.BAD_REQUEST).build();    }    try {        context.getServiceDiscovery().registerService(instance);    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        log.error("Trying to register service", e);        return Response.serverError().build();    }    return Response.status(Response.Status.CREATED).build();}
6366fe6819ad3208743b2b8117e55e213d87ded670a4c640a45c46c4231f88ea
removeService
public Response removeService(@PathParam("name") String name, @PathParam("id") String id)
{    try {        ServiceInstance<T> instance = context.getServiceDiscovery().queryForInstance(name, id);        if (instance != null) {                        context.getServiceDiscovery().unregisterService(instance);        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        log.error("Trying to delete service", e);        return Response.serverError().build();    }    return Response.ok().build();}
1be1ea3ccde1cfd9caf39c6152960697b348c1e8b220af15cc05a4130f466d5d
getDeprecated
public Response getDeprecated(@PathParam("name") String name, @PathParam("id") String id)
{    return internalGet(name, id, true);}
3de90cb86783152f423363deb7809efc681a01e6496137c1b2a787f284421e90
get
public Response get(@PathParam("name") String name, @PathParam("id") String id)
{    return internalGet(name, id, false);}
3253e197d59ade46c3760f34d59ba61efd6b8703f8e03a92aadce9bc25efe7b4
getAllNames
public Response getAllNames()
{    try {        List<String> instances = Lists.newArrayList(context.getServiceDiscovery().queryForNames());        Collections.sort(instances);        return Response.ok(new ServiceNames(instances)).build();    } catch (Exception e) {        log.error("Trying to get service names", e);        return Response.serverError().build();    }}
99424408522d60d22dc6b6ad6b0e6cf04fb3b5e8ef9cda2ffed940aa37d81f51
getAll
public Response getAll(@PathParam("name") String name)
{    try {        Collection<ServiceInstance<T>> instances = context.getServiceDiscovery().queryForInstances(name);        return Response.ok(new ServiceInstances<T>(instances)).build();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        log.error(String.format("Trying to get instances from service (%s)", name), e);        return Response.serverError().build();    }}
756b0bdb8fa4dc9ee3cb47f7491416562d1393bad186c1875955833ccf8e8120
getAny
public Response getAny(@PathParam("name") String name)
{    try {        final List<ServiceInstance<T>> instances = Lists.newArrayList(context.getServiceDiscovery().queryForInstances(name));        ServiceInstance<?> randomInstance = context.getProviderStrategy().getInstance(new InstanceProvider<T>() {            @Override            public List<ServiceInstance<T>> getInstances() throws Exception {                return instances;            }        });        if (randomInstance == null) {            return Response.status(Response.Status.NOT_FOUND).build();        }        return Response.ok(randomInstance).build();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        log.error(String.format("Trying to get any instance from service (%s)", name), e);        return Response.serverError().build();    }}
d03b954d1a484c07551c598b65e9544d0a76ba99f03b8c1e54645e022c669257
getInstances
public List<ServiceInstance<T>> getInstances() throws Exception
{    return instances;}
f69456c9ade535d7dfbcd032a2ec8b4f942a1ecc57e5dbf242f6321877925f52
internalGet
private Response internalGet(String name, String id, boolean addDeprecationHeader)
{    try {        ServiceInstance<T> instance = context.getServiceDiscovery().queryForInstance(name, id);        if (instance == null) {            return Response.status(Response.Status.NOT_FOUND).build();        }        Response.ResponseBuilder builder = Response.ok(instance);        if (addDeprecationHeader) {            builder = builder.header("Warning", "This API has been deprecated. Please see the updated spec for the replacement API.");        }        return builder.build();    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        log.error(String.format("Trying to get instance (%s) from service (%s)", id, name), e);        return Response.serverError().build();    }}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    Preconditions.checkArgument(!service.isShutdown(), "already started");    service.scheduleWithFixedDelay(new Runnable() {        @Override        public void run() {            doWork();        }    }, instanceRefreshMs, instanceRefreshMs, TimeUnit.MILLISECONDS);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    doWork();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    Preconditions.checkArgument(!service.isShutdown(), "not started");    service.shutdownNow();}
0c2c9b2d21d37ec98de145f3465d8b991facb850a3031a5f0f27575bc1fadc9d
doWork
private void doWork()
{    try {        for (String name : discovery.queryForNames()) {            checkService(name);        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        log.error("GC for service names", e);    }}
5b609804ccbd630ae4452ddd857bd29fe031e186799957b9d8ece9d652332b9f
checkService
private void checkService(String name)
{    try {        Collection<ServiceInstance<Object>> instances = discovery.queryForInstances(name);        for (ServiceInstance<Object> instance : instances) {            if (instance.getServiceType() == ServiceType.STATIC) {                if ((System.currentTimeMillis() - instance.getRegistrationTimeUTC()) > instanceRefreshMs) {                    discovery.unregisterService(instance);                }            }        }    } catch (Exception e) {        ThreadUtils.checkInterrupted(e);        log.error(String.format("GC for service: %s", name), e);    }}
706203ef14181d53971fddf5ab6603fcf31442cdccb19cc5e237bca9faee9d63
getDescription
public String getDescription()
{    return description;}
1a211ebf68b221c2c3c67d58559d636c48c482bac17440249777eb28f553a9ad
setDescription
public void setDescription(String description)
{    this.description = description;}
4a94eb368c848a5e986ea58f9f0c91b05d162c859f634f2c7ba88175f241d92c
setData
public void setData(Map<String, String> data)
{    this.data = data;}
2b120fdf07a6e297e516715bf6bbc459897109dc91b84a372b446fd8bb20547a
getData
public Map<String, String> getData()
{    return data;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    final int prime = 31;    int result = 1;    result = prime * result + ((data == null) ? 0 : data.hashCode());    result = prime * result + ((description == null) ? 0 : description.hashCode());    return result;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj)        return true;    if (obj == null)        return false;    if (getClass() != obj.getClass())        return false;    ServiceDetails other = (ServiceDetails) obj;    if (data == null) {        if (other.data != null)            return false;    } else if (!data.equals(other.data))        return false;    if (description == null) {        if (other.description != null)            return false;    } else if (!description.equals(other.description))        return false;    return true;}
27681e68ec2a1eb903f955680ebe003ceb3707295c8aad884b692d378c6e37cf
setup
public void setup() throws Exception
{    context = new MapDiscoveryContext(new MockServiceDiscovery<Map<String, String>>(), new RandomStrategy<Map<String, String>>(), 1000);    serviceNamesMarshaller = new JsonServiceNamesMarshaller();    serviceInstanceMarshaller = new JsonServiceInstanceMarshaller<Map<String, String>>(context);    serviceInstancesMarshaller = new JsonServiceInstancesMarshaller<Map<String, String>>(context);    Application application = new DefaultResourceConfig() {        @Override        public Set<Class<?>> getClasses() {            Set<Class<?>> classes = Sets.newHashSet();            classes.add(MapDiscoveryResource.class);            return classes;        }        @Override        public Set<Object> getSingletons() {            Set<Object> singletons = Sets.newHashSet();            singletons.add(context);            singletons.add(serviceNamesMarshaller);            singletons.add(serviceInstanceMarshaller);            singletons.add(serviceInstancesMarshaller);            return singletons;        }    };    ServletContainer container = new ServletContainer(application);    port = InstanceSpec.getRandomPort();    server = new Server(port);    Context root = new Context(server, "/", Context.SESSIONS);    root.addServlet(new ServletHolder(container), "/*");    server.start();}
74479314c585abfed62b3674589541de7555ab38ac6a1db15f9026ef354b7e76
getClasses
public Set<Class<?>> getClasses()
{    Set<Class<?>> classes = Sets.newHashSet();    classes.add(MapDiscoveryResource.class);    return classes;}
2d3768321600701765313e15ec8a47672e330e377396867f1fcbbecd665b5939
getSingletons
public Set<Object> getSingletons()
{    Set<Object> singletons = Sets.newHashSet();    singletons.add(context);    singletons.add(serviceNamesMarshaller);    singletons.add(serviceInstanceMarshaller);    singletons.add(serviceInstancesMarshaller);    return singletons;}
7c529460b940c419ef707bd1846a5575ea1bfc48c129127836c31f0184c1d8fb
teardown
public void teardown() throws Exception
{    server.stop();    server.join();}
98626f0f6a2d21158e93b61ce15dc5d931c6a6aa0d49da43923faa8fef419b66
testRegisterService
public void testRegisterService() throws Exception
{    Map<String, String> payload = Maps.newHashMap();    payload.put("one", "1");    payload.put("two", "2");    payload.put("three", "3");    ServiceInstance<Map<String, String>> service = ServiceInstance.<Map<String, String>>builder().name("test").payload(payload).serviceType(ServiceType.STATIC).build();    ClientConfig config = new DefaultClientConfig() {        @Override        public Set<Object> getSingletons() {            Set<Object> singletons = Sets.newHashSet();            singletons.add(context);            singletons.add(serviceNamesMarshaller);            singletons.add(serviceInstanceMarshaller);            singletons.add(serviceInstancesMarshaller);            return singletons;        }    };    Client client = Client.create(config);    WebResource resource = client.resource("http://localhost:" + port);    resource.path("/v1/service/test/" + service.getId()).type(MediaType.APPLICATION_JSON_TYPE).put(service);    ServiceNames names = resource.path("/v1/service").get(ServiceNames.class);    Assert.assertEquals(names.getNames(), Lists.newArrayList("test"));    GenericType<ServiceInstances<Map<String, String>>> type = new GenericType<ServiceInstances<Map<String, String>>>() {    };    ServiceInstances<Map<String, String>> instances = resource.path("/v1/service/test").get(type);    Assert.assertEquals(instances.getServices().size(), 1);    Assert.assertEquals(instances.getServices().get(0), service);    Assert.assertEquals(instances.getServices().get(0).getPayload(), payload);        GenericType<ServiceInstance<Map<String, String>>> singleInstanceType = new GenericType<ServiceInstance<Map<String, String>>>() {    };    ServiceInstance<Map<String, String>> instance = resource.path("/v1/service/test/" + service.getId()).get(singleInstanceType);    Assert.assertEquals(instance, service);}
2d3768321600701765313e15ec8a47672e330e377396867f1fcbbecd665b5939
getSingletons
public Set<Object> getSingletons()
{    Set<Object> singletons = Sets.newHashSet();    singletons.add(context);    singletons.add(serviceNamesMarshaller);    singletons.add(serviceInstanceMarshaller);    singletons.add(serviceInstancesMarshaller);    return singletons;}
27681e68ec2a1eb903f955680ebe003ceb3707295c8aad884b692d378c6e37cf
setup
public void setup() throws Exception
{    context = new ServiceDetailsDiscoveryContext(new MockServiceDiscovery<ServiceDetails>(), new RandomStrategy<ServiceDetails>(), 1000);    serviceNamesMarshaller = new JsonServiceNamesMarshaller();    serviceInstanceMarshaller = new JsonServiceInstanceMarshaller<ServiceDetails>(context);    serviceInstancesMarshaller = new JsonServiceInstancesMarshaller<ServiceDetails>(context);    Application application = new DefaultResourceConfig() {        @Override        public Set<Class<?>> getClasses() {            Set<Class<?>> classes = Sets.newHashSet();            classes.add(ServiceDetailsDiscoveryResource.class);            return classes;        }        @Override        public Set<Object> getSingletons() {            Set<Object> singletons = Sets.newHashSet();            singletons.add(context);            singletons.add(serviceNamesMarshaller);            singletons.add(serviceInstanceMarshaller);            singletons.add(serviceInstancesMarshaller);            return singletons;        }    };    ServletContainer container = new ServletContainer(application);    port = InstanceSpec.getRandomPort();    server = new Server(port);    Context root = new Context(server, "/", Context.SESSIONS);    root.addServlet(new ServletHolder(container), "/*");    server.start();}
74479314c585abfed62b3674589541de7555ab38ac6a1db15f9026ef354b7e76
getClasses
public Set<Class<?>> getClasses()
{    Set<Class<?>> classes = Sets.newHashSet();    classes.add(ServiceDetailsDiscoveryResource.class);    return classes;}
2d3768321600701765313e15ec8a47672e330e377396867f1fcbbecd665b5939
getSingletons
public Set<Object> getSingletons()
{    Set<Object> singletons = Sets.newHashSet();    singletons.add(context);    singletons.add(serviceNamesMarshaller);    singletons.add(serviceInstanceMarshaller);    singletons.add(serviceInstancesMarshaller);    return singletons;}
7c529460b940c419ef707bd1846a5575ea1bfc48c129127836c31f0184c1d8fb
teardown
public void teardown() throws Exception
{    server.stop();    server.join();}
98626f0f6a2d21158e93b61ce15dc5d931c6a6aa0d49da43923faa8fef419b66
testRegisterService
public void testRegisterService() throws Exception
{    ServiceDetails payload = new ServiceDetails();    payload.setDescription("Example description for test");    payload.getData().put("one", "1");    payload.getData().put("two", "2");    payload.getData().put("three", "3");    ServiceInstance<ServiceDetails> service = ServiceInstance.<ServiceDetails>builder().name("test").payload(payload).serviceType(ServiceType.STATIC).build();    ClientConfig config = new DefaultClientConfig() {        @Override        public Set<Object> getSingletons() {            Set<Object> singletons = Sets.newHashSet();            singletons.add(context);            singletons.add(serviceNamesMarshaller);            singletons.add(serviceInstanceMarshaller);            singletons.add(serviceInstancesMarshaller);            return singletons;        }    };    Client client = Client.create(config);    WebResource resource = client.resource("http://localhost:" + port);    resource.path("/v1/service/test/" + service.getId()).type(MediaType.APPLICATION_JSON_TYPE).put(service);    ServiceNames names = resource.path("/v1/service").get(ServiceNames.class);    Assert.assertEquals(names.getNames(), Lists.newArrayList("test"));    GenericType<ServiceInstances<ServiceDetails>> type = new GenericType<ServiceInstances<ServiceDetails>>() {    };    ServiceInstances<ServiceDetails> instances = resource.path("/v1/service/test").get(type);    Assert.assertEquals(instances.getServices().size(), 1);    Assert.assertEquals(instances.getServices().get(0), service);    Assert.assertEquals(instances.getServices().get(0).getPayload(), payload);        GenericType<ServiceInstance<ServiceDetails>> singleInstanceType = new GenericType<ServiceInstance<ServiceDetails>>() {    };    ServiceInstance<ServiceDetails> instance = resource.path("/v1/service/test/" + service.getId()).get(singleInstanceType);    Assert.assertEquals(instance, service);}
2d3768321600701765313e15ec8a47672e330e377396867f1fcbbecd665b5939
getSingletons
public Set<Object> getSingletons()
{    Set<Object> singletons = Sets.newHashSet();    singletons.add(context);    singletons.add(serviceNamesMarshaller);    singletons.add(serviceInstanceMarshaller);    singletons.add(serviceInstancesMarshaller);    return singletons;}
27681e68ec2a1eb903f955680ebe003ceb3707295c8aad884b692d378c6e37cf
setup
public void setup() throws Exception
{    context = new StringDiscoveryContext(new MockServiceDiscovery<String>(), new RandomStrategy<String>(), 1000);    serviceNamesMarshaller = new JsonServiceNamesMarshaller();    serviceInstanceMarshaller = new JsonServiceInstanceMarshaller<String>(context);    serviceInstancesMarshaller = new JsonServiceInstancesMarshaller<String>(context);    Application application = new DefaultResourceConfig() {        @Override        public Set<Class<?>> getClasses() {            Set<Class<?>> classes = Sets.newHashSet();            classes.add(StringDiscoveryResource.class);            return classes;        }        @Override        public Set<Object> getSingletons() {            Set<Object> singletons = Sets.newHashSet();            singletons.add(context);            singletons.add(serviceNamesMarshaller);            singletons.add(serviceInstanceMarshaller);            singletons.add(serviceInstancesMarshaller);            return singletons;        }    };    ServletContainer container = new ServletContainer(application);    port = InstanceSpec.getRandomPort();    server = new Server(port);    Context root = new Context(server, "/", Context.SESSIONS);    root.addServlet(new ServletHolder(container), "/*");    server.start();}
74479314c585abfed62b3674589541de7555ab38ac6a1db15f9026ef354b7e76
getClasses
public Set<Class<?>> getClasses()
{    Set<Class<?>> classes = Sets.newHashSet();    classes.add(StringDiscoveryResource.class);    return classes;}
2d3768321600701765313e15ec8a47672e330e377396867f1fcbbecd665b5939
getSingletons
public Set<Object> getSingletons()
{    Set<Object> singletons = Sets.newHashSet();    singletons.add(context);    singletons.add(serviceNamesMarshaller);    singletons.add(serviceInstanceMarshaller);    singletons.add(serviceInstancesMarshaller);    return singletons;}
7c529460b940c419ef707bd1846a5575ea1bfc48c129127836c31f0184c1d8fb
teardown
public void teardown() throws Exception
{    server.stop();    server.join();}
98626f0f6a2d21158e93b61ce15dc5d931c6a6aa0d49da43923faa8fef419b66
testRegisterService
public void testRegisterService() throws Exception
{    ServiceInstance<String> service = ServiceInstance.<String>builder().name("test").payload("From Test").serviceType(ServiceType.STATIC).build();    ClientConfig config = new DefaultClientConfig() {        @Override        public Set<Object> getSingletons() {            Set<Object> singletons = Sets.newHashSet();            singletons.add(context);            singletons.add(serviceNamesMarshaller);            singletons.add(serviceInstanceMarshaller);            singletons.add(serviceInstancesMarshaller);            return singletons;        }    };    Client client = Client.create(config);    WebResource resource = client.resource("http://localhost:" + port);    resource.path("/v1/service/test/" + service.getId()).type(MediaType.APPLICATION_JSON_TYPE).put(service);    ServiceNames names = resource.path("/v1/service").get(ServiceNames.class);    Assert.assertEquals(names.getNames(), Lists.newArrayList("test"));    GenericType<ServiceInstances<String>> type = new GenericType<ServiceInstances<String>>() {    };    ServiceInstances<String> instances = resource.path("/v1/service/test").get(type);    Assert.assertEquals(instances.getServices().size(), 1);    Assert.assertEquals(instances.getServices().get(0), service);        GenericType<ServiceInstance<String>> singleInstanceType = new GenericType<ServiceInstance<String>>() {    };    ServiceInstance<String> instance = resource.path("/v1/service/test/" + service.getId()).get(singleInstanceType);    Assert.assertEquals(instance, service);}
2d3768321600701765313e15ec8a47672e330e377396867f1fcbbecd665b5939
getSingletons
public Set<Object> getSingletons()
{    Set<Object> singletons = Sets.newHashSet();    singletons.add(context);    singletons.add(serviceNamesMarshaller);    singletons.add(serviceInstanceMarshaller);    singletons.add(serviceInstancesMarshaller);    return singletons;}
312d44acdc2c293d4418a1deb6c88daf88a4863ba8ea42326a50e816bc704938
testEmptyServiceNames
public void testEmptyServiceNames()
{    ClientConfig config = new DefaultClientConfig() {        @Override        public Set<Object> getSingletons() {            Set<Object> singletons = Sets.newHashSet();            singletons.add(context);            singletons.add(serviceNamesMarshaller);            singletons.add(serviceInstanceMarshaller);            singletons.add(serviceInstancesMarshaller);            return singletons;        }    };    Client client = Client.create(config);    WebResource resource = client.resource("http://localhost:" + port);    ServiceNames names = resource.path("/v1/service").get(ServiceNames.class);    Assert.assertEquals(names.getNames(), Lists.<String>newArrayList());}
2d3768321600701765313e15ec8a47672e330e377396867f1fcbbecd665b5939
getSingletons
public Set<Object> getSingletons()
{    Set<Object> singletons = Sets.newHashSet();    singletons.add(context);    singletons.add(serviceNamesMarshaller);    singletons.add(serviceInstanceMarshaller);    singletons.add(serviceInstancesMarshaller);    return singletons;}
74479314c585abfed62b3674589541de7555ab38ac6a1db15f9026ef354b7e76
getClasses
public Set<Class<?>> getClasses()
{    Set<Class<?>> classes = Sets.newHashSet();    classes.add(StringDiscoveryResource.class);    return classes;}
2d3768321600701765313e15ec8a47672e330e377396867f1fcbbecd665b5939
getSingletons
public Set<Object> getSingletons()
{    Set<Object> singletons = Sets.newHashSet();    singletons.add(singletonsRef.get().contextSingleton);    singletons.add(singletonsRef.get().serviceNamesMarshallerSingleton);    singletons.add(singletonsRef.get().serviceInstanceMarshallerSingleton);    singletons.add(singletonsRef.get().serviceInstancesMarshallerSingleton);    return singletons;}
5b9981916a4b68e487f024f806ed989990fc5be3404b16cfc0d809e820ff83eb
getContextFromProvider
private static DiscoveryContext<String> getContextFromProvider(Providers providers)
{    ContextResolver<DiscoveryContext> contextResolver = providers.getContextResolver(DiscoveryContext.class, MediaType.WILDCARD_TYPE);        return contextResolver.getContext(DiscoveryContext.class);}
27681e68ec2a1eb903f955680ebe003ceb3707295c8aad884b692d378c6e37cf
setup
public void setup() throws Exception
{    RestEasyApplication.singletonsRef.set(new RestEasySingletons());    ResteasyProviderFactory.setInstance(new ResteasyProviderFactory());    HttpServletDispatcher dispatcher = new HttpServletDispatcher();    port = InstanceSpec.getRandomPort();    server = new Server(port);    Context root = new Context(server, "/", Context.SESSIONS);    root.getInitParams().put("javax.ws.rs.Application", RestEasyApplication.class.getName());    root.addServlet(new ServletHolder(dispatcher), "/*");    root.addEventListener(new ResteasyBootstrap());    server.start();}
7c529460b940c419ef707bd1846a5575ea1bfc48c129127836c31f0184c1d8fb
teardown
public void teardown() throws Exception
{    server.stop();    server.join();}
98626f0f6a2d21158e93b61ce15dc5d931c6a6aa0d49da43923faa8fef419b66
testRegisterService
public void testRegisterService() throws Exception
{    RestEasySingletons restEasySingletons = RestEasyApplication.singletonsRef.get();    ServiceInstance<String> service = ServiceInstance.<String>builder().name("test").payload("From Test").serviceType(ServiceType.STATIC).build();    ByteArrayOutputStream out = new ByteArrayOutputStream();    restEasySingletons.serviceInstanceMarshallerSingleton.writeTo(service, null, null, null, null, null, out);    getJson("http://localhost:" + port + "/v1/service/test/" + service.getId(), new String(out.toByteArray()));    String json = getJson("http://localhost:" + port + "/v1/service", null);    ServiceNames names = restEasySingletons.serviceNamesMarshallerSingleton.readFrom(ServiceNames.class, null, null, MediaType.APPLICATION_JSON_TYPE, null, new ByteArrayInputStream(json.getBytes()));    Assert.assertEquals(names.getNames(), Lists.newArrayList("test"));    json = getJson("http://localhost:" + port + "/v1/service/test", null);    ServiceInstances<String> instances = restEasySingletons.serviceInstancesMarshallerSingleton.readFrom(null, null, null, null, null, new ByteArrayInputStream(json.getBytes()));    Assert.assertEquals(instances.getServices().size(), 1);    Assert.assertEquals(instances.getServices().get(0), service);        json = getJson("http://localhost:" + port + "/v1/service/test/" + service.getId(), null);    ServiceInstance<String> instance = restEasySingletons.serviceInstanceMarshallerSingleton.readFrom(null, null, null, null, null, new ByteArrayInputStream(json.getBytes()));    Assert.assertEquals(instance, service);}
e918cf8e4083319f405c7f66564e162784b2c4233056b5d68d876a053cde2f43
testEmptyServiceNames
public void testEmptyServiceNames() throws Exception
{    String json = getJson("http://localhost:" + port + "/v1/service", null);    ServiceNames names = RestEasyApplication.singletonsRef.get().serviceNamesMarshallerSingleton.readFrom(ServiceNames.class, null, null, MediaType.APPLICATION_JSON_TYPE, null, new ByteArrayInputStream(json.getBytes()));    Assert.assertEquals(names.getNames(), Lists.<String>newArrayList());}
144cff0171ed1095cd35178283f5eac849dd832c4e591f91a854cdd78aa33d80
getJson
private String getJson(String urlStr, String body) throws IOException
{    URL url = new URL(urlStr);    URLConnection urlConnection = url.openConnection();    urlConnection.addRequestProperty("Accept", "application/json");    if (body != null) {        ((HttpURLConnection) urlConnection).setRequestMethod("PUT");        urlConnection.addRequestProperty("Content-Type", "application/json");        urlConnection.addRequestProperty("Content-Length", Integer.toString(body.length()));        urlConnection.setDoOutput(true);        OutputStream out = urlConnection.getOutputStream();        ByteSource.wrap(body.getBytes()).copyTo(out);    }    BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));    try {        return CharStreams.toString(in);    } finally {        in.close();    }}
e77a65a09e1d850e5123db3e6d8dc957b7844b7baa4d6a024712b197703b0857
get
public Collection<ServiceInstance<T>> get()
{    return Lists.newArrayList();}
90ba0dddc593bd95e2a0c0c039c523b81bfb91f87814ebcb222c3914ca772ead
start
public void start() throws Exception
{}
66942a8e3fd15aad2a715cd2a7a8c5b635a65acacf3fdfecd49116102ce5ee93
registerService
public void registerService(ServiceInstance<T> service) throws Exception
{    services.put(service.getName(), service);}
cadc4a9593f13a46b5adb06c7609bd86855337568741f9d3bd8170829b81ebae
unregisterService
public void unregisterService(ServiceInstance<T> service) throws Exception
{    services.remove(service.getName(), service);}
27afda76ace88589c7126a13aa3b9184f6af7e10040be39d9b1c62d97df90d4b
updateService
public void updateService(ServiceInstance<T> service) throws Exception
{    services.put(service.getName(), service);}
0caba5dd24a8035d87c37c9a501bfa57f2b0e5c74a956a9a5d831c8d7183b239
serviceCacheBuilder
public ServiceCacheBuilder<T> serviceCacheBuilder()
{    throw new UnsupportedOperationException();}
65ee31b653af58958daf3b3cfe65f0047395aec73b443190873e73fa8c71fc48
queryForNames
public Collection<String> queryForNames() throws Exception
{    return services.keys();}
578666e0ec617b379b224635648909a60ed851fa3b405631adebd8924a6473f5
queryForInstances
public Collection<ServiceInstance<T>> queryForInstances(String name) throws Exception
{    return services.get(name);}
e276d0f482bb370c4de8117a7df1d69dd7ae011faab6400e468199fd3d17355f
queryForInstance
public ServiceInstance<T> queryForInstance(String name, String id) throws Exception
{    Collection<ServiceInstance<T>> instances = services.get(name);    for (ServiceInstance<T> instance : instances) {        if (instance.getId().equals(id)) {            return instance;        }    }    return null;}
1bece2951f9e1317b9eb58d06f588c94616d2b54d84dcbc08a56a2e17d208ba4
serviceProviderBuilder
public ServiceProviderBuilder<T> serviceProviderBuilder()
{    throw new UnsupportedOperationException();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{}
