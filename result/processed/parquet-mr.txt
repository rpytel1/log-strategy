3b99c3041e205317fff658fa0420239f7b322545979ea55e785d34c574f3826b
getList
public GroupType getList()
{    return list;}
063ab9517bae4b3488c29776e9edf8704f33ce49d22afea07e76baa4042f4781
getRepeated
public GroupType getRepeated()
{    return repeated;}
affa174f25cc42d8ff4101e2b6d980aacf879575b286911e7a5637c05a1b3b2e
getElement
public Type getElement()
{    return element;}
214699ec7e1310229152d13b0ad332f1baef68e2bde8761b4a4a8ec816be33a8
fromArrow
public SchemaMapping fromArrow(Schema arrowSchema)
{    List<Field> fields = arrowSchema.getFields();    List<TypeMapping> parquetFields = fromArrow(fields);    MessageType parquetType = addToBuilder(parquetFields, Types.buildMessage()).named("root");    return new SchemaMapping(arrowSchema, parquetType, parquetFields);}
f05ce1e42a5335b75a7c9c9e653a8b219fb8e8eb3d72467f35379f824f518707
addToBuilder
private GroupBuilder<T> addToBuilder(List<TypeMapping> parquetFields, GroupBuilder<T> builder)
{    for (TypeMapping type : parquetFields) {        builder = builder.addField(type.getParquetType());    }    return builder;}
d44b47e7c8548a5816494ada51f05940768de591e850a550bb77fca82dec5de6
fromArrow
private List<TypeMapping> fromArrow(List<Field> fields)
{    List<TypeMapping> result = new ArrayList<>(fields.size());    for (Field field : fields) {        result.add(fromArrow(field));    }    return result;}
8c74d2c7cf4a7e59ccc6a3917207d0655cf8bf1ed512f42e8fbbf8f638fd84e1
fromArrow
private TypeMapping fromArrow(final Field field)
{    return fromArrow(field, field.getName());}
6af9be46b5c7fea2b12180d72c63cd408d8db1f73e131ecad633b101bec4fa91
fromArrow
private TypeMapping fromArrow(final Field field, final String fieldName)
{    final List<Field> children = field.getChildren();    return field.getType().accept(new ArrowTypeVisitor<TypeMapping>() {        @Override        public TypeMapping visit(Null type) {                        return primitive(BINARY);        }        @Override        public TypeMapping visit(Struct type) {            List<TypeMapping> parquetTypes = fromArrow(children);            return new StructTypeMapping(field, addToBuilder(parquetTypes, Types.buildGroup(OPTIONAL)).named(fieldName), parquetTypes);        }        @Override        public TypeMapping visit(org.apache.arrow.vector.types.pojo.ArrowType.List type) {            return createListTypeMapping();        }        @Override        public TypeMapping visit(org.apache.arrow.vector.types.pojo.ArrowType.FixedSizeList type) {            return createListTypeMapping();        }        private ListTypeMapping createListTypeMapping() {            if (children.size() != 1) {                throw new IllegalArgumentException("list fields must have exactly one child: " + field);            }            TypeMapping parquetChild = fromArrow(children.get(0), "element");            GroupType list = Types.optionalList().element(parquetChild.getParquetType()).named(fieldName);            return new ListTypeMapping(field, new List3Levels(list), parquetChild);        }        @Override        public TypeMapping visit(Union type) {                        List<TypeMapping> parquetTypes = fromArrow(children);            return new UnionTypeMapping(field, addToBuilder(parquetTypes, Types.buildGroup(OPTIONAL)).named(fieldName), parquetTypes);        }        @Override        public TypeMapping visit(Int type) {            boolean signed = type.getIsSigned();            switch(type.getBitWidth()) {                case 8:                case 16:                case 32:                    return primitive(INT32, intType(type.getBitWidth(), signed));                case 64:                    return primitive(INT64, intType(64, signed));                default:                    throw new IllegalArgumentException("Illegal int type: " + field);            }        }        @Override        public TypeMapping visit(FloatingPoint type) {            switch(type.getPrecision()) {                case HALF:                                        return primitive(FLOAT);                case SINGLE:                    return primitive(FLOAT);                case DOUBLE:                    return primitive(DOUBLE);                default:                    throw new IllegalArgumentException("Illegal float type: " + field);            }        }        @Override        public TypeMapping visit(Utf8 type) {            return primitive(BINARY, stringType());        }        @Override        public TypeMapping visit(Binary type) {            return primitive(BINARY);        }        @Override        public TypeMapping visit(Bool type) {            return primitive(BOOLEAN);        }        /**         * See https://github.com/apache/parquet-format/blob/master/LogicalTypes.md#decimal         * @param type an arrow decimal type         * @return a mapping from the arrow decimal to the Parquet type         */        @Override        public TypeMapping visit(Decimal type) {            int precision = type.getPrecision();            int scale = type.getScale();            if (1 <= precision && precision <= 9) {                return decimal(INT32, precision, scale);            } else if (1 <= precision && precision <= 18) {                return decimal(INT64, precision, scale);            } else {                                return decimal(BINARY, precision, scale);            }        }        @Override        public TypeMapping visit(Date type) {            return primitive(INT32, dateType());        }        @Override        public TypeMapping visit(Time type) {            int bitWidth = type.getBitWidth();            TimeUnit timeUnit = type.getUnit();            if (bitWidth == 32 && timeUnit == TimeUnit.MILLISECOND) {                return primitive(INT32, timeType(false, MILLIS));            } else if (bitWidth == 64 && timeUnit == TimeUnit.MICROSECOND) {                return primitive(INT64, timeType(false, MICROS));            } else if (bitWidth == 64 && timeUnit == TimeUnit.NANOSECOND) {                return primitive(INT64, timeType(false, NANOS));            }            throw new UnsupportedOperationException("Unsupported type " + type);        }        @Override        public TypeMapping visit(Timestamp type) {            TimeUnit timeUnit = type.getUnit();            if (timeUnit == TimeUnit.MILLISECOND) {                return primitive(INT64, timestampType(isUtcNormalized(type), MILLIS));            } else if (timeUnit == TimeUnit.MICROSECOND) {                return primitive(INT64, timestampType(isUtcNormalized(type), MICROS));            } else if (timeUnit == TimeUnit.NANOSECOND) {                return primitive(INT64, timestampType(isUtcNormalized(type), NANOS));            }            throw new UnsupportedOperationException("Unsupported type " + type);        }        private boolean isUtcNormalized(Timestamp timestamp) {            String timeZone = timestamp.getTimezone();            return timeZone != null && !timeZone.isEmpty();        }        /**         * See https://github.com/apache/parquet-format/blob/master/LogicalTypes.md#interval         */        @Override        public TypeMapping visit(Interval type) {                        return primitiveFLBA(12, LogicalTypeAnnotation.IntervalLogicalTypeAnnotation.getInstance());        }        @Override        public TypeMapping visit(ArrowType.FixedSizeBinary fixedSizeBinary) {            return primitive(BINARY);        }        private TypeMapping mapping(PrimitiveType parquetType) {            return new PrimitiveTypeMapping(field, parquetType);        }        private TypeMapping decimal(PrimitiveTypeName type, int precision, int scale) {            return mapping(Types.optional(type).as(decimalType(scale, precision)).named(fieldName));        }        private TypeMapping primitive(PrimitiveTypeName type) {            return mapping(Types.optional(type).named(fieldName));        }        private TypeMapping primitive(PrimitiveTypeName type, LogicalTypeAnnotation otype) {            return mapping(Types.optional(type).as(otype).named(fieldName));        }        private TypeMapping primitiveFLBA(int length, LogicalTypeAnnotation otype) {            return mapping(Types.optional(FIXED_LEN_BYTE_ARRAY).length(length).as(otype).named(fieldName));        }    });}
ed631cc1988dac5eb298a637a5d6e56f184e9f615f63909eb0f64c015831cae5
visit
public TypeMapping visit(Null type)
{        return primitive(BINARY);}
4fc9c0c958c3bb2e6dbe36790ea8e295161165022beda092bb9fcabb5834207f
visit
public TypeMapping visit(Struct type)
{    List<TypeMapping> parquetTypes = fromArrow(children);    return new StructTypeMapping(field, addToBuilder(parquetTypes, Types.buildGroup(OPTIONAL)).named(fieldName), parquetTypes);}
c1bacd7300bca105b66fa739fd1cdb493a5e1f289cc942d2b5b4f66794d0ff75
visit
public TypeMapping visit(org.apache.arrow.vector.types.pojo.ArrowType.List type)
{    return createListTypeMapping();}
c63cd72d2b69abbd0a021f12edeb45846ee1928a32a644c2f181aed6cde949ec
visit
public TypeMapping visit(org.apache.arrow.vector.types.pojo.ArrowType.FixedSizeList type)
{    return createListTypeMapping();}
ec8202251559453cde58622a54bb6b2c1206a0b2c5bd1cfe5450bc585d9c0486
createListTypeMapping
private ListTypeMapping createListTypeMapping()
{    if (children.size() != 1) {        throw new IllegalArgumentException("list fields must have exactly one child: " + field);    }    TypeMapping parquetChild = fromArrow(children.get(0), "element");    GroupType list = Types.optionalList().element(parquetChild.getParquetType()).named(fieldName);    return new ListTypeMapping(field, new List3Levels(list), parquetChild);}
25330c2eba2ab72fe9e99b6ed37fe40b0b2b783079bd0151afb7b91a54a34802
visit
public TypeMapping visit(Union type)
{        List<TypeMapping> parquetTypes = fromArrow(children);    return new UnionTypeMapping(field, addToBuilder(parquetTypes, Types.buildGroup(OPTIONAL)).named(fieldName), parquetTypes);}
897b6b9527282c8e5c9f0bec540b722ff5ddb4571c0a518f1d9059c151fc706f
visit
public TypeMapping visit(Int type)
{    boolean signed = type.getIsSigned();    switch(type.getBitWidth()) {        case 8:        case 16:        case 32:            return primitive(INT32, intType(type.getBitWidth(), signed));        case 64:            return primitive(INT64, intType(64, signed));        default:            throw new IllegalArgumentException("Illegal int type: " + field);    }}
8fc228597f1a198349a580164b1571fab84617cf40c2872bb5bd7d14083d1571
visit
public TypeMapping visit(FloatingPoint type)
{    switch(type.getPrecision()) {        case HALF:                        return primitive(FLOAT);        case SINGLE:            return primitive(FLOAT);        case DOUBLE:            return primitive(DOUBLE);        default:            throw new IllegalArgumentException("Illegal float type: " + field);    }}
1ed7a1be6e89cee1817d80f79a36172da765483d573eef58de1eef245794ad6f
visit
public TypeMapping visit(Utf8 type)
{    return primitive(BINARY, stringType());}
76c26663912da285221cb6a4d7d017dc1721c1d3ce17d2c8ced84f5d2922e39a
visit
public TypeMapping visit(Binary type)
{    return primitive(BINARY);}
82aef2b7f97ae5647a03a3e99dc90b7798aa22a2e726e2b932a25706c4c5e771
visit
public TypeMapping visit(Bool type)
{    return primitive(BOOLEAN);}
af5563e08eca24bc20a66e6fe9db720f64385e1053e90721e0a64c8da3c642a2
visit
public TypeMapping visit(Decimal type)
{    int precision = type.getPrecision();    int scale = type.getScale();    if (1 <= precision && precision <= 9) {        return decimal(INT32, precision, scale);    } else if (1 <= precision && precision <= 18) {        return decimal(INT64, precision, scale);    } else {                return decimal(BINARY, precision, scale);    }}
086ab75c055c1fd37d84d3b04be134b6c1c3e9861e6a7ae35ecc90afde4b8655
visit
public TypeMapping visit(Date type)
{    return primitive(INT32, dateType());}
9fde4e4e71fd4ad46eaf1e7e20d4aaded97af7dec16a095c1cf1a7835472501a
visit
public TypeMapping visit(Time type)
{    int bitWidth = type.getBitWidth();    TimeUnit timeUnit = type.getUnit();    if (bitWidth == 32 && timeUnit == TimeUnit.MILLISECOND) {        return primitive(INT32, timeType(false, MILLIS));    } else if (bitWidth == 64 && timeUnit == TimeUnit.MICROSECOND) {        return primitive(INT64, timeType(false, MICROS));    } else if (bitWidth == 64 && timeUnit == TimeUnit.NANOSECOND) {        return primitive(INT64, timeType(false, NANOS));    }    throw new UnsupportedOperationException("Unsupported type " + type);}
e66e22823d6fece9cd403c860a4522a759a8566e5fe3b88b21b1436b56890a0b
visit
public TypeMapping visit(Timestamp type)
{    TimeUnit timeUnit = type.getUnit();    if (timeUnit == TimeUnit.MILLISECOND) {        return primitive(INT64, timestampType(isUtcNormalized(type), MILLIS));    } else if (timeUnit == TimeUnit.MICROSECOND) {        return primitive(INT64, timestampType(isUtcNormalized(type), MICROS));    } else if (timeUnit == TimeUnit.NANOSECOND) {        return primitive(INT64, timestampType(isUtcNormalized(type), NANOS));    }    throw new UnsupportedOperationException("Unsupported type " + type);}
5b80881baff9b85710d2c61d463b7a419d116ef3ebc906d01da265f79f304fd5
isUtcNormalized
private boolean isUtcNormalized(Timestamp timestamp)
{    String timeZone = timestamp.getTimezone();    return timeZone != null && !timeZone.isEmpty();}
842ae9ad581d4bf997cb0ceff03992f3d5c4bb64d4dac68b654be1b1fddfa204
visit
public TypeMapping visit(Interval type)
{        return primitiveFLBA(12, LogicalTypeAnnotation.IntervalLogicalTypeAnnotation.getInstance());}
a7e79396c6aeff3d022e5aa96915e2c90e94ada73766bd690e2ee646427e6824
visit
public TypeMapping visit(ArrowType.FixedSizeBinary fixedSizeBinary)
{    return primitive(BINARY);}
f4bc543553afbb9377134f5703f80cdb768b268ff47ea23f267fde4891b62904
mapping
private TypeMapping mapping(PrimitiveType parquetType)
{    return new PrimitiveTypeMapping(field, parquetType);}
fab70010356bedd08a928eba00533d95390cf77763acc4ecd6e25983d830e68a
decimal
private TypeMapping decimal(PrimitiveTypeName type, int precision, int scale)
{    return mapping(Types.optional(type).as(decimalType(scale, precision)).named(fieldName));}
fb429617d64fced3671ea64f7c450d226bc5c52b825c6732cb4fd3425f7dc74e
primitive
private TypeMapping primitive(PrimitiveTypeName type)
{    return mapping(Types.optional(type).named(fieldName));}
073e37ab32205c8c19d8ae92bdb41757c6d00022915035f209adf58e0222523f
primitive
private TypeMapping primitive(PrimitiveTypeName type, LogicalTypeAnnotation otype)
{    return mapping(Types.optional(type).as(otype).named(fieldName));}
1228a0ea4daa8b52f94d00b1061dbdb2562a6255b9648aeaead2c8cb86fb96d7
primitiveFLBA
private TypeMapping primitiveFLBA(int length, LogicalTypeAnnotation otype)
{    return mapping(Types.optional(FIXED_LEN_BYTE_ARRAY).length(length).as(otype).named(fieldName));}
f4a8d232e1afa902e3851d0acaadc80186cb0ff2bdd9218148f4d08899f673f6
fromParquet
public SchemaMapping fromParquet(MessageType parquetSchema)
{    List<Type> fields = parquetSchema.getFields();    List<TypeMapping> mappings = fromParquet(fields);    List<Field> arrowFields = fields(mappings);    return new SchemaMapping(new Schema(arrowFields), parquetSchema, mappings);}
efefdccb5465789bc4afdfc6c720bf1db6c2883790607b4c4acc65056e2be38d
fields
private List<Field> fields(List<TypeMapping> mappings)
{    List<Field> result = new ArrayList<>(mappings.size());    for (TypeMapping typeMapping : mappings) {        result.add(typeMapping.getArrowField());    }    return result;}
1a7c010a260770d59c95693f7c168b99a9bf67f883935f84f76d48251ce381a8
fromParquet
private List<TypeMapping> fromParquet(List<Type> fields)
{    List<TypeMapping> result = new ArrayList<>(fields.size());    for (Type type : fields) {        result.add(fromParquet(type));    }    return result;}
e84566015ca79d5df03df304724043b8022733819290980631281ee5ef7f3dd1
fromParquet
private TypeMapping fromParquet(Type type)
{    return fromParquet(type, type.getName(), type.getRepetition());}
5b2680eecc9d814bdd130c5d814966a1660f1ece832b299e0a45f3a49492f6f7
fromParquet
private TypeMapping fromParquet(Type type, String name, Repetition repetition)
{    if (repetition == REPEATED) {                TypeMapping child = fromParquet(type, null, REQUIRED);        Field arrowField = new Field(name, false, new ArrowType.List(), asList(child.getArrowField()));        return new RepeatedTypeMapping(arrowField, type, child);    }    if (type.isPrimitive()) {        return fromParquetPrimitive(type.asPrimitiveType(), name);    } else {        return fromParquetGroup(type.asGroupType(), name);    }}
a1e4456cfd2b3633169a93ce52f68f89686b825b0feeb12c27dbbc72efbbb52d
fromParquetGroup
private TypeMapping fromParquetGroup(GroupType type, String name)
{    LogicalTypeAnnotation logicalType = type.getLogicalTypeAnnotation();    if (logicalType == null) {        List<TypeMapping> typeMappings = fromParquet(type.getFields());        Field arrowField = new Field(name, type.isRepetition(OPTIONAL), new Struct(), fields(typeMappings));        return new StructTypeMapping(arrowField, type, typeMappings);    } else {        return logicalType.accept(new LogicalTypeAnnotation.LogicalTypeAnnotationVisitor<TypeMapping>() {            @Override            public Optional<TypeMapping> visit(LogicalTypeAnnotation.ListLogicalTypeAnnotation listLogicalType) {                List3Levels list3Levels = new List3Levels(type);                TypeMapping child = fromParquet(list3Levels.getElement(), null, list3Levels.getElement().getRepetition());                Field arrowField = new Field(name, type.isRepetition(OPTIONAL), new ArrowType.List(), asList(child.getArrowField()));                return of(new ListTypeMapping(arrowField, list3Levels, child));            }        }).orElseThrow(() -> new UnsupportedOperationException("Unsupported type " + type));    }}
d37012cf164633615e51377fcb0281050f86bda7956d17932d7391e7c024d4f9
visit
public Optional<TypeMapping> visit(LogicalTypeAnnotation.ListLogicalTypeAnnotation listLogicalType)
{    List3Levels list3Levels = new List3Levels(type);    TypeMapping child = fromParquet(list3Levels.getElement(), null, list3Levels.getElement().getRepetition());    Field arrowField = new Field(name, type.isRepetition(OPTIONAL), new ArrowType.List(), asList(child.getArrowField()));    return of(new ListTypeMapping(arrowField, list3Levels, child));}
9151d75469b71d6070535034f1e0d01faad564cd8153ed5b07b74f3339bd0d56
fromParquetPrimitive
private TypeMapping fromParquetPrimitive(final PrimitiveType type, final String name)
{    return type.getPrimitiveTypeName().convert(new PrimitiveType.PrimitiveTypeNameConverter<TypeMapping, RuntimeException>() {        private TypeMapping field(ArrowType arrowType) {            Field field = new Field(name, type.isRepetition(OPTIONAL), arrowType, null);            return new PrimitiveTypeMapping(field, type);        }        @Override        public TypeMapping convertFLOAT(PrimitiveTypeName primitiveTypeName) throws RuntimeException {            return field(new ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE));        }        @Override        public TypeMapping convertDOUBLE(PrimitiveTypeName primitiveTypeName) throws RuntimeException {            return field(new ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE));        }        @Override        public TypeMapping convertINT32(PrimitiveTypeName primitiveTypeName) throws RuntimeException {            LogicalTypeAnnotation logicalTypeAnnotation = type.getLogicalTypeAnnotation();            if (logicalTypeAnnotation == null) {                return integer(32, true);            }            return logicalTypeAnnotation.accept(new LogicalTypeAnnotation.LogicalTypeAnnotationVisitor<TypeMapping>() {                @Override                public Optional<TypeMapping> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType) {                    return of(decimal(decimalLogicalType.getPrecision(), decimalLogicalType.getScale()));                }                @Override                public Optional<TypeMapping> visit(LogicalTypeAnnotation.DateLogicalTypeAnnotation dateLogicalType) {                    return of(field(new ArrowType.Date(DateUnit.DAY)));                }                @Override                public Optional<TypeMapping> visit(LogicalTypeAnnotation.TimeLogicalTypeAnnotation timeLogicalType) {                    return timeLogicalType.getUnit() == MILLIS ? of(field(new ArrowType.Time(TimeUnit.MILLISECOND, 32))) : empty();                }                @Override                public Optional<TypeMapping> visit(LogicalTypeAnnotation.IntLogicalTypeAnnotation intLogicalType) {                    if (intLogicalType.getBitWidth() == 64) {                        return empty();                    }                    return of(integer(intLogicalType.getBitWidth(), intLogicalType.isSigned()));                }            }).orElseThrow(() -> new IllegalArgumentException("illegal type " + type));        }        @Override        public TypeMapping convertINT64(PrimitiveTypeName primitiveTypeName) throws RuntimeException {            LogicalTypeAnnotation logicalTypeAnnotation = type.getLogicalTypeAnnotation();            if (logicalTypeAnnotation == null) {                return integer(64, true);            }            return logicalTypeAnnotation.accept(new LogicalTypeAnnotation.LogicalTypeAnnotationVisitor<TypeMapping>() {                @Override                public Optional<TypeMapping> visit(LogicalTypeAnnotation.DateLogicalTypeAnnotation dateLogicalType) {                    return of(field(new ArrowType.Date(DateUnit.DAY)));                }                @Override                public Optional<TypeMapping> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType) {                    return of(decimal(decimalLogicalType.getPrecision(), decimalLogicalType.getScale()));                }                @Override                public Optional<TypeMapping> visit(LogicalTypeAnnotation.IntLogicalTypeAnnotation intLogicalType) {                    return of(integer(intLogicalType.getBitWidth(), intLogicalType.isSigned()));                }                @Override                public Optional<TypeMapping> visit(LogicalTypeAnnotation.TimeLogicalTypeAnnotation timeLogicalType) {                    if (timeLogicalType.getUnit() == MICROS) {                        return of(field(new ArrowType.Time(TimeUnit.MICROSECOND, 64)));                    } else if (timeLogicalType.getUnit() == NANOS) {                        return of(field(new ArrowType.Time(TimeUnit.NANOSECOND, 64)));                    }                    return empty();                }                @Override                public Optional<TypeMapping> visit(LogicalTypeAnnotation.TimestampLogicalTypeAnnotation timestampLogicalType) {                    switch(timestampLogicalType.getUnit()) {                        case MICROS:                            return of(field(new ArrowType.Timestamp(TimeUnit.MICROSECOND, getTimeZone(timestampLogicalType))));                        case MILLIS:                            return of(field(new ArrowType.Timestamp(TimeUnit.MILLISECOND, getTimeZone(timestampLogicalType))));                        case NANOS:                            return of(field(new ArrowType.Timestamp(TimeUnit.NANOSECOND, getTimeZone(timestampLogicalType))));                    }                    return empty();                }                private String getTimeZone(LogicalTypeAnnotation.TimestampLogicalTypeAnnotation timestampLogicalType) {                    return timestampLogicalType.isAdjustedToUTC() ? "UTC" : null;                }            }).orElseThrow(() -> new IllegalArgumentException("illegal type " + type));        }        @Override        public TypeMapping convertINT96(PrimitiveTypeName primitiveTypeName) throws RuntimeException {            if (convertInt96ToArrowTimestamp) {                return field(new ArrowType.Timestamp(TimeUnit.NANOSECOND, null));            } else {                return field(new ArrowType.Binary());            }        }        @Override        public TypeMapping convertFIXED_LEN_BYTE_ARRAY(PrimitiveTypeName primitiveTypeName) throws RuntimeException {            LogicalTypeAnnotation logicalTypeAnnotation = type.getLogicalTypeAnnotation();            if (logicalTypeAnnotation == null) {                return field(new ArrowType.Binary());            }            return logicalTypeAnnotation.accept(new LogicalTypeAnnotation.LogicalTypeAnnotationVisitor<TypeMapping>() {                @Override                public Optional<TypeMapping> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType) {                    return of(decimal(decimalLogicalType.getPrecision(), decimalLogicalType.getScale()));                }            }).orElseThrow(() -> new IllegalArgumentException("illegal type " + type));        }        @Override        public TypeMapping convertBOOLEAN(PrimitiveTypeName primitiveTypeName) throws RuntimeException {            return field(new ArrowType.Bool());        }        @Override        public TypeMapping convertBINARY(PrimitiveTypeName primitiveTypeName) throws RuntimeException {            LogicalTypeAnnotation logicalTypeAnnotation = type.getLogicalTypeAnnotation();            if (logicalTypeAnnotation == null) {                return field(new ArrowType.Binary());            }            return logicalTypeAnnotation.accept(new LogicalTypeAnnotation.LogicalTypeAnnotationVisitor<TypeMapping>() {                @Override                public Optional<TypeMapping> visit(LogicalTypeAnnotation.StringLogicalTypeAnnotation stringLogicalType) {                    return of(field(new ArrowType.Utf8()));                }                @Override                public Optional<TypeMapping> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType) {                    return of(decimal(decimalLogicalType.getPrecision(), decimalLogicalType.getScale()));                }            }).orElseThrow(() -> new IllegalArgumentException("illegal type " + type));        }        private TypeMapping decimal(int precision, int scale) {            return field(new ArrowType.Decimal(precision, scale));        }        private TypeMapping integer(int width, boolean signed) {            return field(new ArrowType.Int(width, signed));        }    });}
9fe7437b5682d8991bff65439bbfe29f14499d6ee25aae4c5b18ee1e31e156f0
field
private TypeMapping field(ArrowType arrowType)
{    Field field = new Field(name, type.isRepetition(OPTIONAL), arrowType, null);    return new PrimitiveTypeMapping(field, type);}
1ae7974a890d79f52b49a5d5ef619c68dd58de4bbc2b4c7ed3de920532b4d0a3
convertFLOAT
public TypeMapping convertFLOAT(PrimitiveTypeName primitiveTypeName) throws RuntimeException
{    return field(new ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE));}
280a21941b65fc4e5ffa782024d8b4539185bd790e54ec9799ab9f09f5bfad5e
convertDOUBLE
public TypeMapping convertDOUBLE(PrimitiveTypeName primitiveTypeName) throws RuntimeException
{    return field(new ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE));}
816a6e2845150046db503a60421eb4b4f05b3834aada19ded2712fa1cfc29bb1
convertINT32
public TypeMapping convertINT32(PrimitiveTypeName primitiveTypeName) throws RuntimeException
{    LogicalTypeAnnotation logicalTypeAnnotation = type.getLogicalTypeAnnotation();    if (logicalTypeAnnotation == null) {        return integer(32, true);    }    return logicalTypeAnnotation.accept(new LogicalTypeAnnotation.LogicalTypeAnnotationVisitor<TypeMapping>() {        @Override        public Optional<TypeMapping> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType) {            return of(decimal(decimalLogicalType.getPrecision(), decimalLogicalType.getScale()));        }        @Override        public Optional<TypeMapping> visit(LogicalTypeAnnotation.DateLogicalTypeAnnotation dateLogicalType) {            return of(field(new ArrowType.Date(DateUnit.DAY)));        }        @Override        public Optional<TypeMapping> visit(LogicalTypeAnnotation.TimeLogicalTypeAnnotation timeLogicalType) {            return timeLogicalType.getUnit() == MILLIS ? of(field(new ArrowType.Time(TimeUnit.MILLISECOND, 32))) : empty();        }        @Override        public Optional<TypeMapping> visit(LogicalTypeAnnotation.IntLogicalTypeAnnotation intLogicalType) {            if (intLogicalType.getBitWidth() == 64) {                return empty();            }            return of(integer(intLogicalType.getBitWidth(), intLogicalType.isSigned()));        }    }).orElseThrow(() -> new IllegalArgumentException("illegal type " + type));}
7cf168dc484c38671962a805778f1ff458ecf731936d41d3378202126a11e537
visit
public Optional<TypeMapping> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType)
{    return of(decimal(decimalLogicalType.getPrecision(), decimalLogicalType.getScale()));}
6beeed10f373d6676f1b1fa77c38eeb4d3d7302c1e2e461acafe29301a158b67
visit
public Optional<TypeMapping> visit(LogicalTypeAnnotation.DateLogicalTypeAnnotation dateLogicalType)
{    return of(field(new ArrowType.Date(DateUnit.DAY)));}
dd541e2553c4e3aab8e366f4822e16adaa4e3360b18a7eee17b99ee0088f43d2
visit
public Optional<TypeMapping> visit(LogicalTypeAnnotation.TimeLogicalTypeAnnotation timeLogicalType)
{    return timeLogicalType.getUnit() == MILLIS ? of(field(new ArrowType.Time(TimeUnit.MILLISECOND, 32))) : empty();}
d72898c50c009be0cd4a205739a6b55cb084c2827e20402f65634d20fea786f3
visit
public Optional<TypeMapping> visit(LogicalTypeAnnotation.IntLogicalTypeAnnotation intLogicalType)
{    if (intLogicalType.getBitWidth() == 64) {        return empty();    }    return of(integer(intLogicalType.getBitWidth(), intLogicalType.isSigned()));}
9ca3ba65f5755b337d55586a3f1d1f78d4e466d9b783ee63da5d3fc17367d630
convertINT64
public TypeMapping convertINT64(PrimitiveTypeName primitiveTypeName) throws RuntimeException
{    LogicalTypeAnnotation logicalTypeAnnotation = type.getLogicalTypeAnnotation();    if (logicalTypeAnnotation == null) {        return integer(64, true);    }    return logicalTypeAnnotation.accept(new LogicalTypeAnnotation.LogicalTypeAnnotationVisitor<TypeMapping>() {        @Override        public Optional<TypeMapping> visit(LogicalTypeAnnotation.DateLogicalTypeAnnotation dateLogicalType) {            return of(field(new ArrowType.Date(DateUnit.DAY)));        }        @Override        public Optional<TypeMapping> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType) {            return of(decimal(decimalLogicalType.getPrecision(), decimalLogicalType.getScale()));        }        @Override        public Optional<TypeMapping> visit(LogicalTypeAnnotation.IntLogicalTypeAnnotation intLogicalType) {            return of(integer(intLogicalType.getBitWidth(), intLogicalType.isSigned()));        }        @Override        public Optional<TypeMapping> visit(LogicalTypeAnnotation.TimeLogicalTypeAnnotation timeLogicalType) {            if (timeLogicalType.getUnit() == MICROS) {                return of(field(new ArrowType.Time(TimeUnit.MICROSECOND, 64)));            } else if (timeLogicalType.getUnit() == NANOS) {                return of(field(new ArrowType.Time(TimeUnit.NANOSECOND, 64)));            }            return empty();        }        @Override        public Optional<TypeMapping> visit(LogicalTypeAnnotation.TimestampLogicalTypeAnnotation timestampLogicalType) {            switch(timestampLogicalType.getUnit()) {                case MICROS:                    return of(field(new ArrowType.Timestamp(TimeUnit.MICROSECOND, getTimeZone(timestampLogicalType))));                case MILLIS:                    return of(field(new ArrowType.Timestamp(TimeUnit.MILLISECOND, getTimeZone(timestampLogicalType))));                case NANOS:                    return of(field(new ArrowType.Timestamp(TimeUnit.NANOSECOND, getTimeZone(timestampLogicalType))));            }            return empty();        }        private String getTimeZone(LogicalTypeAnnotation.TimestampLogicalTypeAnnotation timestampLogicalType) {            return timestampLogicalType.isAdjustedToUTC() ? "UTC" : null;        }    }).orElseThrow(() -> new IllegalArgumentException("illegal type " + type));}
6beeed10f373d6676f1b1fa77c38eeb4d3d7302c1e2e461acafe29301a158b67
visit
public Optional<TypeMapping> visit(LogicalTypeAnnotation.DateLogicalTypeAnnotation dateLogicalType)
{    return of(field(new ArrowType.Date(DateUnit.DAY)));}
7cf168dc484c38671962a805778f1ff458ecf731936d41d3378202126a11e537
visit
public Optional<TypeMapping> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType)
{    return of(decimal(decimalLogicalType.getPrecision(), decimalLogicalType.getScale()));}
d72898c50c009be0cd4a205739a6b55cb084c2827e20402f65634d20fea786f3
visit
public Optional<TypeMapping> visit(LogicalTypeAnnotation.IntLogicalTypeAnnotation intLogicalType)
{    return of(integer(intLogicalType.getBitWidth(), intLogicalType.isSigned()));}
dd541e2553c4e3aab8e366f4822e16adaa4e3360b18a7eee17b99ee0088f43d2
visit
public Optional<TypeMapping> visit(LogicalTypeAnnotation.TimeLogicalTypeAnnotation timeLogicalType)
{    if (timeLogicalType.getUnit() == MICROS) {        return of(field(new ArrowType.Time(TimeUnit.MICROSECOND, 64)));    } else if (timeLogicalType.getUnit() == NANOS) {        return of(field(new ArrowType.Time(TimeUnit.NANOSECOND, 64)));    }    return empty();}
a388e3f3780ff16a8e981db693a93c1d31e020a0a71fefee95dccc69459df610
visit
public Optional<TypeMapping> visit(LogicalTypeAnnotation.TimestampLogicalTypeAnnotation timestampLogicalType)
{    switch(timestampLogicalType.getUnit()) {        case MICROS:            return of(field(new ArrowType.Timestamp(TimeUnit.MICROSECOND, getTimeZone(timestampLogicalType))));        case MILLIS:            return of(field(new ArrowType.Timestamp(TimeUnit.MILLISECOND, getTimeZone(timestampLogicalType))));        case NANOS:            return of(field(new ArrowType.Timestamp(TimeUnit.NANOSECOND, getTimeZone(timestampLogicalType))));    }    return empty();}
d781759fe8512e6286b4f6dd1e9956a0e7c1ebf1fc2b7e124b14b3478838cc40
getTimeZone
private String getTimeZone(LogicalTypeAnnotation.TimestampLogicalTypeAnnotation timestampLogicalType)
{    return timestampLogicalType.isAdjustedToUTC() ? "UTC" : null;}
da04349b4093e19e8c23b706a55f7ebb1fbe07b4eec7ddc4a2ba862a017fca25
convertINT96
public TypeMapping convertINT96(PrimitiveTypeName primitiveTypeName) throws RuntimeException
{    if (convertInt96ToArrowTimestamp) {        return field(new ArrowType.Timestamp(TimeUnit.NANOSECOND, null));    } else {        return field(new ArrowType.Binary());    }}
75236828577b1d3b657ac0be525e4df9279307f16dd7bf01afffbb6e638284f7
convertFIXED_LEN_BYTE_ARRAY
public TypeMapping convertFIXED_LEN_BYTE_ARRAY(PrimitiveTypeName primitiveTypeName) throws RuntimeException
{    LogicalTypeAnnotation logicalTypeAnnotation = type.getLogicalTypeAnnotation();    if (logicalTypeAnnotation == null) {        return field(new ArrowType.Binary());    }    return logicalTypeAnnotation.accept(new LogicalTypeAnnotation.LogicalTypeAnnotationVisitor<TypeMapping>() {        @Override        public Optional<TypeMapping> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType) {            return of(decimal(decimalLogicalType.getPrecision(), decimalLogicalType.getScale()));        }    }).orElseThrow(() -> new IllegalArgumentException("illegal type " + type));}
7cf168dc484c38671962a805778f1ff458ecf731936d41d3378202126a11e537
visit
public Optional<TypeMapping> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType)
{    return of(decimal(decimalLogicalType.getPrecision(), decimalLogicalType.getScale()));}
7b0384c5602837ac212a19b0de7240c839b375821b82353251c856a480b26399
convertBOOLEAN
public TypeMapping convertBOOLEAN(PrimitiveTypeName primitiveTypeName) throws RuntimeException
{    return field(new ArrowType.Bool());}
431b83d29ded63040ab0eaf6b73fdcea9a247e873928a5635cac4b083fce3303
convertBINARY
public TypeMapping convertBINARY(PrimitiveTypeName primitiveTypeName) throws RuntimeException
{    LogicalTypeAnnotation logicalTypeAnnotation = type.getLogicalTypeAnnotation();    if (logicalTypeAnnotation == null) {        return field(new ArrowType.Binary());    }    return logicalTypeAnnotation.accept(new LogicalTypeAnnotation.LogicalTypeAnnotationVisitor<TypeMapping>() {        @Override        public Optional<TypeMapping> visit(LogicalTypeAnnotation.StringLogicalTypeAnnotation stringLogicalType) {            return of(field(new ArrowType.Utf8()));        }        @Override        public Optional<TypeMapping> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType) {            return of(decimal(decimalLogicalType.getPrecision(), decimalLogicalType.getScale()));        }    }).orElseThrow(() -> new IllegalArgumentException("illegal type " + type));}
bfac96d22d94e97514f7c058ffe663840e09019077e5bb7fd663517af62d7b56
visit
public Optional<TypeMapping> visit(LogicalTypeAnnotation.StringLogicalTypeAnnotation stringLogicalType)
{    return of(field(new ArrowType.Utf8()));}
7cf168dc484c38671962a805778f1ff458ecf731936d41d3378202126a11e537
visit
public Optional<TypeMapping> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType)
{    return of(decimal(decimalLogicalType.getPrecision(), decimalLogicalType.getScale()));}
f338b0d6edf691d0f09c2ba1e82daff3c7f140ea51c9da74b2016e752b675e88
decimal
private TypeMapping decimal(int precision, int scale)
{    return field(new ArrowType.Decimal(precision, scale));}
195a4f915ed695978926e65859f4b8ac4e6541b7dc4b80905436aa6eab1e21c4
integer
private TypeMapping integer(int width, boolean signed)
{    return field(new ArrowType.Int(width, signed));}
e8cc3c1109798347049108fe3ccfd6ca2447227e0b82a6f0b20fe312ce17b9fd
map
public SchemaMapping map(Schema arrowSchema, MessageType parquetSchema)
{    List<TypeMapping> children = map(arrowSchema.getFields(), parquetSchema.getFields());    return new SchemaMapping(arrowSchema, parquetSchema, children);}
7de51cb4bb6fa6cdd4d9222e2a150d053ffb8c6655bbe60e08b1849b02e8ae31
map
private List<TypeMapping> map(List<Field> arrowFields, List<Type> parquetFields)
{    if (arrowFields.size() != parquetFields.size()) {        throw new IllegalArgumentException("Can not map schemas as sizes differ: " + arrowFields + " != " + parquetFields);    }    List<TypeMapping> result = new ArrayList<>(arrowFields.size());    for (int i = 0; i < arrowFields.size(); i++) {        Field arrowField = arrowFields.get(i);        Type parquetField = parquetFields.get(i);        result.add(map(arrowField, parquetField));    }    return result;}
76579c592c4f76b67bed5e8d63f41a6beae60e58f6498c0d7f4dbd7eb87a7ddc
map
private TypeMapping map(final Field arrowField, final Type parquetField)
{    return arrowField.getType().accept(new ArrowTypeVisitor<TypeMapping>() {        @Override        public TypeMapping visit(Null type) {            if (!parquetField.isRepetition(OPTIONAL)) {                throw new IllegalArgumentException("Parquet type can't be null: " + parquetField);            }            return primitive();        }        @Override        public TypeMapping visit(Struct type) {            if (parquetField.isPrimitive()) {                throw new IllegalArgumentException("Parquet type not a group: " + parquetField);            }            GroupType groupType = parquetField.asGroupType();            return new StructTypeMapping(arrowField, groupType, map(arrowField.getChildren(), groupType.getFields()));        }        @Override        public TypeMapping visit(org.apache.arrow.vector.types.pojo.ArrowType.List type) {            return createListTypeMapping(type);        }        @Override        public TypeMapping visit(org.apache.arrow.vector.types.pojo.ArrowType.FixedSizeList type) {            return createListTypeMapping(type);        }        private TypeMapping createListTypeMapping(ArrowType.ComplexType type) {            if (arrowField.getChildren().size() != 1) {                throw new IllegalArgumentException("Invalid list type: " + type);            }            Field arrowChild = arrowField.getChildren().get(0);            if (parquetField.isRepetition(REPEATED)) {                return new RepeatedTypeMapping(arrowField, parquetField, map(arrowChild, parquetField));            }            if (parquetField.isPrimitive()) {                throw new IllegalArgumentException("Parquet type not a group: " + parquetField);            }            List3Levels list3Levels = new List3Levels(parquetField.asGroupType());            if (arrowField.getChildren().size() != 1) {                throw new IllegalArgumentException("invalid arrow list: " + arrowField);            }            return new ListTypeMapping(arrowField, list3Levels, map(arrowChild, list3Levels.getElement()));        }        @Override        public TypeMapping visit(Union type) {            if (parquetField.isPrimitive()) {                throw new IllegalArgumentException("Parquet type not a group: " + parquetField);            }            GroupType groupType = parquetField.asGroupType();            return new UnionTypeMapping(arrowField, groupType, map(arrowField.getChildren(), groupType.getFields()));        }        @Override        public TypeMapping visit(Int type) {            return primitive();        }        @Override        public TypeMapping visit(FloatingPoint type) {            return primitive();        }        @Override        public TypeMapping visit(Utf8 type) {            return primitive();        }        @Override        public TypeMapping visit(Binary type) {            return primitive();        }        @Override        public TypeMapping visit(Bool type) {            return primitive();        }        @Override        public TypeMapping visit(Decimal type) {            return primitive();        }        @Override        public TypeMapping visit(Date type) {            return primitive();        }        @Override        public TypeMapping visit(Time type) {            return primitive();        }        @Override        public TypeMapping visit(Timestamp type) {            return primitive();        }        @Override        public TypeMapping visit(Interval type) {            return primitive();        }        @Override        public TypeMapping visit(ArrowType.FixedSizeBinary fixedSizeBinary) {            return primitive();        }        private TypeMapping primitive() {            if (!parquetField.isPrimitive()) {                throw new IllegalArgumentException("Can not map schemas as one is primitive and the other is not: " + arrowField + " != " + parquetField);            }            return new PrimitiveTypeMapping(arrowField, parquetField.asPrimitiveType());        }    });}
ed631cc1988dac5eb298a637a5d6e56f184e9f615f63909eb0f64c015831cae5
visit
public TypeMapping visit(Null type)
{    if (!parquetField.isRepetition(OPTIONAL)) {        throw new IllegalArgumentException("Parquet type can't be null: " + parquetField);    }    return primitive();}
4fc9c0c958c3bb2e6dbe36790ea8e295161165022beda092bb9fcabb5834207f
visit
public TypeMapping visit(Struct type)
{    if (parquetField.isPrimitive()) {        throw new IllegalArgumentException("Parquet type not a group: " + parquetField);    }    GroupType groupType = parquetField.asGroupType();    return new StructTypeMapping(arrowField, groupType, map(arrowField.getChildren(), groupType.getFields()));}
c1bacd7300bca105b66fa739fd1cdb493a5e1f289cc942d2b5b4f66794d0ff75
visit
public TypeMapping visit(org.apache.arrow.vector.types.pojo.ArrowType.List type)
{    return createListTypeMapping(type);}
c63cd72d2b69abbd0a021f12edeb45846ee1928a32a644c2f181aed6cde949ec
visit
public TypeMapping visit(org.apache.arrow.vector.types.pojo.ArrowType.FixedSizeList type)
{    return createListTypeMapping(type);}
78d5c66c4fcf58c1d987b38b0c50379c8ede0c34715a2e2bdf5bf1813306fd30
createListTypeMapping
private TypeMapping createListTypeMapping(ArrowType.ComplexType type)
{    if (arrowField.getChildren().size() != 1) {        throw new IllegalArgumentException("Invalid list type: " + type);    }    Field arrowChild = arrowField.getChildren().get(0);    if (parquetField.isRepetition(REPEATED)) {        return new RepeatedTypeMapping(arrowField, parquetField, map(arrowChild, parquetField));    }    if (parquetField.isPrimitive()) {        throw new IllegalArgumentException("Parquet type not a group: " + parquetField);    }    List3Levels list3Levels = new List3Levels(parquetField.asGroupType());    if (arrowField.getChildren().size() != 1) {        throw new IllegalArgumentException("invalid arrow list: " + arrowField);    }    return new ListTypeMapping(arrowField, list3Levels, map(arrowChild, list3Levels.getElement()));}
25330c2eba2ab72fe9e99b6ed37fe40b0b2b783079bd0151afb7b91a54a34802
visit
public TypeMapping visit(Union type)
{    if (parquetField.isPrimitive()) {        throw new IllegalArgumentException("Parquet type not a group: " + parquetField);    }    GroupType groupType = parquetField.asGroupType();    return new UnionTypeMapping(arrowField, groupType, map(arrowField.getChildren(), groupType.getFields()));}
897b6b9527282c8e5c9f0bec540b722ff5ddb4571c0a518f1d9059c151fc706f
visit
public TypeMapping visit(Int type)
{    return primitive();}
8fc228597f1a198349a580164b1571fab84617cf40c2872bb5bd7d14083d1571
visit
public TypeMapping visit(FloatingPoint type)
{    return primitive();}
1ed7a1be6e89cee1817d80f79a36172da765483d573eef58de1eef245794ad6f
visit
public TypeMapping visit(Utf8 type)
{    return primitive();}
76c26663912da285221cb6a4d7d017dc1721c1d3ce17d2c8ced84f5d2922e39a
visit
public TypeMapping visit(Binary type)
{    return primitive();}
82aef2b7f97ae5647a03a3e99dc90b7798aa22a2e726e2b932a25706c4c5e771
visit
public TypeMapping visit(Bool type)
{    return primitive();}
af5563e08eca24bc20a66e6fe9db720f64385e1053e90721e0a64c8da3c642a2
visit
public TypeMapping visit(Decimal type)
{    return primitive();}
086ab75c055c1fd37d84d3b04be134b6c1c3e9861e6a7ae35ecc90afde4b8655
visit
public TypeMapping visit(Date type)
{    return primitive();}
9fde4e4e71fd4ad46eaf1e7e20d4aaded97af7dec16a095c1cf1a7835472501a
visit
public TypeMapping visit(Time type)
{    return primitive();}
e66e22823d6fece9cd403c860a4522a759a8566e5fe3b88b21b1436b56890a0b
visit
public TypeMapping visit(Timestamp type)
{    return primitive();}
842ae9ad581d4bf997cb0ceff03992f3d5c4bb64d4dac68b654be1b1fddfa204
visit
public TypeMapping visit(Interval type)
{    return primitive();}
a7e79396c6aeff3d022e5aa96915e2c90e94ada73766bd690e2ee646427e6824
visit
public TypeMapping visit(ArrowType.FixedSizeBinary fixedSizeBinary)
{    return primitive();}
d2567ec5ab2139c773c69336d56a71031e69126d4550f0734e54e50701cbdfb7
primitive
private TypeMapping primitive()
{    if (!parquetField.isPrimitive()) {        throw new IllegalArgumentException("Can not map schemas as one is primitive and the other is not: " + arrowField + " != " + parquetField);    }    return new PrimitiveTypeMapping(arrowField, parquetField.asPrimitiveType());}
57678ba2aa4c1080b0dda3811352552064102b43cd3ff08c4029da8bfd86bf23
getArrowSchema
public Schema getArrowSchema()
{    return arrowSchema;}
402985b743b3df9324cd38caa927e2b35d4bad5c597416ef77e1b95ca697c822
getParquetSchema
public MessageType getParquetSchema()
{    return parquetSchema;}
2eefa34acd226f35c04519b2bcd5b9d346a334e30eb903f8df5ea192dec4058b
getChildren
public List<TypeMapping> getChildren()
{    return children;}
0f1392890822551ce9c628b4f207f1b0d17fbef96e160336fa0e3827907715e1
getArrowField
public Field getArrowField()
{    return arrowField;}
b50169c39eace391f6e029453f5b24b789b63c63f985d17d85b6fc63a3760ff6
getParquetType
public Type getParquetType()
{    return parquetType;}
2eefa34acd226f35c04519b2bcd5b9d346a334e30eb903f8df5ea192dec4058b
getChildren
public List<TypeMapping> getChildren()
{    return children;}
6431d15e1c34b42dc3156a7264324c811c5d55ca3e1859fab1b1b5a60ef2a273
accept
public T accept(TypeMappingVisitor<T> visitor)
{    return visitor.visit(this);}
6431d15e1c34b42dc3156a7264324c811c5d55ca3e1859fab1b1b5a60ef2a273
accept
public T accept(TypeMappingVisitor<T> visitor)
{    return visitor.visit(this);}
6431d15e1c34b42dc3156a7264324c811c5d55ca3e1859fab1b1b5a60ef2a273
accept
public T accept(TypeMappingVisitor<T> visitor)
{    return visitor.visit(this);}
e07d0c544f2287fd1c5bdd712cb6a39b339904bba806a6e7086cbf81ffc99b1a
getList3Levels
public List3Levels getList3Levels()
{    return list3Levels;}
de261a6b53f95f7be3f674ba8262b6e14cd06ffb2a212e024780d9cbff92ef29
getChild
public TypeMapping getChild()
{    return child;}
6431d15e1c34b42dc3156a7264324c811c5d55ca3e1859fab1b1b5a60ef2a273
accept
public T accept(TypeMappingVisitor<T> visitor)
{    return visitor.visit(this);}
de261a6b53f95f7be3f674ba8262b6e14cd06ffb2a212e024780d9cbff92ef29
getChild
public TypeMapping getChild()
{    return child;}
6431d15e1c34b42dc3156a7264324c811c5d55ca3e1859fab1b1b5a60ef2a273
accept
public T accept(TypeMappingVisitor<T> visitor)
{    return visitor.visit(this);}
2c9082cbaa4060393e9349500c6588540ce95fe5706bbb50442840bee4ebc281
field
private static Field field(String name, boolean nullable, ArrowType type, Field... children)
{    return new Field(name, nullable, type, asList(children));}
8a996944f5d53d75a7f84ed8ebccc375309fa2b42c15a8145202b664dda38e53
field
private static Field field(String name, ArrowType type, Field... children)
{    return field(name, true, type, children);}
7421d400e0ae3b9bc233a6c489a502f22da355cc7e3e503414c3d8e658f92ed5
testComplexArrowToParquet
public void testComplexArrowToParquet() throws IOException
{    MessageType parquet = converter.fromArrow(complexArrowSchema).getParquetSchema();        Assert.assertEquals(complexParquetSchema.toString(), parquet.toString());    Assert.assertEquals(complexParquetSchema, parquet);}
9f1d946a97cec21240a21601f8b52c09c0d01a7c8f2a6f4c3aadccbef7e36a1a
testAllArrowToParquet
public void testAllArrowToParquet() throws IOException
{    MessageType parquet = converter.fromArrow(allTypesArrowSchema).getParquetSchema();        Assert.assertEquals(allTypesParquetSchema.toString(), parquet.toString());    Assert.assertEquals(allTypesParquetSchema, parquet);}
5435dd2b97b1b9bf288487ad5a1cadb9522aa53734653a95fabc62fe670f5991
testSupportedParquetToArrow
public void testSupportedParquetToArrow() throws IOException
{    Schema arrow = converter.fromParquet(supportedTypesParquetSchema).getArrowSchema();    assertEquals(supportedTypesArrowSchema, arrow);}
7379cf98e79a12780823a9c39af973b4b6e335c8c6240d0d7bf354b66b51087c
testRepeatedParquetToArrow
public void testRepeatedParquetToArrow() throws IOException
{    Schema arrow = converter.fromParquet(Paper.schema).getArrowSchema();    assertEquals(paperArrowSchema, arrow);}
59cf9f9eb4a04fba673ab727a4bbf51de1bc553efe961f807f36ab6bcd83695a
assertEquals
public void assertEquals(Schema left, Schema right)
{    compareFields(left.getFields(), right.getFields());    Assert.assertEquals(left, right);}
84a634b83afc6332d31df32c330e8e71ae2edf6b82afb36e968c6ee6c6d3acbd
compareFields
private void compareFields(List<Field> left, List<Field> right)
{    Assert.assertEquals(left + "\n" + right, left.size(), right.size());    int size = left.size();    for (int i = 0; i < size; i++) {        Field expectedField = left.get(i);        Field field = right.get(i);        compareFields(expectedField.getChildren(), field.getChildren());        Assert.assertEquals(expectedField, field);    }}
a0c19f817aede9bdea30b7889b06b131f04d395c87a6e15612adfb521e67cc2b
testAllMap
public void testAllMap() throws IOException
{    SchemaMapping map = converter.map(allTypesArrowSchema, allTypesParquetSchema);    Assert.assertEquals("p, s<p>, l<p>, l<p>, u<p>, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p, p", toSummaryString(map));}
bd1a7cf53626e52a59637a4b73797f494b86d3465f02fe9418addc79f5497dd9
toSummaryString
private String toSummaryString(SchemaMapping map)
{    List<TypeMapping> fields = map.getChildren();    return toSummaryString(fields);}
6a578028a2f50301ce5e4d4f960e157f8326c16879225fa9a1dc0c4390b1c838
toSummaryString
private String toSummaryString(List<TypeMapping> fields)
{    final StringBuilder sb = new StringBuilder();    for (TypeMapping typeMapping : fields) {        if (sb.length() != 0) {            sb.append(", ");        }        sb.append(typeMapping.accept(new TypeMappingVisitor<String>() {            @Override            public String visit(PrimitiveTypeMapping primitiveTypeMapping) {                return "p";            }            @Override            public String visit(StructTypeMapping structTypeMapping) {                return "s";            }            @Override            public String visit(UnionTypeMapping unionTypeMapping) {                return "u";            }            @Override            public String visit(ListTypeMapping listTypeMapping) {                return "l";            }            @Override            public String visit(RepeatedTypeMapping repeatedTypeMapping) {                return "r";            }        }));        if (typeMapping.getChildren() != null && !typeMapping.getChildren().isEmpty()) {            sb.append("<").append(toSummaryString(typeMapping.getChildren())).append(">");        }    }    return sb.toString();}
f5b2f7e41e565903d6d3e21a9a23b067dd090ba2b9f5750d48e3deffe11f292b
visit
public String visit(PrimitiveTypeMapping primitiveTypeMapping)
{    return "p";}
0e7fe1597027cb8917dd453ff6efd9d1dc53e78f7dd0b3069c758fbd7de42260
visit
public String visit(StructTypeMapping structTypeMapping)
{    return "s";}
f964c33a3eebf01cd85db31bc9ff44916e41c525949311866ed0187bc62a51da
visit
public String visit(UnionTypeMapping unionTypeMapping)
{    return "u";}
edfa5c697cd0296d56b6f30e954d6512f5a01644fdd8ed643440ed4e260ca17b
visit
public String visit(ListTypeMapping listTypeMapping)
{    return "l";}
4baf2fe03dd97b5eb6c882228422002b4d53b2589d789504e30bf8dd5fabcbba
visit
public String visit(RepeatedTypeMapping repeatedTypeMapping)
{    return "r";}
33ed56651e5738a01119670a08344d148c89bc5b6690db5658c31d0b92d26e17
testRepeatedMap
public void testRepeatedMap() throws IOException
{    SchemaMapping map = converter.map(paperArrowSchema, Paper.schema);    Assert.assertEquals("p, s<r<p>, r<p>>, r<s<r<s<p, p>>, p>>", toSummaryString(map));}
ec147b637f46dd174d017b6cfe28dba25274897dc8e23959e05024a79eb772ee
testArrowTimeSecondToParquet
public void testArrowTimeSecondToParquet()
{    converter.fromArrow(new Schema(asList(field("a", new ArrowType.Time(TimeUnit.SECOND, 32))))).getParquetSchema();}
292c96375637d70814e5491ba503908bc29acfb66f8f83fa0dc21426e8354bac
testArrowTimeMillisecondToParquet
public void testArrowTimeMillisecondToParquet()
{    MessageType expected = converter.fromArrow(new Schema(asList(field("a", new ArrowType.Time(TimeUnit.MILLISECOND, 32))))).getParquetSchema();    Assert.assertEquals(expected, Types.buildMessage().addField(Types.optional(INT32).as(timeType(false, MILLIS)).named("a")).named("root"));}
ee3263a2fb15df416ba2196e765a6e5d1ecd16910474ab641f7b0034a7697ada
testArrowTimeMicrosecondToParquet
public void testArrowTimeMicrosecondToParquet()
{    MessageType expected = converter.fromArrow(new Schema(asList(field("a", new ArrowType.Time(TimeUnit.MICROSECOND, 64))))).getParquetSchema();    Assert.assertEquals(expected, Types.buildMessage().addField(Types.optional(INT64).as(timeType(false, MICROS)).named("a")).named("root"));}
365049ec9a87632d0f766e1f55dc08a91ab1a6ca29092d50b7fd31ac38b90ce8
testParquetInt32TimeMillisToArrow
public void testParquetInt32TimeMillisToArrow()
{    MessageType parquet = Types.buildMessage().addField(Types.optional(INT32).as(TIME_MILLIS).named("a")).named("root");    Schema expected = new Schema(asList(field("a", new ArrowType.Time(TimeUnit.MILLISECOND, 32))));    Assert.assertEquals(expected, converter.fromParquet(parquet).getArrowSchema());}
b25dd17bb2df1d74b473e795d0f44655e4a8564830103775c0d0f16b23e91281
testParquetInt64TimeMicrosToArrow
public void testParquetInt64TimeMicrosToArrow()
{    MessageType parquet = Types.buildMessage().addField(Types.optional(INT64).as(TIME_MICROS).named("a")).named("root");    Schema expected = new Schema(asList(field("a", new ArrowType.Time(TimeUnit.MICROSECOND, 64))));    Assert.assertEquals(expected, converter.fromParquet(parquet).getArrowSchema());}
94f6161e4faedd6fa6ea96f191c9047c6ac820c69745d3307d43f05c778f3ad1
testParquetFixedBinaryToArrow
public void testParquetFixedBinaryToArrow()
{    MessageType parquet = Types.buildMessage().addField(Types.optional(FIXED_LEN_BYTE_ARRAY).length(12).named("a")).named("root");    Schema expected = new Schema(asList(field("a", new ArrowType.Binary())));    Assert.assertEquals(expected, converter.fromParquet(parquet).getArrowSchema());}
2ced9ac93606a972afd8e637e33f620b94736c6b7e742691b2ac503546bb4ae5
testParquetFixedBinaryToArrowDecimal
public void testParquetFixedBinaryToArrowDecimal()
{    MessageType parquet = Types.buildMessage().addField(Types.optional(FIXED_LEN_BYTE_ARRAY).length(5).as(DECIMAL).precision(8).scale(2).named("a")).named("root");    Schema expected = new Schema(asList(field("a", new ArrowType.Decimal(8, 2))));    Assert.assertEquals(expected, converter.fromParquet(parquet).getArrowSchema());}
a6ddf4f728f8ee8b2ea1c2ee2b7b8ad5d3db37c6d8ec039b1062b0b98daa834e
testParquetInt96ToArrowBinary
public void testParquetInt96ToArrowBinary()
{    MessageType parquet = Types.buildMessage().addField(Types.optional(INT96).named("a")).named("root");    Schema expected = new Schema(asList(field("a", new ArrowType.Binary())));    Assert.assertEquals(expected, converter.fromParquet(parquet).getArrowSchema());}
94051f36367469268347e9b2b1d9052b242d7be14a4dc3f1cde816798b83268f
testParquetInt96ToArrowTimestamp
public void testParquetInt96ToArrowTimestamp()
{    final SchemaConverter converterInt96ToTimestamp = new SchemaConverter(true);    MessageType parquet = Types.buildMessage().addField(Types.optional(INT96).named("a")).named("root");    Schema expected = new Schema(asList(field("a", new ArrowType.Timestamp(TimeUnit.NANOSECOND, null))));    Assert.assertEquals(expected, converterInt96ToTimestamp.fromParquet(parquet).getArrowSchema());}
99469c760dab31dee11b133c26bc1a6b707515811658729065f82404f73f7d56
testParquetInt64TimeMillisToArrow
public void testParquetInt64TimeMillisToArrow()
{    converter.fromParquet(Types.buildMessage().addField(Types.optional(INT64).as(TIME_MILLIS).named("a")).named("root"));}
f6a7eed0e9105641d53982a3f146a57884e908d7fe2e42182c2a76fd045671f7
testParquetInt32TimeMicrosToArrow
public void testParquetInt32TimeMicrosToArrow()
{    converter.fromParquet(Types.buildMessage().addField(Types.optional(INT32).as(TIME_MICROS).named("a")).named("root"));}
d1b3abdee3cd0d8c6ed436dcfb3c61ba86e8d4b1478e54ae85bf45059185fbc3
testArrowTimestampSecondToParquet
public void testArrowTimestampSecondToParquet()
{    converter.fromArrow(new Schema(asList(field("a", new ArrowType.Timestamp(TimeUnit.SECOND, "UTC"))))).getParquetSchema();}
1475d29a147a87caa42854c63c9fb4ce42134b573094e8f76da324397a3fd7ae
testArrowTimestampMillisecondToParquet
public void testArrowTimestampMillisecondToParquet()
{    MessageType expected = converter.fromArrow(new Schema(asList(field("a", new ArrowType.Timestamp(TimeUnit.MILLISECOND, "UTC"))))).getParquetSchema();    Assert.assertEquals(expected, Types.buildMessage().addField(Types.optional(INT64).as(TIMESTAMP_MILLIS).named("a")).named("root"));}
f9ed7d422cc42d98beeb737e8cdb7c89b08275e527976a59b3606007658cf4d3
testArrowTimestampMicrosecondToParquet
public void testArrowTimestampMicrosecondToParquet()
{    MessageType expected = converter.fromArrow(new Schema(asList(field("a", new ArrowType.Timestamp(TimeUnit.MICROSECOND, "UTC"))))).getParquetSchema();    Assert.assertEquals(expected, Types.buildMessage().addField(Types.optional(INT64).as(TIMESTAMP_MICROS).named("a")).named("root"));}
20fae67d8debdc6538052b4194d7ff41c1c6e335f373ea45ecff688f061d4d8d
testParquetInt64TimestampMillisToArrow
public void testParquetInt64TimestampMillisToArrow()
{    MessageType parquet = Types.buildMessage().addField(Types.optional(INT64).as(TIMESTAMP_MILLIS).named("a")).named("root");    Schema expected = new Schema(asList(field("a", new ArrowType.Timestamp(TimeUnit.MILLISECOND, "UTC"))));    Assert.assertEquals(expected, converter.fromParquet(parquet).getArrowSchema());}
7d596d78eb836fe6a7d8e85809ed51e2abe47390e20f22dc516377fd3544f85e
testParquetInt64TimestampMicrosToArrow
public void testParquetInt64TimestampMicrosToArrow()
{    MessageType parquet = Types.buildMessage().addField(Types.optional(INT64).as(TIMESTAMP_MICROS).named("a")).named("root");    Schema expected = new Schema(asList(field("a", new ArrowType.Timestamp(TimeUnit.MICROSECOND, "UTC"))));    Assert.assertEquals(expected, converter.fromParquet(parquet).getArrowSchema());}
da702b352e4208afff8c5db041708021ed6ced858e75dc2bcd07d5d8d1c7f6d4
testParquetInt32TimestampMillisToArrow
public void testParquetInt32TimestampMillisToArrow()
{    converter.fromParquet(Types.buildMessage().addField(Types.optional(INT32).as(TIMESTAMP_MILLIS).named("a")).named("root"));}
8b35ecfeb227e65ee5a8ea2635aafd49a3ca8e3daf49e86c49f9b99aae83860c
testParquetInt32TimestampMicrosToArrow
public void testParquetInt32TimestampMicrosToArrow()
{    converter.fromParquet(Types.buildMessage().addField(Types.optional(INT32).as(TIMESTAMP_MICROS).named("a")).named("root"));}
4da3915efeb45bd522ec756d13523540a507279d9a0b787efd2cafb4356363d1
getCurrentRecord
public T getCurrentRecord()
{    return root.getCurrentRecord();}
92fd854c4aebb01be238d83e407159211ea5cf60b5efd6fc7db8904dba13699b
getRootConverter
public GroupConverter getRootConverter()
{    return root;}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    parent.add(convert(value));}
7c3f73c96e69cb35837e756142746fd240f40ccf1d7d310c2436e6b135fe196b
hasDictionarySupport
public boolean hasDictionarySupport()
{    return true;}
5edde50d3cb88777a151a88dae34321ada39b284501a5295564b122126c5c393
setDictionary
public void setDictionary(Dictionary dictionary)
{    dict = (T[]) new Object[dictionary.getMaxId() + 1];    for (int i = 0; i <= dictionary.getMaxId(); i++) {        dict[i] = convert(dictionary.decodeToBinary(i));    }}
f0e2ac20a11812631bcef1b96719b529979532faefbea15fec4fc1a05b4795ee
prepareDictionaryValue
public T prepareDictionaryValue(T value)
{    return value;}
f1649786c3679c86c0157574e47953673714091cc71d598cedff963593010d98
addValueFromDictionary
public void addValueFromDictionary(int dictionaryId)
{    parent.add(prepareDictionaryValue(dict[dictionaryId]));}
a2ac1f40a6e220ec515710128c8baf77a725ad0b9f1767a998f776f27fff6cf6
addInt
public void addInt(int value)
{    parent.addByte((byte) value);}
a2ac1f40a6e220ec515710128c8baf77a725ad0b9f1767a998f776f27fff6cf6
addInt
public void addInt(int value)
{    parent.addShort((short) value);}
a2ac1f40a6e220ec515710128c8baf77a725ad0b9f1767a998f776f27fff6cf6
addInt
public void addInt(int value)
{    parent.addChar((char) value);}
954195d234288c19e659aa55edc4121b87eef181d6d86d58a96eaeb2fd0f77ba
addBoolean
public final void addBoolean(boolean value)
{    parent.addBoolean(value);}
b0b35a6cee9e7ab2c621c392008bd654c3d9e63c57dc04786380ffaf46d00efc
addInt
public final void addInt(int value)
{    parent.addInt(value);}
b0b35a6cee9e7ab2c621c392008bd654c3d9e63c57dc04786380ffaf46d00efc
addInt
public final void addInt(int value)
{    parent.addLong((long) value);}
f2540bfd2e5df5e69c6f90cf0607e0a9ce71860bcaa52d1fd7d61e8e4842d97b
addLong
public final void addLong(long value)
{    parent.addLong(value);}
b0b35a6cee9e7ab2c621c392008bd654c3d9e63c57dc04786380ffaf46d00efc
addInt
public final void addInt(int value)
{    parent.addFloat((float) value);}
f2540bfd2e5df5e69c6f90cf0607e0a9ce71860bcaa52d1fd7d61e8e4842d97b
addLong
public final void addLong(long value)
{    parent.addFloat((float) value);}
1a85d501dbca087ef815eaec751801b42fc0a5ac95f7d2226cb9b9a1fabfa923
addFloat
public final void addFloat(float value)
{    parent.addFloat(value);}
b0b35a6cee9e7ab2c621c392008bd654c3d9e63c57dc04786380ffaf46d00efc
addInt
public final void addInt(int value)
{    parent.addDouble((double) value);}
f2540bfd2e5df5e69c6f90cf0607e0a9ce71860bcaa52d1fd7d61e8e4842d97b
addLong
public final void addLong(long value)
{    parent.addDouble((double) value);}
1a85d501dbca087ef815eaec751801b42fc0a5ac95f7d2226cb9b9a1fabfa923
addFloat
public final void addFloat(float value)
{    parent.addDouble((double) value);}
59339a237854c0bcf5065099cd6420a719dcdf94fb2eafa4f7b3e980488340f0
addDouble
public final void addDouble(double value)
{    parent.addDouble(value);}
9bbc3aa902618f890277c022c33450605ec33a63af449025288389261719e648
convert
public byte[] convert(Binary binary)
{    return binary.getBytes();}
7fe48463299aca5270592d56d51ea1640a6e96057e177ba4e47620f22bd7cf2b
convert
public ByteBuffer convert(Binary binary)
{    return ByteBuffer.wrap(binary.getBytes());}
6866443c63459bb285dd1a2bf22cb102ebf4338ee4ef77db2afc5b5b6c068697
prepareDictionaryValue
public ByteBuffer prepareDictionaryValue(ByteBuffer value)
{    return value.duplicate();}
be54c75e3a79860be0a0594f9b931f8c4bfa06471b2288aed5c6306bf405d1b6
convert
public String convert(Binary binary)
{    return binary.toStringUsingUTF8();}
0da8c03925f9b11c4064bb1ffec3060e6d5101315de149910f5753be1b1385bc
convert
public Utf8 convert(Binary binary)
{    return new Utf8(binary.getBytes());}
26bc2a59be3019fd8fdf6dfd010b6356c2d62cf4fcc013eb17c555001b63bea3
convert
public Object convert(Binary binary)
{    try {        return ctor.newInstance(binary.toStringUsingUTF8());    } catch (InstantiationException e) {        throw new ParquetDecodingException("Cannot convert binary to " + stringableName, e);    } catch (IllegalAccessException e) {        throw new ParquetDecodingException("Cannot convert binary to " + stringableName, e);    } catch (InvocationTargetException e) {        throw new ParquetDecodingException("Cannot convert binary to " + stringableName, e);    }}
26bc2a59be3019fd8fdf6dfd010b6356c2d62cf4fcc013eb17c555001b63bea3
convert
public Object convert(Binary binary)
{    return model.createEnum(binary.toStringUsingUTF8(), schema);}
26bc2a59be3019fd8fdf6dfd010b6356c2d62cf4fcc013eb17c555001b63bea3
convert
public Object convert(Binary binary)
{    return model.createFixed(null, /* reuse */    binary.getBytes(), schema);}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    AvroIndexedRecordConverter.this.set(finalAvroIndex, value);}
0a4a2d2340cf359afb40fa545deea21ad4d77813c660167dea9894f02aa0f624
getDatumClass
private static Class<T> getDatumClass(GenericData model, Schema schema)
{    if (model.getConversionFor(schema.getLogicalType()) != null) {                return null;    }    if (model instanceof SpecificData) {        return (Class<T>) ((SpecificData) model).getClass(schema);    }    return null;}
caa84a001c55919593d83885d77837d74f72680d67c8b3ef7552db3984d25f13
getAvroField
private Schema.Field getAvroField(String parquetFieldName)
{    Schema.Field avroField = avroSchema.getField(parquetFieldName);    for (Schema.Field f : avroSchema.getFields()) {        if (f.aliases().contains(parquetFieldName)) {            return f;        }    }    if (avroField == null) {        throw new InvalidRecordException(String.format("Parquet/Avro schema mismatch. Avro field '%s' not found.", parquetFieldName));    }    return avroField;}
d290b4a48c90b5bc52999d6d9c72c5667dcc33ef9a1e41080ea78e1f726f12fa
newConverter
private static Converter newConverter(Schema schema, Type type, GenericData model, ParentValueContainer setter)
{    LogicalType logicalType = schema.getLogicalType();                Conversion<?> conversion = model.getConversionFor(logicalType);    ParentValueContainer parent = ParentValueContainer.getConversionContainer(setter, conversion, schema);    if (schema.getType().equals(Schema.Type.BOOLEAN)) {        return new AvroConverters.FieldBooleanConverter(parent);    } else if (schema.getType().equals(Schema.Type.INT)) {        return new AvroConverters.FieldIntegerConverter(parent);    } else if (schema.getType().equals(Schema.Type.LONG)) {        return new AvroConverters.FieldLongConverter(parent);    } else if (schema.getType().equals(Schema.Type.FLOAT)) {        return new AvroConverters.FieldFloatConverter(parent);    } else if (schema.getType().equals(Schema.Type.DOUBLE)) {        return new AvroConverters.FieldDoubleConverter(parent);    } else if (schema.getType().equals(Schema.Type.BYTES)) {        return new AvroConverters.FieldByteBufferConverter(parent);    } else if (schema.getType().equals(Schema.Type.STRING)) {        return new AvroConverters.FieldStringConverter(parent);    } else if (schema.getType().equals(Schema.Type.RECORD)) {        return new AvroIndexedRecordConverter(parent, type.asGroupType(), schema, model);    } else if (schema.getType().equals(Schema.Type.ENUM)) {        return new FieldEnumConverter(parent, schema, model);    } else if (schema.getType().equals(Schema.Type.ARRAY)) {        return new AvroArrayConverter(parent, type.asGroupType(), schema, model);    } else if (schema.getType().equals(Schema.Type.MAP)) {        return new MapConverter(parent, type.asGroupType(), schema, model);    } else if (schema.getType().equals(Schema.Type.UNION)) {        return new AvroUnionConverter(parent, type, schema, model);    } else if (schema.getType().equals(Schema.Type.FIXED)) {        return new FieldFixedConverter(parent, schema, model);    }    throw new UnsupportedOperationException(String.format("Cannot convert Avro type: %s" + " (Parquet type: %s) ", schema, type));}
9ce45667dff56220ae30a9b01fdc6c6f8a28f1228a27c53f2d027de604340054
set
private void set(int index, Object value)
{    this.currentRecord.put(index, value);}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    return converters[fieldIndex];}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{        this.currentRecord = (T) ((this.specificClass == null) ? new GenericData.Record(avroSchema) : SpecificData.newInstance(specificClass, avroSchema));}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    fillInDefaults();    if (parent != null) {        parent.add(currentRecord);    }}
76dbc80702514f8cd97b9e74e16a059e56d4f4141269e5e1ece0812e946fb12d
fillInDefaults
private void fillInDefaults()
{    for (Map.Entry<Schema.Field, Object> entry : recordDefaults.entrySet()) {        Schema.Field f = entry.getKey();                Object defaultValue = deepCopy(f.schema(), entry.getValue());        this.currentRecord.put(f.pos(), defaultValue);    }}
8404aec2c85fa90a21b2f6dc58232785cfb54b756638ed42ec726a3556b7c279
deepCopy
private Object deepCopy(Schema schema, Object value)
{    switch(schema.getType()) {        case BOOLEAN:        case INT:        case LONG:        case FLOAT:        case DOUBLE:            return value;        default:            return model.deepCopy(schema, value);    }}
a91f8189b0d08e8457532e5e30c30882be373589b8a9ab8bbe919104fbf2fa3f
getCurrentRecord
 T getCurrentRecord()
{    return currentRecord;}
b405f8029e1a0f0248ddb1e2a1e3f991bc030596be8f73cd2d250ff9b1a7c795
addBinary
public final void addBinary(Binary value)
{    Object enumValue = value.toStringUsingUTF8();    if (enumClass != null) {        enumValue = (Enum.valueOf(enumClass, (String) enumValue));    }    parent.add(enumValue);}
b405f8029e1a0f0248ddb1e2a1e3f991bc030596be8f73cd2d250ff9b1a7c795
addBinary
public final void addBinary(Binary value)
{    if (fixedClass == null) {        parent.add(new GenericData.Fixed(avroSchema, value.getBytes()));    } else {        if (fixedClassCtor == null) {            throw new IllegalArgumentException("fixedClass specified but fixedClassCtor is null.");        }        try {            Object fixed = fixedClassCtor.newInstance(value.getBytes());            parent.add(fixed);        } catch (Exception e) {            throw new RuntimeException(e);        }    }}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    array.add(value);}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    return converter;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    array = new GenericData.Array<Object>(0, avroSchema);}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    parent.add(array);}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    ElementConverter.this.element = value;}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    Preconditions.checkArgument(fieldIndex == 0, "Illegal field index: " + fieldIndex);    return elementConverter;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    element = null;}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    array.add(element);}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    Preconditions.checkArgument(memberValue == null, "Union is resolving to more than one type");    memberValue = value;}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    return memberConverters[fieldIndex];}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    memberValue = null;}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    parent.add(memberValue);}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    return keyValueConverter;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    this.map = new HashMap<String, V>();}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    parent.add(map);}
b405f8029e1a0f0248ddb1e2a1e3f991bc030596be8f73cd2d250ff9b1a7c795
addBinary
public final void addBinary(Binary value)
{    key = value.toStringUsingUTF8();}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    MapKeyValueConverter.this.value = (V) value;}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    if (fieldIndex == 0) {        return keyConverter;    } else if (fieldIndex == 1) {        return valueConverter;    }    throw new IllegalArgumentException("only the key (0) and value (1) fields expected: " + fieldIndex);}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    key = null;    value = null;}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    map.put(key, value);}
90dc8990af8f99d42ff6da7fb661faec8a493690fb0e63424afc44e95d605c02
setRequestedProjection
public static void setRequestedProjection(Job job, Schema requestedProjection)
{    AvroReadSupport.setRequestedProjection(ContextUtil.getConfiguration(job), requestedProjection);}
fe45731ae3d338adf169292f8119726ac014c613d94e40bc0869082e4690b3cc
setAvroReadSchema
public static void setAvroReadSchema(Job job, Schema avroReadSchema)
{    AvroReadSupport.setAvroReadSchema(ContextUtil.getConfiguration(job), avroReadSchema);}
fc2e5fedf09fc151d5039f09c7f4f38002d4c9ad44bbf9e4c6b8126c26a365a0
setAvroDataSupplier
public static void setAvroDataSupplier(Job job, Class<? extends AvroDataSupplier> supplierClass)
{    AvroReadSupport.setAvroDataSupplier(ContextUtil.getConfiguration(job), supplierClass);}
f334dbd626754d5af6724c080879fb1fb3b12ff6e68440545d42194bb2636e1c
setSchema
public static void setSchema(Job job, Schema schema)
{    AvroWriteSupport.setSchema(ContextUtil.getConfiguration(job), schema);}
fc2e5fedf09fc151d5039f09c7f4f38002d4c9ad44bbf9e4c6b8126c26a365a0
setAvroDataSupplier
public static void setAvroDataSupplier(Job job, Class<? extends AvroDataSupplier> supplierClass)
{    AvroWriteSupport.setAvroDataSupplier(ContextUtil.getConfiguration(job), supplierClass);}
b0d50e3a2a70c0d0628f9227d52b8cbdce33d303401113d24a28c344e1d93a74
builder
public static Builder<T> builder(Path file)
{    return new Builder<T>(file);}
a17f0b46be627cb9b1545d4f351e9cad24d73052797d8bfee0bfd892fb8792fe
builder
public static Builder<T> builder(InputFile file)
{    return new Builder<T>(file);}
b37048bffd9e5ca1f18dac255fdf0e6523fc37d1aa868e12d168298d22003ceb
withDataModel
public Builder<T> withDataModel(GenericData model)
{    this.model = model;        if (model.getClass() != GenericData.class && model.getClass() != SpecificData.class) {        isReflect = true;    }    return this;}
a0454746a2dcb87d52a68e30c4b871976816f6fdd3fef08225ccf0eeae962fd2
disableCompatibility
public Builder<T> disableCompatibility()
{    this.enableCompatibility = false;    return this;}
e5b32b7490c81aa7d5e2593d4c5c800f4ae4fc430b62be8ef147ea4ab22e6b69
withCompatibility
public Builder<T> withCompatibility(boolean enableCompatibility)
{    this.enableCompatibility = enableCompatibility;    return this;}
9cbda847a70608bb3a280b55cf8a9d897c12e8e6de61562b2ac51ca7e62d94ed
getReadSupport
protected ReadSupport<T> getReadSupport()
{    if (isReflect) {        conf.setBoolean(AvroReadSupport.AVRO_COMPATIBILITY, false);    } else {        conf.setBoolean(AvroReadSupport.AVRO_COMPATIBILITY, enableCompatibility);    }    return new AvroReadSupport<T>(model);}
b0d50e3a2a70c0d0628f9227d52b8cbdce33d303401113d24a28c344e1d93a74
builder
public static Builder<T> builder(Path file)
{    return new Builder<T>(file);}
b0f3087a7ce7ef20616fef6df63994fead6780afaffad8cdee716ff2e265768f
builder
public static Builder<T> builder(OutputFile file)
{    return new Builder<T>(file);}
faf1dd92010d084ac65c9a39b782adc4ac746ec37004a83a7746723744175585
writeSupport
private static WriteSupport<T> writeSupport(Schema avroSchema, GenericData model)
{    return new AvroWriteSupport<T>(new AvroSchemaConverter().convert(avroSchema), avroSchema, model);}
542b889ec86c7afee423a86a8eb0c6f4c482bee782db72e97afa9ed5d578f10e
writeSupport
private static WriteSupport<T> writeSupport(Configuration conf, Schema avroSchema, GenericData model)
{    return new AvroWriteSupport<T>(new AvroSchemaConverter(conf).convert(avroSchema), avroSchema, model);}
15260d0e1c3efaf255f45dcab355510449d620c660be566d85fcf14e9a43c211
withSchema
public Builder<T> withSchema(Schema schema)
{    this.schema = schema;    return this;}
b37048bffd9e5ca1f18dac255fdf0e6523fc37d1aa868e12d168298d22003ceb
withDataModel
public Builder<T> withDataModel(GenericData model)
{    this.model = model;    return this;}
0f6db3e8bf27e8638264a9f65cfc4ce24b213bb67ffd0386445b699dee45c6aa
self
protected Builder<T> self()
{    return this;}
540f488251eb4a78cd058bb2e32668d962e7ee54c408e52133e37860380660cc
getWriteSupport
protected WriteSupport<T> getWriteSupport(Configuration conf)
{    return AvroParquetWriter.writeSupport(conf, schema, model);}
b22dce4d75a059a8149cbd33598c4d8bb374e66baeeff11d835ca8cee33ed0e4
setRequestedProjection
public static void setRequestedProjection(Configuration configuration, Schema requestedProjection)
{    configuration.set(AVRO_REQUESTED_PROJECTION, requestedProjection.toString());}
2cc16fc5ffe287c94fe9e4d2bb262424e7191144c940fc5b285c3fc5f00d9d49
setAvroReadSchema
public static void setAvroReadSchema(Configuration configuration, Schema avroReadSchema)
{    configuration.set(AVRO_READ_SCHEMA, avroReadSchema.toString());}
303d1d43c813d42fdfbb493706080745bf2c28b1a6f8f16af875e3a50b01ff33
setAvroDataSupplier
public static void setAvroDataSupplier(Configuration configuration, Class<? extends AvroDataSupplier> clazz)
{    configuration.set(AVRO_DATA_SUPPLIER, clazz.getName());}
9f05e23006c5ef7acb499b683c83254f7d016dadfbda9d65c3f1212d59959596
init
public ReadContext init(Configuration configuration, Map<String, String> keyValueMetaData, MessageType fileSchema)
{    MessageType projection = fileSchema;    Map<String, String> metadata = new LinkedHashMap<String, String>();    String requestedProjectionString = configuration.get(AVRO_REQUESTED_PROJECTION);    if (requestedProjectionString != null) {        Schema avroRequestedProjection = new Schema.Parser().parse(requestedProjectionString);        projection = new AvroSchemaConverter(configuration).convert(avroRequestedProjection);    }    String avroReadSchema = configuration.get(AVRO_READ_SCHEMA);    if (avroReadSchema != null) {        metadata.put(AVRO_READ_SCHEMA_METADATA_KEY, avroReadSchema);    }    if (configuration.getBoolean(AVRO_COMPATIBILITY, AVRO_DEFAULT_COMPATIBILITY)) {        metadata.put(AVRO_COMPATIBILITY, "true");    }    return new ReadContext(projection, metadata);}
dcbc14ec02a60473c194a6ca67b9e82533789c178ba248e7971115229f645054
prepareForRead
public RecordMaterializer<T> prepareForRead(Configuration configuration, Map<String, String> keyValueMetaData, MessageType fileSchema, ReadContext readContext)
{    Map<String, String> metadata = readContext.getReadSupportMetadata();    MessageType parquetSchema = readContext.getRequestedSchema();    Schema avroSchema;    if (metadata.get(AVRO_READ_SCHEMA_METADATA_KEY) != null) {                avroSchema = new Schema.Parser().parse(metadata.get(AVRO_READ_SCHEMA_METADATA_KEY));    } else if (keyValueMetaData.get(AVRO_SCHEMA_METADATA_KEY) != null) {                avroSchema = new Schema.Parser().parse(keyValueMetaData.get(AVRO_SCHEMA_METADATA_KEY));    } else if (keyValueMetaData.get(OLD_AVRO_SCHEMA_METADATA_KEY) != null) {                avroSchema = new Schema.Parser().parse(keyValueMetaData.get(OLD_AVRO_SCHEMA_METADATA_KEY));    } else {                avroSchema = new AvroSchemaConverter(configuration).convert(parquetSchema);    }    GenericData model = getDataModel(configuration);    String compatEnabled = metadata.get(AvroReadSupport.AVRO_COMPATIBILITY);    if (compatEnabled != null && Boolean.valueOf(compatEnabled)) {        return newCompatMaterializer(parquetSchema, avroSchema, model);    }    return new AvroRecordMaterializer<T>(parquetSchema, avroSchema, model);}
9ee615ddb6d400a62913f75daa1441021f0918322a49c2e5b7972feab3db4687
newCompatMaterializer
private static RecordMaterializer<T> newCompatMaterializer(MessageType parquetSchema, Schema avroSchema, GenericData model)
{    return (RecordMaterializer<T>) new AvroCompatRecordMaterializer(parquetSchema, avroSchema, model);}
24e627f1959e62e5c1982fc724724afb98cf20e40cac82d3f16c0046ef6a04e2
getDataModel
private GenericData getDataModel(Configuration conf)
{    if (model != null) {        return model;    }    Class<? extends AvroDataSupplier> suppClass = conf.getClass(AVRO_DATA_SUPPLIER, SpecificDataSupplier.class, AvroDataSupplier.class);    return ReflectionUtils.newInstance(suppClass, conf).get();}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    AvroRecordConverter.this.currentRecord = (T) value;}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    AvroRecordConverter.this.set(avroField.name(), finalAvroIndex, value);}
26792595967d442e5c39f510eb3d745af4894fd5d62e51ef548ca0881f7ac9dc
getFieldsByName
private static Map<String, Class<?>> getFieldsByName(Class<?> recordClass, boolean excludeJava)
{    Map<String, Class<?>> fields = new LinkedHashMap<String, Class<?>>();    if (recordClass != null) {        Class<?> current = recordClass;        do {            if (excludeJava && current.getPackage() != null && current.getPackage().getName().startsWith("java.")) {                                break;            }            for (Field field : current.getDeclaredFields()) {                if (field.isAnnotationPresent(AvroIgnore.class) || isTransientOrStatic(field)) {                    continue;                }                AvroName altName = field.getAnnotation(AvroName.class);                Class<?> existing = fields.put(altName != null ? altName.value() : field.getName(), field.getType());                if (existing != null) {                    throw new AvroTypeException(current + " contains two fields named: " + field.getName());                }            }            current = current.getSuperclass();        } while (current != null);    }    return fields;}
76f05924ce67765212436db70fcf205e3ba7e7e3ed5916ef3d3c9cd2b32d8ffe
isTransientOrStatic
private static boolean isTransientOrStatic(Field field)
{    return (field.getModifiers() & (Modifier.TRANSIENT | Modifier.STATIC)) != 0;}
caa84a001c55919593d83885d77837d74f72680d67c8b3ef7552db3984d25f13
getAvroField
private Schema.Field getAvroField(String parquetFieldName)
{    Schema.Field avroField = avroSchema.getField(parquetFieldName);    if (avroField != null) {        return avroField;    }    for (Schema.Field f : avroSchema.getFields()) {        if (f.aliases().contains(parquetFieldName)) {            return f;        }    }    throw new InvalidRecordException(String.format("Parquet/Avro schema mismatch: Avro field '%s' not found", parquetFieldName));}
d290b4a48c90b5bc52999d6d9c72c5667dcc33ef9a1e41080ea78e1f726f12fa
newConverter
private static Converter newConverter(Schema schema, Type type, GenericData model, ParentValueContainer setter)
{    return newConverter(schema, type, model, null, setter);}
74c4fb6d7684910a7cb3dac8ceb2318f5273a5f0dd4c582e1329d3450f458910
newConverter
private static Converter newConverter(Schema schema, Type type, GenericData model, Class<?> knownClass, ParentValueContainer setter)
{    LogicalType logicalType = schema.getLogicalType();    Conversion<?> conversion;    if (knownClass != null) {        conversion = model.getConversionByClass(knownClass, logicalType);    } else {        conversion = model.getConversionFor(logicalType);    }    ParentValueContainer parent = ParentValueContainer.getConversionContainer(setter, conversion, schema);    if (schema.getType().equals(Schema.Type.BOOLEAN)) {        return new AvroConverters.FieldBooleanConverter(parent);    } else if (schema.getType().equals(Schema.Type.INT)) {        Class<?> datumClass = getDatumClass(conversion, knownClass, schema, model);        if (datumClass == null) {            return new AvroConverters.FieldIntegerConverter(parent);        } else if (datumClass == byte.class || datumClass == Byte.class) {            return new AvroConverters.FieldByteConverter(parent);        } else if (datumClass == short.class || datumClass == Short.class) {            return new AvroConverters.FieldShortConverter(parent);        } else if (datumClass == char.class || datumClass == Character.class) {            return new AvroConverters.FieldCharConverter(parent);        }        return new AvroConverters.FieldIntegerConverter(parent);    } else if (schema.getType().equals(Schema.Type.LONG)) {        return new AvroConverters.FieldLongConverter(parent);    } else if (schema.getType().equals(Schema.Type.FLOAT)) {        return new AvroConverters.FieldFloatConverter(parent);    } else if (schema.getType().equals(Schema.Type.DOUBLE)) {        return new AvroConverters.FieldDoubleConverter(parent);    } else if (schema.getType().equals(Schema.Type.BYTES)) {        Class<?> datumClass = getDatumClass(conversion, knownClass, schema, model);        if (datumClass == null) {            return new AvroConverters.FieldByteBufferConverter(parent);        } else if (datumClass.isArray() && datumClass.getComponentType() == byte.class) {            return new AvroConverters.FieldByteArrayConverter(parent);        }        return new AvroConverters.FieldByteBufferConverter(parent);    } else if (schema.getType().equals(Schema.Type.STRING)) {        return newStringConverter(schema, model, parent);    } else if (schema.getType().equals(Schema.Type.RECORD)) {        return new AvroRecordConverter(parent, type.asGroupType(), schema, model);    } else if (schema.getType().equals(Schema.Type.ENUM)) {        return new AvroConverters.FieldEnumConverter(parent, schema, model);    } else if (schema.getType().equals(Schema.Type.ARRAY)) {        Class<?> datumClass = getDatumClass(conversion, knownClass, schema, model);        if (datumClass != null && datumClass.isArray()) {            return new AvroArrayConverter(parent, type.asGroupType(), schema, model, datumClass);        } else {            return new AvroCollectionConverter(parent, type.asGroupType(), schema, model, datumClass);        }    } else if (schema.getType().equals(Schema.Type.MAP)) {        return new MapConverter(parent, type.asGroupType(), schema, model);    } else if (schema.getType().equals(Schema.Type.UNION)) {        return new AvroUnionConverter(parent, type, schema, model);    } else if (schema.getType().equals(Schema.Type.FIXED)) {        return new AvroConverters.FieldFixedConverter(parent, schema, model);    }    throw new UnsupportedOperationException(String.format("Cannot convert Avro type: %s to Parquet type: %s", schema, type));}
39b3663f487e08a11a80f3961682e21522f68ed80f129d93af3451fcac6fb3da
newStringConverter
private static Converter newStringConverter(Schema schema, GenericData model, ParentValueContainer parent)
{    Class<?> stringableClass = getStringableClass(schema, model);    if (stringableClass == String.class) {        return new FieldStringConverter(parent);    } else if (stringableClass == CharSequence.class) {        return new AvroConverters.FieldUTF8Converter(parent);    }    return new FieldStringableConverter(parent, stringableClass);}
8f58fa961a55065322d05b71decb89756f4b2613e229752a73fbbace541f4cb8
getStringableClass
private static Class<?> getStringableClass(Schema schema, GenericData model)
{    if (model instanceof SpecificData) {                boolean isMap = (schema.getType() == Schema.Type.MAP);        String stringableClass = schema.getProp(isMap ? JAVA_KEY_CLASS_PROP : JAVA_CLASS_PROP);        if (stringableClass != null) {            try {                return ClassUtils.forName(model.getClassLoader(), stringableClass);            } catch (ClassNotFoundException e) {                        }        }    }    if (ReflectData.class.isAssignableFrom(model.getClass())) {                return String.class;    }        String name = schema.getProp(STRINGABLE_PROP);    if (name == null) {        return CharSequence.class;    }    switch(GenericData.StringType.valueOf(name)) {        case String:            return String.class;        default:                        return CharSequence.class;    }}
79ac8f49ee8bdbce00cdc6438a0c464eb05e366a53fa9ccad36c75f69049e321
getDatumClass
private static Class<T> getDatumClass(Schema schema, GenericData model)
{    return getDatumClass(null, null, schema, model);}
585fcffaa0b627000e978183a2b9da36304b7b4c5b8e3c7e9942314a71aa43ae
getDatumClass
private static Class<T> getDatumClass(Conversion<?> conversion, Class<T> knownClass, Schema schema, GenericData model)
{    if (conversion != null) {                return null;    }        if (knownClass != null) {        return knownClass;    }    if (model instanceof SpecificData) {                return ((SpecificData) model).getClass(schema);    } else if (model.getClass() == GenericData.class) {        return null;    } else {                Class<? extends GenericData> modelClass = model.getClass();        Method getClassMethod;        try {            getClassMethod = modelClass.getMethod("getClass", Schema.class);        } catch (NoSuchMethodException e) {                        return null;        }        try {            return (Class<T>) getClassMethod.invoke(schema);        } catch (IllegalAccessException e) {            return null;        } catch (InvocationTargetException e) {            return null;        }    }}
401714c1da1fb5ff0f10815497d11b3e2b59a7338fb68861cc8f848ad9ea4cb4
set
protected void set(String name, int avroIndex, Object value)
{    model.setField(currentRecord, name, avroIndex, value);}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    return converters[fieldIndex];}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    this.currentRecord = (T) model.newRecord(null, avroSchema);}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    fillInDefaults();    if (parent != null) {        parent.add(currentRecord);    } else {                rootContainer.add(currentRecord);    }}
76dbc80702514f8cd97b9e74e16a059e56d4f4141269e5e1ece0812e946fb12d
fillInDefaults
private void fillInDefaults()
{    for (Map.Entry<Schema.Field, Object> entry : recordDefaults.entrySet()) {        Schema.Field f = entry.getKey();                Object defaultValue = deepCopy(f.schema(), entry.getValue());        set(f.name(), f.pos(), defaultValue);    }}
8404aec2c85fa90a21b2f6dc58232785cfb54b756638ed42ec726a3556b7c279
deepCopy
private Object deepCopy(Schema schema, Object value)
{    switch(schema.getType()) {        case BOOLEAN:        case INT:        case LONG:        case FLOAT:        case DOUBLE:            return value;        default:            return model.deepCopy(schema, value);    }}
a91f8189b0d08e8457532e5e30c30882be373589b8a9ab8bbe919104fbf2fa3f
getCurrentRecord
 T getCurrentRecord()
{    return currentRecord;}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    container.add(value);}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    return converter;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    container = newContainer();}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    parent.add(container);}
5cf9f15b9c6156cd803b69e1495d1334cb467f29315e63d42303dc7b1f40aceb
newContainer
private Collection<Object> newContainer()
{    if (containerClass == null) {        return new GenericData.Array<Object>(0, avroSchema);    } else if (containerClass.isAssignableFrom(ArrayList.class)) {        return new ArrayList<Object>();    } else {                return (Collection<Object>) ReflectData.newInstance(containerClass, avroSchema);    }}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    ElementConverter.this.element = value;}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    Preconditions.checkArgument(fieldIndex == 0, "Illegal field index: " + fieldIndex);    return elementConverter;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    element = null;}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    container.add(element);}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    return converter;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{        container.clear();}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    if (elementClass == boolean.class) {        parent.add(((BooleanArrayList) container).toBooleanArray());    } else if (elementClass == byte.class) {        parent.add(((ByteArrayList) container).toByteArray());    } else if (elementClass == char.class) {        parent.add(((CharArrayList) container).toCharArray());    } else if (elementClass == short.class) {        parent.add(((ShortArrayList) container).toShortArray());    } else if (elementClass == int.class) {        parent.add(((IntArrayList) container).toIntArray());    } else if (elementClass == long.class) {        parent.add(((LongArrayList) container).toLongArray());    } else if (elementClass == float.class) {        parent.add(((FloatArrayList) container).toFloatArray());    } else if (elementClass == double.class) {        parent.add(((DoubleArrayList) container).toDoubleArray());    } else {        parent.add(((ArrayList) container).toArray());    }}
868a342095aadfe9c3a299c85a293f7db912e7c018a45a610e881d84ced3bc76
createSetterAndContainer
private ParentValueContainer createSetterAndContainer()
{    if (elementClass == boolean.class) {        final BooleanArrayList list = new BooleanArrayList();        this.container = list;        return new ParentValueContainer() {            @Override            public void addBoolean(boolean value) {                list.add(value);            }        };    } else if (elementClass == byte.class) {        final ByteArrayList list = new ByteArrayList();        this.container = list;        return new ParentValueContainer() {            @Override            public void addByte(byte value) {                list.add(value);            }        };    } else if (elementClass == char.class) {        final CharArrayList list = new CharArrayList();        this.container = list;        return new ParentValueContainer() {            @Override            public void addChar(char value) {                list.add(value);            }        };    } else if (elementClass == short.class) {        final ShortArrayList list = new ShortArrayList();        this.container = list;        return new ParentValueContainer() {            @Override            public void addShort(short value) {                list.add(value);            }        };    } else if (elementClass == int.class) {        final IntArrayList list = new IntArrayList();        this.container = list;        return new ParentValueContainer() {            @Override            public void addInt(int value) {                list.add(value);            }        };    } else if (elementClass == long.class) {        final LongArrayList list = new LongArrayList();        this.container = list;        return new ParentValueContainer() {            @Override            public void addLong(long value) {                list.add(value);            }        };    } else if (elementClass == float.class) {        final FloatArrayList list = new FloatArrayList();        this.container = list;        return new ParentValueContainer() {            @Override            public void addFloat(float value) {                list.add(value);            }        };    } else if (elementClass == double.class) {        final DoubleArrayList list = new DoubleArrayList();        this.container = list;        return new ParentValueContainer() {            @Override            public void addDouble(double value) {                list.add(value);            }        };    } else {                final List<Object> list = new ArrayList<Object>();        this.container = list;        return new ParentValueContainer() {            @Override            public void add(Object value) {                list.add(value);            }        };    }}
23123f6657c241ab9b9f31f8efedc28a553ed91046d705121ce2667b065d6c17
addBoolean
public void addBoolean(boolean value)
{    list.add(value);}
b926da4be5d170f2cc133333efa609d1d588cc7b619987319cd74195ec655773
addByte
public void addByte(byte value)
{    list.add(value);}
c03d9c5afa3f635d73fad24205074c6728b989499b5c9146904e874a46242d84
addChar
public void addChar(char value)
{    list.add(value);}
a31950b852f8db04ea7db004745a6d1b6dab9100e6515d8b7cdd1623a4af7ef8
addShort
public void addShort(short value)
{    list.add(value);}
a2ac1f40a6e220ec515710128c8baf77a725ad0b9f1767a998f776f27fff6cf6
addInt
public void addInt(int value)
{    list.add(value);}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    list.add(value);}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    list.add(value);}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    list.add(value);}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    list.add(value);}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    isSet = true;    setter.add(value);}
b926da4be5d170f2cc133333efa609d1d588cc7b619987319cd74195ec655773
addByte
public void addByte(byte value)
{    isSet = true;    setter.addByte(value);}
23123f6657c241ab9b9f31f8efedc28a553ed91046d705121ce2667b065d6c17
addBoolean
public void addBoolean(boolean value)
{    isSet = true;    setter.addBoolean(value);}
c03d9c5afa3f635d73fad24205074c6728b989499b5c9146904e874a46242d84
addChar
public void addChar(char value)
{    isSet = true;    setter.addChar(value);}
a31950b852f8db04ea7db004745a6d1b6dab9100e6515d8b7cdd1623a4af7ef8
addShort
public void addShort(short value)
{    isSet = true;    setter.addShort(value);}
a2ac1f40a6e220ec515710128c8baf77a725ad0b9f1767a998f776f27fff6cf6
addInt
public void addInt(int value)
{    isSet = true;    setter.addInt(value);}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    isSet = true;    setter.addLong(value);}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    isSet = true;    setter.addFloat(value);}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    isSet = true;    setter.addDouble(value);}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    Preconditions.checkArgument(fieldIndex == 0, "Illegal field index: " + fieldIndex);    return elementConverter;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    isSet = false;}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    if (!isSet) {        container.add(null);    }}
44f9e5aef608c470caed96b3d36de5b0982782a084a9a8b229693eaac7cf1f98
isElementType
 static boolean isElementType(Type repeatedType, Schema elementSchema)
{    if (repeatedType.isPrimitive() || repeatedType.asGroupType().getFieldCount() > 1 || repeatedType.asGroupType().getType(0).isRepetition(REPEATED)) {                return true;    } else if (elementSchema != null && elementSchema.getType() == Schema.Type.RECORD) {        Schema schemaFromRepeated = CONVERTER.convert(repeatedType.asGroupType());        if (checkReaderWriterCompatibility(elementSchema, schemaFromRepeated).getType() == COMPATIBLE) {            return true;        }    }    return false;}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    Preconditions.checkArgument(AvroUnionConverter.this.memberValue == null, "Union is resolving to more than one type");    memberValue = value;}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    return memberConverters[fieldIndex];}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    memberValue = null;}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    parent.add(memberValue);}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    return keyValueConverter;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    this.map = newMap();}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    parent.add(map);}
95db822b489fc0145357e77c60d91f699e0da542478f475bde28fd0297233415
newMap
private Map<K, V> newMap()
{    if (mapClass == null || mapClass.isAssignableFrom(HashMap.class)) {        return new HashMap<K, V>();    } else {        return (Map<K, V>) ReflectData.newInstance(mapClass, schema);    }}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    MapKeyValueConverter.this.key = (K) value;}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    MapKeyValueConverter.this.value = (V) value;}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    if (fieldIndex == 0) {        return keyConverter;    } else if (fieldIndex == 1) {        return valueConverter;    }    throw new IllegalArgumentException("only the key (0) and value (1) fields expected: " + fieldIndex);}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    key = null;    value = null;}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    map.put(key, value);}
4da3915efeb45bd522ec756d13523540a507279d9a0b787efd2cafb4356363d1
getCurrentRecord
public T getCurrentRecord()
{    return root.getCurrentRecord();}
92fd854c4aebb01be238d83e407159211ea5cf60b5efd6fc7db8904dba13699b
getRootConverter
public GroupConverter getRootConverter()
{    return root;}
d1fd22f3110a951ebe84962c1dae38724f92c2eb896ee9088286129fa15303e0
getNonNull
public static Schema getNonNull(Schema schema)
{    if (schema.getType().equals(Schema.Type.UNION)) {        List<Schema> schemas = schema.getTypes();        if (schemas.size() == 2) {            if (schemas.get(0).getType().equals(Schema.Type.NULL)) {                return schemas.get(1);            } else if (schemas.get(1).getType().equals(Schema.Type.NULL)) {                return schemas.get(0);            } else {                return schema;            }        } else {            return schema;        }    } else {        return schema;    }}
2ce5b105ce45426e6a2fe07f81f90d83e352dd34589b2d9ea99aea8276b474e9
convert
public MessageType convert(Schema avroSchema)
{    if (!avroSchema.getType().equals(Schema.Type.RECORD)) {        throw new IllegalArgumentException("Avro schema must be a record.");    }    return new MessageType(avroSchema.getFullName(), convertFields(avroSchema.getFields()));}
dc4d57494605b5403ff4b364538f36159907d6d6acaaeccd11105cb54c8a366c
convertFields
private List<Type> convertFields(List<Schema.Field> fields)
{    List<Type> types = new ArrayList<Type>();    for (Schema.Field field : fields) {        if (field.schema().getType().equals(Schema.Type.NULL)) {                        continue;        }        types.add(convertField(field));    }    return types;}
e73b766312cf5988f43a75348c3235ca019dd84aed1742d2fa564de0e55214f0
convertField
private Type convertField(String fieldName, Schema schema)
{    return convertField(fieldName, schema, Type.Repetition.REQUIRED);}
998bcc6cb197b2d592caa9590d6524cad366de15db3e5b89d9482645b813438b
convertField
private Type convertField(String fieldName, Schema schema, Type.Repetition repetition)
{    Types.PrimitiveBuilder<PrimitiveType> builder;    Schema.Type type = schema.getType();    if (type.equals(Schema.Type.BOOLEAN)) {        builder = Types.primitive(BOOLEAN, repetition);    } else if (type.equals(Schema.Type.INT)) {        builder = Types.primitive(INT32, repetition);    } else if (type.equals(Schema.Type.LONG)) {        builder = Types.primitive(INT64, repetition);    } else if (type.equals(Schema.Type.FLOAT)) {        builder = Types.primitive(FLOAT, repetition);    } else if (type.equals(Schema.Type.DOUBLE)) {        builder = Types.primitive(DOUBLE, repetition);    } else if (type.equals(Schema.Type.BYTES)) {        builder = Types.primitive(BINARY, repetition);    } else if (type.equals(Schema.Type.STRING)) {        builder = Types.primitive(BINARY, repetition).as(stringType());    } else if (type.equals(Schema.Type.RECORD)) {        return new GroupType(repetition, fieldName, convertFields(schema.getFields()));    } else if (type.equals(Schema.Type.ENUM)) {        builder = Types.primitive(BINARY, repetition).as(enumType());    } else if (type.equals(Schema.Type.ARRAY)) {        if (writeOldListStructure) {            return ConversionPatterns.listType(repetition, fieldName, convertField("array", schema.getElementType(), REPEATED));        } else {            return ConversionPatterns.listOfElements(repetition, fieldName, convertField(AvroWriteSupport.LIST_ELEMENT_NAME, schema.getElementType()));        }    } else if (type.equals(Schema.Type.MAP)) {        Type valType = convertField("value", schema.getValueType());                return ConversionPatterns.stringKeyMapType(repetition, fieldName, valType);    } else if (type.equals(Schema.Type.FIXED)) {        builder = Types.primitive(FIXED_LEN_BYTE_ARRAY, repetition).length(schema.getFixedSize());    } else if (type.equals(Schema.Type.UNION)) {        return convertUnion(fieldName, schema, repetition);    } else {        throw new UnsupportedOperationException("Cannot convert Avro type " + type);    }            LogicalType logicalType = schema.getLogicalType();    if (logicalType != null) {        if (logicalType instanceof LogicalTypes.Decimal) {            LogicalTypes.Decimal decimal = (LogicalTypes.Decimal) logicalType;            builder = builder.as(decimalType(decimal.getScale(), decimal.getPrecision()));        } else {            LogicalTypeAnnotation annotation = convertLogicalType(logicalType);            if (annotation != null) {                builder.as(annotation);            }        }    }    return builder.named(fieldName);}
d35226389321d98473849fb9c0376472fedef29c9d2e212e99dd43be8f1ca78f
convertUnion
private Type convertUnion(String fieldName, Schema schema, Type.Repetition repetition)
{    List<Schema> nonNullSchemas = new ArrayList<Schema>(schema.getTypes().size());        boolean foundNullSchema = false;    for (Schema childSchema : schema.getTypes()) {        if (childSchema.getType().equals(Schema.Type.NULL)) {            foundNullSchema = true;            if (Type.Repetition.REQUIRED == repetition) {                repetition = Type.Repetition.OPTIONAL;            }        } else {            nonNullSchemas.add(childSchema);        }    }        switch(nonNullSchemas.size()) {        case 0:            throw new UnsupportedOperationException("Cannot convert Avro union of only nulls");        case 1:            return foundNullSchema ? convertField(fieldName, nonNullSchemas.get(0), repetition) : convertUnionToGroupType(fieldName, repetition, nonNullSchemas);        default:                        return convertUnionToGroupType(fieldName, repetition, nonNullSchemas);    }}
3c149970ec775a9eab8d088c6a95f44d7dedb82ec3ae4c9f17ac287a7add4fa8
convertUnionToGroupType
private Type convertUnionToGroupType(String fieldName, Type.Repetition repetition, List<Schema> nonNullSchemas)
{    List<Type> unionTypes = new ArrayList<Type>(nonNullSchemas.size());    int index = 0;    for (Schema childSchema : nonNullSchemas) {        unionTypes.add(convertField("member" + index++, childSchema, Type.Repetition.OPTIONAL));    }    return new GroupType(repetition, fieldName, unionTypes);}
903aae736292c1eb33a65fe85f504f0dc6095c82c33d765760c9a81ae9931bdd
convertField
private Type convertField(Schema.Field field)
{    return convertField(field.name(), field.schema());}
38ace24c9bd153a8567c7188c299bf16c4a4aa264c03c6b973580a452d006bc8
convert
public Schema convert(MessageType parquetSchema)
{    return convertFields(parquetSchema.getName(), parquetSchema.getFields(), new HashMap<>());}
2316520d89b64591adaaecfc3a29327e2474daede8d680a0f21ca51863f0b99e
convert
 Schema convert(GroupType parquetSchema)
{    return convertFields(parquetSchema.getName(), parquetSchema.getFields(), new HashMap<>());}
a240fae269f4c05754ad5b8c29d3747e7a343decf596addab037b9940782a9ba
convertFields
private Schema convertFields(String name, List<Type> parquetFields, Map<String, Integer> names)
{    List<Schema.Field> fields = new ArrayList<Schema.Field>();    Integer nameCount = names.merge(name, 1, (oldValue, value) -> oldValue + 1);    for (Type parquetType : parquetFields) {        Schema fieldSchema = convertField(parquetType, names);        if (parquetType.isRepetition(REPEATED)) {            throw new UnsupportedOperationException("REPEATED not supported outside LIST or MAP. Type: " + parquetType);        } else if (parquetType.isRepetition(Type.Repetition.OPTIONAL)) {            fields.add(new Schema.Field(parquetType.getName(), optional(fieldSchema), null, NULL_VALUE));        } else {                        fields.add(new Schema.Field(parquetType.getName(), fieldSchema, null, (Object) null));        }    }    Schema schema = Schema.createRecord(name, null, nameCount > 1 ? name + nameCount : null, false);    schema.setFields(fields);    return schema;}
c6f13bce156a3474c76668cf35007fc239400f02e406c8b8fc6b95bbccd853e3
convertField
private Schema convertField(final Type parquetType, Map<String, Integer> names)
{    if (parquetType.isPrimitive()) {        final PrimitiveType asPrimitive = parquetType.asPrimitiveType();        final PrimitiveTypeName parquetPrimitiveTypeName = asPrimitive.getPrimitiveTypeName();        final LogicalTypeAnnotation annotation = parquetType.getLogicalTypeAnnotation();        Schema schema = parquetPrimitiveTypeName.convert(new PrimitiveType.PrimitiveTypeNameConverter<Schema, RuntimeException>() {            @Override            public Schema convertBOOLEAN(PrimitiveTypeName primitiveTypeName) {                return Schema.create(Schema.Type.BOOLEAN);            }            @Override            public Schema convertINT32(PrimitiveTypeName primitiveTypeName) {                return Schema.create(Schema.Type.INT);            }            @Override            public Schema convertINT64(PrimitiveTypeName primitiveTypeName) {                return Schema.create(Schema.Type.LONG);            }            @Override            public Schema convertINT96(PrimitiveTypeName primitiveTypeName) {                throw new IllegalArgumentException("INT96 not implemented and is deprecated");            }            @Override            public Schema convertFLOAT(PrimitiveTypeName primitiveTypeName) {                return Schema.create(Schema.Type.FLOAT);            }            @Override            public Schema convertDOUBLE(PrimitiveTypeName primitiveTypeName) {                return Schema.create(Schema.Type.DOUBLE);            }            @Override            public Schema convertFIXED_LEN_BYTE_ARRAY(PrimitiveTypeName primitiveTypeName) {                int size = parquetType.asPrimitiveType().getTypeLength();                return Schema.createFixed(parquetType.getName(), null, null, size);            }            @Override            public Schema convertBINARY(PrimitiveTypeName primitiveTypeName) {                if (annotation instanceof LogicalTypeAnnotation.StringLogicalTypeAnnotation || annotation instanceof LogicalTypeAnnotation.EnumLogicalTypeAnnotation) {                    return Schema.create(Schema.Type.STRING);                } else {                    return Schema.create(Schema.Type.BYTES);                }            }        });        LogicalType logicalType = convertLogicalType(annotation);        if (logicalType != null && (!(annotation instanceof LogicalTypeAnnotation.DecimalLogicalTypeAnnotation) || parquetPrimitiveTypeName == BINARY || parquetPrimitiveTypeName == FIXED_LEN_BYTE_ARRAY)) {            schema = logicalType.addToSchema(schema);        }        return schema;    } else {        GroupType parquetGroupType = parquetType.asGroupType();        LogicalTypeAnnotation logicalTypeAnnotation = parquetGroupType.getLogicalTypeAnnotation();        if (logicalTypeAnnotation != null) {            return logicalTypeAnnotation.accept(new LogicalTypeAnnotation.LogicalTypeAnnotationVisitor<Schema>() {                @Override                public Optional<Schema> visit(LogicalTypeAnnotation.ListLogicalTypeAnnotation listLogicalType) {                    if (parquetGroupType.getFieldCount() != 1) {                        throw new UnsupportedOperationException("Invalid list type " + parquetGroupType);                    }                    Type repeatedType = parquetGroupType.getType(0);                    if (!repeatedType.isRepetition(REPEATED)) {                        throw new UnsupportedOperationException("Invalid list type " + parquetGroupType);                    }                    if (isElementType(repeatedType, parquetGroupType.getName())) {                                                return of(Schema.createArray(convertField(repeatedType, names)));                    } else {                        Type elementType = repeatedType.asGroupType().getType(0);                        if (elementType.isRepetition(Type.Repetition.OPTIONAL)) {                            return of(Schema.createArray(optional(convertField(elementType, names))));                        } else {                            return of(Schema.createArray(convertField(elementType, names)));                        }                    }                }                @Override                public                 Optional<Schema> visit(LogicalTypeAnnotation.MapKeyValueTypeAnnotation mapKeyValueLogicalType) {                    return visitMapOrMapKeyValue();                }                @Override                public Optional<Schema> visit(LogicalTypeAnnotation.MapLogicalTypeAnnotation mapLogicalType) {                    return visitMapOrMapKeyValue();                }                private Optional<Schema> visitMapOrMapKeyValue() {                    if (parquetGroupType.getFieldCount() != 1 || parquetGroupType.getType(0).isPrimitive()) {                        throw new UnsupportedOperationException("Invalid map type " + parquetGroupType);                    }                    GroupType mapKeyValType = parquetGroupType.getType(0).asGroupType();                    if (!mapKeyValType.isRepetition(REPEATED) || mapKeyValType.getFieldCount() != 2) {                        throw new UnsupportedOperationException("Invalid map type " + parquetGroupType);                    }                    Type keyType = mapKeyValType.getType(0);                    if (!keyType.isPrimitive() || !keyType.asPrimitiveType().getPrimitiveTypeName().equals(PrimitiveTypeName.BINARY) || !keyType.getLogicalTypeAnnotation().equals(stringType())) {                        throw new IllegalArgumentException("Map key type must be binary (UTF8): " + keyType);                    }                    Type valueType = mapKeyValType.getType(1);                    if (valueType.isRepetition(Type.Repetition.OPTIONAL)) {                        return of(Schema.createMap(optional(convertField(valueType, names))));                    } else {                        return of(Schema.createMap(convertField(valueType, names)));                    }                }                @Override                public Optional<Schema> visit(LogicalTypeAnnotation.EnumLogicalTypeAnnotation enumLogicalType) {                    return of(Schema.create(Schema.Type.STRING));                }            }).orElseThrow(() -> new UnsupportedOperationException("Cannot convert Parquet type " + parquetType));        } else {                        return convertFields(parquetGroupType.getName(), parquetGroupType.getFields(), names);        }    }}
664d519b2e64bf595021cfb8f98b81b86bf6973e47156001eeb7beabc7f13c60
convertBOOLEAN
public Schema convertBOOLEAN(PrimitiveTypeName primitiveTypeName)
{    return Schema.create(Schema.Type.BOOLEAN);}
cc9717b862235fa413fd5e011a594073281a8838eefd010cfc7f00de70758d7e
convertINT32
public Schema convertINT32(PrimitiveTypeName primitiveTypeName)
{    return Schema.create(Schema.Type.INT);}
a550089a6d00131f68e06ee09f0bdf634aca5da48d824dd54da9a8e5224d093a
convertINT64
public Schema convertINT64(PrimitiveTypeName primitiveTypeName)
{    return Schema.create(Schema.Type.LONG);}
f5565e331161b49ae8ca18098ec5dab8605d6ae14912a0edbf263595700d248e
convertINT96
public Schema convertINT96(PrimitiveTypeName primitiveTypeName)
{    throw new IllegalArgumentException("INT96 not implemented and is deprecated");}
15c4e1aea08d487647fceda13417c550bcab6d6ad69d0a9983612f81458ca452
convertFLOAT
public Schema convertFLOAT(PrimitiveTypeName primitiveTypeName)
{    return Schema.create(Schema.Type.FLOAT);}
9451baeb5c3f8b28b253205e6b80c7700b83055c3df72424694b71f2774980a2
convertDOUBLE
public Schema convertDOUBLE(PrimitiveTypeName primitiveTypeName)
{    return Schema.create(Schema.Type.DOUBLE);}
7d5dba544fafc1b4f98a71fac578ba36cbcdc4f3a1d39b3dfbbcf05106cd0e8a
convertFIXED_LEN_BYTE_ARRAY
public Schema convertFIXED_LEN_BYTE_ARRAY(PrimitiveTypeName primitiveTypeName)
{    int size = parquetType.asPrimitiveType().getTypeLength();    return Schema.createFixed(parquetType.getName(), null, null, size);}
bccd4a57d4753df4fae6d143d9cc852bd227abb3297fd2dfee94381cd27a2753
convertBINARY
public Schema convertBINARY(PrimitiveTypeName primitiveTypeName)
{    if (annotation instanceof LogicalTypeAnnotation.StringLogicalTypeAnnotation || annotation instanceof LogicalTypeAnnotation.EnumLogicalTypeAnnotation) {        return Schema.create(Schema.Type.STRING);    } else {        return Schema.create(Schema.Type.BYTES);    }}
e9f14f41c98841072cf1b256c26d5ad619dacf9cfb885ccae9d736ae22789bb5
visit
public Optional<Schema> visit(LogicalTypeAnnotation.ListLogicalTypeAnnotation listLogicalType)
{    if (parquetGroupType.getFieldCount() != 1) {        throw new UnsupportedOperationException("Invalid list type " + parquetGroupType);    }    Type repeatedType = parquetGroupType.getType(0);    if (!repeatedType.isRepetition(REPEATED)) {        throw new UnsupportedOperationException("Invalid list type " + parquetGroupType);    }    if (isElementType(repeatedType, parquetGroupType.getName())) {                return of(Schema.createArray(convertField(repeatedType, names)));    } else {        Type elementType = repeatedType.asGroupType().getType(0);        if (elementType.isRepetition(Type.Repetition.OPTIONAL)) {            return of(Schema.createArray(optional(convertField(elementType, names))));        } else {            return of(Schema.createArray(convertField(elementType, names)));        }    }}
b814511f1cec9b7f902ab0f3cda11883af40efe470f0651b886da38554203866
visit
public Optional<Schema> visit(LogicalTypeAnnotation.MapKeyValueTypeAnnotation mapKeyValueLogicalType)
{    return visitMapOrMapKeyValue();}
9b58805e7e41aeae5bc118e12d46e89a41596c7059c1f940d4042ce7da66150f
visit
public Optional<Schema> visit(LogicalTypeAnnotation.MapLogicalTypeAnnotation mapLogicalType)
{    return visitMapOrMapKeyValue();}
5616807a1bd33d1c065aa41d88badd17ebc90e625640a558f4d6e3b8a9438dd5
visitMapOrMapKeyValue
private Optional<Schema> visitMapOrMapKeyValue()
{    if (parquetGroupType.getFieldCount() != 1 || parquetGroupType.getType(0).isPrimitive()) {        throw new UnsupportedOperationException("Invalid map type " + parquetGroupType);    }    GroupType mapKeyValType = parquetGroupType.getType(0).asGroupType();    if (!mapKeyValType.isRepetition(REPEATED) || mapKeyValType.getFieldCount() != 2) {        throw new UnsupportedOperationException("Invalid map type " + parquetGroupType);    }    Type keyType = mapKeyValType.getType(0);    if (!keyType.isPrimitive() || !keyType.asPrimitiveType().getPrimitiveTypeName().equals(PrimitiveTypeName.BINARY) || !keyType.getLogicalTypeAnnotation().equals(stringType())) {        throw new IllegalArgumentException("Map key type must be binary (UTF8): " + keyType);    }    Type valueType = mapKeyValType.getType(1);    if (valueType.isRepetition(Type.Repetition.OPTIONAL)) {        return of(Schema.createMap(optional(convertField(valueType, names))));    } else {        return of(Schema.createMap(convertField(valueType, names)));    }}
ad293218f26af8a55b6e2a19828448aa962b06ac3f88c315c637ce536b25b446
visit
public Optional<Schema> visit(LogicalTypeAnnotation.EnumLogicalTypeAnnotation enumLogicalType)
{    return of(Schema.create(Schema.Type.STRING));}
83ab41c7216d587f8a1e50d1edb4bfafc697a7b68ffecc68a95c68c0c2ebe48a
convertLogicalType
private LogicalTypeAnnotation convertLogicalType(LogicalType logicalType)
{    if (logicalType == null) {        return null;    } else if (logicalType instanceof LogicalTypes.Decimal) {        LogicalTypes.Decimal decimal = (LogicalTypes.Decimal) logicalType;        return decimalType(decimal.getScale(), decimal.getPrecision());    } else if (logicalType instanceof LogicalTypes.Date) {        return dateType();    } else if (logicalType instanceof LogicalTypes.TimeMillis) {        return timeType(true, MILLIS);    } else if (logicalType instanceof LogicalTypes.TimeMicros) {        return timeType(true, MICROS);    } else if (logicalType instanceof LogicalTypes.TimestampMillis) {        return timestampType(true, MILLIS);    } else if (logicalType instanceof LogicalTypes.TimestampMicros) {        return timestampType(true, MICROS);    }    return null;}
2e2fe59410cc5bef828ae7d4a2203b7d879b0c7c15ac5020615b982cbf6e87d3
convertLogicalType
private LogicalType convertLogicalType(LogicalTypeAnnotation annotation)
{    if (annotation == null) {        return null;    }    return annotation.accept(new LogicalTypeAnnotation.LogicalTypeAnnotationVisitor<LogicalType>() {        @Override        public Optional<LogicalType> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType) {            return of(LogicalTypes.decimal(decimalLogicalType.getPrecision(), decimalLogicalType.getScale()));        }        @Override        public Optional<LogicalType> visit(LogicalTypeAnnotation.DateLogicalTypeAnnotation dateLogicalType) {            return of(LogicalTypes.date());        }        @Override        public Optional<LogicalType> visit(LogicalTypeAnnotation.TimeLogicalTypeAnnotation timeLogicalType) {            LogicalTypeAnnotation.TimeUnit unit = timeLogicalType.getUnit();            switch(unit) {                case MILLIS:                    return of(LogicalTypes.timeMillis());                case MICROS:                    return of(LogicalTypes.timeMicros());            }            return empty();        }        @Override        public Optional<LogicalType> visit(LogicalTypeAnnotation.TimestampLogicalTypeAnnotation timestampLogicalType) {            LogicalTypeAnnotation.TimeUnit unit = timestampLogicalType.getUnit();            switch(unit) {                case MILLIS:                    return of(LogicalTypes.timestampMillis());                case MICROS:                    return of(LogicalTypes.timestampMicros());            }            return empty();        }    }).orElse(null);}
4e3940c686e8391cc577ede4ca9baa684399c88b0b422caf0021ee1e6e49acfe
visit
public Optional<LogicalType> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType)
{    return of(LogicalTypes.decimal(decimalLogicalType.getPrecision(), decimalLogicalType.getScale()));}
68d8812694b9c21b619a29391ea8fe53fcf02037012f68c82c337e370df0dd35
visit
public Optional<LogicalType> visit(LogicalTypeAnnotation.DateLogicalTypeAnnotation dateLogicalType)
{    return of(LogicalTypes.date());}
ef25f619b4117fcaaee5de1050bedea0698ed975dac1bd6e2185a81f15716fae
visit
public Optional<LogicalType> visit(LogicalTypeAnnotation.TimeLogicalTypeAnnotation timeLogicalType)
{    LogicalTypeAnnotation.TimeUnit unit = timeLogicalType.getUnit();    switch(unit) {        case MILLIS:            return of(LogicalTypes.timeMillis());        case MICROS:            return of(LogicalTypes.timeMicros());    }    return empty();}
8dd441a7209df906fdac4e302254eabe3e4b356b046152db0f22a95e720a3dbb
visit
public Optional<LogicalType> visit(LogicalTypeAnnotation.TimestampLogicalTypeAnnotation timestampLogicalType)
{    LogicalTypeAnnotation.TimeUnit unit = timestampLogicalType.getUnit();    switch(unit) {        case MILLIS:            return of(LogicalTypes.timestampMillis());        case MICROS:            return of(LogicalTypes.timestampMicros());    }    return empty();}
ca5f7d5c802b7e3ff314d8e9c0cb7d9e7a5c448eb326c1c9a5475031b8686c75
isElementType
private boolean isElementType(Type repeatedType, String parentName)
{    return (    repeatedType.isPrimitive() || repeatedType.asGroupType().getFieldCount() > 1 || repeatedType.asGroupType().getType(0).isRepetition(REPEATED) ||     repeatedType.getName().equals("array") || repeatedType.getName().equals(parentName + "_tuple") ||     assumeRepeatedIsListElement);}
432d4ff5c4bd6c528d254f13b6ed4d3051aedd6d0b8fd1d92bcc8a385f2ee3a4
optional
private static Schema optional(Schema original)
{        return Schema.createUnion(Arrays.asList(Schema.create(Schema.Type.NULL), original));}
54d4243555c7a3e0d36add5d9bdc4435eb94093183db0c892a09d07d8256d73f
setAvroDataSupplier
public static void setAvroDataSupplier(Configuration configuration, Class<? extends AvroDataSupplier> suppClass)
{    configuration.set(AVRO_DATA_SUPPLIER, suppClass.getName());}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "avro";}
183990e1fab8329247b702104680c3ec86682aaf8bd87345a37656848ea6727f
setSchema
public static void setSchema(Configuration configuration, Schema schema)
{    configuration.set(AVRO_SCHEMA, schema.toString());}
89835da140a91d5cb5181a85b8db073a92d794e99966f7422502dbb7d5467b7c
init
public WriteContext init(Configuration configuration)
{    if (rootAvroSchema == null) {        this.rootAvroSchema = new Schema.Parser().parse(configuration.get(AVRO_SCHEMA));        this.rootSchema = new AvroSchemaConverter().convert(rootAvroSchema);    }    if (model == null) {        this.model = getDataModel(configuration);    }    boolean writeOldListStructure = configuration.getBoolean(WRITE_OLD_LIST_STRUCTURE, WRITE_OLD_LIST_STRUCTURE_DEFAULT);    if (writeOldListStructure) {        this.listWriter = new TwoLevelListWriter();    } else {        this.listWriter = new ThreeLevelListWriter();    }    Map<String, String> extraMetaData = new HashMap<String, String>();    extraMetaData.put(AvroReadSupport.AVRO_SCHEMA_METADATA_KEY, rootAvroSchema.toString());    return new WriteContext(rootSchema, extraMetaData);}
da9aef78cf181856102b820ffa7d5248e8581747b3f0670a7b049c4649b962ef
prepareForWrite
public void prepareForWrite(RecordConsumer recordConsumer)
{    this.recordConsumer = recordConsumer;}
2c967af6bebf751a68523fb4e89e22a07f3e285a163dc2581a7bbe4170bfb7ff
write
public void write(IndexedRecord record)
{    write((T) record);}
e1dbc5a450a06f22ce2d7d2253403253153e3053cbf43f22851c97af786390af
write
public void write(T record)
{    if (rootLogicalType != null) {        Conversion<?> conversion = model.getConversionByClass(record.getClass(), rootLogicalType);        recordConsumer.startMessage();        writeRecordFields(rootSchema, rootAvroSchema, convert(rootAvroSchema, rootLogicalType, conversion, record));        recordConsumer.endMessage();    } else {        recordConsumer.startMessage();        writeRecordFields(rootSchema, rootAvroSchema, record);        recordConsumer.endMessage();    }}
20c407d37d60da64c9d12c13f806c496d80b9c74a4be45d98a3766884094605b
writeRecord
private void writeRecord(GroupType schema, Schema avroSchema, Object record)
{    recordConsumer.startGroup();    writeRecordFields(schema, avroSchema, record);    recordConsumer.endGroup();}
1362ba90b4efa6240f78dc635c08a9e7e099ed9016d1459d52cd02f0372e7b9e
writeRecordFields
private void writeRecordFields(GroupType schema, Schema avroSchema, Object record)
{    List<Type> fields = schema.getFields();    List<Schema.Field> avroFields = avroSchema.getFields();        int index = 0;    for (int avroIndex = 0; avroIndex < avroFields.size(); avroIndex++) {        Schema.Field avroField = avroFields.get(avroIndex);        if (avroField.schema().getType().equals(Schema.Type.NULL)) {            continue;        }        Type fieldType = fields.get(index);        Object value = model.getField(record, avroField.name(), avroIndex);        if (value != null) {            recordConsumer.startField(fieldType.getName(), index);            writeValue(fieldType, avroField.schema(), value);            recordConsumer.endField(fieldType.getName(), index);        } else if (fieldType.isRepetition(Type.Repetition.REQUIRED)) {            throw new RuntimeException("Null-value for required field: " + avroField.name());        }        index++;    }}
b800d657dd02a6c7af8722686016955431d3a5853433360e8e6f609915e82c7d
writeMap
private void writeMap(GroupType schema, Schema avroSchema, Map<CharSequence, V> map)
{    GroupType innerGroup = schema.getType(0).asGroupType();    Type keyType = innerGroup.getType(0);    Type valueType = innerGroup.getType(1);        recordConsumer.startGroup();    if (map.size() > 0) {        recordConsumer.startField(MAP_REPEATED_NAME, 0);        for (Map.Entry<CharSequence, V> entry : map.entrySet()) {                        recordConsumer.startGroup();            recordConsumer.startField(MAP_KEY_NAME, 0);            writeValue(keyType, MAP_KEY_SCHEMA, entry.getKey());            recordConsumer.endField(MAP_KEY_NAME, 0);            V value = entry.getValue();            if (value != null) {                recordConsumer.startField(MAP_VALUE_NAME, 1);                writeValue(valueType, avroSchema.getValueType(), value);                recordConsumer.endField(MAP_VALUE_NAME, 1);            } else if (!valueType.isRepetition(Type.Repetition.OPTIONAL)) {                throw new RuntimeException("Null map value for " + avroSchema.getName());            }            recordConsumer.endGroup();        }        recordConsumer.endField(MAP_REPEATED_NAME, 0);    }    recordConsumer.endGroup();}
a7bc22495a2fd33cbd87f102a199f2c77c748b31fc71484708fee0ee32638b52
writeUnion
private void writeUnion(GroupType parquetSchema, Schema avroSchema, Object value)
{    recordConsumer.startGroup();            int avroIndex = model.resolveUnion(avroSchema, value);        GroupType parquetGroup = parquetSchema.asGroupType();    int parquetIndex = avroIndex;    for (int i = 0; i < avroIndex; i++) {        if (avroSchema.getTypes().get(i).getType().equals(Schema.Type.NULL)) {            parquetIndex--;        }    }                String memberName = "member" + parquetIndex;    recordConsumer.startField(memberName, parquetIndex);    writeValue(parquetGroup.getType(parquetIndex), avroSchema.getTypes().get(avroIndex), value);    recordConsumer.endField(memberName, parquetIndex);    recordConsumer.endGroup();}
2a655caf529372e354cdc7d9a5c6c77c15e4571cbee612f1f80724e94b1f4454
writeValue
private void writeValue(Type type, Schema avroSchema, Object value)
{    Schema nonNullAvroSchema = AvroSchemaConverter.getNonNull(avroSchema);    LogicalType logicalType = nonNullAvroSchema.getLogicalType();    if (logicalType != null) {        Conversion<?> conversion = model.getConversionByClass(value.getClass(), logicalType);        writeValueWithoutConversion(type, nonNullAvroSchema, convert(nonNullAvroSchema, logicalType, conversion, value));    } else {        writeValueWithoutConversion(type, nonNullAvroSchema, value);    }}
4108479caae20bac0435af3dccb3224f55d89e670dddc160a5b86f1d58e77eaa
convert
private Object convert(Schema schema, LogicalType logicalType, Conversion<D> conversion, Object datum)
{    if (conversion == null) {        return datum;    }    Class<D> fromClass = conversion.getConvertedType();    switch(schema.getType()) {        case RECORD:            return conversion.toRecord(fromClass.cast(datum), schema, logicalType);        case ENUM:            return conversion.toEnumSymbol(fromClass.cast(datum), schema, logicalType);        case ARRAY:            return conversion.toArray(fromClass.cast(datum), schema, logicalType);        case MAP:            return conversion.toMap(fromClass.cast(datum), schema, logicalType);        case FIXED:            return conversion.toFixed(fromClass.cast(datum), schema, logicalType);        case STRING:            return conversion.toCharSequence(fromClass.cast(datum), schema, logicalType);        case BYTES:            return conversion.toBytes(fromClass.cast(datum), schema, logicalType);        case INT:            return conversion.toInt(fromClass.cast(datum), schema, logicalType);        case LONG:            return conversion.toLong(fromClass.cast(datum), schema, logicalType);        case FLOAT:            return conversion.toFloat(fromClass.cast(datum), schema, logicalType);        case DOUBLE:            return conversion.toDouble(fromClass.cast(datum), schema, logicalType);        case BOOLEAN:            return conversion.toBoolean(fromClass.cast(datum), schema, logicalType);    }    return datum;}
0c3aa21f61ada6faaa116121264fe2b34d58115db5c7567ba4a2b9ece59d42fa
writeValueWithoutConversion
private void writeValueWithoutConversion(Type type, Schema avroSchema, Object value)
{    switch(avroSchema.getType()) {        case BOOLEAN:            recordConsumer.addBoolean((Boolean) value);            break;        case INT:            if (value instanceof Character) {                recordConsumer.addInteger((Character) value);            } else {                recordConsumer.addInteger(((Number) value).intValue());            }            break;        case LONG:            recordConsumer.addLong(((Number) value).longValue());            break;        case FLOAT:            recordConsumer.addFloat(((Number) value).floatValue());            break;        case DOUBLE:            recordConsumer.addDouble(((Number) value).doubleValue());            break;        case FIXED:            recordConsumer.addBinary(Binary.fromReusedByteArray(((GenericFixed) value).bytes()));            break;        case BYTES:            if (value instanceof byte[]) {                recordConsumer.addBinary(Binary.fromReusedByteArray((byte[]) value));            } else {                recordConsumer.addBinary(Binary.fromReusedByteBuffer((ByteBuffer) value));            }            break;        case STRING:            recordConsumer.addBinary(fromAvroString(value));            break;        case RECORD:            writeRecord(type.asGroupType(), avroSchema, value);            break;        case ENUM:            recordConsumer.addBinary(Binary.fromString(value.toString()));            break;        case ARRAY:            listWriter.writeList(type.asGroupType(), avroSchema, value);            break;        case MAP:            writeMap(type.asGroupType(), avroSchema, (Map<CharSequence, ?>) value);            break;        case UNION:            writeUnion(type.asGroupType(), avroSchema, value);            break;    }}
596fdf6a1b9c9c856fa3ed08663ce564576061d373b7c4356a78e86a49451dde
fromAvroString
private Binary fromAvroString(Object value)
{    if (value instanceof Utf8) {        Utf8 utf8 = (Utf8) value;        return Binary.fromReusedByteArray(utf8.getBytes(), 0, utf8.getByteLength());    } else if (value instanceof CharSequence) {        return Binary.fromCharSequence((CharSequence) value);    }    return Binary.fromCharSequence(value.toString());}
80b7bf2caa4121b9301fcaaeb361417d58c3db1c86879ec5f4952130d574b7d7
getDataModel
private static GenericData getDataModel(Configuration conf)
{    Class<? extends AvroDataSupplier> suppClass = conf.getClass(AVRO_DATA_SUPPLIER, SpecificDataSupplier.class, AvroDataSupplier.class);    return ReflectionUtils.newInstance(suppClass, conf).get();}
8144756c3925b3d2582e9b9a963c4e0cf95c2fa472e191c58048a860311c1a72
writeList
public void writeList(GroupType schema, Schema avroSchema, Object value)
{        recordConsumer.startGroup();    if (value instanceof Collection) {        writeCollection(schema, avroSchema, (Collection) value);    } else {        Class<?> arrayClass = value.getClass();        Preconditions.checkArgument(arrayClass.isArray(), "Cannot write unless collection or array: " + arrayClass.getName());        writeJavaArray(schema, avroSchema, arrayClass, value);    }    recordConsumer.endGroup();}
c44ac78863ef99aebf0e91733ec71d1766be51f502e76557a66b1c334dce6e4c
writeJavaArray
public void writeJavaArray(GroupType schema, Schema avroSchema, Class<?> arrayClass, Object value)
{    Class<?> elementClass = arrayClass.getComponentType();    if (!elementClass.isPrimitive()) {        writeObjectArray(schema, avroSchema, (Object[]) value);        return;    }    switch(avroSchema.getElementType().getType()) {        case BOOLEAN:            Preconditions.checkArgument(elementClass == boolean.class, "Cannot write as boolean array: " + arrayClass.getName());            writeBooleanArray((boolean[]) value);            break;        case INT:            if (elementClass == byte.class) {                writeByteArray((byte[]) value);            } else if (elementClass == char.class) {                writeCharArray((char[]) value);            } else if (elementClass == short.class) {                writeShortArray((short[]) value);            } else if (elementClass == int.class) {                writeIntArray((int[]) value);            } else {                throw new IllegalArgumentException("Cannot write as an int array: " + arrayClass.getName());            }            break;        case LONG:            Preconditions.checkArgument(elementClass == long.class, "Cannot write as long array: " + arrayClass.getName());            writeLongArray((long[]) value);            break;        case FLOAT:            Preconditions.checkArgument(elementClass == float.class, "Cannot write as float array: " + arrayClass.getName());            writeFloatArray((float[]) value);            break;        case DOUBLE:            Preconditions.checkArgument(elementClass == double.class, "Cannot write as double array: " + arrayClass.getName());            writeDoubleArray((double[]) value);            break;        default:            throw new IllegalArgumentException("Cannot write " + avroSchema.getElementType() + " array: " + arrayClass.getName());    }}
789b5cd31b74d5e3db94ccf20ef564adc71278136adc723d66a6ba27d3059b43
writeBooleanArray
protected void writeBooleanArray(boolean[] array)
{    if (array.length > 0) {        startArray();        for (boolean element : array) {            recordConsumer.addBoolean(element);        }        endArray();    }}
5004b76ad2ad24b1c6e92b6f848409efb3523d1b959130dda6df0a4514ee7fdd
writeByteArray
protected void writeByteArray(byte[] array)
{    if (array.length > 0) {        startArray();        for (byte element : array) {            recordConsumer.addInteger(element);        }        endArray();    }}
add862e7411919cfb4942d4fcc3dbed4d9a7494952208fd53b34648af1c8c449
writeShortArray
protected void writeShortArray(short[] array)
{    if (array.length > 0) {        startArray();        for (short element : array) {            recordConsumer.addInteger(element);        }        endArray();    }}
1f2bb26e996ca36304ac5bc78169bec16084489122134ab75407addf8377c344
writeCharArray
protected void writeCharArray(char[] array)
{    if (array.length > 0) {        startArray();        for (char element : array) {            recordConsumer.addInteger(element);        }        endArray();    }}
ecf482336b67c4d264a6668a9eb32b40a40e66c343618b3f804b2b58706fdfe7
writeIntArray
protected void writeIntArray(int[] array)
{    if (array.length > 0) {        startArray();        for (int element : array) {            recordConsumer.addInteger(element);        }        endArray();    }}
d737f0d9e742e7d827695390f7f9edc9ab5002f01d0616ed9075b31de0966cd7
writeLongArray
protected void writeLongArray(long[] array)
{    if (array.length > 0) {        startArray();        for (long element : array) {            recordConsumer.addLong(element);        }        endArray();    }}
6ca39eb06afcbdddce812096ff0c0a8bc8b7e424daa82d6e2b80641da679363c
writeFloatArray
protected void writeFloatArray(float[] array)
{    if (array.length > 0) {        startArray();        for (float element : array) {            recordConsumer.addFloat(element);        }        endArray();    }}
28c7b3e6176bab8d7407b82d4bcd945566b0d365c3123d31e73db7017de7aca7
writeDoubleArray
protected void writeDoubleArray(double[] array)
{    if (array.length > 0) {        startArray();        for (double element : array) {            recordConsumer.addDouble(element);        }        endArray();    }}
5e1cc229df429d09b7941da0649a7639cc3c9e0df789cc367e7ead0e73044fff
writeCollection
public void writeCollection(GroupType schema, Schema avroSchema, Collection<?> array)
{    if (array.size() > 0) {        recordConsumer.startField(OLD_LIST_REPEATED_NAME, 0);        try {            for (Object elt : array) {                writeValue(schema.getType(0), avroSchema.getElementType(), elt);            }        } catch (NullPointerException e) {                        int i = 0;            for (Object elt : array) {                if (elt == null) {                    throw new NullPointerException("Array contains a null element at " + i + "\n" + "Set parquet.avro.write-old-list-structure=false to turn " + "on support for arrays with null elements.");                }                i += 1;            }                        throw e;        }        recordConsumer.endField(OLD_LIST_REPEATED_NAME, 0);    }}
a69228be85a1964d33cc2b416bb74318f768e583a68f88cc974cea9662eb7638
writeObjectArray
protected void writeObjectArray(GroupType type, Schema schema, Object[] array)
{    if (array.length > 0) {        recordConsumer.startField(OLD_LIST_REPEATED_NAME, 0);        try {            for (Object element : array) {                writeValue(type.getType(0), schema.getElementType(), element);            }        } catch (NullPointerException e) {                        for (int i = 0; i < array.length; i += 1) {                if (array[i] == null) {                    throw new NullPointerException("Array contains a null element at " + i + "\n" + "Set parquet.avro.write-old-list-structure=false to turn " + "on support for arrays with null elements.");                }            }                        throw e;        }        recordConsumer.endField(OLD_LIST_REPEATED_NAME, 0);    }}
3003ef025552a7a62581c931376ba6a22975a1951fe7c84bfb2c0dbec415c41a
startArray
protected void startArray()
{    recordConsumer.startField(OLD_LIST_REPEATED_NAME, 0);}
29246ba8f90fc8b533889488650853cf24dae11ef59385f53126a403f1ed7200
endArray
protected void endArray()
{    recordConsumer.endField(OLD_LIST_REPEATED_NAME, 0);}
1d5424d3182f2371402b47fb5252426b0754340b1f9417477595d1f466ae410a
writeCollection
protected void writeCollection(GroupType type, Schema schema, Collection<?> collection)
{    if (collection.size() > 0) {        recordConsumer.startField(LIST_REPEATED_NAME, 0);        GroupType repeatedType = type.getType(0).asGroupType();        Type elementType = repeatedType.getType(0);        for (Object element : collection) {                        recordConsumer.startGroup();            if (element != null) {                recordConsumer.startField(LIST_ELEMENT_NAME, 0);                writeValue(elementType, schema.getElementType(), element);                recordConsumer.endField(LIST_ELEMENT_NAME, 0);            } else if (!elementType.isRepetition(Type.Repetition.OPTIONAL)) {                throw new RuntimeException("Null list element for " + schema.getName());            }            recordConsumer.endGroup();        }        recordConsumer.endField(LIST_REPEATED_NAME, 0);    }}
a69228be85a1964d33cc2b416bb74318f768e583a68f88cc974cea9662eb7638
writeObjectArray
protected void writeObjectArray(GroupType type, Schema schema, Object[] array)
{    if (array.length > 0) {        recordConsumer.startField(LIST_REPEATED_NAME, 0);        GroupType repeatedType = type.getType(0).asGroupType();        Type elementType = repeatedType.getType(0);        for (Object element : array) {                        recordConsumer.startGroup();            if (element != null) {                recordConsumer.startField(LIST_ELEMENT_NAME, 0);                writeValue(elementType, schema.getElementType(), element);                recordConsumer.endField(LIST_ELEMENT_NAME, 0);            } else if (!elementType.isRepetition(Type.Repetition.OPTIONAL)) {                throw new RuntimeException("Null list element for " + schema.getName());            }            recordConsumer.endGroup();        }        recordConsumer.endField(LIST_REPEATED_NAME, 0);    }}
3003ef025552a7a62581c931376ba6a22975a1951fe7c84bfb2c0dbec415c41a
startArray
protected void startArray()
{    recordConsumer.startField(LIST_REPEATED_NAME, 0);        recordConsumer.startGroup();    recordConsumer.startField(LIST_ELEMENT_NAME, 0);}
29246ba8f90fc8b533889488650853cf24dae11ef59385f53126a403f1ed7200
endArray
protected void endArray()
{    recordConsumer.endField(LIST_ELEMENT_NAME, 0);    recordConsumer.endGroup();    recordConsumer.endField(LIST_REPEATED_NAME, 0);}
26d0e132486f8d7dd4288e6a839ea98c98993ec66d5cfadf66ef7a1da3288420
get
public GenericData get()
{    return GenericData.get();}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    throw new RuntimeException("[BUG] ParentValueContainer#add was not overridden");}
23123f6657c241ab9b9f31f8efedc28a553ed91046d705121ce2667b065d6c17
addBoolean
public void addBoolean(boolean value)
{    add(value);}
b926da4be5d170f2cc133333efa609d1d588cc7b619987319cd74195ec655773
addByte
public void addByte(byte value)
{    add(value);}
c03d9c5afa3f635d73fad24205074c6728b989499b5c9146904e874a46242d84
addChar
public void addChar(char value)
{    add(value);}
a31950b852f8db04ea7db004745a6d1b6dab9100e6515d8b7cdd1623a4af7ef8
addShort
public void addShort(short value)
{    add(value);}
a2ac1f40a6e220ec515710128c8baf77a725ad0b9f1767a998f776f27fff6cf6
addInt
public void addInt(int value)
{    add(value);}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    add(value);}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    add(value);}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    add(value);}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    wrapped.add(conversion.fromDouble(value, schema, logicalType));}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    wrapped.add(conversion.fromFloat(value, schema, logicalType));}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    wrapped.add(conversion.fromLong(value, schema, logicalType));}
a2ac1f40a6e220ec515710128c8baf77a725ad0b9f1767a998f776f27fff6cf6
addInt
public void addInt(int value)
{    wrapped.add(conversion.fromInt(value, schema, logicalType));}
a31950b852f8db04ea7db004745a6d1b6dab9100e6515d8b7cdd1623a4af7ef8
addShort
public void addShort(short value)
{    wrapped.add(conversion.fromInt((int) value, schema, logicalType));}
c03d9c5afa3f635d73fad24205074c6728b989499b5c9146904e874a46242d84
addChar
public void addChar(char value)
{    wrapped.add(conversion.fromInt((int) value, schema, logicalType));}
b926da4be5d170f2cc133333efa609d1d588cc7b619987319cd74195ec655773
addByte
public void addByte(byte value)
{    wrapped.add(conversion.fromInt((int) value, schema, logicalType));}
23123f6657c241ab9b9f31f8efedc28a553ed91046d705121ce2667b065d6c17
addBoolean
public void addBoolean(boolean value)
{    wrapped.add(conversion.fromBoolean(value, schema, logicalType));}
2bd28c1b6b99035dcbcd425b0baeee3de18980bc1fc991777e3581ae8ad2f9b2
getConversionContainer
 static ParentValueContainer getConversionContainer(final ParentValueContainer parent, final Conversion<?> conversion, final Schema schema)
{    if (conversion == null) {        return parent;    }    final LogicalType logicalType = schema.getLogicalType();    switch(schema.getType()) {        case STRING:            return new ParentValueContainer() {                @Override                public void add(Object value) {                    parent.add(conversion.fromCharSequence((CharSequence) value, schema, logicalType));                }            };        case BOOLEAN:            return new LogicalTypePrimitiveContainer(parent, schema, conversion) {                @Override                public void add(Object value) {                    parent.add(conversion.fromBoolean((Boolean) value, schema, logicalType));                }            };        case INT:            return new LogicalTypePrimitiveContainer(parent, schema, conversion) {                @Override                public void add(Object value) {                    parent.add(conversion.fromInt((Integer) value, schema, logicalType));                }            };        case LONG:            return new LogicalTypePrimitiveContainer(parent, schema, conversion) {                @Override                public void add(Object value) {                    parent.add(conversion.fromLong((Long) value, schema, logicalType));                }            };        case FLOAT:            return new LogicalTypePrimitiveContainer(parent, schema, conversion) {                @Override                public void add(Object value) {                    parent.add(conversion.fromFloat((Float) value, schema, logicalType));                }            };        case DOUBLE:            return new LogicalTypePrimitiveContainer(parent, schema, conversion) {                @Override                public void add(Object value) {                    parent.add(conversion.fromDouble((Double) value, schema, logicalType));                }            };        case BYTES:            return new ParentValueContainer() {                @Override                public void add(Object value) {                    parent.add(conversion.fromBytes((ByteBuffer) value, schema, logicalType));                }            };        case FIXED:            return new ParentValueContainer() {                @Override                public void add(Object value) {                    parent.add(conversion.fromFixed((GenericData.Fixed) value, schema, logicalType));                }            };        case RECORD:            return new ParentValueContainer() {                @Override                public void add(Object value) {                    parent.add(conversion.fromRecord((IndexedRecord) value, schema, logicalType));                }            };        case ARRAY:            return new ParentValueContainer() {                @Override                public void add(Object value) {                    parent.add(conversion.fromArray((Collection<?>) value, schema, logicalType));                }            };        case MAP:            return new ParentValueContainer() {                @Override                public void add(Object value) {                    parent.add(conversion.fromMap((Map<?, ?>) value, schema, logicalType));                }            };        case ENUM:            return new ParentValueContainer() {                @Override                public void add(Object value) {                    parent.add(conversion.fromEnumSymbol((GenericEnumSymbol) value, schema, logicalType));                }            };        default:            return new LogicalTypePrimitiveContainer(parent, schema, conversion);    }}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    parent.add(conversion.fromCharSequence((CharSequence) value, schema, logicalType));}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    parent.add(conversion.fromBoolean((Boolean) value, schema, logicalType));}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    parent.add(conversion.fromInt((Integer) value, schema, logicalType));}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    parent.add(conversion.fromLong((Long) value, schema, logicalType));}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    parent.add(conversion.fromFloat((Float) value, schema, logicalType));}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    parent.add(conversion.fromDouble((Double) value, schema, logicalType));}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    parent.add(conversion.fromBytes((ByteBuffer) value, schema, logicalType));}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    parent.add(conversion.fromFixed((GenericData.Fixed) value, schema, logicalType));}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    parent.add(conversion.fromRecord((IndexedRecord) value, schema, logicalType));}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    parent.add(conversion.fromArray((Collection<?>) value, schema, logicalType));}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    parent.add(conversion.fromMap((Map<?, ?>) value, schema, logicalType));}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    parent.add(conversion.fromEnumSymbol((GenericEnumSymbol) value, schema, logicalType));}
26d0e132486f8d7dd4288e6a839ea98c98993ec66d5cfadf66ef7a1da3288420
get
public GenericData get()
{    return ReflectData.get();}
26d0e132486f8d7dd4288e6a839ea98c98993ec66d5cfadf66ef7a1da3288420
get
public GenericData get()
{    return SpecificData.get();}
27e1c751edd5fcc28e960c5d7be93fde565d1978224a24ff81c3e733676071a3
record
public static Schema record(String name, String namespace, Schema.Field... fields)
{    Schema record = Schema.createRecord(name, null, namespace, false);    record.setFields(Arrays.asList(fields));    return record;}
0b47d1a1496e9c8ef83074cae3a4095e270fde37912954f16818a60113307216
record
public static Schema record(String name, Schema.Field... fields)
{    return record(name, null, fields);}
53aab1cbe16dd9b2bf36c82f486a1e5ff86c21cbddb49b910b9c34e7ebcc7cd6
field
public static Schema.Field field(String name, Schema schema)
{    return new Schema.Field(name, schema, null, null);}
0cbef8c440baed29a6177ae7493242054077fc0cecd5821212ad96c4567cec97
optionalField
public static Schema.Field optionalField(String name, Schema schema)
{    return new Schema.Field(name, optional(schema), null, JsonProperties.NULL_VALUE);}
75c4999f80e16d8fb24f98a6ec3434aeac9dac6675f622edf0620ecfd5bef92f
array
public static Schema array(Schema element)
{    return Schema.createArray(element);}
90ce5fb503e7a24c90d0256cc7bd6218c3deac0baa121ac0e6b72c04a66b8752
primitive
public static Schema primitive(Schema.Type type)
{    return Schema.create(type);}
8627784beb32dfb1469f2d71a722c05f6d7528aa551b2640947fb0ebf82d1672
optional
public static Schema optional(Schema original)
{    return Schema.createUnion(Lists.newArrayList(Schema.create(Schema.Type.NULL), original));}
9e3de8c5924871bf67f61073bc1ff46db53b8e6dd8e24e91f9a444de69397d87
instance
public static GenericRecord instance(Schema schema, Object... pairs)
{    if ((pairs.length % 2) != 0) {        throw new RuntimeException("Not enough values");    }    GenericRecord record = new GenericData.Record(schema);    for (int i = 0; i < pairs.length; i += 2) {        record.put(pairs[i].toString(), pairs[i + 1]);    }    return record;}
90b5326849df228c4722c3321ef99bda00d2915ce60e1b1a5f742c23a3bb5dde
read
public static List<D> read(GenericData model, Schema schema, File file) throws IOException
{    List<D> data = new ArrayList<D>();    Configuration conf = new Configuration(false);    AvroReadSupport.setRequestedProjection(conf, schema);    AvroReadSupport.setAvroReadSchema(conf, schema);    try (ParquetReader<D> fileReader = AvroParquetReader.<D>builder(new Path(file.toString())).withDataModel(    model).withConf(conf).build()) {        D datum;        while ((datum = fileReader.read()) != null) {            data.add(datum);        }    }    return data;}
4c88f07fa2b13aefb8f8617040ec5415f589b93357b219e01d9f39705ac19f7c
write
public static File write(TemporaryFolder temp, GenericData model, Schema schema, D... data) throws IOException
{    File file = temp.newFile();    Assert.assertTrue(file.delete());    try (ParquetWriter<D> writer = AvroParquetWriter.<D>builder(new Path(file.toString())).withDataModel(model).withSchema(schema).build()) {        for (D datum : data) {            writer.write(datum);        }    }    return file;}
2e99d685ca1232710cf0b74e5fcf3dd09f4e94ca6b3c5e9acde379e8c7a7023f
setupNewBehaviorConfiguration
public static void setupNewBehaviorConfiguration()
{    OLD_BEHAVIOR_CONF.setBoolean(AvroSchemaConverter.ADD_LIST_ELEMENT_RECORDS, true);    NEW_BEHAVIOR_CONF.setBoolean(AvroSchemaConverter.ADD_LIST_ELEMENT_RECORDS, false);}
b84ba1f9425b71b19fb7376d244eea4c319d144ae6238234341d80aba9da5302
testUnannotatedListOfPrimitives
public void testUnannotatedListOfPrimitives() throws Exception
{    Path test = writeDirect("message UnannotatedListOfPrimitives {" + "  repeated int32 list_of_ints;" + "}", rc -> {        rc.startMessage();        rc.startField("list_of_ints", 0);        rc.addInteger(34);        rc.addInteger(35);        rc.addInteger(36);        rc.endField("list_of_ints", 0);        rc.endMessage();    });    Schema expectedSchema = record("OldPrimitiveInList", field("list_of_ints", array(primitive(Schema.Type.INT))));    GenericRecord expectedRecord = instance(expectedSchema, "list_of_ints", Arrays.asList(34, 35, 36));        assertReaderContains(oldBehaviorReader(test), expectedSchema, expectedRecord);    assertReaderContains(newBehaviorReader(test), expectedSchema, expectedRecord);}
5a4baebacbd4874fdec760dafc68dba24c886301fb3991c61b4ec2abe60edce9
testUnannotatedListOfGroups
public void testUnannotatedListOfGroups() throws Exception
{    Path test = writeDirect("message UnannotatedListOfGroups {" + "  repeated group list_of_points {" + "    required float x;" + "    required float y;" + "  }" + "}", rc -> {        rc.startMessage();        rc.startField("list_of_points", 0);        rc.startGroup();        rc.startField("x", 0);        rc.addFloat(1.0f);        rc.endField("x", 0);        rc.startField("y", 1);        rc.addFloat(1.0f);        rc.endField("y", 1);        rc.endGroup();        rc.startGroup();        rc.startField("x", 0);        rc.addFloat(2.0f);        rc.endField("x", 0);        rc.startField("y", 1);        rc.addFloat(2.0f);        rc.endField("y", 1);        rc.endGroup();        rc.endField("list_of_points", 0);        rc.endMessage();    });    Schema point = record("?", field("x", primitive(Schema.Type.FLOAT)), field("y", primitive(Schema.Type.FLOAT)));    Schema expectedSchema = record("OldPrimitiveInList", field("list_of_points", array(point)));    GenericRecord expectedRecord = instance(expectedSchema, "list_of_points", Arrays.asList(instance(point, "x", 1.0f, "y", 1.0f), instance(point, "x", 2.0f, "y", 2.0f)));        assertReaderContains(oldBehaviorReader(test), expectedSchema, expectedRecord);    assertReaderContains(newBehaviorReader(test), expectedSchema, expectedRecord);}
ae247d14d731916bf43b1eb580350f39cbb8856c00aa6df59bb6a274aa3973e0
testRepeatedPrimitiveInList
public void testRepeatedPrimitiveInList() throws Exception
{    Path test = writeDirect("message RepeatedPrimitiveInList {" + "  required group list_of_ints (LIST) {" + "    repeated int32 array;" + "  }" + "}", rc -> {        rc.startMessage();        rc.startField("list_of_ints", 0);        rc.startGroup();        rc.startField("array", 0);        rc.addInteger(34);        rc.addInteger(35);        rc.addInteger(36);        rc.endField("array", 0);        rc.endGroup();        rc.endField("list_of_ints", 0);        rc.endMessage();    });    Schema expectedSchema = record("RepeatedPrimitiveInList", field("list_of_ints", array(Schema.create(Schema.Type.INT))));    GenericRecord expectedRecord = instance(expectedSchema, "list_of_ints", Arrays.asList(34, 35, 36));        assertReaderContains(oldBehaviorReader(test), expectedSchema, expectedRecord);    assertReaderContains(newBehaviorReader(test), expectedSchema, expectedRecord);}
9683c96afd0fa837c2487e739090fbe99c0943a3b54dcb5d6267f554b31ea0ba
testMultiFieldGroupInList
public void testMultiFieldGroupInList() throws Exception
{        Path test = writeDirect("message MultiFieldGroupInList {" + "  optional group locations (LIST) {" + "    repeated group element {" + "      required double latitude;" + "      required double longitude;" + "    }" + "  }" + "}", rc -> {        rc.startMessage();        rc.startField("locations", 0);        rc.startGroup();        rc.startField("element", 0);        rc.startGroup();        rc.startField("latitude", 0);        rc.addDouble(0.0);        rc.endField("latitude", 0);        rc.startField("longitude", 1);        rc.addDouble(0.0);        rc.endField("longitude", 1);        rc.endGroup();        rc.startGroup();        rc.startField("latitude", 0);        rc.addDouble(0.0);        rc.endField("latitude", 0);        rc.startField("longitude", 1);        rc.addDouble(180.0);        rc.endField("longitude", 1);        rc.endGroup();        rc.endField("element", 0);        rc.endGroup();        rc.endField("locations", 0);        rc.endMessage();    });    Schema location = record("element", field("latitude", primitive(Schema.Type.DOUBLE)), field("longitude", primitive(Schema.Type.DOUBLE)));    Schema expectedSchema = record("MultiFieldGroupInList", optionalField("locations", array(location)));    GenericRecord expectedRecord = instance(expectedSchema, "locations", Arrays.asList(instance(location, "latitude", 0.0, "longitude", 0.0), instance(location, "latitude", 0.0, "longitude", 180.0)));        assertReaderContains(oldBehaviorReader(test), expectedSchema, expectedRecord);    assertReaderContains(newBehaviorReader(test), expectedSchema, expectedRecord);}
7661fdb267d3ffb786c4aaaf78468e570aaa3f081547a61db12abaed6c764431
testSingleFieldGroupInList
public void testSingleFieldGroupInList() throws Exception
{        Path test = writeDirect("message SingleFieldGroupInList {" + "  optional group single_element_groups (LIST) {" + "    repeated group single_element_group {" + "      required int64 count;" + "    }" + "  }" + "}", rc -> {        rc.startMessage();        rc.startField("single_element_groups", 0);        rc.startGroup();                rc.startField("single_element_group", 0);        rc.startGroup();        rc.startField("count", 0);        rc.addLong(1234L);        rc.endField("count", 0);        rc.endGroup();        rc.startGroup();        rc.startField("count", 0);        rc.addLong(2345L);        rc.endField("count", 0);        rc.endGroup();                rc.endField("single_element_group", 0);        rc.endGroup();        rc.endField("single_element_groups", 0);        rc.endMessage();    });                Schema singleElementGroupSchema = record("single_element_group", field("count", primitive(Schema.Type.LONG)));    Schema oldSchema = record("SingleFieldGroupInList", optionalField("single_element_groups", array(singleElementGroupSchema)));    GenericRecord oldRecord = instance(oldSchema, "single_element_groups", Arrays.asList(instance(singleElementGroupSchema, "count", 1234L), instance(singleElementGroupSchema, "count", 2345L)));    assertReaderContains(oldBehaviorReader(test), oldSchema, oldRecord);        Schema newSchema = record("SingleFieldGroupInList", optionalField("single_element_groups", array(primitive(Schema.Type.LONG))));    GenericRecord newRecord = instance(newSchema, "single_element_groups", Arrays.asList(1234L, 2345L));    assertReaderContains(newBehaviorReader(test), newSchema, newRecord);}
af2dbd055433d2b507461a330f5ebebb8f4ba9ebf45cf5b79e5ba47e273eb039
testSingleFieldGroupInListWithSchema
public void testSingleFieldGroupInListWithSchema() throws Exception
{            Schema singleElementRecord = record("single_element_group", field("count", primitive(Schema.Type.LONG)));    Schema expectedSchema = record("SingleFieldGroupInList", optionalField("single_element_groups", array(singleElementRecord)));    Map<String, String> metadata = new HashMap<String, String>();    metadata.put(AvroWriteSupport.AVRO_SCHEMA, expectedSchema.toString());    Path test = writeDirect("message SingleFieldGroupInList {" + "  optional group single_element_groups (LIST) {" + "    repeated group single_element_group {" + "      required int64 count;" + "    }" + "  }" + "}", rc -> {        rc.startMessage();        rc.startField("single_element_groups", 0);        rc.startGroup();                rc.startField("single_element_group", 0);        rc.startGroup();        rc.startField("count", 0);        rc.addLong(1234L);        rc.endField("count", 0);        rc.endGroup();        rc.startGroup();        rc.startField("count", 0);        rc.addLong(2345L);        rc.endField("count", 0);        rc.endGroup();                rc.endField("single_element_group", 0);        rc.endGroup();        rc.endField("single_element_groups", 0);        rc.endMessage();    }, metadata);    GenericRecord expectedRecord = instance(expectedSchema, "single_element_groups", Arrays.asList(instance(singleElementRecord, "count", 1234L), instance(singleElementRecord, "count", 2345L)));        assertReaderContains(oldBehaviorReader(test), expectedSchema, expectedRecord);    assertReaderContains(newBehaviorReader(test), expectedSchema, expectedRecord);}
3a3a31b1888e62287391186f67d9124844f06223abfb349935f59c47a4b895e9
testNewOptionalGroupInList
public void testNewOptionalGroupInList() throws Exception
{    Path test = writeDirect("message NewOptionalGroupInList {" + "  optional group locations (LIST) {" + "    repeated group list {" + "      optional group element {" + "        required double latitude;" + "        required double longitude;" + "      }" + "    }" + "  }" + "}", rc -> {        rc.startMessage();        rc.startField("locations", 0);        rc.startGroup();                rc.startField("list", 0);                        rc.startGroup();        rc.startField("element", 0);        rc.startGroup();        rc.startField("latitude", 0);        rc.addDouble(0.0);        rc.endField("latitude", 0);        rc.startField("longitude", 1);        rc.addDouble(0.0);        rc.endField("longitude", 1);        rc.endGroup();        rc.endField("element", 0);                rc.endGroup();                        rc.startGroup();                rc.endGroup();                        rc.startGroup();        rc.startField("element", 0);        rc.startGroup();        rc.startField("latitude", 0);        rc.addDouble(0.0);        rc.endField("latitude", 0);        rc.startField("longitude", 1);        rc.addDouble(180.0);        rc.endField("longitude", 1);        rc.endGroup();        rc.endField("element", 0);                rc.endGroup();                rc.endField("list", 0);        rc.endGroup();        rc.endField("locations", 0);        rc.endMessage();    });    Schema location = record("element", field("latitude", primitive(Schema.Type.DOUBLE)), field("longitude", primitive(Schema.Type.DOUBLE)));        Schema elementRecord = record("list", optionalField("element", location));    Schema oldSchema = record("NewOptionalGroupInList", optionalField("locations", array(elementRecord)));    GenericRecord oldRecord = instance(oldSchema, "locations", Arrays.asList(instance(elementRecord, "element", instance(location, "latitude", 0.0, "longitude", 0.0)), instance(elementRecord), instance(elementRecord, "element", instance(location, "latitude", 0.0, "longitude", 180.0))));    assertReaderContains(oldBehaviorReader(test), oldSchema, oldRecord);        Schema newSchema = record("NewOptionalGroupInList", optionalField("locations", array(optional(location))));    GenericRecord newRecord = instance(newSchema, "locations", Arrays.asList(instance(location, "latitude", 0.0, "longitude", 0.0), null, instance(location, "latitude", 0.0, "longitude", 180.0)));    assertReaderContains(newBehaviorReader(test), newSchema, newRecord);}
53d979a675586bbb9135b8b6a0eebf188ac9aca7389bf934dc0a01b609d2a809
testNewRequiredGroupInList
public void testNewRequiredGroupInList() throws Exception
{    Path test = writeDirect("message NewRequiredGroupInList {" + "  optional group locations (LIST) {" + "    repeated group list {" + "      required group element {" + "        required double latitude;" + "        required double longitude;" + "      }" + "    }" + "  }" + "}", rc -> {        rc.startMessage();        rc.startField("locations", 0);        rc.startGroup();                rc.startField("list", 0);                        rc.startGroup();        rc.startField("element", 0);        rc.startGroup();        rc.startField("latitude", 0);        rc.addDouble(0.0);        rc.endField("latitude", 0);        rc.startField("longitude", 1);        rc.addDouble(180.0);        rc.endField("longitude", 1);        rc.endGroup();        rc.endField("element", 0);                rc.endGroup();                        rc.startGroup();        rc.startField("element", 0);        rc.startGroup();        rc.startField("latitude", 0);        rc.addDouble(0.0);        rc.endField("latitude", 0);        rc.startField("longitude", 1);        rc.addDouble(0.0);        rc.endField("longitude", 1);        rc.endGroup();        rc.endField("element", 0);                rc.endGroup();                rc.endField("list", 0);        rc.endGroup();        rc.endField("locations", 0);        rc.endMessage();    });    Schema location = record("element", field("latitude", primitive(Schema.Type.DOUBLE)), field("longitude", primitive(Schema.Type.DOUBLE)));        Schema elementRecord = record("list", field("element", location));    Schema oldSchema = record("NewRequiredGroupInList", optionalField("locations", array(elementRecord)));    GenericRecord oldRecord = instance(oldSchema, "locations", Arrays.asList(instance(elementRecord, "element", instance(location, "latitude", 0.0, "longitude", 180.0)), instance(elementRecord, "element", instance(location, "latitude", 0.0, "longitude", 0.0))));    assertReaderContains(oldBehaviorReader(test), oldSchema, oldRecord);        Schema newSchema = record("NewRequiredGroupInList", optionalField("locations", array(location)));    GenericRecord newRecord = instance(newSchema, "locations", Arrays.asList(instance(location, "latitude", 0.0, "longitude", 180.0), instance(location, "latitude", 0.0, "longitude", 0.0)));    assertReaderContains(newBehaviorReader(test), newSchema, newRecord);}
10097ae59fcdd1b794b21187f3098912595bb7c5d1989afe7b6393ba6f83976d
testAvroCompatOptionalGroupInList
public void testAvroCompatOptionalGroupInList() throws Exception
{    Path test = writeDirect("message AvroCompatOptionalGroupInList {" + "  optional group locations (LIST) {" + "    repeated group array {" + "      optional group element {" + "        required double latitude;" + "        required double longitude;" + "      }" + "    }" + "  }" + "}", rc -> {        rc.startMessage();        rc.startField("locations", 0);        rc.startGroup();                rc.startField("array", 0);                        rc.startGroup();        rc.startField("element", 0);        rc.startGroup();        rc.startField("latitude", 0);        rc.addDouble(0.0);        rc.endField("latitude", 0);        rc.startField("longitude", 1);        rc.addDouble(180.0);        rc.endField("longitude", 1);        rc.endGroup();        rc.endField("element", 0);                rc.endGroup();                        rc.startGroup();        rc.startField("element", 0);        rc.startGroup();        rc.startField("latitude", 0);        rc.addDouble(0.0);        rc.endField("latitude", 0);        rc.startField("longitude", 1);        rc.addDouble(0.0);        rc.endField("longitude", 1);        rc.endGroup();        rc.endField("element", 0);                rc.endGroup();                rc.endField("array", 0);        rc.endGroup();        rc.endField("locations", 0);        rc.endMessage();    });    Schema location = record("element", field("latitude", primitive(Schema.Type.DOUBLE)), field("longitude", primitive(Schema.Type.DOUBLE)));        Schema elementRecord = record("array", optionalField("element", location));    Schema oldSchema = record("AvroCompatOptionalGroupInList", optionalField("locations", array(elementRecord)));    GenericRecord oldRecord = instance(oldSchema, "locations", Arrays.asList(instance(elementRecord, "element", instance(location, "latitude", 0.0, "longitude", 180.0)), instance(elementRecord, "element", instance(location, "latitude", 0.0, "longitude", 0.0))));        assertReaderContains(oldBehaviorReader(test), oldSchema, oldRecord);    assertReaderContains(newBehaviorReader(test), oldSchema, oldRecord);}
15946cbfcf3d85602d918e2db74b18208d29655cdb61d7ecb670a256ac1716a2
testAvroCompatOptionalGroupInListWithSchema
public void testAvroCompatOptionalGroupInListWithSchema() throws Exception
{    Path test = writeDirect("message AvroCompatOptionalGroupInListWithSchema {" + "  optional group locations (LIST) {" + "    repeated group array {" + "      optional group element {" + "        required double latitude;" + "        required double longitude;" + "      }" + "    }" + "  }" + "}", rc -> {        rc.startMessage();        rc.startField("locations", 0);        rc.startGroup();                rc.startField("array", 0);                        rc.startGroup();        rc.startField("element", 0);        rc.startGroup();        rc.startField("latitude", 0);        rc.addDouble(0.0);        rc.endField("latitude", 0);        rc.startField("longitude", 1);        rc.addDouble(180.0);        rc.endField("longitude", 1);        rc.endGroup();        rc.endField("element", 0);                rc.endGroup();                        rc.startGroup();        rc.startField("element", 0);        rc.startGroup();        rc.startField("latitude", 0);        rc.addDouble(0.0);        rc.endField("latitude", 0);        rc.startField("longitude", 1);        rc.addDouble(0.0);        rc.endField("longitude", 1);        rc.endGroup();        rc.endField("element", 0);                rc.endGroup();                rc.endField("array", 0);        rc.endGroup();        rc.endField("locations", 0);        rc.endMessage();    });    Schema location = record("element", field("latitude", primitive(Schema.Type.DOUBLE)), field("longitude", primitive(Schema.Type.DOUBLE)));    Schema newSchema = record("AvroCompatOptionalGroupInListWithSchema", optionalField("locations", array(optional(location))));    GenericRecord newRecord = instance(newSchema, "locations", Arrays.asList(instance(location, "latitude", 0.0, "longitude", 180.0), instance(location, "latitude", 0.0, "longitude", 0.0)));    Configuration oldConfWithSchema = new Configuration();    AvroReadSupport.setAvroReadSchema(oldConfWithSchema, newSchema);        assertReaderContains(new AvroParquetReader<GenericRecord>(oldConfWithSchema, test), newSchema, newRecord);    Configuration newConfWithSchema = new Configuration(NEW_BEHAVIOR_CONF);    AvroReadSupport.setAvroReadSchema(newConfWithSchema, newSchema);    assertReaderContains(new AvroParquetReader<GenericRecord>(newConfWithSchema, test), newSchema, newRecord);}
9a2a5458406b514c2e60fc76cb763e411078c178f20a615a91d139e9fe114748
testAvroCompatListInList
public void testAvroCompatListInList() throws Exception
{    Path test = writeDirect("message AvroCompatListInList {" + "  optional group listOfLists (LIST) {" + "    repeated group array (LIST) {" + "      repeated int32 array;" + "    }" + "  }" + "}", rc -> {        rc.startMessage();        rc.startField("locations", 0);        rc.startGroup();                rc.startField("array", 0);        rc.startGroup();                rc.startField("array", 0);                rc.addInteger(34);        rc.addInteger(35);        rc.addInteger(36);                rc.endField("array", 0);        rc.endGroup();                rc.startGroup();        rc.endGroup();        rc.startGroup();                rc.startField("array", 0);                rc.addInteger(32);        rc.addInteger(33);        rc.addInteger(34);                rc.endField("array", 0);        rc.endGroup();                rc.endField("array", 0);        rc.endGroup();        rc.endField("locations", 0);        rc.endMessage();    });    Schema listOfLists = array(array(primitive(Schema.Type.INT)));    Schema oldSchema = record("AvroCompatListInList", optionalField("listOfLists", listOfLists));    GenericRecord oldRecord = instance(oldSchema, "listOfLists", Arrays.asList(Arrays.asList(34, 35, 36), Arrays.asList(), Arrays.asList(32, 33, 34)));        assertReaderContains(oldBehaviorReader(test), oldSchema, oldRecord);    assertReaderContains(newBehaviorReader(test), oldSchema, oldRecord);}
0964274048380c008e2f618d79188c8d77ab9f73a6c6d4e172e5d2cfac1ef6a9
testThriftCompatListInList
public void testThriftCompatListInList() throws Exception
{    Path test = writeDirect("message ThriftCompatListInList {" + "  optional group listOfLists (LIST) {" + "    repeated group listOfLists_tuple (LIST) {" + "      repeated int32 listOfLists_tuple_tuple;" + "    }" + "  }" + "}", rc -> {        rc.startMessage();        rc.startField("locations", 0);        rc.startGroup();                rc.startField("listOfLists_tuple", 0);        rc.startGroup();                rc.startField("listOfLists_tuple_tuple", 0);                rc.addInteger(34);        rc.addInteger(35);        rc.addInteger(36);                rc.endField("listOfLists_tuple_tuple", 0);        rc.endGroup();                rc.startGroup();        rc.endGroup();        rc.startGroup();                rc.startField("listOfLists_tuple_tuple", 0);                rc.addInteger(32);        rc.addInteger(33);        rc.addInteger(34);                rc.endField("listOfLists_tuple_tuple", 0);        rc.endGroup();                rc.endField("listOfLists_tuple", 0);        rc.endGroup();        rc.endField("locations", 0);        rc.endMessage();    });    Schema listOfLists = array(array(primitive(Schema.Type.INT)));    Schema oldSchema = record("ThriftCompatListInList", optionalField("listOfLists", listOfLists));    GenericRecord oldRecord = instance(oldSchema, "listOfLists", Arrays.asList(Arrays.asList(34, 35, 36), Arrays.asList(), Arrays.asList(32, 33, 34)));        assertReaderContains(oldBehaviorReader(test), oldSchema, oldRecord);    assertReaderContains(newBehaviorReader(test), oldSchema, oldRecord);}
43603572b56a88d379532443ca5e0e0c458a51311e8cb979e5c4d7087be9fd64
testThriftCompatRequiredGroupInList
public void testThriftCompatRequiredGroupInList() throws Exception
{    Path test = writeDirect("message ThriftCompatRequiredGroupInList {" + "  optional group locations (LIST) {" + "    repeated group locations_tuple {" + "      optional group element {" + "        required double latitude;" + "        required double longitude;" + "      }" + "    }" + "  }" + "}", rc -> {        rc.startMessage();        rc.startField("locations", 0);        rc.startGroup();                rc.startField("locations_tuple", 0);                        rc.startGroup();        rc.startField("element", 0);        rc.startGroup();        rc.startField("latitude", 0);        rc.addDouble(0.0);        rc.endField("latitude", 0);        rc.startField("longitude", 1);        rc.addDouble(180.0);        rc.endField("longitude", 1);        rc.endGroup();        rc.endField("element", 0);                rc.endGroup();                        rc.startGroup();        rc.startField("element", 0);        rc.startGroup();        rc.startField("latitude", 0);        rc.addDouble(0.0);        rc.endField("latitude", 0);        rc.startField("longitude", 1);        rc.addDouble(0.0);        rc.endField("longitude", 1);        rc.endGroup();        rc.endField("element", 0);                rc.endGroup();                rc.endField("locations_tuple", 0);        rc.endGroup();        rc.endField("locations", 0);        rc.endMessage();    });    Schema location = record("element", field("latitude", primitive(Schema.Type.DOUBLE)), field("longitude", primitive(Schema.Type.DOUBLE)));        Schema elementRecord = record("locations_tuple", optionalField("element", location));    Schema oldSchema = record("ThriftCompatRequiredGroupInList", optionalField("locations", array(elementRecord)));    GenericRecord oldRecord = instance(oldSchema, "locations", Arrays.asList(instance(elementRecord, "element", instance(location, "latitude", 0.0, "longitude", 180.0)), instance(elementRecord, "element", instance(location, "latitude", 0.0, "longitude", 0.0))));        assertReaderContains(oldBehaviorReader(test), oldSchema, oldRecord);    assertReaderContains(newBehaviorReader(test), oldSchema, oldRecord);}
612ce79043fe8ba47d76da6c8fc1404597b5539dbd50d6da2fb560695125777a
testHiveCompatOptionalGroupInList
public void testHiveCompatOptionalGroupInList() throws Exception
{    Path test = writeDirect("message HiveCompatOptionalGroupInList {" + "  optional group locations (LIST) {" + "    repeated group bag {" + "      optional group element {" + "        required double latitude;" + "        required double longitude;" + "      }" + "    }" + "  }" + "}", rc -> {        rc.startMessage();        rc.startField("locations", 0);        rc.startGroup();                rc.startField("bag", 0);                        rc.startGroup();        rc.startField("element", 0);        rc.startGroup();        rc.startField("latitude", 0);        rc.addDouble(0.0);        rc.endField("latitude", 0);        rc.startField("longitude", 1);        rc.addDouble(180.0);        rc.endField("longitude", 1);        rc.endGroup();        rc.endField("element", 0);                rc.endGroup();                        rc.startGroup();        rc.startField("element", 0);        rc.startGroup();        rc.startField("latitude", 0);        rc.addDouble(0.0);        rc.endField("latitude", 0);        rc.startField("longitude", 1);        rc.addDouble(0.0);        rc.endField("longitude", 1);        rc.endGroup();        rc.endField("element", 0);                rc.endGroup();                rc.endField("bag", 0);        rc.endGroup();        rc.endField("locations", 0);        rc.endMessage();    });    Schema location = record("element", field("latitude", primitive(Schema.Type.DOUBLE)), field("longitude", primitive(Schema.Type.DOUBLE)));        Schema elementRecord = record("bag", optionalField("element", location));    Schema oldSchema = record("HiveCompatOptionalGroupInList", optionalField("locations", array(elementRecord)));    GenericRecord oldRecord = instance(oldSchema, "locations", Arrays.asList(instance(elementRecord, "element", instance(location, "latitude", 0.0, "longitude", 180.0)), instance(elementRecord, "element", instance(location, "latitude", 0.0, "longitude", 0.0))));        assertReaderContains(oldBehaviorReader(test), oldSchema, oldRecord);    Schema newSchema = record("HiveCompatOptionalGroupInList", optionalField("locations", array(optional(location))));    GenericRecord newRecord = instance(newSchema, "locations", Arrays.asList(instance(location, "latitude", 0.0, "longitude", 180.0), instance(location, "latitude", 0.0, "longitude", 0.0)));    assertReaderContains(newBehaviorReader(test), newSchema, newRecord);}
af9da24b9c0ba401b0502763690759b1e0e8f3dc4208e65af0e2a89b1ac0b48f
testListOfSingleElementStructsWithElementField
public void testListOfSingleElementStructsWithElementField() throws Exception
{    Path test = writeDirect("message ListOfSingleElementStructsWithElementField {" + "  optional group list_of_structs (LIST) {" + "    repeated group list {" + "      required group element {" + "        required float element;" + "      }" + "    }" + "  }" + "}", rc -> {        rc.startMessage();        rc.startField("list_of_structs", 0);        rc.startGroup();                rc.startField("list", 0);                        rc.startGroup();        rc.startField("element", 0);                rc.startGroup();        rc.startField("element", 0);        rc.addFloat(33.0F);        rc.endField("element", 0);        rc.endGroup();        rc.endField("element", 0);                rc.endGroup();                        rc.startGroup();        rc.startField("element", 0);                rc.startGroup();        rc.startField("element", 0);        rc.addFloat(34.0F);        rc.endField("element", 0);        rc.endGroup();        rc.endField("element", 0);                rc.endGroup();                rc.endField("list", 0);        rc.endGroup();        rc.endField("list_of_structs", 0);        rc.endMessage();    });    Schema structWithElementField = record("element", field("element", primitive(Schema.Type.FLOAT)));        Schema elementRecord = record("list", field("element", structWithElementField));    Schema oldSchema = record("ListOfSingleElementStructsWithElementField", optionalField("list_of_structs", array(elementRecord)));    GenericRecord oldRecord = instance(oldSchema, "list_of_structs", Arrays.asList(instance(elementRecord, "element", instance(structWithElementField, "element", 33.0F)), instance(elementRecord, "element", instance(structWithElementField, "element", 34.0F))));        final MessageType fileSchema;    try (ParquetFileReader reader = ParquetFileReader.open(new Configuration(), test)) {        fileSchema = reader.getFileMetaData().getSchema();        Assert.assertEquals("Converted schema should assume 2-layer structure", oldSchema, new AvroSchemaConverter(OLD_BEHAVIOR_CONF).convert(fileSchema));    }        assertReaderContains(oldBehaviorReader(test), oldSchema, oldRecord);    Schema newSchema = record("ListOfSingleElementStructsWithElementField", optionalField("list_of_structs", array(structWithElementField)));    GenericRecord newRecord = instance(newSchema, "list_of_structs", Arrays.asList(instance(structWithElementField, "element", 33.0F), instance(structWithElementField, "element", 34.0F)));        Assert.assertEquals("Converted schema should assume 3-layer structure", newSchema, new AvroSchemaConverter(NEW_BEHAVIOR_CONF).convert(fileSchema));    assertReaderContains(newBehaviorReader(test), newSchema, newRecord);        Schema structWithDoubleElementField = record("element", field("element", primitive(Schema.Type.DOUBLE)));    Schema doubleElementRecord = record("list", field("element", structWithDoubleElementField));    Schema oldDoubleSchema = record("ListOfSingleElementStructsWithElementField", optionalField("list_of_structs", array(doubleElementRecord)));    GenericRecord oldDoubleRecord = instance(oldDoubleSchema, "list_of_structs", Arrays.asList(instance(doubleElementRecord, "element", instance(structWithDoubleElementField, "element", 33.0)), instance(doubleElementRecord, "element", instance(structWithDoubleElementField, "element", 34.0))));    assertReaderContains(oldBehaviorReader(test, oldDoubleSchema), oldDoubleSchema, oldDoubleRecord);    Schema newDoubleSchema = record("ListOfSingleElementStructsWithElementField", optionalField("list_of_structs", array(structWithDoubleElementField)));    GenericRecord newDoubleRecord = instance(newDoubleSchema, "list_of_structs", Arrays.asList(instance(structWithDoubleElementField, "element", 33.0), instance(structWithDoubleElementField, "element", 34.0)));    assertReaderContains(newBehaviorReader(test, newDoubleSchema), newDoubleSchema, newDoubleRecord);}
72991a745732a142963805b7ede6b776a94983427977c99839bee77c047d8ff3
oldBehaviorReader
public AvroParquetReader<T> oldBehaviorReader(Path path) throws IOException
{    return new AvroParquetReader<T>(OLD_BEHAVIOR_CONF, path);}
aba31fa315bcee55c74332f783f2d063341db4bd6ebf1ead4b58baef40f721a5
oldBehaviorReader
public AvroParquetReader<T> oldBehaviorReader(Path path, Schema expectedSchema) throws IOException
{    Configuration conf = new Configuration(OLD_BEHAVIOR_CONF);    AvroReadSupport.setAvroReadSchema(conf, expectedSchema);    return new AvroParquetReader<T>(conf, path);}
3f1a1c4cec84b22c141ef630b198bf40e4d87f977016ed47ff04f0e755afe78f
newBehaviorReader
public AvroParquetReader<T> newBehaviorReader(Path path) throws IOException
{    return new AvroParquetReader<T>(NEW_BEHAVIOR_CONF, path);}
099c400737fbe1e2acd81dd0a3a0fefa87103b1332c93865f756eef80091ff82
newBehaviorReader
public AvroParquetReader<T> newBehaviorReader(Path path, Schema expectedSchema) throws IOException
{    Configuration conf = new Configuration(NEW_BEHAVIOR_CONF);    AvroReadSupport.setAvroReadSchema(conf, expectedSchema);    return new AvroParquetReader<T>(conf, path);}
5db4ed4bcfc51d2f1967816b674fbe8edb70df7be40dd2b4b3bfda8bd7a48681
assertReaderContains
public void assertReaderContains(AvroParquetReader<T> reader, Schema expectedSchema, T... expectedRecords) throws IOException
{    for (T expectedRecord : expectedRecords) {        T actualRecord = reader.read();        Assert.assertEquals("Should match expected schema", expectedSchema, actualRecord.getSchema());        Assert.assertEquals("Should match the expected record", expectedRecord, actualRecord);    }    Assert.assertNull("Should only contain " + expectedRecords.length + " record" + (expectedRecords.length == 1 ? "" : "s"), reader.read());}
26d0e132486f8d7dd4288e6a839ea98c98993ec66d5cfadf66ef7a1da3288420
get
public GenericData get()
{    return GenericData.get();}
976cf8118d39c3a5beddbae2f504e24fa1d33f21fe4125f1d35c900ad40cdff0
testSetSupplierMethod
public void testSetSupplierMethod()
{    Configuration conf = new Configuration(false);    AvroReadSupport.setAvroDataSupplier(conf, GenericDataSupplier.class);    Assert.assertEquals("Should contain the class name", "org.apache.parquet.avro.TestAvroDataSupplier$GenericDataSupplier", conf.get(AvroReadSupport.AVRO_DATA_SUPPLIER));}
91ced49c0eb37bdfe255306c41fe9bc1be1fad2fca25f42f08290f80a17f4b8e
setupConf
public static void setupConf()
{    NEW_BEHAVIOR.setBoolean("parquet.avro.add-list-element-records", false);    NEW_BEHAVIOR.setBoolean("parquet.avro.write-old-list-structure", false);}
10eb9647289c936b76dadfd5dc44b13e4b6163cc5e6f6db5978bc1b16c2b46e1
testAvroToParquetConversion
private void testAvroToParquetConversion(Schema avroSchema, String schemaString) throws Exception
{    testAvroToParquetConversion(new Configuration(false), avroSchema, schemaString);}
e6b8edbe30059998be452f8ca08eae6f3d052cc5d6cd04ee6b18e08b067614e3
testAvroToParquetConversion
private void testAvroToParquetConversion(Configuration conf, Schema avroSchema, String schemaString) throws Exception
{    AvroSchemaConverter avroSchemaConverter = new AvroSchemaConverter(conf);    MessageType schema = avroSchemaConverter.convert(avroSchema);    MessageType expectedMT = MessageTypeParser.parseMessageType(schemaString);    assertEquals("converting " + schema + " to " + schemaString, expectedMT.toString(), schema.toString());}
943a668785e796aae0466afca9a3e290c56a4052a81653440e4a0be0d330eebf
testParquetToAvroConversion
private void testParquetToAvroConversion(Schema avroSchema, String schemaString) throws Exception
{    testParquetToAvroConversion(new Configuration(false), avroSchema, schemaString);}
185a9ae84f78c71ad1d4df6a3368cbbde7a227a62aad4b4c6b231b7f1b08cd18
testParquetToAvroConversion
private void testParquetToAvroConversion(Configuration conf, Schema avroSchema, String schemaString) throws Exception
{    AvroSchemaConverter avroSchemaConverter = new AvroSchemaConverter(conf);    Schema schema = avroSchemaConverter.convert(MessageTypeParser.parseMessageType(schemaString));    assertEquals("converting " + schemaString + " to " + avroSchema, avroSchema.toString(), schema.toString());}
6605f46fe0352039d9163ffc722c25df6727e3e2a497d851a6e6204bc06b1123
testRoundTripConversion
private void testRoundTripConversion(Schema avroSchema, String schemaString) throws Exception
{    testRoundTripConversion(new Configuration(), avroSchema, schemaString);}
74ab40ad2dc0e91527c7eb2cd50e4c2c04a640c9546c5a6bda9f284fea0c633a
testRoundTripConversion
private void testRoundTripConversion(Configuration conf, Schema avroSchema, String schemaString) throws Exception
{    AvroSchemaConverter avroSchemaConverter = new AvroSchemaConverter(conf);    MessageType schema = avroSchemaConverter.convert(avroSchema);    MessageType expectedMT = MessageTypeParser.parseMessageType(schemaString);    assertEquals("converting " + schema + " to " + schemaString, expectedMT.toString(), schema.toString());    Schema convertedAvroSchema = avroSchemaConverter.convert(expectedMT);    assertEquals("converting " + expectedMT + " to " + avroSchema.toString(true), avroSchema.toString(), convertedAvroSchema.toString());}
bb65e8c8a334010aacb3e329c1352aea508102693cf97e82bf8d3e6689d6db6e
testTopLevelMustBeARecord
public void testTopLevelMustBeARecord()
{    new AvroSchemaConverter().convert(Schema.create(INT));}
c717b6ac97344f5da0133974970b8f753098a5890d650bb2c6ae2b713a92d8c0
testAllTypes
public void testAllTypes() throws Exception
{    Schema schema = new Schema.Parser().parse(Resources.getResource("all.avsc").openStream());    testAvroToParquetConversion(NEW_BEHAVIOR, schema, "message org.apache.parquet.avro.myrecord {\n" +     "  required boolean myboolean;\n" + "  required int32 myint;\n" + "  required int64 mylong;\n" + "  required float myfloat;\n" + "  required double mydouble;\n" + "  required binary mybytes;\n" + "  required binary mystring (UTF8);\n" + "  required group mynestedrecord {\n" + "    required int32 mynestedint;\n" + "  }\n" + "  required binary myenum (ENUM);\n" + "  required group myarray (LIST) {\n" + "    repeated group list {\n" + "      required int32 element;\n" + "    }\n" + "  }\n" + "  required group myemptyarray (LIST) {\n" + "    repeated group list {\n" + "      required int32 element;\n" + "    }\n" + "  }\n" + "  optional group myoptionalarray (LIST) {\n" + "    repeated group list {\n" + "      required int32 element;\n" + "    }\n" + "  }\n" + "  required group myarrayofoptional (LIST) {\n" + "    repeated group list {\n" + "      optional int32 element;\n" + "    }\n" + "  }\n" + "  required group mymap (MAP) {\n" + "    repeated group map (MAP_KEY_VALUE) {\n" + "      required binary key (UTF8);\n" + "      required int32 value;\n" + "    }\n" + "  }\n" + "  required group myemptymap (MAP) {\n" + "    repeated group map (MAP_KEY_VALUE) {\n" + "      required binary key (UTF8);\n" + "      required int32 value;\n" + "    }\n" + "  }\n" + "  required fixed_len_byte_array(1) myfixed;\n" + "}\n");}
b40d5eeed674d7e84ab3b175650747176cd8d741ebe6788ec708ece030fa8a53
testAllTypesOldListBehavior
public void testAllTypesOldListBehavior() throws Exception
{    Schema schema = new Schema.Parser().parse(Resources.getResource("all.avsc").openStream());    testAvroToParquetConversion(schema, "message org.apache.parquet.avro.myrecord {\n" +     "  required boolean myboolean;\n" + "  required int32 myint;\n" + "  required int64 mylong;\n" + "  required float myfloat;\n" + "  required double mydouble;\n" + "  required binary mybytes;\n" + "  required binary mystring (UTF8);\n" + "  required group mynestedrecord {\n" + "    required int32 mynestedint;\n" + "  }\n" + "  required binary myenum (ENUM);\n" + "  required group myarray (LIST) {\n" + "    repeated int32 array;\n" + "  }\n" + "  required group myemptyarray (LIST) {\n" + "    repeated int32 array;\n" + "  }\n" + "  optional group myoptionalarray (LIST) {\n" + "    repeated int32 array;\n" + "  }\n" + "  required group myarrayofoptional (LIST) {\n" + "    repeated int32 array;\n" + "  }\n" + "  required group mymap (MAP) {\n" + "    repeated group map (MAP_KEY_VALUE) {\n" + "      required binary key (UTF8);\n" + "      required int32 value;\n" + "    }\n" + "  }\n" + "  required group myemptymap (MAP) {\n" + "    repeated group map (MAP_KEY_VALUE) {\n" + "      required binary key (UTF8);\n" + "      required int32 value;\n" + "    }\n" + "  }\n" + "  required fixed_len_byte_array(1) myfixed;\n" + "}\n");}
59b302a77d67fd004d8c6df633fe3e3423f501dff363743634ce3912d822dd60
testAllTypesParquetToAvro
public void testAllTypesParquetToAvro() throws Exception
{    Schema schema = new Schema.Parser().parse(Resources.getResource("allFromParquetNewBehavior.avsc").openStream());        testParquetToAvroConversion(NEW_BEHAVIOR, schema, ALL_PARQUET_SCHEMA);}
7b2a77172046c35d0c496c9731cf159d2fefc093299372711e8d0e19e877ada9
testAllTypesParquetToAvroOldBehavior
public void testAllTypesParquetToAvroOldBehavior() throws Exception
{    Schema schema = new Schema.Parser().parse(Resources.getResource("allFromParquetOldBehavior.avsc").openStream());        testParquetToAvroConversion(schema, ALL_PARQUET_SCHEMA);}
85a327536642e35920df6eb4fcc2a069bb14bd8477c4cbb2f4cb6e5c42025432
testParquetMapWithNonStringKeyFails
public void testParquetMapWithNonStringKeyFails() throws Exception
{    MessageType parquetSchema = MessageTypeParser.parseMessageType("message myrecord {\n" + "  required group mymap (MAP) {\n" + "    repeated group map (MAP_KEY_VALUE) {\n" + "      required int32 key;\n" + "      required int32 value;\n" + "    }\n" + "  }\n" + "}\n");    new AvroSchemaConverter().convert(parquetSchema);}
2e734cd12884709fba8c4af4afe3c76e41aa55dbbaa13893cb99918768bb1a27
testOptionalFields
public void testOptionalFields() throws Exception
{    Schema schema = Schema.createRecord("record1", null, null, false);    Schema optionalInt = optional(Schema.create(INT));    schema.setFields(Collections.singletonList(new Schema.Field("myint", optionalInt, null, JsonProperties.NULL_VALUE)));    testRoundTripConversion(schema, "message record1 {\n" + "  optional int32 myint;\n" + "}\n");}
abc27d21de50de3c05ebe1660adcecfe7d1f969b56e9dd57754121667ec449c5
testOptionalMapValue
public void testOptionalMapValue() throws Exception
{    Schema schema = Schema.createRecord("record1", null, null, false);    Schema optionalIntMap = Schema.createMap(optional(Schema.create(INT)));    schema.setFields(Arrays.asList(new Schema.Field("myintmap", optionalIntMap, null, null)));    testRoundTripConversion(schema, "message record1 {\n" + "  required group myintmap (MAP) {\n" + "    repeated group map (MAP_KEY_VALUE) {\n" + "      required binary key (UTF8);\n" + "      optional int32 value;\n" + "    }\n" + "  }\n" + "}\n");}
46d5ebc38016a8e5c7a2b4b9f0b075998b041a36357c69368666f394f7fab061
testOptionalArrayElement
public void testOptionalArrayElement() throws Exception
{    Schema schema = Schema.createRecord("record1", null, null, false);    Schema optionalIntArray = Schema.createArray(optional(Schema.create(INT)));    schema.setFields(Arrays.asList(new Schema.Field("myintarray", optionalIntArray, null, null)));    testRoundTripConversion(NEW_BEHAVIOR, schema, "message record1 {\n" + "  required group myintarray (LIST) {\n" + "    repeated group list {\n" + "      optional int32 element;\n" + "    }\n" + "  }\n" + "}\n");}
504d230e9a4fba6e4ba600cfcf27b947a6371e6970b2a3f68f8334d7ed4054ef
testUnionOfTwoTypes
public void testUnionOfTwoTypes() throws Exception
{    Schema schema = Schema.createRecord("record2", null, null, false);    Schema multipleTypes = Schema.createUnion(Arrays.asList(Schema.create(Schema.Type.NULL), Schema.create(INT), Schema.create(Schema.Type.FLOAT)));    schema.setFields(Arrays.asList(new Schema.Field("myunion", multipleTypes, null, JsonProperties.NULL_VALUE)));            testAvroToParquetConversion(schema, "message record2 {\n" + "  optional group myunion {\n" + "    optional int32 member0;\n" + "    optional float member1;\n" + "  }\n" + "}\n");}
321243dfe66a7ca28f47c459bb3d246a783a9ca65da1f274ac963dcd64ae4c4a
testArrayOfOptionalRecords
public void testArrayOfOptionalRecords() throws Exception
{    Schema innerRecord = Schema.createRecord("element", null, null, false);    Schema optionalString = optional(Schema.create(Schema.Type.STRING));    innerRecord.setFields(Lists.newArrayList(new Schema.Field("s1", optionalString, null, JsonProperties.NULL_VALUE), new Schema.Field("s2", optionalString, null, JsonProperties.NULL_VALUE)));    Schema schema = Schema.createRecord("HasArray", null, null, false);    schema.setFields(Lists.newArrayList(new Schema.Field("myarray", Schema.createArray(optional(innerRecord)), null, null)));    System.err.println("Avro schema: " + schema.toString(true));    testRoundTripConversion(NEW_BEHAVIOR, schema, "message HasArray {\n" + "  required group myarray (LIST) {\n" + "    repeated group list {\n" + "      optional group element {\n" + "        optional binary s1 (UTF8);\n" + "        optional binary s2 (UTF8);\n" + "      }\n" + "    }\n" + "  }\n" + "}\n");}
cbc58f586e8b9625414890fe0634a0b90493ee45cdb0483563712bfc83f7aafc
testArrayOfOptionalRecordsOldBehavior
public void testArrayOfOptionalRecordsOldBehavior() throws Exception
{    Schema innerRecord = Schema.createRecord("InnerRecord", null, null, false);    Schema optionalString = optional(Schema.create(Schema.Type.STRING));    innerRecord.setFields(Lists.newArrayList(new Schema.Field("s1", optionalString, null, JsonProperties.NULL_VALUE), new Schema.Field("s2", optionalString, null, JsonProperties.NULL_VALUE)));    Schema schema = Schema.createRecord("HasArray", null, null, false);    schema.setFields(Lists.newArrayList(new Schema.Field("myarray", Schema.createArray(optional(innerRecord)), null, null)));    System.err.println("Avro schema: " + schema.toString(true));        testAvroToParquetConversion(schema, "message HasArray {\n" + "  required group myarray (LIST) {\n" + "    repeated group array {\n" + "      optional binary s1 (UTF8);\n" + "      optional binary s2 (UTF8);\n" + "    }\n" + "  }\n" + "}\n");}
c394f036e4e6e7f1fc69984ab90441b701a028148d89089549c9b83ae64b0a51
testOldAvroListOfLists
public void testOldAvroListOfLists() throws Exception
{    Schema listOfLists = optional(Schema.createArray(Schema.createArray(Schema.create(INT))));    Schema schema = Schema.createRecord("AvroCompatListInList", null, null, false);    schema.setFields(Lists.newArrayList(new Schema.Field("listOfLists", listOfLists, null, JsonProperties.NULL_VALUE)));    System.err.println("Avro schema: " + schema.toString(true));    testRoundTripConversion(schema, "message AvroCompatListInList {\n" + "  optional group listOfLists (LIST) {\n" + "    repeated group array (LIST) {\n" + "      repeated int32 array;\n" + "    }\n" + "  }\n" + "}");        testParquetToAvroConversion(NEW_BEHAVIOR, schema, "message AvroCompatListInList {\n" + "  optional group listOfLists (LIST) {\n" + "    repeated group array (LIST) {\n" + "      repeated int32 array;\n" + "    }\n" + "  }\n" + "}");}
89290d5c772e9d3be8a05eb25109e56595392722e10989f0c36df8c9ae4ef6e3
testOldThriftListOfLists
public void testOldThriftListOfLists() throws Exception
{    Schema listOfLists = optional(Schema.createArray(Schema.createArray(Schema.create(INT))));    Schema schema = Schema.createRecord("ThriftCompatListInList", null, null, false);    schema.setFields(Lists.newArrayList(new Schema.Field("listOfLists", listOfLists, null, JsonProperties.NULL_VALUE)));    System.err.println("Avro schema: " + schema.toString(true));        testParquetToAvroConversion(schema, "message ThriftCompatListInList {\n" + "  optional group listOfLists (LIST) {\n" + "    repeated group listOfLists_tuple (LIST) {\n" + "      repeated int32 listOfLists_tuple_tuple;\n" + "    }\n" + "  }\n" + "}");        testParquetToAvroConversion(NEW_BEHAVIOR, schema, "message ThriftCompatListInList {\n" + "  optional group listOfLists (LIST) {\n" + "    repeated group listOfLists_tuple (LIST) {\n" + "      repeated int32 listOfLists_tuple_tuple;\n" + "    }\n" + "  }\n" + "}");}
546eb85a43b16f66f349c8655d27145ce506f5fdaa5c191b0a21fda6a19a0cb3
testUnknownTwoLevelListOfLists
public void testUnknownTwoLevelListOfLists() throws Exception
{                Schema listOfLists = optional(Schema.createArray(Schema.createArray(Schema.create(INT))));    Schema schema = Schema.createRecord("UnknownTwoLevelListInList", null, null, false);    schema.setFields(Lists.newArrayList(new Schema.Field("listOfLists", listOfLists, null, JsonProperties.NULL_VALUE)));    System.err.println("Avro schema: " + schema.toString(true));        testParquetToAvroConversion(schema, "message UnknownTwoLevelListInList {\n" + "  optional group listOfLists (LIST) {\n" + "    repeated group mylist (LIST) {\n" + "      repeated int32 innerlist;\n" + "    }\n" + "  }\n" + "}");        testParquetToAvroConversion(NEW_BEHAVIOR, schema, "message UnknownTwoLevelListInList {\n" + "  optional group listOfLists (LIST) {\n" + "    repeated group mylist (LIST) {\n" + "      repeated int32 innerlist;\n" + "    }\n" + "  }\n" + "}");}
1c3d8b31c3d7dcc6345d120123d9d76bbadce6d18afac3302a78f9c4d0085a66
testParquetMapWithoutMapKeyValueAnnotation
public void testParquetMapWithoutMapKeyValueAnnotation() throws Exception
{    Schema schema = Schema.createRecord("myrecord", null, null, false);    Schema map = Schema.createMap(Schema.create(INT));    schema.setFields(Collections.singletonList(new Schema.Field("mymap", map, null, null)));    String parquetSchema = "message myrecord {\n" + "  required group mymap (MAP) {\n" + "    repeated group map {\n" + "      required binary key (UTF8);\n" + "      required int32 value;\n" + "    }\n" + "  }\n" + "}\n";    testParquetToAvroConversion(schema, parquetSchema);    testParquetToAvroConversion(NEW_BEHAVIOR, schema, parquetSchema);}
124e2dbbea2e2f356fb645fff7bc4a3122fce211cb45ddc20e11b7b645bf7a76
testDecimalBytesType
public void testDecimalBytesType() throws Exception
{    Schema schema = Schema.createRecord("myrecord", null, null, false);    Schema decimal = LogicalTypes.decimal(9, 2).addToSchema(Schema.create(Schema.Type.BYTES));    schema.setFields(Collections.singletonList(new Schema.Field("dec", decimal, null, null)));    testRoundTripConversion(schema, "message myrecord {\n" + "  required binary dec (DECIMAL(9,2));\n" + "}\n");}
9e4d6c69a8f586ceaf91618f89c564a2538704961a1b1eaa6daa3024ebc93d37
testDecimalFixedType
public void testDecimalFixedType() throws Exception
{    Schema schema = Schema.createRecord("myrecord", null, null, false);    Schema decimal = LogicalTypes.decimal(9, 2).addToSchema(Schema.createFixed("dec", null, null, 8));    schema.setFields(Collections.singletonList(new Schema.Field("dec", decimal, null, null)));    testRoundTripConversion(schema, "message myrecord {\n" + "  required fixed_len_byte_array(8) dec (DECIMAL(9,2));\n" + "}\n");}
41e149ab0ffa038ad66194491970cdb8bc5f31da9c2ac26d65a058241ff5da28
testDecimalIntegerType
public void testDecimalIntegerType() throws Exception
{    Schema expected = Schema.createRecord("myrecord", null, null, false, Arrays.asList(new Schema.Field("dec", Schema.create(INT), null, null)));        testParquetToAvroConversion(expected, "message myrecord {\n" + "  required int32 dec (DECIMAL(9,2));\n" + "}\n");}
fd40facc7e98f92c534400d4d6204f7b0f0f54cfddcf8e565a976389cd26b216
testDecimalLongType
public void testDecimalLongType() throws Exception
{    Schema expected = Schema.createRecord("myrecord", null, null, false, Arrays.asList(new Schema.Field("dec", Schema.create(LONG), null, null)));        testParquetToAvroConversion(expected, "message myrecord {\n" + "  required int64 dec (DECIMAL(9,2));\n" + "}\n");}
b2028dbddbd3dc656fe6ca954f8c6f9248443723eebdc7e214fa3d406d25a229
testDateType
public void testDateType() throws Exception
{    Schema date = LogicalTypes.date().addToSchema(Schema.create(INT));    Schema expected = Schema.createRecord("myrecord", null, null, false, Arrays.asList(new Schema.Field("date", date, null, null)));    testRoundTripConversion(expected, "message myrecord {\n" + "  required int32 date (DATE);\n" + "}\n");    for (PrimitiveTypeName primitive : new PrimitiveTypeName[] { INT64, INT96, FLOAT, DOUBLE, BOOLEAN, BINARY, FIXED_LEN_BYTE_ARRAY }) {        final PrimitiveType type;        if (primitive == FIXED_LEN_BYTE_ARRAY) {            type = new PrimitiveType(REQUIRED, primitive, 12, "test", DATE);        } else {            type = new PrimitiveType(REQUIRED, primitive, "test", DATE);        }        assertThrows("Should not allow TIME_MICROS with " + primitive, IllegalArgumentException.class, () -> new AvroSchemaConverter().convert(message(type)));    }}
f6be6d12534039ef70df905ee959615a2e9a7dc5118a1a4e1e1d59c8f104f7a7
testTimeMillisType
public void testTimeMillisType() throws Exception
{    Schema date = LogicalTypes.timeMillis().addToSchema(Schema.create(INT));    Schema expected = Schema.createRecord("myrecord", null, null, false, Arrays.asList(new Schema.Field("time", date, null, null)));    testRoundTripConversion(expected, "message myrecord {\n" + "  required int32 time (TIME(MILLIS,true));\n" + "}\n");    for (PrimitiveTypeName primitive : new PrimitiveTypeName[] { INT64, INT96, FLOAT, DOUBLE, BOOLEAN, BINARY, FIXED_LEN_BYTE_ARRAY }) {        final PrimitiveType type;        if (primitive == FIXED_LEN_BYTE_ARRAY) {            type = new PrimitiveType(REQUIRED, primitive, 12, "test", TIME_MILLIS);        } else {            type = new PrimitiveType(REQUIRED, primitive, "test", TIME_MILLIS);        }        assertThrows("Should not allow TIME_MICROS with " + primitive, IllegalArgumentException.class, () -> new AvroSchemaConverter().convert(message(type)));    }}
214b621b6b277424fc04e646bc48ea6d78cfb1cbe5f0b98efdbe95273601fa42
testTimeMicrosType
public void testTimeMicrosType() throws Exception
{    Schema date = LogicalTypes.timeMicros().addToSchema(Schema.create(LONG));    Schema expected = Schema.createRecord("myrecord", null, null, false, Arrays.asList(new Schema.Field("time", date, null, null)));    testRoundTripConversion(expected, "message myrecord {\n" + "  required int64 time (TIME(MICROS,true));\n" + "}\n");    for (PrimitiveTypeName primitive : new PrimitiveTypeName[] { INT32, INT96, FLOAT, DOUBLE, BOOLEAN, BINARY, FIXED_LEN_BYTE_ARRAY }) {        final PrimitiveType type;        if (primitive == FIXED_LEN_BYTE_ARRAY) {            type = new PrimitiveType(REQUIRED, primitive, 12, "test", TIME_MICROS);        } else {            type = new PrimitiveType(REQUIRED, primitive, "test", TIME_MICROS);        }        assertThrows("Should not allow TIME_MICROS with " + primitive, IllegalArgumentException.class, () -> new AvroSchemaConverter().convert(message(type)));    }}
0050970a4230a6053e0382df5a79854c73a45b5179eda7f231cb95415ba6ae8d
testTimestampMillisType
public void testTimestampMillisType() throws Exception
{    Schema date = LogicalTypes.timestampMillis().addToSchema(Schema.create(LONG));    Schema expected = Schema.createRecord("myrecord", null, null, false, Arrays.asList(new Schema.Field("timestamp", date, null, null)));    testRoundTripConversion(expected, "message myrecord {\n" + "  required int64 timestamp (TIMESTAMP(MILLIS,true));\n" + "}\n");    for (PrimitiveTypeName primitive : new PrimitiveTypeName[] { INT32, INT96, FLOAT, DOUBLE, BOOLEAN, BINARY, FIXED_LEN_BYTE_ARRAY }) {        final PrimitiveType type;        if (primitive == FIXED_LEN_BYTE_ARRAY) {            type = new PrimitiveType(REQUIRED, primitive, 12, "test", TIMESTAMP_MILLIS);        } else {            type = new PrimitiveType(REQUIRED, primitive, "test", TIMESTAMP_MILLIS);        }        assertThrows("Should not allow TIMESTAMP_MILLIS with " + primitive, IllegalArgumentException.class, () -> new AvroSchemaConverter().convert(message(type)));    }}
00f1d54d001d833d4c3c51a905acbfb6b57722598307061b33b1e731f609bc57
testTimestampMicrosType
public void testTimestampMicrosType() throws Exception
{    Schema date = LogicalTypes.timestampMicros().addToSchema(Schema.create(LONG));    Schema expected = Schema.createRecord("myrecord", null, null, false, Arrays.asList(new Schema.Field("timestamp", date, null, null)));    testRoundTripConversion(expected, "message myrecord {\n" + "  required int64 timestamp (TIMESTAMP(MICROS,true));\n" + "}\n");    for (PrimitiveTypeName primitive : new PrimitiveTypeName[] { INT32, INT96, FLOAT, DOUBLE, BOOLEAN, BINARY, FIXED_LEN_BYTE_ARRAY }) {        final PrimitiveType type;        if (primitive == FIXED_LEN_BYTE_ARRAY) {            type = new PrimitiveType(REQUIRED, primitive, 12, "test", TIMESTAMP_MICROS);        } else {            type = new PrimitiveType(REQUIRED, primitive, "test", TIMESTAMP_MICROS);        }        assertThrows("Should not allow TIMESTAMP_MICROS with " + primitive, IllegalArgumentException.class, () -> new AvroSchemaConverter().convert(message(type)));    }}
5868aca04f4be149eb545393249b217beb7d80d14511646351002dbe95321c34
testReuseNameInNestedStructure
public void testReuseNameInNestedStructure() throws Exception
{    Schema innerA1 = record("a1", "a12", field("a4", primitive(Schema.Type.FLOAT)));    Schema outerA1 = record("a1", field("a2", primitive(Schema.Type.FLOAT)), optionalField("a1", innerA1));    Schema schema = record("Message", optionalField("a1", outerA1));    String parquetSchema = "message Message {\n" + "      optional group a1 {\n" + "        required float a2;\n" + "        optional group a1 {\n" + "          required float a4;\n" + "         }\n" + "      }\n" + "}\n";    testParquetToAvroConversion(schema, parquetSchema);    testParquetToAvroConversion(NEW_BEHAVIOR, schema, parquetSchema);}
f16f777972c3a3ba715660628dd1d340c326b7748a92fa6c0a884657ad54a265
testReuseNameInNestedStructureAtSameLevel
public void testReuseNameInNestedStructureAtSameLevel() throws Exception
{    Schema a2 = record("a2", field("a4", primitive(Schema.Type.FLOAT)));    Schema a22 = record("a2", "a22", field("a4", primitive(Schema.Type.FLOAT)), field("a5", primitive(Schema.Type.FLOAT)));    Schema a1 = record("a1", optionalField("a2", a2));    Schema a3 = record("a3", optionalField("a2", a22));    Schema schema = record("Message", optionalField("a1", a1), optionalField("a3", a3));    String parquetSchema = "message Message {\n" + "      optional group a1 {\n" + "        optional group a2 {\n" + "          required float a4;\n" + "         }\n" + "      }\n" + "      optional group a3 {\n" + "        optional group a2 {\n" + "          required float a4;\n" + "          required float a5;\n" + "         }\n" + "      }\n" + "}\n";    testParquetToAvroConversion(schema, parquetSchema);    testParquetToAvroConversion(NEW_BEHAVIOR, schema, parquetSchema);}
8627784beb32dfb1469f2d71a722c05f6d7528aa551b2640947fb0ebf82d1672
optional
public static Schema optional(Schema original)
{    return Schema.createUnion(Lists.newArrayList(Schema.create(Schema.Type.NULL), original));}
662765e9b99c45f4c14a6d3fbcc8d5c6dcb9875acb767e9cc98c65f57e35fac1
message
public static MessageType message(PrimitiveType primitive)
{    return Types.buildMessage().addField(primitive).named("myrecord");}
e23f7e21bd235330c29ffa1bc05eb380b6733a0b532ec6b7ca8d92bf684094b4
assertThrows
public static void assertThrows(String message, Class<? extends Exception> expected, Runnable runnable)
{    try {        runnable.run();        Assert.fail("No exception was thrown (" + message + "), expected: " + expected.getName());    } catch (Exception actual) {        try {            Assert.assertEquals(message, expected, actual.getClass());        } catch (AssertionError e) {            e.addSuppressed(actual);            throw e;        }    }}
1904a4240bd7428bd7254a67ee05c1c42d543f0671e29f5e62cc81f9fcef52e7
testCompatStringCompatibility
public void testCompatStringCompatibility() throws IOException
{                    Path testFile = new Path(Resources.getResource("strings-2.parquet").getFile());    Configuration conf = new Configuration();    ParquetReader<GenericRecord> reader = AvroParquetReader.builder(new AvroReadSupport<GenericRecord>(), testFile).withConf(conf).build();    GenericRecord r;    while ((r = reader.read()) != null) {        Assert.assertTrue("Should read value into a String", r.get("text") instanceof String);    }}
1744e72ad71bba2abbc23c09e01adaa63749058aab3458be4f4180d307ec4dba
testStringCompatibility
public void testStringCompatibility() throws IOException
{    Path testFile = new Path(Resources.getResource("strings-2.parquet").getFile());    Configuration conf = new Configuration();    conf.setBoolean(AvroReadSupport.AVRO_COMPATIBILITY, false);    ParquetReader<GenericRecord> reader = AvroParquetReader.builder(new AvroReadSupport<GenericRecord>(), testFile).withConf(conf).build();    GenericRecord r;    while ((r = reader.read()) != null) {        Assert.assertTrue("Should read value into a String", r.get("text") instanceof Utf8);    }}
289f1597a90218f911e45f224f3873845000475f617e37a65359e3bd3730e2bb
addToSchema
public Schema addToSchema(Schema schema)
{    super.addToSchema(schema);    schema.addProp(REF_FIELD_NAME, refFieldName);    return schema;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return REFERENCE;}
01aa68945a139be25e68182e6c2ace30ccb9c3f7d0434c19b73ba2eb738d249f
getRefFieldName
public String getRefFieldName()
{    return refFieldName;}
9c8753af4248bc6cfdffb49d546cd09255922836141b423436c52fa0aa74ca10
validate
public void validate(Schema schema)
{    super.validate(schema);    if (schema.getField(refFieldName) == null) {        throw new IllegalArgumentException("Invalid field name for reference field: " + refFieldName);    }}
289f1597a90218f911e45f224f3873845000475f617e37a65359e3bd3730e2bb
addToSchema
public Schema addToSchema(Schema schema)
{    super.addToSchema(schema);    schema.addProp(ID_FIELD_NAME, idFieldName);    return schema;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return REFERENCEABLE;}
f8e09dad628707a829c0e2d23d88c8458496eac0226a41d3b1aff69ac1a5c7e0
getIdFieldName
public String getIdFieldName()
{    return idFieldName;}
9c8753af4248bc6cfdffb49d546cd09255922836141b423436c52fa0aa74ca10
validate
public void validate(Schema schema)
{    super.validate(schema);    Schema.Field idField = schema.getField(idFieldName);    if (idField == null || idField.schema().getType() != Schema.Type.LONG) {        throw new IllegalArgumentException("Invalid ID field: " + idFieldName + ": " + idField);    }}
8934432fbfaf426d90a3233ebe4bbb4328f5f426473c0e3f93d68cd56a5a3633
addReferenceTypes
public static void addReferenceTypes()
{    LogicalTypes.register(Referenceable.REFERENCEABLE, new LogicalTypes.LogicalTypeFactory() {        @Override        public LogicalType fromSchema(Schema schema) {            return new Referenceable(schema);        }    });    LogicalTypes.register(Reference.REFERENCE, new LogicalTypes.LogicalTypeFactory() {        @Override        public LogicalType fromSchema(Schema schema) {            return new Reference(schema);        }    });}
36dfb5961f1202e55daceaf634633d8efcfa821d6e42fb8a497c9c8192f70340
fromSchema
public LogicalType fromSchema(Schema schema)
{    return new Referenceable(schema);}
36dfb5961f1202e55daceaf634633d8efcfa821d6e42fb8a497c9c8192f70340
fromSchema
public LogicalType fromSchema(Schema schema)
{    return new Reference(schema);}
80b91eb29d1cd366cfa574b40daa486878dbcadcefc58689e978239cb4b55523
getTracker
public ReferenceableTracker getTracker()
{    return tracker;}
fd3d35b5e0b88bf86decbf7d01f1146f1a48a8c745e135894dd7f7463d2e27be
getHandler
public ReferenceHandler getHandler()
{    return handler;}
f92605823fb7877eeb08f467eea27b2cdaca618b4e506aad7289bc8911942951
getConvertedType
public Class<IndexedRecord> getConvertedType()
{    return (Class) Record.class;}
79c42293ac3a43d7598dc0ac8104dd9a114e436cd5a14a6241ebbe2b10b5f8ba
getLogicalTypeName
public String getLogicalTypeName()
{    return Referenceable.REFERENCEABLE;}
74f1d0d8347b078c3b2e80d2b57e1459534d5500aa6e5912e00bb4e78f7ff936
fromRecord
public IndexedRecord fromRecord(IndexedRecord value, Schema schema, LogicalType type)
{        long id = getId(value, schema);        references.put(id, value);        List<Callback> callbacks = callbacksById.get(id);    for (Callback callback : callbacks) {        callback.set(value);    }    return value;}
76fb806e3f145050af6e203e07da7cbe15b55ad008a8369e9d7c7f93f5062ecc
toRecord
public IndexedRecord toRecord(IndexedRecord value, Schema schema, LogicalType type)
{        long id = getId(value, schema);            ids.put(value, id);    return value;}
768814ab06160ca6ffe6b225238703ca62c561757d27bbcc0c1ed72d254851f9
getId
private long getId(IndexedRecord referenceable, Schema schema)
{    Referenceable info = (Referenceable) schema.getLogicalType();    int idField = schema.getField(info.getIdFieldName()).pos();    return (Long) referenceable.get(idField);}
f92605823fb7877eeb08f467eea27b2cdaca618b4e506aad7289bc8911942951
getConvertedType
public Class<IndexedRecord> getConvertedType()
{    return (Class) Record.class;}
79c42293ac3a43d7598dc0ac8104dd9a114e436cd5a14a6241ebbe2b10b5f8ba
getLogicalTypeName
public String getLogicalTypeName()
{    return Reference.REFERENCE;}
e6501f7e3f02931fb2bc84f12d9c39b3dc51f0041acd59b2270fdc980c2b4c13
fromRecord
public IndexedRecord fromRecord(final IndexedRecord record, Schema schema, LogicalType type)
{        final Schema.Field refField = schema.getField(((Reference) type).getRefFieldName());    Long id = (Long) record.get(refField.pos());    if (id != null) {        if (references.containsKey(id)) {            record.put(refField.pos(), references.get(id));        } else {            List<Callback> callbacks = callbacksById.get(id);            if (callbacks == null) {                callbacks = new ArrayList<Callback>();                callbacksById.put(id, callbacks);            }                        callbacks.add(new Callback() {                @Override                public void set(Object referenceable) {                    record.put(refField.pos(), referenceable);                }            });        }    }    return record;}
1ab3538f4c505bb96346509be42d76a0ef359a03eb5715bb37d5b43675510ce9
set
public void set(Object referenceable)
{    record.put(refField.pos(), referenceable);}
1a66c5f5007aea6c5778b0b239109e79c7fff31a257d038f5e31b37a4659b567
toRecord
public IndexedRecord toRecord(IndexedRecord record, Schema schema, LogicalType type)
{        Schema.Field refField = schema.getField(((Reference) type).getRefFieldName());    IndexedRecord referenced = (IndexedRecord) record.get(refField.pos());    if (referenced == null) {        return record;    }        return new HijackingIndexedRecord(record, refField.pos(), ids.get(referenced));}
24a0e8f4089701b155328460d08976411ba0d7f744b77ab2e712496ffa81b814
put
public void put(int i, Object v)
{    throw new RuntimeException("[BUG] This is a read-only class.");}
2ea0205e522ed62ca511b522fdeaf1cedf0c2afbc5adfc3869c76d9961e32934
get
public Object get(int i)
{    if (i == index) {        return data;    }    return wrapped.get(i);}
b74ae948bba816a824396f5fcd959e744592a67ff01eb79c422acb487a04550a
getSchema
public Schema getSchema()
{    return wrapped.getSchema();}
a2a314ef22554dd92e27423b4f2d7f98b9f605698c00bf86585d1f2c50b7ab22
test
public void test() throws IOException
{    ReferenceManager manager = new ReferenceManager();    GenericData model = new GenericData();    model.addLogicalTypeConversion(manager.getTracker());    model.addLogicalTypeConversion(manager.getHandler());    Schema parentSchema = Schema.createRecord("Parent", null, null, false);    Schema placeholderSchema = Schema.createRecord("Placeholder", null, null, false);    List<Schema.Field> placeholderFields = new ArrayList<Schema.Field>();        placeholderFields.add(new Schema.Field("id", Schema.create(Schema.Type.LONG), null, null));    placeholderSchema.setFields(placeholderFields);    Referenceable idRef = new Referenceable("id");    Schema parentRefSchema = Schema.createUnion(Schema.create(Schema.Type.NULL), Schema.create(Schema.Type.LONG), idRef.addToSchema(placeholderSchema));    Reference parentRef = new Reference("parent");    List<Schema.Field> childFields = new ArrayList<Schema.Field>();    childFields.add(new Schema.Field("c", Schema.create(Schema.Type.STRING), null, null));    childFields.add(new Schema.Field("parent", parentRefSchema, null, null));    Schema childSchema = parentRef.addToSchema(Schema.createRecord("Child", null, null, false, childFields));    List<Schema.Field> parentFields = new ArrayList<Schema.Field>();    parentFields.add(new Schema.Field("id", Schema.create(Schema.Type.LONG), null, null));    parentFields.add(new Schema.Field("p", Schema.create(Schema.Type.STRING), null, null));    parentFields.add(new Schema.Field("child", childSchema, null, null));    parentSchema.setFields(parentFields);    Schema schema = idRef.addToSchema(parentSchema);    System.out.println("Schema: " + schema.toString(true));    Record parent = new Record(schema);    parent.put("id", 1L);    parent.put("p", "parent data!");    Record child = new Record(childSchema);    child.put("c", "child data!");    child.put("parent", parent);    parent.put("child", child);        File data = AvroTestUtil.write(temp, model, schema, parent);    List<Record> records = AvroTestUtil.read(model, schema, data);    Record actual = records.get(0);        Assert.assertEquals("Should correctly read back the parent id", 1L, actual.get("id"));    Assert.assertEquals("Should correctly read back the parent data", new Utf8("parent data!"), actual.get("p"));    Record actualChild = (Record) actual.get("child");    Assert.assertEquals("Should correctly read back the child data", new Utf8("child data!"), actualChild.get("c"));    Object childParent = actualChild.get("parent");    Assert.assertTrue("Should have a parent Record object", childParent instanceof Record);    Record childParentRecord = (Record) actualChild.get("parent");    Assert.assertEquals("Should have the right parent id", 1L, childParentRecord.get("id"));    Assert.assertEquals("Should have the right parent data", new Utf8("parent data!"), childParentRecord.get("p"));}
57e08299ffe82e0611f07878f6cbcbc66958c1ef26b2e62ea286f3dec79d0c77
addDecimalAndUUID
public static void addDecimalAndUUID()
{    GENERIC.addLogicalTypeConversion(new Conversions.DecimalConversion());    GENERIC.addLogicalTypeConversion(new Conversions.UUIDConversion());}
ace7f2ba182c7331f2e60ca6718df7934e20cac4c34a7d2b3fa612e6dad9df5c
getFieldValues
private List<T> getFieldValues(Collection<GenericRecord> records, String field, Class<T> expectedClass)
{    List<T> values = new ArrayList<T>();    for (GenericRecord record : records) {        values.add(expectedClass.cast(record.get(field)));    }    return values;}
341a32cdb578b032c85976394fe125322cbb295129f6fa0c4687a1cf7fcac9b7
testReadUUID
public void testReadUUID() throws IOException
{    Schema uuidSchema = record("R", field("uuid", LogicalTypes.uuid().addToSchema(Schema.create(STRING))));    GenericRecord u1 = instance(uuidSchema, "uuid", UUID.randomUUID());    GenericRecord u2 = instance(uuidSchema, "uuid", UUID.randomUUID());    Schema stringSchema = record("R", field("uuid", Schema.create(STRING)));    GenericRecord s1 = instance(stringSchema, "uuid", u1.get("uuid").toString());    GenericRecord s2 = instance(stringSchema, "uuid", u2.get("uuid").toString());    File test = write(stringSchema, s1, s2);    Assert.assertEquals("Should convert Strings to UUIDs", Arrays.asList(u1, u2), read(GENERIC, uuidSchema, test));}
331c8e9b9794653f2bc075fb4f3d0973d3ba97fd5ece8c5ecc0a5110046c913b
testWriteUUIDReadStringSchema
public void testWriteUUIDReadStringSchema() throws IOException
{    Schema uuidSchema = record("R", field("uuid", LogicalTypes.uuid().addToSchema(Schema.create(STRING))));    GenericRecord u1 = instance(uuidSchema, "uuid", UUID.randomUUID());    GenericRecord u2 = instance(uuidSchema, "uuid", UUID.randomUUID());    Schema stringUuidSchema = Schema.create(STRING);    stringUuidSchema.addProp(GenericData.STRING_PROP, "String");    Schema stringSchema = record("R", field("uuid", stringUuidSchema));    GenericRecord s1 = instance(stringSchema, "uuid", u1.get("uuid").toString());    GenericRecord s2 = instance(stringSchema, "uuid", u2.get("uuid").toString());    File test = write(GENERIC, uuidSchema, u1, u2);    Assert.assertEquals("Should read UUIDs as Strings", Arrays.asList(s1, s2), read(GENERIC, stringSchema, test));}
be4a24d10733b43885d9f82e9cb91141315e9b362ea32107d1f420c9acdc950e
testWriteUUIDReadStringMissingLogicalType
public void testWriteUUIDReadStringMissingLogicalType() throws IOException
{    Schema uuidSchema = record("R", field("uuid", LogicalTypes.uuid().addToSchema(Schema.create(STRING))));    GenericRecord u1 = instance(uuidSchema, "uuid", UUID.randomUUID());    GenericRecord u2 = instance(uuidSchema, "uuid", UUID.randomUUID());    GenericRecord s1 = instance(uuidSchema, "uuid", new Utf8(u1.get("uuid").toString()));    GenericRecord s2 = instance(uuidSchema, "uuid", new Utf8(u2.get("uuid").toString()));    File test = write(GENERIC, uuidSchema, u1, u2);    Assert.assertEquals("Should read UUIDs as Strings", Arrays.asList(s1, s2), read(GenericData.get(), uuidSchema, test));}
9530cd72742c23bd9ab88394040d60173676edfbea92b7ef409b7641a156f56b
testWriteNullableUUID
public void testWriteNullableUUID() throws IOException
{    Schema nullableUuidSchema = record("R", optionalField("uuid", LogicalTypes.uuid().addToSchema(Schema.create(STRING))));    GenericRecord u1 = instance(nullableUuidSchema, "uuid", UUID.randomUUID());    GenericRecord u2 = instance(nullableUuidSchema, "uuid", UUID.randomUUID());    Schema stringUuidSchema = Schema.create(STRING);    stringUuidSchema.addProp(GenericData.STRING_PROP, "String");    Schema nullableStringSchema = record("R", optionalField("uuid", stringUuidSchema));    GenericRecord s1 = instance(nullableStringSchema, "uuid", u1.get("uuid").toString());    GenericRecord s2 = instance(nullableStringSchema, "uuid", u2.get("uuid").toString());    File test = write(GENERIC, nullableUuidSchema, u1, u2);    Assert.assertEquals("Should read UUIDs as Strings", Arrays.asList(s1, s2), read(GENERIC, nullableStringSchema, test));}
5060b48984de48816a469c0d95e3de5b5c8982f66dde753bbecd0912842f0df7
testReadDecimalFixed
public void testReadDecimalFixed() throws IOException
{    Schema fixedSchema = Schema.createFixed("aFixed", null, null, 4);    Schema fixedRecord = record("R", field("dec", fixedSchema));    Schema decimalSchema = DECIMAL_9_2.addToSchema(Schema.createFixed("aFixed", null, null, 4));    Schema decimalRecord = record("R", field("dec", decimalSchema));    GenericRecord r1 = instance(decimalRecord, "dec", D1);    GenericRecord r2 = instance(decimalRecord, "dec", D2);    List<GenericRecord> expected = Arrays.asList(r1, r2);    Conversion<BigDecimal> conversion = new Conversions.DecimalConversion();        GenericRecord r1fixed = instance(fixedRecord, "dec", conversion.toFixed(D1, fixedSchema, DECIMAL_9_2));    GenericRecord r2fixed = instance(fixedRecord, "dec", conversion.toFixed(D2, fixedSchema, DECIMAL_9_2));    File test = write(fixedRecord, r1fixed, r2fixed);    Assert.assertEquals("Should convert fixed to BigDecimals", expected, read(GENERIC, decimalRecord, test));}
731e610b329037c1e22d7edf66e741db7a7007dbe3cb7f21155624d7c86a7730
testWriteDecimalFixed
public void testWriteDecimalFixed() throws IOException
{    Schema fixedSchema = Schema.createFixed("aFixed", null, null, 4);    Schema fixedRecord = record("R", field("dec", fixedSchema));    Schema decimalSchema = DECIMAL_9_2.addToSchema(Schema.createFixed("aFixed", null, null, 4));    Schema decimalRecord = record("R", field("dec", decimalSchema));    GenericRecord r1 = instance(decimalRecord, "dec", D1);    GenericRecord r2 = instance(decimalRecord, "dec", D2);    Conversion<BigDecimal> conversion = new Conversions.DecimalConversion();        GenericRecord r1fixed = instance(fixedRecord, "dec", conversion.toFixed(D1, fixedSchema, DECIMAL_9_2));    GenericRecord r2fixed = instance(fixedRecord, "dec", conversion.toFixed(D2, fixedSchema, DECIMAL_9_2));    List<GenericRecord> expected = Arrays.asList(r1fixed, r2fixed);    File test = write(GENERIC, decimalRecord, r1, r2);    Assert.assertEquals("Should read BigDecimals as fixed", expected, read(GENERIC, fixedRecord, test));}
ad6cb5bdde2f993b28778e7ed7dafb834ea9c9385e057a76e5813458efec26d2
testReadDecimalBytes
public void testReadDecimalBytes() throws IOException
{    Schema bytesSchema = Schema.create(Schema.Type.BYTES);    Schema bytesRecord = record("R", field("dec", bytesSchema));    Schema decimalSchema = DECIMAL_9_2.addToSchema(Schema.create(Schema.Type.BYTES));    Schema decimalRecord = record("R", field("dec", decimalSchema));    GenericRecord r1 = instance(decimalRecord, "dec", D1);    GenericRecord r2 = instance(decimalRecord, "dec", D2);    List<GenericRecord> expected = Arrays.asList(r1, r2);    Conversion<BigDecimal> conversion = new Conversions.DecimalConversion();        GenericRecord r1bytes = instance(bytesRecord, "dec", conversion.toBytes(D1, bytesSchema, DECIMAL_9_2));    GenericRecord r2bytes = instance(bytesRecord, "dec", conversion.toBytes(D2, bytesSchema, DECIMAL_9_2));    File test = write(bytesRecord, r1bytes, r2bytes);    Assert.assertEquals("Should convert bytes to BigDecimals", expected, read(GENERIC, decimalRecord, test));}
a68ec1f6d5ee8399aa5e81bba11ac539f0e71d07013950882a57a0ebe0bf1805
testWriteDecimalBytes
public void testWriteDecimalBytes() throws IOException
{    Schema bytesSchema = Schema.create(Schema.Type.BYTES);    Schema bytesRecord = record("R", field("dec", bytesSchema));    Schema decimalSchema = DECIMAL_9_2.addToSchema(Schema.create(Schema.Type.BYTES));    Schema decimalRecord = record("R", field("dec", decimalSchema));    GenericRecord r1 = instance(decimalRecord, "dec", D1);    GenericRecord r2 = instance(decimalRecord, "dec", D2);    Conversion<BigDecimal> conversion = new Conversions.DecimalConversion();        GenericRecord r1bytes = instance(bytesRecord, "dec", conversion.toBytes(D1, bytesSchema, DECIMAL_9_2));    GenericRecord r2bytes = instance(bytesRecord, "dec", conversion.toBytes(D2, bytesSchema, DECIMAL_9_2));    List<GenericRecord> expected = Arrays.asList(r1bytes, r2bytes);    File test = write(GENERIC, decimalRecord, r1, r2);    Assert.assertEquals("Should read BigDecimals as bytes", expected, read(GENERIC, bytesRecord, test));}
7266ec28b8527de20895c66429c2ca054a197631a9a47bd401e7254cbbc068a7
write
private File write(Schema schema, D... data) throws IOException
{    return write(GenericData.get(), schema, data);}
28e27a5e2a408002182af84ed4939b4f658ea15840fb2ad3c9de4f0e687bfabe
write
private File write(GenericData model, Schema schema, D... data) throws IOException
{    return AvroTestUtil.write(temp, model, schema, data);}
788670d64ae1bbf768a2236e99240aae4ef2b16251810fa099acc4b85b3d91b0
nextRecord
public static GenericRecord nextRecord(Integer i)
{    return new GenericRecordBuilder(avroSchema).set("a", i).build();}
f1b79cd73081803aac4d597efe66cc1e35d6cdcd7d3d407951eb90b869e57624
run
public void run(Context context) throws IOException, InterruptedException
{    for (int i = 0; i < 10; i++) {        GenericRecord a;        a = TestInputOutputFormat.nextRecord(i == 4 ? null : i);        context.write(null, a);    }}
30ee16b511c17f52a293deaf5f5c1e953ec7a589a92f8dd6c47dfe22eb813763
map
protected void map(Void key, GenericRecord value, Context context) throws IOException, InterruptedException
{    context.write(null, new Text(value.toString()));}
c2c75b5eb5762dda20687d84e7565d4cf3b9de60742e0694a6cffba3f16ea18a
testReadWrite
public void testReadWrite() throws Exception
{    final Configuration conf = new Configuration();    final Path inputPath = new Path("src/test/java/org/apache/parquet/avro/TestInputOutputFormat.java");    final Path parquetPath = new Path("target/test/hadoop/TestInputOutputFormat/parquet");    final Path outputPath = new Path("target/test/hadoop/TestInputOutputFormat/out");    final FileSystem fileSystem = parquetPath.getFileSystem(conf);    fileSystem.delete(parquetPath, true);    fileSystem.delete(outputPath, true);    {        final Job job = new Job(conf, "write");                TextInputFormat.addInputPath(job, inputPath);        job.setInputFormatClass(TextInputFormat.class);        job.setMapperClass(TestInputOutputFormat.MyMapper.class);        job.setNumReduceTasks(0);        job.setOutputFormatClass(AvroParquetOutputFormat.class);        AvroParquetOutputFormat.setOutputPath(job, parquetPath);        AvroParquetOutputFormat.setSchema(job, avroSchema);        waitForJob(job);    }    {        final Job job = new Job(conf, "read");        job.setInputFormatClass(AvroParquetInputFormat.class);        AvroParquetInputFormat.setInputPaths(job, parquetPath);        job.setMapperClass(TestInputOutputFormat.MyMapper2.class);        job.setNumReduceTasks(0);        job.setOutputFormatClass(TextOutputFormat.class);        TextOutputFormat.setOutputPath(job, outputPath);        waitForJob(job);    }    try (final BufferedReader out = new BufferedReader(new FileReader(new File(outputPath.toString(), "part-m-00000")))) {        String lineOut;        int lineNumber = 0;        while ((lineOut = out.readLine()) != null) {            lineOut = lineOut.substring(lineOut.indexOf("\t") + 1);            GenericRecord a = nextRecord(lineNumber == 4 ? null : lineNumber);            assertEquals("line " + lineNumber, a.toString(), lineOut);            ++lineNumber;        }        assertNull("line " + lineNumber, out.readLine());    }}
1ae73b30cdadc8449c547b5e2074b79321881a77c70d90b50bd9f3775f37e746
waitForJob
private void waitForJob(Job job) throws Exception
{    job.submit();    while (!job.isComplete()) {        LOG.debug("waiting for job {}", job.getJobName());        sleep(100);    }    LOG.info("status for job {}: {}", job.getJobName(), (job.isSuccessful() ? "SUCCESS" : "FAILURE"));    if (!job.isSuccessful()) {        throw new RuntimeException("job failed " + job.getJobName());    }}
e159cd20e5d846e508be922f0450be0db638ed2ba32c3229ae07c0ea68938d77
data
public static Collection<Object[]> data()
{    Object[][] data = new Object[][] {     { false },     { true } };    return Arrays.asList(data);}
6f49236d18ad0e66af7c518f1df182d8415d99bf9841af9a407cee90c3ee0853
testEmptyArray
public void testEmptyArray() throws Exception
{    Schema schema = new Schema.Parser().parse(Resources.getResource("array.avsc").openStream());        List<Integer> emptyArray = new ArrayList<>();    Path file = new Path(createTempFile().getPath());    try (ParquetWriter<GenericRecord> writer = AvroParquetWriter.<GenericRecord>builder(file).withSchema(schema).withConf(testConf).build()) {        GenericData.Record record = new GenericRecordBuilder(schema).set("myarray", emptyArray).build();        writer.write(record);    }    try (AvroParquetReader<GenericRecord> reader = new AvroParquetReader<>(testConf, file)) {        GenericRecord nextRecord = reader.read();        assertNotNull(nextRecord);        assertEquals(emptyArray, nextRecord.get("myarray"));    }}
b466947788effc9fbc8f2899acaf85ed3ec5ac2389ff9049ef16e50e0d3b0627
testEmptyMap
public void testEmptyMap() throws Exception
{    Schema schema = new Schema.Parser().parse(Resources.getResource("map.avsc").openStream());    Path file = new Path(createTempFile().getPath());    ImmutableMap<String, Integer> emptyMap = new ImmutableMap.Builder<String, Integer>().build();    try (ParquetWriter<GenericRecord> writer = AvroParquetWriter.<GenericRecord>builder(file).withSchema(schema).withConf(testConf).build()) {                GenericData.Record record = new GenericRecordBuilder(schema).set("mymap", emptyMap).build();        writer.write(record);    }    try (AvroParquetReader<GenericRecord> reader = new AvroParquetReader<GenericRecord>(testConf, file)) {        GenericRecord nextRecord = reader.read();        assertNotNull(nextRecord);        assertEquals(emptyMap, nextRecord.get("mymap"));    }}
d8c76982b286730fe2b0d1aded6a441e96000bc0d8a85ee25dbcc7caec35358f
testMapWithNulls
public void testMapWithNulls() throws Exception
{    Schema schema = new Schema.Parser().parse(Resources.getResource("map_with_nulls.avsc").openStream());    Path file = new Path(createTempFile().getPath());        Map<CharSequence, Integer> map = new HashMap<>();    map.put(str("thirty-four"), 34);    map.put(str("eleventy-one"), null);    map.put(str("one-hundred"), 100);    try (ParquetWriter<GenericRecord> writer = AvroParquetWriter.<GenericRecord>builder(file).withSchema(schema).withConf(testConf).build()) {        GenericData.Record record = new GenericRecordBuilder(schema).set("mymap", map).build();        writer.write(record);    }    try (AvroParquetReader<GenericRecord> reader = new AvroParquetReader<>(testConf, file)) {        GenericRecord nextRecord = reader.read();        assertNotNull(nextRecord);        assertEquals(map, nextRecord.get("mymap"));    }}
e45dfbf20632a536ae80c815a78031ac1404442bd37b3feaaba425c244463257
testMapRequiredValueWithNull
public void testMapRequiredValueWithNull() throws Exception
{    Schema schema = Schema.createRecord("record1", null, null, false);    schema.setFields(Lists.newArrayList(new Schema.Field("mymap", Schema.createMap(Schema.create(Schema.Type.INT)), null, null)));    Path file = new Path(createTempFile().getPath());    try (ParquetWriter<GenericRecord> writer = AvroParquetWriter.<GenericRecord>builder(file).withSchema(schema).withConf(testConf).build()) {                Map<String, Integer> map = new HashMap<String, Integer>();        map.put("thirty-four", 34);        map.put("eleventy-one", null);        map.put("one-hundred", 100);        GenericData.Record record = new GenericRecordBuilder(schema).set("mymap", map).build();        writer.write(record);    }}
c3b205198bd5e96ef225f663ad397b94c411e07403802ddfc0c44a0c53e2923a
testMapWithUtf8Key
public void testMapWithUtf8Key() throws Exception
{    Schema schema = new Schema.Parser().parse(Resources.getResource("map.avsc").openStream());    Path file = new Path(createTempFile().getPath());    try (ParquetWriter<GenericRecord> writer = AvroParquetWriter.<GenericRecord>builder(file).withSchema(schema).withConf(testConf).build()) {                GenericData.Record record = new GenericRecordBuilder(schema).set("mymap", ImmutableMap.of(new Utf8("a"), 1, new Utf8("b"), 2)).build();        writer.write(record);    }    try (AvroParquetReader<GenericRecord> reader = new AvroParquetReader<>(testConf, file)) {        GenericRecord nextRecord = reader.read();        assertNotNull(nextRecord);        assertEquals(ImmutableMap.of(str("a"), 1, str("b"), 2), nextRecord.get("mymap"));    }}
d3771c2bf11c35f7c8e7d8a590c9345091ec0e3d0e30ed14fccdbef1d9b83604
testDecimalValues
public void testDecimalValues() throws Exception
{    Schema decimalSchema = Schema.createRecord("myrecord", null, null, false);    Schema decimal = LogicalTypes.decimal(9, 2).addToSchema(Schema.create(Schema.Type.BYTES));    decimalSchema.setFields(Collections.singletonList(new Schema.Field("dec", decimal, null, null)));        GenericData decimalSupport = new GenericData();    decimalSupport.addLogicalTypeConversion(new Conversions.DecimalConversion());    File file = temp.newFile("decimal.parquet");    file.delete();    Path path = new Path(file.toString());    List<GenericRecord> expected = Lists.newArrayList();    try (ParquetWriter<GenericRecord> writer = AvroParquetWriter.<GenericRecord>builder(path).withDataModel(decimalSupport).withSchema(decimalSchema).build()) {        Random random = new Random(34L);        GenericRecordBuilder builder = new GenericRecordBuilder(decimalSchema);        for (int i = 0; i < 1000; i += 1) {            BigDecimal dec = new BigDecimal(new BigInteger(31, random), 2);            builder.set("dec", dec);            GenericRecord rec = builder.build();            expected.add(rec);            writer.write(builder.build());        }    }    List<GenericRecord> records = Lists.newArrayList();    try (ParquetReader<GenericRecord> reader = AvroParquetReader.<GenericRecord>builder(path).withDataModel(decimalSupport).disableCompatibility().build()) {        GenericRecord rec;        while ((rec = reader.read()) != null) {            records.add(rec);        }    }    Assert.assertTrue("dec field should be a BigDecimal instance", records.get(0).get("dec") instanceof BigDecimal);    Assert.assertEquals("Content should match", expected, records);}
215c0d136ed9a5b9fb4b364a362982d62a5ed46d115eb58523a70eec3777f804
testFixedDecimalValues
public void testFixedDecimalValues() throws Exception
{    Schema decimalSchema = Schema.createRecord("myrecord", null, null, false);    Schema decimal = LogicalTypes.decimal(9, 2).addToSchema(Schema.createFixed("dec", null, null, 4));    decimalSchema.setFields(Collections.singletonList(new Schema.Field("dec", decimal, null, null)));        GenericData decimalSupport = new GenericData();    decimalSupport.addLogicalTypeConversion(new Conversions.DecimalConversion());    File file = temp.newFile("decimal.parquet");    file.delete();    Path path = new Path(file.toString());    List<GenericRecord> expected = Lists.newArrayList();    try (ParquetWriter<GenericRecord> writer = AvroParquetWriter.<GenericRecord>builder(path).withDataModel(decimalSupport).withSchema(decimalSchema).build()) {        Random random = new Random(34L);        GenericRecordBuilder builder = new GenericRecordBuilder(decimalSchema);        for (int i = 0; i < 1000; i += 1) {            BigDecimal dec = new BigDecimal(new BigInteger(31, random), 2);            builder.set("dec", dec);            GenericRecord rec = builder.build();            expected.add(rec);            writer.write(builder.build());        }    }    List<GenericRecord> records = Lists.newArrayList();    try (ParquetReader<GenericRecord> reader = AvroParquetReader.<GenericRecord>builder(path).withDataModel(decimalSupport).disableCompatibility().build()) {        GenericRecord rec;        while ((rec = reader.read()) != null) {            records.add(rec);        }    }    Assert.assertTrue("dec field should be a BigDecimal instance", records.get(0).get("dec") instanceof BigDecimal);    Assert.assertEquals("Content should match", expected, records);}
049782c18fbdd6792746a664b16dbfa70b182a95d81c55926e8a18c2ab90c21b
testAll
public void testAll() throws Exception
{    Schema schema = new Schema.Parser().parse(Resources.getResource("all.avsc").openStream());    Path file = new Path(createTempFile().getPath());    List<Integer> integerArray = Arrays.asList(1, 2, 3);    GenericData.Record nestedRecord = new GenericRecordBuilder(schema.getField("mynestedrecord").schema()).set("mynestedint", 1).build();    List<Integer> emptyArray = new ArrayList<Integer>();    Schema arrayOfOptionalIntegers = Schema.createArray(optional(Schema.create(Schema.Type.INT)));    GenericData.Array<Integer> genericIntegerArrayWithNulls = new GenericData.Array<Integer>(arrayOfOptionalIntegers, Arrays.asList(1, null, 2, null, 3));    GenericFixed genericFixed = new GenericData.Fixed(Schema.createFixed("fixed", null, null, 1), new byte[] { (byte) 65 });    ImmutableMap<String, Integer> emptyMap = new ImmutableMap.Builder<String, Integer>().build();    try (ParquetWriter<GenericRecord> writer = AvroParquetWriter.<GenericRecord>builder(file).withSchema(schema).withConf(testConf).build()) {        GenericData.Array<Integer> genericIntegerArray = new GenericData.Array<Integer>(Schema.createArray(Schema.create(Schema.Type.INT)), integerArray);        GenericData.Record record = new GenericRecordBuilder(schema).set("mynull", null).set("myboolean", true).set("myint", 1).set("mylong", 2L).set("myfloat", 3.1f).set("mydouble", 4.1).set("mybytes", ByteBuffer.wrap("hello".getBytes(StandardCharsets.UTF_8))).set("mystring", "hello").set("mynestedrecord", nestedRecord).set("myenum", "a").set("myarray", genericIntegerArray).set("myemptyarray", emptyArray).set("myoptionalarray", genericIntegerArray).set("myarrayofoptional", genericIntegerArrayWithNulls).set("mymap", ImmutableMap.of("a", 1, "b", 2)).set("myemptymap", emptyMap).set("myfixed", genericFixed).build();        writer.write(record);    }    final GenericRecord nextRecord;    try (AvroParquetReader<GenericRecord> reader = new AvroParquetReader<GenericRecord>(testConf, file)) {        nextRecord = reader.read();    }    Object expectedEnumSymbol = compat ? "a" : new GenericData.EnumSymbol(schema.getField("myenum").schema(), "a");    assertNotNull(nextRecord);    assertEquals(null, nextRecord.get("mynull"));    assertEquals(true, nextRecord.get("myboolean"));    assertEquals(1, nextRecord.get("myint"));    assertEquals(2L, nextRecord.get("mylong"));    assertEquals(3.1f, nextRecord.get("myfloat"));    assertEquals(4.1, nextRecord.get("mydouble"));    assertEquals(ByteBuffer.wrap("hello".getBytes(StandardCharsets.UTF_8)), nextRecord.get("mybytes"));    assertEquals(str("hello"), nextRecord.get("mystring"));    assertEquals(expectedEnumSymbol, nextRecord.get("myenum"));    assertEquals(nestedRecord, nextRecord.get("mynestedrecord"));    assertEquals(integerArray, nextRecord.get("myarray"));    assertEquals(emptyArray, nextRecord.get("myemptyarray"));    assertEquals(integerArray, nextRecord.get("myoptionalarray"));    assertEquals(genericIntegerArrayWithNulls, nextRecord.get("myarrayofoptional"));    assertEquals(ImmutableMap.of(str("a"), 1, str("b"), 2), nextRecord.get("mymap"));    assertEquals(emptyMap, nextRecord.get("myemptymap"));    assertEquals(genericFixed, nextRecord.get("myfixed"));}
f57f2558d2d63ac14219abdfea412d2878b898d170db3df98c853afb2a6a290a
testAllUsingDefaultAvroSchema
public void testAllUsingDefaultAvroSchema() throws Exception
{    Path file = new Path(createTempFile().getPath());        try (ParquetWriter<Map<String, Object>> parquetWriter = new ParquetWriter<>(file, new WriteSupport<Map<String, Object>>() {        private RecordConsumer recordConsumer;        @Override        public WriteContext init(Configuration configuration) {            return new WriteContext(MessageTypeParser.parseMessageType(TestAvroSchemaConverter.ALL_PARQUET_SCHEMA), new HashMap<String, String>());        }        @Override        public void prepareForWrite(RecordConsumer recordConsumer) {            this.recordConsumer = recordConsumer;        }        @Override        public void write(Map<String, Object> record) {            recordConsumer.startMessage();            int index = 0;            recordConsumer.startField("myboolean", index);            recordConsumer.addBoolean((Boolean) record.get("myboolean"));            recordConsumer.endField("myboolean", index++);            recordConsumer.startField("myint", index);            recordConsumer.addInteger((Integer) record.get("myint"));            recordConsumer.endField("myint", index++);            recordConsumer.startField("mylong", index);            recordConsumer.addLong((Long) record.get("mylong"));            recordConsumer.endField("mylong", index++);            recordConsumer.startField("myfloat", index);            recordConsumer.addFloat((Float) record.get("myfloat"));            recordConsumer.endField("myfloat", index++);            recordConsumer.startField("mydouble", index);            recordConsumer.addDouble((Double) record.get("mydouble"));            recordConsumer.endField("mydouble", index++);            recordConsumer.startField("mybytes", index);            recordConsumer.addBinary(Binary.fromReusedByteBuffer((ByteBuffer) record.get("mybytes")));            recordConsumer.endField("mybytes", index++);            recordConsumer.startField("mystring", index);            recordConsumer.addBinary(Binary.fromString((String) record.get("mystring")));            recordConsumer.endField("mystring", index++);            recordConsumer.startField("mynestedrecord", index);            recordConsumer.startGroup();            recordConsumer.startField("mynestedint", 0);            recordConsumer.addInteger((Integer) record.get("mynestedint"));            recordConsumer.endField("mynestedint", 0);            recordConsumer.endGroup();            recordConsumer.endField("mynestedrecord", index++);            recordConsumer.startField("myenum", index);            recordConsumer.addBinary(Binary.fromString((String) record.get("myenum")));            recordConsumer.endField("myenum", index++);            recordConsumer.startField("myarray", index);            recordConsumer.startGroup();            recordConsumer.startField("array", 0);            for (int val : (int[]) record.get("myarray")) {                recordConsumer.addInteger(val);            }            recordConsumer.endField("array", 0);            recordConsumer.endGroup();            recordConsumer.endField("myarray", index++);            recordConsumer.startField("myoptionalarray", index);            recordConsumer.startGroup();            recordConsumer.startField("array", 0);            for (int val : (int[]) record.get("myoptionalarray")) {                recordConsumer.addInteger(val);            }            recordConsumer.endField("array", 0);            recordConsumer.endGroup();            recordConsumer.endField("myoptionalarray", index++);            recordConsumer.startField("myarrayofoptional", index);            recordConsumer.startGroup();            recordConsumer.startField("list", 0);            for (Integer val : (Integer[]) record.get("myarrayofoptional")) {                recordConsumer.startGroup();                if (val != null) {                    recordConsumer.startField("element", 0);                    recordConsumer.addInteger(val);                    recordConsumer.endField("element", 0);                }                recordConsumer.endGroup();            }            recordConsumer.endField("list", 0);            recordConsumer.endGroup();            recordConsumer.endField("myarrayofoptional", index++);            recordConsumer.startField("myrecordarray", index);            recordConsumer.startGroup();            recordConsumer.startField("array", 0);            recordConsumer.startGroup();            recordConsumer.startField("a", 0);            for (int val : (int[]) record.get("myrecordarraya")) {                recordConsumer.addInteger(val);            }            recordConsumer.endField("a", 0);            recordConsumer.startField("b", 1);            for (int val : (int[]) record.get("myrecordarrayb")) {                recordConsumer.addInteger(val);            }            recordConsumer.endField("b", 1);            recordConsumer.endGroup();            recordConsumer.endField("array", 0);            recordConsumer.endGroup();            recordConsumer.endField("myrecordarray", index++);            recordConsumer.startField("mymap", index);            recordConsumer.startGroup();            recordConsumer.startField("map", 0);            recordConsumer.startGroup();            Map<String, Integer> mymap = (Map<String, Integer>) record.get("mymap");            recordConsumer.startField("key", 0);            for (String key : mymap.keySet()) {                recordConsumer.addBinary(Binary.fromString(key));            }            recordConsumer.endField("key", 0);            recordConsumer.startField("value", 1);            for (int val : mymap.values()) {                recordConsumer.addInteger(val);            }            recordConsumer.endField("value", 1);            recordConsumer.endGroup();            recordConsumer.endField("map", 0);            recordConsumer.endGroup();            recordConsumer.endField("mymap", index++);            recordConsumer.startField("myfixed", index);            recordConsumer.addBinary(Binary.fromReusedByteArray((byte[]) record.get("myfixed")));            recordConsumer.endField("myfixed", index++);            recordConsumer.endMessage();        }    })) {        Map<String, Object> record = new HashMap<String, Object>();        record.put("myboolean", true);        record.put("myint", 1);        record.put("mylong", 2L);        record.put("myfloat", 3.1f);        record.put("mydouble", 4.1);        record.put("mybytes", ByteBuffer.wrap("hello".getBytes(StandardCharsets.UTF_8)));        record.put("mystring", "hello");        record.put("myenum", "a");        record.put("mynestedint", 1);        record.put("myarray", new int[] { 1, 2, 3 });        record.put("myoptionalarray", new int[] { 1, 2, 3 });        record.put("myarrayofoptional", new Integer[] { 1, null, 2, null, 3 });        record.put("myrecordarraya", new int[] { 1, 2, 3 });        record.put("myrecordarrayb", new int[] { 4, 5, 6 });        record.put("mymap", ImmutableMap.of("a", 1, "b", 2));        record.put("myfixed", new byte[] { (byte) 65 });        parquetWriter.write(record);    }    Schema nestedRecordSchema = Schema.createRecord("mynestedrecord", null, null, false);    nestedRecordSchema.setFields(Arrays.asList(new Schema.Field("mynestedint", Schema.create(Schema.Type.INT), null, null)));    GenericData.Record nestedRecord = new GenericRecordBuilder(nestedRecordSchema).set("mynestedint", 1).build();    List<Integer> integerArray = Arrays.asList(1, 2, 3);    List<Integer> ingeterArrayWithNulls = Arrays.asList(1, null, 2, null, 3);    Schema recordArraySchema = Schema.createRecord("array", null, null, false);    recordArraySchema.setFields(Arrays.asList(new Schema.Field("a", Schema.create(Schema.Type.INT), null, null), new Schema.Field("b", Schema.create(Schema.Type.INT), null, null)));    GenericRecordBuilder builder = new GenericRecordBuilder(recordArraySchema);    List<GenericData.Record> recordArray = new ArrayList<GenericData.Record>();    recordArray.add(builder.set("a", 1).set("b", 4).build());    recordArray.add(builder.set("a", 2).set("b", 5).build());    recordArray.add(builder.set("a", 3).set("b", 6).build());    GenericData.Array<GenericData.Record> genericRecordArray = new GenericData.Array<GenericData.Record>(Schema.createArray(recordArraySchema), recordArray);    GenericFixed genericFixed = new GenericData.Fixed(Schema.createFixed("fixed", null, null, 1), new byte[] { (byte) 65 });    try (AvroParquetReader<GenericRecord> reader = new AvroParquetReader<>(testConf, file)) {        GenericRecord nextRecord = reader.read();        assertNotNull(nextRecord);        assertEquals(true, nextRecord.get("myboolean"));        assertEquals(1, nextRecord.get("myint"));        assertEquals(2L, nextRecord.get("mylong"));        assertEquals(3.1f, nextRecord.get("myfloat"));        assertEquals(4.1, nextRecord.get("mydouble"));        assertEquals(ByteBuffer.wrap("hello".getBytes(StandardCharsets.UTF_8)), nextRecord.get("mybytes"));        assertEquals(str("hello"), nextRecord.get("mystring"));                assertEquals(str("a"), nextRecord.get("myenum"));        assertEquals(nestedRecord, nextRecord.get("mynestedrecord"));        assertEquals(integerArray, nextRecord.get("myarray"));        assertEquals(integerArray, nextRecord.get("myoptionalarray"));        assertEquals(ingeterArrayWithNulls, nextRecord.get("myarrayofoptional"));        assertEquals(genericRecordArray, nextRecord.get("myrecordarray"));        assertEquals(ImmutableMap.of(str("a"), 1, str("b"), 2), nextRecord.get("mymap"));        assertEquals(genericFixed, nextRecord.get("myfixed"));    }}
89835da140a91d5cb5181a85b8db073a92d794e99966f7422502dbb7d5467b7c
init
public WriteContext init(Configuration configuration)
{    return new WriteContext(MessageTypeParser.parseMessageType(TestAvroSchemaConverter.ALL_PARQUET_SCHEMA), new HashMap<String, String>());}
da9aef78cf181856102b820ffa7d5248e8581747b3f0670a7b049c4649b962ef
prepareForWrite
public void prepareForWrite(RecordConsumer recordConsumer)
{    this.recordConsumer = recordConsumer;}
6900f0c69cb433cbba76f9d1ffe12dd45899852f1b6124e0469c544663df1fbd
write
public void write(Map<String, Object> record)
{    recordConsumer.startMessage();    int index = 0;    recordConsumer.startField("myboolean", index);    recordConsumer.addBoolean((Boolean) record.get("myboolean"));    recordConsumer.endField("myboolean", index++);    recordConsumer.startField("myint", index);    recordConsumer.addInteger((Integer) record.get("myint"));    recordConsumer.endField("myint", index++);    recordConsumer.startField("mylong", index);    recordConsumer.addLong((Long) record.get("mylong"));    recordConsumer.endField("mylong", index++);    recordConsumer.startField("myfloat", index);    recordConsumer.addFloat((Float) record.get("myfloat"));    recordConsumer.endField("myfloat", index++);    recordConsumer.startField("mydouble", index);    recordConsumer.addDouble((Double) record.get("mydouble"));    recordConsumer.endField("mydouble", index++);    recordConsumer.startField("mybytes", index);    recordConsumer.addBinary(Binary.fromReusedByteBuffer((ByteBuffer) record.get("mybytes")));    recordConsumer.endField("mybytes", index++);    recordConsumer.startField("mystring", index);    recordConsumer.addBinary(Binary.fromString((String) record.get("mystring")));    recordConsumer.endField("mystring", index++);    recordConsumer.startField("mynestedrecord", index);    recordConsumer.startGroup();    recordConsumer.startField("mynestedint", 0);    recordConsumer.addInteger((Integer) record.get("mynestedint"));    recordConsumer.endField("mynestedint", 0);    recordConsumer.endGroup();    recordConsumer.endField("mynestedrecord", index++);    recordConsumer.startField("myenum", index);    recordConsumer.addBinary(Binary.fromString((String) record.get("myenum")));    recordConsumer.endField("myenum", index++);    recordConsumer.startField("myarray", index);    recordConsumer.startGroup();    recordConsumer.startField("array", 0);    for (int val : (int[]) record.get("myarray")) {        recordConsumer.addInteger(val);    }    recordConsumer.endField("array", 0);    recordConsumer.endGroup();    recordConsumer.endField("myarray", index++);    recordConsumer.startField("myoptionalarray", index);    recordConsumer.startGroup();    recordConsumer.startField("array", 0);    for (int val : (int[]) record.get("myoptionalarray")) {        recordConsumer.addInteger(val);    }    recordConsumer.endField("array", 0);    recordConsumer.endGroup();    recordConsumer.endField("myoptionalarray", index++);    recordConsumer.startField("myarrayofoptional", index);    recordConsumer.startGroup();    recordConsumer.startField("list", 0);    for (Integer val : (Integer[]) record.get("myarrayofoptional")) {        recordConsumer.startGroup();        if (val != null) {            recordConsumer.startField("element", 0);            recordConsumer.addInteger(val);            recordConsumer.endField("element", 0);        }        recordConsumer.endGroup();    }    recordConsumer.endField("list", 0);    recordConsumer.endGroup();    recordConsumer.endField("myarrayofoptional", index++);    recordConsumer.startField("myrecordarray", index);    recordConsumer.startGroup();    recordConsumer.startField("array", 0);    recordConsumer.startGroup();    recordConsumer.startField("a", 0);    for (int val : (int[]) record.get("myrecordarraya")) {        recordConsumer.addInteger(val);    }    recordConsumer.endField("a", 0);    recordConsumer.startField("b", 1);    for (int val : (int[]) record.get("myrecordarrayb")) {        recordConsumer.addInteger(val);    }    recordConsumer.endField("b", 1);    recordConsumer.endGroup();    recordConsumer.endField("array", 0);    recordConsumer.endGroup();    recordConsumer.endField("myrecordarray", index++);    recordConsumer.startField("mymap", index);    recordConsumer.startGroup();    recordConsumer.startField("map", 0);    recordConsumer.startGroup();    Map<String, Integer> mymap = (Map<String, Integer>) record.get("mymap");    recordConsumer.startField("key", 0);    for (String key : mymap.keySet()) {        recordConsumer.addBinary(Binary.fromString(key));    }    recordConsumer.endField("key", 0);    recordConsumer.startField("value", 1);    for (int val : mymap.values()) {        recordConsumer.addInteger(val);    }    recordConsumer.endField("value", 1);    recordConsumer.endGroup();    recordConsumer.endField("map", 0);    recordConsumer.endGroup();    recordConsumer.endField("mymap", index++);    recordConsumer.startField("myfixed", index);    recordConsumer.addBinary(Binary.fromReusedByteArray((byte[]) record.get("myfixed")));    recordConsumer.endField("myfixed", index++);    recordConsumer.endMessage();}
7ab8b3ac3513ed761baa47660d8a64d257f9e494ac8b24cc1d8ac8eda4ca23cc
testUnionWithSingleNonNullType
public void testUnionWithSingleNonNullType() throws Exception
{    Schema avroSchema = Schema.createRecord("SingleStringUnionRecord", null, null, false);    avroSchema.setFields(Collections.singletonList(new Schema.Field("value", Schema.createUnion(Schema.create(Schema.Type.STRING)), null, null)));    Path file = new Path(createTempFile().getPath());        try (ParquetWriter parquetWriter = AvroParquetWriter.builder(file).withSchema(avroSchema).withConf(new Configuration()).build()) {        GenericRecord record = new GenericRecordBuilder(avroSchema).set("value", "theValue").build();        parquetWriter.write(record);    }    try (AvroParquetReader<GenericRecord> reader = new AvroParquetReader<>(testConf, file)) {        GenericRecord nextRecord = reader.read();        assertNotNull(nextRecord);        assertEquals(str("theValue"), nextRecord.get("value"));    }}
a57bac1f0df2d4c523090decacac55317c255bfe03f5a77d2d26e0d8ce066b0a
testDuplicatedValuesWithDictionary
public void testDuplicatedValuesWithDictionary() throws Exception
{    Schema schema = SchemaBuilder.record("spark_schema").fields().optionalBytes("value").endRecord();    Path file = new Path(createTempFile().getPath());    String[] records = { "one", "two", "three", "three", "two", "one", "zero" };    try (ParquetWriter<GenericData.Record> writer = AvroParquetWriter.<GenericData.Record>builder(file).withSchema(schema).withConf(testConf).build()) {        for (String record : records) {            writer.write(new GenericRecordBuilder(schema).set("value", record.getBytes()).build());        }    }    try (ParquetReader<GenericRecord> reader = AvroParquetReader.<GenericRecord>builder(file).withConf(testConf).build()) {        GenericRecord rec;        int i = 0;        while ((rec = reader.read()) != null) {            ByteBuffer buf = (ByteBuffer) rec.get("value");            byte[] bytes = new byte[buf.remaining()];            buf.get(bytes);            assertEquals(records[i++], new String(bytes));        }    }}
72751c92699425bf486df7d14a397a469b98619402a5d41f00b4a8ae579dca1b
testNestedLists
public void testNestedLists() throws Exception
{    Schema schema = new Schema.Parser().parse(Resources.getResource("nested_array.avsc").openStream());    Path file = new Path(createTempFile().getPath());        ParquetWriter parquetWriter = AvroParquetWriter.builder(file).withSchema(schema).withConf(testConf).build();    Schema innerRecordSchema = schema.getField("l1").schema().getTypes().get(1).getElementType().getTypes().get(1);    GenericRecord record = new GenericRecordBuilder(schema).set("l1", Collections.singletonList(new GenericRecordBuilder(innerRecordSchema).set("l2", Collections.singletonList("hello")).build())).build();    parquetWriter.write(record);    parquetWriter.close();    AvroParquetReader<GenericRecord> reader = new AvroParquetReader(testConf, file);    GenericRecord nextRecord = reader.read();    assertNotNull(nextRecord);    assertNotNull(nextRecord.get("l1"));    List l1List = (List) nextRecord.get("l1");    assertNotNull(l1List.get(0));    List l2List = (List) ((GenericRecord) l1List.get(0)).get("l2");    assertEquals(str("hello"), l2List.get(0));}
19968a93dac7e10ed68615bb820d153862913a3c2046a91e0d98587c77ecb304
createTempFile
private File createTempFile() throws IOException
{    File tmp = File.createTempFile(getClass().getSimpleName(), ".tmp");    tmp.deleteOnExit();    tmp.delete();    return tmp;}
5022c9c904c228710925661be3be70d84ce505ee405f04d8f7eedc5dc473cbcc
str
public CharSequence str(String value)
{    return compat ? value : new Utf8(value);}
e159cd20e5d846e508be922f0450be0db638ed2ba32c3229ae07c0ea68938d77
data
public static Collection<Object[]> data()
{    Object[][] data = new Object[][] {     { false },     { true } };    return Arrays.asList(data);}
6f49236d18ad0e66af7c518f1df182d8415d99bf9841af9a407cee90c3ee0853
testEmptyArray
public void testEmptyArray() throws Exception
{    Schema schema = new Schema.Parser().parse(Resources.getResource("array.avsc").openStream());    File tmp = File.createTempFile(getClass().getSimpleName(), ".tmp");    tmp.deleteOnExit();    tmp.delete();    Path file = new Path(tmp.getPath());    List<Integer> emptyArray = new ArrayList<Integer>();    try (AvroParquetWriter<GenericRecord> writer = new AvroParquetWriter<GenericRecord>(file, schema)) {                GenericData.Record record = new GenericRecordBuilder(schema).set("myarray", emptyArray).build();        writer.write(record);    }    try (AvroParquetReader<GenericRecord> reader = new AvroParquetReader<>(testConf, file)) {        GenericRecord nextRecord = reader.read();        assertNotNull(nextRecord);        assertEquals(emptyArray, nextRecord.get("myarray"));    }}
b466947788effc9fbc8f2899acaf85ed3ec5ac2389ff9049ef16e50e0d3b0627
testEmptyMap
public void testEmptyMap() throws Exception
{    Schema schema = new Schema.Parser().parse(Resources.getResource("map.avsc").openStream());    File tmp = File.createTempFile(getClass().getSimpleName(), ".tmp");    tmp.deleteOnExit();    tmp.delete();    Path file = new Path(tmp.getPath());    ImmutableMap emptyMap = new ImmutableMap.Builder<String, Integer>().build();    try (AvroParquetWriter<GenericRecord> writer = new AvroParquetWriter<GenericRecord>(file, schema)) {                GenericData.Record record = new GenericRecordBuilder(schema).set("mymap", emptyMap).build();        writer.write(record);    }    try (AvroParquetReader<GenericRecord> reader = new AvroParquetReader<>(testConf, file)) {        GenericRecord nextRecord = reader.read();        assertNotNull(nextRecord);        assertEquals(emptyMap, nextRecord.get("mymap"));    }}
d8c76982b286730fe2b0d1aded6a441e96000bc0d8a85ee25dbcc7caec35358f
testMapWithNulls
public void testMapWithNulls() throws Exception
{    Schema schema = new Schema.Parser().parse(Resources.getResource("map_with_nulls.avsc").openStream());    File tmp = File.createTempFile(getClass().getSimpleName(), ".tmp");    tmp.deleteOnExit();    tmp.delete();    Path file = new Path(tmp.getPath());    Map<CharSequence, Integer> map = new HashMap<>();    try (AvroParquetWriter<GenericRecord> writer = new AvroParquetWriter<GenericRecord>(file, schema)) {                map.put(str("thirty-four"), 34);        map.put(str("eleventy-one"), null);        map.put(str("one-hundred"), 100);        GenericData.Record record = new GenericRecordBuilder(schema).set("mymap", map).build();        writer.write(record);    }    try (AvroParquetReader<GenericRecord> reader = new AvroParquetReader<>(testConf, file)) {        GenericRecord nextRecord = reader.read();        assertNotNull(nextRecord);        assertEquals(map, nextRecord.get("mymap"));    }}
e45dfbf20632a536ae80c815a78031ac1404442bd37b3feaaba425c244463257
testMapRequiredValueWithNull
public void testMapRequiredValueWithNull() throws Exception
{    Schema schema = Schema.createRecord("record1", null, null, false);    schema.setFields(Lists.newArrayList(new Schema.Field("mymap", Schema.createMap(Schema.create(Schema.Type.INT)), null, null)));    File tmp = File.createTempFile(getClass().getSimpleName(), ".tmp");    tmp.deleteOnExit();    tmp.delete();    Path file = new Path(tmp.getPath());    try (AvroParquetWriter<GenericRecord> writer = new AvroParquetWriter<GenericRecord>(file, schema)) {                Map<String, Integer> map = new HashMap<String, Integer>();        map.put("thirty-four", 34);        map.put("eleventy-one", null);        map.put("one-hundred", 100);        GenericData.Record record = new GenericRecordBuilder(schema).set("mymap", map).build();        writer.write(record);    }}
c3b205198bd5e96ef225f663ad397b94c411e07403802ddfc0c44a0c53e2923a
testMapWithUtf8Key
public void testMapWithUtf8Key() throws Exception
{    Schema schema = new Schema.Parser().parse(Resources.getResource("map.avsc").openStream());    File tmp = File.createTempFile(getClass().getSimpleName(), ".tmp");    tmp.deleteOnExit();    tmp.delete();    Path file = new Path(tmp.getPath());    try (AvroParquetWriter<GenericRecord> writer = new AvroParquetWriter<GenericRecord>(file, schema)) {                GenericData.Record record = new GenericRecordBuilder(schema).set("mymap", ImmutableMap.of(new Utf8("a"), 1, new Utf8("b"), 2)).build();        writer.write(record);    }    try (AvroParquetReader<GenericRecord> reader = new AvroParquetReader<>(testConf, file)) {        GenericRecord nextRecord = reader.read();        assertNotNull(nextRecord);        assertEquals(ImmutableMap.of(str("a"), 1, str("b"), 2), nextRecord.get("mymap"));    }}
049782c18fbdd6792746a664b16dbfa70b182a95d81c55926e8a18c2ab90c21b
testAll
public void testAll() throws Exception
{    Schema schema = new Schema.Parser().parse(Resources.getResource("all.avsc").openStream());    File tmp = File.createTempFile(getClass().getSimpleName(), ".tmp");    tmp.deleteOnExit();    tmp.delete();    Path file = new Path(tmp.getPath());    GenericData.Record nestedRecord = new GenericRecordBuilder(schema.getField("mynestedrecord").schema()).set("mynestedint", 1).build();    List<Integer> integerArray = Arrays.asList(1, 2, 3);    GenericData.Array<Integer> genericIntegerArray = new GenericData.Array<Integer>(Schema.createArray(Schema.create(Schema.Type.INT)), integerArray);    GenericFixed genericFixed = new GenericData.Fixed(Schema.createFixed("fixed", null, null, 1), new byte[] { (byte) 65 });    List<Integer> emptyArray = new ArrayList<Integer>();    ImmutableMap emptyMap = new ImmutableMap.Builder<String, Integer>().build();    try (AvroParquetWriter<GenericRecord> writer = new AvroParquetWriter<>(file, schema)) {        GenericData.Record record = new GenericRecordBuilder(schema).set("mynull", null).set("myboolean", true).set("myint", 1).set("mylong", 2L).set("myfloat", 3.1f).set("mydouble", 4.1).set("mybytes", ByteBuffer.wrap("hello".getBytes(StandardCharsets.UTF_8))).set("mystring", "hello").set("mynestedrecord", nestedRecord).set("myenum", "a").set("myarray", genericIntegerArray).set("myemptyarray", emptyArray).set("myoptionalarray", genericIntegerArray).set("myarrayofoptional", genericIntegerArray).set("mymap", ImmutableMap.of("a", 1, "b", 2)).set("myemptymap", emptyMap).set("myfixed", genericFixed).build();        writer.write(record);    }    try (AvroParquetReader<GenericRecord> reader = new AvroParquetReader<>(testConf, file)) {        GenericRecord nextRecord = reader.read();        Object expectedEnumSymbol = compat ? "a" : new GenericData.EnumSymbol(schema.getField("myenum").schema(), "a");        assertNotNull(nextRecord);        assertEquals(null, nextRecord.get("mynull"));        assertEquals(true, nextRecord.get("myboolean"));        assertEquals(1, nextRecord.get("myint"));        assertEquals(2L, nextRecord.get("mylong"));        assertEquals(3.1f, nextRecord.get("myfloat"));        assertEquals(4.1, nextRecord.get("mydouble"));        assertEquals(ByteBuffer.wrap("hello".getBytes(StandardCharsets.UTF_8)), nextRecord.get("mybytes"));        assertEquals(str("hello"), nextRecord.get("mystring"));        assertEquals(expectedEnumSymbol, nextRecord.get("myenum"));        assertEquals(nestedRecord, nextRecord.get("mynestedrecord"));        assertEquals(integerArray, nextRecord.get("myarray"));        assertEquals(emptyArray, nextRecord.get("myemptyarray"));        assertEquals(integerArray, nextRecord.get("myoptionalarray"));        assertEquals(integerArray, nextRecord.get("myarrayofoptional"));        assertEquals(ImmutableMap.of(str("a"), 1, str("b"), 2), nextRecord.get("mymap"));        assertEquals(emptyMap, nextRecord.get("myemptymap"));        assertEquals(genericFixed, nextRecord.get("myfixed"));    }}
c57212df8a38b684a7ecaf56e2ed38eeff535c87bf32631e1c8351a9d60e2fa7
testArrayWithNullValues
public void testArrayWithNullValues() throws Exception
{    Schema schema = new Schema.Parser().parse(Resources.getResource("all.avsc").openStream());    File tmp = File.createTempFile(getClass().getSimpleName(), ".tmp");    tmp.deleteOnExit();    tmp.delete();    Path file = new Path(tmp.getPath());    GenericData.Record nestedRecord = new GenericRecordBuilder(schema.getField("mynestedrecord").schema()).set("mynestedint", 1).build();    List<Integer> integerArray = Arrays.asList(1, 2, 3);    GenericData.Array<Integer> genericIntegerArray = new GenericData.Array<Integer>(Schema.createArray(Schema.create(Schema.Type.INT)), integerArray);    GenericFixed genericFixed = new GenericData.Fixed(Schema.createFixed("fixed", null, null, 1), new byte[] { (byte) 65 });    List<Integer> emptyArray = new ArrayList<Integer>();    ImmutableMap emptyMap = new ImmutableMap.Builder<String, Integer>().build();    Schema arrayOfOptionalIntegers = Schema.createArray(optional(Schema.create(Schema.Type.INT)));    GenericData.Array<Integer> genericIntegerArrayWithNulls = new GenericData.Array<>(arrayOfOptionalIntegers, Arrays.asList(1, null, 2, null, 3));    GenericData.Record record = new GenericRecordBuilder(schema).set("mynull", null).set("myboolean", true).set("myint", 1).set("mylong", 2L).set("myfloat", 3.1f).set("mydouble", 4.1).set("mybytes", ByteBuffer.wrap("hello".getBytes(StandardCharsets.UTF_8))).set("mystring", "hello").set("mynestedrecord", nestedRecord).set("myenum", "a").set("myarray", genericIntegerArray).set("myemptyarray", emptyArray).set("myoptionalarray", genericIntegerArray).set("myarrayofoptional", genericIntegerArrayWithNulls).set("mymap", ImmutableMap.of("a", 1, "b", 2)).set("myemptymap", emptyMap).set("myfixed", genericFixed).build();    try (AvroParquetWriter<GenericRecord> writer = new AvroParquetWriter<>(file, schema)) {        writer.write(record);        fail("Should not succeed writing an array with null values");    } catch (Exception e) {        Assert.assertTrue("Error message should provide context and help", e.getMessage().contains("parquet.avro.write-old-list-structure"));    }}
f57f2558d2d63ac14219abdfea412d2878b898d170db3df98c853afb2a6a290a
testAllUsingDefaultAvroSchema
public void testAllUsingDefaultAvroSchema() throws Exception
{    File tmp = File.createTempFile(getClass().getSimpleName(), ".tmp");    tmp.deleteOnExit();    tmp.delete();    Path file = new Path(tmp.getPath());        try (ParquetWriter<Map<String, Object>> parquetWriter = new ParquetWriter<Map<String, Object>>(file, new WriteSupport<Map<String, Object>>() {        private RecordConsumer recordConsumer;        @Override        public WriteContext init(Configuration configuration) {            return new WriteContext(MessageTypeParser.parseMessageType(TestAvroSchemaConverter.ALL_PARQUET_SCHEMA), new HashMap<String, String>());        }        @Override        public void prepareForWrite(RecordConsumer recordConsumer) {            this.recordConsumer = recordConsumer;        }        @Override        public void write(Map<String, Object> record) {            recordConsumer.startMessage();            int index = 0;            recordConsumer.startField("myboolean", index);            recordConsumer.addBoolean((Boolean) record.get("myboolean"));            recordConsumer.endField("myboolean", index++);            recordConsumer.startField("myint", index);            recordConsumer.addInteger((Integer) record.get("myint"));            recordConsumer.endField("myint", index++);            recordConsumer.startField("mylong", index);            recordConsumer.addLong((Long) record.get("mylong"));            recordConsumer.endField("mylong", index++);            recordConsumer.startField("myfloat", index);            recordConsumer.addFloat((Float) record.get("myfloat"));            recordConsumer.endField("myfloat", index++);            recordConsumer.startField("mydouble", index);            recordConsumer.addDouble((Double) record.get("mydouble"));            recordConsumer.endField("mydouble", index++);            recordConsumer.startField("mybytes", index);            recordConsumer.addBinary(Binary.fromReusedByteBuffer((ByteBuffer) record.get("mybytes")));            recordConsumer.endField("mybytes", index++);            recordConsumer.startField("mystring", index);            recordConsumer.addBinary(Binary.fromString((String) record.get("mystring")));            recordConsumer.endField("mystring", index++);            recordConsumer.startField("mynestedrecord", index);            recordConsumer.startGroup();            recordConsumer.startField("mynestedint", 0);            recordConsumer.addInteger((Integer) record.get("mynestedint"));            recordConsumer.endField("mynestedint", 0);            recordConsumer.endGroup();            recordConsumer.endField("mynestedrecord", index++);            recordConsumer.startField("myenum", index);            recordConsumer.addBinary(Binary.fromString((String) record.get("myenum")));            recordConsumer.endField("myenum", index++);            recordConsumer.startField("myarray", index);            recordConsumer.startGroup();            recordConsumer.startField("array", 0);            for (int val : (int[]) record.get("myarray")) {                recordConsumer.addInteger(val);            }            recordConsumer.endField("array", 0);            recordConsumer.endGroup();            recordConsumer.endField("myarray", index++);            recordConsumer.startField("myoptionalarray", index);            recordConsumer.startGroup();            recordConsumer.startField("array", 0);            for (int val : (int[]) record.get("myoptionalarray")) {                recordConsumer.addInteger(val);            }            recordConsumer.endField("array", 0);            recordConsumer.endGroup();            recordConsumer.endField("myoptionalarray", index++);            recordConsumer.startField("myarrayofoptional", index);            recordConsumer.startGroup();            recordConsumer.startField("list", 0);            for (Integer val : (Integer[]) record.get("myarrayofoptional")) {                recordConsumer.startGroup();                if (val != null) {                    recordConsumer.startField("element", 0);                    recordConsumer.addInteger(val);                    recordConsumer.endField("element", 0);                }                recordConsumer.endGroup();            }            recordConsumer.endField("list", 0);            recordConsumer.endGroup();            recordConsumer.endField("myarrayofoptional", index++);            recordConsumer.startField("myrecordarray", index);            recordConsumer.startGroup();            recordConsumer.startField("array", 0);            recordConsumer.startGroup();            recordConsumer.startField("a", 0);            for (int val : (int[]) record.get("myrecordarraya")) {                recordConsumer.addInteger(val);            }            recordConsumer.endField("a", 0);            recordConsumer.startField("b", 1);            for (int val : (int[]) record.get("myrecordarrayb")) {                recordConsumer.addInteger(val);            }            recordConsumer.endField("b", 1);            recordConsumer.endGroup();            recordConsumer.endField("array", 0);            recordConsumer.endGroup();            recordConsumer.endField("myrecordarray", index++);            recordConsumer.startField("mymap", index);            recordConsumer.startGroup();            recordConsumer.startField("map", 0);            recordConsumer.startGroup();            Map<String, Integer> mymap = (Map<String, Integer>) record.get("mymap");            recordConsumer.startField("key", 0);            for (String key : mymap.keySet()) {                recordConsumer.addBinary(Binary.fromString(key));            }            recordConsumer.endField("key", 0);            recordConsumer.startField("value", 1);            for (int val : mymap.values()) {                recordConsumer.addInteger(val);            }            recordConsumer.endField("value", 1);            recordConsumer.endGroup();            recordConsumer.endField("map", 0);            recordConsumer.endGroup();            recordConsumer.endField("mymap", index++);            recordConsumer.startField("myfixed", index);            recordConsumer.addBinary(Binary.fromReusedByteArray((byte[]) record.get("myfixed")));            recordConsumer.endField("myfixed", index++);            recordConsumer.endMessage();        }    })) {        Map<String, Object> record = new HashMap<String, Object>();        record.put("myboolean", true);        record.put("myint", 1);        record.put("mylong", 2L);        record.put("myfloat", 3.1f);        record.put("mydouble", 4.1);        record.put("mybytes", ByteBuffer.wrap("hello".getBytes(StandardCharsets.UTF_8)));        record.put("mystring", "hello");        record.put("myenum", "a");        record.put("mynestedint", 1);        record.put("myarray", new int[] { 1, 2, 3 });        record.put("myoptionalarray", new int[] { 1, 2, 3 });        record.put("myarrayofoptional", new Integer[] { 1, null, 2, null, 3 });        record.put("myrecordarraya", new int[] { 1, 2, 3 });        record.put("myrecordarrayb", new int[] { 4, 5, 6 });        record.put("mymap", ImmutableMap.of("a", 1, "b", 2));        record.put("myfixed", new byte[] { (byte) 65 });        parquetWriter.write(record);    }    Schema nestedRecordSchema = Schema.createRecord("mynestedrecord", null, null, false);    nestedRecordSchema.setFields(Arrays.asList(new Schema.Field("mynestedint", Schema.create(Schema.Type.INT), null, null)));    GenericData.Record nestedRecord = new GenericRecordBuilder(nestedRecordSchema).set("mynestedint", 1).build();    List<Integer> integerArray = Arrays.asList(1, 2, 3);    Schema recordArraySchema = Schema.createRecord("array", null, null, false);    recordArraySchema.setFields(Arrays.asList(new Schema.Field("a", Schema.create(Schema.Type.INT), null, null), new Schema.Field("b", Schema.create(Schema.Type.INT), null, null)));    GenericRecordBuilder builder = new GenericRecordBuilder(recordArraySchema);    List<GenericData.Record> recordArray = new ArrayList<GenericData.Record>();    recordArray.add(builder.set("a", 1).set("b", 4).build());    recordArray.add(builder.set("a", 2).set("b", 5).build());    recordArray.add(builder.set("a", 3).set("b", 6).build());    GenericData.Array<GenericData.Record> genericRecordArray = new GenericData.Array<GenericData.Record>(Schema.createArray(recordArraySchema), recordArray);    GenericFixed genericFixed = new GenericData.Fixed(Schema.createFixed("fixed", null, null, 1), new byte[] { (byte) 65 });        Schema elementSchema = record("list", optionalField("element", primitive(Schema.Type.INT)));    GenericRecordBuilder elementBuilder = new GenericRecordBuilder(elementSchema);    GenericData.Array<GenericData.Record> genericRecordArrayWithNullIntegers = new GenericData.Array<GenericData.Record>(array(elementSchema), Arrays.asList(elementBuilder.set("element", 1).build(), elementBuilder.set("element", null).build(), elementBuilder.set("element", 2).build(), elementBuilder.set("element", null).build(), elementBuilder.set("element", 3).build()));    try (AvroParquetReader<GenericRecord> reader = new AvroParquetReader<>(testConf, file)) {        GenericRecord nextRecord = reader.read();        assertNotNull(nextRecord);        assertEquals(true, nextRecord.get("myboolean"));        assertEquals(1, nextRecord.get("myint"));        assertEquals(2L, nextRecord.get("mylong"));        assertEquals(3.1f, nextRecord.get("myfloat"));        assertEquals(4.1, nextRecord.get("mydouble"));        assertEquals(ByteBuffer.wrap("hello".getBytes(StandardCharsets.UTF_8)), nextRecord.get("mybytes"));        assertEquals(str("hello"), nextRecord.get("mystring"));        assertEquals(str("a"), nextRecord.get("myenum"));        assertEquals(nestedRecord, nextRecord.get("mynestedrecord"));        assertEquals(integerArray, nextRecord.get("myarray"));        assertEquals(integerArray, nextRecord.get("myoptionalarray"));        assertEquals(genericRecordArrayWithNullIntegers, nextRecord.get("myarrayofoptional"));        assertEquals(genericRecordArray, nextRecord.get("myrecordarray"));        assertEquals(ImmutableMap.of(str("a"), 1, str("b"), 2), nextRecord.get("mymap"));        assertEquals(genericFixed, nextRecord.get("myfixed"));    }}
89835da140a91d5cb5181a85b8db073a92d794e99966f7422502dbb7d5467b7c
init
public WriteContext init(Configuration configuration)
{    return new WriteContext(MessageTypeParser.parseMessageType(TestAvroSchemaConverter.ALL_PARQUET_SCHEMA), new HashMap<String, String>());}
da9aef78cf181856102b820ffa7d5248e8581747b3f0670a7b049c4649b962ef
prepareForWrite
public void prepareForWrite(RecordConsumer recordConsumer)
{    this.recordConsumer = recordConsumer;}
6900f0c69cb433cbba76f9d1ffe12dd45899852f1b6124e0469c544663df1fbd
write
public void write(Map<String, Object> record)
{    recordConsumer.startMessage();    int index = 0;    recordConsumer.startField("myboolean", index);    recordConsumer.addBoolean((Boolean) record.get("myboolean"));    recordConsumer.endField("myboolean", index++);    recordConsumer.startField("myint", index);    recordConsumer.addInteger((Integer) record.get("myint"));    recordConsumer.endField("myint", index++);    recordConsumer.startField("mylong", index);    recordConsumer.addLong((Long) record.get("mylong"));    recordConsumer.endField("mylong", index++);    recordConsumer.startField("myfloat", index);    recordConsumer.addFloat((Float) record.get("myfloat"));    recordConsumer.endField("myfloat", index++);    recordConsumer.startField("mydouble", index);    recordConsumer.addDouble((Double) record.get("mydouble"));    recordConsumer.endField("mydouble", index++);    recordConsumer.startField("mybytes", index);    recordConsumer.addBinary(Binary.fromReusedByteBuffer((ByteBuffer) record.get("mybytes")));    recordConsumer.endField("mybytes", index++);    recordConsumer.startField("mystring", index);    recordConsumer.addBinary(Binary.fromString((String) record.get("mystring")));    recordConsumer.endField("mystring", index++);    recordConsumer.startField("mynestedrecord", index);    recordConsumer.startGroup();    recordConsumer.startField("mynestedint", 0);    recordConsumer.addInteger((Integer) record.get("mynestedint"));    recordConsumer.endField("mynestedint", 0);    recordConsumer.endGroup();    recordConsumer.endField("mynestedrecord", index++);    recordConsumer.startField("myenum", index);    recordConsumer.addBinary(Binary.fromString((String) record.get("myenum")));    recordConsumer.endField("myenum", index++);    recordConsumer.startField("myarray", index);    recordConsumer.startGroup();    recordConsumer.startField("array", 0);    for (int val : (int[]) record.get("myarray")) {        recordConsumer.addInteger(val);    }    recordConsumer.endField("array", 0);    recordConsumer.endGroup();    recordConsumer.endField("myarray", index++);    recordConsumer.startField("myoptionalarray", index);    recordConsumer.startGroup();    recordConsumer.startField("array", 0);    for (int val : (int[]) record.get("myoptionalarray")) {        recordConsumer.addInteger(val);    }    recordConsumer.endField("array", 0);    recordConsumer.endGroup();    recordConsumer.endField("myoptionalarray", index++);    recordConsumer.startField("myarrayofoptional", index);    recordConsumer.startGroup();    recordConsumer.startField("list", 0);    for (Integer val : (Integer[]) record.get("myarrayofoptional")) {        recordConsumer.startGroup();        if (val != null) {            recordConsumer.startField("element", 0);            recordConsumer.addInteger(val);            recordConsumer.endField("element", 0);        }        recordConsumer.endGroup();    }    recordConsumer.endField("list", 0);    recordConsumer.endGroup();    recordConsumer.endField("myarrayofoptional", index++);    recordConsumer.startField("myrecordarray", index);    recordConsumer.startGroup();    recordConsumer.startField("array", 0);    recordConsumer.startGroup();    recordConsumer.startField("a", 0);    for (int val : (int[]) record.get("myrecordarraya")) {        recordConsumer.addInteger(val);    }    recordConsumer.endField("a", 0);    recordConsumer.startField("b", 1);    for (int val : (int[]) record.get("myrecordarrayb")) {        recordConsumer.addInteger(val);    }    recordConsumer.endField("b", 1);    recordConsumer.endGroup();    recordConsumer.endField("array", 0);    recordConsumer.endGroup();    recordConsumer.endField("myrecordarray", index++);    recordConsumer.startField("mymap", index);    recordConsumer.startGroup();    recordConsumer.startField("map", 0);    recordConsumer.startGroup();    Map<String, Integer> mymap = (Map<String, Integer>) record.get("mymap");    recordConsumer.startField("key", 0);    for (String key : mymap.keySet()) {        recordConsumer.addBinary(Binary.fromString(key));    }    recordConsumer.endField("key", 0);    recordConsumer.startField("value", 1);    for (int val : mymap.values()) {        recordConsumer.addInteger(val);    }    recordConsumer.endField("value", 1);    recordConsumer.endGroup();    recordConsumer.endField("map", 0);    recordConsumer.endGroup();    recordConsumer.endField("mymap", index++);    recordConsumer.startField("myfixed", index);    recordConsumer.addBinary(Binary.fromReusedByteArray((byte[]) record.get("myfixed")));    recordConsumer.endField("myfixed", index++);    recordConsumer.endMessage();}
5022c9c904c228710925661be3be70d84ce505ee405f04d8f7eedc5dc473cbcc
str
public CharSequence str(String value)
{    return compat ? value : new Utf8(value);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    Service service = (Service) o;    if (date != service.date)        return false;    if (!mechanic.equals(service.mechanic))        return false;    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = (int) (date ^ (date >>> 32));    result = 31 * result + mechanic.hashCode();    return result;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    Engine engine = (Engine) o;    if (Float.compare(engine.capacity, capacity) != 0)        return false;    if (hasTurboCharger != engine.hasTurboCharger)        return false;    if (type != engine.type)        return false;    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = type.hashCode();    result = 31 * result + (capacity != +0.0f ? Float.floatToIntBits(capacity) : 0);    result = 31 * result + (hasTurboCharger ? 1 : 0);    return result;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    Stereo stereo = (Stereo) o;    if (speakers != stereo.speakers)        return false;    if (!make.equals(stereo.make))        return false;    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = make.hashCode();    result = 31 * result + speakers;    return result;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    LeatherTrim that = (LeatherTrim) o;    if (!colour.equals(that.colour))        return false;    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return colour.hashCode();}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    Car car = (Car) o;    if (doors != car.doors)        return false;    if (year != car.year)        return false;    if (!engine.equals(car.engine))        return false;    if (!make.equals(car.make))        return false;    if (!model.equals(car.model))        return false;    if (optionalExtra != null ? !optionalExtra.equals(car.optionalExtra) : car.optionalExtra != null)        return false;    if (!registration.equals(car.registration))        return false;    if (serviceHistory != null ? !serviceHistory.equals(car.serviceHistory) : car.serviceHistory != null)        return false;    if (!Arrays.equals(vin, car.vin))        return false;    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = (int) (year ^ (year >>> 32));    result = 31 * result + registration.hashCode();    result = 31 * result + make.hashCode();    result = 31 * result + model.hashCode();    result = 31 * result + Arrays.hashCode(vin);    result = 31 * result + doors;    result = 31 * result + engine.hashCode();    result = 31 * result + (optionalExtra != null ? optionalExtra.hashCode() : 0);    result = 31 * result + (serviceHistory != null ? serviceHistory.hashCode() : 0);    return result;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    ShortCar shortCar = (ShortCar) o;    if (year != shortCar.year)        return false;    if (!engine.equals(shortCar.engine))        return false;    if (make != null ? !make.equals(shortCar.make) : shortCar.make != null)        return false;    if (!Arrays.equals(vin, shortCar.vin))        return false;    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = make != null ? make.hashCode() : 0;    result = 31 * result + engine.hashCode();    result = 31 * result + (int) (year ^ (year >>> 32));    result = 31 * result + Arrays.hashCode(vin);    return result;}
b930050cc38c1fc7e43b7a6a2e7388eb04a16997298b19c9f3b6c26dbe7b18bc
nextRecord
public static Car nextRecord(int i)
{    Car car = new Car();    car.doors = 2;    car.make = "Tesla";    car.model = String.format("Model X v%d", i % 2);    car.vin = String.format("1VXBR12EXCP%06d", i).getBytes();    car.year = 2014 + i;    car.registration = "California";    LeatherTrim trim = new LeatherTrim();    trim.colour = "black";    car.optionalExtra = trim;    Engine engine = new Engine();    engine.capacity = 85.0f;    engine.type = (i % 2) == 0 ? EngineType.ELECTRIC : EngineType.PETROL;    engine.hasTurboCharger = false;    car.engine = engine;    if (i % 4 == 0) {        Service service = new Service();        service.date = 1374084640;        service.mechanic = "Elon Musk";        car.serviceHistory = Lists.newArrayList();        car.serviceHistory.add(service);    }    return car;}
f1b79cd73081803aac4d597efe66cc1e35d6cdcd7d3d407951eb90b869e57624
run
public void run(Context context) throws IOException, InterruptedException
{    for (int i = 0; i < 10; i++) {        context.write(null, nextRecord(i));    }}
6e5c239df36debebb73210d0ce464a87c41bb637fede84d97cd92e2919fb9c19
map
protected void map(Void key, Car car, Context context) throws IOException, InterruptedException
{        if (car != null) {        context.write(null, car);    }}
78e488be58b011c4b4e2c5b7988448b8f73a6122854558d3c4c10f6618b8e90f
map
protected void map(Void key, ShortCar car, Context context) throws IOException, InterruptedException
{        if (car != null) {        context.write(null, car);    }}
2cb2b8c29fc2760c915562b8d3ac4268c4018003c9027c17b546700c2a89961d
bind
public RecordFilter bind(Iterable<ColumnReader> readers)
{    return filter.bind(readers);}
288be8129d888f0932100daa65a087beed0bf926a2f25825efc643d9ea6584db
createParquetFile
public void createParquetFile() throws Exception
{        conf.setBoolean(AvroReadSupport.AVRO_COMPATIBILITY, false);    AvroReadSupport.setAvroDataSupplier(conf, ReflectDataSupplier.class);    AvroWriteSupport.setAvroDataSupplier(conf, ReflectDataSupplier.class);    final FileSystem fileSystem = parquetPath.getFileSystem(conf);    fileSystem.delete(parquetPath, true);    fileSystem.delete(outputPath, true);    {        final Job job = new Job(conf, "write");                TextInputFormat.addInputPath(job, inputPath);        job.setInputFormatClass(TextInputFormat.class);        job.setMapperClass(TestReflectInputOutputFormat.MyMapper.class);        job.setNumReduceTasks(0);        job.setOutputFormatClass(AvroParquetOutputFormat.class);        AvroParquetOutputFormat.setOutputPath(job, parquetPath);        AvroParquetOutputFormat.setSchema(job, CAR_SCHEMA);        AvroParquetOutputFormat.setAvroDataSupplier(job, ReflectDataSupplier.class);        waitForJob(job);    }}
c2c75b5eb5762dda20687d84e7565d4cf3b9de60742e0694a6cffba3f16ea18a
testReadWrite
public void testReadWrite() throws Exception
{    conf.setBoolean(AvroReadSupport.AVRO_COMPATIBILITY, false);    final Job job = new Job(conf, "read");    job.setInputFormatClass(AvroParquetInputFormat.class);    AvroParquetInputFormat.setInputPaths(job, parquetPath);        AvroParquetInputFormat.setUnboundRecordFilter(job, ElectricCarFilter.class);        Schema projection = Schema.createRecord(CAR_SCHEMA.getName(), CAR_SCHEMA.getDoc(), CAR_SCHEMA.getNamespace(), false);    List<Schema.Field> fields = Lists.newArrayList();    for (Schema.Field field : ReflectData.get().getSchema(Car.class).getFields()) {        if (!"optionalExtra".equals(field.name())) {            fields.add(new Schema.Field(field.name(), field.schema(), field.doc(), field.defaultVal(), field.order()));        }    }    projection.setFields(fields);    AvroParquetInputFormat.setRequestedProjection(job, projection);    job.setMapperClass(TestReflectInputOutputFormat.MyMapper2.class);    job.setNumReduceTasks(0);    job.setOutputFormatClass(AvroParquetOutputFormat.class);    AvroParquetOutputFormat.setOutputPath(job, outputPath);    AvroParquetOutputFormat.setSchema(job, CAR_SCHEMA);    waitForJob(job);    final Path mapperOutput = new Path(outputPath.toString(), "part-m-00000.parquet");    try (final AvroParquetReader<Car> out = new AvroParquetReader<Car>(conf, mapperOutput)) {        Car car;        Car previousCar = null;        int lineNumber = 0;        while ((car = out.read()) != null) {            if (previousCar != null) {                                assertTrue(car.model == previousCar.model);            }                        if (car.engine.type == EngineType.PETROL) {                fail("UnboundRecordFilter failed to remove cars with PETROL engines");            }                        Car expectedCar = nextRecord(lineNumber * 2);                                    expectedCar.optionalExtra = null;            assertEquals("line " + lineNumber, expectedCar, car);            ++lineNumber;            previousCar = car;        }    }}
fbb6681d649e7c9eb7b00c08e09019c502f2bf753fb64a1eeb6e65e8ac877460
testReadWriteChangedCar
public void testReadWriteChangedCar() throws Exception
{    conf.setBoolean(AvroReadSupport.AVRO_COMPATIBILITY, false);    final Job job = new Job(conf, "read changed/short");    job.setInputFormatClass(AvroParquetInputFormat.class);    AvroParquetInputFormat.setInputPaths(job, parquetPath);        AvroParquetInputFormat.setUnboundRecordFilter(job, ElectricCarFilter.class);            Schema projection = Schema.createRecord(CAR_SCHEMA.getName(), CAR_SCHEMA.getDoc(), CAR_SCHEMA.getNamespace(), false);    List<Schema.Field> fields = Lists.newArrayList();    for (Schema.Field field : CAR_SCHEMA.getFields()) {                if ("engine".equals(field.name()) || "year".equals(field.name()) || "vin".equals(field.name())) {            fields.add(new Schema.Field(field.name(), field.schema(), field.doc(), field.defaultVal(), field.order()));        }    }    projection.setFields(fields);    AvroParquetInputFormat.setRequestedProjection(job, projection);    AvroParquetInputFormat.setAvroReadSchema(job, SHORT_CAR_SCHEMA);    job.setMapperClass(TestReflectInputOutputFormat.MyMapperShort.class);    job.setNumReduceTasks(0);    job.setOutputFormatClass(AvroParquetOutputFormat.class);    AvroParquetOutputFormat.setOutputPath(job, outputPath);    AvroParquetOutputFormat.setSchema(job, SHORT_CAR_SCHEMA);    waitForJob(job);    final Path mapperOutput = new Path(outputPath.toString(), "part-m-00000.parquet");    try (final AvroParquetReader<ShortCar> out = new AvroParquetReader<ShortCar>(conf, mapperOutput)) {        ShortCar car;        int lineNumber = 0;        while ((car = out.read()) != null) {                                    Car expectedCar = nextRecord(lineNumber * 2);                        assertNull(car.make);            assertEquals(car.engine, expectedCar.engine);            assertEquals(car.year, expectedCar.year);            assertArrayEquals(car.vin, expectedCar.vin);            ++lineNumber;        }    }}
1ae73b30cdadc8449c547b5e2074b79321881a77c70d90b50bd9f3775f37e746
waitForJob
private void waitForJob(Job job) throws Exception
{    job.submit();    while (!job.isComplete()) {        LOG.debug("waiting for job {}", job.getJobName());        sleep(100);    }    LOG.info("status for job {}: {}", job.getJobName(), (job.isSuccessful() ? "SUCCESS" : "FAILURE"));    if (!job.isSuccessful()) {        throw new RuntimeException("job failed " + job.getJobName());    }}
483272a117c358206cc534bd168d0c6913089706e527353cca82168a09958303
deleteOutputFile
public void deleteOutputFile() throws IOException
{    final FileSystem fileSystem = parquetPath.getFileSystem(conf);    fileSystem.delete(parquetPath, true);    fileSystem.delete(outputPath, true);}
c78a2cc719311a35d2269da4b94079757dab5a1616c68abe27876bcfd26dc419
addUUID
public static void addUUID()
{    REFLECT.addLogicalTypeConversion(new Conversions.UUIDConversion());    REFLECT.addLogicalTypeConversion(new Conversions.DecimalConversion());}
071efc21ec33a61a65413f9da20ec49f6cc5cae6962150c32cf6ef9c89737a64
testReflectedSchema
public void testReflectedSchema()
{    Schema expected = SchemaBuilder.record(RecordWithUUIDList.class.getName()).fields().name("uuids").type().array().items().stringType().noDefault().endRecord();    expected.getField("uuids").schema().addProp(SpecificData.CLASS_PROP, List.class.getName());    LogicalTypes.uuid().addToSchema(expected.getField("uuids").schema().getElementType());    Schema actual = REFLECT.getSchema(RecordWithUUIDList.class);    Assert.assertEquals("Should use the UUID logical type", expected, actual);}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    if (this == other) {        return true;    }    if (other == null || getClass() != other.getClass()) {        return false;    }    DecimalRecordBytes that = (DecimalRecordBytes) other;    if (decimal == null) {        return (that.decimal == null);    }    return decimal.equals(that.decimal);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return decimal != null ? decimal.hashCode() : 0;}
1b965e6f6f2059c42aec81533e0ae549d07f781c803aca3564de1d4fdc8b27ac
testDecimalBytes
public void testDecimalBytes() throws IOException
{    Schema schema = REFLECT.getSchema(DecimalRecordBytes.class);    Assert.assertEquals("Should have the correct record name", "org.apache.parquet.avro.TestReflectLogicalTypes", schema.getNamespace());    Assert.assertEquals("Should have the correct record name", "DecimalRecordBytes", schema.getName());    Assert.assertEquals("Should have the correct logical type", LogicalTypes.decimal(9, 2), LogicalTypes.fromSchema(schema.getField("decimal").schema()));    DecimalRecordBytes record = new DecimalRecordBytes();    record.decimal = new BigDecimal("3.14");    File test = write(REFLECT, schema, record);    Assert.assertEquals("Should match the decimal after round trip", Arrays.asList(record), read(REFLECT, schema, test));}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    if (this == other) {        return true;    }    if (other == null || getClass() != other.getClass()) {        return false;    }    DecimalRecordFixed that = (DecimalRecordFixed) other;    if (decimal == null) {        return (that.decimal == null);    }    return decimal.equals(that.decimal);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return decimal != null ? decimal.hashCode() : 0;}
62b5715c7bfc33517db7a7a2c02a7d6191cd3abf2f5b837e8f0f19b3b952f794
testDecimalFixed
public void testDecimalFixed() throws IOException
{    Schema schema = REFLECT.getSchema(DecimalRecordFixed.class);    Assert.assertEquals("Should have the correct record name", "org.apache.parquet.avro.TestReflectLogicalTypes", schema.getNamespace());    Assert.assertEquals("Should have the correct record name", "DecimalRecordFixed", schema.getName());    Assert.assertEquals("Should have the correct logical type", LogicalTypes.decimal(9, 2), LogicalTypes.fromSchema(schema.getField("decimal").schema()));    DecimalRecordFixed record = new DecimalRecordFixed();    record.decimal = new BigDecimal("3.14");    File test = write(REFLECT, schema, record);    Assert.assertEquals("Should match the decimal after round trip", Arrays.asList(record), read(REFLECT, schema, test));}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    if (this == other) {        return true;    }    if (other == null || getClass() != other.getClass()) {        return false;    }    Pair<?, ?> that = (Pair<?, ?>) other;    if (first == null) {        if (that.first != null) {            return false;        }    } else if (first.equals(that.first)) {        return false;    }    if (second == null) {        if (that.second != null) {            return false;        }    } else if (second.equals(that.second)) {        return false;    }    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return Arrays.hashCode(new Object[] { first, second });}
4731bda55f30a54c171eed7c76d740820313a690ee2451f8a913b230c9fd0ff8
of
public static Pair<X, Y> of(X first, Y second)
{    return new Pair<X, Y>(first, second);}
2c04dbb7a88bca04cb2bc2f834d6bf675f22af801cb282779bcecc25be03224c
testPairRecord
public void testPairRecord() throws IOException
{    ReflectData model = new ReflectData();    model.addLogicalTypeConversion(new Conversion<Pair>() {        @Override        public Class<Pair> getConvertedType() {            return Pair.class;        }        @Override        public String getLogicalTypeName() {            return "pair";        }        @Override        public Pair fromRecord(IndexedRecord value, Schema schema, LogicalType type) {            return Pair.of(value.get(0), value.get(1));        }        @Override        public IndexedRecord toRecord(Pair value, Schema schema, LogicalType type) {            GenericData.Record record = new GenericData.Record(schema);            record.put(0, value.first);            record.put(1, value.second);            return record;        }    });    LogicalTypes.register("pair", new LogicalTypes.LogicalTypeFactory() {        private final LogicalType PAIR = new LogicalType("pair");        @Override        public LogicalType fromSchema(Schema schema) {            return PAIR;        }    });    Schema schema = model.getSchema(PairRecord.class);    Assert.assertEquals("Should have the correct record name", "org.apache.parquet.avro.TestReflectLogicalTypes", schema.getNamespace());    Assert.assertEquals("Should have the correct record name", "PairRecord", schema.getName());    Assert.assertEquals("Should have the correct logical type", "pair", LogicalTypes.fromSchema(schema.getField("pair").schema()).getName());    PairRecord record = new PairRecord();    record.pair = Pair.of(34L, 35L);    List<PairRecord> expected = new ArrayList<PairRecord>();    expected.add(record);    File test = write(model, schema, record);    Pair<Long, Long> actual = AvroTestUtil.<PairRecord>read(model, schema, test).get(0).pair;    Assert.assertEquals("Data should match after serialization round-trip", 34L, (long) actual.first);    Assert.assertEquals("Data should match after serialization round-trip", 35L, (long) actual.second);}
c47891dc46949f710f7acd64b42a5744d272939b18e20c720b0af99fbc450d83
getConvertedType
public Class<Pair> getConvertedType()
{    return Pair.class;}
79c42293ac3a43d7598dc0ac8104dd9a114e436cd5a14a6241ebbe2b10b5f8ba
getLogicalTypeName
public String getLogicalTypeName()
{    return "pair";}
1909abfe0c0ba443d0b29e153662518cbbc0c6976153a009e5cd7d919e5bcf32
fromRecord
public Pair fromRecord(IndexedRecord value, Schema schema, LogicalType type)
{    return Pair.of(value.get(0), value.get(1));}
f3412facdc8cda4f04818667af26a55ce091194372af534c62a27e784bf397b3
toRecord
public IndexedRecord toRecord(Pair value, Schema schema, LogicalType type)
{    GenericData.Record record = new GenericData.Record(schema);    record.put(0, value.first);    record.put(1, value.second);    return record;}
36dfb5961f1202e55daceaf634633d8efcfa821d6e42fb8a497c9c8192f70340
fromSchema
public LogicalType fromSchema(Schema schema)
{    return PAIR;}
341a32cdb578b032c85976394fe125322cbb295129f6fa0c4687a1cf7fcac9b7
testReadUUID
public void testReadUUID() throws IOException
{    Schema uuidSchema = SchemaBuilder.record(RecordWithUUID.class.getName()).fields().requiredString("uuid").endRecord();    LogicalTypes.uuid().addToSchema(uuidSchema.getField("uuid").schema());    UUID u1 = UUID.randomUUID();    UUID u2 = UUID.randomUUID();    RecordWithStringUUID r1 = new RecordWithStringUUID();    r1.uuid = u1.toString();    RecordWithStringUUID r2 = new RecordWithStringUUID();    r2.uuid = u2.toString();    List<RecordWithUUID> expected = Arrays.asList(new RecordWithUUID(), new RecordWithUUID());    expected.get(0).uuid = u1;    expected.get(1).uuid = u2;    File test = write(ReflectData.get().getSchema(RecordWithStringUUID.class), r1, r2);    Assert.assertEquals("Should convert Strings to UUIDs", expected, read(REFLECT, uuidSchema, test));        Schema uuidStringSchema = SchemaBuilder.record(RecordWithStringUUID.class.getName()).fields().requiredString("uuid").endRecord();    LogicalTypes.uuid().addToSchema(uuidStringSchema.getField("uuid").schema());    Assert.assertEquals("Should not convert to UUID if accessor is String", Arrays.asList(r1, r2), read(REFLECT, uuidStringSchema, test));}
f676a4d4af81cef00217a0e7b523cf04ddf8dae70106924cb49096112ed8f83a
testWriteUUID
public void testWriteUUID() throws IOException
{    Schema uuidSchema = SchemaBuilder.record(RecordWithUUID.class.getName()).fields().requiredString("uuid").endRecord();    LogicalTypes.uuid().addToSchema(uuidSchema.getField("uuid").schema());    UUID u1 = UUID.randomUUID();    UUID u2 = UUID.randomUUID();    RecordWithUUID r1 = new RecordWithUUID();    r1.uuid = u1;    RecordWithUUID r2 = new RecordWithUUID();    r2.uuid = u2;    List<RecordWithStringUUID> expected = Arrays.asList(new RecordWithStringUUID(), new RecordWithStringUUID());    expected.get(0).uuid = u1.toString();    expected.get(1).uuid = u2.toString();    File test = write(REFLECT, uuidSchema, r1, r2);        Schema uuidStringSchema = SchemaBuilder.record(RecordWithStringUUID.class.getName()).fields().requiredString("uuid").endRecord();    Assert.assertEquals("Should read uuid as String without UUID conversion", expected, read(REFLECT, uuidStringSchema, test));    LogicalTypes.uuid().addToSchema(uuidStringSchema.getField("uuid").schema());    Assert.assertEquals("Should read uuid as String without UUID logical type", expected, read(ReflectData.get(), uuidStringSchema, test));}
9530cd72742c23bd9ab88394040d60173676edfbea92b7ef409b7641a156f56b
testWriteNullableUUID
public void testWriteNullableUUID() throws IOException
{    Schema nullableUuidSchema = SchemaBuilder.record(RecordWithUUID.class.getName()).fields().optionalString("uuid").endRecord();    LogicalTypes.uuid().addToSchema(nullableUuidSchema.getField("uuid").schema().getTypes().get(1));    UUID u1 = UUID.randomUUID();    UUID u2 = UUID.randomUUID();    RecordWithUUID r1 = new RecordWithUUID();    r1.uuid = u1;    RecordWithUUID r2 = new RecordWithUUID();    r2.uuid = u2;    List<RecordWithStringUUID> expected = Arrays.asList(new RecordWithStringUUID(), new RecordWithStringUUID());    expected.get(0).uuid = u1.toString();    expected.get(1).uuid = u2.toString();    File test = write(REFLECT, nullableUuidSchema, r1, r2);        Schema nullableUuidStringSchema = SchemaBuilder.record(RecordWithStringUUID.class.getName()).fields().optionalString("uuid").endRecord();    Assert.assertEquals("Should read uuid as String without UUID conversion", expected, read(REFLECT, nullableUuidStringSchema, test));}
105367f5a66c82cb5ab17a1960182e4980311dfd970926dc292c3a8014dd3fd0
testWriteUUIDMissingLogicalType
public void testWriteUUIDMissingLogicalType() throws IOException
{    Schema uuidSchema = SchemaBuilder.record(RecordWithUUID.class.getName()).fields().requiredString("uuid").endRecord();    LogicalTypes.uuid().addToSchema(uuidSchema.getField("uuid").schema());    UUID u1 = UUID.randomUUID();    UUID u2 = UUID.randomUUID();    RecordWithUUID r1 = new RecordWithUUID();    r1.uuid = u1;    RecordWithUUID r2 = new RecordWithUUID();    r2.uuid = u2;    List<RecordWithStringUUID> expected = Arrays.asList(new RecordWithStringUUID(), new RecordWithStringUUID());    expected.get(0).uuid = u1.toString();    expected.get(1).uuid = u2.toString();        File test = write(uuidSchema, r1, r2);        Schema uuidStringSchema = SchemaBuilder.record(RecordWithStringUUID.class.getName()).fields().requiredString("uuid").endRecord();    Assert.assertEquals("Should read uuid as String without UUID conversion", expected, read(REFLECT, uuidStringSchema, test));    Assert.assertEquals("Should read uuid as String without UUID logical type", expected, read(ReflectData.get(), uuidStringSchema, test));}
019cd0f0172c3c08147773723ce04b8582434d681775f4895f43d05f9cf695a5
testReadUUIDGenericRecord
public void testReadUUIDGenericRecord() throws IOException
{    Schema uuidSchema = SchemaBuilder.record("RecordWithUUID").fields().requiredString("uuid").endRecord();    LogicalTypes.uuid().addToSchema(uuidSchema.getField("uuid").schema());    UUID u1 = UUID.randomUUID();    UUID u2 = UUID.randomUUID();    RecordWithStringUUID r1 = new RecordWithStringUUID();    r1.uuid = u1.toString();    RecordWithStringUUID r2 = new RecordWithStringUUID();    r2.uuid = u2.toString();    List<GenericData.Record> expected = Arrays.asList(new GenericData.Record(uuidSchema), new GenericData.Record(uuidSchema));    expected.get(0).put("uuid", u1);    expected.get(1).put("uuid", u2);    File test = write(ReflectData.get().getSchema(RecordWithStringUUID.class), r1, r2);    Assert.assertEquals("Should convert Strings to UUIDs", expected, read(REFLECT, uuidSchema, test));        Schema uuidStringSchema = SchemaBuilder.record(RecordWithStringUUID.class.getName()).fields().requiredString("uuid").endRecord();    LogicalTypes.uuid().addToSchema(uuidSchema.getField("uuid").schema());    Assert.assertEquals("Should not convert to UUID if accessor is String", Arrays.asList(r1, r2), read(REFLECT, uuidStringSchema, test));}
50361a62e41561873c0f47a341ad84c7a27c3c5392444fd7bf162d1bdfba6a90
testReadUUIDArray
public void testReadUUIDArray() throws IOException
{    Schema uuidArraySchema = SchemaBuilder.record(RecordWithUUIDArray.class.getName()).fields().name("uuids").type().array().items().stringType().noDefault().endRecord();    LogicalTypes.uuid().addToSchema(uuidArraySchema.getField("uuids").schema().getElementType());    UUID u1 = UUID.randomUUID();    UUID u2 = UUID.randomUUID();    GenericRecord r = new GenericData.Record(uuidArraySchema);    r.put("uuids", Arrays.asList(u1.toString(), u2.toString()));    RecordWithUUIDArray expected = new RecordWithUUIDArray();    expected.uuids = new UUID[] { u1, u2 };    File test = write(uuidArraySchema, r);    Assert.assertEquals("Should convert Strings to UUIDs", expected, read(REFLECT, uuidArraySchema, test).get(0));}
531554f7a7efcaa6336fd72ed5e3dd580b60a4ffcdb4f9ba760e0c0e7468b983
testWriteUUIDArray
public void testWriteUUIDArray() throws IOException
{    Schema uuidArraySchema = SchemaBuilder.record(RecordWithUUIDArray.class.getName()).fields().name("uuids").type().array().items().stringType().noDefault().endRecord();    LogicalTypes.uuid().addToSchema(uuidArraySchema.getField("uuids").schema().getElementType());    Schema stringArraySchema = SchemaBuilder.record("RecordWithUUIDArray").fields().name("uuids").type().array().items().stringType().noDefault().endRecord();    stringArraySchema.getField("uuids").schema().addProp(SpecificData.CLASS_PROP, List.class.getName());    UUID u1 = UUID.randomUUID();    UUID u2 = UUID.randomUUID();    GenericRecord expected = new GenericData.Record(stringArraySchema);    List<String> uuids = new ArrayList<String>();    uuids.add(u1.toString());    uuids.add(u2.toString());    expected.put("uuids", uuids);    RecordWithUUIDArray r = new RecordWithUUIDArray();    r.uuids = new UUID[] { u1, u2 };    File test = write(REFLECT, uuidArraySchema, r);    Assert.assertEquals("Should read UUIDs as Strings", expected, read(ReflectData.get(), stringArraySchema, test).get(0));}
614828981f4219d9de96b3f274b55e3649fd9c3256302c3bbcf68b61ac941293
testReadUUIDList
public void testReadUUIDList() throws IOException
{    Schema uuidListSchema = SchemaBuilder.record(RecordWithUUIDList.class.getName()).fields().name("uuids").type().array().items().stringType().noDefault().endRecord();    uuidListSchema.getField("uuids").schema().addProp(SpecificData.CLASS_PROP, List.class.getName());    LogicalTypes.uuid().addToSchema(uuidListSchema.getField("uuids").schema().getElementType());    UUID u1 = UUID.randomUUID();    UUID u2 = UUID.randomUUID();    GenericRecord r = new GenericData.Record(uuidListSchema);    r.put("uuids", Arrays.asList(u1.toString(), u2.toString()));    RecordWithUUIDList expected = new RecordWithUUIDList();    expected.uuids = Arrays.asList(u1, u2);    File test = write(uuidListSchema, r);    Assert.assertEquals("Should convert Strings to UUIDs", expected, read(REFLECT, uuidListSchema, test).get(0));}
a8fe40c2000d9deeed638f97c318ec6aca2b0293c73b19631d80c04142046ad3
testWriteUUIDList
public void testWriteUUIDList() throws IOException
{    Schema uuidListSchema = SchemaBuilder.record(RecordWithUUIDList.class.getName()).fields().name("uuids").type().array().items().stringType().noDefault().endRecord();    uuidListSchema.getField("uuids").schema().addProp(SpecificData.CLASS_PROP, List.class.getName());    LogicalTypes.uuid().addToSchema(uuidListSchema.getField("uuids").schema().getElementType());    Schema stringArraySchema = SchemaBuilder.record("RecordWithUUIDArray").fields().name("uuids").type().array().items().stringType().noDefault().endRecord();    stringArraySchema.getField("uuids").schema().addProp(SpecificData.CLASS_PROP, List.class.getName());    UUID u1 = UUID.randomUUID();    UUID u2 = UUID.randomUUID();    GenericRecord expected = new GenericData.Record(stringArraySchema);    expected.put("uuids", Arrays.asList(u1.toString(), u2.toString()));    RecordWithUUIDList r = new RecordWithUUIDList();    r.uuids = Arrays.asList(u1, u2);    File test = write(REFLECT, uuidListSchema, r);    Assert.assertEquals("Should read UUIDs as Strings", expected, read(REFLECT, stringArraySchema, test).get(0));}
7266ec28b8527de20895c66429c2ca054a197631a9a47bd401e7254cbbc068a7
write
private File write(Schema schema, D... data) throws IOException
{    return write(ReflectData.get(), schema, data);}
28e27a5e2a408002182af84ed4939b4f658ea15840fb2ad3c9de4f0e687bfabe
write
private File write(GenericData model, Schema schema, D... data) throws IOException
{    return AvroTestUtil.write(temp, model, schema, data);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return uuid.hashCode();}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (obj == null) {        return false;    }    if (!(obj instanceof RecordWithUUID)) {        return false;    }    RecordWithUUID that = (RecordWithUUID) obj;    return this.uuid.equals(that.uuid);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return uuid.hashCode();}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (obj == null) {        return false;    }    if (!(obj instanceof RecordWithStringUUID)) {        return false;    }    RecordWithStringUUID that = (RecordWithStringUUID) obj;    return this.uuid.equals(that.uuid);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return Arrays.hashCode(uuids);}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (obj == null) {        return false;    }    if (!(obj instanceof RecordWithUUIDArray)) {        return false;    }    RecordWithUUIDArray that = (RecordWithUUIDArray) obj;    return Arrays.equals(this.uuids, that.uuids);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return uuids.hashCode();}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (obj == null) {        return false;    }    if (!(obj instanceof RecordWithUUIDList)) {        return false;    }    RecordWithUUIDList that = (RecordWithUUIDList) obj;    return this.uuids.equals(that.uuids);}
008e803771db8f9b7d02b04a09ddf5a536bf2b17159760252b1f65473862f9ac
testReadWriteReflect
public void testReadWriteReflect() throws IOException
{    Configuration conf = new Configuration(false);    conf.setBoolean(AvroReadSupport.AVRO_COMPATIBILITY, false);    AvroReadSupport.setAvroDataSupplier(conf, ReflectDataSupplier.class);    Path path = writePojosToParquetFile(10, CompressionCodecName.UNCOMPRESSED, false);    try (ParquetReader<Pojo> reader = new AvroParquetReader<Pojo>(conf, path)) {        Pojo object = getPojo();        for (int i = 0; i < 10; i++) {            assertEquals(object, reader.read());        }        assertNull(reader.read());    }}
51792682a5db84850c7522c54d59d31f3c46c60926263fa452c65032194b5cbd
testWriteReflectReadGeneric
public void testWriteReflectReadGeneric() throws IOException
{    Configuration conf = new Configuration(false);    conf.setBoolean(AvroReadSupport.AVRO_COMPATIBILITY, false);    AvroReadSupport.setAvroDataSupplier(conf, GenericDataSupplier.class);    Path path = writePojosToParquetFile(2, CompressionCodecName.UNCOMPRESSED, false);    try (ParquetReader<GenericRecord> reader = new AvroParquetReader<GenericRecord>(conf, path)) {        GenericRecord object = getGenericPojoUtf8();        for (int i = 0; i < 2; i += 1) {            assertEquals(object, reader.read());        }        assertNull(reader.read());    }}
b1831810e11bca2f54f0928085ddbaff0b5c4280f1521a1ccbf9e34ca72b9779
getGenericPojoUtf8
private GenericRecord getGenericPojoUtf8()
{    Schema schema = ReflectData.get().getSchema(Pojo.class);    GenericData.Record record = new GenericData.Record(schema);    record.put("myboolean", true);    record.put("mybyte", 1);    record.put("myshort", 1);    record.put("myint", 1);    record.put("mylong", 2L);    record.put("myfloat", 3.1f);    record.put("mydouble", 4.1);    record.put("mybytes", ByteBuffer.wrap(new byte[] { 1, 2, 3, 4 }));    record.put("mystring", new Utf8("Hello"));    record.put("myenum", new GenericData.EnumSymbol(schema.getField("myenum").schema(), "A"));    Map<CharSequence, CharSequence> map = new HashMap<CharSequence, CharSequence>();    map.put(new Utf8("a"), new Utf8("1"));    map.put(new Utf8("b"), new Utf8("2"));    record.put("mymap", map);    record.put("myshortarray", new GenericData.Array<Integer>(schema.getField("myshortarray").schema(), Lists.newArrayList(1, 2)));    record.put("myintarray", new GenericData.Array<Integer>(schema.getField("myintarray").schema(), Lists.newArrayList(1, 2)));    record.put("mystringarray", new GenericData.Array<Utf8>(schema.getField("mystringarray").schema(), Lists.newArrayList(new Utf8("a"), new Utf8("b"))));    record.put("mylist", new GenericData.Array<Utf8>(schema.getField("mylist").schema(), Lists.newArrayList(new Utf8("a"), new Utf8("b"), new Utf8("c"))));    record.put("mystringable", new StringableObj("blah blah"));    return record;}
4041e550bf9eaee0339e5c0527b0390a5228839e7eaec53c8d50f3a1e4f93e45
getPojo
private Pojo getPojo()
{    Pojo object = new Pojo();    object.myboolean = true;    object.mybyte = 1;    object.myshort = 1;    object.myint = 1;    object.mylong = 2L;    object.myfloat = 3.1f;    object.mydouble = 4.1;    object.mybytes = new byte[] { 1, 2, 3, 4 };    object.mystring = "Hello";    object.myenum = E.A;    Map<String, String> map = new HashMap<String, String>();    map.put("a", "1");    map.put("b", "2");    object.mymap = map;    object.myshortarray = new short[] { 1, 2 };    object.myintarray = new int[] { 1, 2 };    object.mystringarray = new String[] { "a", "b" };    object.mylist = Lists.newArrayList("a", "b", "c");    object.mystringable = new StringableObj("blah blah");    return object;}
f9138d0d7c77c50119d459ee598b02ba96c5f45c4c2a89e9fd9a10cc19cce582
writePojosToParquetFile
private Path writePojosToParquetFile(int num, CompressionCodecName compression, boolean enableDictionary) throws IOException
{    File tmp = File.createTempFile(getClass().getSimpleName(), ".tmp");    tmp.deleteOnExit();    tmp.delete();    Path path = new Path(tmp.getPath());    Pojo object = getPojo();    Schema schema = ReflectData.get().getSchema(object.getClass());    try (ParquetWriter<Pojo> writer = AvroParquetWriter.<Pojo>builder(path).withSchema(schema).withCompressionCodec(compression).withDataModel(ReflectData.get()).withDictionaryEncoding(enableDictionary).build()) {        for (int i = 0; i < num; i++) {            writer.write(object);        }    }    return path;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return this.value;}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    return other instanceof StringableObj && this.value.equals(((StringableObj) other).value);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof Pojo))        return false;    Pojo that = (Pojo) o;    return myboolean == that.myboolean && mybyte == that.mybyte && myshort == that.myshort && myint == that.myint && mylong == that.mylong && myfloat == that.myfloat && mydouble == that.mydouble && Arrays.equals(mybytes, that.mybytes) && mystring.equals(that.mystring) && myenum == that.myenum && mymap.equals(that.mymap) && Arrays.equals(myshortarray, that.myshortarray) && Arrays.equals(myintarray, that.myintarray) && Arrays.equals(mystringarray, that.mystringarray) && mylist.equals(that.mylist) && mystringable.equals(that.mystringable);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "Pojo{" + "myboolean=" + myboolean + ", mybyte=" + mybyte + ", myshort=" + myshort + ", myint=" + myint + ", mylong=" + mylong + ", myfloat=" + myfloat + ", mydouble=" + mydouble + ", mybytes=" + Arrays.toString(mybytes) + ", mystring='" + mystring + '\'' + ", myenum=" + myenum + ", mymap=" + mymap + ", myshortarray=" + Arrays.toString(myshortarray) + ", myintarray=" + Arrays.toString(myintarray) + ", mystringarray=" + Arrays.toString(mystringarray) + ", mylist=" + mylist + ", mystringable=" + mystringable.toString() + '}';}
b930050cc38c1fc7e43b7a6a2e7388eb04a16997298b19c9f3b6c26dbe7b18bc
nextRecord
public static Car nextRecord(int i)
{    String vin = "1VXBR12EXCP000000";    Car.Builder carBuilder = Car.newBuilder().setDoors(2).setMake("Tesla").setModel(String.format("Model X v%d", i % 2)).setVin(new Vin(vin.getBytes())).setYear(2014 + i).setOptionalExtra(LeatherTrim.newBuilder().setColour("black").build()).setRegistration("California");    Engine.Builder engineBuilder = Engine.newBuilder().setCapacity(85.0f).setHasTurboCharger(false);    if (i % 2 == 0) {        engineBuilder.setType(EngineType.ELECTRIC);    } else {        engineBuilder.setType(EngineType.PETROL);    }    carBuilder.setEngine(engineBuilder.build());    if (i % 4 == 0) {        List<Service> serviceList = Lists.newArrayList();        serviceList.add(Service.newBuilder().setDate(1374084640).setMechanic("Elon Musk").build());        carBuilder.setServiceHistory(serviceList);    }    return carBuilder.build();}
f1b79cd73081803aac4d597efe66cc1e35d6cdcd7d3d407951eb90b869e57624
run
public void run(Context context) throws IOException, InterruptedException
{    for (int i = 0; i < 10; i++) {        context.write(null, nextRecord(i));    }}
6e5c239df36debebb73210d0ce464a87c41bb637fede84d97cd92e2919fb9c19
map
protected void map(Void key, Car car, Context context) throws IOException, InterruptedException
{        if (car != null) {        context.write(null, car);    }}
78e488be58b011c4b4e2c5b7988448b8f73a6122854558d3c4c10f6618b8e90f
map
protected void map(Void key, ShortCar car, Context context) throws IOException, InterruptedException
{        if (car != null) {        context.write(null, car);    }}
2cb2b8c29fc2760c915562b8d3ac4268c4018003c9027c17b546700c2a89961d
bind
public RecordFilter bind(Iterable<ColumnReader> readers)
{    return filter.bind(readers);}
288be8129d888f0932100daa65a087beed0bf926a2f25825efc643d9ea6584db
createParquetFile
public void createParquetFile() throws Exception
{    final FileSystem fileSystem = parquetPath.getFileSystem(conf);    fileSystem.delete(parquetPath, true);    fileSystem.delete(outputPath, true);    {        final Job job = new Job(conf, "write");                TextInputFormat.addInputPath(job, inputPath);        job.setInputFormatClass(TextInputFormat.class);        job.setMapperClass(TestSpecificInputOutputFormat.MyMapper.class);        job.setNumReduceTasks(0);        job.setOutputFormatClass(AvroParquetOutputFormat.class);        AvroParquetOutputFormat.setOutputPath(job, parquetPath);        AvroParquetOutputFormat.setSchema(job, Car.SCHEMA$);        waitForJob(job);    }}
c2c75b5eb5762dda20687d84e7565d4cf3b9de60742e0694a6cffba3f16ea18a
testReadWrite
public void testReadWrite() throws Exception
{    final Job job = new Job(conf, "read");    job.setInputFormatClass(AvroParquetInputFormat.class);    AvroParquetInputFormat.setInputPaths(job, parquetPath);        AvroParquetInputFormat.setUnboundRecordFilter(job, ElectricCarFilter.class);        Schema projection = Schema.createRecord(Car.SCHEMA$.getName(), Car.SCHEMA$.getDoc(), Car.SCHEMA$.getNamespace(), false);    List<Schema.Field> fields = Lists.newArrayList();    for (Schema.Field field : Car.SCHEMA$.getFields()) {        if (!"optionalExtra".equals(field.name())) {            fields.add(new Schema.Field(field.name(), field.schema(), field.doc(), field.defaultVal(), field.order()));        }    }    projection.setFields(fields);    AvroParquetInputFormat.setRequestedProjection(job, projection);    job.setMapperClass(TestSpecificInputOutputFormat.MyMapper2.class);    job.setNumReduceTasks(0);    job.setOutputFormatClass(AvroParquetOutputFormat.class);    AvroParquetOutputFormat.setOutputPath(job, outputPath);    AvroParquetOutputFormat.setSchema(job, Car.SCHEMA$);    waitForJob(job);    final Path mapperOutput = new Path(outputPath.toString(), "part-m-00000.parquet");    try (final AvroParquetReader<Car> out = new AvroParquetReader<>(mapperOutput)) {        Car car;        Car previousCar = null;        int lineNumber = 0;        while ((car = out.read()) != null) {            if (previousCar != null) {                                assertTrue(car.getModel() == previousCar.getModel());            }                        if (car.getEngine().getType() == EngineType.PETROL) {                fail("UnboundRecordFilter failed to remove cars with PETROL engines");            }                        Car expectedCar = nextRecord(lineNumber * 2);                                    expectedCar.setOptionalExtra(null);            assertEquals("line " + lineNumber, expectedCar, car);            ++lineNumber;            previousCar = car;        }    }}
fbb6681d649e7c9eb7b00c08e09019c502f2bf753fb64a1eeb6e65e8ac877460
testReadWriteChangedCar
public void testReadWriteChangedCar() throws Exception
{    final Job job = new Job(conf, "read changed/short");    job.setInputFormatClass(AvroParquetInputFormat.class);    AvroParquetInputFormat.setInputPaths(job, parquetPath);        AvroParquetInputFormat.setUnboundRecordFilter(job, ElectricCarFilter.class);            Schema projection = Schema.createRecord(Car.SCHEMA$.getName(), Car.SCHEMA$.getDoc(), Car.SCHEMA$.getNamespace(), false);    List<Schema.Field> fields = Lists.newArrayList();    for (Schema.Field field : Car.SCHEMA$.getFields()) {                if ("engine".equals(field.name()) || "year".equals(field.name()) || "vin".equals(field.name())) {            fields.add(new Schema.Field(field.name(), field.schema(), field.doc(), field.defaultVal(), field.order()));        }    }    projection.setFields(fields);    AvroParquetInputFormat.setRequestedProjection(job, projection);    AvroParquetInputFormat.setAvroReadSchema(job, ShortCar.SCHEMA$);    job.setMapperClass(TestSpecificInputOutputFormat.MyMapperShort.class);    job.setNumReduceTasks(0);    job.setOutputFormatClass(AvroParquetOutputFormat.class);    AvroParquetOutputFormat.setOutputPath(job, outputPath);    AvroParquetOutputFormat.setSchema(job, ShortCar.SCHEMA$);    waitForJob(job);    final Path mapperOutput = new Path(outputPath.toString(), "part-m-00000.parquet");    try (final AvroParquetReader<ShortCar> out = new AvroParquetReader<>(mapperOutput)) {        ShortCar car;        int lineNumber = 0;        while ((car = out.read()) != null) {                                    Car expectedCar = nextRecord(lineNumber * 2);                        assertNull(car.getMake());            assertEquals(car.getEngine(), expectedCar.getEngine());            assertEquals(car.getYear(), expectedCar.getYear());            assertEquals(car.getVin(), expectedCar.getVin());            ++lineNumber;        }    }}
1ae73b30cdadc8449c547b5e2074b79321881a77c70d90b50bd9f3775f37e746
waitForJob
private void waitForJob(Job job) throws Exception
{    job.submit();    while (!job.isComplete()) {        LOG.debug("waiting for job {}", job.getJobName());        sleep(100);    }    LOG.info("status for job {}: {}", job.getJobName(), (job.isSuccessful() ? "SUCCESS" : "FAILURE"));    if (!job.isSuccessful()) {        throw new RuntimeException("job failed " + job.getJobName());    }}
483272a117c358206cc534bd168d0c6913089706e527353cca82168a09958303
deleteOutputFile
public void deleteOutputFile() throws IOException
{    final FileSystem fileSystem = parquetPath.getFileSystem(conf);    fileSystem.delete(parquetPath, true);    fileSystem.delete(outputPath, true);}
e159cd20e5d846e508be922f0450be0db638ed2ba32c3229ae07c0ea68938d77
data
public static Collection<Object[]> data()
{    Object[][] data = new Object[][] {     { false },     { true } };    return Arrays.asList(data);}
43b940f1f31f5b664f19b1b3e8eb91cccad09f5a49c59cca667b9005a7811c55
testCompatReadWriteSpecific
public void testCompatReadWriteSpecific() throws IOException
{    Path path = writeCarsToParquetFile(10, CompressionCodecName.UNCOMPRESSED, false);    try (ParquetReader<Car> reader = new AvroParquetReader<>(testConf, path)) {        for (int i = 0; i < 10; i++) {            assertEquals(getVwPolo().toString(), reader.read().toString());            assertEquals(getVwPassat().toString(), reader.read().toString());            assertEquals(getBmwMini().toString(), reader.read().toString());        }        assertNull(reader.read());    }}
62e0ca3de02d16634c66e5460fbd9d575b1889941f76b21f8b4422ae241c9f45
testReadWriteSpecificWithDictionary
public void testReadWriteSpecificWithDictionary() throws IOException
{    Path path = writeCarsToParquetFile(10, CompressionCodecName.UNCOMPRESSED, true);    try (ParquetReader<Car> reader = new AvroParquetReader<>(testConf, path)) {        for (int i = 0; i < 10; i++) {            assertEquals(getVwPolo().toString(), reader.read().toString());            assertEquals(getVwPassat().toString(), reader.read().toString());            assertEquals(getBmwMini().toString(), reader.read().toString());        }        assertNull(reader.read());    }}
499d04509fc6410b7b50432606c3cc50bf4a313761481c846ea8852056fa5041
testFilterMatchesMultiple
public void testFilterMatchesMultiple() throws IOException
{    Path path = writeCarsToParquetFile(10, CompressionCodecName.UNCOMPRESSED, false);    try (ParquetReader<Car> reader = new AvroParquetReader<>(testConf, path, column("make", equalTo("Volkswagen")))) {        for (int i = 0; i < 10; i++) {            assertEquals(getVwPolo().toString(), reader.read().toString());            assertEquals(getVwPassat().toString(), reader.read().toString());        }        assertNull(reader.read());    }}
400a2717de7c54b714206fc5e974c2987125df50d16f897082819aadc8a7778f
testFilterMatchesMultipleBlocks
public void testFilterMatchesMultipleBlocks() throws IOException
{    Path path = writeCarsToParquetFile(10000, CompressionCodecName.UNCOMPRESSED, false, DEFAULT_BLOCK_SIZE / 64, DEFAULT_PAGE_SIZE / 64);    try (ParquetReader<Car> reader = new AvroParquetReader<>(testConf, path, column("make", equalTo("Volkswagen")))) {        for (int i = 0; i < 10000; i++) {            assertEquals(getVwPolo().toString(), reader.read().toString());            assertEquals(getVwPassat().toString(), reader.read().toString());        }        assertNull(reader.read());    }}
959173ea952d68b6986a210a157a6b0091e09d3f757bf0b8e32a69242558e880
testFilterMatchesNoBlocks
public void testFilterMatchesNoBlocks() throws IOException
{    Path path = writeCarsToParquetFile(10000, CompressionCodecName.UNCOMPRESSED, false, DEFAULT_BLOCK_SIZE / 64, DEFAULT_PAGE_SIZE / 64);    try (ParquetReader<Car> reader = new AvroParquetReader<>(testConf, path, column("make", equalTo("Bogus")))) {        assertNull(reader.read());    }}
e807d80b2774883d74bd854a0c71dbc87862cb287ae859bf9b4d83252b5cc232
testFilterMatchesFinalBlockOnly
public void testFilterMatchesFinalBlockOnly() throws IOException
{    File tmp = File.createTempFile(getClass().getSimpleName(), ".tmp");    tmp.deleteOnExit();    tmp.delete();    Path path = new Path(tmp.getPath());    Car vwPolo = getVwPolo();    Car vwPassat = getVwPassat();    Car bmwMini = getBmwMini();    try (ParquetWriter<Car> writer = new AvroParquetWriter<Car>(path, Car.SCHEMA$, CompressionCodecName.UNCOMPRESSED, DEFAULT_BLOCK_SIZE / 128, DEFAULT_PAGE_SIZE / 128, false)) {        for (int i = 0; i < 10000; i++) {            writer.write(vwPolo);            writer.write(vwPassat);            writer.write(vwPolo);        }                writer.write(bmwMini);    }    try (ParquetReader<Car> reader = new AvroParquetReader<Car>(testConf, path, column("make", equalTo("BMW")))) {        assertEquals(getBmwMini().toString(), reader.read().toString());        assertNull(reader.read());    }}
0eaa37fdf6a10ebde29deb4a95102f2d9143092169688f4d147153770ff02d5c
testFilterWithDictionary
public void testFilterWithDictionary() throws IOException
{    Path path = writeCarsToParquetFile(1, CompressionCodecName.UNCOMPRESSED, true);    try (ParquetReader<Car> reader = new AvroParquetReader<>(testConf, path, column("make", equalTo("Volkswagen")))) {        assertEquals(getVwPolo().toString(), reader.read().toString());        assertEquals(getVwPassat().toString(), reader.read().toString());        assertNull(reader.read());    }}
ccb4d4b9153b4673bd3ec01ba69393d86813e4b3b459268fb4edc5e63be33ebd
testFilterOnSubAttribute
public void testFilterOnSubAttribute() throws IOException
{    Path path = writeCarsToParquetFile(1, CompressionCodecName.UNCOMPRESSED, false);    ParquetReader<Car> reader = new AvroParquetReader<Car>(testConf, path, column("engine.type", equalTo(EngineType.DIESEL)));    assertEquals(reader.read().toString(), getVwPassat().toString());    assertNull(reader.read());    reader = new AvroParquetReader<Car>(testConf, path, column("engine.capacity", equalTo(1.4f)));    assertEquals(getVwPolo().toString(), reader.read().toString());    assertNull(reader.read());    reader = new AvroParquetReader<Car>(testConf, path, column("engine.hasTurboCharger", equalTo(true)));    assertEquals(getBmwMini().toString(), reader.read().toString());    assertNull(reader.read());}
d759025bbe55238e89747c4cff700c683ed2c5996275f83344a656c8d5c32c30
testProjection
public void testProjection() throws IOException
{    Path path = writeCarsToParquetFile(1, CompressionCodecName.UNCOMPRESSED, false);    Configuration conf = new Configuration(testConf);    Schema schema = Car.getClassSchema();    List<Schema.Field> fields = schema.getFields();        List<Schema.Field> projectedFields = new ArrayList<Schema.Field>();    for (Schema.Field field : fields) {        String name = field.name();        if ("optionalExtra".equals(name) || "serviceHistory".equals(name)) {            continue;        }                Schema.Field fieldClone = new Schema.Field(name, field.schema(), field.doc(), field.defaultVal());        projectedFields.add(fieldClone);    }    Schema projectedSchema = Schema.createRecord(schema.getName(), schema.getDoc(), schema.getNamespace(), schema.isError());    projectedSchema.setFields(projectedFields);    AvroReadSupport.setRequestedProjection(conf, projectedSchema);    try (ParquetReader<Car> reader = new AvroParquetReader<Car>(conf, path)) {        for (Car car = reader.read(); car != null; car = reader.read()) {            assertTrue(car.getDoors() == 4 || car.getDoors() == 5);            assertNotNull(car.getEngine());            assertNotNull(car.getMake());            assertNotNull(car.getModel());            assertEquals(2010, car.getYear());            assertNotNull(car.getVin());            assertNull(car.getOptionalExtra());            assertNull(car.getServiceHistory());        }    }}
cfdb998ba2ebc94585e402478065462e2cf331915d8a14d5f78e23da328fd241
testAvroReadSchema
public void testAvroReadSchema() throws IOException
{    Path path = writeCarsToParquetFile(1, CompressionCodecName.UNCOMPRESSED, false);    Configuration conf = new Configuration(testConf);    AvroReadSupport.setAvroReadSchema(conf, NewCar.SCHEMA$);    try (ParquetReader<NewCar> reader = new AvroParquetReader<>(conf, path)) {        for (NewCar car = reader.read(); car != null; car = reader.read()) {            assertNotNull(car.getEngine());            assertNotNull(car.getBrand());            assertEquals(2010, car.getYear());            assertNotNull(car.getVin());            assertNull(car.getDescription());            assertEquals(5, car.getOpt());        }    }}
ce2c6e471d629bc6c297a0e541230c8394924008f5d2b8354bf5ad742ddc0f00
writeCarsToParquetFile
private Path writeCarsToParquetFile(int num, CompressionCodecName compression, boolean enableDictionary) throws IOException
{    return writeCarsToParquetFile(num, compression, enableDictionary, DEFAULT_BLOCK_SIZE, DEFAULT_PAGE_SIZE);}
f9a276f77dbc1383658200090e2c0c69ce4810a5abeee420b751d31513049572
writeCarsToParquetFile
private Path writeCarsToParquetFile(int num, CompressionCodecName compression, boolean enableDictionary, int blockSize, int pageSize) throws IOException
{    File tmp = File.createTempFile(getClass().getSimpleName(), ".tmp");    tmp.deleteOnExit();    tmp.delete();    Path path = new Path(tmp.getPath());    Car vwPolo = getVwPolo();    Car vwPassat = getVwPassat();    Car bmwMini = getBmwMini();    try (ParquetWriter<Car> writer = new AvroParquetWriter<>(path, Car.SCHEMA$, compression, blockSize, pageSize, enableDictionary)) {        for (int i = 0; i < num; i++) {            writer.write(vwPolo);            writer.write(vwPassat);            writer.write(bmwMini);        }    }    return path;}
60abb6c16b361f8b4bb215034ef70dbeca5f1cb391a2ba959a9419d405e4e1ca
getVwPolo
public static Car getVwPolo()
{    String vin = "WVWDB4505LK000001";    return Car.newBuilder().setYear(2010).setRegistration("A123 GTR").setMake("Volkswagen").setModel("Polo").setVin(new Vin(vin.getBytes())).setDoors(4).setEngine(Engine.newBuilder().setType(EngineType.PETROL).setCapacity(1.4f).setHasTurboCharger(false).build()).setOptionalExtra(Stereo.newBuilder().setMake("Blaupunkt").setSpeakers(4).build()).setServiceHistory(ImmutableList.of(Service.newBuilder().setDate(1325376000l).setMechanic("Jim").build(), Service.newBuilder().setDate(1356998400l).setMechanic("Mike").build())).build();}
1b66702a23de70a120fdc52a249d5042f58fad876920344ac22bf21bce801bfd
getVwPassat
public static Car getVwPassat()
{    String vin = "WVWDB4505LK000002";    return Car.newBuilder().setYear(2010).setRegistration("A123 GXR").setMake("Volkswagen").setModel("Passat").setVin(new Vin(vin.getBytes())).setDoors(5).setEngine(Engine.newBuilder().setType(EngineType.DIESEL).setCapacity(2.0f).setHasTurboCharger(false).build()).setOptionalExtra(LeatherTrim.newBuilder().setColour("Black").build()).setServiceHistory(ImmutableList.of(Service.newBuilder().setDate(1325376000l).setMechanic("Jim").build())).build();}
7373a0408b5792d3341f4c731b401cc4b67eef3deb0d59258ad93fe394cf8a43
getBmwMini
public static Car getBmwMini()
{    String vin = "WBABA91060AL00003";    return Car.newBuilder().setYear(2010).setRegistration("A124 GSR").setMake("BMW").setModel("Mini").setVin(new Vin(vin.getBytes())).setDoors(4).setEngine(Engine.newBuilder().setType(EngineType.PETROL).setCapacity(1.6f).setHasTurboCharger(true).build()).setOptionalExtra(null).setServiceHistory(ImmutableList.of(Service.newBuilder().setDate(1356998400l).setMechanic("Mike").build())).build();}
d8da30ed322c9f3f493604673ed203f6a085637af48c231fe6beac3dbb6ea625
readSchemaFile
public static void readSchemaFile() throws IOException
{    TestStringBehavior.SCHEMA = new Schema.Parser().parse(Resources.getResource("stringBehavior.avsc").openStream());}
d813bdd655fedff92fc180e5e7e5b377d7a1c4cd6f4906aeaa3709afec2837c4
writeDataFiles
public void writeDataFiles() throws IOException
{        GenericRecord record = new GenericRecordBuilder(SCHEMA).set("default_class", "default").set("string_class", "string").set("stringable_class", BIG_DECIMAL.toString()).set("default_map", ImmutableMap.of("default_key", 34)).set("string_map", ImmutableMap.of("string_key", 35)).set("stringable_map", ImmutableMap.of(BIG_DECIMAL.toString(), 36)).build();    File file = temp.newFile("parquet");    file.delete();    file.deleteOnExit();    parquetFile = new Path(file.getPath());    try (ParquetWriter<GenericRecord> parquet = AvroParquetWriter.<GenericRecord>builder(parquetFile).withDataModel(GenericData.get()).withSchema(SCHEMA).build()) {        parquet.write(record);    }    avroFile = temp.newFile("avro");    avroFile.delete();    avroFile.deleteOnExit();    try (DataFileWriter<GenericRecord> avro = new DataFileWriter<GenericRecord>(new GenericDatumWriter<>(SCHEMA)).create(SCHEMA, avroFile)) {        avro.append(record);    }}
1971ff2750a766cbb2c25bbd8bb8dfc914f5348247934488e0fb1d630d2529ee
testGeneric
public void testGeneric() throws IOException
{    GenericRecord avroRecord;    try (DataFileReader<GenericRecord> avro = new DataFileReader<>(avroFile, new GenericDatumReader<>(SCHEMA))) {        avroRecord = avro.next();    }    GenericRecord parquetRecord;    Configuration conf = new Configuration();    conf.setBoolean(AvroReadSupport.AVRO_COMPATIBILITY, false);    AvroReadSupport.setAvroDataSupplier(conf, GenericDataSupplier.class);    AvroReadSupport.setAvroReadSchema(conf, SCHEMA);    try (ParquetReader<GenericRecord> parquet = AvroParquetReader.<GenericRecord>builder(parquetFile).withConf(conf).build()) {        parquetRecord = parquet.read();    }    Assert.assertEquals("Avro default string class should be Utf8", Utf8.class, avroRecord.get("default_class").getClass());    Assert.assertEquals("Parquet default string class should be Utf8", Utf8.class, parquetRecord.get("default_class").getClass());    Assert.assertEquals("Avro avro.java.string=String class should be String", String.class, avroRecord.get("string_class").getClass());    Assert.assertEquals("Parquet avro.java.string=String class should be String", String.class, parquetRecord.get("string_class").getClass());    Assert.assertEquals("Avro stringable class should be Utf8", Utf8.class, avroRecord.get("stringable_class").getClass());    Assert.assertEquals("Parquet stringable class should be Utf8", Utf8.class, parquetRecord.get("stringable_class").getClass());    Assert.assertEquals("Avro map default string class should be Utf8", Utf8.class, keyClass(avroRecord.get("default_map")));    Assert.assertEquals("Parquet map default string class should be Utf8", Utf8.class, keyClass(parquetRecord.get("default_map")));    Assert.assertEquals("Avro map avro.java.string=String class should be String", String.class, keyClass(avroRecord.get("string_map")));    Assert.assertEquals("Parquet map avro.java.string=String class should be String", String.class, keyClass(parquetRecord.get("string_map")));    Assert.assertEquals("Avro map stringable class should be Utf8", Utf8.class, keyClass(avroRecord.get("stringable_map")));    Assert.assertEquals("Parquet map stringable class should be Utf8", Utf8.class, keyClass(parquetRecord.get("stringable_map")));}
06958593035dc2e6ba822afe7a38dfcc9eb9e24e8415d4902153706f68a18af3
testSpecific
public void testSpecific() throws IOException
{    org.apache.parquet.avro.StringBehaviorTest avroRecord;    try (DataFileReader<org.apache.parquet.avro.StringBehaviorTest> avro = new DataFileReader<>(avroFile, new SpecificDatumReader<>(org.apache.parquet.avro.StringBehaviorTest.getClassSchema()))) {        avroRecord = avro.next();    }    org.apache.parquet.avro.StringBehaviorTest parquetRecord;    Configuration conf = new Configuration();    conf.setBoolean(AvroReadSupport.AVRO_COMPATIBILITY, false);    AvroReadSupport.setAvroDataSupplier(conf, SpecificDataSupplier.class);    AvroReadSupport.setAvroReadSchema(conf, org.apache.parquet.avro.StringBehaviorTest.getClassSchema());    try (ParquetReader<org.apache.parquet.avro.StringBehaviorTest> parquet = AvroParquetReader.<org.apache.parquet.avro.StringBehaviorTest>builder(parquetFile).withConf(conf).build()) {        parquetRecord = parquet.read();    }    Assert.assertEquals("Avro default string class should be String", Utf8.class, avroRecord.default_class.getClass());    Assert.assertEquals("Parquet default string class should be String", Utf8.class, parquetRecord.default_class.getClass());    Assert.assertEquals("Avro avro.java.string=String class should be String", String.class, avroRecord.string_class.getClass());    Assert.assertEquals("Parquet avro.java.string=String class should be String", String.class, parquetRecord.string_class.getClass());    Assert.assertEquals("Avro stringable class should be BigDecimal", BigDecimal.class, avroRecord.stringable_class.getClass());    Assert.assertEquals("Parquet stringable class should be BigDecimal", BigDecimal.class, parquetRecord.stringable_class.getClass());    Assert.assertEquals("Should have the correct BigDecimal value", BIG_DECIMAL, parquetRecord.stringable_class);    Assert.assertEquals("Avro map default string class should be String", Utf8.class, keyClass(avroRecord.default_map));    Assert.assertEquals("Parquet map default string class should be String", Utf8.class, keyClass(parquetRecord.default_map));    Assert.assertEquals("Avro map avro.java.string=String class should be String", String.class, keyClass(avroRecord.string_map));    Assert.assertEquals("Parquet map avro.java.string=String class should be String", String.class, keyClass(parquetRecord.string_map));    Assert.assertEquals("Avro map stringable class should be BigDecimal", BigDecimal.class, keyClass(avroRecord.stringable_map));    Assert.assertEquals("Parquet map stringable class should be BigDecimal", BigDecimal.class, keyClass(parquetRecord.stringable_map));}
d86ce29b8fd0060958bdb38e2c4f5841b88101c61e7aab8e1f0eef9475bd487a
testReflect
public void testReflect() throws IOException
{    Schema reflectSchema = ReflectData.get().getSchema(ReflectRecord.class);    ReflectRecord avroRecord;    try (DataFileReader<ReflectRecord> avro = new DataFileReader<>(avroFile, new ReflectDatumReader<>(reflectSchema))) {        avroRecord = avro.next();    }    ReflectRecord parquetRecord;    Configuration conf = new Configuration();    conf.setBoolean(AvroReadSupport.AVRO_COMPATIBILITY, false);    AvroReadSupport.setAvroDataSupplier(conf, ReflectDataSupplier.class);    AvroReadSupport.setAvroReadSchema(conf, reflectSchema);    try (ParquetReader<ReflectRecord> parquet = AvroParquetReader.<ReflectRecord>builder(parquetFile).withConf(conf).build()) {        parquetRecord = parquet.read();    }    Assert.assertEquals("Avro default string class should be String", String.class, avroRecord.default_class.getClass());    Assert.assertEquals("Parquet default string class should be String", String.class, parquetRecord.default_class.getClass());    Assert.assertEquals("Avro avro.java.string=String class should be String", String.class, avroRecord.string_class.getClass());    Assert.assertEquals("Parquet avro.java.string=String class should be String", String.class, parquetRecord.string_class.getClass());    Assert.assertEquals("Avro stringable class should be BigDecimal", BigDecimal.class, avroRecord.stringable_class.getClass());    Assert.assertEquals("Parquet stringable class should be BigDecimal", BigDecimal.class, parquetRecord.stringable_class.getClass());    Assert.assertEquals("Should have the correct BigDecimal value", BIG_DECIMAL, parquetRecord.stringable_class);    Assert.assertEquals("Avro map default string class should be String", String.class, keyClass(avroRecord.default_map));    Assert.assertEquals("Parquet map default string class should be String", String.class, keyClass(parquetRecord.default_map));    Assert.assertEquals("Avro map avro.java.string=String class should be String", String.class, keyClass(avroRecord.string_map));    Assert.assertEquals("Parquet map avro.java.string=String class should be String", String.class, keyClass(parquetRecord.string_map));    Assert.assertEquals("Avro map stringable class should be BigDecimal", BigDecimal.class, keyClass(avroRecord.stringable_map));    Assert.assertEquals("Parquet map stringable class should be BigDecimal", BigDecimal.class, keyClass(parquetRecord.stringable_map));}
fe7088529f86bf056c791d50f30c8f6b045bcb75a33d902b3e0409a4159cf9a5
testReflectJavaClass
public void testReflectJavaClass() throws IOException
{    Schema reflectSchema = ReflectData.get().getSchema(ReflectRecordJavaClass.class);    System.err.println("Schema: " + reflectSchema.toString(true));    ReflectRecordJavaClass avroRecord;    try (DataFileReader<ReflectRecordJavaClass> avro = new DataFileReader<>(avroFile, new ReflectDatumReader<>(reflectSchema))) {        avroRecord = avro.next();    }    ReflectRecordJavaClass parquetRecord;    Configuration conf = new Configuration();    conf.setBoolean(AvroReadSupport.AVRO_COMPATIBILITY, false);    AvroReadSupport.setAvroDataSupplier(conf, ReflectDataSupplier.class);    AvroReadSupport.setAvroReadSchema(conf, reflectSchema);    AvroReadSupport.setRequestedProjection(conf, reflectSchema);    try (ParquetReader<ReflectRecordJavaClass> parquet = AvroParquetReader.<ReflectRecordJavaClass>builder(parquetFile).withConf(conf).build()) {        parquetRecord = parquet.read();    }        Assert.assertEquals("Avro default string class should be String", String.class, avroRecord.default_class.getClass());    Assert.assertEquals("Parquet default string class should be String", String.class, parquetRecord.default_class.getClass());    Assert.assertEquals("Avro stringable class should be BigDecimal", BigDecimal.class, avroRecord.stringable_class.getClass());    Assert.assertEquals("Parquet stringable class should be BigDecimal", BigDecimal.class, parquetRecord.stringable_class.getClass());    Assert.assertEquals("Should have the correct BigDecimal value", BIG_DECIMAL, parquetRecord.stringable_class);}
537d8d5b1c7806205a62defc6080fa3c14e5b66728e3d135aece9da5645b51a4
keyClass
public static Class<?> keyClass(Object obj)
{    Assert.assertTrue("Should be a map", obj instanceof Map);    Map<?, ?> map = (Map<?, ?>) obj;    return Iterables.getFirst(map.keySet(), null).getClass();}
2991f0e788990b00bf04f023bd75d64d9478c6fff5a39775dd1d40dc0aed4675
deleteIfExists
public static void deleteIfExists(Configuration conf, Path path)
{    try {        FileSystem fs = path.getFileSystem(conf);        if (fs.exists(path)) {            if (!fs.delete(path, true)) {                System.err.println("Couldn't delete " + path);            }        }    } catch (IOException e) {        System.err.println("Couldn't delete " + path);        e.printStackTrace();    }}
c02c3ce2cd4c9684ecdce77648b6fd8374ea3de6acbd6bdf68be509fc86b4ae7
exists
public static boolean exists(Configuration conf, Path path) throws IOException
{    FileSystem fs = path.getFileSystem(conf);    return fs.exists(path);}
35eaea58d6cd65860ff4202e2800702d2edcaeea664e9afcd26dd2f1c5ce29ae
generateAll
public void generateAll()
{    try {        generateData(file_1M, configuration, PARQUET_2_0, BLOCK_SIZE_DEFAULT, PAGE_SIZE_DEFAULT, FIXED_LEN_BYTEARRAY_SIZE, UNCOMPRESSED, ONE_MILLION);                generateData(file_1M_BS256M_PS4M, configuration, PARQUET_2_0, BLOCK_SIZE_256M, PAGE_SIZE_4M, FIXED_LEN_BYTEARRAY_SIZE, UNCOMPRESSED, ONE_MILLION);        generateData(file_1M_BS256M_PS8M, configuration, PARQUET_2_0, BLOCK_SIZE_256M, PAGE_SIZE_8M, FIXED_LEN_BYTEARRAY_SIZE, UNCOMPRESSED, ONE_MILLION);        generateData(file_1M_BS512M_PS4M, configuration, PARQUET_2_0, BLOCK_SIZE_512M, PAGE_SIZE_4M, FIXED_LEN_BYTEARRAY_SIZE, UNCOMPRESSED, ONE_MILLION);        generateData(file_1M_BS512M_PS8M, configuration, PARQUET_2_0, BLOCK_SIZE_512M, PAGE_SIZE_8M, FIXED_LEN_BYTEARRAY_SIZE, UNCOMPRESSED, ONE_MILLION);                        generateData(file_1M_SNAPPY, configuration, PARQUET_2_0, BLOCK_SIZE_DEFAULT, PAGE_SIZE_DEFAULT, FIXED_LEN_BYTEARRAY_SIZE, SNAPPY, ONE_MILLION);        generateData(file_1M_GZIP, configuration, PARQUET_2_0, BLOCK_SIZE_DEFAULT, PAGE_SIZE_DEFAULT, FIXED_LEN_BYTEARRAY_SIZE, GZIP, ONE_MILLION);    } catch (IOException e) {        throw new RuntimeException(e);    }}
a2adbc6d93d986f6934bc5cb0c4e2b9bc06e2fcfd22a3a1e9c5800abf05d8199
generateData
public void generateData(Path outFile, Configuration configuration, ParquetProperties.WriterVersion version, int blockSize, int pageSize, int fixedLenByteArraySize, CompressionCodecName codec, int nRows) throws IOException
{    if (exists(configuration, outFile)) {        System.out.println("File already exists " + outFile);        return;    }    System.out.println("Generating data @ " + outFile);    MessageType schema = parseMessageType("message test { " + "required binary binary_field; " + "required int32 int32_field; " + "required int64 int64_field; " + "required boolean boolean_field; " + "required float float_field; " + "required double double_field; " + "required fixed_len_byte_array(" + fixedLenByteArraySize + ") flba_field; " + "required int96 int96_field; " + "} ");    GroupWriteSupport.setSchema(schema, configuration);    SimpleGroupFactory f = new SimpleGroupFactory(schema);    ParquetWriter<Group> writer = new ParquetWriter<Group>(outFile, new GroupWriteSupport(), codec, blockSize, pageSize, DICT_PAGE_SIZE, true, false, version, configuration);        char[] chars = new char[fixedLenByteArraySize];    Arrays.fill(chars, '*');    for (int i = 0; i < nRows; i++) {        writer.write(f.newGroup().append("binary_field", randomUUID().toString()).append("int32_field", i).append("int64_field", 64l).append("boolean_field", true).append("float_field", 1.0f).append("double_field", 2.0d).append("flba_field", new String(chars)).append("int96_field", Binary.fromConstantByteArray(new byte[12])));    }    writer.close();}
a317f472727975f13a20ef21472e1d5e0a0fd93702ee696b9c962178a725931f
cleanup
public void cleanup()
{    deleteIfExists(configuration, targetDir);}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    DataGenerator generator = new DataGenerator();    if (args.length < 1) {        System.err.println("Please specify a command (generate|cleanup).");        System.exit(1);    }    String command = args[0];    if (command.equalsIgnoreCase("generate")) {        generator.generateAll();    } else if (command.equalsIgnoreCase("cleanup")) {        generator.cleanup();    } else {        throw new IllegalArgumentException("invalid command " + command);    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    try {        FileSystem fs = file.getFileSystem(new Configuration());        long bytes = fs.getFileStatus(file).getLen();        int exp = (int) (Math.log(bytes) / Math.log(1024));        if (exp == 0) {            return Long.toString(bytes);        }        String suffix = SUFFIXES[exp - 1];        return String.format("%d [%.2f%s]", bytes, bytes / Math.pow(1024, exp), suffix);    } catch (IOException e) {        return "N/A";    }}
efb82e60acd366c08c816c747e244656dfd42e8a21d9a0d6d2b2d1806b020447
nextString
 String nextString()
{    char[] str = new char[MIN_LENGTH + random.nextInt(MAX_LENGTH - MIN_LENGTH)];    for (int i = 0, n = str.length; i < n; ++i) {        str[i] = ALPHABET.charAt(random.nextInt(ALPHABET.length()));    }    return new String(str);}
570f89c6097b63a4617f89f6d5d0475e537ca3c19baae972c8da33256efa65a4
configureBuilder
public Builder<T> configureBuilder(Builder<T> builder)
{    return builder;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "DEFAULT";}
a519d9243b10063ef8c9c3452d4e78f4a6d7b2c7e394e89085ae077839117c94
configureBuilder
public org.apache.parquet.hadoop.ParquetWriter.Builder<T, ?> configureBuilder(org.apache.parquet.hadoop.ParquetWriter.Builder<T, ?> builder)
{    return builder;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "DEFAULT";}
570f89c6097b63a4617f89f6d5d0475e537ca3c19baae972c8da33256efa65a4
configureBuilder
public Builder<T> configureBuilder(Builder<T> builder)
{    return builder.useColumnIndexFilter(false);}
570f89c6097b63a4617f89f6d5d0475e537ca3c19baae972c8da33256efa65a4
configureBuilder
public Builder<T> configureBuilder(Builder<T> builder)
{    return builder.useColumnIndexFilter(true);}
b150699598169203f66f245853225ead9f9fe7194066b7c0f0f7dc0c05b33d0d
arrangeToBuckets
public static void arrangeToBuckets(long[] data, int bucketCnt)
{    long bucketSize = (long) (Long.MAX_VALUE / (bucketCnt / 2.0));    long[] bucketBorders = new long[bucketCnt - 1];    for (int i = 0, n = bucketBorders.length; i < n; ++i) {        bucketBorders[i] = Long.MIN_VALUE + (i + 1) * bucketSize;    }    LongList[] buckets = new LongList[bucketCnt];    for (int i = 0; i < bucketCnt; ++i) {        buckets[i] = new LongArrayList(data.length / bucketCnt);    }    for (int i = 0, n = data.length; i < n; ++i) {        long value = data[i];        int bucket = Arrays.binarySearch(bucketBorders, value);        if (bucket < 0) {            bucket = -(bucket + 1);        }        buckets[bucket].add(value);    }    int offset = 0;    int mid = bucketCnt / 2;    for (int i = 0; i < bucketCnt; ++i) {        int bucketIndex;        if (i % 2 == 0) {            bucketIndex = mid + i / 2;        } else {            bucketIndex = mid - i / 2 - 1;        }        LongList bucket = buckets[bucketIndex];        bucket.getElements(0, data, offset, bucket.size());        offset += bucket.size();    }}
a7d3965463d27150d9121dc9e977d0d9d5c5bf48b40674a42a9729eb247942d9
arrangeData
 void arrangeData(long[] data)
{    Arrays.parallelSort(data);}
a7d3965463d27150d9121dc9e977d0d9d5c5bf48b40674a42a9729eb247942d9
arrangeData
 void arrangeData(long[] data)
{    arrangeToBuckets(data, 9);}
a7d3965463d27150d9121dc9e977d0d9d5c5bf48b40674a42a9729eb247942d9
arrangeData
 void arrangeData(long[] data)
{    arrangeToBuckets(data, 5);}
a7d3965463d27150d9121dc9e977d0d9d5c5bf48b40674a42a9729eb247942d9
arrangeData
 void arrangeData(long[] data)
{    arrangeToBuckets(data, 3);}
a7d3965463d27150d9121dc9e977d0d9d5c5bf48b40674a42a9729eb247942d9
arrangeData
 void arrangeData(long[] data)
{}
a1786f9bcef2801bc13d90d43dcc16b11fa8dc0cdfc2792937623a7c4e471e0f
configureBuilder
public ParquetWriter.Builder<T, ?> configureBuilder(ParquetWriter.Builder<T, ?> builder)
{    return builder.withPageSize(    Integer.MAX_VALUE).withPageRowCountLimit(1_000);}
a1786f9bcef2801bc13d90d43dcc16b11fa8dc0cdfc2792937623a7c4e471e0f
configureBuilder
public ParquetWriter.Builder<T, ?> configureBuilder(ParquetWriter.Builder<T, ?> builder)
{    return builder.withPageSize(    Integer.MAX_VALUE).withPageRowCountLimit(10_000);}
a1786f9bcef2801bc13d90d43dcc16b11fa8dc0cdfc2792937623a7c4e471e0f
configureBuilder
public ParquetWriter.Builder<T, ?> configureBuilder(ParquetWriter.Builder<T, ?> builder)
{    return builder.withPageSize(    Integer.MAX_VALUE).withPageRowCountLimit(50_000);}
a1786f9bcef2801bc13d90d43dcc16b11fa8dc0cdfc2792937623a7c4e471e0f
configureBuilder
public ParquetWriter.Builder<T, ?> configureBuilder(ParquetWriter.Builder<T, ?> builder)
{    return builder.withPageSize(    Integer.MAX_VALUE).withPageRowCountLimit(100_000);}
2beeb75f42663075398d808f9eb0791cb8d072821a902c99c9b56acdb5e06d09
writeFile
public void writeFile() throws IOException
{    WriteConfigurator writeConfigurator = getWriteConfigurator();    file = new Path(Files.createTempFile("benchmark-filtering_" + characteristic + '_' + writeConfigurator + '_', ".parquet").toAbsolutePath().toString());    long[] data = generateData();    characteristic.arrangeData(data);    try (ParquetWriter<Group> writer = writeConfigurator.configureBuilder(ExampleParquetWriter.builder(file).config(GroupWriteSupport.PARQUET_EXAMPLE_SCHEMA, SCHEMA.toString()).withRowGroupSize(    Integer.MAX_VALUE).withWriteMode(OVERWRITE)).build()) {        for (long value : data) {            Group group = new SimpleGroup(SCHEMA);            group.add(0, value);            group.add(1, Binary.fromString(dummyGenerator.nextString()));            group.add(2, Binary.fromString(dummyGenerator.nextString()));            group.add(3, Binary.fromString(dummyGenerator.nextString()));            group.add(4, Binary.fromString(dummyGenerator.nextString()));            group.add(5, Binary.fromString(dummyGenerator.nextString()));            writer.write(group);        }    }}
4387232f05838420ece0a6afe5b9f6553cb8065269b2eda8df95d7311e0ee589
getWriteConfigurator
 WriteConfigurator getWriteConfigurator()
{    return WriteConfigurator.DEFAULT;}
352dfb2d2fcaf9c67c1762bc2fcae7b37e359bbcde505dc722828c451cede5a7
getReadConfigurator
 ReadConfigurator getReadConfigurator()
{    return ReadConfigurator.DEFAULT;}
1cc44d78622a4566cddb308c5acdac7c5c9d10d2b1faed19a216df3ef351aec0
generateData
private long[] generateData()
{    Random random = new Random(43);    long[] data = new long[RECORD_COUNT];    for (int i = 0, n = data.length; i < n; ++i) {        data[i] = random.nextLong();    }    return data;}
2489a6542f98b62301ea336cc29785ec493ac5e7f47501c4bc05860aa1f57357
resetRandom
public void resetRandom()
{    random = new Random(42);    dummyGenerator = new StringGenerator();}
9918159dd05bfd736d4d4366b3a350d45d0f9c1d7903121e2944379412ed9a4f
gc
public void gc()
{    System.gc();}
78b0c582e05e5caa0f302ba6a572a82c98cec40f214230226436c67b5c32f8d2
deleteFile
public void deleteFile() throws IOException
{    LOGGER.info("Deleting file {} (size: {})", file, new FileSize(file));    file.getFileSystem(new Configuration()).delete(file, false);}
7ccdf1ed82ad1142669daa6d6a160c3cdfbdf7eb85c8c455601bd2f7362ae714
createReaderBuilder
public ParquetReader.Builder<Group> createReaderBuilder() throws IOException
{    ReadConfigurator readConfigurator = getReadConfigurator();    return readConfigurator.configureBuilder(new ParquetReader.Builder<Group>(HadoopInputFile.fromPath(file, new Configuration())) {        @Override        protected ReadSupport<Group> getReadSupport() {            return new GroupReadSupport();        }    }.set(GroupWriteSupport.PARQUET_EXAMPLE_SCHEMA, SCHEMA.toString()));}
c92d0c5cce2ae623ff3ac8ded6150aa5e3c62cf6c608e1ac1806f2fc82ebc43b
getReadSupport
protected ReadSupport<Group> getReadSupport()
{    return new GroupReadSupport();}
84a65d1ef4f4975f3504220d6b7b0e0a57dabc36b0e99ded5305364698c4e6d5
getRandom
public Random getRandom()
{    return random;}
352dfb2d2fcaf9c67c1762bc2fcae7b37e359bbcde505dc722828c451cede5a7
getReadConfigurator
 ReadConfigurator getReadConfigurator()
{    return columnIndexUsage;}
4387232f05838420ece0a6afe5b9f6553cb8065269b2eda8df95d7311e0ee589
getWriteConfigurator
 WriteConfigurator getWriteConfigurator()
{    return pageRowLimit;}
352dfb2d2fcaf9c67c1762bc2fcae7b37e359bbcde505dc722828c451cede5a7
getReadConfigurator
 ReadConfigurator getReadConfigurator()
{    return ColumnIndexUsage.WITH_COLUMN_INDEX;}
f3e34fa2031ecc581965afe0a97ddc45e6a106cc5ff3153eebb6b1fc98e567a0
benchmarkWithOrWithoutColumnIndex
public void benchmarkWithOrWithoutColumnIndex(Blackhole blackhole, WithOrWithoutColumnIndexContext context) throws Exception
{    benchmark(blackhole, context);}
bb3894d67f88098f26839c4e4951f1fb6481efe70b500d77b86ae7096d04ee70
benchmarkPageSize
public void benchmarkPageSize(Blackhole blackhole, PageSizeContext context) throws Exception
{    benchmark(blackhole, context);}
f1fc9bd05b5030d80ca266b2ece56277a350b675069b3864dfded8d7a40d0622
benchmark
private void benchmark(Blackhole blackhole, BaseContext context) throws Exception
{    FilterPredicate filter = FilterApi.eq(BaseContext.COLUMN, context.getRandom().nextLong());    try (ParquetReader<Group> reader = context.createReaderBuilder().withFilter(FilterCompat.get(filter)).build()) {        blackhole.consume(reader.read());    }}
25e7ad709bee723c87fc07351f3d9f072baaff241104b7d2663fe4d7edbe7ff5
supportsBlockSize
public boolean supportsBlockSize()
{    return false;}
fdebbca15f0d2b8bcb26e93cdc926ee87ad94cd1c7f686e4202d0942b709884f
defaultBlockSize
public long defaultBlockSize()
{    return -1L;}
812cb001b076b2ffb90e1587614cc21cfe3e76b4f9de1ea3cd5b1e76fbf0cf94
createOrOverwrite
public PositionOutputStream createOrOverwrite(long blockSizeHint)
{    return create(blockSizeHint);}
de4215b9f56c865e0f5aaef2529fa40e9548af57d6f44d8a78d2ee6579a39981
create
public PositionOutputStream create(long blockSizeHint)
{    return new PositionOutputStream() {        private long pos;        @Override        public long getPos() throws IOException {            return pos;        }        @Override        public void write(int b) throws IOException {            ++pos;        }    };}
5800a0f531c192e683ef74c0c5de6015daf6261d1f8e5c0ce6d8e043b01926c7
getPos
public long getPos() throws IOException
{    return pos;}
28b71ced43af8c83f8eb799b762b9363eea3393c08bf12a29b90de2304757b0c
write
public void write(int b) throws IOException
{    ++pos;}
27fc2e591c21ae229b011e4487cdaaab3856604871731ac8e099fa05280346a6
nextValue
public Group nextValue()
{    if (random.nextDouble() > NULL_RATIO) {        Group group = FACTORY.newGroup();        group.addGroup("int_list").addGroup("list").append("element", random.nextInt());        return group;    } else {        return NULL;    }}
3512671109a0a1149e663576a60e7422ed4b1265a717e82882c8953417506ed7
benchmarkWriting
public void benchmarkWriting() throws IOException
{    ValueGenerator generator = new ValueGenerator();    try (ParquetWriter<Group> writer = ExampleParquetWriter.builder(BLACK_HOLE).withWriteMode(Mode.OVERWRITE).withType(SCHEMA).build()) {        for (int i = 0; i < RECORD_COUNT; ++i) {            writer.write(generator.nextValue());        }    }}
fadf8e4c5f873fac9add47a4a772b88d1ced2c41821ec9db27cb0caede403d89
generateData
public void generateData(Path outFile, int nRows, boolean writeChecksums, CompressionCodecName compression) throws IOException
{    if (exists(configuration, outFile)) {        System.out.println("File already exists " + outFile);        return;    }    ParquetWriter<Group> writer = ExampleParquetWriter.builder(outFile).withConf(configuration).withWriteMode(ParquetFileWriter.Mode.OVERWRITE).withCompressionCodec(compression).withDictionaryEncoding(true).withType(SCHEMA).withPageWriteChecksumEnabled(writeChecksums).build();    GroupFactory groupFactory = new SimpleGroupFactory(SCHEMA);    Random rand = new Random(42);    for (int i = 0; i < nRows; i++) {        Group group = groupFactory.newGroup();        group.append("long_field", (long) i).append("binary_field", randomUUID().toString()).addGroup("group").append("int_field", rand.nextInt() % 100).append("int_field", rand.nextInt() % 100).append("int_field", rand.nextInt() % 100).append("int_field", rand.nextInt() % 100);        writer.write(group);    }    writer.close();}
35eaea58d6cd65860ff4202e2800702d2edcaeea664e9afcd26dd2f1c5ce29ae
generateAll
public void generateAll()
{    try {                        generateData(file_100K_CHECKSUMS_UNCOMPRESSED, 100 * ONE_K, true, UNCOMPRESSED);        generateData(file_100K_CHECKSUMS_GZIP, 100 * ONE_K, true, GZIP);        generateData(file_100K_CHECKSUMS_SNAPPY, 100 * ONE_K, true, SNAPPY);        generateData(file_1M_CHECKSUMS_UNCOMPRESSED, ONE_MILLION, true, UNCOMPRESSED);        generateData(file_1M_CHECKSUMS_GZIP, ONE_MILLION, true, GZIP);        generateData(file_1M_CHECKSUMS_SNAPPY, ONE_MILLION, true, SNAPPY);        generateData(file_10M_CHECKSUMS_UNCOMPRESSED, 10 * ONE_MILLION, true, UNCOMPRESSED);        generateData(file_10M_CHECKSUMS_GZIP, 10 * ONE_MILLION, true, GZIP);        generateData(file_10M_CHECKSUMS_SNAPPY, 10 * ONE_MILLION, true, SNAPPY);    } catch (IOException e) {        throw new RuntimeException(e);    }}
5ff0b8f7d2b080bcc6214fa5f91be74727145ea81cacb63a99c8d0f3106c089f
setup
public void setup()
{    pageChecksumDataGenerator.generateAll();}
f75a5d52e467eb41021b69edd5be6feb651178e6dc9acb1dc7c26a56c9efc6b7
readFile
private void readFile(Path file, int nRows, boolean verifyChecksums, Blackhole blackhole) throws IOException
{    try (ParquetReader<Group> reader = ParquetReader.builder(new GroupReadSupport(), file).withConf(configuration).usePageChecksumVerification(verifyChecksums).build()) {        for (int i = 0; i < nRows; i++) {            Group group = reader.read();            blackhole.consume(group.getLong("long_field", 0));            blackhole.consume(group.getBinary("binary_field", 0));            Group subgroup = group.getGroup("group", 0);            blackhole.consume(subgroup.getInteger("int_field", 0));            blackhole.consume(subgroup.getInteger("int_field", 1));            blackhole.consume(subgroup.getInteger("int_field", 2));            blackhole.consume(subgroup.getInteger("int_field", 3));        }    }}
230d1c1b9d49c1e88919c99ee75527d9d82da3910eb01d223fb9f27d6ceb0676
read100KRowsUncompressedWithoutVerification
public void read100KRowsUncompressedWithoutVerification(Blackhole blackhole) throws IOException
{    readFile(file_100K_CHECKSUMS_UNCOMPRESSED, 100 * ONE_K, false, blackhole);}
434ff05955b9fe347099a49ff3853744c7b30650bfec643c18170895bd8b08a1
read100KRowsUncompressedWithVerification
public void read100KRowsUncompressedWithVerification(Blackhole blackhole) throws IOException
{    readFile(file_100K_CHECKSUMS_UNCOMPRESSED, 100 * ONE_K, true, blackhole);}
00939b519011df7e098b1edb327696da222f1b05fdb83d52c9bf37638825ba3f
read100KRowsGzipWithoutVerification
public void read100KRowsGzipWithoutVerification(Blackhole blackhole) throws IOException
{    readFile(file_100K_CHECKSUMS_GZIP, 100 * ONE_K, false, blackhole);}
c2dfa6048ed5f0476e9f72d69fb44819a4694536adfb5925f01aaac5a0388838
read100KRowsGzipWithVerification
public void read100KRowsGzipWithVerification(Blackhole blackhole) throws IOException
{    readFile(file_100K_CHECKSUMS_GZIP, 100 * ONE_K, true, blackhole);}
a6b32180e1d719b6dc99cf615d0bf962aee46fb9d345b15dfa9fdfdc0edcc553
read100KRowsSnappyWithoutVerification
public void read100KRowsSnappyWithoutVerification(Blackhole blackhole) throws IOException
{    readFile(file_100K_CHECKSUMS_SNAPPY, 100 * ONE_K, false, blackhole);}
1cd66f9accacba25dc4fdb180436231ef13e11ba583ae1d2a4e43f7b0286ec82
read100KRowsSnappyWithVerification
public void read100KRowsSnappyWithVerification(Blackhole blackhole) throws IOException
{    readFile(file_100K_CHECKSUMS_SNAPPY, 100 * ONE_K, true, blackhole);}
50a50ec5b413f7816c9a480c47d084aa50fa291252555d85e7529c386e57683e
read1MRowsUncompressedWithoutVerification
public void read1MRowsUncompressedWithoutVerification(Blackhole blackhole) throws IOException
{    readFile(file_1M_CHECKSUMS_UNCOMPRESSED, ONE_MILLION, false, blackhole);}
4dd9be6c6c8ac602e5881e2159a9c6765f7cbbae2212ca612a0adc85b7ae40d2
read1MRowsUncompressedWithVerification
public void read1MRowsUncompressedWithVerification(Blackhole blackhole) throws IOException
{    readFile(file_1M_CHECKSUMS_UNCOMPRESSED, ONE_MILLION, true, blackhole);}
ea908e6885bc80d92953b8130611e9bde8216fc17aac4c8a0f07234e19721efc
read1MRowsGzipWithoutVerification
public void read1MRowsGzipWithoutVerification(Blackhole blackhole) throws IOException
{    readFile(file_1M_CHECKSUMS_GZIP, ONE_MILLION, false, blackhole);}
ddddb0089ab5e90835b7df7030cea864c29a1a434def66a20e85982fdb9962d2
read1MRowsGzipWithVerification
public void read1MRowsGzipWithVerification(Blackhole blackhole) throws IOException
{    readFile(file_1M_CHECKSUMS_GZIP, ONE_MILLION, true, blackhole);}
2b48cdf1da7e32165ff381020155efa29d814002704262b2b6a6b6e2dccece6f
read1MRowsSnappyWithoutVerification
public void read1MRowsSnappyWithoutVerification(Blackhole blackhole) throws IOException
{    readFile(file_1M_CHECKSUMS_SNAPPY, ONE_MILLION, false, blackhole);}
569f65cb3a3e7adcd3db50898807fe2f9938aee63cf63c7377d0980e7e9fbbb2
read1MRowsSnappyWithVerification
public void read1MRowsSnappyWithVerification(Blackhole blackhole) throws IOException
{    readFile(file_1M_CHECKSUMS_SNAPPY, ONE_MILLION, true, blackhole);}
4af89ac4510277474a56d670f75204abfc12368d5e395917d412cd8f0a93513d
read10MRowsUncompressedWithoutVerification
public void read10MRowsUncompressedWithoutVerification(Blackhole blackhole) throws IOException
{    readFile(file_10M_CHECKSUMS_UNCOMPRESSED, 10 * ONE_MILLION, false, blackhole);}
08f23d62e2b03b09fc368d4a3190048510a71bc9e5d11d0a045e5b48b55ad46e
read10MRowsUncompressedWithVerification
public void read10MRowsUncompressedWithVerification(Blackhole blackhole) throws IOException
{    readFile(file_10M_CHECKSUMS_UNCOMPRESSED, 10 * ONE_MILLION, true, blackhole);}
20aaff57975398a725507e5c0b20ce74ae4d836bf18dbe14b1e861a79908347d
read10MRowsGzipWithoutVerification
public void read10MRowsGzipWithoutVerification(Blackhole blackhole) throws IOException
{    readFile(file_10M_CHECKSUMS_GZIP, 10 * ONE_MILLION, false, blackhole);}
39feb59b9636f1cdb839c2d18cf1a501891452f2f1f48607076336a0a4636e65
read10MRowsGzipWithVerification
public void read10MRowsGzipWithVerification(Blackhole blackhole) throws IOException
{    readFile(file_10M_CHECKSUMS_GZIP, 10 * ONE_MILLION, true, blackhole);}
da57271bdf24e3d0e2afff78012be09f1b6f86d5e5eb31216a28519b552109cf
read10MRowsSnappyWithoutVerification
public void read10MRowsSnappyWithoutVerification(Blackhole blackhole) throws IOException
{    readFile(file_10M_CHECKSUMS_SNAPPY, 10 * ONE_MILLION, false, blackhole);}
ef924a839406d86a277f3e46ea59cce517b153ebcc4f466e6e231598f358e7fd
read10MRowsSnappyWithVerification
public void read10MRowsSnappyWithVerification(Blackhole blackhole) throws IOException
{    readFile(file_10M_CHECKSUMS_SNAPPY, 10 * ONE_MILLION, true, blackhole);}
5ff0b8f7d2b080bcc6214fa5f91be74727145ea81cacb63a99c8d0f3106c089f
setup
public void setup()
{    pageChecksumDataGenerator.cleanup();}
e6b7d46cd3f9b504a699d06d70289c64d44b7687d4c45618eb1db2dce0893162
write100KRowsUncompressedWithoutChecksums
public void write100KRowsUncompressedWithoutChecksums() throws IOException
{    pageChecksumDataGenerator.generateData(file_100K_NOCHECKSUMS_UNCOMPRESSED, 100 * ONE_K, false, UNCOMPRESSED);}
ff6caa0154c38acf73f7f843a3fccc95466c3d19cb3092ef8c0b5407b3e136cf
write100KRowsUncompressedWithChecksums
public void write100KRowsUncompressedWithChecksums() throws IOException
{    pageChecksumDataGenerator.generateData(file_100K_CHECKSUMS_UNCOMPRESSED, 100 * ONE_K, true, UNCOMPRESSED);}
443e9e4e8c1960fa81eb02a6f348a5536a5064a141bb22955d2e902abaaa1d93
write100KRowsGzipWithoutChecksums
public void write100KRowsGzipWithoutChecksums() throws IOException
{    pageChecksumDataGenerator.generateData(file_100K_NOCHECKSUMS_GZIP, 100 * ONE_K, false, GZIP);}
3592ffc353035965cffd9fc9fc16e845efb8ae7e7394c1185bb711b7004469f9
write100KRowsGzipWithChecksums
public void write100KRowsGzipWithChecksums() throws IOException
{    pageChecksumDataGenerator.generateData(file_100K_CHECKSUMS_GZIP, 100 * ONE_K, true, GZIP);}
9d3e98286b56b54b34ba55182ae02e2c18aa27f3c1d46d445ee1c7137389594e
write100KRowsSnappyWithoutChecksums
public void write100KRowsSnappyWithoutChecksums() throws IOException
{    pageChecksumDataGenerator.generateData(file_100K_NOCHECKSUMS_SNAPPY, 100 * ONE_K, false, SNAPPY);}
910f43cf785ed9554d8fd4a3176839686adc0f16790239cfffc77206d144a134
write100KRowsSnappyWithChecksums
public void write100KRowsSnappyWithChecksums() throws IOException
{    pageChecksumDataGenerator.generateData(file_100K_CHECKSUMS_SNAPPY, 100 * ONE_K, true, SNAPPY);}
43f473701965a22a5f34df28ed83d7fb3e3549ca2ade76f92528e83ea473e5f1
write1MRowsUncompressedWithoutChecksums
public void write1MRowsUncompressedWithoutChecksums() throws IOException
{    pageChecksumDataGenerator.generateData(file_1M_NOCHECKSUMS_UNCOMPRESSED, ONE_MILLION, false, UNCOMPRESSED);}
fd56622b8494fa180547fdfcd2e61614c56f7da1fba2d64f674d78ae0a30f71a
write1MRowsUncompressedWithChecksums
public void write1MRowsUncompressedWithChecksums() throws IOException
{    pageChecksumDataGenerator.generateData(file_1M_CHECKSUMS_UNCOMPRESSED, ONE_MILLION, true, UNCOMPRESSED);}
780cf6d0b878586488be71b9241a35007e39e06997810d82c16c8d7541e54a63
write1MRowsGzipWithoutChecksums
public void write1MRowsGzipWithoutChecksums() throws IOException
{    pageChecksumDataGenerator.generateData(file_1M_NOCHECKSUMS_GZIP, ONE_MILLION, false, GZIP);}
ef4ba451a7772b5114f8752a2b96f2b98ddcb5aa32b79be47d53b6788f5399bb
write1MRowsGzipWithChecksums
public void write1MRowsGzipWithChecksums() throws IOException
{    pageChecksumDataGenerator.generateData(file_1M_CHECKSUMS_GZIP, ONE_MILLION, true, GZIP);}
885f0aa46ced89171a10b9906171a745b3204650a08b365530496800ac12d002
write1MRowsSnappyWithoutChecksums
public void write1MRowsSnappyWithoutChecksums() throws IOException
{    pageChecksumDataGenerator.generateData(file_1M_NOCHECKSUMS_SNAPPY, ONE_MILLION, false, SNAPPY);}
fe014558c32cfe3b04d2d530cc32c2280dd8ba6a98052c2dd4cab699d392268a
write1MRowsSnappyWithChecksums
public void write1MRowsSnappyWithChecksums() throws IOException
{    pageChecksumDataGenerator.generateData(file_1M_CHECKSUMS_SNAPPY, ONE_MILLION, true, SNAPPY);}
e6aebeb57aa3e5f4851e179dc292316eee578e28b2b05e14c0cf62b49d4319eb
write10MRowsUncompressedWithoutChecksums
public void write10MRowsUncompressedWithoutChecksums() throws IOException
{    pageChecksumDataGenerator.generateData(file_10M_NOCHECKSUMS_UNCOMPRESSED, 10 * ONE_MILLION, false, UNCOMPRESSED);}
4254a6d67a7af835a08f0ce32dd204d4a2d79bb804a176cb1a095a6fac5b04ce
write10MRowsUncompressedWithChecksums
public void write10MRowsUncompressedWithChecksums() throws IOException
{    pageChecksumDataGenerator.generateData(file_10M_CHECKSUMS_UNCOMPRESSED, 10 * ONE_MILLION, true, UNCOMPRESSED);}
bdc64eea5a085d03ff1d0155b38645ed78970aecb443220d8a44cd4b628b9ab6
write10MRowsGzipWithoutChecksums
public void write10MRowsGzipWithoutChecksums() throws IOException
{    pageChecksumDataGenerator.generateData(file_10M_NOCHECKSUMS_GZIP, 10 * ONE_MILLION, false, GZIP);}
e967e5ad6fd3b30bcc3e380783e2421fd03d3e328bf6f5ae19c4a0dbb012823d
write10MRowsGzipWithChecksums
public void write10MRowsGzipWithChecksums() throws IOException
{    pageChecksumDataGenerator.generateData(file_10M_CHECKSUMS_GZIP, 10 * ONE_MILLION, true, GZIP);}
56beecfaf551b09e60b11aa5f8e1832cd63f9fe1b1066881912cea89007c771f
write10MRowsSnappyWithoutChecksums
public void write10MRowsSnappyWithoutChecksums() throws IOException
{    pageChecksumDataGenerator.generateData(file_10M_NOCHECKSUMS_SNAPPY, 10 * ONE_MILLION, false, SNAPPY);}
0f131ffe638d545e91191365f743e814757836a4f71f2b37300b09e087d04a6a
write10MRowsSnappyWithChecksums
public void write10MRowsSnappyWithChecksums() throws IOException
{    pageChecksumDataGenerator.generateData(file_10M_CHECKSUMS_SNAPPY, 10 * ONE_MILLION, true, SNAPPY);}
f57bf47c9e3e959f5d43c30f6eb74f598e68b0697636b274b7cad4e074ac0d92
read
private void read(Path parquetFile, int nRows, Blackhole blackhole) throws IOException
{    ParquetReader<Group> reader = ParquetReader.builder(new GroupReadSupport(), parquetFile).withConf(configuration).build();    for (int i = 0; i < nRows; i++) {        Group group = reader.read();        blackhole.consume(group.getBinary("binary_field", 0));        blackhole.consume(group.getInteger("int32_field", 0));        blackhole.consume(group.getLong("int64_field", 0));        blackhole.consume(group.getBoolean("boolean_field", 0));        blackhole.consume(group.getFloat("float_field", 0));        blackhole.consume(group.getDouble("double_field", 0));        blackhole.consume(group.getBinary("flba_field", 0));        blackhole.consume(group.getInt96("int96_field", 0));    }    reader.close();}
fd05c161eaa4ee2d6b0c7790e9f39ad1adac72e85cff51920adf1fc70cfd2438
generateFilesForRead
public void generateFilesForRead()
{    new DataGenerator().generateAll();}
9146af9e1dc78ab3b8c929579936135eef390e828a5752d776714119851b322b
read1MRowsDefaultBlockAndPageSizeUncompressed
public void read1MRowsDefaultBlockAndPageSizeUncompressed(Blackhole blackhole) throws IOException
{    read(file_1M, ONE_MILLION, blackhole);}
c7b22fbf46101516164c9a024ce304dc1bbc1caa05c26a06589800a840ff7254
read1MRowsBS256MPS4MUncompressed
public void read1MRowsBS256MPS4MUncompressed(Blackhole blackhole) throws IOException
{    read(file_1M_BS256M_PS4M, ONE_MILLION, blackhole);}
311bd628060ce152077e3286744abb57313d5a1674b1e651f41c811e4e16ce73
read1MRowsBS256MPS8MUncompressed
public void read1MRowsBS256MPS8MUncompressed(Blackhole blackhole) throws IOException
{    read(file_1M_BS256M_PS8M, ONE_MILLION, blackhole);}
ad3caa69cf346f5fe03aaca9efc2394eee740a2e905add8a723f59132ac0bd4b
read1MRowsBS512MPS4MUncompressed
public void read1MRowsBS512MPS4MUncompressed(Blackhole blackhole) throws IOException
{    read(file_1M_BS512M_PS4M, ONE_MILLION, blackhole);}
509414fd9288675ea7cf811b32d5f06c6337c7d2b6d203e3797cc81568fce869
read1MRowsBS512MPS8MUncompressed
public void read1MRowsBS512MPS8MUncompressed(Blackhole blackhole) throws IOException
{    read(file_1M_BS512M_PS8M, ONE_MILLION, blackhole);}
8660ad676ef79c0425b43d7b7aa49f3aa47a83c90f0ec1471a331059a4204f05
read1MRowsDefaultBlockAndPageSizeSNAPPY
public void read1MRowsDefaultBlockAndPageSizeSNAPPY(Blackhole blackhole) throws IOException
{    read(file_1M_SNAPPY, ONE_MILLION, blackhole);}
28328478b2aed934b4c0cb2c25f7f91cf2800dd9103c08d0fe9d93bdc0175101
read1MRowsDefaultBlockAndPageSizeGZIP
public void read1MRowsDefaultBlockAndPageSizeGZIP(Blackhole blackhole) throws IOException
{    read(file_1M_GZIP, ONE_MILLION, blackhole);}
5ff0b8f7d2b080bcc6214fa5f91be74727145ea81cacb63a99c8d0f3106c089f
setup
public void setup()
{        dataGenerator.cleanup();}
5b8b3f82b27f8a7377f60a5b7a704c0a7e7bccfb5e6de5cf907986b1c8896838
write1MRowsDefaultBlockAndPageSizeUncompressed
public void write1MRowsDefaultBlockAndPageSizeUncompressed() throws IOException
{    dataGenerator.generateData(file_1M, configuration, PARQUET_2_0, BLOCK_SIZE_DEFAULT, PAGE_SIZE_DEFAULT, FIXED_LEN_BYTEARRAY_SIZE, UNCOMPRESSED, ONE_MILLION);}
16e5e6c3bf61bf1b030fbb190c6bb51179721d1b7f6e856a05da155da497eed9
write1MRowsBS256MPS4MUncompressed
public void write1MRowsBS256MPS4MUncompressed() throws IOException
{    dataGenerator.generateData(file_1M_BS256M_PS4M, configuration, PARQUET_2_0, BLOCK_SIZE_256M, PAGE_SIZE_4M, FIXED_LEN_BYTEARRAY_SIZE, UNCOMPRESSED, ONE_MILLION);}
83c57ee09be9c4d8b01f2e1fbf67d7c3b925e1059fdae3ed60092fb2db5a73eb
write1MRowsBS256MPS8MUncompressed
public void write1MRowsBS256MPS8MUncompressed() throws IOException
{    dataGenerator.generateData(file_1M_BS256M_PS8M, configuration, PARQUET_2_0, BLOCK_SIZE_256M, PAGE_SIZE_8M, FIXED_LEN_BYTEARRAY_SIZE, UNCOMPRESSED, ONE_MILLION);}
b6815d6cad5b6b74ad98baa2086be8b230cdbb373e5878ba03344d0119732d76
write1MRowsBS512MPS4MUncompressed
public void write1MRowsBS512MPS4MUncompressed() throws IOException
{    dataGenerator.generateData(file_1M_BS512M_PS4M, configuration, PARQUET_2_0, BLOCK_SIZE_512M, PAGE_SIZE_4M, FIXED_LEN_BYTEARRAY_SIZE, UNCOMPRESSED, ONE_MILLION);}
34b2ab40cafb3e4621b6483da2b03b6bd56630633cd65336d6958922cd2fdbf4
write1MRowsBS512MPS8MUncompressed
public void write1MRowsBS512MPS8MUncompressed() throws IOException
{    dataGenerator.generateData(file_1M_BS512M_PS8M, configuration, PARQUET_2_0, BLOCK_SIZE_512M, PAGE_SIZE_8M, FIXED_LEN_BYTEARRAY_SIZE, UNCOMPRESSED, ONE_MILLION);}
3ca11d63b13554fc66b52edbb897a4ac434a7651b16f51a3a7507ed8977f16ae
write1MRowsDefaultBlockAndPageSizeSNAPPY
public void write1MRowsDefaultBlockAndPageSizeSNAPPY() throws IOException
{    dataGenerator.generateData(file_1M_SNAPPY, configuration, PARQUET_2_0, BLOCK_SIZE_DEFAULT, PAGE_SIZE_DEFAULT, FIXED_LEN_BYTEARRAY_SIZE, SNAPPY, ONE_MILLION);}
7c33579eab492707b0c68cdb15733b8d0e2f86d19da58f9b5d7c085de39f1214
write1MRowsDefaultBlockAndPageSizeGZIP
public void write1MRowsDefaultBlockAndPageSizeGZIP() throws IOException
{    dataGenerator.generateData(file_1M_GZIP, configuration, PARQUET_2_0, BLOCK_SIZE_DEFAULT, PAGE_SIZE_DEFAULT, FIXED_LEN_BYTEARRAY_SIZE, GZIP, ONE_MILLION);}
6542d259002d40e003f1c00e209397cdc8f1a747d4b2f7eca66c4e0eb42e4b5d
sourceConfInit
public void sourceConfInit(FlowProcess<JobConf> fp, Tap<JobConf, RecordReader, OutputCollector> tap, JobConf jobConf)
{    super.sourceConfInit(fp, tap, jobConf);    jobConf.setInputFormat(DeprecatedParquetInputFormat.class);    ParquetInputFormat.setReadSupportClass(jobConf, ThriftReadSupport.class);    ThriftReadSupport.setRecordConverterClass(jobConf, TBaseRecordConverter.class);}
37cca28adcf19bb5011e6fa98d732b7078bc9ac65004a26651c50c2a48cbc811
sinkConfInit
public void sinkConfInit(FlowProcess<JobConf> fp, Tap<JobConf, RecordReader, OutputCollector> tap, JobConf jobConf)
{    if (this.config.getKlass() == null) {        throw new IllegalArgumentException("To use ParquetTBaseScheme as a sink, you must specify a thrift class in the constructor");    }    DeprecatedParquetOutputFormat.setAsOutputFormat(jobConf);    DeprecatedParquetOutputFormat.setWriteSupportClass(jobConf, TBaseWriteSupport.class);    TBaseWriteSupport.<T>setThriftClass(jobConf, this.config.getKlass());}
6542d259002d40e003f1c00e209397cdc8f1a747d4b2f7eca66c4e0eb42e4b5d
sourceConfInit
public void sourceConfInit(FlowProcess<JobConf> fp, Tap<JobConf, RecordReader, OutputCollector> tap, JobConf jobConf)
{    if (filterPredicate != null) {        ParquetInputFormat.setFilterPredicate(jobConf, filterPredicate);    }    jobConf.setInputFormat(DeprecatedParquetInputFormat.class);    ParquetInputFormat.setReadSupportClass(jobConf, TupleReadSupport.class);    TupleReadSupport.setRequestedFields(jobConf, getSourceFields());}
76edb5ee56a5658df4cc05082705bb6180f2276fcfaa0a771c76f8c734b72fdb
retrieveSourceFields
public Fields retrieveSourceFields(FlowProcess<JobConf> flowProcess, Tap tap)
{    MessageType schema = readSchema(flowProcess, tap);    SchemaIntersection intersection = new SchemaIntersection(schema, getSourceFields());    setSourceFields(intersection.getSourceFields());    return getSourceFields();}
835ffe7480fa6e29b0f5fb35931bb8bcd8b15b2ee7bb8b493d94324900e51dbd
readSchema
private MessageType readSchema(FlowProcess<JobConf> flowProcess, Tap tap)
{    try {        Hfs hfs;        if (tap instanceof CompositeTap)            hfs = (Hfs) ((CompositeTap) tap).getChildTaps().next();        else            hfs = (Hfs) tap;        List<Footer> footers = getFooters(flowProcess, hfs);        if (footers.isEmpty()) {            throw new TapException("Could not read Parquet metadata at " + hfs.getPath());        } else {            return footers.get(0).getParquetMetadata().getFileMetaData().getSchema();        }    } catch (IOException e) {        throw new TapException(e);    }}
76cead93fae0f075a63bbbeb4ca2c0f4293ff44bb97744d329faa90f0d125547
getFooters
private List<Footer> getFooters(FlowProcess<JobConf> flowProcess, Hfs hfs) throws IOException
{    JobConf jobConf = flowProcess.getConfigCopy();    DeprecatedParquetInputFormat format = new DeprecatedParquetInputFormat();    format.addInputPath(jobConf, hfs.getPath());    return format.getFooters(jobConf);}
06b8db2a1dfc26dd8ba4c3d36463199482cc393e009234134a62f0d9e09a5298
source
public boolean source(FlowProcess<JobConf> fp, SourceCall<Object[], RecordReader> sc) throws IOException
{    Container<Tuple> value = (Container<Tuple>) sc.getInput().createValue();    boolean hasNext = sc.getInput().next(null, value);    if (!hasNext) {        return false;    }        if (value == null) {        return true;    }    sc.getIncomingEntry().setTuple(value.get());    return true;}
37cca28adcf19bb5011e6fa98d732b7078bc9ac65004a26651c50c2a48cbc811
sinkConfInit
public void sinkConfInit(FlowProcess<JobConf> fp, Tap<JobConf, RecordReader, OutputCollector> tap, JobConf jobConf)
{    DeprecatedParquetOutputFormat.setAsOutputFormat(jobConf);    jobConf.set(TupleWriteSupport.PARQUET_CASCADING_SCHEMA, parquetSchema);    ParquetOutputFormat.setWriteSupportClass(jobConf, TupleWriteSupport.class);}
54d8ceb0a7ec948b10f25adcda94cd33d20a707d8239f2b801dac849663217ee
isSink
public boolean isSink()
{    return parquetSchema != null;}
52eba1a2155afac5299a111c915daaba5833e7fe416d132ba91a4494f31dd0d8
sink
public void sink(FlowProcess<JobConf> fp, SinkCall<Object[], OutputCollector> sink) throws IOException
{    TupleEntry tuple = sink.getOutgoingEntry();    OutputCollector outputCollector = sink.getOutput();    outputCollector.collect(null, tuple);}
663542e9b7d6cfa68d7e9788994e0382d1a188d471f35eec88b068eb9a181b79
getFilterPredicate
public FilterPredicate getFilterPredicate()
{    return filterPredicate;}
69ee62cc66075307ce2587248ce7df1e12b48915c46751467f0bfaf9559bd0a8
getProjectionString
public String getProjectionString()
{    return deprecatedProjectionString;}
94d5753647ced6da136861337aca48913cd0963f85374ff9218497717abfba7b
getStrictProjectionString
public String getStrictProjectionString()
{    return strictProjectionString;}
62881eca1629eda92a61ebbb6a2a06d04d626e2fad5d35d60d401272452192d3
getKlass
public Class<T> getKlass()
{    return klass;}
ce1625daf9f311a4113458c0d58c9bfd140c83160979bc4824884fecd6c2ddaf
withFilterPredicate
public Config<T> withFilterPredicate(FilterPredicate f)
{    return new Config<T>(this.klass, checkNotNull(f, "filterPredicate"), this.deprecatedProjectionString, this.strictProjectionString);}
58ad6909e6f5ab1b0da5cc7d5ba26344b94cbc8d53685e605ab74d17a71f6823
withProjectionString
public Config<T> withProjectionString(String p)
{    return new Config<T>(this.klass, this.filterPredicate, checkNotNull(p, "projectionString"), this.strictProjectionString);}
e833780294a6cb3d862587234a0847de7930f5ea9425d632b8001fc5d729f27c
withStrictProjectionString
public Config<T> withStrictProjectionString(String p)
{    return new Config<T>(this.klass, this.filterPredicate, this.deprecatedProjectionString, checkNotNull(p, "projectionString"));}
99a6059f5fe2933734373888d6e710b1a6f49b17782a427c815c7421ee792d99
withRecordClass
public Config<T> withRecordClass(Class<T> klass)
{    return new Config<T>(checkNotNull(klass, "recordClass"), this.filterPredicate, this.deprecatedProjectionString, this.strictProjectionString);}
3a684605cbe3261e2a907041044a14bb769edf083caecdafb63d3d5e4089c0af
setProjectionPushdown
private void setProjectionPushdown(JobConf jobConf)
{    if (this.config.deprecatedProjectionString != null) {        ThriftReadSupport.setProjectionPushdown(jobConf, this.config.deprecatedProjectionString);    }}
b9e5239e4b505e6bb0dc30cab8d423a92e31079f3a803b81248a06a532b8ad75
setStrictProjectionPushdown
private void setStrictProjectionPushdown(JobConf jobConf)
{    if (this.config.strictProjectionString != null) {        ThriftReadSupport.setStrictFieldProjectionFilter(jobConf, this.config.strictProjectionString);    }}
e25f3a613d04278913d0479ae93f653882f36f1c8fa5ad76fc8955ac0b51bc1b
setPredicatePushdown
private void setPredicatePushdown(JobConf jobConf)
{    if (this.config.filterPredicate != null) {        ParquetInputFormat.setFilterPredicate(jobConf, this.config.filterPredicate);    }}
29c846d06ac57b5659005e9c76f22ad3b574696bc8eff42c68864547b16fcc92
sourceConfInit
public void sourceConfInit(FlowProcess<JobConf> jobConfFlowProcess, Tap<JobConf, RecordReader, OutputCollector> jobConfRecordReaderOutputCollectorTap, final JobConf jobConf)
{    setPredicatePushdown(jobConf);    setProjectionPushdown(jobConf);    setStrictProjectionPushdown(jobConf);    setRecordClass(jobConf);}
09a13becc29a94f69fa66d5b19483cfcd44dd26e907b4e7f8c703af3f1996ecd
setRecordClass
private void setRecordClass(JobConf jobConf)
{    if (config.klass != null) {        ParquetThriftInputFormat.setThriftClass(jobConf, config.klass);    }}
06b8db2a1dfc26dd8ba4c3d36463199482cc393e009234134a62f0d9e09a5298
source
public boolean source(FlowProcess<JobConf> fp, SourceCall<Object[], RecordReader> sc) throws IOException
{    Container<T> value = (Container<T>) sc.getInput().createValue();    boolean hasNext = sc.getInput().next(null, value);    if (!hasNext) {        return false;    }        if (value == null) {        return true;    }    sc.getIncomingEntry().setTuple(new Tuple(value.get()));    return true;}
67af7e7c1478a2aee28bfe337be85d20d65c63bf63cba62af5506572db42cceb
sink
public void sink(FlowProcess<JobConf> fp, SinkCall<Object[], OutputCollector> sc) throws IOException
{    TupleEntry tuple = sc.getOutgoingEntry();    if (tuple.size() != 1) {        throw new RuntimeException("ParquetValueScheme expects tuples with an arity of exactly 1, but found " + tuple.getFields());    }    T value = (T) tuple.getObject(0);    OutputCollector output = sc.getOutput();    output.collect(null, value);}
70719fa068547c628c50550d0f82e52fc806aa7ac04932f1f77606705fc3df9d
testWrite
public void testWrite() throws Exception
{    Path path = new Path(parquetOutputPath);    JobConf jobConf = new JobConf();    final FileSystem fs = path.getFileSystem(jobConf);    if (fs.exists(path))        fs.delete(path, true);    Scheme sourceScheme = new TextLine(new Fields("first", "last"));    Tap source = new Hfs(sourceScheme, txtInputPath);    Scheme sinkScheme = new ParquetTBaseScheme(Name.class);    Tap sink = new Hfs(sinkScheme, parquetOutputPath);    Pipe assembly = new Pipe("namecp");    assembly = new Each(assembly, new PackThriftFunction());    HadoopFlowConnector hadoopFlowConnector = new HadoopFlowConnector();    Flow flow = hadoopFlowConnector.connect("namecp", source, sink, assembly);    flow.complete();    assertTrue(fs.exists(new Path(parquetOutputPath)));    assertTrue(fs.exists(new Path(parquetOutputPath + "/_metadata")));    assertTrue(fs.exists(new Path(parquetOutputPath + "/_common_metadata")));}
5fd4a313e76b4c72b8f04da6d40c8f3f451749f179b8171720d0f7bb15574d8f
testRead
public void testRead() throws Exception
{    doRead(new ParquetTBaseScheme(Name.class));}
3c2b913d436fb1b350215a74364b4e57c5acd1f1e6afd79cb805d82f7ba82d57
testReadWithoutClass
public void testReadWithoutClass() throws Exception
{    doRead(new ParquetTBaseScheme());}
96872774776f48fed15d0d06a4e907e45c1f53c5ea281761fbd5b52b417fc18a
doRead
private void doRead(Scheme sourceScheme) throws Exception
{    createFileForRead();    Path path = new Path(txtOutputPath);    final FileSystem fs = path.getFileSystem(new Configuration());    if (fs.exists(path))        fs.delete(path, true);    Tap source = new Hfs(sourceScheme, parquetInputPath);    Scheme sinkScheme = new TextLine(new Fields("first", "last"));    Tap sink = new Hfs(sinkScheme, txtOutputPath);    Pipe assembly = new Pipe("namecp");    assembly = new Each(assembly, new UnpackThriftFunction());    Flow flow = new HadoopFlowConnector().connect("namecp", source, sink, assembly);    flow.complete();    String result = FileUtils.readFileToString(new File(txtOutputPath + "/part-00000"));    assertEquals("Alice\tPractice\nBob\tHope\nCharlie\tHorse\n", result);}
5ec74ee370a99998755dfb8582787761b784694e3149d9755cfb862ce2642112
createFileForRead
private void createFileForRead() throws Exception
{    final Path fileToCreate = new Path(parquetInputPath + "/names.parquet");    final Configuration conf = new Configuration();    final FileSystem fs = fileToCreate.getFileSystem(conf);    if (fs.exists(fileToCreate))        fs.delete(fileToCreate, true);    TProtocolFactory protocolFactory = new TCompactProtocol.Factory();    TaskAttemptID taskId = new TaskAttemptID("local", 0, true, 0, 0);    ThriftToParquetFileWriter w = new ThriftToParquetFileWriter(fileToCreate, ContextUtil.newTaskAttemptContext(conf, taskId), protocolFactory, Name.class);    final ByteArrayOutputStream baos = new ByteArrayOutputStream();    final TProtocol protocol = protocolFactory.getProtocol(new TIOStreamTransport(baos));    Name n1 = new Name();    n1.setFirst_name("Alice");    n1.setLast_name("Practice");    Name n2 = new Name();    n2.setFirst_name("Bob");    n2.setLast_name("Hope");    Name n3 = new Name();    n3.setFirst_name("Charlie");    n3.setLast_name("Horse");    n1.write(protocol);    w.write(new BytesWritable(baos.toByteArray()));    baos.reset();    n2.write(protocol);    w.write(new BytesWritable(baos.toByteArray()));    baos.reset();    n3.write(protocol);    w.write(new BytesWritable(baos.toByteArray()));    w.close();}
249a384a8ce00b5a43e2eaae043a0c519fb43142ee17436c249f156bdecde0cf
operate
public void operate(FlowProcess flowProcess, FunctionCall functionCall)
{    TupleEntry arguments = functionCall.getArguments();    Tuple result = new Tuple();    Name name = new Name();    name.setFirst_name(arguments.getString(0));    name.setLast_name(arguments.getString(1));    result.add(name);    functionCall.getOutputCollector().add(result);}
249a384a8ce00b5a43e2eaae043a0c519fb43142ee17436c249f156bdecde0cf
operate
public void operate(FlowProcess flowProcess, FunctionCall functionCall)
{    TupleEntry arguments = functionCall.getArguments();    Tuple result = new Tuple();    Name name = (Name) arguments.get(0);    result.add(name.getFirst_name());    result.add(name.getLast_name());    functionCall.getOutputCollector().add(result);}
383ec8c4ede08ec4758c9fd3f8cf0e521f45f351f145d888bb94f65c789c6f7f
newConverter
private Converter newConverter(Type type, int i)
{    if (!type.isPrimitive()) {        throw new IllegalArgumentException("cascading can only build tuples from primitive types");    } else {        return new TuplePrimitiveConverter(this, i);    }}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    return converters[fieldIndex];}
016bac278a8f60aec7a89722089f1c9f9f835485f6ec65fc52d0e84186d25458
start
public final void start()
{    currentTuple = Tuple.size(converters.length);}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{}
c7f3e4931c4b68e44c3c90e99aef712be371bba8a4d1809a20e1a803a9fce16f
getCurrentTuple
public final Tuple getCurrentTuple()
{    return currentTuple;}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    parent.getCurrentTuple().setString(index, value.toStringUsingUTF8());}
23123f6657c241ab9b9f31f8efedc28a553ed91046d705121ce2667b065d6c17
addBoolean
public void addBoolean(boolean value)
{    parent.getCurrentTuple().setBoolean(index, value);}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    parent.getCurrentTuple().setDouble(index, value);}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    parent.getCurrentTuple().setFloat(index, value);}
a2ac1f40a6e220ec515710128c8baf77a725ad0b9f1767a998f776f27fff6cf6
addInt
public void addInt(int value)
{    parent.getCurrentTuple().setInteger(index, value);}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    parent.getCurrentTuple().setLong(index, value);}
f217af5a4bd0d4c550c05f4593198974a2891c9655de266166cf37177252324b
getCurrentRecord
public Tuple getCurrentRecord()
{    return root.getCurrentTuple();}
92fd854c4aebb01be238d83e407159211ea5cf60b5efd6fc7db8904dba13699b
getRootConverter
public GroupConverter getRootConverter()
{    return root;}
e1e0c3cb304597743a3ef9c8ae953b1d73e1762c1f5d450bc08f482310d354c6
getRequestedSchema
public MessageType getRequestedSchema()
{    return requestedSchema;}
3819d5b68b81971edd5e45e30bdd3d83020aed52d695cc852b1edead850a5d41
getSourceFields
public Fields getSourceFields()
{    return sourceFields;}
0c35dd513bb326ac26086d95915ccdb84bf8575a32ab47ffaad5e72dc6f4486e
getRequestedFields
protected static Fields getRequestedFields(Configuration configuration)
{    String fieldsString = configuration.get(PARQUET_CASCADING_REQUESTED_FIELDS);    if (fieldsString == null)        return Fields.ALL;    String[] parts = StringUtils.split(fieldsString, ":");    if (parts.length == 0)        return Fields.ALL;    else        return new Fields(parts);}
b7d02d4690774b19be56c0468205695b2846e119a98c0fd0e1d7f47078a486ed
setRequestedFields
protected static void setRequestedFields(JobConf configuration, Fields fields)
{    String fieldsString = StringUtils.join(fields.iterator(), ":");    configuration.set(PARQUET_CASCADING_REQUESTED_FIELDS, fieldsString);}
9f05e23006c5ef7acb499b683c83254f7d016dadfbda9d65c3f1212d59959596
init
public ReadContext init(Configuration configuration, Map<String, String> keyValueMetaData, MessageType fileSchema)
{    Fields requestedFields = getRequestedFields(configuration);    if (requestedFields == null) {        return new ReadContext(fileSchema);    } else {        SchemaIntersection intersection = new SchemaIntersection(fileSchema, requestedFields);        return new ReadContext(intersection.getRequestedSchema());    }}
2ccc017acce6dd815e6be342b8fcd102a893ed79a7d490b11b70a9c7e1ca3783
prepareForRead
public RecordMaterializer<Tuple> prepareForRead(Configuration configuration, Map<String, String> keyValueMetaData, MessageType fileSchema, ReadContext readContext)
{    MessageType requestedSchema = readContext.getRequestedSchema();    return new TupleRecordMaterializer(requestedSchema);}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "cascading";}
89835da140a91d5cb5181a85b8db073a92d794e99966f7422502dbb7d5467b7c
init
public WriteContext init(Configuration configuration)
{    String schema = configuration.get(PARQUET_CASCADING_SCHEMA);    rootSchema = MessageTypeParser.parseMessageType(schema);    return new WriteContext(rootSchema, new HashMap<String, String>());}
da9aef78cf181856102b820ffa7d5248e8581747b3f0670a7b049c4649b962ef
prepareForWrite
public void prepareForWrite(RecordConsumer recordConsumer)
{    this.recordConsumer = recordConsumer;}
29e75d4eb6f2eea169951591067dfeb4a3b578fc3506e0f14430a65c7d2ca368
write
public void write(TupleEntry record)
{    recordConsumer.startMessage();    final List<Type> fields = rootSchema.getFields();    for (int i = 0; i < fields.size(); i++) {        Type field = fields.get(i);        if (record == null || record.getObject(field.getName()) == null) {            continue;        }        recordConsumer.startField(field.getName(), i);        if (field.isPrimitive()) {            writePrimitive(record, field.asPrimitiveType());        } else {            throw new UnsupportedOperationException("Complex type not implemented");        }        recordConsumer.endField(field.getName(), i);    }    recordConsumer.endMessage();}
695180b14db399624ac1c0d399e288060e23397e142280866cbc487ab4153e90
writePrimitive
private void writePrimitive(TupleEntry record, PrimitiveType field)
{    switch(field.getPrimitiveTypeName()) {        case BINARY:            recordConsumer.addBinary(Binary.fromString(record.getString(field.getName())));            break;        case BOOLEAN:            recordConsumer.addBoolean(record.getBoolean(field.getName()));            break;        case INT32:            recordConsumer.addInteger(record.getInteger(field.getName()));            break;        case INT64:            recordConsumer.addLong(record.getLong(field.getName()));            break;        case DOUBLE:            recordConsumer.addDouble(record.getDouble(field.getName()));            break;        case FLOAT:            recordConsumer.addFloat(record.getFloat(field.getName()));            break;        case FIXED_LEN_BYTE_ARRAY:            throw new UnsupportedOperationException("Fixed len byte array type not implemented");        case INT96:            throw new UnsupportedOperationException("Int96 type not implemented");        default:            throw new UnsupportedOperationException(field.getName() + " type not implemented");    }}
f2b2f428a93ff21bc52b9dae0a7cd2cd90c8bcfd37abed98582e1da77407f207
testReadPattern
public void testReadPattern() throws Exception
{    String sourceFolder = parquetInputPath;    testReadWrite(sourceFolder);    String sourceGlobPattern = parquetInputPath + "/*";    testReadWrite(sourceGlobPattern);    String multiLevelGlobPattern = "target/test/ParquetTupleIn/**/*";    testReadWrite(multiLevelGlobPattern);}
cccb633a11e69d1d62f0deee87892b4bfc4f52c87245b965f757184fe30d9c72
testFieldProjection
public void testFieldProjection() throws Exception
{    createFileForRead();    Path path = new Path(txtOutputPath);    final FileSystem fs = path.getFileSystem(new Configuration());    if (fs.exists(path))        fs.delete(path, true);    Scheme sourceScheme = new ParquetTupleScheme(new Fields("last_name"));    Tap source = new Hfs(sourceScheme, parquetInputPath);    Scheme sinkScheme = new TextLine(new Fields("last_name"));    Tap sink = new Hfs(sinkScheme, txtOutputPath);    Pipe assembly = new Pipe("namecp");    assembly = new Each(assembly, new ProjectedTupleFunction());    Flow flow = new HadoopFlowConnector().connect("namecp", source, sink, assembly);    flow.complete();    String result = FileUtils.readFileToString(new File(txtOutputPath + "/part-00000"));    assertEquals("Practice\nHope\nHorse\n", result);}
a3f4a9fa6055236f72851c997a9ea3639a966c91a858ef4ff58f61629ffe668d
testReadWrite
public void testReadWrite(String inputPath) throws Exception
{    createFileForRead();    Path path = new Path(txtOutputPath);    final FileSystem fs = path.getFileSystem(new Configuration());    if (fs.exists(path))        fs.delete(path, true);    Scheme sourceScheme = new ParquetTupleScheme(new Fields("first_name", "last_name"));    Tap source = new Hfs(sourceScheme, inputPath);    Scheme sinkScheme = new TextLine(new Fields("first", "last"));    Tap sink = new Hfs(sinkScheme, txtOutputPath);    Pipe assembly = new Pipe("namecp");    assembly = new Each(assembly, new UnpackTupleFunction());    Flow flow = new HadoopFlowConnector().connect("namecp", source, sink, assembly);    flow.complete();    String result = FileUtils.readFileToString(new File(txtOutputPath + "/part-00000"));    assertEquals("Alice\tPractice\nBob\tHope\nCharlie\tHorse\n", result);}
5ec74ee370a99998755dfb8582787761b784694e3149d9755cfb862ce2642112
createFileForRead
private void createFileForRead() throws Exception
{    final Path fileToCreate = new Path(parquetInputPath + "/names.parquet");    final Configuration conf = new Configuration();    final FileSystem fs = fileToCreate.getFileSystem(conf);    if (fs.exists(fileToCreate))        fs.delete(fileToCreate, true);    TProtocolFactory protocolFactory = new TCompactProtocol.Factory();    TaskAttemptID taskId = new TaskAttemptID("local", 0, true, 0, 0);    ThriftToParquetFileWriter w = new ThriftToParquetFileWriter(fileToCreate, ContextUtil.newTaskAttemptContext(conf, taskId), protocolFactory, Name.class);    final ByteArrayOutputStream baos = new ByteArrayOutputStream();    final TProtocol protocol = protocolFactory.getProtocol(new TIOStreamTransport(baos));    Name n1 = new Name();    n1.setFirst_name("Alice");    n1.setLast_name("Practice");    Name n2 = new Name();    n2.setFirst_name("Bob");    n2.setLast_name("Hope");    Name n3 = new Name();    n3.setFirst_name("Charlie");    n3.setLast_name("Horse");    n1.write(protocol);    w.write(new BytesWritable(baos.toByteArray()));    baos.reset();    n2.write(protocol);    w.write(new BytesWritable(baos.toByteArray()));    baos.reset();    n3.write(protocol);    w.write(new BytesWritable(baos.toByteArray()));    w.close();}
249a384a8ce00b5a43e2eaae043a0c519fb43142ee17436c249f156bdecde0cf
operate
public void operate(FlowProcess flowProcess, FunctionCall functionCall)
{    TupleEntry arguments = functionCall.getArguments();    Tuple result = new Tuple();    Tuple name = new Tuple();    name.addString(arguments.getString(0));    name.addString(arguments.getString(1));    result.add(name);    functionCall.getOutputCollector().add(result);}
249a384a8ce00b5a43e2eaae043a0c519fb43142ee17436c249f156bdecde0cf
operate
public void operate(FlowProcess flowProcess, FunctionCall functionCall)
{    TupleEntry arguments = functionCall.getArguments();    Tuple result = new Tuple();    Tuple name = new Tuple();    name.addString(arguments.getString(0));        result.add(name);    functionCall.getOutputCollector().add(result);}
54710884ec98f4f6e15906845487c5f557ac31a4215a9c0deccb8b593f4a77a9
sourceConfInit
public void sourceConfInit(FlowProcess<? extends JobConf> fp, Tap<JobConf, RecordReader, OutputCollector> tap, JobConf jobConf)
{    super.sourceConfInit(fp, tap, jobConf);    jobConf.setInputFormat(DeprecatedParquetInputFormat.class);    ParquetInputFormat.setReadSupportClass(jobConf, ThriftReadSupport.class);    ThriftReadSupport.setRecordConverterClass(jobConf, TBaseRecordConverter.class);}
66224d2e30f41191b01f21c1f11f79dd83b892cbe86d46257fa89938a5441a8f
sinkConfInit
public void sinkConfInit(FlowProcess<? extends JobConf> fp, Tap<JobConf, RecordReader, OutputCollector> tap, JobConf jobConf)
{    if (this.config.getKlass() == null) {        throw new IllegalArgumentException("To use ParquetTBaseScheme as a sink, you must specify a thrift class in the constructor");    }    DeprecatedParquetOutputFormat.setAsOutputFormat(jobConf);    DeprecatedParquetOutputFormat.setWriteSupportClass(jobConf, TBaseWriteSupport.class);    TBaseWriteSupport.<T>setThriftClass(jobConf, this.config.getKlass());}
54710884ec98f4f6e15906845487c5f557ac31a4215a9c0deccb8b593f4a77a9
sourceConfInit
public void sourceConfInit(FlowProcess<? extends JobConf> fp, Tap<JobConf, RecordReader, OutputCollector> tap, JobConf jobConf)
{    if (filterPredicate != null) {        ParquetInputFormat.setFilterPredicate(jobConf, filterPredicate);    }    jobConf.setInputFormat(DeprecatedParquetInputFormat.class);    ParquetInputFormat.setReadSupportClass(jobConf, TupleReadSupport.class);    TupleReadSupport.setRequestedFields(jobConf, getSourceFields());}
c1c51d1161a618bc93775ab039d1a36a2e3e6e51989bebb974095a3fb6e55223
retrieveSourceFields
public Fields retrieveSourceFields(FlowProcess<? extends JobConf> flowProcess, Tap tap)
{    MessageType schema = readSchema(flowProcess, tap);    SchemaIntersection intersection = new SchemaIntersection(schema, getSourceFields());    setSourceFields(intersection.getSourceFields());    return getSourceFields();}
3567a084976bbf2842c0d3ac11e24c7dcd84cad2d223fffe4fb83890a4e8d378
readSchema
private MessageType readSchema(FlowProcess<? extends JobConf> flowProcess, Tap tap)
{    try {        Hfs hfs;        if (tap instanceof CompositeTap)            hfs = (Hfs) ((CompositeTap) tap).getChildTaps().next();        else            hfs = (Hfs) tap;        List<Footer> footers = getFooters(flowProcess, hfs);        if (footers.isEmpty()) {            throw new TapException("Could not read Parquet metadata at " + hfs.getPath());        } else {            return footers.get(0).getParquetMetadata().getFileMetaData().getSchema();        }    } catch (IOException e) {        throw new TapException(e);    }}
a431274790ba5fc1e850337128b37a3988276454db5f1cc864977da957ad08ef
getFooters
private List<Footer> getFooters(FlowProcess<? extends JobConf> flowProcess, Hfs hfs) throws IOException
{    JobConf jobConf = flowProcess.getConfigCopy();    DeprecatedParquetInputFormat format = new DeprecatedParquetInputFormat();    format.addInputPath(jobConf, hfs.getPath());    return format.getFooters(jobConf);}
affbf6242cccad081a0640679f089578ee95308301b1eca673f3b8d6c59d6f84
source
public boolean source(FlowProcess<? extends JobConf> fp, SourceCall<Object[], RecordReader> sc) throws IOException
{    Container<Tuple> value = (Container<Tuple>) sc.getInput().createValue();    boolean hasNext = sc.getInput().next(null, value);    if (!hasNext) {        return false;    }        if (value == null) {        return true;    }    sc.getIncomingEntry().setTuple(value.get());    return true;}
66224d2e30f41191b01f21c1f11f79dd83b892cbe86d46257fa89938a5441a8f
sinkConfInit
public void sinkConfInit(FlowProcess<? extends JobConf> fp, Tap<JobConf, RecordReader, OutputCollector> tap, JobConf jobConf)
{    DeprecatedParquetOutputFormat.setAsOutputFormat(jobConf);    jobConf.set(TupleWriteSupport.PARQUET_CASCADING_SCHEMA, parquetSchema);    ParquetOutputFormat.setWriteSupportClass(jobConf, TupleWriteSupport.class);}
54d8ceb0a7ec948b10f25adcda94cd33d20a707d8239f2b801dac849663217ee
isSink
public boolean isSink()
{    return parquetSchema != null;}
f32d78530f072b310a6232b53aa3b725f360f02c2bdbbfbeaf4df980e3bdf253
sink
public void sink(FlowProcess<? extends JobConf> fp, SinkCall<Object[], OutputCollector> sink) throws IOException
{    TupleEntry tuple = sink.getOutgoingEntry();    OutputCollector outputCollector = sink.getOutput();    outputCollector.collect(null, tuple);}
663542e9b7d6cfa68d7e9788994e0382d1a188d471f35eec88b068eb9a181b79
getFilterPredicate
public FilterPredicate getFilterPredicate()
{    return filterPredicate;}
69ee62cc66075307ce2587248ce7df1e12b48915c46751467f0bfaf9559bd0a8
getProjectionString
public String getProjectionString()
{    return deprecatedProjectionString;}
94d5753647ced6da136861337aca48913cd0963f85374ff9218497717abfba7b
getStrictProjectionString
public String getStrictProjectionString()
{    return strictProjectionString;}
62881eca1629eda92a61ebbb6a2a06d04d626e2fad5d35d60d401272452192d3
getKlass
public Class<T> getKlass()
{    return klass;}
ce1625daf9f311a4113458c0d58c9bfd140c83160979bc4824884fecd6c2ddaf
withFilterPredicate
public Config<T> withFilterPredicate(FilterPredicate f)
{    return new Config<T>(this.klass, checkNotNull(f, "filterPredicate"), this.deprecatedProjectionString, this.strictProjectionString);}
58ad6909e6f5ab1b0da5cc7d5ba26344b94cbc8d53685e605ab74d17a71f6823
withProjectionString
public Config<T> withProjectionString(String p)
{    return new Config<T>(this.klass, this.filterPredicate, checkNotNull(p, "projectionString"), this.strictProjectionString);}
e833780294a6cb3d862587234a0847de7930f5ea9425d632b8001fc5d729f27c
withStrictProjectionString
public Config<T> withStrictProjectionString(String p)
{    return new Config<T>(this.klass, this.filterPredicate, this.deprecatedProjectionString, checkNotNull(p, "projectionString"));}
99a6059f5fe2933734373888d6e710b1a6f49b17782a427c815c7421ee792d99
withRecordClass
public Config<T> withRecordClass(Class<T> klass)
{    return new Config<T>(checkNotNull(klass, "recordClass"), this.filterPredicate, this.deprecatedProjectionString, this.strictProjectionString);}
3a684605cbe3261e2a907041044a14bb769edf083caecdafb63d3d5e4089c0af
setProjectionPushdown
private void setProjectionPushdown(JobConf jobConf)
{    if (this.config.deprecatedProjectionString != null) {        ThriftReadSupport.setProjectionPushdown(jobConf, this.config.deprecatedProjectionString);    }}
b9e5239e4b505e6bb0dc30cab8d423a92e31079f3a803b81248a06a532b8ad75
setStrictProjectionPushdown
private void setStrictProjectionPushdown(JobConf jobConf)
{    if (this.config.strictProjectionString != null) {        ThriftReadSupport.setStrictFieldProjectionFilter(jobConf, this.config.strictProjectionString);    }}
e25f3a613d04278913d0479ae93f653882f36f1c8fa5ad76fc8955ac0b51bc1b
setPredicatePushdown
private void setPredicatePushdown(JobConf jobConf)
{    if (this.config.filterPredicate != null) {        ParquetInputFormat.setFilterPredicate(jobConf, this.config.filterPredicate);    }}
cb0668763def11aced744700343d4661f2e19b2696a8b89d15512004fb3ab11e
sourceConfInit
public void sourceConfInit(FlowProcess<? extends JobConf> jobConfFlowProcess, Tap<JobConf, RecordReader, OutputCollector> jobConfRecordReaderOutputCollectorTap, JobConf jobConf)
{    setPredicatePushdown(jobConf);    setProjectionPushdown(jobConf);    setStrictProjectionPushdown(jobConf);    setRecordClass(jobConf);}
09a13becc29a94f69fa66d5b19483cfcd44dd26e907b4e7f8c703af3f1996ecd
setRecordClass
private void setRecordClass(JobConf jobConf)
{    if (config.klass != null) {        ParquetThriftInputFormat.setThriftClass(jobConf, config.klass);    }}
affbf6242cccad081a0640679f089578ee95308301b1eca673f3b8d6c59d6f84
source
public boolean source(FlowProcess<? extends JobConf> fp, SourceCall<Object[], RecordReader> sc) throws IOException
{    Container<T> value = (Container<T>) sc.getInput().createValue();    boolean hasNext = sc.getInput().next(null, value);    if (!hasNext) {        return false;    }        if (value == null) {        return true;    }    sc.getIncomingEntry().setTuple(new Tuple(value.get()));    return true;}
4c9b05ad24548aca9041f47e208ff6ab78fc89e967a94c2431b0274203049177
sink
public void sink(FlowProcess<? extends JobConf> fp, SinkCall<Object[], OutputCollector> sc) throws IOException
{    TupleEntry tuple = sc.getOutgoingEntry();    if (tuple.size() != 1) {        throw new RuntimeException("ParquetValueScheme expects tuples with an arity of exactly 1, but found " + tuple.getFields());    }    T value = (T) tuple.getObject(0);    OutputCollector output = sc.getOutput();    output.collect(null, value);}
70719fa068547c628c50550d0f82e52fc806aa7ac04932f1f77606705fc3df9d
testWrite
public void testWrite() throws Exception
{    Path path = new Path(parquetOutputPath);    JobConf jobConf = new JobConf();    final FileSystem fs = path.getFileSystem(jobConf);    if (fs.exists(path))        fs.delete(path, true);    Scheme sourceScheme = new TextLine(new Fields("first", "last"));    Tap source = new Hfs(sourceScheme, txtInputPath);    Scheme sinkScheme = new ParquetTBaseScheme(Name.class);    Tap sink = new Hfs(sinkScheme, parquetOutputPath);    Pipe assembly = new Pipe("namecp");    assembly = new Each(assembly, new PackThriftFunction());    HadoopFlowConnector hadoopFlowConnector = new HadoopFlowConnector();    Flow flow = hadoopFlowConnector.connect("namecp", source, sink, assembly);    flow.complete();    assertTrue(fs.exists(new Path(parquetOutputPath)));    assertTrue(fs.exists(new Path(parquetOutputPath + "/_metadata")));    assertTrue(fs.exists(new Path(parquetOutputPath + "/_common_metadata")));}
5fd4a313e76b4c72b8f04da6d40c8f3f451749f179b8171720d0f7bb15574d8f
testRead
public void testRead() throws Exception
{    doRead(new ParquetTBaseScheme(Name.class));}
3c2b913d436fb1b350215a74364b4e57c5acd1f1e6afd79cb805d82f7ba82d57
testReadWithoutClass
public void testReadWithoutClass() throws Exception
{    doRead(new ParquetTBaseScheme());}
96872774776f48fed15d0d06a4e907e45c1f53c5ea281761fbd5b52b417fc18a
doRead
private void doRead(Scheme sourceScheme) throws Exception
{    createFileForRead();    Path path = new Path(txtOutputPath);    final FileSystem fs = path.getFileSystem(new Configuration());    if (fs.exists(path))        fs.delete(path, true);    Tap source = new Hfs(sourceScheme, parquetInputPath);    Scheme sinkScheme = new TextLine(new Fields("first", "last"));    Tap sink = new Hfs(sinkScheme, txtOutputPath);    Pipe assembly = new Pipe("namecp");    assembly = new Each(assembly, new UnpackThriftFunction());    Flow flow = new HadoopFlowConnector().connect("namecp", source, sink, assembly);    flow.complete();    String result = FileUtils.readFileToString(new File(txtOutputPath + "/part-00000"));    assertEquals("Alice\tPractice\nBob\tHope\nCharlie\tHorse\n", result);}
5ec74ee370a99998755dfb8582787761b784694e3149d9755cfb862ce2642112
createFileForRead
private void createFileForRead() throws Exception
{    final Path fileToCreate = new Path(parquetInputPath + "/names.parquet");    final Configuration conf = new Configuration();    final FileSystem fs = fileToCreate.getFileSystem(conf);    if (fs.exists(fileToCreate))        fs.delete(fileToCreate, true);    TProtocolFactory protocolFactory = new TCompactProtocol.Factory();    TaskAttemptID taskId = new TaskAttemptID("local", 0, true, 0, 0);    ThriftToParquetFileWriter w = new ThriftToParquetFileWriter(fileToCreate, ContextUtil.newTaskAttemptContext(conf, taskId), protocolFactory, Name.class);    final ByteArrayOutputStream baos = new ByteArrayOutputStream();    final TProtocol protocol = protocolFactory.getProtocol(new TIOStreamTransport(baos));    Name n1 = new Name();    n1.setFirst_name("Alice");    n1.setLast_name("Practice");    Name n2 = new Name();    n2.setFirst_name("Bob");    n2.setLast_name("Hope");    Name n3 = new Name();    n3.setFirst_name("Charlie");    n3.setLast_name("Horse");    n1.write(protocol);    w.write(new BytesWritable(baos.toByteArray()));    baos.reset();    n2.write(protocol);    w.write(new BytesWritable(baos.toByteArray()));    baos.reset();    n3.write(protocol);    w.write(new BytesWritable(baos.toByteArray()));    w.close();}
249a384a8ce00b5a43e2eaae043a0c519fb43142ee17436c249f156bdecde0cf
operate
public void operate(FlowProcess flowProcess, FunctionCall functionCall)
{    TupleEntry arguments = functionCall.getArguments();    Tuple result = new Tuple();    Name name = new Name();    name.setFirst_name(arguments.getString(0));    name.setLast_name(arguments.getString(1));    result.add(name);    functionCall.getOutputCollector().add(result);}
249a384a8ce00b5a43e2eaae043a0c519fb43142ee17436c249f156bdecde0cf
operate
public void operate(FlowProcess flowProcess, FunctionCall functionCall)
{    TupleEntry arguments = functionCall.getArguments();    Tuple result = new Tuple();    Name name = (Name) arguments.getObject(0);    result.add(name.getFirst_name());    result.add(name.getLast_name());    functionCall.getOutputCollector().add(result);}
fa089fb011403e6208bd60e0ab22af26534ed6e5a709dd0d2da5b1b37645ee9c
defaultFS
public FileSystem defaultFS() throws IOException
{    if (localFS == null) {        this.localFS = FileSystem.getLocal(getConf());    }    return localFS;}
13bec5dfbbea38d237bbf488fa8c59b134dc83add9b2e35b7af48029bd13e26b
output
public void output(String content, Logger console, String filename) throws IOException
{    if (filename == null || "-".equals(filename)) {        console.info(content);    } else {        FSDataOutputStream outgoing = create(filename);        try {            outgoing.write(content.getBytes(StandardCharsets.UTF_8));        } finally {            outgoing.close();        }    }}
1c636fee96458e39d063bbaad90ab91c514c98d64e35b60780f6ba8ecb5dd9a7
create
public FSDataOutputStream create(String filename) throws IOException
{    return create(filename, true);}
a1b2143071f366292f472c85aafb69aa4b6e7a0ac930ac4b52deb37f160cba23
createWithChecksum
public FSDataOutputStream createWithChecksum(String filename) throws IOException
{    return create(filename, false);}
45e2f071711dd43332d88b3ba6e3635d83a721c29145643e06fbfcec0c28023e
create
private FSDataOutputStream create(String filename, boolean noChecksum) throws IOException
{    Path filePath = qualifiedPath(filename);        FileSystem fs = filePath.getFileSystem(getConf());    if (noChecksum && fs instanceof ChecksumFileSystem) {        fs = ((ChecksumFileSystem) fs).getRawFileSystem();    }    return fs.create(filePath, true);}
6d7484b81353ba550043eded3cb5eeba1f2deea6c8957612a8e173d6917c67d6
qualifiedPath
public Path qualifiedPath(String filename) throws IOException
{    Path cwd = defaultFS().makeQualified(new Path("."));    return new Path(filename).makeQualified(defaultFS().getUri(), cwd);}
4577896eece428602e2bcbbc54af85e158f60ad0b17e7883be36632914c52ab0
qualifiedURI
public URI qualifiedURI(String filename) throws IOException
{    try {        URI fileURI = new URI(filename);        if (RESOURCE_URI_SCHEME.equals(fileURI.getScheme())) {            return fileURI;        }    } catch (URISyntaxException ignore) {    }    return qualifiedPath(filename).toUri();}
1d8d3da78cf9c182f86e31ae238db87b18cd123cc078f1555a976c2203f5e043
open
public InputStream open(String filename) throws IOException
{    if (STDIN_AS_SOURCE.equals(filename)) {        return System.in;    }    URI uri = qualifiedURI(filename);    if (RESOURCE_URI_SCHEME.equals(uri.getScheme())) {        return Resources.getResource(uri.getRawSchemeSpecificPart()).openStream();    } else {        Path filePath = new Path(uri);                FileSystem fs = filePath.getFileSystem(getConf());        return fs.open(filePath);    }}
3222e5fe33ab751483676f2ae4fb5a834bff97117a8b40848795d1a1260f17bf
openSeekable
public SeekableInput openSeekable(String filename) throws IOException
{    Path path = qualifiedPath(filename);        FileSystem fs = path.getFileSystem(getConf());    return new SeekableFSDataInputStream(fs, path);}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    HadoopFileSystemURLStreamHandler.setDefaultConf(conf);}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{        return null != conf ? conf : new Configuration();}
eceff07b362e969b7bb608c23e6a68f9721100b2179a5b81a46531b4f97607dd
loaderFor
protected static ClassLoader loaderFor(List<String> jars, List<String> paths) throws MalformedURLException
{    return AccessController.doPrivileged(new GetClassLoader(urls(jars, paths)));}
4f7c1496fd53e721df2858dc8b7622ac6e83ad916cbc2c959f0a7c608cef7994
loaderForJars
protected static ClassLoader loaderForJars(List<String> jars) throws MalformedURLException
{    return AccessController.doPrivileged(new GetClassLoader(urls(jars, null)));}
e32ec5d9782d5e4e419fbc13dffb9d2af8a31b3fb0b0c428f64b96d2e06f0d0b
loaderForPaths
protected static ClassLoader loaderForPaths(List<String> paths) throws MalformedURLException
{    return AccessController.doPrivileged(new GetClassLoader(urls(null, paths)));}
27a580a973eb058422653ed6e36c9120224611faa2d6b1c378b888c0dbb4f372
urls
private static List<URL> urls(List<String> jars, List<String> dirs) throws MalformedURLException
{        final List<URL> urls = Lists.newArrayList();    if (dirs != null) {        for (String lib : dirs) {                        File path = lib.endsWith("/") ? new File(lib) : new File(lib + "/");            Preconditions.checkArgument(path.exists(), "Lib directory does not exist: " + lib);            Preconditions.checkArgument(path.isDirectory(), "Not a directory: " + lib);            Preconditions.checkArgument(path.canRead() && path.canExecute(), "Insufficient permissions to access lib directory: " + lib);            urls.add(path.toURI().toURL());        }    }    if (jars != null) {        for (String jar : jars) {            File path = new File(jar);            Preconditions.checkArgument(path.exists(), "Jar files does not exist: " + jar);            Preconditions.checkArgument(path.isFile(), "Not a file: " + jar);            Preconditions.checkArgument(path.canRead(), "Cannot read jar file: " + jar);            urls.add(path.toURI().toURL());        }    }    return urls;}
348b49f90cfe68e4ee602cae1777ea3553dde9f2cf8060094cf0c9cea49e5993
openDataFile
protected Iterable<D> openDataFile(final String source, Schema projection) throws IOException
{    Formats.Format format = Formats.detectFormat(open(source));    switch(format) {        case PARQUET:            Configuration conf = new Configuration(getConf());                        AvroReadSupport.setRequestedProjection(conf, projection);            AvroReadSupport.setAvroReadSchema(conf, projection);            final ParquetReader<D> parquet = AvroParquetReader.<D>builder(qualifiedPath(source)).disableCompatibility().withDataModel(GenericData.get()).withConf(conf).build();            return new Iterable<D>() {                @Override                public Iterator<D> iterator() {                    return new Iterator<D>() {                        private boolean hasNext = false;                        private D next = advance();                        @Override                        public boolean hasNext() {                            return hasNext;                        }                        @Override                        public D next() {                            if (!hasNext) {                                throw new NoSuchElementException();                            }                            D toReturn = next;                            this.next = advance();                            return toReturn;                        }                        private D advance() {                            try {                                D next = parquet.read();                                this.hasNext = (next != null);                                return next;                            } catch (IOException e) {                                throw new RuntimeException("Failed while reading Parquet file: " + source, e);                            }                        }                        @Override                        public void remove() {                            throw new UnsupportedOperationException("Remove is not supported");                        }                    };                }            };        case AVRO:            Iterable<D> avroReader = (Iterable<D>) DataFileReader.openReader(openSeekable(source), new GenericDatumReader<>(projection));            return avroReader;        default:            if (source.endsWith("json")) {                return new AvroJsonReader<>(open(source), projection);            } else {                Preconditions.checkArgument(projection == null, "Cannot select columns from text files");                Iterable text = CharStreams.readLines(new InputStreamReader(open(source)));                return text;            }    }}
a031f950dbcd28fec27c8f208752c6708e5dc1766a501104b5206d52cec12976
iterator
public Iterator<D> iterator()
{    return new Iterator<D>() {        private boolean hasNext = false;        private D next = advance();        @Override        public boolean hasNext() {            return hasNext;        }        @Override        public D next() {            if (!hasNext) {                throw new NoSuchElementException();            }            D toReturn = next;            this.next = advance();            return toReturn;        }        private D advance() {            try {                D next = parquet.read();                this.hasNext = (next != null);                return next;            } catch (IOException e) {                throw new RuntimeException("Failed while reading Parquet file: " + source, e);            }        }        @Override        public void remove() {            throw new UnsupportedOperationException("Remove is not supported");        }    };}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return hasNext;}
bcf3741d1e793bddf2847f47034bb3e589dc0cdc8a62c7d8a34bf22ea417a01e
next
public D next()
{    if (!hasNext) {        throw new NoSuchElementException();    }    D toReturn = next;    this.next = advance();    return toReturn;}
4b5c663577f303fa803d96ceaca389997d4d5eaa4f432e44240cce65c4985b69
advance
private D advance()
{    try {        D next = parquet.read();        this.hasNext = (next != null);        return next;    } catch (IOException e) {        throw new RuntimeException("Failed while reading Parquet file: " + source, e);    }}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException("Remove is not supported");}
be508407f26d26b74ac7aacb4ff6dbdcdf053821635863342bbdbfeec699c954
getAvroSchema
protected Schema getAvroSchema(String source) throws IOException
{    Formats.Format format;    try (SeekableInput in = openSeekable(source)) {        format = Formats.detectFormat((InputStream) in);        in.seek(0);        switch(format) {            case PARQUET:                return Schemas.fromParquet(getConf(), qualifiedURI(source));            case AVRO:                return Schemas.fromAvro(open(source));            case TEXT:                if (source.endsWith("avsc")) {                    return Schemas.fromAvsc(open(source));                } else if (source.endsWith("json")) {                    return Schemas.fromJSON("json", open(source));                }            default:        }        throw new IllegalArgumentException(String.format("Could not determine file format of %s.", source));    }}
314d5698f8c540a650afa0fda19512841433ccc3d5ccd34e4450b16d5270d240
run
public int run() throws IOException
{    Preconditions.checkArgument(sourceFiles != null && !sourceFiles.isEmpty(), "Missing file name");    Preconditions.checkArgument(sourceFiles.size() == 1, "Only one file can be given");    final String source = sourceFiles.get(0);    Schema schema = getAvroSchema(source);    Schema projection = Expressions.filterSchema(schema, columns);    Iterable<Object> reader = openDataFile(source, projection);    boolean threw = true;    long count = 0;    try {        for (Object record : reader) {            if (numRecords > 0 && count >= numRecords) {                break;            }            if (columns == null || columns.size() != 1) {                console.info(String.valueOf(record));            } else {                console.info(String.valueOf(select(projection, record, columns.get(0))));            }            count += 1;        }        threw = false;    } catch (RuntimeException e) {        throw new RuntimeException("Failed on record " + count, e);    } finally {        if (reader instanceof Closeable) {            Closeables.close((Closeable) reader, threw);        }    }    return 0;}
80fb381904a52fdf2805fc3fff55b849476f45caf8d596782956670073a7ab46
getExamples
public List<String> getExamples()
{    return Lists.newArrayList("# Show the first 10 records in file \"data.avro\":", "data.avro", "# Show the first 50 records in file \"data.parquet\":", "data.parquet -n 50");}
314d5698f8c540a650afa0fda19512841433ccc3d5ccd34e4450b16d5270d240
run
public int run() throws IOException
{    boolean badFiles = false;    for (String file : files) {        String problem = check(file);        if (problem != null) {            badFiles = true;            console.info("{} has corrupt stats: {}", file, problem);        } else {            console.info("{} has no corrupt stats", file);        }    }    return badFiles ? 1 : 0;}
090a9c14557bf493c3c98e258548c30c6c4492eb9a15b74e19e198e24cd38df8
check
private String check(String file) throws IOException
{    Path path = qualifiedPath(file);    ParquetMetadata footer = ParquetFileReader.readFooter(getConf(), path, ParquetMetadataConverter.NO_FILTER);    FileMetaData meta = footer.getFileMetaData();    String createdBy = meta.getCreatedBy();    if (CorruptStatistics.shouldIgnoreStatistics(createdBy, BINARY)) {                FileMetaData fakeMeta = new FileMetaData(meta.getSchema(), meta.getKeyValueMetaData(), Version.FULL_VERSION);                List<ColumnDescriptor> columns = Lists.newArrayList();        Iterables.addAll(columns, Iterables.filter(meta.getSchema().getColumns(), new Predicate<ColumnDescriptor>() {            @Override            public boolean apply(@Nullable ColumnDescriptor input) {                return input != null && input.getType() == BINARY;            }        }));                ParquetFileReader reader = new ParquetFileReader(getConf(), fakeMeta, path, footer.getBlocks(), columns);        try {            PageStatsValidator validator = new PageStatsValidator();            for (PageReadStore pages = reader.readNextRowGroup(); pages != null; pages = reader.readNextRowGroup()) {                validator.validate(columns, pages);            }        } catch (BadStatsException e) {            return e.getMessage();        }    }    return null;}
4b50cbb9a7d43a40dad64102b90a63bfb203a849f53d54f4e1711b7ff8b3b3b2
apply
public boolean apply(@Nullable ColumnDescriptor input)
{    return input != null && input.getType() == BINARY;}
80fb381904a52fdf2805fc3fff55b849476f45caf8d596782956670073a7ab46
getExamples
public List<String> getExamples()
{    return Arrays.asList("# Check file1.parquet for corrupt page and column stats", "file1.parquet");}
c912f40c38afde0ef75b8d08ab2c675551c383cef1763b349d2cf096213fb12d
readDictionaryPage
public DictionaryPage readDictionaryPage()
{    return dict;}
a44ab89ac1bd1c96a51dfa0d50dcc13fd7563de2e02c8e8f8722aff5468302dd
getTotalValueCount
public long getTotalValueCount()
{    return data.getValueCount();}
9cb4eeb0904f10d1d5e6bace639960ffa54293753cf81bf158838b756b0b9925
readPage
public DataPage readPage()
{    return data;}
49e577ceaea416b548c27c1959875188093b5c9b6728e72f40e9970cc16c65e5
getStatisticsFromPageHeader
private static Statistics<T> getStatisticsFromPageHeader(DataPage page)
{    return page.accept(new DataPage.Visitor<Statistics<T>>() {        @Override        @SuppressWarnings("unchecked")        public Statistics<T> visit(DataPageV1 dataPageV1) {            return (Statistics<T>) dataPageV1.getStatistics();        }        @Override        @SuppressWarnings("unchecked")        public Statistics<T> visit(DataPageV2 dataPageV2) {            return (Statistics<T>) dataPageV2.getStatistics();        }    });}
054c91d1112cbdc1a01b919993cabc9420694edc972f439893b181c4b083e943
visit
public Statistics<T> visit(DataPageV1 dataPageV1)
{    return (Statistics<T>) dataPageV1.getStatistics();}
5301e037091d435d1f1a8f9dfbcb4623bd0f3f55d04559b84f7a8816e424bb45
visit
public Statistics<T> visit(DataPageV2 dataPageV2)
{    return (Statistics<T>) dataPageV2.getStatistics();}
a79e32cfffb6c83314d317ebedaff33b9cbf2be1a00e9947fa87e54ecc2ea74f
validate
public void validate(T value)
{    if (hasNonNull) {        if (comparator.compare(min, value) > 0) {            throw new BadStatsException("Min should be <= all values.");        }        if (comparator.compare(max, value) < 0) {            throw new BadStatsException("Max should be >= all values.");        }    }}
db29998795e8ddd9640abd75241a4627d56dd34f3223087213084dd4b050ca44
getValidatingConverter
private PrimitiveConverter getValidatingConverter(final DataPage page, PrimitiveTypeName type)
{    return type.convert(new PrimitiveTypeNameConverter<PrimitiveConverter, RuntimeException>() {        @Override        public PrimitiveConverter convertFLOAT(PrimitiveTypeName primitiveTypeName) {            final StatsValidator<Float> validator = new StatsValidator<Float>(page);            return new PrimitiveConverter() {                @Override                public void addFloat(float value) {                    validator.validate(value);                }            };        }        @Override        public PrimitiveConverter convertDOUBLE(PrimitiveTypeName primitiveTypeName) {            final StatsValidator<Double> validator = new StatsValidator<Double>(page);            return new PrimitiveConverter() {                @Override                public void addDouble(double value) {                    validator.validate(value);                }            };        }        @Override        public PrimitiveConverter convertINT32(PrimitiveTypeName primitiveTypeName) {            final StatsValidator<Integer> validator = new StatsValidator<Integer>(page);            return new PrimitiveConverter() {                @Override                public void addInt(int value) {                    validator.validate(value);                }            };        }        @Override        public PrimitiveConverter convertINT64(PrimitiveTypeName primitiveTypeName) {            final StatsValidator<Long> validator = new StatsValidator<Long>(page);            return new PrimitiveConverter() {                @Override                public void addLong(long value) {                    validator.validate(value);                }            };        }        @Override        public PrimitiveConverter convertBOOLEAN(PrimitiveTypeName primitiveTypeName) {            final StatsValidator<Boolean> validator = new StatsValidator<Boolean>(page);            return new PrimitiveConverter() {                @Override                public void addBoolean(boolean value) {                    validator.validate(value);                }            };        }        @Override        public PrimitiveConverter convertINT96(PrimitiveTypeName primitiveTypeName) {            return convertBINARY(primitiveTypeName);        }        @Override        public PrimitiveConverter convertFIXED_LEN_BYTE_ARRAY(PrimitiveTypeName primitiveTypeName) {            return convertBINARY(primitiveTypeName);        }        @Override        public PrimitiveConverter convertBINARY(PrimitiveTypeName primitiveTypeName) {            final StatsValidator<Binary> validator = new StatsValidator<Binary>(page);            return new PrimitiveConverter() {                @Override                public void addBinary(Binary value) {                    validator.validate(value);                }            };        }    });}
226b5456fb2d26c1ce9e3c737dc056c251cf7e50cc558e85776cec6d2636ff54
convertFLOAT
public PrimitiveConverter convertFLOAT(PrimitiveTypeName primitiveTypeName)
{    final StatsValidator<Float> validator = new StatsValidator<Float>(page);    return new PrimitiveConverter() {        @Override        public void addFloat(float value) {            validator.validate(value);        }    };}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    validator.validate(value);}
4eab9f54472fb300242a626cb1bfa494c9507068630f657ec9d418f4aef1355e
convertDOUBLE
public PrimitiveConverter convertDOUBLE(PrimitiveTypeName primitiveTypeName)
{    final StatsValidator<Double> validator = new StatsValidator<Double>(page);    return new PrimitiveConverter() {        @Override        public void addDouble(double value) {            validator.validate(value);        }    };}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    validator.validate(value);}
5e7e6197a77ef8b0c204b55dd4cb247e34cda4628de1ee9e1ecf873bbcc97e71
convertINT32
public PrimitiveConverter convertINT32(PrimitiveTypeName primitiveTypeName)
{    final StatsValidator<Integer> validator = new StatsValidator<Integer>(page);    return new PrimitiveConverter() {        @Override        public void addInt(int value) {            validator.validate(value);        }    };}
a2ac1f40a6e220ec515710128c8baf77a725ad0b9f1767a998f776f27fff6cf6
addInt
public void addInt(int value)
{    validator.validate(value);}
d20b9b36dbc75e2020c3064708cbb0520f0f2b8c470e8db02accb4cbcb0005b6
convertINT64
public PrimitiveConverter convertINT64(PrimitiveTypeName primitiveTypeName)
{    final StatsValidator<Long> validator = new StatsValidator<Long>(page);    return new PrimitiveConverter() {        @Override        public void addLong(long value) {            validator.validate(value);        }    };}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    validator.validate(value);}
2ec17d66dfc871e660b0fb4c0b4cb0a849dc856b5c918fbe13d6ddc0d7bdadd5
convertBOOLEAN
public PrimitiveConverter convertBOOLEAN(PrimitiveTypeName primitiveTypeName)
{    final StatsValidator<Boolean> validator = new StatsValidator<Boolean>(page);    return new PrimitiveConverter() {        @Override        public void addBoolean(boolean value) {            validator.validate(value);        }    };}
23123f6657c241ab9b9f31f8efedc28a553ed91046d705121ce2667b065d6c17
addBoolean
public void addBoolean(boolean value)
{    validator.validate(value);}
df6cdccdcf78cbdcd55ae0927694bc70565035076282b875d4531e5afabf2f2d
convertINT96
public PrimitiveConverter convertINT96(PrimitiveTypeName primitiveTypeName)
{    return convertBINARY(primitiveTypeName);}
643456a237eb7fd4a33a2ab57acc0055d8a5dcfcd413abd3c0b4f67c298f93a7
convertFIXED_LEN_BYTE_ARRAY
public PrimitiveConverter convertFIXED_LEN_BYTE_ARRAY(PrimitiveTypeName primitiveTypeName)
{    return convertBINARY(primitiveTypeName);}
ef587a33a1e503d04d418eb33738423e02218e537b66d8d6415743f7d86ef048
convertBINARY
public PrimitiveConverter convertBINARY(PrimitiveTypeName primitiveTypeName)
{    final StatsValidator<Binary> validator = new StatsValidator<Binary>(page);    return new PrimitiveConverter() {        @Override        public void addBinary(Binary value) {            validator.validate(value);        }    };}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    validator.validate(value);}
692521e0f3d8258f3ff468b3186192430acca811f5d7c489fa4bbea6c1899758
validate
public void validate(List<ColumnDescriptor> columns, PageReadStore store)
{    for (ColumnDescriptor desc : columns) {        PageReader reader = store.getPageReader(desc);        DictionaryPage dict = reader.readDictionaryPage();        DictionaryPage reusableDict = null;        if (dict != null) {            try {                reusableDict = new DictionaryPage(BytesInput.from(dict.getBytes().toByteArray()), dict.getDictionarySize(), dict.getEncoding());            } catch (IOException e) {                throw new ParquetDecodingException("Cannot read dictionary", e);            }        }        DataPage page;        while ((page = reader.readPage()) != null) {            validateStatsForPage(page, reusableDict, desc);        }    }}
0546c5baa9c5f7f44c19259f20691c6eccc497729b9de1e055b16f61fc6a40ba
validateStatsForPage
private void validateStatsForPage(DataPage page, DictionaryPage dict, ColumnDescriptor desc)
{    SingletonPageReader reader = new SingletonPageReader(dict, page);    PrimitiveConverter converter = getValidatingConverter(page, desc.getType());    Statistics stats = getStatisticsFromPageHeader(page);    long numNulls = 0;    ColumnReader column = COL_READER_CTOR.newInstance(desc, reader, converter, null);    for (int i = 0; i < reader.getTotalValueCount(); i += 1) {        if (column.getCurrentDefinitionLevel() >= desc.getMaxDefinitionLevel()) {            column.writeCurrentValueToConverter();        } else {            numNulls += 1;        }        column.consume();    }    if (numNulls != stats.getNumNulls()) {        throw new BadStatsException("Number of nulls doesn't match.");    }    console.debug(String.format("Validated stats min=%s max=%s nulls=%d for page=%s col=%s", stats.minAsString(), stats.maxAsString(), stats.getNumNulls(), page, Arrays.toString(desc.getPath())));}
314d5698f8c540a650afa0fda19512841433ccc3d5ccd34e4450b16d5270d240
run
public int run() throws IOException
{    Preconditions.checkArgument(targets != null && targets.size() == 1, "A data file is required.");    String source = targets.get(0);    CompressionCodecName codec = Codecs.parquetCodec(compressionCodecName);    Schema schema;    if (avroSchemaFile != null) {        schema = Schemas.fromAvsc(open(avroSchemaFile));    } else {        schema = getAvroSchema(source);    }    Schema projection = filterSchema(schema, columns);    Path outPath = qualifiedPath(outputPath);    FileSystem outFS = outPath.getFileSystem(getConf());    if (overwrite && outFS.exists(outPath)) {        console.debug("Deleting output file {} (already exists)", outPath);        outFS.delete(outPath);    }    Iterable<Record> reader = openDataFile(source, projection);    boolean threw = true;    long count = 0;    try {        try (ParquetWriter<Record> writer = AvroParquetWriter.<Record>builder(qualifiedPath(outputPath)).withWriterVersion(v2 ? PARQUET_2_0 : PARQUET_1_0).withConf(getConf()).withCompressionCodec(codec).withRowGroupSize(rowGroupSize).withDictionaryPageSize(dictionaryPageSize < 64 ? 64 : dictionaryPageSize).withDictionaryEncoding(dictionaryPageSize != 0).withPageSize(pageSize).withDataModel(GenericData.get()).withSchema(projection).build()) {            for (Record record : reader) {                writer.write(record);                count += 1;            }        }        threw = false;    } catch (RuntimeException e) {        throw new RuntimeException("Failed on record " + count, e);    } finally {        if (reader instanceof Closeable) {            Closeables.close((Closeable) reader, threw);        }    }    return 0;}
80fb381904a52fdf2805fc3fff55b849476f45caf8d596782956670073a7ab46
getExamples
public List<String> getExamples()
{    return Lists.newArrayList("# Create a Parquet file from an Avro file", "sample.avro -o sample.parquet", "# Create a Parquet file in S3 from a local Avro file", "path/to/sample.avro -o s3:/user/me/sample.parquet", "# Create a Parquet file from Avro data in S3", "s3:/data/path/sample.avro -o sample.parquet");}
314d5698f8c540a650afa0fda19512841433ccc3d5ccd34e4450b16d5270d240
run
public int run() throws IOException
{    Preconditions.checkArgument(targets != null && targets.size() == 1, "CSV path is required.");    if (header != null) {                noHeader = true;    }    CSVProperties props = new CSVProperties.Builder().delimiter(delimiter).escape(escape).quote(quote).header(header).hasHeader(!noHeader).linesToSkip(linesToSkip).charset(charsetName).build();    String source = targets.get(0);    Schema csvSchema;    if (avroSchemaFile != null) {        csvSchema = Schemas.fromAvsc(open(avroSchemaFile));    } else {        Set<String> required = ImmutableSet.of();        if (requiredFields != null) {            required = ImmutableSet.copyOf(requiredFields);        }        String filename = new File(source).getName();        String recordName;        if (filename.contains(".")) {            recordName = filename.substring(0, filename.indexOf("."));        } else {            recordName = filename;        }        csvSchema = AvroCSV.inferNullableSchema(recordName, open(source), props, required);    }    long count = 0;    try (AvroCSVReader<Record> reader = new AvroCSVReader<>(open(source), props, csvSchema, Record.class, true)) {        CompressionCodecName codec = Codecs.parquetCodec(compressionCodecName);        try (ParquetWriter<Record> writer = AvroParquetWriter.<Record>builder(qualifiedPath(outputPath)).withWriterVersion(v2 ? PARQUET_2_0 : PARQUET_1_0).withWriteMode(overwrite ? ParquetFileWriter.Mode.OVERWRITE : ParquetFileWriter.Mode.CREATE).withCompressionCodec(codec).withDictionaryEncoding(true).withDictionaryPageSize(dictionaryPageSize).withPageSize(pageSize).withRowGroupSize(rowGroupSize).withDataModel(GenericData.get()).withConf(getConf()).withSchema(csvSchema).build()) {            for (Record record : reader) {                writer.write(record);            }        } catch (RuntimeException e) {            throw new RuntimeException("Failed on record " + count, e);        }    }    return 0;}
80fb381904a52fdf2805fc3fff55b849476f45caf8d596782956670073a7ab46
getExamples
public List<String> getExamples()
{    return Lists.newArrayList("# Create a Parquet file from a CSV file", "sample.csv sample.parquet --schema schema.avsc", "# Create a Parquet file in HDFS from local CSV", "path/to/sample.csv hdfs:/user/me/sample.parquet --schema schema.avsc", "# Create an Avro file from CSV data in S3", "s3:/data/path/sample.csv sample.avro --format avro --schema s3:/schemas/schema.avsc");}
314d5698f8c540a650afa0fda19512841433ccc3d5ccd34e4450b16d5270d240
run
public int run() throws IOException
{    Preconditions.checkArgument(samplePaths != null && !samplePaths.isEmpty(), "Sample CSV path is required");    Preconditions.checkArgument(samplePaths.size() == 1, "Only one CSV sample can be given");    if (header != null) {                noHeader = true;    }    CSVProperties props = new CSVProperties.Builder().delimiter(delimiter).escape(escape).quote(quote).header(header).hasHeader(!noHeader).linesToSkip(linesToSkip).charset(charsetName).build();    Set<String> required = ImmutableSet.of();    if (requiredFields != null) {        required = ImmutableSet.copyOf(requiredFields);    }        String sampleSchema = AvroCSV.inferNullableSchema(recordName, open(samplePaths.get(0)), props, required).toString(!minimize);    output(sampleSchema, console, outputPath);    return 0;}
80fb381904a52fdf2805fc3fff55b849476f45caf8d596782956670073a7ab46
getExamples
public List<String> getExamples()
{    return Lists.newArrayList("# Print the schema for samples.csv to standard out:", "samples.csv --record-name Sample", "# Write schema to sample.avsc:", "samples.csv -o sample.avsc --record-name Sample");}
314d5698f8c540a650afa0fda19512841433ccc3d5ccd34e4450b16d5270d240
run
public int run() throws IOException
{    Preconditions.checkArgument(targets != null && targets.size() >= 1, "A Parquet file is required.");    Preconditions.checkArgument(targets.size() == 1, "Cannot process multiple Parquet files.");    String source = targets.get(0);    ParquetMetadata footer = ParquetFileReader.readFooter(getConf(), qualifiedPath(source), ParquetMetadataConverter.NO_FILTER);    console.info("\nFile path:  {}", source);    console.info("Created by: {}", footer.getFileMetaData().getCreatedBy());    Map<String, String> kv = footer.getFileMetaData().getKeyValueMetaData();    if (kv != null && !kv.isEmpty()) {        console.info("Properties:");        String format = "  %" + maxSize(kv.keySet()) + "s: %s";        for (Map.Entry<String, String> entry : kv.entrySet()) {            console.info(String.format(format, entry.getKey(), entry.getValue()));        }    } else {        console.info("Properties: (none)");    }    MessageType schema = footer.getFileMetaData().getSchema();    console.info("Schema:\n{}", schema);    List<BlockMetaData> rowGroups = footer.getBlocks();    for (int index = 0, n = rowGroups.size(); index < n; index += 1) {        printRowGroup(console, index, rowGroups.get(index), schema);    }    console.info("");    return 0;}
80fb381904a52fdf2805fc3fff55b849476f45caf8d596782956670073a7ab46
getExamples
public List<String> getExamples()
{    return Lists.newArrayList();}
820b48958b6cea210d3cc1e021df0c5d4c3caf27b67cb4d472fefa93ec55161a
maxSize
private int maxSize(Iterable<String> strings)
{    int size = 0;    for (String s : strings) {        size = Math.max(size, s.length());    }    return size;}
a8f0aaf701accd2458b6d896087c4fab426f6aa08d73f14540774fbe647c933f
printRowGroup
private void printRowGroup(Logger console, int index, BlockMetaData rowGroup, MessageType schema)
{    long start = rowGroup.getStartingPos();    long rowCount = rowGroup.getRowCount();    long compressedSize = rowGroup.getCompressedSize();    long uncompressedSize = rowGroup.getTotalByteSize();    String filePath = rowGroup.getPath();    console.info(String.format("\nRow group %d:  count: %d  %s records  start: %d  total: %s%s\n%s", index, rowCount, humanReadable(((float) compressedSize) / rowCount), start, humanReadable(compressedSize), filePath != null ? " path: " + filePath : "", StringUtils.leftPad("", 80, '-')));    int size = maxSize(Iterables.transform(rowGroup.getColumns(), new Function<ColumnChunkMetaData, String>() {        @Override        public String apply(@Nullable ColumnChunkMetaData input) {            return input == null ? "" : input.getPath().toDotString();        }    }));    console.info(String.format("%-" + size + "s  %-9s %-9s %-9s %-10s %-7s %s", "", "type", "encodings", "count", "avg size", "nulls", "min / max"));    for (ColumnChunkMetaData column : rowGroup.getColumns()) {        printColumnChunk(console, size, column, schema);    }}
4f0bc124e32108b486f01f609e82242f26b22217f96be7bfa53912fa8372c2e9
apply
public String apply(@Nullable ColumnChunkMetaData input)
{    return input == null ? "" : input.getPath().toDotString();}
c938385f67d5eeb3a6c103d2941c6121d2702378b46eefc81e4f249870f1ca56
printColumnChunk
private void printColumnChunk(Logger console, int width, ColumnChunkMetaData column, MessageType schema)
{    String[] path = column.getPath().toArray();    PrimitiveType type = primitive(schema, path);    Preconditions.checkNotNull(type);    ColumnDescriptor desc = schema.getColumnDescription(path);    long size = column.getTotalSize();    long count = column.getValueCount();    float perValue = ((float) size) / count;    CompressionCodecName codec = column.getCodec();    Set<Encoding> encodings = column.getEncodings();    EncodingStats encodingStats = column.getEncodingStats();    String encodingSummary = encodingStats == null ? encodingsAsString(encodings, desc) : encodingStatsAsString(encodingStats);    Statistics stats = column.getStatistics();    String name = column.getPath().toDotString();    PrimitiveType.PrimitiveTypeName typeName = type.getPrimitiveTypeName();    if (typeName == PrimitiveType.PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY) {        console.info(String.format("%-" + width + "s  FIXED[%d] %s %-7s %-9d %-8s %-7s %s", name, type.getTypeLength(), shortCodec(codec), encodingSummary, count, humanReadable(perValue), stats == null || !stats.isNumNullsSet() ? "" : String.valueOf(stats.getNumNulls()), minMaxAsString(stats)));    } else {        console.info(String.format("%-" + width + "s  %-9s %s %-7s %-9d %-10s %-7s %s", name, typeName, shortCodec(codec), encodingSummary, count, humanReadable(perValue), stats == null || !stats.isNumNullsSet() ? "" : String.valueOf(stats.getNumNulls()), minMaxAsString(stats)));    }}
314d5698f8c540a650afa0fda19512841433ccc3d5ccd34e4450b16d5270d240
run
public int run() throws IOException
{    Preconditions.checkArgument(targets != null && targets.size() == 1, "Parquet file is required.");    if (targets.size() > 1) {        Preconditions.checkArgument(outputPath == null, "Cannot output multiple schemas to file " + outputPath);        for (String source : targets) {            console.info("{}: {}", source, getSchema(source));        }    } else {        String source = targets.get(0);        if (outputPath != null) {            Path outPath = qualifiedPath(outputPath);            FileSystem outFS = outPath.getFileSystem(getConf());            if (overwrite && outFS.exists(outPath)) {                console.debug("Deleting output file {} (already exists)", outPath);                outFS.delete(outPath);            }            try (OutputStream out = create(outputPath)) {                out.write(getSchema(source).getBytes(StandardCharsets.UTF_8));            }        } else {            console.info(getSchema(source));        }    }    return 0;}
80fb381904a52fdf2805fc3fff55b849476f45caf8d596782956670073a7ab46
getExamples
public List<String> getExamples()
{    return Lists.newArrayList("# Print the Avro schema for a Parquet file", "sample.parquet", "# Print the Avro schema for an Avro file", "sample.avro", "# Print the Avro schema for a JSON file", "sample.json");}
87b4d4b876194672a2e672a5db93f219bf63b837dc0aa442ba641c98f5ea2762
getSchema
private String getSchema(String source) throws IOException
{    if (parquetSchema) {        return getParquetSchema(source);    } else {        return getAvroSchema(source).toString(true);    }}
520e4446a0743bbaf287f9627231dec3e1fa118874e0484d48c3898f8e444e03
getParquetSchema
private String getParquetSchema(String source) throws IOException
{    Formats.Format format;    try (SeekableInput in = openSeekable(source)) {        format = Formats.detectFormat((InputStream) in);        in.seek(0);        switch(format) {            case PARQUET:                return new ParquetFileReader(getConf(), qualifiedPath(source), ParquetMetadataConverter.NO_FILTER).getFileMetaData().getSchema().toString();            default:                throw new IllegalArgumentException(String.format("Could not get a Parquet schema for format %s: %s", format, source));        }    }}
80fb381904a52fdf2805fc3fff55b849476f45caf8d596782956670073a7ab46
getExamples
public List<String> getExamples()
{    return Lists.newArrayList("# Show only column indexes for column 'col' from a Parquet file", "-c col -i sample.parquet");}
314d5698f8c540a650afa0fda19512841433ccc3d5ccd34e4450b16d5270d240
run
public int run() throws IOException
{    Preconditions.checkArgument(files != null && files.size() >= 1, "A Parquet file is required.");    Preconditions.checkArgument(files.size() == 1, "Cannot process multiple Parquet files.");    InputFile in = HadoopInputFile.fromPath(qualifiedPath(files.get(0)), getConf());    if (!showColumnIndex && !showOffsetIndex) {        showColumnIndex = true;        showOffsetIndex = true;    }    Set<String> rowGroupIndexSet = new HashSet<>();    if (rowGroupIndexes != null) {        rowGroupIndexSet.addAll(rowGroupIndexes);    }    try (ParquetFileReader reader = ParquetFileReader.open(in)) {        boolean firstBlock = true;        int rowGroupIndex = 0;        for (BlockMetaData block : reader.getFooter().getBlocks()) {            if (!rowGroupIndexSet.isEmpty() && !rowGroupIndexSet.contains(Integer.toString(rowGroupIndex))) {                ++rowGroupIndex;                continue;            }            if (!firstBlock) {                console.info("");            }            firstBlock = false;            console.info("row-group {}:", rowGroupIndex);            for (ColumnChunkMetaData column : getColumns(block)) {                String path = column.getPath().toDotString();                if (showColumnIndex) {                    console.info("column index for column {}:", path);                    ColumnIndex columnIndex = reader.readColumnIndex(column);                    if (columnIndex == null) {                        console.info("NONE");                    } else {                        console.info(columnIndex.toString());                    }                }                if (showOffsetIndex) {                    console.info("offset index for column {}:", path);                    OffsetIndex offsetIndex = reader.readOffsetIndex(column);                    if (offsetIndex == null) {                        console.info("NONE");                    } else {                        console.info(offsetIndex.toString());                    }                }            }            ++rowGroupIndex;        }    }    return 0;}
f6c2e888dd6ed3a7994b583dde4d5e10edaf44301fd3f3d8fe41ffdca005fafc
getColumns
private List<ColumnChunkMetaData> getColumns(BlockMetaData block)
{    List<ColumnChunkMetaData> columns = block.getColumns();    if (ColumnPaths == null || ColumnPaths.isEmpty()) {        return columns;    }    Map<String, ColumnChunkMetaData> pathMap = new HashMap<>();    for (ColumnChunkMetaData column : columns) {        pathMap.put(column.getPath().toDotString(), column);    }    List<ColumnChunkMetaData> filtered = new ArrayList<>();    for (String path : ColumnPaths) {        ColumnChunkMetaData column = pathMap.get(path);        if (column != null) {            filtered.add(column);        }    }    return filtered;}
314d5698f8c540a650afa0fda19512841433ccc3d5ccd34e4450b16d5270d240
run
public int run() throws IOException
{    Preconditions.checkArgument(targets != null && targets.size() >= 1, "A Parquet file is required.");    Preconditions.checkArgument(targets.size() == 1, "Cannot process multiple Parquet files.");    String source = targets.get(0);    ParquetFileReader reader = ParquetFileReader.open(getConf(), qualifiedPath(source));    MessageType schema = reader.getFileMetaData().getSchema();    ColumnDescriptor descriptor = Util.descriptor(column, schema);    PrimitiveType type = Util.primitive(column, schema);    Preconditions.checkNotNull(type);    DictionaryPageReadStore dictionaryReader;    int rowGroup = 0;    while ((dictionaryReader = reader.getNextDictionaryReader()) != null) {        DictionaryPage page = dictionaryReader.readDictionaryPage(descriptor);        Dictionary dict = page.getEncoding().initDictionary(descriptor, page);        console.info("\nRow group {} dictionary for \"{}\":", rowGroup, column, page.getCompressedSize());        for (int i = 0; i <= dict.getMaxId(); i += 1) {            switch(type.getPrimitiveTypeName()) {                case BINARY:                    if (type.getLogicalTypeAnnotation() instanceof LogicalTypeAnnotation.StringLogicalTypeAnnotation) {                        console.info("{}: {}", String.format("%6d", i), Util.humanReadable(dict.decodeToBinary(i).toStringUsingUTF8(), 70));                    } else {                        console.info("{}: {}", String.format("%6d", i), Util.humanReadable(dict.decodeToBinary(i).getBytesUnsafe(), 70));                    }                    break;                case INT32:                    console.info("{}: {}", String.format("%6d", i), dict.decodeToInt(i));                    break;                case INT64:                    console.info("{}: {}", String.format("%6d", i), dict.decodeToLong(i));                    break;                case FLOAT:                    console.info("{}: {}", String.format("%6d", i), dict.decodeToFloat(i));                    break;                case DOUBLE:                    console.info("{}: {}", String.format("%6d", i), dict.decodeToDouble(i));                    break;                default:                    throw new IllegalArgumentException("Unknown dictionary type: " + type.getPrimitiveTypeName());            }        }        reader.skipNextRowGroup();        rowGroup += 1;    }    console.info("");    return 0;}
80fb381904a52fdf2805fc3fff55b849476f45caf8d596782956670073a7ab46
getExamples
public List<String> getExamples()
{    return Lists.newArrayList("# Show the dictionary for column 'col' from a Parquet file", "-c col sample.parquet");}
314d5698f8c540a650afa0fda19512841433ccc3d5ccd34e4450b16d5270d240
run
public int run() throws IOException
{    Preconditions.checkArgument(targets != null && targets.size() >= 1, "A Parquet file is required.");    Preconditions.checkArgument(targets.size() == 1, "Cannot process multiple Parquet files.");    String source = targets.get(0);    ParquetFileReader reader = ParquetFileReader.open(getConf(), qualifiedPath(source));    MessageType schema = reader.getFileMetaData().getSchema();    Map<ColumnDescriptor, PrimitiveType> columns = Maps.newLinkedHashMap();    if (this.columns == null || this.columns.isEmpty()) {        for (ColumnDescriptor descriptor : schema.getColumns()) {            columns.put(descriptor, primitive(schema, descriptor.getPath()));        }    } else {        for (String column : this.columns) {            columns.put(descriptor(column, schema), primitive(column, schema));        }    }    CompressionCodecName codec = reader.getRowGroups().get(0).getColumns().get(0).getCodec();        Map<String, List<String>> formatted = Maps.newLinkedHashMap();    PageFormatter formatter = new PageFormatter();    PageReadStore pageStore;    int rowGroupNum = 0;    while ((pageStore = reader.readNextRowGroup()) != null) {        for (ColumnDescriptor descriptor : columns.keySet()) {            List<String> lines = formatted.get(columnName(descriptor));            if (lines == null) {                lines = Lists.newArrayList();                formatted.put(columnName(descriptor), lines);            }            formatter.setContext(rowGroupNum, columns.get(descriptor), codec);            PageReader pages = pageStore.getPageReader(descriptor);            DictionaryPage dict = pages.readDictionaryPage();            if (dict != null) {                lines.add(formatter.format(dict));            }            DataPage page;            while ((page = pages.readPage()) != null) {                lines.add(formatter.format(page));            }        }        rowGroupNum += 1;    }        for (String columnName : formatted.keySet()) {        console.info(String.format("\nColumn: %s\n%s", columnName, StringUtils.leftPad("", 80, '-')));        console.info(formatter.getHeader());        for (String line : formatted.get(columnName)) {            console.info(line);        }        console.info("");    }    return 0;}
80fb381904a52fdf2805fc3fff55b849476f45caf8d596782956670073a7ab46
getExamples
public List<String> getExamples()
{    return Lists.newArrayList("# Show pages for column 'col' from a Parquet file", "-c col sample.parquet");}
226a727ff17c23315745d10e83c77707725d059b1b0a386478a60676b2676b09
getHeader
 String getHeader()
{    return String.format("  %-6s %-5s %-4s %-7s %-10s %-10s %-8s %-7s %s", "page", "type", "enc", "count", "avg size", "size", "rows", "nulls", "min / max");}
511953d6a4e091086ca1a8b2352b13c9a4941024b69d5d56eb6e64fd8ed29790
setContext
 void setContext(int rowGroupNum, PrimitiveType type, CompressionCodecName codec)
{    this.rowGroupNum = rowGroupNum;    this.pageNum = 0;    this.type = type;    this.shortCodec = shortCodec(codec);}
dfb0d30c88c022a8ee56d43894e50a2a3dcdf6c3e82bb86b78779b2f58fc907f
format
 String format(Page page)
{    String formatted = "";    if (page instanceof DictionaryPage) {        formatted = printDictionaryPage((DictionaryPage) page);    } else if (page instanceof DataPage) {        formatted = ((DataPage) page).accept(this);    }    pageNum += 1;    return formatted;}
addfc26c348234717610e70c2ee344ef59b1e8d79f3e9036c26f9216da7a55ac
printDictionaryPage
private String printDictionaryPage(DictionaryPage dict)
{        dict.getUncompressedSize();    long totalSize = dict.getCompressedSize();    int count = dict.getDictionarySize();    float perValue = ((float) totalSize) / count;    String enc = encodingAsString(dict.getEncoding(), true);    if (pageNum == 0) {        return String.format("%3d-D    %-5s %s %-2s %-7d %-10s %-10s", rowGroupNum, "dict", shortCodec, enc, count, humanReadable(perValue), humanReadable(totalSize));    } else {        return String.format("%3d-%-3d  %-5s %s %-2s %-7d %-10s %-10s", rowGroupNum, pageNum, "dict", shortCodec, enc, count, humanReadable(perValue), humanReadable(totalSize));    }}
f56fcc1fb40c610e088560101383b67a913968ae5f8f6d9406edd3bc7b8d4e8a
visit
public String visit(DataPageV1 page)
{    String enc = encodingAsString(page.getValueEncoding(), false);    long totalSize = page.getCompressedSize();    int count = page.getValueCount();    String numNulls = page.getStatistics().isNumNullsSet() ? Long.toString(page.getStatistics().getNumNulls()) : "";    float perValue = ((float) totalSize) / count;    String minMax = minMaxAsString(page.getStatistics());    return String.format("%3d-%-3d  %-5s %s %-2s %-7d %-10s %-10s %-8s %-7s %s", rowGroupNum, pageNum, "data", shortCodec, enc, count, humanReadable(perValue), humanReadable(totalSize), "", numNulls, minMax);}
ae28ce53aff80e632fc0e3332527d4db6533231031953167466a7d4b2015231c
visit
public String visit(DataPageV2 page)
{    String enc = encodingAsString(page.getDataEncoding(), false);    long totalSize = page.getCompressedSize();    int count = page.getValueCount();    int numRows = page.getRowCount();    int numNulls = page.getNullCount();    float perValue = ((float) totalSize) / count;    String minMax = minMaxAsString(page.getStatistics());    String compression = (page.isCompressed() ? shortCodec : "_");    return String.format("%3d-%-3d  %-5s %s %-2s %-7d %-10s %-10s %-8d %-7s %s", rowGroupNum, pageNum, "data", compression, enc, count, humanReadable(perValue), humanReadable(totalSize), numRows, numNulls, minMax);}
314d5698f8c540a650afa0fda19512841433ccc3d5ccd34e4450b16d5270d240
run
public int run() throws IOException
{    Preconditions.checkArgument(targets != null && targets.size() == 1, "A data file is required.");    String source = targets.get(0);    CodecFactory codecFactory = Codecs.avroCodec(compressionCodecName);    final Schema schema;    if (avroSchemaFile != null) {        schema = Schemas.fromAvsc(open(avroSchemaFile));    } else {        schema = getAvroSchema(source);    }    final Schema projection = filterSchema(schema, columns);    Path outPath = qualifiedPath(outputPath);    try (FileSystem outFS = outPath.getFileSystem(getConf())) {        if (overwrite && outFS.exists(outPath)) {            console.debug("Deleting output file {} (already exists)", outPath);            outFS.delete(outPath);        }    }    Iterable<Record> reader = openDataFile(source, projection);    boolean threw = true;    long count = 0;    DatumWriter<Record> datumWriter = new GenericDatumWriter<>(schema);    try (DataFileWriter<Record> fileWriter = new DataFileWriter<>(datumWriter)) {        fileWriter.setCodec(codecFactory);        try (DataFileWriter<Record> writer = fileWriter.create(projection, create(outputPath))) {            for (Record record : reader) {                writer.append(record);                count += 1;            }        }        threw = false;    } catch (RuntimeException e) {        throw new RuntimeException("Failed on record " + count, e);    } finally {        if (reader instanceof Closeable) {            Closeables.close((Closeable) reader, threw);        }    }    return 0;}
80fb381904a52fdf2805fc3fff55b849476f45caf8d596782956670073a7ab46
getExamples
public List<String> getExamples()
{    return Lists.newArrayList("# Create an Avro file from a Parquet file", "sample.parquet sample.avro", "# Create an Avro file in HDFS from a local JSON file", "path/to/sample.json hdfs:/user/me/sample.parquet", "# Create an Avro file from data in S3", "s3:/data/path/sample.parquet sample.avro");}
4ca89c9b50c0d1f3db7a2a7c70a173a148ea3c07941fbb6dd851fa239442efcf
newReader
 static CSVReader newReader(InputStream incoming, CSVProperties props)
{    return new CSVReader(new InputStreamReader(incoming, Charset.forName(props.charset)), props.delimiter.charAt(0), props.quote.charAt(0), props.escape.charAt(0), props.linesToSkip, false, /* strict quotes off: don't ignore unquoted strings */    true);}
a78d7eebbc92fef62af9b3fed1152e709ef04e278650c73847624a12c391c9f6
newParser
 static CSVParser newParser(CSVProperties props)
{    return new CSVParser(props.delimiter.charAt(0), props.quote.charAt(0), props.escape.charAt(0), false, /* strict quotes off: don't ignore unquoted strings */    true);}
abccee64d873fdf425fc494ca59847e8d9305e400d425f8d0235285bc5a20fd4
inferNullableSchema
public static Schema inferNullableSchema(String name, InputStream incoming, CSVProperties props) throws IOException
{    return inferSchemaInternal(name, incoming, props, NO_REQUIRED_FIELDS, true);}
9a80552bcd2f8997926e62bd89b219b0af3e86ac3d9bb4dcb2d9197d176befbd
inferNullableSchema
public static Schema inferNullableSchema(String name, InputStream incoming, CSVProperties props, Set<String> requiredFields) throws IOException
{    return inferSchemaInternal(name, incoming, props, requiredFields, true);}
e091a611bf525a4354fbdf75226115874cf13af830fee6abb4e4f7b34f46b9c3
inferSchema
public static Schema inferSchema(String name, InputStream incoming, CSVProperties props) throws IOException
{    return inferSchemaInternal(name, incoming, props, NO_REQUIRED_FIELDS, false);}
412e3137a9b26b8261216f24ff93c308f5fa8baa5107da443c8cfdce62c5ed79
inferSchema
public static Schema inferSchema(String name, InputStream incoming, CSVProperties props, Set<String> requiredFields) throws IOException
{    return inferSchemaInternal(name, incoming, props, requiredFields, false);}
f2502abd2ed99048a88e7380a92e0297fef130477e35d01cb89ffb3f25398dcb
inferSchemaInternal
private static Schema inferSchemaInternal(String name, InputStream incoming, CSVProperties props, Set<String> requiredFields, boolean makeNullable) throws IOException
{    CSVReader reader = newReader(incoming, props);    String[] header;    String[] line;    if (props.useHeader) {                header = reader.readNext();        line = reader.readNext();        Preconditions.checkNotNull(line, "No content to infer schema");    } else if (props.header != null) {        header = newParser(props).parseLine(props.header);        line = reader.readNext();        Preconditions.checkNotNull(line, "No content to infer schema");    } else {                line = reader.readNext();        Preconditions.checkNotNull(line, "No content to infer schema");        header = new String[line.length];        for (int i = 0; i < line.length; i += 1) {            header[i] = "field_" + String.valueOf(i);        }    }    Schema.Type[] types = new Schema.Type[header.length];    String[] values = new String[header.length];    boolean[] nullable = new boolean[header.length];    boolean[] empty = new boolean[header.length];    for (int processed = 0; processed < DEFAULT_INFER_LINES; processed += 1) {        if (line == null) {            break;        }        for (int i = 0; i < header.length; i += 1) {            if (i < line.length) {                if (types[i] == null) {                    types[i] = inferFieldType(line[i]);                    if (types[i] != null) {                                                values[i] = line[i];                    }                }                if (line[i] == null) {                    nullable[i] = true;                } else if (line[i].isEmpty()) {                    empty[i] = true;                }            } else {                                nullable[i] = true;            }        }        line = reader.readNext();    }    SchemaBuilder.FieldAssembler<Schema> fieldAssembler = SchemaBuilder.record(name).fields();        for (int i = 0; i < header.length; i += 1) {        if (header[i] == null) {            throw new RuntimeException("Bad header for field " + i + ": null");        }        String fieldName = header[i].trim();        if (fieldName.isEmpty()) {            throw new RuntimeException("Bad header for field " + i + ": \"" + fieldName + "\"");        } else if (!isAvroCompatibleName(fieldName)) {            throw new RuntimeException("Bad header for field, should start with a character " + "or _ and can contain only alphanumerics and _ " + i + ": \"" + fieldName + "\"");        }                boolean foundNull = (nullable[i] || (empty[i] && types[i] != Schema.Type.STRING));        if (requiredFields.contains(fieldName)) {            if (foundNull) {                throw new RuntimeException("Found null value for required field: " + fieldName + " (" + types[i] + ")");            }            fieldAssembler = fieldAssembler.name(fieldName).doc("Type inferred from '" + sample(values[i]) + "'").type(schema(types[i], false)).noDefault();        } else {            SchemaBuilder.GenericDefault<Schema> defaultBuilder = fieldAssembler.name(fieldName).doc("Type inferred from '" + sample(values[i]) + "'").type(schema(types[i], makeNullable || foundNull));            if (makeNullable || foundNull) {                fieldAssembler = defaultBuilder.withDefault(null);            } else {                fieldAssembler = defaultBuilder.noDefault();            }        }    }    return fieldAssembler.endRecord();}
1c4915a024865904e7433d9133fd84fd1ecc1c9bd2bbcde04f18e1e83f81fb38
sample
private static String sample(String value)
{    if (value != null) {        return NON_PRINTABLE.replaceFrom(value.subSequence(0, min(50, value.length())), '.');    } else {        return "null";    }}
e60cf2b1df6023f37961fae3cf6ce9fbb8a12b42e262695372361c0cca6226b7
schema
private static Schema schema(Schema.Type type, boolean makeNullable)
{    Schema schema = Schema.create(type == null ? Schema.Type.STRING : type);    if (makeNullable || type == null) {        schema = Schema.createUnion(Lists.newArrayList(Schema.create(Schema.Type.NULL), schema));    }    return schema;}
fafda12526338c71796e611842aa204e91b7e25e4b12d823b000e4f5b0a427fc
inferFieldType
private static Schema.Type inferFieldType(String example)
{    if (example == null || example.isEmpty()) {                return null;    } else if (LONG.matcher(example).matches()) {        return Schema.Type.LONG;    } else if (DOUBLE.matcher(example).matches()) {        return Schema.Type.DOUBLE;    } else if (FLOAT.matcher(example).matches()) {        return Schema.Type.FLOAT;    }    return Schema.Type.STRING;}
77f30dd743f959ad4629bc7889ddaf6bb706c2d00bfa90bad5d6cc5645e1f355
isAvroCompatibleName
private static boolean isAvroCompatibleName(String name)
{    return AVRO_COMPATIBLE.matcher(name).matches();}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return hasNext;}
c8bdca1c159be1f114d59823385a107cb1e1393427235435e4cb9dd743d2eaa5
next
public E next()
{    if (!hasNext) {        throw new NoSuchElementException();    }    try {        if (reuseRecords) {            this.record = builder.makeRecord(next, record);            return record;        } else {            return builder.makeRecord(next, null);        }    } finally {        this.hasNext = advance();    }}
7cb65707512c43725866183e0b202572dd8fce17ab787a8c978ea2de07a067fd
advance
private boolean advance()
{    try {        next = reader.readNext();    } catch (IOException ex) {        throw new RuntimeIOException("Could not read record", ex);    }    return (next != null);}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    try {        reader.close();    } catch (IOException e) {        throw new RuntimeIOException("Cannot close reader", e);    }}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException("Remove is not implemented.");}
5075bfc98a062ea4b29a732dae0454346475177e17c872d8ce3f9b992ea93a8c
iterator
public Iterator<E> iterator()
{    return this;}
f747de21e043b03baa316b75238f44990647d73dee27d23dbcb9929ba5f432ef
charset
public Builder charset(String charset)
{    this.charset = charset;    return this;}
fd68e44fdba87582341f310833998cec8bc6615d075a05dc86bb7630dcc7e30d
delimiter
public Builder delimiter(String delimiter)
{    this.delimiter = StringEscapeUtils.unescapeJava(delimiter);    return this;}
b72affd8162cc23cb36033149de01d434338206458b68220ee4981fb47696a5a
quote
public Builder quote(String quote)
{    this.quote = StringEscapeUtils.unescapeJava(quote);    return this;}
15c9cdebc00dbdd0e071bcab7c0a2e6a0670433d7ea03ad1754ea7c2d686aae5
escape
public Builder escape(String escape)
{    this.escape = StringEscapeUtils.unescapeJava(escape);    return this;}
8b07119e18ff7400ac053b6bdf1404e4e0505dcb5a62c0e498b0dd20295d95d6
header
public Builder header(String header)
{    this.header = header;    return this;}
1019f13a6a5ea6a0183c24f03645a78e183cfdcf627d858ed5600b9f7fa85c61
hasHeader
public Builder hasHeader()
{    this.useHeader = true;    return this;}
0965cb7a337a3d1940b73ca935660ebf7c0ec20d663de8ff646f12fb2c7fea42
hasHeader
public Builder hasHeader(boolean hasHeader)
{    this.useHeader = hasHeader;    return this;}
1bc138806f9b107d2c7012ab420a26321ea90bb36c46452cc27342219e26f8dc
linesToSkip
public Builder linesToSkip(int linesToSkip)
{    this.linesToSkip = linesToSkip;    return this;}
34cd280eae00aa3ec3c6703ace752ff07bde5a337c0c4500973012c4d790db6c
build
public CSVProperties build()
{    return new CSVProperties(charset, delimiter, quote, escape, header, useHeader, linesToSkip);}
904549ec7e9b6e83672c91c31458973bcec3d4942b2c21a1804e5257d4ce0abf
makeRecord
public E makeRecord(String[] fields, E reuse)
{    E record = reuse;    if (record == null) {        record = newRecordInstance();    }    if (record instanceof IndexedRecord) {        fillIndexed((IndexedRecord) record, fields);    } else {        fillReflect(record, fields);    }    return record;}
887d759af4c78ec6ec8e7c4dc03f4ec4c496b36062f542d565d7a72142c0d671
newRecordInstance
private E newRecordInstance()
{    if (recordClass != GenericData.Record.class && !recordClass.isInterface()) {        E record = (E) ReflectData.newInstance(recordClass, schema);        if (record != null) {            return record;        }    }    return (E) new GenericData.Record(schema);}
d51aa0934769ea3c02849b5ac78ba5ab1750823bb885740be009eb0c6b96dfca
fillIndexed
private void fillIndexed(IndexedRecord record, String[] data)
{    for (int i = 0; i < indexes.length; i += 1) {        int index = indexes[i];        record.put(i, makeValue(index < data.length ? data[index] : null, fields[i]));    }}
d9eff84d015a0646d65652bcb4070ded595c1a20f03d9a4f1e5ffe63690b7b75
fillReflect
private void fillReflect(Object record, String[] data)
{    for (int i = 0; i < indexes.length; i += 1) {        Schema.Field field = fields[i];        int index = indexes[i];        Object value = makeValue(index < data.length ? data[index] : null, field);        ReflectData.get().setField(record, field.name(), i, value);    }}
4ed9af1e1851f952cf1227e851c2dd25725237691178cbe62eb9b767e25dbce9
makeValue
private static Object makeValue(String string, Schema.Field field)
{    try {        Object value = makeValue(string, field.schema());        if (value != null || Schemas.nullOk(field.schema())) {            return value;        } else {                        return ReflectData.get().getDefaultValue(field);        }    } catch (RecordException e) {                throw new RecordException(String.format("Cannot convert field %s", field.name()), e);    } catch (NumberFormatException e) {        throw new RecordException(String.format("Field %s: value not a %s: '%s'", field.name(), field.schema(), string), e);    } catch (AvroRuntimeException e) {        throw new RecordException(String.format("Field %s: cannot make %s value: '%s'", field.name(), field.schema(), string), e);    }}
cc670442ee975475e1a02a1ba554790d7b916f4a4959e2ac5d7ce0f49f042347
makeValue
private static Object makeValue(String string, Schema schema)
{    if (string == null) {        return null;    }    try {        switch(schema.getType()) {            case BOOLEAN:                return Boolean.valueOf(string);            case STRING:                return string;            case FLOAT:                return Float.valueOf(string);            case DOUBLE:                return Double.valueOf(string);            case INT:                return Integer.valueOf(string);            case LONG:                return Long.valueOf(string);            case ENUM:                                if (schema.hasEnumSymbol(string)) {                    return string;                } else {                    try {                        return schema.getEnumSymbols().get(Integer.parseInt(string));                    } catch (IndexOutOfBoundsException ex) {                        return null;                    }                }            case UNION:                Object value = null;                for (Schema possible : schema.getTypes()) {                    value = makeValue(string, possible);                    if (value != null) {                        return value;                    }                }                return null;            case NULL:                return null;            default:                                throw new RecordException("Unsupported field type:" + schema.getType());        }    } catch (NumberFormatException e) {                if (string.isEmpty()) {            return null;        } else {            throw e;        }    }}
3e04ddf3c51bd7dc600d3b5d0debfc4957d439b32ba31e048134e3622727bc91
getDefaultConf
public static Configuration getDefaultConf()
{    return defaultConf;}
728540d8d63c31986aa5823477bd7eef93a9e89074c413be0b5edca18147ea64
setDefaultConf
public static void setDefaultConf(Configuration defaultConf)
{    HadoopFileSystemURLStreamHandler.defaultConf = defaultConf;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
6f6120b679cdd5200c569adb28f2f435c05ba9cdf1d77e07fabdf869b023f73c
openConnection
protected URLConnection openConnection(URL url) throws IOException
{    return new HadoopFileSystemURLConnection(url);}
74814c7b2c03c956c95c5e6cc772d4c0dfe2966894d73f00b0453545facde013
connect
public void connect() throws IOException
{}
1bb9d826482de87041e929f03d6073d7bca36bd7359f7658f22d33e1af426037
getInputStream
public InputStream getInputStream() throws IOException
{    Path path = new Path(url.toExternalForm());    FileSystem fileSystem = path.getFileSystem(conf);    return fileSystem.open(path);}
4f7879f328cf0a4a4c88d5eee194afa33e45af69525e65dbbd973e94170db2d3
setProgramName
public void setProgramName(String programName)
{    this.programName = programName;}
e80ec46cf536226a34c97a4d3f4f9f3922432bdc4a804428a029269ec7069d0c
run
public int run()
{    if (helpCommands.isEmpty()) {        printGenericHelp();    } else {        for (String cmd : helpCommands) {            JCommander commander = jc.getCommands().get(cmd);            if (commander == null) {                console.error("\nUnknown command: {}\n", cmd);                printGenericHelp();                return 1;            }            boolean hasRequired = false;            console.info("\nUsage: {} [general options] {} {} [command options]", new Object[] { programName, cmd, commander.getMainParameterDescription() });            console.info("\n  Description:");            console.info("\n    {}", jc.getCommandDescription(cmd));            if (!commander.getParameters().isEmpty()) {                console.info("\n  Command options:\n");                for (ParameterDescription param : commander.getParameters()) {                    hasRequired = printOption(console, param) || hasRequired;                }                if (hasRequired) {                    console.info("\n  * = required");                }            }            List<String> examples = ((Command) commander.getObjects().get(0)).getExamples();            if (examples != null) {                console.info("\n  Examples:");                for (String example : examples) {                    if (example.startsWith("#")) {                                                console.info("\n    {}", example);                    } else {                        console.info("    {} {} {}", new Object[] { programName, cmd, example });                    }                }            }                        console.info("");        }    }    return 0;}
46a53807137cf4d48211abba68a3c9c73c3c3584917d71ba4912eaa392c05ea4
printGenericHelp
public void printGenericHelp()
{    boolean hasRequired = false;    console.info("\nUsage: {} [options] [command] [command options]", programName);    console.info("\n  Options:\n");    for (ParameterDescription param : jc.getParameters()) {        hasRequired = printOption(console, param) || hasRequired;    }    if (hasRequired) {        console.info("\n  * = required");    }    console.info("\n  Commands:\n");    for (String command : jc.getCommands().keySet()) {        console.info("    {}\n\t{}", command, jc.getCommandDescription(command));    }    console.info("\n  Examples:");    console.info("\n    # print information for create\n    {} help create", programName);    console.info("\n  See '{} help <command>' for more information on a " + "specific command.", programName);}
f0da60ff347dfebbef6405688bbd2478d73aad106b8ad8164d7a67d18225113b
printOption
private boolean printOption(Logger console, ParameterDescription param)
{    boolean required = param.getParameter().required();    if (!param.getParameter().hidden()) {        console.info("  {} {}\n\t{}{}", new Object[] { required ? "*" : " ", param.getNames().trim(), param.getDescription(), formatDefault(param) });    }    return required;}
1bab05bad324dfbac0ed97d2b3064af218c0e5269ac4e740aa5f7e327bee751b
formatDefault
private String formatDefault(ParameterDescription param)
{    Object defaultValue = param.getDefault();    if (defaultValue == null || param.getParameter().arity() < 1) {        return "";    }    return " (default: " + ((defaultValue instanceof String) ? "\"" + defaultValue + "\"" : defaultValue.toString()) + ")";}
80fb381904a52fdf2805fc3fff55b849476f45caf8d596782956670073a7ab46
getExamples
public List<String> getExamples()
{    return null;}
95d1b0cb01b34f118663bd3e45a6d2ed80ba63c386518f470a2e53072bd630ec
parser
public static Iterator<JsonNode> parser(final InputStream stream)
{    try {                JsonParser parser = FACTORY.createParser(stream);        return parser.readValuesAs(JsonNode.class);    } catch (IOException e) {        throw new RuntimeIOException("Cannot read from stream", e);    }}
2b3b7fd42e2260087718cf1b56ce0d74f534f458ace09b00d5218bfe98b7cb4d
parse
public static JsonNode parse(String json)
{    return parse(json, JsonNode.class);}
d63c24f72348952d664da5ce4aedff91ac797caad7df6e0b9f319d96b457aee6
parse
public static T parse(String json, Class<T> returnType)
{    try {        return MAPPER.readValue(json, returnType);    } catch (JsonParseException e) {        throw new IllegalArgumentException("Invalid JSON", e);    } catch (JsonMappingException e) {        throw new IllegalArgumentException("Invalid JSON", e);    } catch (IOException e) {        throw new RuntimeIOException("Cannot initialize JSON parser", e);    }}
d9315478e4b4e304fd49aad9f5a0560db367e78479b523e30d9d9f8414d8da42
parse
public static JsonNode parse(InputStream json)
{    return parse(json, JsonNode.class);}
b6a3f6d81563e21b84f11f9d15c789c877e83f7a3f238f1c27a0127558240a48
parse
public static T parse(InputStream json, Class<T> returnType)
{    try {        return MAPPER.readValue(json, returnType);    } catch (JsonParseException e) {        throw new IllegalArgumentException("Invalid JSON stream", e);    } catch (JsonMappingException e) {        throw new IllegalArgumentException("Invalid JSON stream", e);    } catch (IOException e) {        throw new RuntimeIOException("Cannot initialize JSON parser", e);    }}
1a082fd7a76ad1a4c151700352e80b42c7b93ccac5d635cb8174e1e89ab8ac36
convertToAvro
public static Object convertToAvro(GenericData model, JsonNode datum, Schema schema)
{    if (datum == null) {        return null;    }    switch(schema.getType()) {        case RECORD:            RecordException.check(datum.isObject(), "Cannot convert non-object to record: %s", datum);            Object record = model.newRecord(null, schema);            for (Schema.Field field : schema.getFields()) {                model.setField(record, field.name(), field.pos(), convertField(model, datum.get(field.name()), field));            }            return record;        case MAP:            RecordException.check(datum.isObject(), "Cannot convert non-object to map: %s", datum);            Map<String, Object> map = Maps.newLinkedHashMap();            Iterator<Map.Entry<String, JsonNode>> iter = datum.fields();            while (iter.hasNext()) {                Map.Entry<String, JsonNode> entry = iter.next();                map.put(entry.getKey(), convertToAvro(model, entry.getValue(), schema.getValueType()));            }            return map;        case ARRAY:            RecordException.check(datum.isArray(), "Cannot convert to array: %s", datum);            List<Object> list = Lists.newArrayListWithExpectedSize(datum.size());            for (JsonNode element : datum) {                list.add(convertToAvro(model, element, schema.getElementType()));            }            return list;        case UNION:            return convertToAvro(model, datum, resolveUnion(datum, schema.getTypes()));        case BOOLEAN:            RecordException.check(datum.isBoolean(), "Cannot convert to boolean: %s", datum);            return datum.booleanValue();        case FLOAT:            RecordException.check(datum.isFloat() || datum.isInt(), "Cannot convert to float: %s", datum);            return datum.floatValue();        case DOUBLE:            RecordException.check(datum.isDouble() || datum.isFloat() || datum.isLong() || datum.isInt(), "Cannot convert to double: %s", datum);            return datum.doubleValue();        case INT:            RecordException.check(datum.isInt(), "Cannot convert to int: %s", datum);            return datum.intValue();        case LONG:            RecordException.check(datum.isLong() || datum.isInt(), "Cannot convert to long: %s", datum);            return datum.longValue();        case STRING:            RecordException.check(datum.isTextual(), "Cannot convert to string: %s", datum);            return datum.textValue();        case ENUM:            RecordException.check(datum.isTextual(), "Cannot convert to string: %s", datum);            return model.createEnum(datum.textValue(), schema);        case BYTES:            RecordException.check(datum.isBinary(), "Cannot convert to binary: %s", datum);            try {                return ByteBuffer.wrap(datum.binaryValue());            } catch (IOException e) {                throw new RecordException("Failed to read JSON binary", e);            }        case FIXED:            RecordException.check(datum.isBinary(), "Cannot convert to fixed: %s", datum);            byte[] bytes;            try {                bytes = datum.binaryValue();            } catch (IOException e) {                throw new RecordException("Failed to read JSON binary", e);            }            RecordException.check(bytes.length < schema.getFixedSize(), "Binary data is too short: %s bytes for %s", bytes.length, schema);            return model.createFixed(null, bytes, schema);        case NULL:            return null;        default:                        throw new IllegalArgumentException("Unknown schema type: " + schema);    }}
a5811b2c08587b882d5a79251db510515c7c91da86673843d6ecf47c148cab2d
convertField
private static Object convertField(GenericData model, JsonNode datum, Schema.Field field)
{    try {        Object value = convertToAvro(model, datum, field.schema());        if (value != null || Schemas.nullOk(field.schema())) {            return value;        } else {            return model.getDefaultValue(field);        }    } catch (RecordException e) {                throw new RecordException(String.format("Cannot convert field %s", field.name()), e);    } catch (AvroRuntimeException e) {        throw new RecordException(String.format("Field %s: cannot make %s value: '%s'", field.name(), field.schema(), String.valueOf(datum)), e);    }}
0db8c4e55827e4a4a97bf6ec757f4254a04d21ab98a1d638506d7de43dd18797
resolveUnion
private static Schema resolveUnion(JsonNode datum, Collection<Schema> schemas)
{    Set<Schema.Type> primitives = Sets.newHashSet();    List<Schema> others = Lists.newArrayList();    for (Schema schema : schemas) {        if (PRIMITIVES.containsKey(schema.getType())) {            primitives.add(schema.getType());        } else {            others.add(schema);        }    }        Schema primitiveSchema = null;    if (datum == null || datum.isNull()) {        primitiveSchema = closestPrimitive(primitives, Schema.Type.NULL);    } else if (datum.isShort() || datum.isInt()) {        primitiveSchema = closestPrimitive(primitives, Schema.Type.INT, Schema.Type.LONG, Schema.Type.FLOAT, Schema.Type.DOUBLE);    } else if (datum.isLong()) {        primitiveSchema = closestPrimitive(primitives, Schema.Type.LONG, Schema.Type.DOUBLE);    } else if (datum.isFloat()) {        primitiveSchema = closestPrimitive(primitives, Schema.Type.FLOAT, Schema.Type.DOUBLE);    } else if (datum.isDouble()) {        primitiveSchema = closestPrimitive(primitives, Schema.Type.DOUBLE);    } else if (datum.isBoolean()) {        primitiveSchema = closestPrimitive(primitives, Schema.Type.BOOLEAN);    }    if (primitiveSchema != null) {        return primitiveSchema;    }        for (Schema schema : others) {        if (matches(datum, schema)) {            return schema;        }    }    throw new RecordException(String.format("Cannot resolve union: %s not in %s", datum, schemas));}
6ba95871c390065d4cc983114b05b2f9b67a8831033a43f596a99b9318d044c8
closestPrimitive
private static Schema closestPrimitive(Set<Schema.Type> possible, Schema.Type... types)
{    for (Schema.Type type : types) {        if (possible.contains(type) && PRIMITIVES.containsKey(type)) {            return PRIMITIVES.get(type);        }    }    return null;}
85d13fb16ca653c5f50a28373e4e2d79792395e1819c44a107ac0d85e2508642
matches
private static boolean matches(JsonNode datum, Schema schema)
{    switch(schema.getType()) {        case RECORD:            if (datum.isObject()) {                                boolean missingField = false;                for (Schema.Field field : schema.getFields()) {                    if (!datum.has(field.name()) && field.defaultVal() == null) {                        missingField = true;                        break;                    }                }                if (!missingField) {                    return true;                }            }            break;        case UNION:            if (resolveUnion(datum, schema.getTypes()) != null) {                return true;            }            break;        case MAP:            if (datum.isObject()) {                return true;            }            break;        case ARRAY:            if (datum.isArray()) {                return true;            }            break;        case BOOLEAN:            if (datum.isBoolean()) {                return true;            }            break;        case FLOAT:            if (datum.isFloat() || datum.isInt()) {                return true;            }            break;        case DOUBLE:            if (datum.isDouble() || datum.isFloat() || datum.isLong() || datum.isInt()) {                return true;            }            break;        case INT:            if (datum.isInt()) {                return true;            }            break;        case LONG:            if (datum.isLong() || datum.isInt()) {                return true;            }            break;        case STRING:            if (datum.isTextual()) {                return true;            }            break;        case ENUM:            if (datum.isTextual() && schema.hasEnumSymbol(datum.textValue())) {                return true;            }            break;        case BYTES:        case FIXED:            if (datum.isBinary()) {                return true;            }            break;        case NULL:            if (datum == null || datum.isNull()) {                return true;            }            break;        default:                        throw new IllegalArgumentException("Unsupported schema: " + schema);    }    return false;}
e69bd6bfcbcd899eb49c9832c7406b3ba83b0e4af444827f36be36996400b99a
inferSchema
public static Schema inferSchema(InputStream incoming, final String name, int numRecords)
{    Iterator<Schema> schemas = Iterators.transform(parser(incoming), new Function<JsonNode, Schema>() {        @Override        public Schema apply(JsonNode node) {            return inferSchema(node, name);        }    });    if (!schemas.hasNext()) {        return null;    }    Schema result = schemas.next();    for (int i = 1; schemas.hasNext() && i < numRecords; i += 1) {        result = Schemas.merge(result, schemas.next());    }    return result;}
9995b8976c014a13ba823d819491fe9b0bd39a960a80a52ea3f6a559a42bf852
apply
public Schema apply(JsonNode node)
{    return inferSchema(node, name);}
c0dd5d91c88f5747003b6533c605140cb62ed8fc70068134dc9a8828e77371ec
inferSchema
public static Schema inferSchema(JsonNode node, String name)
{    return visit(node, new JsonSchemaVisitor(name));}
bd1caace17ada3218773fbea0d8d80bd8c6ce4dae0c65640a5be49d8c33b73a3
inferSchemaWithMaps
public static Schema inferSchemaWithMaps(JsonNode node, String name)
{    return visit(node, new JsonSchemaVisitor(name).useMaps());}
1104704ae0bf29ecf987eca19f226851f696ba7c2e0dcdc94ff5bc073ae55067
useMaps
public JsonSchemaVisitor useMaps()
{    this.objectsToRecords = false;    return this;}
6875f802db27dd981f9f172ec669a6115adf0a083e0956df9481b5dddb4ea849
object
public Schema object(ObjectNode object, Map<String, Schema> fields)
{    if (objectsToRecords || recordLevels.size() < 1) {        List<Schema.Field> recordFields = Lists.newArrayListWithExpectedSize(fields.size());        for (Map.Entry<String, Schema> entry : fields.entrySet()) {            recordFields.add(new Schema.Field(entry.getKey(), entry.getValue(), "Type inferred from '" + object.get(entry.getKey()) + "'", null));        }        Schema recordSchema;        if (recordLevels.size() < 1) {            recordSchema = Schema.createRecord(name, null, null, false);        } else {            recordSchema = Schema.createRecord(DOT.join(recordLevels), null, null, false);        }        recordSchema.setFields(recordFields);        return recordSchema;    } else {                switch(fields.size()) {            case 0:                return Schema.createMap(Schema.create(Schema.Type.NULL));            case 1:                return Schema.createMap(Iterables.getOnlyElement(fields.values()));            default:                return Schema.createMap(Schemas.mergeOrUnion(fields.values()));        }    }}
2692205fe6837b347ae03b48a9ca1d217b07643c30d3197f34009597eb0fb491
array
public Schema array(ArrayNode ignored, List<Schema> elementSchemas)
{        switch(elementSchemas.size()) {        case 0:            return Schema.createArray(Schema.create(Schema.Type.NULL));        case 1:            return Schema.createArray(Iterables.getOnlyElement(elementSchemas));        default:            return Schema.createArray(Schemas.mergeOrUnion(elementSchemas));    }}
e2fef5f513a5681448130a3645c70cf7f0b9b016a5f307be7b6e84b700bfe79f
binary
public Schema binary(BinaryNode ignored)
{    return Schema.create(Schema.Type.BYTES);}
5b61084b526258d1ca5f8b135e6e7ab1870ecb743b7864f54504508906ce4134
text
public Schema text(TextNode ignored)
{    return Schema.create(Schema.Type.STRING);}
70a7d08cadd7eb2e036b56c536a9ea165f8191f3edf04d6feb3d8da52437c508
number
public Schema number(NumericNode number)
{    if (number.isInt()) {        return Schema.create(Schema.Type.INT);    } else if (number.isLong()) {        return Schema.create(Schema.Type.LONG);    } else if (number.isFloat()) {        return Schema.create(Schema.Type.FLOAT);    } else if (number.isDouble()) {        return Schema.create(Schema.Type.DOUBLE);    } else {        throw new UnsupportedOperationException(number.getClass().getName() + " is not supported");    }}
2cd4b8fb4c7d1e694c179b9d89d5f3c97004cfd606f292977870f91efbfcd09f
bool
public Schema bool(BooleanNode ignored)
{    return Schema.create(Schema.Type.BOOLEAN);}
60320376b434655353a29dd6e4217f54c45815cf0b6cf23d5a342ddc0ea57664
nullNode
public Schema nullNode(NullNode ignored)
{    return Schema.create(Schema.Type.NULL);}
565ac5c8d435f385114e1acababfde2b39361bdf444049e74c5687e9adf7d7d7
missing
public Schema missing(MissingNode ignored)
{    throw new UnsupportedOperationException("MissingNode is not supported.");}
e478cf1a38a77b44eed06cd5945ab5e774a2a27c42fed2577634e199b60edc9e
visit
private static T visit(JsonNode node, JsonTreeVisitor<T> visitor)
{    switch(node.getNodeType()) {        case OBJECT:            Preconditions.checkArgument(node instanceof ObjectNode, "Expected instance of ObjectNode: " + node);                        Map<String, T> fields = Maps.newLinkedHashMap();            Iterator<Map.Entry<String, JsonNode>> iter = node.fields();            while (iter.hasNext()) {                Map.Entry<String, JsonNode> entry = iter.next();                visitor.recordLevels.push(entry.getKey());                fields.put(entry.getKey(), visit(entry.getValue(), visitor));                visitor.recordLevels.pop();            }            return visitor.object((ObjectNode) node, fields);        case ARRAY:            Preconditions.checkArgument(node instanceof ArrayNode, "Expected instance of ArrayNode: " + node);            List<T> elements = Lists.newArrayListWithExpectedSize(node.size());            for (JsonNode element : node) {                elements.add(visit(element, visitor));            }            return visitor.array((ArrayNode) node, elements);        case BINARY:            Preconditions.checkArgument(node instanceof BinaryNode, "Expected instance of BinaryNode: " + node);            return visitor.binary((BinaryNode) node);        case STRING:            Preconditions.checkArgument(node instanceof TextNode, "Expected instance of TextNode: " + node);            return visitor.text((TextNode) node);        case NUMBER:            Preconditions.checkArgument(node instanceof NumericNode, "Expected instance of NumericNode: " + node);            return visitor.number((NumericNode) node);        case BOOLEAN:            Preconditions.checkArgument(node instanceof BooleanNode, "Expected instance of BooleanNode: " + node);            return visitor.bool((BooleanNode) node);        case MISSING:            Preconditions.checkArgument(node instanceof MissingNode, "Expected instance of MissingNode: " + node);            return visitor.missing((MissingNode) node);        case NULL:            Preconditions.checkArgument(node instanceof NullNode, "Expected instance of NullNode: " + node);            return visitor.nullNode((NullNode) node);        default:            throw new IllegalArgumentException("Unknown node type: " + node.getNodeType() + ": " + node);    }}
f47f5f8eb06beeea8ae20e8e290e1670ce200e56e489eb1ff40ba700a14c3146
object
public T object(ObjectNode object, Map<String, T> fields)
{    return null;}
5eef9502725a7cb2fb4c1aa644201bb2fb469d230a9521fef9bcf0b566660251
array
public T array(ArrayNode array, List<T> elements)
{    return null;}
115236365d7a59044f6829a808ef07debaf2662363e7224b19bb3a5d571d938c
binary
public T binary(BinaryNode binary)
{    return null;}
f106ce49ffd57d7c3b28d91558e5dbd7c9d5c4b8f8c76d17167b6785c86060c0
text
public T text(TextNode text)
{    return null;}
4d430bb8fc53c81df4113c45f8aeed78e1a68626985bab6a2f4641224896b413
number
public T number(NumericNode number)
{    return null;}
1798429968e4c375ad3358dddb98dcc7b92dc80f0e2c99bbb2e2750c7d5c58a3
bool
public T bool(BooleanNode bool)
{    return null;}
ec837654e9ffb6fd4198612e41e8d5b003699247d582ff87bbeea2aa646c622f
missing
public T missing(MissingNode missing)
{    return null;}
05fb48c0c128329e2c40826f8db85b7396708fb45e8ce01df5060b6ea3b9736c
nullNode
public T nullNode(NullNode nullNode)
{    return null;}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return iterator.hasNext();}
c8bdca1c159be1f114d59823385a107cb1e1393427235435e4cb9dd743d2eaa5
next
public E next()
{    return iterator.next();}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    iterator = null;    try {        stream.close();    } catch (IOException e) {        throw new RuntimeIOException("Cannot close reader", e);    }}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException("Remove is not implemented.");}
5075bfc98a062ea4b29a732dae0454346475177e17c872d8ce3f9b992ea93a8c
iterator
public Iterator<E> iterator()
{    return this;}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    try {        jc.parse(args);    } catch (MissingCommandException e) {        console.error(e.getMessage());        return 1;    } catch (ParameterException e) {        help.setProgramName(programName);        String cmd = jc.getParsedCommand();        if (args.length == 1) {                        help.helpCommands.add(cmd);            help.run();            return 1;        } else {                        for (String arg : args) {                if (HELP_ARGS.contains(arg)) {                    help.helpCommands.add(cmd);                    help.run();                    return 0;                }            }        }        console.error(e.getMessage());        return 1;    }    help.setProgramName(programName);        if (debug) {        org.apache.log4j.Logger console = org.apache.log4j.Logger.getLogger(Main.class);        console.setLevel(Level.DEBUG);    }    String parsed = jc.getParsedCommand();    if (parsed == null) {        help.run();        return 1;    } else if ("help".equals(parsed)) {        return help.run();    }    Command command = (Command) jc.getCommands().get(parsed).getObjects().get(0);    if (command == null) {        help.run();        return 1;    }    try {        if (command instanceof Configurable) {            ((Configurable) command).setConf(getConf());        }        return command.run();    } catch (IllegalArgumentException e) {        if (debug) {            console.error("Argument error", e);        } else {            console.error("Argument error: {}", e.getMessage());        }        return 1;    } catch (IllegalStateException e) {        if (debug) {            console.error("State error", e);        } else {            console.error("State error: {}", e.getMessage());        }        return 1;    } catch (Exception e) {        console.error("Unknown error", e);        return 1;    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{        PropertyConfigurator.configure(Main.class.getResource("/cli-logging.properties"));    Logger console = LoggerFactory.getLogger(Main.class);        LogFactory.getFactory().setAttribute("org.apache.commons.logging.Log", "org.apache.commons.logging.impl.Log4JLogger");    int rc = ToolRunner.run(new Configuration(), new Main(console), args);    System.exit(rc);}
e7f28051f830debc16dc7d115d91196f0aaf298038821c4181a56be7961abb78
parquetCodec
public static CompressionCodecName parquetCodec(String codec)
{    try {        return CompressionCodecName.valueOf(codec.toUpperCase(Locale.ENGLISH));    } catch (IllegalArgumentException e) {        throw new IllegalArgumentException("Unknown compression codec: " + codec);    }}
6f5c6d6d270d6711f015e7721477af378138c3261127aca9f639c1ebdb82b76c
avroCodec
public static CodecFactory avroCodec(String codec)
{    CompressionCodecName parquetCodec = parquetCodec(codec);    switch(parquetCodec) {        case UNCOMPRESSED:            return CodecFactory.nullCodec();        case SNAPPY:            return CodecFactory.snappyCodec();        case GZIP:            return CodecFactory.deflateCodec(9);        case ZSTD:            return CodecFactory.zstandardCodec(CodecFactory.DEFAULT_ZSTANDARD_LEVEL);        default:            throw new IllegalArgumentException("Codec incompatible with Avro: " + codec);    }}
61e133d070c33c7562031fe8c0c17b3b426901fac1d6293766db405751bbc7ac
select
public static Object select(Schema schema, Object datum, String path)
{    return select(schema, datum, Lists.newArrayList(parse(path)));}
72ea1bb00a5a7f726f11c6cc2811be724a62e89fe1ed30961b8a7e2fddb54fe4
select
private static Object select(Schema schema, Object datum, List<PathExpr> tokens)
{    if (tokens.isEmpty()) {        return datum;    }    Preconditions.checkArgument(tokens.size() == 1, "Cannot return multiple values");    PathExpr token = tokens.get(0);    switch(schema.getType()) {        case RECORD:            if (!(datum instanceof GenericRecord) && "json".equals(schema.getName())) {                                return select(schema.getField("value").schema(), datum, tokens);            }            Preconditions.checkArgument(token.type == PathExpr.Type.FIELD, "Cannot dereference records");            Preconditions.checkArgument(datum instanceof GenericRecord, "Not a record: %s", datum);            GenericRecord record = (GenericRecord) datum;            Schema.Field field = schema.getField(token.value);            Preconditions.checkArgument(field != null, "No such field '%s' in schema: %s", token.value, schema);            return select(field.schema(), record.get(token.value), token.children);        case MAP:            Preconditions.checkArgument(datum instanceof Map, "Not a map: %s", datum);            Map<Object, Object> map = (Map<Object, Object>) datum;            Object value = map.get(token.value);            if (value == null) {                                value = map.get(new Utf8(token.value));            }            return select(schema.getValueType(), value, token.children);        case ARRAY:            Preconditions.checkArgument(token.type == PathExpr.Type.DEREF, "Cannot access fields of an array");            Preconditions.checkArgument(datum instanceof Collection, "Not an array: %s", datum);            Preconditions.checkArgument(NUMERIC_RE.matcher(token.value).matches(), "Not an array index: %s", token.value);            List<Object> list = (List<Object>) datum;            return select(schema.getElementType(), list.get(Integer.parseInt(token.value)), token.children);        case UNION:            int branch = GenericData.get().resolveUnion(schema, datum);            return select(schema.getTypes().get(branch), datum, tokens);        default:            throw new IllegalArgumentException("Cannot access child of primitive value: " + datum);    }}
8b17f0c211d32ec7277d9999c0954c3fe03c348a678865fdc0d1e7d7a0efcc91
filterSchema
public static Schema filterSchema(Schema schema, String... fieldPaths)
{    return filterSchema(schema, Lists.newArrayList(fieldPaths));}
58f8008cd726658fdb296f32f3018cb61f263f16861178e9eb9e4ef2deb4d01e
filterSchema
public static Schema filterSchema(Schema schema, List<String> fieldPaths)
{    if (fieldPaths == null) {        return schema;    }    List<PathExpr> paths = merge(Lists.newArrayList(fieldPaths));    return filter(schema, paths);}
8daf87051d093cd7fa6ce1bccb08a0db6cad42c719f2bbe01df27e2d9d63cf9b
parse
private static PathExpr parse(String path)
{    PathExpr expr = null;    PathExpr last = null;    boolean inDeref = false;    boolean afterDeref = false;    int valueStart = 0;    for (int i = 0; i < path.length(); i += 1) {        switch(path.charAt(i)) {            case '.':                Preconditions.checkState(valueStart != i || afterDeref, "Empty reference: ''");                if (!inDeref) {                    if (valueStart != i) {                        PathExpr current = PathExpr.field(path.substring(valueStart, i));                        if (last != null) {                            last.children.add(current);                        } else {                            expr = current;                        }                        last = current;                    }                    valueStart = i + 1;                    afterDeref = false;                }                break;            case '[':                Preconditions.checkState(!inDeref, "Cannot nest [ within []");                Preconditions.checkState(valueStart != i || afterDeref, "Empty reference: ''");                if (valueStart != i) {                    PathExpr current = PathExpr.field(path.substring(valueStart, i));                    if (last != null) {                        last.children.add(current);                    } else {                        expr = current;                    }                    last = current;                }                valueStart = i + 1;                inDeref = true;                afterDeref = false;                break;            case ']':                Preconditions.checkState(inDeref, "Cannot use ] without a starting [");                Preconditions.checkState(valueStart != i, "Empty reference: ''");                PathExpr current = PathExpr.deref(path.substring(valueStart, i));                if (last != null) {                    last.children.add(current);                } else {                    expr = current;                }                last = current;                valueStart = i + 1;                inDeref = false;                afterDeref = true;                break;            default:                Preconditions.checkState(!afterDeref, "Fields after [] must start with .");        }    }    Preconditions.checkState(!inDeref, "Fields after [ must end with ]");    if (valueStart < path.length()) {        PathExpr current = PathExpr.field(path.substring(valueStart, path.length()));        if (last != null) {            last.children.add(current);        } else {            expr = current;        }    }    return expr;}
3e43d8864ae38f7d58d85d6e73cebaec21a9c585b44f171b77b1f38d960710a6
merge
private static List<PathExpr> merge(List<String> fields)
{    List<PathExpr> paths = Lists.newArrayList();    for (String field : fields) {        merge(paths, parse(field));    }    return paths;}
941cd2d48183eb0bfae13e9cf0ea01d96fafe8de7aa4b7ffb8585a7e9d25f1cf
merge
private static List<PathExpr> merge(List<PathExpr> tokens, PathExpr toAdd)
{    boolean merged = false;    for (PathExpr token : tokens) {        if ((token.type == toAdd.type) && (token.type == PathExpr.Type.DEREF || token.value.equals(toAdd.value))) {            for (PathExpr child : toAdd.children) {                merge(token.children, child);            }            merged = true;        }    }    if (!merged) {        tokens.add(toAdd);    }    return tokens;}
0ec9c91986dec864a4ccd74590b6928a16498785323e17ef53c39e4bfe9c8d34
filter
private static Schema filter(Schema schema, List<PathExpr> exprs)
{    if (exprs.isEmpty()) {        return schema;    }    switch(schema.getType()) {        case RECORD:            List<Schema.Field> fields = Lists.newArrayList();            for (PathExpr expr : exprs) {                Schema.Field field = schema.getField(expr.value);                Preconditions.checkArgument(field != null, "Cannot find field '%s' in schema: %s", expr.value, schema);                fields.add(new Schema.Field(expr.value, filter(field.schema(), expr.children), field.doc(), field.defaultVal(), field.order()));            }            return Schema.createRecord(schema.getName(), schema.getDoc(), schema.getNamespace(), schema.isError(), fields);        case UNION:                        if (schema.getTypes().size() == 2) {                if (schema.getTypes().get(0).getType() == Schema.Type.NULL) {                    return filter(schema.getTypes().get(1), exprs);                } else if (schema.getTypes().get(1).getType() == Schema.Type.NULL) {                    return filter(schema.getTypes().get(0), exprs);                }            }            List<Schema> schemas = Lists.newArrayList();            for (PathExpr expr : exprs) {                schemas.add(filter(schema, expr));            }            if (schemas.size() > 1) {                return Schema.createUnion(schemas);            } else {                return schemas.get(0);            }        case MAP:            Preconditions.checkArgument(exprs.size() == 1, "Cannot find multiple children of map schema: %s", schema);            return filter(schema, exprs.get(0));        case ARRAY:            Preconditions.checkArgument(exprs.size() == 1, "Cannot find multiple children of array schema: %s", schema);            return filter(schema, exprs.get(0));        default:            throw new IllegalArgumentException(String.format("Cannot find child of primitive schema: %s", schema));    }}
4edd55914a7217ddeac84f86d9ba9d612124c3c8f56d99f518a744d6fbbee62b
filter
private static Schema filter(Schema schema, PathExpr expr)
{    if (expr == null) {        return schema;    }    switch(schema.getType()) {        case RECORD:            Preconditions.checkArgument(expr.type == PathExpr.Type.FIELD, "Cannot index a record: [%s]", expr.value);            Schema.Field field = schema.getField(expr.value);            if (field != null) {                return filter(field.schema(), expr.children);            } else {                throw new IllegalArgumentException(String.format("Cannot find field '%s' in schema: %s", expr.value, schema.toString(true)));            }        case MAP:            return Schema.createMap(filter(schema.getValueType(), expr.children));        case ARRAY:            Preconditions.checkArgument(expr.type == PathExpr.Type.DEREF, "Cannot find field '%s' in an array", expr.value);            Preconditions.checkArgument(NUMERIC_RE.matcher(expr.value).matches(), "Cannot index array by non-numeric value '%s'", expr.value);            return Schema.createArray(filter(schema.getElementType(), expr.children));        case UNION:                                    Preconditions.checkArgument(expr.type == PathExpr.Type.DEREF, "Cannot find field '%s' in a union", expr.value);            List<Schema> options = schema.getTypes();            if (NUMERIC_RE.matcher(expr.value).matches()) {                                int i = Integer.parseInt(expr.value);                if (i < options.size()) {                    return filter(options.get(i), expr.children);                }            } else {                                for (Schema option : options) {                    if (expr.value.equalsIgnoreCase(option.getName())) {                        return filter(option, expr.children);                    }                }            }            throw new IllegalArgumentException(String.format("Invalid union index '%s' for schema: %s", expr.value, schema));        default:            throw new IllegalArgumentException(String.format("Cannot find '%s' in primitive schema: %s", expr.value, schema));    }}
a6bf1ad71c7e089836dda3650339c5ac11a7914ac0246b1bad80d24020101973
deref
 static PathExpr deref(String value)
{    return new PathExpr(Type.DEREF, value);}
666a64e4fd498050ae76d7a8954a67f95f11fea77e68060cbda2a019346b15c7
deref
 static PathExpr deref(String value, PathExpr child)
{    return new PathExpr(Type.DEREF, value, Lists.newArrayList(child));}
9a6e2ee91709d6a4ec052a3676b808c1417e4c27fa614af1b2abc144c6fa283b
field
 static PathExpr field(String value)
{    return new PathExpr(Type.FIELD, value);}
06b2a682e74cd35ec2bc75e64152dd66717bb52e764d86b68a7511ae64909aec
field
 static PathExpr field(String value, PathExpr child)
{    return new PathExpr(Type.FIELD, value, Lists.newArrayList(child));}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    PathExpr pathExpr = (PathExpr) o;    if (type != pathExpr.type)        return false;    if (value != null ? !value.equals(pathExpr.value) : pathExpr.value != null)        return false;    return children != null ? children.equals(pathExpr.children) : pathExpr.children == null;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = type != null ? type.hashCode() : 0;    result = 31 * result + (value != null ? value.hashCode() : 0);    result = 31 * result + (children != null ? children.hashCode() : 0);    return result;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return MoreObjects.toStringHelper(this).add("type", type).add("value", value).add("children", children).toString();}
c3349f38127296731a633a3c0350e95488f34569481c74074366159cc0781db5
detectFormat
public static Format detectFormat(InputStream stream) throws IOException
{    byte[] first3 = new byte[3];    stream.read(first3);    if (Arrays.equals(first3, new byte[] { 'P', 'A', 'R' })) {        return Format.PARQUET;    } else if (Arrays.equals(first3, new byte[] { 'O', 'b', 'j' })) {        return Format.AVRO;    } else if (Arrays.equals(first3, new byte[] { 'S', 'E', 'Q' })) {        return Format.SEQUENCE;    } else {        return Format.TEXT;    }}
c76ee3410ad8fc25c54135cecac3a1a95d362f8479bd20716a0b839b1385c614
run
public ClassLoader run()
{    return new URLClassLoader(urls, Thread.currentThread().getContextClassLoader());}
1d3057ce7216e9e33e77b11846c08d1cecbbdc68e105d9311d5d8bf5fd2bfbf7
check
public static void check(boolean isValid, String message, Object... args)
{    if (!isValid) {        String[] argStrings = new String[args.length];        for (int i = 0; i < args.length; i += 1) {            argStrings[i] = String.valueOf(args[i]);        }        throw new RecordException(String.format(String.valueOf(message), (Object[]) argStrings));    }}
18f9e7ac9ce0f9823d9f80a02ad49e6ade891e58f3b9044053e5228e70a7bd66
fromAvsc
public static Schema fromAvsc(InputStream in) throws IOException
{        return new Schema.Parser().parse(in);}
528fb5dd3f5958773b2bce2d6a3ddced3735d3df38c4341964214f265ce3ff37
fromAvro
public static Schema fromAvro(InputStream in) throws IOException
{    GenericDatumReader<GenericRecord> datumReader = new GenericDatumReader<GenericRecord>();    DataFileStream<GenericRecord> stream = null;    boolean threw = true;    try {        stream = new DataFileStream<>(in, datumReader);        Schema schema = stream.getSchema();        threw = false;        return schema;    } finally {        Closeables.close(stream, threw);    }}
97d4ae389f8d61365a7cb9dd146ff3cbc06a76a14ae3ae877b10a28fe1afdb57
fromParquet
public static Schema fromParquet(Configuration conf, URI location) throws IOException
{    Path path = new Path(location);    FileSystem fs = path.getFileSystem(conf);    ParquetMetadata footer = ParquetFileReader.readFooter(fs.getConf(), path);    String schemaString = footer.getFileMetaData().getKeyValueMetaData().get("parquet.avro.schema");    if (schemaString == null) {                schemaString = footer.getFileMetaData().getKeyValueMetaData().get("avro.schema");    }    if (schemaString != null) {        return new Schema.Parser().parse(schemaString);    } else {        return new AvroSchemaConverter().convert(footer.getFileMetaData().getSchema());    }}
82b0895d642406efc4e69f7b65e0e579f06e5c4d7b18821c631f6d0fb934673a
fromJSON
public static Schema fromJSON(String name, InputStream in) throws IOException
{    return AvroJson.inferSchema(in, name, 20);}
bc44a280bc564597003a533fa0ae181752366106408e0298199888df1110be7c
nullOk
public static boolean nullOk(Schema schema)
{    if (Schema.Type.NULL == schema.getType()) {        return true;    } else if (Schema.Type.UNION == schema.getType()) {        for (Schema possible : schema.getTypes()) {            if (nullOk(possible)) {                return true;            }        }    }    return false;}
986eda96bfd9d945714c952c3fcd931bd593ebf01012b2dcc46eb62839cf37f9
merge
public static Schema merge(Iterable<Schema> schemas)
{    Iterator<Schema> iter = schemas.iterator();    if (!iter.hasNext()) {        return null;    }    Schema result = iter.next();    while (iter.hasNext()) {        result = merge(result, iter.next());    }    return result;}
e9626fa2b27b5355cd45601ef6b049dc0a4e2cb52cb72e2d6bc0448adb96876b
mergeOrUnion
public static Schema mergeOrUnion(Iterable<Schema> schemas)
{    Iterator<Schema> iter = schemas.iterator();    if (!iter.hasNext()) {        return null;    }    Schema result = iter.next();    while (iter.hasNext()) {        result = mergeOrUnion(result, iter.next());    }    return result;}
adec7afe15a8be5c12a86f6540254ee6b549c5c38ff4c54502521f09c8434f05
merge
public static Schema merge(Schema left, Schema right)
{    Schema merged = mergeOnly(left, right);    Preconditions.checkState(merged != null, "Cannot merge %s and %s", left, right);    return merged;}
22171aca7a003092f5fd446b8e1690a5a7d976a4f8e138e86a7047a1c27debe0
mergeOrUnion
private static Schema mergeOrUnion(Schema left, Schema right)
{    Schema merged = mergeOnly(left, right);    if (merged != null) {        return merged;    }    return union(left, right);}
771c45b0a703e9c2704e729722b7763634896a3008157a7eef07b81f1e028edc
union
private static Schema union(Schema left, Schema right)
{    if (left.getType() == Schema.Type.UNION) {        if (right.getType() == Schema.Type.UNION) {                        Schema combined = left;            for (Schema type : right.getTypes()) {                combined = union(combined, type);            }            return combined;        } else {            boolean notMerged = true;                        List<Schema> types = Lists.newArrayList();            Iterator<Schema> schemas = left.getTypes().iterator();                        while (schemas.hasNext()) {                Schema next = schemas.next();                Schema merged = mergeOnly(next, right);                if (merged != null) {                    types.add(merged);                    notMerged = false;                    break;                } else {                                        types.add(next);                }            }                        while (schemas.hasNext()) {                types.add(schemas.next());            }            if (notMerged) {                types.add(right);            }            return Schema.createUnion(types);        }    } else if (right.getType() == Schema.Type.UNION) {        return union(right, left);    }    return Schema.createUnion(ImmutableList.of(left, right));}
eeaf00e37219bc2d203ce853908275f030e479651a620ebdedadff0c8a20c75d
mergeOnly
private static Schema mergeOnly(Schema left, Schema right)
{    if (Objects.equal(left, right)) {        return left;    }        switch(left.getType()) {        case INT:            if (right.getType() == Schema.Type.LONG) {                return right;            }            break;        case LONG:            if (right.getType() == Schema.Type.INT) {                return left;            }            break;        case FLOAT:            if (right.getType() == Schema.Type.DOUBLE) {                return right;            }            break;        case DOUBLE:            if (right.getType() == Schema.Type.FLOAT) {                return left;            }    }        if (left.getType() != right.getType()) {        return null;    }    switch(left.getType()) {        case UNION:            return union(left, right);        case RECORD:            if (left.getName() == null && right.getName() == null && fieldSimilarity(left, right) < SIMILARITY_THRESH) {                return null;            } else if (!Objects.equal(left.getName(), right.getName())) {                return null;            }            Schema combinedRecord = Schema.createRecord(coalesce(left.getName(), right.getName()), coalesce(left.getDoc(), right.getDoc()), coalesce(left.getNamespace(), right.getNamespace()), false);            combinedRecord.setFields(mergeFields(left, right));            return combinedRecord;        case MAP:            return Schema.createMap(mergeOrUnion(left.getValueType(), right.getValueType()));        case ARRAY:            return Schema.createArray(mergeOrUnion(left.getElementType(), right.getElementType()));        case ENUM:            if (!Objects.equal(left.getName(), right.getName())) {                return null;            }            Set<String> symbols = Sets.newLinkedHashSet();            symbols.addAll(left.getEnumSymbols());            symbols.addAll(right.getEnumSymbols());            return Schema.createEnum(left.getName(), coalesce(left.getDoc(), right.getDoc()), coalesce(left.getNamespace(), right.getNamespace()), ImmutableList.copyOf(symbols));        default:                        throw new UnsupportedOperationException("Unknown schema type: " + left.getType());    }}
54defd339dce9aacfd1ff087bcd351873045ca27c03d45e64cd3d4315e99c519
nullableForDefault
private static Schema nullableForDefault(Schema schema)
{    if (schema.getType() == Schema.Type.NULL) {        return schema;    }    if (schema.getType() != Schema.Type.UNION) {        return Schema.createUnion(ImmutableList.of(NULL, schema));    }    if (schema.getTypes().get(0).getType() == Schema.Type.NULL) {        return schema;    }    List<Schema> types = Lists.newArrayList();    types.add(NULL);    for (Schema type : schema.getTypes()) {        if (type.getType() != Schema.Type.NULL) {            types.add(type);        }    }    return Schema.createUnion(types);}
a1fd99f503f24cf0619e94485d2b7ca7c5b6ec140756d479851424133e93d56f
mergeFields
private static List<Schema.Field> mergeFields(Schema left, Schema right)
{    List<Schema.Field> fields = Lists.newArrayList();    for (Schema.Field leftField : left.getFields()) {        Schema.Field rightField = right.getField(leftField.name());        if (rightField != null) {            fields.add(new Schema.Field(leftField.name(), mergeOrUnion(leftField.schema(), rightField.schema()), coalesce(leftField.doc(), rightField.doc()), coalesce(leftField.defaultVal(), rightField.defaultVal())));        } else {            if (leftField.defaultVal() != null) {                fields.add(copy(leftField));            } else {                fields.add(new Schema.Field(leftField.name(), nullableForDefault(leftField.schema()), leftField.doc(), NULL_DEFAULT));            }        }    }    for (Schema.Field rightField : right.getFields()) {        if (left.getField(rightField.name()) == null) {            if (rightField.defaultVal() != null) {                fields.add(copy(rightField));            } else {                fields.add(new Schema.Field(rightField.name(), nullableForDefault(rightField.schema()), rightField.doc(), NULL_DEFAULT));            }        }    }    return fields;}
085f01a9237eacd4b30ea0949d54582860ab532c6ffd8aa9e638d47ecaed02b6
copy
public static Schema.Field copy(Schema.Field field)
{    return new Schema.Field(field.name(), field.schema(), field.doc(), field.defaultVal());}
e39f1c50a1b90ad98d0d77f14cd6180cd92a2ed87832d495b17989ddcf770f0e
fieldSimilarity
private static float fieldSimilarity(Schema left, Schema right)
{        Set<String> leftNames = names(left.getFields());    Set<String> rightNames = names(right.getFields());    int common = Sets.intersection(leftNames, rightNames).size();    float leftRatio = ((float) common) / ((float) leftNames.size());    float rightRatio = ((float) common) / ((float) rightNames.size());    return hmean(leftRatio, rightRatio);}
d007f3f4bc6f936e69ad8423186fbe6a51cf68833f28c8984f4ea5a0d2643ef0
names
private static Set<String> names(Collection<Schema.Field> fields)
{    Set<String> names = Sets.newHashSet();    for (Schema.Field field : fields) {        names.add(field.name());    }    return names;}
7c1a7111fbf13d408fd482c4bac75338a284e60fd673b6eed4dde166410cee22
hmean
private static float hmean(float left, float right)
{    return (2.0f * left * right) / (left + right);}
f01e4246b24d2cf73873d63755e1917a63d0f450c1737aa440b1e53b77ca63fa
coalesce
private static E coalesce(E... objects)
{    for (E object : objects) {        if (object != null) {            return object;        }    }    return null;}
d82b4dff89e8597e847f70bbec619b3fbe6165fdff6be403c9711e93ebce3d4d
seek
public void seek(long p) throws IOException
{    in.seek(p);}
0efa2bd8fc7bc3d72996c492a3eaca80646290caeceea873a5afabb84aa9504c
tell
public long tell() throws IOException
{    return in.getPos();}
6be07d6c52de04a91907264c1c435ebdd48a3b2cf48f2e117699a543fff56681
length
public long length() throws IOException
{    return stat.getLen();}
f1bd356e482fbc023feab89d2655df447ac6f2bcd456f7c68cc5c21e4167b36b
read
public int read(byte[] b) throws IOException
{    return in.read(b);}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    return in.read();}
56e08d87e6bd0be2a60f9b2de3195d58bc9d56a2637f6fed6210d21e832632ea
read
public int read(byte[] b, int off, int len) throws IOException
{    return in.read(b, off, len);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    in.close();}
1f97de48fb467bcc2ec114d51b074856c794461815edb7a1fbe25a6fdc55115a
humanReadable
public static String humanReadable(float bytes)
{    if (bytes > TB) {        return String.format("%.03f TB", bytes / TB);    } else if (bytes > GB) {        return String.format("%.03f GB", bytes / GB);    } else if (bytes > MB) {        return String.format("%.03f MB", bytes / MB);    } else if (bytes > KB) {        return String.format("%.03f kB", bytes / KB);    } else {        return String.format("%.02f B", bytes);    }}
bed7b4aa24e7e714f01770fd8e204c6880a2079fad231e831d20686ab4387f5a
humanReadable
public static String humanReadable(long bytes)
{    if (bytes > TB) {        return String.format("%.03f TB", ((float) bytes) / TB);    } else if (bytes > GB) {        return String.format("%.03f GB", ((float) bytes) / GB);    } else if (bytes > MB) {        return String.format("%.03f MB", ((float) bytes) / MB);    } else if (bytes > KB) {        return String.format("%.03f kB", ((float) bytes) / KB);    } else {        return String.format("%d B", bytes);    }}
4520c969b6419cfa7776a664215a85a7c0b7104f347058bb7c8ff2f06522ab6e
minMaxAsString
public static String minMaxAsString(Statistics stats, OriginalType annotation)
{    return minMaxAsString(stats);}
3235f8829906ec0e35dcc896168cf4d8289ee5483a8906fde62dbfb23eaee2cd
minMaxAsString
public static String minMaxAsString(Statistics stats)
{    if (stats == null) {        return "no stats";    }    if (!stats.hasNonNullValue()) {        return "";    }    return String.format("%s / %s", humanReadable(stats.minAsString(), 30), humanReadable(stats.maxAsString(), 30));}
c2bded2d4845899925797bb0f63c339d06a55630bf0064b2f392090e52e40785
toString
public static String toString(Statistics stats, long count, OriginalType annotation)
{    return toString(stats, count);}
5fe1e27f52a4c8b240d00fd0ee274e7e713b1cbe04c16e571fcdba9abaf35f14
toString
public static String toString(Statistics stats, long count)
{    if (stats == null) {        return "no stats";    }    return String.format("min: %s max: %s nulls: %d/%d", humanReadable(stats.minAsString(), 30), humanReadable(stats.maxAsString(), 30), stats.getNumNulls(), count);}
d683df2c43feeb5aab6f466777a81e36b04b9fdb44ce125d18481880f042fe65
humanReadable
public static String humanReadable(String str, int len)
{    if (str == null) {        return "null";    }    StringBuilder sb = new StringBuilder();    sb.append("\"");    if (str.length() > len - 2) {        sb.append(str.substring(0, len - 5)).append("...");    } else {        sb.append(str);    }    sb.append("\"");    return sb.toString();}
cff9e2fa42288e10c7993966da018884ab434d02371ac8ed78a47b1f1ef918c0
humanReadable
public static String humanReadable(byte[] bytes, int len)
{    Preconditions.checkArgument(len >= 5, "Display length must be minimum 5");    if (bytes == null || bytes.length == 0) {        return "null";    }    final String asString = HashCode.fromBytes(bytes).toString();    return "0x" + Ascii.truncate(asString, len - 2, "...");}
13cfcfa6b2234d6bd60c85b2402795556c7a81aa2f5d4fee25d602f2a8f87fd4
shortCodec
public static String shortCodec(CompressionCodecName codec)
{    switch(codec) {        case UNCOMPRESSED:            return "_";        case SNAPPY:            return "S";        case GZIP:            return "G";        case LZO:            return "L";        case BROTLI:            return "B";        case LZ4:            return "4";        case ZSTD:            return "Z";        default:            return "?";    }}
5f7f2e68fda6a1e275b98b4319f9601ed658d0c0a2baad28dc93cc749229366d
encodingAsString
public static String encodingAsString(Encoding encoding, boolean isDict)
{    switch(encoding) {        case PLAIN:            return "_";        case PLAIN_DICTIONARY:                        return isDict ? "_" : "R";        case RLE_DICTIONARY:            return "R";        case DELTA_BINARY_PACKED:        case DELTA_LENGTH_BYTE_ARRAY:        case DELTA_BYTE_ARRAY:            return "D";        default:            return "?";    }}
27d74298ff9f45f23b5bf3d68c012498dfa3756fb3aa209767215abc5fcb5cf0
encodingStatsAsString
public static String encodingStatsAsString(EncodingStats encodingStats)
{    StringBuilder sb = new StringBuilder();    if (encodingStats.hasDictionaryPages()) {        for (Encoding encoding : encodingStats.getDictionaryEncodings()) {            sb.append(encodingAsString(encoding, true));        }        sb.append(" ");    } else {        sb.append("  ");    }    Set<Encoding> encodings = encodingStats.getDataEncodings();    if (encodings.contains(RLE_DICTIONARY) || encodings.contains(PLAIN_DICTIONARY)) {        sb.append("R");    }    if (encodings.contains(PLAIN)) {        sb.append("_");    }    if (encodings.contains(DELTA_BYTE_ARRAY) || encodings.contains(DELTA_BINARY_PACKED) || encodings.contains(DELTA_LENGTH_BYTE_ARRAY)) {        sb.append("D");    }        if (encodingStats.hasDictionaryEncodedPages() && encodingStats.hasNonDictionaryEncodedPages()) {        sb.append(" F");    }    return sb.toString();}
598364084928d1e48fe49a51842b5a9c2b6fd9b0f876e9d4fc2dbe76938f0f2d
encodingsAsString
public static String encodingsAsString(Set<Encoding> encodings, ColumnDescriptor desc)
{    StringBuilder sb = new StringBuilder();    if (encodings.contains(RLE) || encodings.contains(BIT_PACKED)) {        sb.append(desc.getMaxDefinitionLevel() == 0 ? "B" : "R");        sb.append(desc.getMaxRepetitionLevel() == 0 ? "B" : "R");        if (encodings.contains(PLAIN_DICTIONARY)) {            sb.append("R");        }        if (encodings.contains(PLAIN)) {            sb.append("_");        }    } else {        sb.append("RR");        if (encodings.contains(RLE_DICTIONARY)) {            sb.append("R");        }        if (encodings.contains(PLAIN)) {            sb.append("_");        }        if (encodings.contains(DELTA_BYTE_ARRAY) || encodings.contains(DELTA_BINARY_PACKED) || encodings.contains(DELTA_LENGTH_BYTE_ARRAY)) {            sb.append("D");        }    }    return sb.toString();}
9f0d27b5a057e10de5d0fff7344a2d2af9a25361d6d211bb37cd304b2ccd516f
descriptor
public static ColumnDescriptor descriptor(String column, MessageType schema)
{    String[] path = Iterables.toArray(DOT.split(column), String.class);    Preconditions.checkArgument(schema.containsPath(path), "Schema doesn't have column: " + column);    return schema.getColumnDescription(path);}
0287af63b25247f3abe0766797c3aab2caaff1e1e6ae6886d7c4aabb34296708
columnName
public static String columnName(ColumnDescriptor desc)
{    return Joiner.on('.').join(desc.getPath());}
e232ae78fe892ed815e3d3309715f93a80455bc747919fadec103ef024db258d
primitive
public static PrimitiveType primitive(MessageType schema, String[] path)
{    Type current = schema;    for (String part : path) {        current = current.asGroupType().getType(part);        if (current.isPrimitive()) {            return current.asPrimitiveType();        }    }    return null;}
35eac6acba90f23f29ca64b6b9f10ff89a4af79980d5fdca75fbd62e0ae0e867
primitive
public static PrimitiveType primitive(String column, MessageType schema)
{    String[] path = Iterables.toArray(DOT.split(column), String.class);    Preconditions.checkArgument(schema.containsPath(path), "Schema doesn't have column: " + column);    return primitive(schema, path);}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    this.command = new TestCommand(this.console);}
88b594e85260b42bc923609399ff9e2c45512fb753ed21259da41f6630812eea
qualifiedPathTest
public void qualifiedPathTest() throws IOException
{    Path path = this.command.qualifiedPath(FILE_PATH);    Assert.assertEquals("test.parquet", path.getName());}
d8a2db9fc5e319d6da680e776893cd8ab5b2409f4ff8f3a84cbd009a8d6ba628
qualifiedURITest
public void qualifiedURITest() throws IOException
{    URI uri = this.command.qualifiedURI(FILE_PATH);    Assert.assertEquals("/var/tmp/test.parquet", uri.getPath());}
cef2731c899fbdecc71a8e9bbc117f34376bdcbb4483abd959f247befa2a7830
qualifiedURIResourceURITest
public void qualifiedURIResourceURITest() throws IOException
{    URI uri = this.command.qualifiedURI("resource:/a");    Assert.assertEquals("/a", uri.getPath());}
465e22b449125bf013b467f92ab9248272d0d548bcc39f67d393b8133e2d4c49
qualifiedPathTestForWindows
public void qualifiedPathTestForWindows() throws IOException
{    Assume.assumeTrue(System.getProperty("os.name").toLowerCase().startsWith("win"));    Path path = this.command.qualifiedPath(WIN_FILE_PATH);    Assert.assertEquals("test.parquet", path.getName());}
7fb453cbe4c84a2d17307bdeb1d9b853549869b33a7b784808c7db204883cddb
qualifiedURITestForWindows
public void qualifiedURITestForWindows() throws IOException
{    Assume.assumeTrue(System.getProperty("os.name").toLowerCase().startsWith("win"));    URI uri = this.command.qualifiedURI(WIN_FILE_PATH);    Assert.assertEquals("/C:/Test/Downloads/test.parquet", uri.getPath());}
314d5698f8c540a650afa0fda19512841433ccc3d5ccd34e4450b16d5270d240
run
public int run() throws IOException
{    return 0;}
80fb381904a52fdf2805fc3fff55b849476f45caf8d596782956670073a7ab46
getExamples
public List<String> getExamples()
{    return null;}
87e4b1fd4d3167e8076398f5aab4b81f2e3c15a77ce8b0bb2f64cf3195417f23
toAvro
protected File toAvro(File parquetFile) throws IOException
{    return toAvro(parquetFile, "GZIP");}
3e7b03173441ad2276204dcd59ac7672af04534b7588bba8db8de313e9d2c659
toAvro
protected File toAvro(File parquetFile, String compressionCodecName) throws IOException
{    ToAvroCommand command = new ToAvroCommand(createLogger());    command.targets = Arrays.asList(parquetFile.getAbsolutePath());    File output = new File(getTempFolder(), getClass().getSimpleName() + ".avro");    command.outputPath = output.getAbsolutePath();    command.compressionCodecName = compressionCodecName;    command.setConf(new Configuration());    int exitCode = command.run();    assert (exitCode == 0);    return output;}
c426b8cbd10ec7199bb4d6a27bccbd15f7da3c33e07ed373a9133be920b1300d
testCatCommand
public void testCatCommand() throws IOException
{    File file = parquetFile();    CatCommand command = new CatCommand(createLogger(), 0);    command.sourceFiles = Arrays.asList(file.getAbsolutePath());    command.setConf(new Configuration());    Assert.assertEquals(0, command.run());}
8e798688f3b061904090a1d3f8b39fe031377e25a8f7e001f073f5f9c604c111
testCheckParquet251Command
public void testCheckParquet251Command() throws IOException
{    File file = parquetFile();    CheckParquet251Command command = new CheckParquet251Command(createLogger());    command.files = Arrays.asList(file.getAbsolutePath());    command.setConf(new Configuration());    Assert.assertEquals(0, command.run());}
447289ee3ccb1b6f3e0a441887fd35b1414622570d78859b58a78b0f24dd20ab
testConvertCommand
public void testConvertCommand() throws IOException
{    File file = toAvro(parquetFile());    ConvertCommand command = new ConvertCommand(createLogger());    command.targets = Arrays.asList(file.getAbsolutePath());    File output = new File(getTempFolder(), "converted.avro");    command.outputPath = output.getAbsolutePath();    command.setConf(new Configuration());    Assert.assertEquals(0, command.run());    Assert.assertTrue(output.exists());}
ebafde2f0e7cc23d278335e89e845d6b341feb0c1b4f03a2c106bda37bed8cf8
testConvertCSVCommand
public void testConvertCSVCommand() throws IOException
{    File file = csvFile();    ConvertCSVCommand command = new ConvertCSVCommand(createLogger());    command.targets = Arrays.asList(file.getAbsolutePath());    File output = new File(getTempFolder(), getClass().getSimpleName() + ".parquet");    command.outputPath = output.getAbsolutePath();    command.setConf(new Configuration());    Assert.assertEquals(0, command.run());    Assert.assertTrue(output.exists());}
c536957a0359efaba4fa041a9429ed02027b66c9e6f5cc21d07eb308cc675a0d
setUp
public void setUp() throws IOException
{    createTestCSVFile();}
c3dfe14a3c42888c6fb7de7d8c5eef6f60f726ed36acacc78445e687566b0036
csvFile
protected File csvFile()
{    File tmpDir = getTempFolder();    return new File(tmpDir, getClass().getSimpleName() + ".csv");}
825fa48299eb0a8b131622c7236d9de66945fe41c80683f6dd9408e515fe7dcd
createTestCSVFile
private void createTestCSVFile() throws IOException
{    File file = csvFile();    try (BufferedWriter writer = new BufferedWriter(new FileWriter(file))) {        writer.write(String.format("%s,%s,%s\n", INT32_FIELD, INT64_FIELD, BINARY_FIELD));        writer.write(String.format("%d,%d,\"%s\"\n", Integer.MIN_VALUE, Long.MIN_VALUE, COLORS[0]));        writer.write(String.format("%d,%d,\"%s\"\n", Integer.MAX_VALUE, Long.MAX_VALUE, COLORS[1]));    }}
19fd84f040b9e39a33b5f1aa083682fcfceb20fdd5590f3e49fd2e16247b0607
testCSVSchemaCommand
public void testCSVSchemaCommand() throws IOException
{    File file = csvFile();    CSVSchemaCommand command = new CSVSchemaCommand(createLogger());    command.samplePaths = Arrays.asList(file.getAbsolutePath());    command.recordName = "Test";    command.setConf(new Configuration());    Assert.assertEquals(0, command.run());}
3410ff18f28971937bbe4e15b411b32719db38a1da8fd253cbcaefa5f679b99b
getTempFolder
protected File getTempFolder()
{    return this.tempFolder.getRoot();}
87ebba38af2731f68b99e3dc2fde09180ee382d93696f61bed7bbf1bc52721a6
createLogger
protected static Logger createLogger()
{    PropertyConfigurator.configure(ParquetFileTest.class.getResource("/cli-logging.properties"));    Logger console = LoggerFactory.getLogger(ParquetFileTest.class);    LogFactory.getFactory().setAttribute("org.apache.commons.logging.Log", "org.apache.commons.logging.impl.Log4JLogger");    return console;}
c536957a0359efaba4fa041a9429ed02027b66c9e6f5cc21d07eb308cc675a0d
setUp
public void setUp() throws IOException
{    createTestParquetFile();}
37a0c9fd39cdff5784aff70cb003f6c2002c6c3b670007a2a94eab170ebe9544
parquetFile
protected File parquetFile()
{    File tmpDir = getTempFolder();    return new File(tmpDir, getClass().getSimpleName() + ".parquet");}
386fc565be2c49649a48f2050cacbb32c5c3a90be45578f9ff9252cb28ae4b88
createSchema
private static MessageType createSchema()
{    return new MessageType("schema", new PrimitiveType(REQUIRED, PrimitiveTypeName.INT32, INT32_FIELD), new PrimitiveType(REQUIRED, PrimitiveTypeName.INT64, INT64_FIELD), new PrimitiveType(REQUIRED, PrimitiveTypeName.FLOAT, FLOAT_FIELD), new PrimitiveType(REQUIRED, PrimitiveTypeName.DOUBLE, DOUBLE_FIELD), new PrimitiveType(REQUIRED, PrimitiveTypeName.BINARY, BINARY_FIELD), new PrimitiveType(REQUIRED, PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY, 12, FIXED_LEN_BYTE_ARRAY_FIELD));}
e3ad3201d82b5c8ac372acaf1d909afbdb5d59095f929fb2d9800f2d30f28ac9
createTestParquetFile
private void createTestParquetFile() throws IOException
{    File file = parquetFile();    Path fsPath = new Path(file.getPath());    Configuration conf = new Configuration();    MessageType schema = createSchema();    SimpleGroupFactory fact = new SimpleGroupFactory(schema);    GroupWriteSupport.setSchema(schema, conf);    try (ParquetWriter<Group> writer = new ParquetWriter<>(fsPath, new GroupWriteSupport(), CompressionCodecName.UNCOMPRESSED, 1024, 1024, 512, true, false, ParquetProperties.WriterVersion.PARQUET_2_0, conf)) {        for (int i = 0; i < 10; i++) {            final byte[] bytes = new byte[12];            ThreadLocalRandom.current().nextBytes(bytes);            writer.write(fact.newGroup().append(INT32_FIELD, 32 + i).append(INT64_FIELD, 64L + i).append(FLOAT_FIELD, 1.0f + i).append(DOUBLE_FIELD, 2.0d + i).append(BINARY_FIELD, Binary.fromString(COLORS[i % COLORS.length])).append(FIXED_LEN_BYTE_ARRAY_FIELD, Binary.fromConstantByteArray(bytes)));        }    }}
e03a322951eb889514c808b615ff7950db3549d286cf3f5efea09d08ab723f03
testParquetMetadataCommand
public void testParquetMetadataCommand() throws IOException
{    File file = parquetFile();    ParquetMetadataCommand command = new ParquetMetadataCommand(createLogger());    command.targets = Arrays.asList(file.getAbsolutePath());    command.setConf(new Configuration());    Assert.assertEquals(0, command.run());}
75244f5dfb2e8de98a0c99223a6058b8bacf59ad2dfa1b8934dc9db77ab5e5ee
testSchemaCommand
public void testSchemaCommand() throws IOException
{    File file = parquetFile();    SchemaCommand command = new SchemaCommand(createLogger());    command.targets = Arrays.asList(file.getAbsolutePath());    command.setConf(new Configuration());    Assert.assertEquals(0, command.run());}
975e1b7a668bfd442c6f1a12bb4fea0cd813e92f114f979fa96cdc2ca19ea680
testShowColumnIndexCommand
public void testShowColumnIndexCommand() throws IOException
{    File file = parquetFile();    ShowColumnIndexCommand command = new ShowColumnIndexCommand(createLogger());    command.files = Arrays.asList(file.getAbsolutePath());    command.setConf(new Configuration());    Assert.assertEquals(0, command.run());}
aea6317c58851a9df63fc8213a163f913b58113975737673f2785d7ceb301c61
testShowDirectoryCommand
public void testShowDirectoryCommand() throws IOException
{    File file = parquetFile();    ShowDictionaryCommand command = new ShowDictionaryCommand(createLogger());    command.targets = Arrays.asList(file.getAbsolutePath());    command.column = BINARY_FIELD;    command.setConf(new Configuration());    Assert.assertEquals(0, command.run());}
4d3a8b2d28e3d4d884a94d06fa118244557840398c8b02c681500329241b6b23
testShowPagesCommand
public void testShowPagesCommand() throws IOException
{    File file = parquetFile();    ShowPagesCommand command = new ShowPagesCommand(createLogger());    command.targets = Arrays.asList(file.getAbsolutePath());    command.setConf(new Configuration());    Assert.assertEquals(0, command.run());}
6e7727903a9252212936df354fa404f7e21fb42f19c94aa92d59bd064d2e234d
testToAvroCommandFromParquet
public void testToAvroCommandFromParquet() throws IOException
{    File avroFile = toAvro(parquetFile());    Assert.assertTrue(avroFile.exists());}
6c936d6883325447c14f78b4ad3741f1f203268e9098d58f3313f6a5d1b1c3d9
testToAvroCommandFromJson
public void testToAvroCommandFromJson() throws IOException
{    final File jsonInputFile = folder.newFile("sample.json");    final File avroOutputFile = folder.newFile("sample.avro");        final String inputJson = "{\"id\": 1, \"name\": \"Alice\"}\n" + "{\"id\": 2, \"name\": \"Bob\"}\n" + "{\"id\": 3, \"name\": \"Carol\"}\n" + "{\"id\": 4, \"name\": \"Dave\"}";    try (BufferedWriter writer = new BufferedWriter(new FileWriter(jsonInputFile))) {        writer.write(inputJson);    }    ToAvroCommand cmd = new ToAvroCommand(null);    JCommander.newBuilder().addObject(cmd).build().parse(jsonInputFile.getAbsolutePath(), "--output", avroOutputFile.getAbsolutePath());    assert (cmd.run() == 0);}
6629e7575a266ed3ab277033ac4af651cc13e7c863c2e7e3dc87b7f8a84b962b
testToAvroCommandWithGzipCompression
public void testToAvroCommandWithGzipCompression() throws IOException
{    File avroFile = toAvro(parquetFile(), "GZIP");    Assert.assertTrue(avroFile.exists());}
31c88a2da562b3df1ff308594cca42b01a471805aee12addde5989908944d0cc
testToAvroCommandWithSnappyCompression
public void testToAvroCommandWithSnappyCompression() throws IOException
{    File avroFile = toAvro(parquetFile(), "SNAPPY");    Assert.assertTrue(avroFile.exists());}
5241dfbd98c60de7cf98341f2d21e80ce80c2b16e3e9f3416cf06c0f1dbadd28
testToAvroCommandWithZstdCompression
public void testToAvroCommandWithZstdCompression() throws IOException
{    File avroFile = toAvro(parquetFile(), "ZSTD");    Assert.assertTrue(avroFile.exists());}
fb864086a69a83e22daa0a3eca4e793f23f3d3574e9c9ebfd343c0c757d2d954
testToAvroCommandWithInvalidCompression
public void testToAvroCommandWithInvalidCompression() throws IOException
{    toAvro(parquetFile(), "FOO");}
df77ed6fa6a5b89191a0e0957e38f2dfa38c7c2f0816d4843bd22879608c3580
getPath
public String[] getPath()
{    return path;}
4bbcfb13c2121b3592501ec57819be357f998cc42f9b924a1cae525baf53426f
getMaxRepetitionLevel
public int getMaxRepetitionLevel()
{    return maxRep;}
60f121644a16be824062d173f628205c4920d8b233b821753106f713fbe0e3c4
getMaxDefinitionLevel
public int getMaxDefinitionLevel()
{    return maxDef;}
33863a388ceaa73f61f42ed255644025c13814df9196ccfe0d910ea0eaa4c759
getType
public PrimitiveTypeName getType()
{    return type.getPrimitiveTypeName();}
8ac76fd8edc40c354d5e8f3ab38abc789c351b489792e4a4341b58f445bb5490
getTypeLength
public int getTypeLength()
{    return type.getTypeLength();}
dd7ba3358cd4c70fde4174e96da32193c06dbf7a02da2ad4e78d38a9f53e7065
getPrimitiveType
public PrimitiveType getPrimitiveType()
{    return type;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return Arrays.hashCode(path);}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    if (other == this)        return true;    if (!(other instanceof ColumnDescriptor))        return false;    ColumnDescriptor descriptor = (ColumnDescriptor) other;    return Arrays.equals(path, descriptor.path);}
726cef862446229a643449893360b0d72bba7d4a9a3b9f8e2e8af9786b19ec89
compareTo
public int compareTo(ColumnDescriptor o)
{    int length = path.length < o.path.length ? path.length : o.path.length;    for (int i = 0; i < length; i++) {        int compareTo = path[i].compareTo(o.path[i]);        if (compareTo != 0) {            return compareTo;        }    }    return path.length - o.path.length;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return Arrays.toString(path) + " " + type;}
fe673517ec8ae382c56e8fa50674773b10b7339cd7bef671f6c0135b7b48c651
isColumnFlushNeeded
 boolean isColumnFlushNeeded()
{    return false;}
3d8ee53ad91e9129f673687f3d9fcb3f058bc5dc228085fdcc174f07e9247418
getEncoding
public Encoding getEncoding()
{    return encoding;}
b00e20c49a32493ce96ac3b89f88c9a13234490f84b0fbfdec93097eeb85ec08
decodeToBinary
public Binary decodeToBinary(int id)
{    throw new UnsupportedOperationException(this.getClass().getName());}
caae8c699f20855cb64238fe71be69fd13a6827032cb3487c492c4f3b959bc01
decodeToInt
public int decodeToInt(int id)
{    throw new UnsupportedOperationException(this.getClass().getName());}
b5a7b61bd38029ed0086954c8ee8bcfebb82fdea35be39bf9fd37e017d559192
decodeToLong
public long decodeToLong(int id)
{    throw new UnsupportedOperationException(this.getClass().getName());}
33a64d0d3ef4ee2cb0d0804e6f57c749fb04087526df2d648737714c60ba842e
decodeToFloat
public float decodeToFloat(int id)
{    throw new UnsupportedOperationException(this.getClass().getName());}
898abecc3f64d2e322d4edddeb13ff3701ae7e4df4d59819aca79c856dde6c37
decodeToDouble
public double decodeToDouble(int id)
{    throw new UnsupportedOperationException(this.getClass().getName());}
bedfbf7cbc3493c4825cccffa909ca31c2202ad7d8a4fa9d8836bdf96df302da
decodeToBoolean
public boolean decodeToBoolean(int id)
{    throw new UnsupportedOperationException(this.getClass().getName());}
fb9e1b0a10a280f6671aa9ec43977ecc0a0899a8a5c59477dc592c086724737e
getMaxLevel
 int getMaxLevel(ColumnDescriptor descriptor, ValuesType valuesType)
{    int maxLevel;    switch(valuesType) {        case REPETITION_LEVEL:            maxLevel = descriptor.getMaxRepetitionLevel();            break;        case DEFINITION_LEVEL:            maxLevel = descriptor.getMaxDefinitionLevel();            break;        case VALUES:            if (descriptor.getType() == BOOLEAN) {                maxLevel = 1;                break;            }        default:            throw new ParquetDecodingException("Unsupported encoding for values: " + this);    }    return maxLevel;}
1dc1b60dc0bf4383db8e94e3fb7d7306e816c7744cf09018e9d204f3cba7c457
usesDictionary
public boolean usesDictionary()
{    return false;}
191bd67679dcde6fd68ccfd3243ac675f7ca0d9e0d5d846052a4b4623ef27485
initDictionary
public Dictionary initDictionary(ColumnDescriptor descriptor, DictionaryPage dictionaryPage) throws IOException
{    throw new UnsupportedOperationException(this.name() + " does not support dictionary");}
e5d0867ef1de30d03ade1809516f30f0aea5e2a48d13b6209b108934ce4fbb75
getValuesReader
public ValuesReader getValuesReader(ColumnDescriptor descriptor, ValuesType valuesType)
{    throw new UnsupportedOperationException("Error decoding " + descriptor + ". " + this.name() + " is dictionary based");}
ff34e8cb7399e6d3a8ab60b0af9beff341289e20121bd289471616c742cd6a8e
getDictionaryBasedValuesReader
public ValuesReader getDictionaryBasedValuesReader(ColumnDescriptor descriptor, ValuesType valuesType, Dictionary dictionary)
{    throw new UnsupportedOperationException(this.name() + " is not dictionary based");}
e5d0867ef1de30d03ade1809516f30f0aea5e2a48d13b6209b108934ce4fbb75
getValuesReader
public ValuesReader getValuesReader(ColumnDescriptor descriptor, ValuesType valuesType)
{    switch(descriptor.getType()) {        case BOOLEAN:            return new BooleanPlainValuesReader();        case BINARY:            return new BinaryPlainValuesReader();        case FLOAT:            return new FloatPlainValuesReader();        case DOUBLE:            return new DoublePlainValuesReader();        case INT32:            return new IntegerPlainValuesReader();        case INT64:            return new LongPlainValuesReader();        case INT96:            return new FixedLenByteArrayPlainValuesReader(12);        case FIXED_LEN_BYTE_ARRAY:            return new FixedLenByteArrayPlainValuesReader(descriptor.getTypeLength());        default:            throw new ParquetDecodingException("no plain reader for type " + descriptor.getType());    }}
191bd67679dcde6fd68ccfd3243ac675f7ca0d9e0d5d846052a4b4623ef27485
initDictionary
public Dictionary initDictionary(ColumnDescriptor descriptor, DictionaryPage dictionaryPage) throws IOException
{    switch(descriptor.getType()) {        case BINARY:            return new PlainBinaryDictionary(dictionaryPage);        case FIXED_LEN_BYTE_ARRAY:            return new PlainBinaryDictionary(dictionaryPage, descriptor.getTypeLength());        case INT96:            return new PlainBinaryDictionary(dictionaryPage, 12);        case INT64:            return new PlainLongDictionary(dictionaryPage);        case DOUBLE:            return new PlainDoubleDictionary(dictionaryPage);        case INT32:            return new PlainIntegerDictionary(dictionaryPage);        case FLOAT:            return new PlainFloatDictionary(dictionaryPage);        default:            throw new ParquetDecodingException("Dictionary encoding not supported for type: " + descriptor.getType());    }}
e5d0867ef1de30d03ade1809516f30f0aea5e2a48d13b6209b108934ce4fbb75
getValuesReader
public ValuesReader getValuesReader(ColumnDescriptor descriptor, ValuesType valuesType)
{    int bitWidth = BytesUtils.getWidthFromMaxInt(getMaxLevel(descriptor, valuesType));    if (bitWidth == 0) {        return new ZeroIntegerValuesReader();    }    return new RunLengthBitPackingHybridValuesReader(bitWidth);}
e5d0867ef1de30d03ade1809516f30f0aea5e2a48d13b6209b108934ce4fbb75
getValuesReader
public ValuesReader getValuesReader(ColumnDescriptor descriptor, ValuesType valuesType)
{    return new ByteBitPackingValuesReader(getMaxLevel(descriptor, valuesType), BIG_ENDIAN);}
ff34e8cb7399e6d3a8ab60b0af9beff341289e20121bd289471616c742cd6a8e
getDictionaryBasedValuesReader
public ValuesReader getDictionaryBasedValuesReader(ColumnDescriptor descriptor, ValuesType valuesType, Dictionary dictionary)
{    return RLE_DICTIONARY.getDictionaryBasedValuesReader(descriptor, valuesType, dictionary);}
191bd67679dcde6fd68ccfd3243ac675f7ca0d9e0d5d846052a4b4623ef27485
initDictionary
public Dictionary initDictionary(ColumnDescriptor descriptor, DictionaryPage dictionaryPage) throws IOException
{    return PLAIN.initDictionary(descriptor, dictionaryPage);}
1dc1b60dc0bf4383db8e94e3fb7d7306e816c7744cf09018e9d204f3cba7c457
usesDictionary
public boolean usesDictionary()
{    return true;}
e5d0867ef1de30d03ade1809516f30f0aea5e2a48d13b6209b108934ce4fbb75
getValuesReader
public ValuesReader getValuesReader(ColumnDescriptor descriptor, ValuesType valuesType)
{    if (descriptor.getType() != INT32 && descriptor.getType() != INT64) {        throw new ParquetDecodingException("Encoding DELTA_BINARY_PACKED is only supported for type INT32 and INT64");    }    return new DeltaBinaryPackingValuesReader();}
e5d0867ef1de30d03ade1809516f30f0aea5e2a48d13b6209b108934ce4fbb75
getValuesReader
public ValuesReader getValuesReader(ColumnDescriptor descriptor, ValuesType valuesType)
{    if (descriptor.getType() != BINARY) {        throw new ParquetDecodingException("Encoding DELTA_LENGTH_BYTE_ARRAY is only supported for type BINARY");    }    return new DeltaLengthByteArrayValuesReader();}
e5d0867ef1de30d03ade1809516f30f0aea5e2a48d13b6209b108934ce4fbb75
getValuesReader
public ValuesReader getValuesReader(ColumnDescriptor descriptor, ValuesType valuesType)
{    if (descriptor.getType() != BINARY && descriptor.getType() != FIXED_LEN_BYTE_ARRAY) {        throw new ParquetDecodingException("Encoding DELTA_BYTE_ARRAY is only supported for type BINARY and FIXED_LEN_BYTE_ARRAY");    }    return new DeltaByteArrayReader();}
ff34e8cb7399e6d3a8ab60b0af9beff341289e20121bd289471616c742cd6a8e
getDictionaryBasedValuesReader
public ValuesReader getDictionaryBasedValuesReader(ColumnDescriptor descriptor, ValuesType valuesType, Dictionary dictionary)
{    switch(descriptor.getType()) {        case BINARY:        case FIXED_LEN_BYTE_ARRAY:        case INT96:        case INT64:        case DOUBLE:        case INT32:        case FLOAT:            return new DictionaryValuesReader(dictionary);        default:            throw new ParquetDecodingException("Dictionary encoding not supported for type: " + descriptor.getType());    }}
1dc1b60dc0bf4383db8e94e3fb7d7306e816c7744cf09018e9d204f3cba7c457
usesDictionary
public boolean usesDictionary()
{    return true;}
ae1572943e123f687969e8b72f4e3762a764f375021aac4bb49bf5acaff2b7ef
getDictionaryEncodings
public Set<Encoding> getDictionaryEncodings()
{    return dictStats.keySet();}
bfd33c3dd7d5227331fa76a87b7dfeb0235d72e5b0aaa42e124f9f879f38228c
getDataEncodings
public Set<Encoding> getDataEncodings()
{    return dataStats.keySet();}
1fa86d8268c54ac5a386af6571593003e9440285833e76ce33e52be18f1fda29
getNumDictionaryPagesEncodedAs
public int getNumDictionaryPagesEncodedAs(Encoding enc)
{    if (dictStats.containsKey(enc)) {        return dictStats.get(enc);    } else {        return 0;    }}
4d4167e6bd2603c2e5357c43b3cad85b9b5246700eb2a96217a3a8e985e92560
getNumDataPagesEncodedAs
public int getNumDataPagesEncodedAs(Encoding enc)
{    if (dataStats.containsKey(enc)) {        return dataStats.get(enc);    } else {        return 0;    }}
721f3e049c3de435d9ff4b7691d29da663708892de17a0a0f18e88b67fd8aaa8
hasDictionaryPages
public boolean hasDictionaryPages()
{    return !dictStats.isEmpty();}
3dad07a08e48966ca64fd51c0dd0201caa36d45da03663322702d53288682788
hasDictionaryEncodedPages
public boolean hasDictionaryEncodedPages()
{    Set<Encoding> encodings = dataStats.keySet();    return (encodings.contains(RLE_DICTIONARY) || encodings.contains(PLAIN_DICTIONARY));}
2c6a3a7fac26c8d08b7e9042d64a6ef2f0610520229d7f0b6846410a610b1d43
hasNonDictionaryEncodedPages
public boolean hasNonDictionaryEncodedPages()
{    if (dataStats.isEmpty()) {                return false;    }        Set<Encoding> encodings = new HashSet<Encoding>(dataStats.keySet());    if (!encodings.remove(RLE_DICTIONARY) && !encodings.remove(PLAIN_DICTIONARY)) {                return true;    }    if (encodings.isEmpty()) {        return false;    }        return true;}
1250d538c4a77530ad8124fbe0fbcc0b8e4bfa0ae6aefd02b3b45281761414ed
usesV2Pages
public boolean usesV2Pages()
{    return usesV2Pages;}
7930c451f279d9927ff235e4ac064561e1505f9b7ae117d9f681b345534ff9e3
clear
public Builder clear()
{    this.usesV2Pages = false;    dictStats.clear();    dataStats.clear();    return this;}
f19386634c2d1aebe08bb8c6fdd3478136b7cd5e12dd94669dc82f63ddac0088
withV2Pages
public Builder withV2Pages()
{    this.usesV2Pages = true;    return this;}
3f61ba9785bba262c72bce8e5d3931abe36684e1e401f932e8b5914b502c29ed
addDictEncoding
public Builder addDictEncoding(Encoding encoding)
{    return addDictEncoding(encoding, 1);}
29c7865c76471d3393f926f0fb8818d13fff5a352e172b6ed0d190879a229dab
addDictEncoding
public Builder addDictEncoding(Encoding encoding, int numPages)
{    Integer pages = dictStats.get(encoding);    dictStats.put(encoding, numPages + (pages != null ? pages : 0));    return this;}
7b7f6bba04d64c12f5e905a5b4df538e430fa79dfb12380f4e2c08172a8bca1f
addDataEncodings
public Builder addDataEncodings(Collection<Encoding> encodings)
{    for (Encoding encoding : encodings) {        addDataEncoding(encoding);    }    return this;}
19fdac8df45f4343e625c66ac0934e1e3693309ccc490e8d0e494718b51d2437
addDataEncoding
public Builder addDataEncoding(Encoding encoding)
{    return addDataEncoding(encoding, 1);}
04d012567fc7d67a4e989b1af6a2bba275676ab3737b37f8ff72dff5f1ed2cf1
addDataEncoding
public Builder addDataEncoding(Encoding encoding, int numPages)
{    Integer pages = dataStats.get(encoding);    dataStats.put(encoding, numPages + (pages != null ? pages : 0));    return this;}
ae3e0c07faec8639674179488bb86494c3e04994fb45dc6c6a14847c72865664
build
public EncodingStats build()
{    return new EncodingStats(Collections.unmodifiableMap(new LinkedHashMap<Encoding, Integer>(dictStats)), Collections.unmodifiableMap(new LinkedHashMap<Encoding, Integer>(dataStats)), usesV2Pages);}
fe29c56bce64162461f01944cc1b338850e3d4b2b021be322ecf337a9e03d42f
getDictionaryId
public int getDictionaryId()
{    throw new UnsupportedOperationException();}
bba4ad1e0d7fde16938e3092d7ee00bd94f6edb268f1b0b7927bf2ada4410224
getInteger
public int getInteger()
{    throw new UnsupportedOperationException();}
9c78019fc3aab731a329d8a65bf42ad673e51e48f8d63cf0a35f18fdfe6787f2
getBoolean
public boolean getBoolean()
{    throw new UnsupportedOperationException();}
aa8a7e95569508772b5a86c662e4e16f24d5d8b09b7c2a751260288d63aa45ff
getLong
public long getLong()
{    throw new UnsupportedOperationException();}
fd68727d3aeb8910ee68424dda540731d6f823400b40902c0535e9527a64331d
getBinary
public Binary getBinary()
{    throw new UnsupportedOperationException();}
ee9a51dbf95b211d37a60138ffb4deb11942d61f5c9721afa1016727fb401415
getFloat
public float getFloat()
{    throw new UnsupportedOperationException();}
95f35c6fbf999bf94e0a9c9c5fa482ed65318ab2572fb3b51e8c181fc2611e97
getDouble
public double getDouble()
{    throw new UnsupportedOperationException();}
37896c8a714a767ece2c56f09fb5ce6d8bb5a886d40519571c7a5958b5ac78e8
bindToDictionary
private void bindToDictionary(final Dictionary dictionary)
{    binding = new Binding() {        void read() {            dictionaryId = dataColumn.readValueDictionaryId();        }        public void skip() {            dataColumn.skip();        }        @Override        void skip(int n) {            dataColumn.skip(n);        }        public int getDictionaryId() {            return dictionaryId;        }        void writeValue() {            converter.addValueFromDictionary(dictionaryId);        }        public int getInteger() {            return dictionary.decodeToInt(dictionaryId);        }        public boolean getBoolean() {            return dictionary.decodeToBoolean(dictionaryId);        }        public long getLong() {            return dictionary.decodeToLong(dictionaryId);        }        public Binary getBinary() {            return dictionary.decodeToBinary(dictionaryId);        }        public float getFloat() {            return dictionary.decodeToFloat(dictionaryId);        }        public double getDouble() {            return dictionary.decodeToDouble(dictionaryId);        }    };}
611fbfc30fc7123b26ef1b23b6fbe7bc58ae5110c7bbd2871941b529adb9b598
read
 void read()
{    dictionaryId = dataColumn.readValueDictionaryId();}
895e92fa2273cdf5e5c97c44b286ea867f7a7e0a6106c85286a4176e76e78d9d
skip
public void skip()
{    dataColumn.skip();}
40bff8a8ecb3b8b5244ac2a7ae1210f7a0a7940c011e725d75fc3f7925b11c6a
skip
 void skip(int n)
{    dataColumn.skip(n);}
fe29c56bce64162461f01944cc1b338850e3d4b2b021be322ecf337a9e03d42f
getDictionaryId
public int getDictionaryId()
{    return dictionaryId;}
2646844b7e9e0b3f91f8c73cf24a957a621aa47c239224606186f978014f44fd
writeValue
 void writeValue()
{    converter.addValueFromDictionary(dictionaryId);}
bba4ad1e0d7fde16938e3092d7ee00bd94f6edb268f1b0b7927bf2ada4410224
getInteger
public int getInteger()
{    return dictionary.decodeToInt(dictionaryId);}
9c78019fc3aab731a329d8a65bf42ad673e51e48f8d63cf0a35f18fdfe6787f2
getBoolean
public boolean getBoolean()
{    return dictionary.decodeToBoolean(dictionaryId);}
aa8a7e95569508772b5a86c662e4e16f24d5d8b09b7c2a751260288d63aa45ff
getLong
public long getLong()
{    return dictionary.decodeToLong(dictionaryId);}
fd68727d3aeb8910ee68424dda540731d6f823400b40902c0535e9527a64331d
getBinary
public Binary getBinary()
{    return dictionary.decodeToBinary(dictionaryId);}
ee9a51dbf95b211d37a60138ffb4deb11942d61f5c9721afa1016727fb401415
getFloat
public float getFloat()
{    return dictionary.decodeToFloat(dictionaryId);}
95f35c6fbf999bf94e0a9c9c5fa482ed65318ab2572fb3b51e8c181fc2611e97
getDouble
public double getDouble()
{    return dictionary.decodeToDouble(dictionaryId);}
b942e0349a893bb4a99732852b83ce12fed56d25e8267eeed9b1b16c785064d8
bind
private void bind(PrimitiveTypeName type)
{    binding = type.convert(new PrimitiveTypeNameConverter<Binding, RuntimeException>() {        @Override        public Binding convertFLOAT(PrimitiveTypeName primitiveTypeName) throws RuntimeException {            return new Binding() {                float current;                void read() {                    current = dataColumn.readFloat();                }                public void skip() {                    current = 0;                    dataColumn.skip();                }                @Override                void skip(int n) {                    current = 0;                    dataColumn.skip(n);                }                public float getFloat() {                    return current;                }                void writeValue() {                    converter.addFloat(current);                }            };        }        @Override        public Binding convertDOUBLE(PrimitiveTypeName primitiveTypeName) throws RuntimeException {            return new Binding() {                double current;                void read() {                    current = dataColumn.readDouble();                }                public void skip() {                    current = 0;                    dataColumn.skip();                }                @Override                void skip(int n) {                    current = 0;                    dataColumn.skip(n);                }                public double getDouble() {                    return current;                }                void writeValue() {                    converter.addDouble(current);                }            };        }        @Override        public Binding convertINT32(PrimitiveTypeName primitiveTypeName) throws RuntimeException {            return new Binding() {                int current;                void read() {                    current = dataColumn.readInteger();                }                public void skip() {                    current = 0;                    dataColumn.skip();                }                @Override                void skip(int n) {                    current = 0;                    dataColumn.skip(n);                }                @Override                public int getInteger() {                    return current;                }                void writeValue() {                    converter.addInt(current);                }            };        }        @Override        public Binding convertINT64(PrimitiveTypeName primitiveTypeName) throws RuntimeException {            return new Binding() {                long current;                void read() {                    current = dataColumn.readLong();                }                public void skip() {                    current = 0;                    dataColumn.skip();                }                @Override                void skip(int n) {                    current = 0;                    dataColumn.skip(n);                }                @Override                public long getLong() {                    return current;                }                void writeValue() {                    converter.addLong(current);                }            };        }        @Override        public Binding convertINT96(PrimitiveTypeName primitiveTypeName) throws RuntimeException {            return this.convertBINARY(primitiveTypeName);        }        @Override        public Binding convertFIXED_LEN_BYTE_ARRAY(PrimitiveTypeName primitiveTypeName) throws RuntimeException {            return this.convertBINARY(primitiveTypeName);        }        @Override        public Binding convertBOOLEAN(PrimitiveTypeName primitiveTypeName) throws RuntimeException {            return new Binding() {                boolean current;                void read() {                    current = dataColumn.readBoolean();                }                public void skip() {                    current = false;                    dataColumn.skip();                }                @Override                void skip(int n) {                    current = false;                    dataColumn.skip(n);                }                @Override                public boolean getBoolean() {                    return current;                }                void writeValue() {                    converter.addBoolean(current);                }            };        }        @Override        public Binding convertBINARY(PrimitiveTypeName primitiveTypeName) throws RuntimeException {            return new Binding() {                Binary current;                void read() {                    current = dataColumn.readBytes();                }                public void skip() {                    current = null;                    dataColumn.skip();                }                @Override                void skip(int n) {                    current = null;                    dataColumn.skip(n);                }                @Override                public Binary getBinary() {                    return current;                }                void writeValue() {                    converter.addBinary(current);                }            };        }    });}
176b568f98fc4c0fc7ae379bcb3fe6eed06535bceee80ed7a9dfe0f48f991e62
convertFLOAT
public Binding convertFLOAT(PrimitiveTypeName primitiveTypeName) throws RuntimeException
{    return new Binding() {        float current;        void read() {            current = dataColumn.readFloat();        }        public void skip() {            current = 0;            dataColumn.skip();        }        @Override        void skip(int n) {            current = 0;            dataColumn.skip(n);        }        public float getFloat() {            return current;        }        void writeValue() {            converter.addFloat(current);        }    };}
611fbfc30fc7123b26ef1b23b6fbe7bc58ae5110c7bbd2871941b529adb9b598
read
 void read()
{    current = dataColumn.readFloat();}
895e92fa2273cdf5e5c97c44b286ea867f7a7e0a6106c85286a4176e76e78d9d
skip
public void skip()
{    current = 0;    dataColumn.skip();}
40bff8a8ecb3b8b5244ac2a7ae1210f7a0a7940c011e725d75fc3f7925b11c6a
skip
 void skip(int n)
{    current = 0;    dataColumn.skip(n);}
ee9a51dbf95b211d37a60138ffb4deb11942d61f5c9721afa1016727fb401415
getFloat
public float getFloat()
{    return current;}
2646844b7e9e0b3f91f8c73cf24a957a621aa47c239224606186f978014f44fd
writeValue
 void writeValue()
{    converter.addFloat(current);}
56332e9780977dff7202034aa61b57743db1f4001617219b0a606f51122ebdb1
convertDOUBLE
public Binding convertDOUBLE(PrimitiveTypeName primitiveTypeName) throws RuntimeException
{    return new Binding() {        double current;        void read() {            current = dataColumn.readDouble();        }        public void skip() {            current = 0;            dataColumn.skip();        }        @Override        void skip(int n) {            current = 0;            dataColumn.skip(n);        }        public double getDouble() {            return current;        }        void writeValue() {            converter.addDouble(current);        }    };}
611fbfc30fc7123b26ef1b23b6fbe7bc58ae5110c7bbd2871941b529adb9b598
read
 void read()
{    current = dataColumn.readDouble();}
895e92fa2273cdf5e5c97c44b286ea867f7a7e0a6106c85286a4176e76e78d9d
skip
public void skip()
{    current = 0;    dataColumn.skip();}
40bff8a8ecb3b8b5244ac2a7ae1210f7a0a7940c011e725d75fc3f7925b11c6a
skip
 void skip(int n)
{    current = 0;    dataColumn.skip(n);}
95f35c6fbf999bf94e0a9c9c5fa482ed65318ab2572fb3b51e8c181fc2611e97
getDouble
public double getDouble()
{    return current;}
2646844b7e9e0b3f91f8c73cf24a957a621aa47c239224606186f978014f44fd
writeValue
 void writeValue()
{    converter.addDouble(current);}
f7a0b0ce2c40513849c6b206483ebb229d3ec637af270cfffa08e0ee79e7fcd2
convertINT32
public Binding convertINT32(PrimitiveTypeName primitiveTypeName) throws RuntimeException
{    return new Binding() {        int current;        void read() {            current = dataColumn.readInteger();        }        public void skip() {            current = 0;            dataColumn.skip();        }        @Override        void skip(int n) {            current = 0;            dataColumn.skip(n);        }        @Override        public int getInteger() {            return current;        }        void writeValue() {            converter.addInt(current);        }    };}
611fbfc30fc7123b26ef1b23b6fbe7bc58ae5110c7bbd2871941b529adb9b598
read
 void read()
{    current = dataColumn.readInteger();}
895e92fa2273cdf5e5c97c44b286ea867f7a7e0a6106c85286a4176e76e78d9d
skip
public void skip()
{    current = 0;    dataColumn.skip();}
40bff8a8ecb3b8b5244ac2a7ae1210f7a0a7940c011e725d75fc3f7925b11c6a
skip
 void skip(int n)
{    current = 0;    dataColumn.skip(n);}
bba4ad1e0d7fde16938e3092d7ee00bd94f6edb268f1b0b7927bf2ada4410224
getInteger
public int getInteger()
{    return current;}
2646844b7e9e0b3f91f8c73cf24a957a621aa47c239224606186f978014f44fd
writeValue
 void writeValue()
{    converter.addInt(current);}
d202efc7d6fcb5e1496bb34c551a5904691c2fc7c41d2a13e943ee060a48ade4
convertINT64
public Binding convertINT64(PrimitiveTypeName primitiveTypeName) throws RuntimeException
{    return new Binding() {        long current;        void read() {            current = dataColumn.readLong();        }        public void skip() {            current = 0;            dataColumn.skip();        }        @Override        void skip(int n) {            current = 0;            dataColumn.skip(n);        }        @Override        public long getLong() {            return current;        }        void writeValue() {            converter.addLong(current);        }    };}
611fbfc30fc7123b26ef1b23b6fbe7bc58ae5110c7bbd2871941b529adb9b598
read
 void read()
{    current = dataColumn.readLong();}
895e92fa2273cdf5e5c97c44b286ea867f7a7e0a6106c85286a4176e76e78d9d
skip
public void skip()
{    current = 0;    dataColumn.skip();}
40bff8a8ecb3b8b5244ac2a7ae1210f7a0a7940c011e725d75fc3f7925b11c6a
skip
 void skip(int n)
{    current = 0;    dataColumn.skip(n);}
aa8a7e95569508772b5a86c662e4e16f24d5d8b09b7c2a751260288d63aa45ff
getLong
public long getLong()
{    return current;}
2646844b7e9e0b3f91f8c73cf24a957a621aa47c239224606186f978014f44fd
writeValue
 void writeValue()
{    converter.addLong(current);}
b4043a34136b9f7ad53bbef1cf7131c846105b97e425146c7dcd5f82bed1a8e1
convertINT96
public Binding convertINT96(PrimitiveTypeName primitiveTypeName) throws RuntimeException
{    return this.convertBINARY(primitiveTypeName);}
7f5c75b072c1db369b4bd5a7f45e6d75051c4544c4261d0a1c7f62824c47e22c
convertFIXED_LEN_BYTE_ARRAY
public Binding convertFIXED_LEN_BYTE_ARRAY(PrimitiveTypeName primitiveTypeName) throws RuntimeException
{    return this.convertBINARY(primitiveTypeName);}
e23c663db9485ee1add7d80721494ece5ef8f9412c29b27ec68f62d6c6cb5521
convertBOOLEAN
public Binding convertBOOLEAN(PrimitiveTypeName primitiveTypeName) throws RuntimeException
{    return new Binding() {        boolean current;        void read() {            current = dataColumn.readBoolean();        }        public void skip() {            current = false;            dataColumn.skip();        }        @Override        void skip(int n) {            current = false;            dataColumn.skip(n);        }        @Override        public boolean getBoolean() {            return current;        }        void writeValue() {            converter.addBoolean(current);        }    };}
611fbfc30fc7123b26ef1b23b6fbe7bc58ae5110c7bbd2871941b529adb9b598
read
 void read()
{    current = dataColumn.readBoolean();}
895e92fa2273cdf5e5c97c44b286ea867f7a7e0a6106c85286a4176e76e78d9d
skip
public void skip()
{    current = false;    dataColumn.skip();}
40bff8a8ecb3b8b5244ac2a7ae1210f7a0a7940c011e725d75fc3f7925b11c6a
skip
 void skip(int n)
{    current = false;    dataColumn.skip(n);}
9c78019fc3aab731a329d8a65bf42ad673e51e48f8d63cf0a35f18fdfe6787f2
getBoolean
public boolean getBoolean()
{    return current;}
2646844b7e9e0b3f91f8c73cf24a957a621aa47c239224606186f978014f44fd
writeValue
 void writeValue()
{    converter.addBoolean(current);}
c99ee2d1669804cff0ee9d012b63adc6b2037175bddd164203dd2b0058359f9d
convertBINARY
public Binding convertBINARY(PrimitiveTypeName primitiveTypeName) throws RuntimeException
{    return new Binding() {        Binary current;        void read() {            current = dataColumn.readBytes();        }        public void skip() {            current = null;            dataColumn.skip();        }        @Override        void skip(int n) {            current = null;            dataColumn.skip(n);        }        @Override        public Binary getBinary() {            return current;        }        void writeValue() {            converter.addBinary(current);        }    };}
611fbfc30fc7123b26ef1b23b6fbe7bc58ae5110c7bbd2871941b529adb9b598
read
 void read()
{    current = dataColumn.readBytes();}
895e92fa2273cdf5e5c97c44b286ea867f7a7e0a6106c85286a4176e76e78d9d
skip
public void skip()
{    current = null;    dataColumn.skip();}
40bff8a8ecb3b8b5244ac2a7ae1210f7a0a7940c011e725d75fc3f7925b11c6a
skip
 void skip(int n)
{    current = null;    dataColumn.skip(n);}
fd68727d3aeb8910ee68424dda540731d6f823400b40902c0535e9527a64331d
getBinary
public Binary getBinary()
{    return current;}
2646844b7e9e0b3f91f8c73cf24a957a621aa47c239224606186f978014f44fd
writeValue
 void writeValue()
{    converter.addBinary(current);}
1394313d52d86dedcb9281dc3405db2200f57005bb388553348e1a555f6f415f
isFullyConsumed
 boolean isFullyConsumed()
{    return readValues >= totalValueCount;}
800edc9609d40aa600ba99177c6b410bb4ca7568a04ae91a9aa9c7df56919800
writeCurrentValueToConverter
public void writeCurrentValueToConverter()
{    readValue();    this.binding.writeValue();}
0e6de59b2646c1cf8e69863af67f28e621cebd5f0c79cb0b0153d1ca84f20651
getCurrentValueDictionaryID
public int getCurrentValueDictionaryID()
{    readValue();    return binding.getDictionaryId();}
bba4ad1e0d7fde16938e3092d7ee00bd94f6edb268f1b0b7927bf2ada4410224
getInteger
public int getInteger()
{    readValue();    return this.binding.getInteger();}
9c78019fc3aab731a329d8a65bf42ad673e51e48f8d63cf0a35f18fdfe6787f2
getBoolean
public boolean getBoolean()
{    readValue();    return this.binding.getBoolean();}
aa8a7e95569508772b5a86c662e4e16f24d5d8b09b7c2a751260288d63aa45ff
getLong
public long getLong()
{    readValue();    return this.binding.getLong();}
fd68727d3aeb8910ee68424dda540731d6f823400b40902c0535e9527a64331d
getBinary
public Binary getBinary()
{    readValue();    return this.binding.getBinary();}
ee9a51dbf95b211d37a60138ffb4deb11942d61f5c9721afa1016727fb401415
getFloat
public float getFloat()
{    readValue();    return this.binding.getFloat();}
95f35c6fbf999bf94e0a9c9c5fa482ed65318ab2572fb3b51e8c181fc2611e97
getDouble
public double getDouble()
{    readValue();    return this.binding.getDouble();}
580e9c2936496c72c779745223f69c842d44879bcd7b51a49aa8f041609d251a
getCurrentRepetitionLevel
public int getCurrentRepetitionLevel()
{    return repetitionLevel;}
25bb4a2830d89627604ab65acf17e87089425b783110ac57cf189bfd3e72cc4f
getDescriptor
public ColumnDescriptor getDescriptor()
{    return path;}
c2b1850c3eea57ef25577200135dd93ccd20c41407766caeae209a2227f1a4d4
readValue
public void readValue()
{    try {        if (!valueRead) {            binding.read();            valueRead = true;        }    } catch (RuntimeException e) {        if (CorruptDeltaByteArrays.requiresSequentialReads(writerVersion, currentEncoding) && e instanceof ArrayIndexOutOfBoundsException) {                        throw new ParquetDecodingException("Read failure possibly due to " + "PARQUET-246: try setting parquet.split.files to false", new ParquetDecodingException(format("Can't read value in column %s at value %d out of %d, " + "%d out of %d in currentPage. repetition level: " + "%d, definition level: %d", path, readValues, totalValueCount, readValues - (endOfPageValueCount - pageValueCount), pageValueCount, repetitionLevel, definitionLevel), e));        }        throw new ParquetDecodingException(format("Can't read value in column %s at value %d out of %d, " + "%d out of %d in currentPage. repetition level: " + "%d, definition level: %d", path, readValues, totalValueCount, readValues - (endOfPageValueCount - pageValueCount), pageValueCount, repetitionLevel, definitionLevel), e);    }}
895e92fa2273cdf5e5c97c44b286ea867f7a7e0a6106c85286a4176e76e78d9d
skip
public void skip()
{    if (!valueRead) {        binding.skip();        valueRead = true;    }}
6663b94bbed76cf15b148f93a22b7c85c5e9a7546dd4f9cea5f7e31bdc69c2ab
getCurrentDefinitionLevel
public int getCurrentDefinitionLevel()
{    return definitionLevel;}
c14a40ca9b9ea6e9e4f70d3b30ef4bbc4e4b0fc45a47306701b7292666de6143
checkRead
private void checkRead()
{    int rl, dl;    int skipValues = 0;    for (; ; ) {        if (isPageFullyConsumed()) {            if (isFullyConsumed()) {                LOG.debug("end reached");                                repetitionLevel = 0;                return;            }            readPage();            skipValues = 0;        }        rl = repetitionLevelColumn.nextInt();        dl = definitionLevelColumn.nextInt();        ++readValues;        if (!skipRL(rl)) {            break;        }        if (dl == maxDefinitionLevel) {            ++skipValues;        }    }    binding.skip(skipValues);    repetitionLevel = rl;    definitionLevel = dl;}
e2f9b7e472ac1d1b54f575f8b9c288857eb1193e631f1bf385259cbbd2e71f56
readPage
private void readPage()
{    LOG.debug("loading page");    DataPage page = pageReader.readPage();    page.accept(new DataPage.Visitor<Void>() {        @Override        public Void visit(DataPageV1 dataPageV1) {            readPageV1(dataPageV1);            return null;        }        @Override        public Void visit(DataPageV2 dataPageV2) {            readPageV2(dataPageV2);            return null;        }    });}
9dfeeef84d22791019a63418e36587931f7cf8f2e3f34b3ac4a43f56d057d1f5
visit
public Void visit(DataPageV1 dataPageV1)
{    readPageV1(dataPageV1);    return null;}
9fb850d5d401238dd825031717fe4ef5981331d3c60d082db62fa9bf05599455
visit
public Void visit(DataPageV2 dataPageV2)
{    readPageV2(dataPageV2);    return null;}
d621e821d5a6127988a2d4e004b89bd49d612b68bc51cdb09ac9b25dc7302737
initDataReader
private void initDataReader(Encoding dataEncoding, ByteBufferInputStream in, int valueCount)
{    ValuesReader previousReader = this.dataColumn;    this.currentEncoding = dataEncoding;    this.pageValueCount = valueCount;    this.endOfPageValueCount = readValues + pageValueCount;    if (dataEncoding.usesDictionary()) {        if (dictionary == null) {            throw new ParquetDecodingException("could not read page in col " + path + " as the dictionary was missing for encoding " + dataEncoding);        }        this.dataColumn = dataEncoding.getDictionaryBasedValuesReader(path, VALUES, dictionary);    } else {        this.dataColumn = dataEncoding.getValuesReader(path, VALUES);    }    if (dataEncoding.usesDictionary() && converter.hasDictionarySupport()) {        bindToDictionary(dictionary);    } else {        bind(path.getType());    }    try {        dataColumn.initFromPage(pageValueCount, in);    } catch (IOException e) {        throw new ParquetDecodingException("could not read page in col " + path, e);    }    if (CorruptDeltaByteArrays.requiresSequentialReads(writerVersion, dataEncoding) && previousReader != null && previousReader instanceof RequiresPreviousReader) {                ((RequiresPreviousReader) dataColumn).setPreviousReader(previousReader);    }}
5d89d45e4543f33d3deac3e855bcea73f0ea68fa0b19bef6df5e090a8e9aa6c4
readPageV1
private void readPageV1(DataPageV1 page)
{    ValuesReader rlReader = page.getRlEncoding().getValuesReader(path, REPETITION_LEVEL);    ValuesReader dlReader = page.getDlEncoding().getValuesReader(path, DEFINITION_LEVEL);    this.repetitionLevelColumn = new ValuesReaderIntIterator(rlReader);    this.definitionLevelColumn = new ValuesReaderIntIterator(dlReader);    int valueCount = page.getValueCount();    try {        BytesInput bytes = page.getBytes();        LOG.debug("page size {} bytes and {} values", bytes.size(), valueCount);        LOG.debug("reading repetition levels at 0");        ByteBufferInputStream in = bytes.toInputStream();        rlReader.initFromPage(valueCount, in);        LOG.debug("reading definition levels at {}", in.position());        dlReader.initFromPage(valueCount, in);        LOG.debug("reading data at {}", in.position());        initDataReader(page.getValueEncoding(), in, valueCount);    } catch (IOException e) {        throw new ParquetDecodingException("could not read page " + page + " in col " + path, e);    }    newPageInitialized(page);}
b3cc5e1226bd4554ff77dc00772bbf4132ff393cb5df817c4e64649f7fc9f83e
readPageV2
private void readPageV2(DataPageV2 page)
{    this.repetitionLevelColumn = newRLEIterator(path.getMaxRepetitionLevel(), page.getRepetitionLevels());    this.definitionLevelColumn = newRLEIterator(path.getMaxDefinitionLevel(), page.getDefinitionLevels());    int valueCount = page.getValueCount();    LOG.debug("page data size {} bytes and {} values", page.getData().size(), valueCount);    try {        initDataReader(page.getDataEncoding(), page.getData().toInputStream(), valueCount);    } catch (IOException e) {        throw new ParquetDecodingException("could not read page " + page + " in col " + path, e);    }    newPageInitialized(page);}
7856a304c6007bfd9b1a37d24e65f737cc983f4caa145868b795abc5a38f14fb
getPageValueCount
 final int getPageValueCount()
{    return pageValueCount;}
88486bc2046d30307d98e5a3ab96e21cd8a4a7a563789ade7c9c405e358873a9
newRLEIterator
private IntIterator newRLEIterator(int maxLevel, BytesInput bytes)
{    try {        if (maxLevel == 0) {            return new NullIntIterator();        }        return new RLEIntIterator(new RunLengthBitPackingHybridDecoder(BytesUtils.getWidthFromMaxInt(maxLevel), bytes.toInputStream()));    } catch (IOException e) {        throw new ParquetDecodingException("could not read levels in page for col " + path, e);    }}
cb83e1fac52f5b9cded9364a6c293d9707a96b293087c436ed9a3314136f8fa0
isPageFullyConsumed
 boolean isPageFullyConsumed()
{    return readValues >= endOfPageValueCount;}
0edbdaff08ce33c29dc12b1c8723c06c4d7827b1b3f6b7b620a127c9f9442860
consume
public void consume()
{    checkRead();    valueRead = false;}
a44ab89ac1bd1c96a51dfa0d50dcc13fd7563de2e02c8e8f8722aff5468302dd
getTotalValueCount
public long getTotalValueCount()
{    return totalValueCount;}
3026fe5857548eee1fcc5009b1704063424ddb8ad4acf410eec5ff33c9cb0ddf
nextInt
 int nextInt()
{    return delegate.readInteger();}
3026fe5857548eee1fcc5009b1704063424ddb8ad4acf410eec5ff33c9cb0ddf
nextInt
 int nextInt()
{    try {        return delegate.readInt();    } catch (IOException e) {        throw new ParquetDecodingException(e);    }}
3026fe5857548eee1fcc5009b1704063424ddb8ad4acf410eec5ff33c9cb0ddf
nextInt
 int nextInt()
{    return 0;}
4733c7e2acaab203bf7f1b4d4a899eb94e1c0b28108b6b5422acac2f4dd08173
skipRL
 boolean skipRL(int rl)
{    return false;}
712b9829fc1d68911f830b81901d244f047956292e4d9cb179378cb9deefeceb
newPageInitialized
 void newPageInitialized(DataPage page)
{}
28626e508fa631987844f7f401168a8c3329aed106b265e41b2318b4bd2194f5
getColumnReader
public ColumnReader getColumnReader(ColumnDescriptor path)
{    PrimitiveConverter converter = getPrimitiveConverter(path);    PageReader pageReader = pageReadStore.getPageReader(path);    Optional<PrimitiveIterator.OfLong> rowIndexes = pageReadStore.getRowIndexes();    if (rowIndexes.isPresent()) {        return new SynchronizingColumnReader(path, pageReader, converter, writerVersion, rowIndexes.get());    } else {        return new ColumnReaderImpl(path, pageReader, converter, writerVersion);    }}
e71521207b41488ded309cddb2834ae34f2ee25227047e4a50be400e3cda5206
newMemColumnReader
private ColumnReaderImpl newMemColumnReader(ColumnDescriptor path, PageReader pageReader)
{    PrimitiveConverter converter = getPrimitiveConverter(path);    return new ColumnReaderImpl(path, pageReader, converter, writerVersion);}
c7474ae1fe84f339a14519e89c0c72951a27d717126c50c71e3cf15ef930bbf3
getPrimitiveConverter
private PrimitiveConverter getPrimitiveConverter(ColumnDescriptor path)
{    Type currentType = schema;    Converter currentConverter = recordConverter;    for (String fieldName : path.getPath()) {        final GroupType groupType = currentType.asGroupType();        int fieldIndex = groupType.getFieldIndex(fieldName);        currentType = groupType.getType(fieldName);        currentConverter = currentConverter.asGroupConverter().getConverter(fieldIndex);    }    PrimitiveConverter converter = currentConverter.asPrimitiveConverter();    return converter;}
e24342ea424b2876f4d24b5c65e5156eb4520f64152dbd229df72796bdb9adb2
log
private void log(Object value, int r, int d)
{    LOG.debug("{} {} r:{} d:{}", path, value, r, d);}
4ca1b5bca338ddd3a63f88ccf54e8723261d20a9541c3c66eaf212fac5e7fce3
resetStatistics
private void resetStatistics()
{    this.statistics = Statistics.createStats(path.getPrimitiveType());}
68448e991fc39d2f6abfc6d49e5ddc57fe49c7a9beb850757fa0c3c1c6cf3719
definitionLevel
private void definitionLevel(int definitionLevel)
{    definitionLevelColumn.writeInteger(definitionLevel);}
7182bf259fcb1c06fe386f7f865b31b61d74fe7e68bf5c528eae583415de29e3
repetitionLevel
private void repetitionLevel(int repetitionLevel)
{    repetitionLevelColumn.writeInteger(repetitionLevel);    assert pageRowCount == 0 ? repetitionLevel == 0 : true : "Every page shall start on record boundaries";    if (repetitionLevel == 0) {        ++pageRowCount;    }}
cbd3b64601d64801ea2b6b5cbd4ced5dc1ab2411f49b891edb97cbc88b23fdbd
writeNull
public void writeNull(int repetitionLevel, int definitionLevel)
{    if (DEBUG)        log(null, repetitionLevel, definitionLevel);    repetitionLevel(repetitionLevel);    definitionLevel(definitionLevel);    statistics.incrementNumNulls();    ++valueCount;}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{        repetitionLevelColumn.close();    definitionLevelColumn.close();    dataColumn.close();}
7e6728033b48c8641ea3e1ea2de0cd9690f159308b12f4450c6166714177d6e3
getBufferedSizeInMemory
public long getBufferedSizeInMemory()
{    return repetitionLevelColumn.getBufferedSize() + definitionLevelColumn.getBufferedSize() + dataColumn.getBufferedSize() + pageWriter.getMemSize();}
b4a558026ed47a9b43b29d94165e24d48fda9dabc838f587bb58f7bf2803af2e
write
public void write(double value, int repetitionLevel, int definitionLevel)
{    if (DEBUG)        log(value, repetitionLevel, definitionLevel);    repetitionLevel(repetitionLevel);    definitionLevel(definitionLevel);    dataColumn.writeDouble(value);    statistics.updateStats(value);    ++valueCount;}
d39fb6324bd5b06b761cf916ec238d9704e8f6b7a4f733df9d220ea42695900d
write
public void write(float value, int repetitionLevel, int definitionLevel)
{    if (DEBUG)        log(value, repetitionLevel, definitionLevel);    repetitionLevel(repetitionLevel);    definitionLevel(definitionLevel);    dataColumn.writeFloat(value);    statistics.updateStats(value);    ++valueCount;}
7b24db9f5d5c7ebb22495d8f1c7abbf4122ad81d8bba3cbc49050dea4fbbacab
write
public void write(Binary value, int repetitionLevel, int definitionLevel)
{    if (DEBUG)        log(value, repetitionLevel, definitionLevel);    repetitionLevel(repetitionLevel);    definitionLevel(definitionLevel);    dataColumn.writeBytes(value);    statistics.updateStats(value);    ++valueCount;}
dbe0fcdf27e1ffaaf36a89f63674baebe3e1fd4a4e8ea319ce997e38a1fc4702
write
public void write(boolean value, int repetitionLevel, int definitionLevel)
{    if (DEBUG)        log(value, repetitionLevel, definitionLevel);    repetitionLevel(repetitionLevel);    definitionLevel(definitionLevel);    dataColumn.writeBoolean(value);    statistics.updateStats(value);    ++valueCount;}
53c3e69fd1408e8633b8a927e44162bb73dfae96cea1c615d82f559c276b8640
write
public void write(int value, int repetitionLevel, int definitionLevel)
{    if (DEBUG)        log(value, repetitionLevel, definitionLevel);    repetitionLevel(repetitionLevel);    definitionLevel(definitionLevel);    dataColumn.writeInteger(value);    statistics.updateStats(value);    ++valueCount;}
b5ff81594e698e7e5429928ea010d7759f6083e62eb1a6c132a799a10fe088c7
write
public void write(long value, int repetitionLevel, int definitionLevel)
{    if (DEBUG)        log(value, repetitionLevel, definitionLevel);    repetitionLevel(repetitionLevel);    definitionLevel(definitionLevel);    dataColumn.writeLong(value);    statistics.updateStats(value);    ++valueCount;}
b4aca1a72d1b12d7d2f59c3d546643ebeed1ea698443fe9203047f4282e92745
finalizeColumnChunk
 void finalizeColumnChunk()
{    final DictionaryPage dictionaryPage = dataColumn.toDictPageAndClose();    if (dictionaryPage != null) {        if (DEBUG)            LOG.debug("write dictionary");        try {            pageWriter.writeDictionaryPage(dictionaryPage);        } catch (IOException e) {            throw new ParquetEncodingException("could not write dictionary page for " + path, e);        }        dataColumn.resetDictionary();    }}
5e192700ff0859109dcb70e1cb9f42e075218e363a51faa959a42eb81eeb80b5
getCurrentPageBufferedSize
 long getCurrentPageBufferedSize()
{    return repetitionLevelColumn.getBufferedSize() + definitionLevelColumn.getBufferedSize() + dataColumn.getBufferedSize();}
2a0e2171926b66eafcf3673f09db494c5e10f8ab3a6a649a9398f027c5a46346
getTotalBufferedSize
 long getTotalBufferedSize()
{    return repetitionLevelColumn.getBufferedSize() + definitionLevelColumn.getBufferedSize() + dataColumn.getBufferedSize() + pageWriter.getMemSize();}
6afa67d96da8a7ad3dec5e8c5f6d7d3e597c9da6a92c107c84a96ec0f99276aa
allocatedSize
 long allocatedSize()
{    return repetitionLevelColumn.getAllocatedSize() + definitionLevelColumn.getAllocatedSize() + dataColumn.getAllocatedSize() + pageWriter.allocatedSize();}
33da7b2fe8a654e1929e81f702c77081474ceff3296b767cf6b51017ec72730b
memUsageString
 String memUsageString(String indent)
{    StringBuilder b = new StringBuilder(indent).append(path).append(" {\n");    b.append(indent).append(" r:").append(repetitionLevelColumn.getAllocatedSize()).append(" bytes\n");    b.append(indent).append(" d:").append(definitionLevelColumn.getAllocatedSize()).append(" bytes\n");    b.append(dataColumn.memUsageString(indent + "  data:")).append("\n");    b.append(pageWriter.memUsageString(indent + "  pages:")).append("\n");    b.append(indent).append(String.format("  total: %,d/%,d", getTotalBufferedSize(), allocatedSize())).append("\n");    b.append(indent).append("}\n");    return b.toString();}
90cd07a5956fcd6596f8a728b3bc09637817c1e30b5da17d6d037a11f080434f
getRowsWrittenSoFar
 long getRowsWrittenSoFar()
{    return this.rowsWrittenSoFar;}
079555d87e7af304bb6fa4261a43257af46596dcc8282c0df0998ffda010f9cb
writePage
 void writePage()
{    if (valueCount == 0) {        throw new ParquetEncodingException("writing empty page");    }    this.rowsWrittenSoFar += pageRowCount;    if (DEBUG)        LOG.debug("write page");    try {        writePage(pageRowCount, valueCount, statistics, repetitionLevelColumn, definitionLevelColumn, dataColumn);    } catch (IOException e) {        throw new ParquetEncodingException("could not write page for " + path, e);    }    repetitionLevelColumn.reset();    definitionLevelColumn.reset();    dataColumn.reset();    valueCount = 0;    resetStatistics();    pageRowCount = 0;}
b9909619a128fd944638333056b8b06ac2dea08720dbf16496bab2dcf257e04a
createRLWriter
 ValuesWriter createRLWriter(ParquetProperties props, ColumnDescriptor path)
{    return props.newRepetitionLevelWriter(path);}
da1329b8a549ad2da21426980cec1dc5055f06ac1ca72d02f4200e50db6bf947
createDLWriter
 ValuesWriter createDLWriter(ParquetProperties props, ColumnDescriptor path)
{    return props.newDefinitionLevelWriter(path);}
b3e4e2f631aff83e014f47dd369d1dcf4f6940b1dc17b1533837b68206ea02d3
writePage
 void writePage(int rowCount, int valueCount, Statistics<?> statistics, ValuesWriter repetitionLevels, ValuesWriter definitionLevels, ValuesWriter values) throws IOException
{    pageWriter.writePage(concat(repetitionLevels.getBytes(), definitionLevels.getBytes(), values.getBytes()), valueCount, rowCount, statistics, repetitionLevels.getEncoding(), definitionLevels.getEncoding(), values.getEncoding());}
318792bb7e7c97eb05ff79e99daac6fe67cad1bfa7ae196cf0f5d3f9cfdfd7b1
getBytes
public BytesInput getBytes()
{    try {        return encoder.toBytes();    } catch (IOException e) {        throw new ParquetEncodingException(e);    }}
b9909619a128fd944638333056b8b06ac2dea08720dbf16496bab2dcf257e04a
createRLWriter
 ValuesWriter createRLWriter(ParquetProperties props, ColumnDescriptor path)
{    return path.getMaxRepetitionLevel() == 0 ? NULL_WRITER : new RLEWriterForV2(props.newRepetitionLevelEncoder(path));}
da1329b8a549ad2da21426980cec1dc5055f06ac1ca72d02f4200e50db6bf947
createDLWriter
 ValuesWriter createDLWriter(ParquetProperties props, ColumnDescriptor path)
{    return path.getMaxDefinitionLevel() == 0 ? NULL_WRITER : new RLEWriterForV2(props.newDefinitionLevelEncoder(path));}
b3e4e2f631aff83e014f47dd369d1dcf4f6940b1dc17b1533837b68206ea02d3
writePage
 void writePage(int rowCount, int valueCount, Statistics<?> statistics, ValuesWriter repetitionLevels, ValuesWriter definitionLevels, ValuesWriter values) throws IOException
{        BytesInput bytes = values.getBytes();    Encoding encoding = values.getEncoding();    pageWriter.writePageV2(rowCount, Math.toIntExact(statistics.getNumNulls()), valueCount, repetitionLevels.getBytes(), definitionLevels.getBytes(), encoding, bytes, statistics);}
29f1e58dea377232aeef578714184718703c25b5f5443370857b76bb8161164c
getColumnWriter
public ColumnWriter getColumnWriter(ColumnDescriptor path)
{    ColumnWriterBase column = columns.get(path);    if (column == null) {        column = createColumnWriter(path, pageWriteStore.getPageWriter(path), props);        columns.put(path, column);    }    return column;}
29f1e58dea377232aeef578714184718703c25b5f5443370857b76bb8161164c
getColumnWriter
public ColumnWriter getColumnWriter(ColumnDescriptor path)
{    return columns.get(path);}
29f1e58dea377232aeef578714184718703c25b5f5443370857b76bb8161164c
getColumnWriter
public ColumnWriter getColumnWriter(ColumnDescriptor path)
{    return columnWriterProvider.getColumnWriter(path);}
b357c91f7f3c0a3d303489d8e8e7156cf1c6cdfb5988f8a7b5807c9c0c0fa16a
getColumnDescriptors
public Set<ColumnDescriptor> getColumnDescriptors()
{    return columns.keySet();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder();    for (Entry<ColumnDescriptor, ColumnWriterBase> entry : columns.entrySet()) {        sb.append(Arrays.toString(entry.getKey().getPath())).append(": ");        sb.append(entry.getValue().getTotalBufferedSize()).append(" bytes");        sb.append("\n");    }    return sb.toString();}
3276143416d44249f488f85b127246b083e1e6024d88125aae60e635a8ad8ba7
getAllocatedSize
public long getAllocatedSize()
{    long total = 0;    for (ColumnWriterBase memColumn : columns.values()) {        total += memColumn.allocatedSize();    }    return total;}
0c921188cddfdbdd5e940a92767fca400663f7ba7c1b4fbfdb5a2e991b21cb93
getBufferedSize
public long getBufferedSize()
{    long total = 0;    for (ColumnWriterBase memColumn : columns.values()) {        total += memColumn.getTotalBufferedSize();    }    return total;}
ea956eca0ceec4b07db63def8a0f238be4f058fb174f02b053447578581df262
flush
public void flush()
{    for (ColumnWriterBase memColumn : columns.values()) {        long rows = rowCount - memColumn.getRowsWrittenSoFar();        if (rows > 0) {            memColumn.writePage();        }        memColumn.finalizeColumnChunk();    }}
e4a1e31ebb8e326fa4817a42e9e67e3574f771bad021989e779433ddb97f34af
memUsageString
public String memUsageString()
{    StringBuilder b = new StringBuilder("Store {\n");    for (ColumnWriterBase memColumn : columns.values()) {        b.append(memColumn.memUsageString(" "));    }    b.append("}\n");    return b.toString();}
a93304b7ccd525f6de757b36e0140e0d17b32049957cfb15415ba54258b161bd
maxColMemSize
public long maxColMemSize()
{    long max = 0;    for (ColumnWriterBase memColumn : columns.values()) {        max = Math.max(max, memColumn.getBufferedSizeInMemory());    }    return max;}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{        flush();    for (ColumnWriterBase memColumn : columns.values()) {        memColumn.close();    }}
902efc93e2b44aa9778c16b0540857076ef96fb4b47ce98941d77f435e6cdac8
endRecord
public void endRecord()
{    ++rowCount;    if (rowCount >= rowCountForNextSizeCheck) {        sizeCheck();    }}
5dfa0451bb3bb3dea58ed855bad7e194ecd3567f30e2c60dd6233881650f7ff1
sizeCheck
private void sizeCheck()
{    long minRecordToWait = Long.MAX_VALUE;    int pageRowCountLimit = props.getPageRowCountLimit();    long rowCountForNextRowCountCheck = rowCount + pageRowCountLimit;    for (ColumnWriterBase writer : columns.values()) {        long usedMem = writer.getCurrentPageBufferedSize();        long rows = rowCount - writer.getRowsWrittenSoFar();        long remainingMem = props.getPageSizeThreshold() - usedMem;        if (remainingMem <= thresholdTolerance || rows >= pageRowCountLimit) {            writer.writePage();            remainingMem = props.getPageSizeThreshold();        } else {            rowCountForNextRowCountCheck = min(rowCountForNextRowCountCheck, writer.getRowsWrittenSoFar() + pageRowCountLimit);        }        long rowsToFillPage = usedMem == 0 ? props.getMaxRowCountForPageSizeCheck() : (long) ((float) rows) / usedMem * remainingMem;        if (rowsToFillPage < minRecordToWait) {            minRecordToWait = rowsToFillPage;        }    }    if (minRecordToWait == Long.MAX_VALUE) {        minRecordToWait = props.getMinRowCountForPageSizeCheck();    }    if (props.estimateNextSizeCheck()) {                rowCountForNextSizeCheck = rowCount + min(max(minRecordToWait / 2, props.getMinRowCountForPageSizeCheck()), props.getMaxRowCountForPageSizeCheck());    } else {        rowCountForNextSizeCheck = rowCount + props.getMinRowCountForPageSizeCheck();    }        if (rowCountForNextRowCountCheck < rowCountForNextSizeCheck) {        rowCountForNextSizeCheck = rowCountForNextRowCountCheck;    }}
1c9482e50eb134a50ef64c540dcead2c6999365cfdc16550514d5a9fa8231370
isColumnFlushNeeded
public boolean isColumnFlushNeeded()
{    return rowCount + 1 >= rowCountForNextSizeCheck;}
3aed10fe1a1305c203b06904a0a7dd8f9f3dfc6e57886a81f4bf9071ad333557
createColumnWriter
 ColumnWriterBase createColumnWriter(ColumnDescriptor path, PageWriter pageWriter, ParquetProperties props)
{    return new ColumnWriterV1(path, pageWriter, props);}
3aed10fe1a1305c203b06904a0a7dd8f9f3dfc6e57886a81f4bf9071ad333557
createColumnWriter
 ColumnWriterBase createColumnWriter(ColumnDescriptor path, PageWriter pageWriter, ParquetProperties props)
{    return new ColumnWriterV2(path, pageWriter, props);}
cb83e1fac52f5b9cded9364a6c293d9707a96b293087c436ed9a3314136f8fa0
isPageFullyConsumed
 boolean isPageFullyConsumed()
{    return getPageValueCount() <= valuesReadFromPage || lastRowInPage < targetRow;}
1394313d52d86dedcb9281dc3405db2200f57005bb388553348e1a555f6f415f
isFullyConsumed
 boolean isFullyConsumed()
{    return !rowIndexes.hasNext();}
4733c7e2acaab203bf7f1b4d4a899eb94e1c0b28108b6b5422acac2f4dd08173
skipRL
 boolean skipRL(int rl)
{    ++valuesReadFromPage;    if (rl == 0) {        ++currentRow;        if (currentRow > targetRow) {            targetRow = rowIndexes.hasNext() ? rowIndexes.nextLong() : Long.MAX_VALUE;        }    }    return currentRow < targetRow;}
cfb7d0203d504a60c8ca68f0c9ffa8fe097c82a343efd6e0bcbdab41b9869213
newPageInitialized
protected void newPageInitialized(DataPage page)
{    long firstRowIndex = page.getFirstRowIndex().orElseThrow(() -> new IllegalArgumentException("Missing firstRowIndex for synchronizing values"));    int rowCount = page.getIndexRowCount().orElseThrow(() -> new IllegalArgumentException("Missing rowCount for synchronizing values"));    currentRow = firstRowIndex - 1;    lastRowInPage = firstRowIndex + rowCount - 1;    valuesReadFromPage = 0;}
df77728261357b2ada5d0b5077b0890a86169748d86543a8197d261d1c7a324f
getValueCount
public int getValueCount()
{    return valueCount;}
6813d7f3521940a59012bc0ff88151e45efcc13aa378f46aeced87432aaa1d5c
getFirstRowIndex
public Optional<Long> getFirstRowIndex()
{    return firstRowIndex < 0 ? Optional.empty() : Optional.of(firstRowIndex);}
318792bb7e7c97eb05ff79e99daac6fe67cad1bfa7ae196cf0f5d3f9cfdfd7b1
getBytes
public BytesInput getBytes()
{    return bytes;}
d1485c2bef4d274a4fa2fe6fccb7b028ad7158681de88124124604f4b5379187
getStatistics
public Statistics<?> getStatistics()
{    return statistics;}
a12b17b66201ba357f56e9797567fc74beb11e809c9d433285784e39604fbbd8
getDlEncoding
public Encoding getDlEncoding()
{    return dlEncoding;}
ba6ae4e754256dce6c642af8ae359be1bfdd3bddc0e2168825c09dd751af7bca
getRlEncoding
public Encoding getRlEncoding()
{    return rlEncoding;}
7c82ce64dc2b5133f44937fe88eb7dec3fb5c562961a92ff2b650005df018b9e
getValueEncoding
public Encoding getValueEncoding()
{    return valuesEncoding;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "Page [bytes.size=" + bytes.size() + ", valueCount=" + getValueCount() + ", uncompressedSize=" + getUncompressedSize() + "]";}
b14e9c673c07e25bba6ffbe3054cf8666078cfe0a0e991d92e6e3c858981754f
accept
public T accept(Visitor<T> visitor)
{    return visitor.visit(this);}
19e2b6fbdc9c421aedcb7afab0a9b9c2d95e7386af3a18c0c75a8551043006f2
getIndexRowCount
public Optional<Integer> getIndexRowCount()
{    return indexRowCount < 0 ? Optional.empty() : Optional.of(indexRowCount);}
2929ee821a65c45b439cd218502f49aed7ca8e89080e4d169698352c04409e6b
uncompressed
public static DataPageV2 uncompressed(int rowCount, int nullCount, int valueCount, BytesInput repetitionLevels, BytesInput definitionLevels, Encoding dataEncoding, BytesInput data, Statistics<?> statistics)
{    return new DataPageV2(rowCount, nullCount, valueCount, repetitionLevels, definitionLevels, dataEncoding, data, Math.toIntExact(repetitionLevels.size() + definitionLevels.size() + data.size()), statistics, false);}
224b82a5786b388b6c54e7706c76170238525f53aea07977002609a2390d24d1
uncompressed
public static DataPageV2 uncompressed(int rowCount, int nullCount, int valueCount, long firstRowIndex, BytesInput repetitionLevels, BytesInput definitionLevels, Encoding dataEncoding, BytesInput data, Statistics<?> statistics)
{    return new DataPageV2(rowCount, nullCount, valueCount, firstRowIndex, repetitionLevels, definitionLevels, dataEncoding, data, Math.toIntExact(repetitionLevels.size() + definitionLevels.size() + data.size()), statistics, false);}
87d4bb2bde63b8828a526ce6473bbbaa73bac93cd3e49ed72c808959b279e1bc
compressed
public static DataPageV2 compressed(int rowCount, int nullCount, int valueCount, BytesInput repetitionLevels, BytesInput definitionLevels, Encoding dataEncoding, BytesInput data, int uncompressedSize, Statistics<?> statistics)
{    return new DataPageV2(rowCount, nullCount, valueCount, repetitionLevels, definitionLevels, dataEncoding, data, uncompressedSize, statistics, true);}
f3049780d2379a381fbbf6e482c4d201be2edb5a54faeb33c278da300ce58f12
getRowCount
public int getRowCount()
{    return rowCount;}
4c8baa062c630d26a38e2af4f2dad7872cce750a2667caeb096b67f8c2d832dc
getNullCount
public int getNullCount()
{    return nullCount;}
0ccdc4c6e004e54d49e93db5b3a00ff57a04fedaad4c9cdace15e9d70db26b2b
getRepetitionLevels
public BytesInput getRepetitionLevels()
{    return repetitionLevels;}
a515d6aff587b68197fa827ba68107f2662ba92b4502c5d9cae8d0ba2bda7166
getDefinitionLevels
public BytesInput getDefinitionLevels()
{    return definitionLevels;}
c625524169911852e5eebdb071a090f4c0c4b5d8445b0b1bd0d92ce340d1e0a7
getDataEncoding
public Encoding getDataEncoding()
{    return dataEncoding;}
504aaab788cda398f3c01a935cd309549a96448bcfa045b096b0c337a3ba0a1a
getData
public BytesInput getData()
{    return data;}
d1485c2bef4d274a4fa2fe6fccb7b028ad7158681de88124124604f4b5379187
getStatistics
public Statistics<?> getStatistics()
{    return statistics;}
b58d85dfcbc498f11ead6b1ebd07cb907ada2747e6957b213106eca22f0de6d0
isCompressed
public boolean isCompressed()
{    return isCompressed;}
19e2b6fbdc9c421aedcb7afab0a9b9c2d95e7386af3a18c0c75a8551043006f2
getIndexRowCount
public Optional<Integer> getIndexRowCount()
{    return Optional.of(rowCount);}
b14e9c673c07e25bba6ffbe3054cf8666078cfe0a0e991d92e6e3c858981754f
accept
public T accept(Visitor<T> visitor)
{    return visitor.visit(this);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "Page V2 [" + "dl size=" + definitionLevels.size() + ", " + "rl size=" + repetitionLevels.size() + ", " + "data size=" + data.size() + ", " + "data enc=" + dataEncoding + ", " + "valueCount=" + getValueCount() + ", " + "rowCount=" + getRowCount() + ", " + "is compressed=" + isCompressed + ", " + "uncompressedSize=" + getUncompressedSize() + "]";}
318792bb7e7c97eb05ff79e99daac6fe67cad1bfa7ae196cf0f5d3f9cfdfd7b1
getBytes
public BytesInput getBytes()
{    return bytes;}
e1f28ce1194b6863bdea6cb4c90dd928ace5f30fc468261e7189520cc534c61b
getDictionarySize
public int getDictionarySize()
{    return dictionarySize;}
3d8ee53ad91e9129f673687f3d9fcb3f058bc5dc228085fdcc174f07e9247418
getEncoding
public Encoding getEncoding()
{    return encoding;}
8289bd19ff25b1d5bf64a61cabc94de6098c0a7b8feef62b5707ae284e2ee6a7
copy
public DictionaryPage copy() throws IOException
{    return new DictionaryPage(BytesInput.copy(bytes), getUncompressedSize(), dictionarySize, encoding);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "Page [bytes.size=" + bytes.size() + ", entryCount=" + dictionarySize + ", uncompressedSize=" + getUncompressedSize() + ", encoding=" + encoding + "]";}
a24cea9f99e5e24bed56926dba3eff37c076735b087f4ffc19bfa129700850e9
getCompressedSize
public int getCompressedSize()
{    return compressedSize;}
caf2d902b4074a6bcf307a9790786ee9458edee87529569f98d8696e7aa28a7d
getUncompressedSize
public int getUncompressedSize()
{    return uncompressedSize;}
cf13098d504aec4ec44e911ce9ffcfe8370579caa3aecaa1cd6b8b6d349ca000
setCrc
public void setCrc(int crc)
{    this.crc = OptionalInt.of(crc);}
2e59b7397701c2a80eb646b2d804245efe10696d7480783719b7a9669f5bf6a5
getCrc
public OptionalInt getCrc()
{    return crc;}
a210f4d671e2d1cfa562c93f154222160126dc2b9fff25082f16faac8a130760
getRowIndexes
 Optional<PrimitiveIterator.OfLong> getRowIndexes()
{    return Optional.empty();}
9e8b77db82b7de5e44371c50b5086671c633a9b076deb66a050f7539173d4556
fromString
public static WriterVersion fromString(String name)
{    for (WriterVersion v : WriterVersion.values()) {        if (v.shortName.equals(name)) {            return v;        }    }        return WriterVersion.valueOf(name);}
d80f1ee0b3b44b8edd52079536fda52d757750a94dd58b8da0fdf480a150587e
newRepetitionLevelWriter
public ValuesWriter newRepetitionLevelWriter(ColumnDescriptor path)
{    return newColumnDescriptorValuesWriter(path.getMaxRepetitionLevel());}
f5bc822fd3550c96a697bca6bd1ef988aaf236acaa95456ce6a46a9d83b5c35c
newDefinitionLevelWriter
public ValuesWriter newDefinitionLevelWriter(ColumnDescriptor path)
{    return newColumnDescriptorValuesWriter(path.getMaxDefinitionLevel());}
0a163d4b27c34278a626e4dc665bf2dc6e258418821f13545baf830ee50a069c
newColumnDescriptorValuesWriter
private ValuesWriter newColumnDescriptorValuesWriter(int maxLevel)
{    if (maxLevel == 0) {        return new DevNullValuesWriter();    } else {        return new RunLengthBitPackingHybridValuesWriter(getWidthFromMaxInt(maxLevel), MIN_SLAB_SIZE, pageSizeThreshold, allocator);    }}
7bae23bc31b6c272168b20a8eafc4276caacd4f0f115e8f98b7436b9e0794391
newRepetitionLevelEncoder
public RunLengthBitPackingHybridEncoder newRepetitionLevelEncoder(ColumnDescriptor path)
{    return newLevelEncoder(path.getMaxRepetitionLevel());}
5b45ebce0d789ffd7ecbcf038a78ce43dfbeaeba9c419bb2ce56da55f0fa848e
newDefinitionLevelEncoder
public RunLengthBitPackingHybridEncoder newDefinitionLevelEncoder(ColumnDescriptor path)
{    return newLevelEncoder(path.getMaxDefinitionLevel());}
b6a98f5c0f819ebe03eaf33f479780f1f3ecdd7e5427ac6cf7e9067e01feb74c
newLevelEncoder
private RunLengthBitPackingHybridEncoder newLevelEncoder(int maxLevel)
{    return new RunLengthBitPackingHybridEncoder(getWidthFromMaxInt(maxLevel), MIN_SLAB_SIZE, pageSizeThreshold, allocator);}
f9616fdf15828203c53d87668e0a490a2a59f65ee83bb46cd1be0eb20bc725ff
newValuesWriter
public ValuesWriter newValuesWriter(ColumnDescriptor path)
{    return valuesWriterFactory.newValuesWriter(path);}
d476093d7bc16b5a73ed9d84ba3bce8e19026b0b93a27becb1e66a129f070857
getPageSizeThreshold
public int getPageSizeThreshold()
{    return pageSizeThreshold;}
ea888a0cf5cb16048104feef3fd01f1b331eeddddd68c31aa670ddef000ea985
getInitialSlabSize
public int getInitialSlabSize()
{    return initialSlabSize;}
0df48eb8b8830fdf1c438b3905930260bf28fdf486bdb0a9f1da1e597d1d833f
getDictionaryPageSizeThreshold
public int getDictionaryPageSizeThreshold()
{    return dictionaryPageSizeThreshold;}
608b9be5dd18b7b83f235c4776426c0d60a442c243ef9c3f8a8305d05685f868
getWriterVersion
public WriterVersion getWriterVersion()
{    return writerVersion;}
bb380d8520ce6fbda30a7663996c3cdfe96848fe4d2ed02af8f6354c1a9bec68
isEnableDictionary
public boolean isEnableDictionary()
{    return enableDictionary;}
8da478be30239be43934a3f5a312089be6187deb04bc104c2e3a45f410bfd206
getAllocator
public ByteBufferAllocator getAllocator()
{    return allocator;}
3563c51e1baecb75f1af5d1c9e324a12b8a7c1277e38f961bf1862064116bd31
newColumnWriteStore
public ColumnWriteStore newColumnWriteStore(MessageType schema, PageWriteStore pageStore)
{    switch(writerVersion) {        case PARQUET_1_0:            return new ColumnWriteStoreV1(schema, pageStore, this);        case PARQUET_2_0:            return new ColumnWriteStoreV2(schema, pageStore, this);        default:            throw new IllegalArgumentException("unknown version " + writerVersion);    }}
5b41458fd6b65ccee054f4b96cb969cd6901eaf4ab74beef6c3cb6bf80e46357
getMinRowCountForPageSizeCheck
public int getMinRowCountForPageSizeCheck()
{    return minRowCountForPageSizeCheck;}
9b109711fddbbb2fd5790891dc54c3a4131ed384a92fbc2f8bef19f3a58dbbff
getMaxRowCountForPageSizeCheck
public int getMaxRowCountForPageSizeCheck()
{    return maxRowCountForPageSizeCheck;}
d493eb36aac5414955cb63813b009373c94389403aebb587478d459b3adc7ff1
getValuesWriterFactory
public ValuesWriterFactory getValuesWriterFactory()
{    return valuesWriterFactory;}
32e112b59e00adbb9df2035f399f90c3e2fe654f37790efb4a66ffb7d0a3e306
getColumnIndexTruncateLength
public int getColumnIndexTruncateLength()
{    return columnIndexTruncateLength;}
c1a0acd40cba650254e6e5eaa5d3e2eff2a6284911c932c48ebc9847756c1ec6
estimateNextSizeCheck
public boolean estimateNextSizeCheck()
{    return estimateNextSizeCheck;}
0e9ea0bca0cb42abdc2df33fe62c7e6d63f2230a520315d942978d4554e2f8be
getPageRowCountLimit
public int getPageRowCountLimit()
{    return pageRowCountLimit;}
902a4d382f774e806a7a570c05e0fb89e807b88e784c9554aa037d13782af3cd
getPageWriteChecksumEnabled
public boolean getPageWriteChecksumEnabled()
{    return pageWriteChecksumEnabled;}
cf558fab344ef794057daaaf3d4721487c20c3f85d09e31f5c8f20f006d4a450
builder
public static Builder builder()
{    return new Builder();}
a402c2a5de54c7a06c45e84e775f7f5e812e0bb20a5981ae4d3a5033521303a4
copy
public static Builder copy(ParquetProperties toCopy)
{    return new Builder(toCopy);}
96cf40954e125c510211b3011d883d456504a4795c390e27aa2efb60ebe00e84
withPageSize
public Builder withPageSize(int pageSize)
{    Preconditions.checkArgument(pageSize > 0, "Invalid page size (negative): %s", pageSize);    this.pageSize = pageSize;    return this;}
efcf510a70f2ec841e644a92bc7a16dcaa334ae5c3a3e43cc74a5b2b30612a55
withDictionaryEncoding
public Builder withDictionaryEncoding(boolean enableDictionary)
{    this.enableDict = enableDictionary;    return this;}
bb6ba00c02ba04df7a5d8a8a0b076fb3a5c530cee48b57b54d51dfb279ead7e2
withDictionaryPageSize
public Builder withDictionaryPageSize(int dictionaryPageSize)
{    Preconditions.checkArgument(dictionaryPageSize > 0, "Invalid dictionary page size (negative): %s", dictionaryPageSize);    this.dictPageSize = dictionaryPageSize;    return this;}
012d1d42df8afbe1cd81eb7f5ea4e936df92df6e90a75d6d5348bbef5b7112e1
withWriterVersion
public Builder withWriterVersion(WriterVersion version)
{    this.writerVersion = version;    return this;}
423833f2f99ee4d9211f05aa966e4b54859fb0a0e391911ef8c912d358912505
withMinRowCountForPageSizeCheck
public Builder withMinRowCountForPageSizeCheck(int min)
{    Preconditions.checkArgument(min > 0, "Invalid row count for page size check (negative): %s", min);    this.minRowCountForPageSizeCheck = min;    return this;}
1a5c7c356f5ca6020b8d1cbe27a9c9efb1fe7a059eea0e9fdc9c05a097675789
withMaxRowCountForPageSizeCheck
public Builder withMaxRowCountForPageSizeCheck(int max)
{    Preconditions.checkArgument(max > 0, "Invalid row count for page size check (negative): %s", max);    this.maxRowCountForPageSizeCheck = max;    return this;}
2c5ef8de813d05e4a75ddd6ab96147d5ac151decd0334366fc4e7ccfab77d0b4
estimateRowCountForPageSizeCheck
public Builder estimateRowCountForPageSizeCheck(boolean estimateNextSizeCheck)
{    this.estimateNextSizeCheck = estimateNextSizeCheck;    return this;}
8e62c0fd64b4a0c5a706f4d7bc609ac6ba4b16704389c118f5dac9634aace7eb
withAllocator
public Builder withAllocator(ByteBufferAllocator allocator)
{    Preconditions.checkNotNull(allocator, "ByteBufferAllocator");    this.allocator = allocator;    return this;}
99f1cbcc43444bd4fdb6d81517711df8a9940ac18b6c8cea8b82bd086e06088b
withValuesWriterFactory
public Builder withValuesWriterFactory(ValuesWriterFactory factory)
{    Preconditions.checkNotNull(factory, "ValuesWriterFactory");    this.valuesWriterFactory = factory;    return this;}
29bb316177f92d5b0698ab2d3441b4aa6c803b1eb24b588ae1744444c8c715d5
withColumnIndexTruncateLength
public Builder withColumnIndexTruncateLength(int length)
{    Preconditions.checkArgument(length > 0, "Invalid column index min/max truncate length (negative) : %s", length);    this.columnIndexTruncateLength = length;    return this;}
ddad632319d166df27d278277f74fb82e8617179d646dd83de2716ec5316bf87
withPageRowCountLimit
public Builder withPageRowCountLimit(int rowCount)
{    Preconditions.checkArgument(rowCount > 0, "Invalid row count limit for pages: " + rowCount);    pageRowCountLimit = rowCount;    return this;}
9ed0bc320ab116bcc965d13ca84f2a8191bef7e97d122b9fe6e50e7a5bf3e608
withPageWriteChecksumEnabled
public Builder withPageWriteChecksumEnabled(boolean val)
{    this.pageWriteChecksumEnabled = val;    return this;}
b40e21c7f230665ec92594d643953026a624594609911870b6b9cf29eed7727b
build
public ParquetProperties build()
{    ParquetProperties properties = new ParquetProperties(writerVersion, pageSize, dictPageSize, enableDict, minRowCountForPageSizeCheck, maxRowCountForPageSizeCheck, estimateNextSizeCheck, allocator, valuesWriterFactory, columnIndexTruncateLength, pageRowCountLimit, pageWriteChecksumEnabled);                    valuesWriterFactory.initialize(properties);    return properties;}
91d853d12c7ae8baa067bb5488180dc7eec69b07c57ac12ccb0e8dabcbc7b1cf
updateStats
public void updateStats(Binary value)
{    if (!this.hasNonNullValue()) {        initializeStats(value, value);    } else {        updateStats(value, value);    }}
a36d8e4b77b5be4ca5a64934a367c3bbe0f87d10d5919b51bf9306570c9d8347
mergeStatisticsMinMax
public void mergeStatisticsMinMax(Statistics stats)
{    BinaryStatistics binaryStats = (BinaryStatistics) stats;    if (!this.hasNonNullValue()) {        initializeStats(binaryStats.getMin(), binaryStats.getMax());    } else {        updateStats(binaryStats.getMin(), binaryStats.getMax());    }}
9a72df6e7e4267cfc4b0a639be0828168e49428717094c94964e155bd96b9e6b
setMinMaxFromBytes
public void setMinMaxFromBytes(byte[] minBytes, byte[] maxBytes)
{    max = Binary.fromReusedByteArray(maxBytes);    min = Binary.fromReusedByteArray(minBytes);    this.markAsNotEmpty();}
2f01645f365109018e12db7ec0bf767552c47bfcd30b1a2717601f85d39f0863
getMaxBytes
public byte[] getMaxBytes()
{    return max == null ? null : max.getBytes();}
1faaa367315a898b7649ef1a372ebdc000ee59fbfd1eb5dbf59cc6c76f436718
getMinBytes
public byte[] getMinBytes()
{    return min == null ? null : min.getBytes();}
f30077ad806b07b65bd976cbaa5bc3e510c9054e667ecf4e78ead940598afc20
stringify
 String stringify(Binary value)
{    return stringifier.stringify(value);}
ee8a3e0a9edf3a8fe8c76c164b27a24a23c4a46da8b05b705a35e91c31b5a5f8
isSmallerThan
public boolean isSmallerThan(long size)
{    return !hasNonNullValue() || ((min.length() + max.length()) < size);}
f7b8292d7604b023a43aff7ae5c14958c5bab61279d37f9c9d9b331719f3ecdc
updateStats
public void updateStats(Binary min_value, Binary max_value)
{    if (comparator().compare(min, min_value) > 0) {        min = min_value.copy();    }    if (comparator().compare(max, max_value) < 0) {        max = max_value.copy();    }}
4349739b9b35c3484439a82ed0da2094602af0d8385b341687e6efd5ab938d21
initializeStats
public void initializeStats(Binary min_value, Binary max_value)
{    min = min_value.copy();    max = max_value.copy();    this.markAsNotEmpty();}
20cfa24fdf730594d9bf405bf45292c60f75fad688f0ea71e18ebd7be4a2d0b2
genericGetMin
public Binary genericGetMin()
{    return min;}
6020025a4fcb66a0717adf36b24311478d9e11448fa21bc651efd9965abcefe3
genericGetMax
public Binary genericGetMax()
{    return max;}
0d7d0aab9a4a1aeaae0c45dc1d9de2aa00cac7be6aedcef00852af6381be9b8b
getMax
public Binary getMax()
{    return max;}
be9bc634eb6cd6e44873b27092db2ad602ce9a5b4f405f4b340fa01fe5292d6e
getMin
public Binary getMin()
{    return min;}
46dea3c123ebac3a384228de1fc83293e2a0cd778009510d8ca39f8d5395a112
setMinMax
public void setMinMax(Binary min, Binary max)
{    this.max = max;    this.min = min;    this.markAsNotEmpty();}
77a96309b938a542f6e408a8d888b831c3783d0e472600a9a3b2580925b51504
copy
public BinaryStatistics copy()
{    return new BinaryStatistics(this);}
5e32522053b4d69b1bfc8fab0d4e724880ae1acc1d29a42d3669a28a51501c77
updateStats
public void updateStats(boolean value)
{    if (!this.hasNonNullValue()) {        initializeStats(value, value);    } else {        updateStats(value, value);    }}
a36d8e4b77b5be4ca5a64934a367c3bbe0f87d10d5919b51bf9306570c9d8347
mergeStatisticsMinMax
public void mergeStatisticsMinMax(Statistics stats)
{    BooleanStatistics boolStats = (BooleanStatistics) stats;    if (!this.hasNonNullValue()) {        initializeStats(boolStats.getMin(), boolStats.getMax());    } else {        updateStats(boolStats.getMin(), boolStats.getMax());    }}
9a72df6e7e4267cfc4b0a639be0828168e49428717094c94964e155bd96b9e6b
setMinMaxFromBytes
public void setMinMaxFromBytes(byte[] minBytes, byte[] maxBytes)
{    max = BytesUtils.bytesToBool(maxBytes);    min = BytesUtils.bytesToBool(minBytes);    this.markAsNotEmpty();}
2f01645f365109018e12db7ec0bf767552c47bfcd30b1a2717601f85d39f0863
getMaxBytes
public byte[] getMaxBytes()
{    return BytesUtils.booleanToBytes(max);}
1faaa367315a898b7649ef1a372ebdc000ee59fbfd1eb5dbf59cc6c76f436718
getMinBytes
public byte[] getMinBytes()
{    return BytesUtils.booleanToBytes(min);}
8a99dd7f2f2583c8258dbf8d0e75cfde3eb05959fe388ec2badc112c87852c51
stringify
 String stringify(Boolean value)
{    return stringifier.stringify(value);}
ee8a3e0a9edf3a8fe8c76c164b27a24a23c4a46da8b05b705a35e91c31b5a5f8
isSmallerThan
public boolean isSmallerThan(long size)
{    return !hasNonNullValue() || (2 < size);}
d6c8dbe07f19c684eeb4981b30475a301e31c2977dd54a93b5050ea23026caf1
updateStats
public void updateStats(boolean min_value, boolean max_value)
{    if (comparator().compare(min, min_value) > 0) {        min = min_value;    }    if (comparator().compare(max, max_value) < 0) {        max = max_value;    }}
f1b404223a48feae9616a78292c861c173bde7e033f9a6c398e7914a731acbe3
initializeStats
public void initializeStats(boolean min_value, boolean max_value)
{    min = min_value;    max = max_value;    this.markAsNotEmpty();}
3eaedabe0c47e67329be89cce8584796f267ab26941184f307a38193be3da8f2
genericGetMin
public Boolean genericGetMin()
{    return min;}
26ac2fb35a110c8cd5343cff44865c7cf44eca1dee9079ce93f1708eb46ffc9b
genericGetMax
public Boolean genericGetMax()
{    return max;}
c803ca7a677bad689d1fb3d8f3185bf47a53bcf5190cea0f064fe1455c24a783
compareMinToValue
public int compareMinToValue(boolean value)
{    return comparator().compare(min, value);}
2fd9c1daa76751121cf2d0590f8b09cbc251d0a0c6a8bffe4cc556b29b1506cb
compareMaxToValue
public int compareMaxToValue(boolean value)
{    return comparator().compare(max, value);}
72fbdf318a50c9bec5fd9714e5188cd942dbbdaf56d164bac198112a219f49b5
getMax
public boolean getMax()
{    return max;}
44e651a90ec7401e71c33a33fc2963b4e44f0ea1afa6b81fae00bd518875805e
getMin
public boolean getMin()
{    return min;}
04843dc6945ef9cfb26ace0d9ee704be47adc2408e7e0171975ef6e32366f481
setMinMax
public void setMinMax(boolean min, boolean max)
{    this.max = max;    this.min = min;    this.markAsNotEmpty();}
302939ca3e3d3cbaeccd81ace99bf64ef65621e401748f85902044896aa50292
copy
public BooleanStatistics copy()
{    return new BooleanStatistics(this);}
d77b5cefa884e40ac0d507d113c922b2669e154e479ebfaef1d4abe70e5c3c1b
updateStats
public void updateStats(double value)
{    if (!this.hasNonNullValue()) {        initializeStats(value, value);    } else {        updateStats(value, value);    }}
a36d8e4b77b5be4ca5a64934a367c3bbe0f87d10d5919b51bf9306570c9d8347
mergeStatisticsMinMax
public void mergeStatisticsMinMax(Statistics stats)
{    DoubleStatistics doubleStats = (DoubleStatistics) stats;    if (!this.hasNonNullValue()) {        initializeStats(doubleStats.getMin(), doubleStats.getMax());    } else {        updateStats(doubleStats.getMin(), doubleStats.getMax());    }}
9a72df6e7e4267cfc4b0a639be0828168e49428717094c94964e155bd96b9e6b
setMinMaxFromBytes
public void setMinMaxFromBytes(byte[] minBytes, byte[] maxBytes)
{    max = Double.longBitsToDouble(BytesUtils.bytesToLong(maxBytes));    min = Double.longBitsToDouble(BytesUtils.bytesToLong(minBytes));    this.markAsNotEmpty();}
2f01645f365109018e12db7ec0bf767552c47bfcd30b1a2717601f85d39f0863
getMaxBytes
public byte[] getMaxBytes()
{    return BytesUtils.longToBytes(Double.doubleToLongBits(max));}
1faaa367315a898b7649ef1a372ebdc000ee59fbfd1eb5dbf59cc6c76f436718
getMinBytes
public byte[] getMinBytes()
{    return BytesUtils.longToBytes(Double.doubleToLongBits(min));}
c0074c4d8a278b03c356bf261acaed175f30eae64c07104a1c01b7fd77d01de4
stringify
 String stringify(Double value)
{    return stringifier.stringify(value);}
ee8a3e0a9edf3a8fe8c76c164b27a24a23c4a46da8b05b705a35e91c31b5a5f8
isSmallerThan
public boolean isSmallerThan(long size)
{    return !hasNonNullValue() || (16 < size);}
1300138f9eecc5c322ec50748421ac6cf42c1c5ab1163dc4eb835a059a038f9f
updateStats
public void updateStats(double min_value, double max_value)
{    if (comparator().compare(min, min_value) > 0) {        min = min_value;    }    if (comparator().compare(max, max_value) < 0) {        max = max_value;    }}
fbe8d8740527949716ce918e98c45aa5351ff6044e554aa8bb83d3fa7bffe9a9
initializeStats
public void initializeStats(double min_value, double max_value)
{    min = min_value;    max = max_value;    this.markAsNotEmpty();}
b8298c9b92dc2dd819f6a9cd592aa6978e7a877ef2526e0404d598d51e750a0c
genericGetMin
public Double genericGetMin()
{    return min;}
6b4c51e7ff2a25b47136561119a5f7c62245b7af142129d1afc694587d91701f
genericGetMax
public Double genericGetMax()
{    return max;}
09a3e9f125703c393398c5bc5a0ec9d11c7cddf2c0ae12eaa0190765d23c6544
compareMinToValue
public int compareMinToValue(double value)
{    return comparator().compare(min, value);}
7f1c56f9b6e864668e4fbdd148fb6b9e6a3af868a7da4fb131b93c0a63d1fc9a
compareMaxToValue
public int compareMaxToValue(double value)
{    return comparator().compare(max, value);}
344768211b8524396497604faa40c0faf07104b2ac1129fe45998a40221da827
getMax
public double getMax()
{    return max;}
028aeafab053f5bceceab90c3393687fa7a23c1f765b70af7a1a78527c825869
getMin
public double getMin()
{    return min;}
6a74e1041bf5575d38178b21bb93cfe291ffd532220259a4a53327afb7cc9478
setMinMax
public void setMinMax(double min, double max)
{    this.max = max;    this.min = min;    this.markAsNotEmpty();}
3c06b7d4944a4c9cf941e287317f77cb5d3c11bd15447e767c298501f205525e
copy
public DoubleStatistics copy()
{    return new DoubleStatistics(this);}
2f92cf049c0f59154aaaf2b797086b7b85cf1fd21c9ada207c48c41c53725cd9
updateStats
public void updateStats(float value)
{    if (!this.hasNonNullValue()) {        initializeStats(value, value);    } else {        updateStats(value, value);    }}
a36d8e4b77b5be4ca5a64934a367c3bbe0f87d10d5919b51bf9306570c9d8347
mergeStatisticsMinMax
public void mergeStatisticsMinMax(Statistics stats)
{    FloatStatistics floatStats = (FloatStatistics) stats;    if (!this.hasNonNullValue()) {        initializeStats(floatStats.getMin(), floatStats.getMax());    } else {        updateStats(floatStats.getMin(), floatStats.getMax());    }}
9a72df6e7e4267cfc4b0a639be0828168e49428717094c94964e155bd96b9e6b
setMinMaxFromBytes
public void setMinMaxFromBytes(byte[] minBytes, byte[] maxBytes)
{    max = Float.intBitsToFloat(BytesUtils.bytesToInt(maxBytes));    min = Float.intBitsToFloat(BytesUtils.bytesToInt(minBytes));    this.markAsNotEmpty();}
2f01645f365109018e12db7ec0bf767552c47bfcd30b1a2717601f85d39f0863
getMaxBytes
public byte[] getMaxBytes()
{    return BytesUtils.intToBytes(Float.floatToIntBits(max));}
1faaa367315a898b7649ef1a372ebdc000ee59fbfd1eb5dbf59cc6c76f436718
getMinBytes
public byte[] getMinBytes()
{    return BytesUtils.intToBytes(Float.floatToIntBits(min));}
4d57df7126f5044935652706ce7173ae7a10b2ab39678adb2084791d9a579b6d
stringify
 String stringify(Float value)
{    return stringifier.stringify(value);}
ee8a3e0a9edf3a8fe8c76c164b27a24a23c4a46da8b05b705a35e91c31b5a5f8
isSmallerThan
public boolean isSmallerThan(long size)
{    return !hasNonNullValue() || (8 < size);}
5e98f9efc95da1140f9fc78cec87269d088019312e361e5857c6633ae09cb256
updateStats
public void updateStats(float min_value, float max_value)
{    if (comparator().compare(min, min_value) > 0) {        min = min_value;    }    if (comparator().compare(max, max_value) < 0) {        max = max_value;    }}
52d748c72303c0fef22ae898952dce825d5b38d8f1d4c39db2a32a9d91e9c7f3
initializeStats
public void initializeStats(float min_value, float max_value)
{    min = min_value;    max = max_value;    this.markAsNotEmpty();}
db2cfeae5119991ccc43d087d799d3a7a3365821aafd355429324962ff43434c
genericGetMin
public Float genericGetMin()
{    return min;}
8487eb71d2278271265d288f7e59c41882d5886628070888dd55353beebc5da0
genericGetMax
public Float genericGetMax()
{    return max;}
3237fe0b1cee1b325c517830ef730083130cb805b788746c0e21dd0f37694dc7
compareMinToValue
public int compareMinToValue(float value)
{    return comparator().compare(min, value);}
b6b397b670859176e1dc6d7a9a2c81caa8eacb69554662356585007580928b46
compareMaxToValue
public int compareMaxToValue(float value)
{    return comparator().compare(max, value);}
4facea16fd1f93fe27ff9b34a0561cf1bf285761db336f131f0753a2a1b18f32
getMax
public float getMax()
{    return max;}
02139f36a3a5a2c7115c5e0e2c441af98af60fd5f7c5d7d3d703b9d2ff2a49ec
getMin
public float getMin()
{    return min;}
c7a2ec8c44a2b2b570bf6475604884418a7b7306b41832403be34c1c246db0b3
setMinMax
public void setMinMax(float min, float max)
{    this.max = max;    this.min = min;    this.markAsNotEmpty();}
754c88cab14ff0e6daf7c08603ab79c4df9a97e61b141db93d43547fb77a6b7b
copy
public FloatStatistics copy()
{    return new FloatStatistics(this);}
90e57873f39f973510912cd234b2b20bb37514a83f8f2bb47aa3a54dd456cd89
updateStats
public void updateStats(int value)
{    if (!this.hasNonNullValue()) {        initializeStats(value, value);    } else {        updateStats(value, value);    }}
a36d8e4b77b5be4ca5a64934a367c3bbe0f87d10d5919b51bf9306570c9d8347
mergeStatisticsMinMax
public void mergeStatisticsMinMax(Statistics stats)
{    IntStatistics intStats = (IntStatistics) stats;    if (!this.hasNonNullValue()) {        initializeStats(intStats.getMin(), intStats.getMax());    } else {        updateStats(intStats.getMin(), intStats.getMax());    }}
9a72df6e7e4267cfc4b0a639be0828168e49428717094c94964e155bd96b9e6b
setMinMaxFromBytes
public void setMinMaxFromBytes(byte[] minBytes, byte[] maxBytes)
{    max = BytesUtils.bytesToInt(maxBytes);    min = BytesUtils.bytesToInt(minBytes);    this.markAsNotEmpty();}
2f01645f365109018e12db7ec0bf767552c47bfcd30b1a2717601f85d39f0863
getMaxBytes
public byte[] getMaxBytes()
{    return BytesUtils.intToBytes(max);}
1faaa367315a898b7649ef1a372ebdc000ee59fbfd1eb5dbf59cc6c76f436718
getMinBytes
public byte[] getMinBytes()
{    return BytesUtils.intToBytes(min);}
00525a077900f82b837a8b566f1ed22521936a3377c5f5b8145bf70a167a9e91
stringify
 String stringify(Integer value)
{    return stringifier.stringify(value);}
ee8a3e0a9edf3a8fe8c76c164b27a24a23c4a46da8b05b705a35e91c31b5a5f8
isSmallerThan
public boolean isSmallerThan(long size)
{    return !hasNonNullValue() || (8 < size);}
84993e59d0e9c84dea4b3a676e1bb60e4d41e63ee064b334c71718484b955dbc
updateStats
public void updateStats(int min_value, int max_value)
{    if (comparator().compare(min, min_value) > 0) {        min = min_value;    }    if (comparator().compare(max, max_value) < 0) {        max = max_value;    }}
d236d1f527b211629f6f25cddbf7685262aa0b506d182f4523b6a3981e503e40
initializeStats
public void initializeStats(int min_value, int max_value)
{    min = min_value;    max = max_value;    this.markAsNotEmpty();}
bc6ea0c26d11ab13a8d3fade1925e74dd18be561f7a1f4fb562bd625d7e48643
genericGetMin
public Integer genericGetMin()
{    return min;}
6e2707dd67e1b42db131f6fa31795de367de9943a2551c46da95c1d084b776d1
genericGetMax
public Integer genericGetMax()
{    return max;}
24debb90ac1087edba194cb69344a543466b663377020d49f4bbdf9c02d52bc5
compareMinToValue
public int compareMinToValue(int value)
{    return comparator().compare(min, value);}
facc5bdf7ec319ecd31c8ac525759dde847cc9f50a82807ebd687022b9e1caf0
compareMaxToValue
public int compareMaxToValue(int value)
{    return comparator().compare(max, value);}
0162fc18d4a93b10d202d279493398c3ff82687c1dd39ad599a1186b2c596430
getMax
public int getMax()
{    return max;}
823878651dbcf7b281ceb9a8db0431f812559552e766a017c72cbdb7b69e1cb0
getMin
public int getMin()
{    return min;}
89afd99924b67fb6efbfc4c1de25ea505da86065657a4fc650f309e45b12c8cf
setMinMax
public void setMinMax(int min, int max)
{    this.max = max;    this.min = min;    this.markAsNotEmpty();}
9027bbe518456c2d76170a0313d990fe1a173417d4014346475ae081c31b4edb
copy
public IntStatistics copy()
{    return new IntStatistics(this);}
fa3bd39e5cd00023d4deba7edd35ccb558ddbdb36ab6c2cb753d19e09a42db68
updateStats
public void updateStats(long value)
{    if (!this.hasNonNullValue()) {        initializeStats(value, value);    } else {        updateStats(value, value);    }}
a36d8e4b77b5be4ca5a64934a367c3bbe0f87d10d5919b51bf9306570c9d8347
mergeStatisticsMinMax
public void mergeStatisticsMinMax(Statistics stats)
{    LongStatistics longStats = (LongStatistics) stats;    if (!this.hasNonNullValue()) {        initializeStats(longStats.getMin(), longStats.getMax());    } else {        updateStats(longStats.getMin(), longStats.getMax());    }}
9a72df6e7e4267cfc4b0a639be0828168e49428717094c94964e155bd96b9e6b
setMinMaxFromBytes
public void setMinMaxFromBytes(byte[] minBytes, byte[] maxBytes)
{    max = BytesUtils.bytesToLong(maxBytes);    min = BytesUtils.bytesToLong(minBytes);    this.markAsNotEmpty();}
2f01645f365109018e12db7ec0bf767552c47bfcd30b1a2717601f85d39f0863
getMaxBytes
public byte[] getMaxBytes()
{    return BytesUtils.longToBytes(max);}
1faaa367315a898b7649ef1a372ebdc000ee59fbfd1eb5dbf59cc6c76f436718
getMinBytes
public byte[] getMinBytes()
{    return BytesUtils.longToBytes(min);}
4f46f34d92c41e56fe74e6e94bf383cf9678ff58a27950049afe1b98c63a1883
stringify
 String stringify(Long value)
{    return stringifier.stringify(value);}
ee8a3e0a9edf3a8fe8c76c164b27a24a23c4a46da8b05b705a35e91c31b5a5f8
isSmallerThan
public boolean isSmallerThan(long size)
{    return !hasNonNullValue() || (16 < size);}
f3d229db4ebca3976dea8844e431868e0775418416360ce04f9b4e8a6e782ec9
updateStats
public void updateStats(long min_value, long max_value)
{    if (comparator().compare(min, min_value) > 0) {        min = min_value;    }    if (comparator().compare(max, max_value) < 0) {        max = max_value;    }}
aeed6dc05fd992d41322390c558c37ea9b767af14f745c4ea200cdd80606ef88
initializeStats
public void initializeStats(long min_value, long max_value)
{    min = min_value;    max = max_value;    this.markAsNotEmpty();}
807093f2d2010757cb88535d2a7d2e524cf815d8ffed0802c5e29172e6fc086d
genericGetMin
public Long genericGetMin()
{    return min;}
e8cc2b4cd56931c5ea815bf8e440c93aba86ccfc0607c66c5eb0aa31761a9563
genericGetMax
public Long genericGetMax()
{    return max;}
f09052a1e9e08f3e51e5e1a12325776be19ac49e0c33a9db1d95a66b76166442
compareMinToValue
public int compareMinToValue(long value)
{    return comparator().compare(min, value);}
20c48d26cc64573766a0f025cd0819e018e7f776a236abffe0926de129e8aa5c
compareMaxToValue
public int compareMaxToValue(long value)
{    return comparator().compare(max, value);}
186954df172aa73793e35935d4d56173de402d5bb93fb733250e56ecabcc93cf
getMax
public long getMax()
{    return max;}
e5532703446ad984632281d343d0cf95efa3233ebe068d58acaafd92f78afafd
getMin
public long getMin()
{    return min;}
0b12a2869e25b49f895b0ac3d5ef9e9c6c480a6bc96e6d4d213c5332b1125754
setMinMax
public void setMinMax(long min, long max)
{    this.max = max;    this.min = min;    this.markAsNotEmpty();}
4368b121260d5670e2303f4af3323c70b6fb25cd763bcb6f96385b892f76e9d0
copy
public LongStatistics copy()
{    return new LongStatistics(this);}
d6f8037a7538ae01510705b04a0393cae93de4e9c11914cb7648a10e00c9fbb6
withMin
public Builder withMin(byte[] min)
{    this.min = min;    return this;}
35fde078259858dc5f6aadb1bf9e9eaa5c5dcfc5e2439259d68c1e7cb230f71c
withMax
public Builder withMax(byte[] max)
{    this.max = max;    return this;}
c5595302f24f748352692b3181247be28a836dee59b20ca239fc837466d24d3d
withNumNulls
public Builder withNumNulls(long numNulls)
{    this.numNulls = numNulls;    return this;}
886bd624e7b572cc1313b485d59c4477eb89648c69e179c17f280ffbf8e1da9e
build
public Statistics<?> build()
{    Statistics<?> stats = createStats(type);    if (min != null && max != null) {        stats.setMinMaxFromBytes(min, max);    }    stats.num_nulls = this.numNulls;    return stats;}
886bd624e7b572cc1313b485d59c4477eb89648c69e179c17f280ffbf8e1da9e
build
public Statistics<?> build()
{    FloatStatistics stats = (FloatStatistics) super.build();    if (stats.hasNonNullValue()) {        Float min = stats.genericGetMin();        Float max = stats.genericGetMax();                if (min.isNaN() || max.isNaN()) {            stats.setMinMax(0.0f, 0.0f);            ((Statistics<?>) stats).hasNonNullValue = false;        } else {                        if (Float.compare(min, 0.0f) == 0) {                min = -0.0f;                stats.setMinMax(min, max);            }            if (Float.compare(max, -0.0f) == 0) {                max = 0.0f;                stats.setMinMax(min, max);            }        }    }    return stats;}
886bd624e7b572cc1313b485d59c4477eb89648c69e179c17f280ffbf8e1da9e
build
public Statistics<?> build()
{    DoubleStatistics stats = (DoubleStatistics) super.build();    if (stats.hasNonNullValue()) {        Double min = stats.genericGetMin();        Double max = stats.genericGetMax();                if (min.isNaN() || max.isNaN()) {            stats.setMinMax(0.0, 0.0);            ((Statistics<?>) stats).hasNonNullValue = false;        } else {                        if (Double.compare(min, 0.0) == 0) {                min = -0.0;                stats.setMinMax(min, max);            }            if (Double.compare(max, -0.0) == 0) {                max = 0.0;                stats.setMinMax(min, max);            }        }    }    return stats;}
7b902026f48bc5f2d47466ba39f97e80b31b8daeb658271ae5efc09638a73569
getStatsBasedOnType
public static Statistics getStatsBasedOnType(PrimitiveTypeName type)
{    switch(type) {        case INT32:            return new IntStatistics();        case INT64:            return new LongStatistics();        case FLOAT:            return new FloatStatistics();        case DOUBLE:            return new DoubleStatistics();        case BOOLEAN:            return new BooleanStatistics();        case BINARY:            return new BinaryStatistics();        case INT96:            return new BinaryStatistics();        case FIXED_LEN_BYTE_ARRAY:            return new BinaryStatistics();        default:            throw new UnknownColumnTypeException(type);    }}
30c1149905dd4e66d4fbe9de4eee3f56732093a1d2a2a307aca367842de7c773
createStats
public static Statistics<?> createStats(Type type)
{    PrimitiveType primitive = type.asPrimitiveType();    switch(primitive.getPrimitiveTypeName()) {        case INT32:            return new IntStatistics(primitive);        case INT64:            return new LongStatistics(primitive);        case FLOAT:            return new FloatStatistics(primitive);        case DOUBLE:            return new DoubleStatistics(primitive);        case BOOLEAN:            return new BooleanStatistics(primitive);        case BINARY:        case INT96:        case FIXED_LEN_BYTE_ARRAY:            return new BinaryStatistics(primitive);        default:            throw new UnknownColumnTypeException(primitive.getPrimitiveTypeName());    }}
d182e4e017fbc2e8452350912eaeb7a3b9087e7b16cf1cf33cf5c1f0b500518f
getBuilderForReading
public static Builder getBuilderForReading(PrimitiveType type)
{    switch(type.getPrimitiveTypeName()) {        case FLOAT:            return new FloatBuilder(type);        case DOUBLE:            return new DoubleBuilder(type);        default:            return new Builder(type);    }}
90e57873f39f973510912cd234b2b20bb37514a83f8f2bb47aa3a54dd456cd89
updateStats
public void updateStats(int value)
{    throw new UnsupportedOperationException();}
fa3bd39e5cd00023d4deba7edd35ccb558ddbdb36ab6c2cb753d19e09a42db68
updateStats
public void updateStats(long value)
{    throw new UnsupportedOperationException();}
2f92cf049c0f59154aaaf2b797086b7b85cf1fd21c9ada207c48c41c53725cd9
updateStats
public void updateStats(float value)
{    throw new UnsupportedOperationException();}
d77b5cefa884e40ac0d507d113c922b2669e154e479ebfaef1d4abe70e5c3c1b
updateStats
public void updateStats(double value)
{    throw new UnsupportedOperationException();}
5e32522053b4d69b1bfc8fab0d4e724880ae1acc1d29a42d3669a28a51501c77
updateStats
public void updateStats(boolean value)
{    throw new UnsupportedOperationException();}
91d853d12c7ae8baa067bb5488180dc7eec69b07c57ac12ccb0e8dabcbc7b1cf
updateStats
public void updateStats(Binary value)
{    throw new UnsupportedOperationException();}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    if (other == this)        return true;    if (!(other instanceof Statistics))        return false;    Statistics stats = (Statistics) other;    return type.equals(stats.type) && Arrays.equals(stats.getMaxBytes(), this.getMaxBytes()) && Arrays.equals(stats.getMinBytes(), this.getMinBytes()) && stats.getNumNulls() == this.getNumNulls();}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return 31 * type.hashCode() + 31 * Arrays.hashCode(getMaxBytes()) + 17 * Arrays.hashCode(getMinBytes()) + Long.valueOf(this.getNumNulls()).hashCode();}
1517d6f62ac213015b29eed3dc6bdb1b44c942d0b910378ae1d80c9590d0609d
mergeStatistics
public void mergeStatistics(Statistics stats)
{    if (stats.isEmpty())        return;        if (type.equals(stats.type)) {        incrementNumNulls(stats.getNumNulls());        if (stats.hasNonNullValue()) {            mergeStatisticsMinMax(stats);            markAsNotEmpty();        }    } else {        throw StatisticsClassException.create(this, stats);    }}
e73174ec98d37d500101af87ea16263fef2842d6df764f9b84cf0addbc0964c4
comparator
public final PrimitiveComparator<T> comparator()
{    return comparator;}
a799333c4b168056e3106af8c1e69a060cf5b01bf0eaeaad6ce3a39d705cc0c2
compareMinToValue
public final int compareMinToValue(T value)
{    return comparator.compare(genericGetMin(), value);}
77c1dec900731802d4466d8f8599c108229ad307c6d6c24e0843d834bbce3e5b
compareMaxToValue
public final int compareMaxToValue(T value)
{    return comparator.compare(genericGetMax(), value);}
922cb1485829e85161ea04d1a3588f3d8d88260049562226357ed5d9bdc0f225
minAsString
public String minAsString()
{    return stringify(genericGetMin());}
6fc57443c3a8687169a63b681c4bc2fda06b54a1ae8c6dcaafcaf59c50b1ceeb
maxAsString
public String maxAsString()
{    return stringify(genericGetMax());}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    if (this.hasNonNullValue()) {        if (isNumNullsSet()) {            return String.format("min: %s, max: %s, num_nulls: %d", minAsString(), maxAsString(), this.getNumNulls());        } else {            return String.format("min: %s, max: %s, num_nulls not defined", minAsString(), maxAsString());        }    } else if (!this.isEmpty())        return String.format("num_nulls: %d, min/max not defined", this.getNumNulls());    else        return "no stats for this column";}
6dd4c84a60e9320634be19a9f7af7d97a5724b2f684772738802422623172dba
incrementNumNulls
public void incrementNumNulls()
{    num_nulls++;}
bbab8d216ce81155d005bc557790a45a4a85c8fd41081bd2ef42dee0c1a87289
incrementNumNulls
public void incrementNumNulls(long increment)
{    num_nulls += increment;}
d0700fe0deb5f0e037ee1e04028eca46ccdc8e090670ff6b67e952401b212194
getNumNulls
public long getNumNulls()
{    return num_nulls;}
485c8bb4182f01c4181113a4d85d5b713f26b4337c144828739cf133efa4fabc
setNumNulls
public void setNumNulls(long nulls)
{    num_nulls = nulls;}
803915e853382ad445a6e2333fabb8beb8e4acd70e908a0d818400f7baac42af
isEmpty
public boolean isEmpty()
{    return !hasNonNullValue && !isNumNullsSet();}
b8e45cc42fb5abc08fc66be013f895286c486d6cf35d1fecea7aff310f5ae311
hasNonNullValue
public boolean hasNonNullValue()
{    return hasNonNullValue;}
405a8d1fab1a4211e60bdd6b2ffa8de38b4fa172f3400d27effafc7e97337364
isNumNullsSet
public boolean isNumNullsSet()
{    return num_nulls >= 0;}
4108ba423ab7fde641a7097802f31fe633a8841c025fda0b7b091f3f3e23f800
markAsNotEmpty
protected void markAsNotEmpty()
{    hasNonNullValue = true;}
7d97e6dfc64a838f79850e9c3edcf7e7f2c144c2dde9b0c949e86cb2ec489426
type
public PrimitiveType type()
{    return type;}
5396c202e237db0330fd707b881e2c4b083265c8e31469e4e6363daa9e40afdc
create
 static StatisticsClassException create(Statistics<?> stats1, Statistics<?> stats2)
{    if (stats1.getClass() != stats2.getClass()) {        return new StatisticsClassException(stats1.getClass().toString(), stats2.getClass().toString());    }    return new StatisticsClassException("Statistics comparator mismatched: " + stats1.comparator() + " vs. " + stats2.comparator());}
25bb4a2830d89627604ab65acf17e87089425b783110ac57cf189bfd3e72cc4f
getDescriptor
public ColumnDescriptor getDescriptor()
{    return descriptor;}
33863a388ceaa73f61f42ed255644025c13814df9196ccfe0d910ea0eaa4c759
getType
public PrimitiveTypeName getType()
{    return this.type;}
d8df9ef1bfee0aee5f248ce3a8a8027f0467f8a4d006cb1b13c566de23142ce5
readInteger
public int readInteger()
{    try {        return bitPackingReader.read();    } catch (IOException e) {        throw new ParquetDecodingException(e);    }}
01af9a6e21f393adbad03aaaec41ddfd2271cbe7147c3315adc23b32afbd1f1e
initFromPage
public void initFromPage(int valueCount, ByteBufferInputStream stream) throws IOException
{    int effectiveBitLength = valueCount * bitsPerValue;    int length = BytesUtils.paddedByteCountFromBits(effectiveBitLength);    LOG.debug("reading {} bytes for {} values of size {} bits.", length, valueCount, bitsPerValue);    this.in = stream.sliceStream(length);    this.bitPackingReader = createBitPackingReader(bitsPerValue, this.in, valueCount);    updateNextOffset(length);}
895e92fa2273cdf5e5c97c44b286ea867f7a7e0a6106c85286a4176e76e78d9d
skip
public void skip()
{    readInteger();}
d4ed25ac8ad321cf30617caf76c4576654e12017af8058c0917f5c720521f0ec
init
private void init()
{    this.bitPackingWriter = getBitPackingWriter(bitsPerValue, out);}
c0f4d43203aca7b2bdaaeaea2925c45142a8f4f8ce782e3195685290f3010a85
writeInteger
public void writeInteger(int v)
{    try {        bitPackingWriter.write(v);    } catch (IOException e) {        throw new ParquetEncodingException(e);    }}
0c921188cddfdbdd5e940a92767fca400663f7ba7c1b4fbfdb5a2e991b21cb93
getBufferedSize
public long getBufferedSize()
{    return out.size();}
318792bb7e7c97eb05ff79e99daac6fe67cad1bfa7ae196cf0f5d3f9cfdfd7b1
getBytes
public BytesInput getBytes()
{    try {        this.bitPackingWriter.finish();        return BytesInput.from(out);    } catch (IOException e) {        throw new ParquetEncodingException(e);    }}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    out.reset();    init();}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    out.close();}
3276143416d44249f488f85b127246b083e1e6024d88125aae60e635a8ad8ba7
getAllocatedSize
public long getAllocatedSize()
{    return out.getCapacity();}
729f860abc36decbc60be91f7b83b54762252f09cb85d7c4e9f7517c5dace502
memUsageString
public String memUsageString(String prefix)
{    return out.memUsageString(prefix);}
3d8ee53ad91e9129f673687f3d9fcb3f058bc5dc228085fdcc174f07e9247418
getEncoding
public Encoding getEncoding()
{    return BIT_PACKED;}
d8df9ef1bfee0aee5f248ce3a8a8027f0467f8a4d006cb1b13c566de23142ce5
readInteger
public int readInteger()
{    ++decodedPosition;    if (decodedPosition == decoded.length) {        try {            if (in.available() < bitWidth) {                                                byte[] tempEncode = new byte[bitWidth];                in.read(tempEncode, 0, in.available());                packer.unpack8Values(tempEncode, 0, decoded, 0);            } else {                ByteBuffer encoded = in.slice(bitWidth);                packer.unpack8Values(encoded, encoded.position(), decoded, 0);            }        } catch (IOException e) {            throw new ParquetDecodingException("Failed to read packed values", e);        }        decodedPosition = 0;    }    return decoded[decodedPosition];}
01af9a6e21f393adbad03aaaec41ddfd2271cbe7147c3315adc23b32afbd1f1e
initFromPage
public void initFromPage(int valueCount, ByteBufferInputStream stream) throws IOException
{    int effectiveBitLength = valueCount * bitWidth;        int length = BytesUtils.paddedByteCountFromBits(effectiveBitLength);    LOG.debug("reading {} bytes for {} values of size {} bits.", length, valueCount, bitWidth);                length = Math.min(length, stream.available());    this.in = stream.sliceStream(length);    this.decodedPosition = VALUES_AT_A_TIME - 1;    updateNextOffset(length);}
895e92fa2273cdf5e5c97c44b286ea867f7a7e0a6106c85286a4176e76e78d9d
skip
public void skip()
{    readInteger();}
c0f4d43203aca7b2bdaaeaea2925c45142a8f4f8ce782e3195685290f3010a85
writeInteger
public void writeInteger(int v)
{    try {        this.encoder.writeInt(v);    } catch (IOException e) {        throw new ParquetEncodingException(e);    }}
3d8ee53ad91e9129f673687f3d9fcb3f058bc5dc228085fdcc174f07e9247418
getEncoding
public Encoding getEncoding()
{    return BIT_PACKED;}
318792bb7e7c97eb05ff79e99daac6fe67cad1bfa7ae196cf0f5d3f9cfdfd7b1
getBytes
public BytesInput getBytes()
{    try {        return encoder.toBytes();    } catch (IOException e) {        throw new ParquetEncodingException(e);    }}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    encoder = new ByteBasedBitPackingEncoder(bitWidth, packer);}
0c921188cddfdbdd5e940a92767fca400663f7ba7c1b4fbfdb5a2e991b21cb93
getBufferedSize
public long getBufferedSize()
{    return encoder.getBufferSize();}
3276143416d44249f488f85b127246b083e1e6024d88125aae60e635a8ad8ba7
getAllocatedSize
public long getAllocatedSize()
{    return encoder.getAllocatedSize();}
729f860abc36decbc60be91f7b83b54762252f09cb85d7c4e9f7517c5dace502
memUsageString
public String memUsageString(String prefix)
{    return encoder.memUsageString(prefix);}
0c921188cddfdbdd5e940a92767fca400663f7ba7c1b4fbfdb5a2e991b21cb93
getBufferedSize
public long getBufferedSize()
{    return 0;}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{}
c0f4d43203aca7b2bdaaeaea2925c45142a8f4f8ce782e3195685290f3010a85
writeInteger
public void writeInteger(int v)
{}
644b5c9971438561394a816247116e501f32c7e55e2546a4568d0db0454d8779
writeByte
public void writeByte(int value)
{}
03850df0dc4909e107d68f02fa0e21869ab47db161066b909cedd886600a3783
writeBoolean
public void writeBoolean(boolean v)
{}
8f0216b0899ac492f9af6758d712efeddec16fcf44b260cf6adb8ec61358fd95
writeBytes
public void writeBytes(Binary v)
{}
d2d10759f3f6446c990ff017a3a12bb92aebe7b21235aeec4165a583a5f99843
writeLong
public void writeLong(long v)
{}
2b134caba1fc10f0ee1a1e74953ca441e44259f4d1e7999b06f1b84ad6d6360d
writeDouble
public void writeDouble(double v)
{}
6e1945aeb8741d792f7fb70e14deadbc9827e8eec055d14d90f9fa5c8549a12d
writeFloat
public void writeFloat(float v)
{}
318792bb7e7c97eb05ff79e99daac6fe67cad1bfa7ae196cf0f5d3f9cfdfd7b1
getBytes
public BytesInput getBytes()
{    return BytesInput.empty();}
3276143416d44249f488f85b127246b083e1e6024d88125aae60e635a8ad8ba7
getAllocatedSize
public long getAllocatedSize()
{    return 0;}
3d8ee53ad91e9129f673687f3d9fcb3f058bc5dc228085fdcc174f07e9247418
getEncoding
public Encoding getEncoding()
{    return BIT_PACKED;}
729f860abc36decbc60be91f7b83b54762252f09cb85d7c4e9f7517c5dace502
memUsageString
public String memUsageString(String prefix)
{    return prefix + "0";}
803ab4742e5b3385e5052b75dc976e7bf7e2467b84f95dd016410697fb5c3820
readConfig
public static DeltaBinaryPackingConfig readConfig(InputStream in) throws IOException
{    return new DeltaBinaryPackingConfig(BytesUtils.readUnsignedVarInt(in), BytesUtils.readUnsignedVarInt(in));}
e7347e5dbf9eb5716c33b216f2c94a3f2e31db1162bd7f08b668e90d692e183d
toBytesInput
public BytesInput toBytesInput()
{    return BytesInput.concat(BytesInput.fromUnsignedVarInt(blockSizeInValues), BytesInput.fromUnsignedVarInt(miniBlockNumInABlock));}
01af9a6e21f393adbad03aaaec41ddfd2271cbe7147c3315adc23b32afbd1f1e
initFromPage
public void initFromPage(int valueCount, ByteBufferInputStream stream) throws IOException
{    this.in = stream;    long startPos = in.position();    this.config = DeltaBinaryPackingConfig.readConfig(in);    this.totalValueCount = BytesUtils.readUnsignedVarInt(in);    allocateValuesBuffer();    bitWidths = new int[config.miniBlockNumInABlock];        valuesBuffer[valuesBuffered++] = BytesUtils.readZigZagVarLong(in);    while (valuesBuffered < totalValueCount) {                loadNewBlockToBuffer();    }    updateNextOffset((int) (in.position() - startPos));}
32ab086bee94fad4cd19d49d3c7b2bf64eb55a096a19298b654fe9cc15cbf2d4
allocateValuesBuffer
private void allocateValuesBuffer()
{    int totalMiniBlockCount = (int) Math.ceil((double) totalValueCount / config.miniBlockSizeInValues);        valuesBuffer = new long[totalMiniBlockCount * config.miniBlockSizeInValues + 1];}
895e92fa2273cdf5e5c97c44b286ea867f7a7e0a6106c85286a4176e76e78d9d
skip
public void skip()
{    checkRead();    valuesRead++;}
83659b3f3c32cda5d1e381b9ad4b7db55d1ee8ecce3504ad3c9ad45a376b6f2e
skip
public void skip(int n)
{        valuesRead += n - 1;    checkRead();    ++valuesRead;}
d8df9ef1bfee0aee5f248ce3a8a8027f0467f8a4d006cb1b13c566de23142ce5
readInteger
public int readInteger()
{        return (int) readLong();}
730921a7d0ef2efc7176d3cd9075bfb0f498473ea4299801ce714e8bf53bc895
readLong
public long readLong()
{    checkRead();    return valuesBuffer[valuesRead++];}
c14a40ca9b9ea6e9e4f70d3b30ef4bbc4e4b0fc45a47306701b7292666de6143
checkRead
private void checkRead()
{    if (valuesRead >= totalValueCount) {        throw new ParquetDecodingException("no more value to read, total value count is " + totalValueCount);    }}
d0cad8e6fd75107d0259d89d579a0719a0de87bac8accd2093059d5e0fcf8dbc
loadNewBlockToBuffer
private void loadNewBlockToBuffer() throws IOException
{    try {        minDeltaInCurrentBlock = BytesUtils.readZigZagVarLong(in);    } catch (IOException e) {        throw new ParquetDecodingException("can not read min delta in current block", e);    }    readBitWidthsForMiniBlocks();        int i;    for (i = 0; i < config.miniBlockNumInABlock && valuesBuffered < totalValueCount; i++) {        BytePackerForLong packer = Packer.LITTLE_ENDIAN.newBytePackerForLong(bitWidths[i]);        unpackMiniBlock(packer);    }        int valueUnpacked = i * config.miniBlockSizeInValues;    for (int j = valuesBuffered - valueUnpacked; j < valuesBuffered; j++) {        int index = j;        valuesBuffer[index] += minDeltaInCurrentBlock + valuesBuffer[index - 1];    }}
cfadf15b3fbf15ed02d59b45820b230f9a7be4cdb6225927d0e0543773c6ebe8
unpackMiniBlock
private void unpackMiniBlock(BytePackerForLong packer) throws IOException
{    for (int j = 0; j < config.miniBlockSizeInValues; j += 8) {        unpack8Values(packer);    }}
755beb457e1fa29db164418bb41c469f18bcf4aad85b111c8143e261c7d32cbd
unpack8Values
private void unpack8Values(BytePackerForLong packer) throws IOException
{            ByteBuffer buffer = in.slice(packer.getBitWidth());    packer.unpack8Values(buffer, buffer.position(), valuesBuffer, valuesBuffered);    this.valuesBuffered += 8;}
41ea83f122c82661fec339f20bdd379a856e7d661d22f14178f07cb029628e64
readBitWidthsForMiniBlocks
private void readBitWidthsForMiniBlocks()
{    for (int i = 0; i < config.miniBlockNumInABlock; i++) {        try {            bitWidths[i] = BytesUtils.readIntLittleEndianOnOneByte(in);        } catch (IOException e) {            throw new ParquetDecodingException("Can not decode bitwidth in block header", e);        }    }}
0c921188cddfdbdd5e940a92767fca400663f7ba7c1b4fbfdb5a2e991b21cb93
getBufferedSize
public long getBufferedSize()
{    return baos.size();}
ef02eff11aa674839548aa444e0c75fd7dfed6fb9dcb8abcbb8e36d52aec60ee
writeBitWidthForMiniBlock
protected void writeBitWidthForMiniBlock(int i)
{    try {        BytesUtils.writeIntLittleEndianOnOneByte(baos, bitWidths[i]);    } catch (IOException e) {        throw new ParquetEncodingException("can not write bitwith for miniblock", e);    }}
6133912ca57d747d4db443a156ddc715be0bcfa4b42a0aad52c87e964631f1a9
getMiniBlockCountToFlush
protected int getMiniBlockCountToFlush(double numberCount)
{    return (int) Math.ceil(numberCount / config.miniBlockSizeInValues);}
3d8ee53ad91e9129f673687f3d9fcb3f058bc5dc228085fdcc174f07e9247418
getEncoding
public Encoding getEncoding()
{    return Encoding.DELTA_BINARY_PACKED;}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    this.totalValueCount = 0;    this.baos.reset();    this.deltaValuesToFlush = 0;}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    this.totalValueCount = 0;    this.baos.close();    this.deltaValuesToFlush = 0;}
3276143416d44249f488f85b127246b083e1e6024d88125aae60e635a8ad8ba7
getAllocatedSize
public long getAllocatedSize()
{    return baos.getCapacity();}
729f860abc36decbc60be91f7b83b54762252f09cb85d7c4e9f7517c5dace502
memUsageString
public String memUsageString(String prefix)
{    return String.format("%s DeltaBinaryPacking %d bytes", prefix, getAllocatedSize());}
c0f4d43203aca7b2bdaaeaea2925c45142a8f4f8ce782e3195685290f3010a85
writeInteger
public void writeInteger(int v)
{    totalValueCount++;    if (totalValueCount == 1) {        firstValue = v;        previousValue = firstValue;        return;    }                int delta = v - previousValue;    previousValue = v;    deltaBlockBuffer[deltaValuesToFlush++] = delta;    if (delta < minDeltaInCurrentBlock) {        minDeltaInCurrentBlock = delta;    }    if (config.blockSizeInValues == deltaValuesToFlush) {        flushBlockBuffer();    }}
6482f7db12c87c76e5d38d9fdb2bb161c1ec74927f7fbdf3d8dd958869398a70
flushBlockBuffer
private void flushBlockBuffer()
{        for (int i = 0; i < deltaValuesToFlush; i++) {        deltaBlockBuffer[i] = deltaBlockBuffer[i] - minDeltaInCurrentBlock;    }    writeMinDelta();    int miniBlocksToFlush = getMiniBlockCountToFlush(deltaValuesToFlush);    calculateBitWidthsForDeltaBlockBuffer(miniBlocksToFlush);    for (int i = 0; i < config.miniBlockNumInABlock; i++) {        writeBitWidthForMiniBlock(i);    }    for (int i = 0; i < miniBlocksToFlush; i++) {                int currentBitWidth = bitWidths[i];        int blockOffset = 0;        BytePacker packer = Packer.LITTLE_ENDIAN.newBytePacker(currentBitWidth);        int miniBlockStart = i * config.miniBlockSizeInValues;        for (int j = miniBlockStart; j < (i + 1) * config.miniBlockSizeInValues; j += 8) {                                                                        packer.pack8Values(deltaBlockBuffer, j, miniBlockByteBuffer, blockOffset);            blockOffset += currentBitWidth;        }        baos.write(miniBlockByteBuffer, 0, blockOffset);    }    minDeltaInCurrentBlock = Integer.MAX_VALUE;    deltaValuesToFlush = 0;}
468d54c87cceb4a46f0bdda6a518c70b574720f82567af6b563407bd0e2a9b83
writeMinDelta
private void writeMinDelta()
{    try {        BytesUtils.writeZigZagVarInt(minDeltaInCurrentBlock, baos);    } catch (IOException e) {        throw new ParquetEncodingException("can not write min delta for block", e);    }}
3fe92aa7be2a9e2d2c71971913aea66d661be39e30b8044effca14e628caebe6
calculateBitWidthsForDeltaBlockBuffer
private void calculateBitWidthsForDeltaBlockBuffer(int miniBlocksToFlush)
{    for (int miniBlockIndex = 0; miniBlockIndex < miniBlocksToFlush; miniBlockIndex++) {        int mask = 0;        int miniStart = miniBlockIndex * config.miniBlockSizeInValues;                int miniEnd = Math.min((miniBlockIndex + 1) * config.miniBlockSizeInValues, deltaValuesToFlush);        for (int i = miniStart; i < miniEnd; i++) {            mask |= deltaBlockBuffer[i];        }        bitWidths[miniBlockIndex] = 32 - Integer.numberOfLeadingZeros(mask);    }}
318792bb7e7c97eb05ff79e99daac6fe67cad1bfa7ae196cf0f5d3f9cfdfd7b1
getBytes
public BytesInput getBytes()
{        if (deltaValuesToFlush != 0) {        flushBlockBuffer();    }    return BytesInput.concat(config.toBytesInput(), BytesInput.fromUnsignedVarInt(totalValueCount), BytesInput.fromZigZagVarInt(firstValue), BytesInput.from(baos));}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    super.reset();    this.minDeltaInCurrentBlock = Integer.MAX_VALUE;}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    super.close();    this.minDeltaInCurrentBlock = Integer.MAX_VALUE;}
d2d10759f3f6446c990ff017a3a12bb92aebe7b21235aeec4165a583a5f99843
writeLong
public void writeLong(long v)
{    totalValueCount++;    if (totalValueCount == 1) {        firstValue = v;        previousValue = firstValue;        return;    }                long delta = v - previousValue;    previousValue = v;    deltaBlockBuffer[deltaValuesToFlush++] = delta;    if (delta < minDeltaInCurrentBlock) {        minDeltaInCurrentBlock = delta;    }    if (config.blockSizeInValues == deltaValuesToFlush) {        flushBlockBuffer();    }}
6482f7db12c87c76e5d38d9fdb2bb161c1ec74927f7fbdf3d8dd958869398a70
flushBlockBuffer
private void flushBlockBuffer()
{        for (int i = 0; i < deltaValuesToFlush; i++) {        deltaBlockBuffer[i] = deltaBlockBuffer[i] - minDeltaInCurrentBlock;    }    writeMinDelta();    int miniBlocksToFlush = getMiniBlockCountToFlush(deltaValuesToFlush);    calculateBitWidthsForDeltaBlockBuffer(miniBlocksToFlush);    for (int i = 0; i < config.miniBlockNumInABlock; i++) {        writeBitWidthForMiniBlock(i);    }    for (int i = 0; i < miniBlocksToFlush; i++) {                int currentBitWidth = bitWidths[i];        int blockOffset = 0;                BytePackerForLong packer = Packer.LITTLE_ENDIAN.newBytePackerForLong(currentBitWidth);        int miniBlockStart = i * config.miniBlockSizeInValues;                for (int j = miniBlockStart; j < (i + 1) * config.miniBlockSizeInValues; j += 8) {                                                            packer.pack8Values(deltaBlockBuffer, j, miniBlockByteBuffer, blockOffset);            blockOffset += currentBitWidth;        }        baos.write(miniBlockByteBuffer, 0, blockOffset);    }    minDeltaInCurrentBlock = Long.MAX_VALUE;    deltaValuesToFlush = 0;}
468d54c87cceb4a46f0bdda6a518c70b574720f82567af6b563407bd0e2a9b83
writeMinDelta
private void writeMinDelta()
{    try {        BytesUtils.writeZigZagVarLong(minDeltaInCurrentBlock, baos);    } catch (IOException e) {        throw new ParquetEncodingException("can not write min delta for block", e);    }}
3fe92aa7be2a9e2d2c71971913aea66d661be39e30b8044effca14e628caebe6
calculateBitWidthsForDeltaBlockBuffer
private void calculateBitWidthsForDeltaBlockBuffer(int miniBlocksToFlush)
{    for (int miniBlockIndex = 0; miniBlockIndex < miniBlocksToFlush; miniBlockIndex++) {        long mask = 0;        int miniStart = miniBlockIndex * config.miniBlockSizeInValues;                int miniEnd = Math.min((miniBlockIndex + 1) * config.miniBlockSizeInValues, deltaValuesToFlush);        for (int i = miniStart; i < miniEnd; i++) {            mask |= deltaBlockBuffer[i];        }        bitWidths[miniBlockIndex] = 64 - Long.numberOfLeadingZeros(mask);    }}
318792bb7e7c97eb05ff79e99daac6fe67cad1bfa7ae196cf0f5d3f9cfdfd7b1
getBytes
public BytesInput getBytes()
{        if (deltaValuesToFlush != 0) {        flushBlockBuffer();    }    return BytesInput.concat(config.toBytesInput(), BytesInput.fromUnsignedVarInt(totalValueCount), BytesInput.fromZigZagVarLong(firstValue), BytesInput.from(baos));}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    super.reset();    this.minDeltaInCurrentBlock = Long.MAX_VALUE;}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    super.close();    this.minDeltaInCurrentBlock = Long.MAX_VALUE;}
01af9a6e21f393adbad03aaaec41ddfd2271cbe7147c3315adc23b32afbd1f1e
initFromPage
public void initFromPage(int valueCount, ByteBufferInputStream stream) throws IOException
{    LOG.debug("init from page at offset {} for length {}", stream.position(), stream.available());    lengthReader.initFromPage(valueCount, stream);    this.in = stream.remainingStream();}
d4b7df18ce82f584ed081b22220ce7c9d747c434184149ef37e15f72accbd8a5
readBytes
public Binary readBytes()
{    int length = lengthReader.readInteger();    try {        return Binary.fromConstantByteBuffer(in.slice(length));    } catch (IOException e) {        throw new ParquetDecodingException("Failed to read " + length + " bytes");    }}
895e92fa2273cdf5e5c97c44b286ea867f7a7e0a6106c85286a4176e76e78d9d
skip
public void skip()
{    skip(1);}
83659b3f3c32cda5d1e381b9ad4b7db55d1ee8ecce3504ad3c9ad45a376b6f2e
skip
public void skip(int n)
{    int length = 0;    for (int i = 0; i < n; ++i) {        length += lengthReader.readInteger();    }    try {        in.skipFully(length);    } catch (IOException e) {        throw new ParquetDecodingException("Failed to skip " + length + " bytes");    }}
8f0216b0899ac492f9af6758d712efeddec16fcf44b260cf6adb8ec61358fd95
writeBytes
public void writeBytes(Binary v)
{    try {        lengthWriter.writeInteger(v.length());        v.writeTo(out);    } catch (IOException e) {        throw new ParquetEncodingException("could not write bytes", e);    }}
0c921188cddfdbdd5e940a92767fca400663f7ba7c1b4fbfdb5a2e991b21cb93
getBufferedSize
public long getBufferedSize()
{    return lengthWriter.getBufferedSize() + arrayOut.size();}
318792bb7e7c97eb05ff79e99daac6fe67cad1bfa7ae196cf0f5d3f9cfdfd7b1
getBytes
public BytesInput getBytes()
{    try {        out.flush();    } catch (IOException e) {        throw new ParquetEncodingException("could not write page", e);    }    LOG.debug("writing a buffer of size {}", arrayOut.size());    return BytesInput.concat(lengthWriter.getBytes(), BytesInput.from(arrayOut));}
3d8ee53ad91e9129f673687f3d9fcb3f058bc5dc228085fdcc174f07e9247418
getEncoding
public Encoding getEncoding()
{    return Encoding.DELTA_LENGTH_BYTE_ARRAY;}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    lengthWriter.reset();    arrayOut.reset();}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    lengthWriter.close();    arrayOut.close();}
3276143416d44249f488f85b127246b083e1e6024d88125aae60e635a8ad8ba7
getAllocatedSize
public long getAllocatedSize()
{    return lengthWriter.getAllocatedSize() + arrayOut.getCapacity();}
729f860abc36decbc60be91f7b83b54762252f09cb85d7c4e9f7517c5dace502
memUsageString
public String memUsageString(String prefix)
{    return arrayOut.memUsageString(lengthWriter.memUsageString(prefix) + " DELTA_LENGTH_BYTE_ARRAY");}
01af9a6e21f393adbad03aaaec41ddfd2271cbe7147c3315adc23b32afbd1f1e
initFromPage
public void initFromPage(int valueCount, ByteBufferInputStream stream) throws IOException
{    prefixLengthReader.initFromPage(valueCount, stream);    suffixReader.initFromPage(valueCount, stream);}
895e92fa2273cdf5e5c97c44b286ea867f7a7e0a6106c85286a4176e76e78d9d
skip
public void skip()
{        readBytes();}
d4b7df18ce82f584ed081b22220ce7c9d747c434184149ef37e15f72accbd8a5
readBytes
public Binary readBytes()
{    int prefixLength = prefixLengthReader.readInteger();        Binary suffix = suffixReader.readBytes();    int length = prefixLength + suffix.length();        if (prefixLength != 0) {        byte[] out = new byte[length];        System.arraycopy(previous.getBytesUnsafe(), 0, out, 0, prefixLength);        System.arraycopy(suffix.getBytesUnsafe(), 0, out, prefixLength, suffix.length());        previous = Binary.fromConstantByteArray(out);    } else {        previous = suffix;    }    return previous;}
4fc4f5e937e64888cc2d0f2cc8d4a4c6127f97fb28127f6d01f01636e5f9725d
setPreviousReader
public void setPreviousReader(ValuesReader reader)
{    if (reader != null) {        this.previous = ((DeltaByteArrayReader) reader).previous;    }}
0c921188cddfdbdd5e940a92767fca400663f7ba7c1b4fbfdb5a2e991b21cb93
getBufferedSize
public long getBufferedSize()
{    return prefixLengthWriter.getBufferedSize() + suffixWriter.getBufferedSize();}
318792bb7e7c97eb05ff79e99daac6fe67cad1bfa7ae196cf0f5d3f9cfdfd7b1
getBytes
public BytesInput getBytes()
{    return BytesInput.concat(prefixLengthWriter.getBytes(), suffixWriter.getBytes());}
3d8ee53ad91e9129f673687f3d9fcb3f058bc5dc228085fdcc174f07e9247418
getEncoding
public Encoding getEncoding()
{    return Encoding.DELTA_BYTE_ARRAY;}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    prefixLengthWriter.reset();    suffixWriter.reset();    previous = new byte[0];}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    prefixLengthWriter.close();    suffixWriter.close();}
3276143416d44249f488f85b127246b083e1e6024d88125aae60e635a8ad8ba7
getAllocatedSize
public long getAllocatedSize()
{    return prefixLengthWriter.getAllocatedSize() + suffixWriter.getAllocatedSize();}
729f860abc36decbc60be91f7b83b54762252f09cb85d7c4e9f7517c5dace502
memUsageString
public String memUsageString(String prefix)
{    prefix = prefixLengthWriter.memUsageString(prefix);    return suffixWriter.memUsageString(prefix + "  DELTA_STRINGS");}
8f0216b0899ac492f9af6758d712efeddec16fcf44b260cf6adb8ec61358fd95
writeBytes
public void writeBytes(Binary v)
{    int i = 0;    byte[] vb = v.getBytes();    int length = previous.length < vb.length ? previous.length : vb.length;        for (i = 0; (i < length) && (previous[i] == vb[i]); i++) ;    prefixLengthWriter.writeInteger(i);    suffixWriter.writeBytes(v.slice(i, vb.length - i));    previous = vb;}
01af9a6e21f393adbad03aaaec41ddfd2271cbe7147c3315adc23b32afbd1f1e
initFromPage
public void initFromPage(int valueCount, ByteBufferInputStream stream) throws IOException
{    this.in = stream.remainingStream();    if (in.available() > 0) {        LOG.debug("init from page at offset {} for length {}", stream.position(), stream.available());        int bitWidth = BytesUtils.readIntLittleEndianOnOneByte(in);        LOG.debug("bit width {}", bitWidth);        decoder = new RunLengthBitPackingHybridDecoder(bitWidth, in);    } else {        decoder = new RunLengthBitPackingHybridDecoder(1, in) {            @Override            public int readInt() throws IOException {                throw new IOException("Attempt to read from empty page");            }        };    }}
f236e7fb1e87c9b6c5be0f35fb6c4eb85b118d1b426358e70800a74f43350299
readInt
public int readInt() throws IOException
{    throw new IOException("Attempt to read from empty page");}
43e2732541efcf41e0296bfe8823bc201ca2305ae0426fa9cd8524eff48b292d
readValueDictionaryId
public int readValueDictionaryId()
{    try {        return decoder.readInt();    } catch (IOException e) {        throw new ParquetDecodingException(e);    }}
d4b7df18ce82f584ed081b22220ce7c9d747c434184149ef37e15f72accbd8a5
readBytes
public Binary readBytes()
{    try {        return dictionary.decodeToBinary(decoder.readInt());    } catch (IOException e) {        throw new ParquetDecodingException(e);    }}
259231fd3c9d3226ead8aa14f18984f79d990802bee7f1567c1637dfbbcc072a
readFloat
public float readFloat()
{    try {        return dictionary.decodeToFloat(decoder.readInt());    } catch (IOException e) {        throw new ParquetDecodingException(e);    }}
c9fd13d4898df6fa5844155b1eb3aff624d9da4a466717e380b0eb68932ca73a
readDouble
public double readDouble()
{    try {        return dictionary.decodeToDouble(decoder.readInt());    } catch (IOException e) {        throw new ParquetDecodingException(e);    }}
d8df9ef1bfee0aee5f248ce3a8a8027f0467f8a4d006cb1b13c566de23142ce5
readInteger
public int readInteger()
{    try {        return dictionary.decodeToInt(decoder.readInt());    } catch (IOException e) {        throw new ParquetDecodingException(e);    }}
730921a7d0ef2efc7176d3cd9075bfb0f498473ea4299801ce714e8bf53bc895
readLong
public long readLong()
{    try {        return dictionary.decodeToLong(decoder.readInt());    } catch (IOException e) {        throw new ParquetDecodingException(e);    }}
895e92fa2273cdf5e5c97c44b286ea867f7a7e0a6106c85286a4176e76e78d9d
skip
public void skip()
{    try {                decoder.readInt();    } catch (IOException e) {        throw new ParquetDecodingException(e);    }}
7533ca139f5374edcef9bfa721cc0f4675d7e1b4963962acfea8f04022857ce0
dictPage
protected DictionaryPage dictPage(ValuesWriter dictPageWriter)
{    DictionaryPage ret = new DictionaryPage(dictPageWriter.getBytes(), lastUsedDictionarySize, encodingForDictionaryPage);    dictPageWriter.close();    return ret;}
9e4d1ff4a7021ac14a7ca5ce58aed7e272aac3cd61bfb72fe4ad4ff11adc3e7a
shouldFallBack
public boolean shouldFallBack()
{        return dictionaryByteSize > maxDictionaryByteSize || getDictionarySize() > MAX_DICTIONARY_ENTRIES;}
3acdd2c6db0913654246577f213b98b0510106428d2695c5b5a9c686ee5a93ab
isCompressionSatisfying
public boolean isCompressionSatisfying(long rawSize, long encodedSize)
{    return (encodedSize + dictionaryByteSize) < rawSize;}
ce2d1323b6c029419fdf0b7f349d0a9416fabef364bd0e9a3caf61441fdbef31
fallBackAllValuesTo
public void fallBackAllValuesTo(ValuesWriter writer)
{    fallBackDictionaryEncodedData(writer);    if (lastUsedDictionarySize == 0) {                        clearDictionaryContent();        dictionaryByteSize = 0;        encodedValues = new IntList();    }}
0c921188cddfdbdd5e940a92767fca400663f7ba7c1b4fbfdb5a2e991b21cb93
getBufferedSize
public long getBufferedSize()
{    return encodedValues.size() * 4;}
3276143416d44249f488f85b127246b083e1e6024d88125aae60e635a8ad8ba7
getAllocatedSize
public long getAllocatedSize()
{        return encodedValues.size() * 4 + dictionaryByteSize;}
318792bb7e7c97eb05ff79e99daac6fe67cad1bfa7ae196cf0f5d3f9cfdfd7b1
getBytes
public BytesInput getBytes()
{    int maxDicId = getDictionarySize() - 1;    LOG.debug("max dic id {}", maxDicId);    int bitWidth = BytesUtils.getWidthFromMaxInt(maxDicId);    int initialSlabSize = CapacityByteArrayOutputStream.initialSlabSizeHeuristic(MIN_INITIAL_SLAB_SIZE, maxDictionaryByteSize, 10);    RunLengthBitPackingHybridEncoder encoder = new RunLengthBitPackingHybridEncoder(bitWidth, initialSlabSize, maxDictionaryByteSize, this.allocator);    encoders.add(encoder);    IntIterator iterator = encodedValues.iterator();    try {        while (iterator.hasNext()) {            encoder.writeInt(iterator.next());        }                byte[] bytesHeader = new byte[] { (byte) bitWidth };        BytesInput rleEncodedBytes = encoder.toBytes();        LOG.debug("rle encoded bytes {}", rleEncodedBytes.size());        BytesInput bytes = concat(BytesInput.from(bytesHeader), rleEncodedBytes);                lastUsedDictionarySize = getDictionarySize();        lastUsedDictionaryByteSize = dictionaryByteSize;        return bytes;    } catch (IOException e) {        throw new ParquetEncodingException("could not encode the values", e);    }}
3d8ee53ad91e9129f673687f3d9fcb3f058bc5dc228085fdcc174f07e9247418
getEncoding
public Encoding getEncoding()
{    return encodingForDataPage;}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    close();    encodedValues = new IntList();}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    encodedValues = null;    for (RunLengthBitPackingHybridEncoder encoder : encoders) {        encoder.close();    }    encoders.clear();}
d34554e133628c3de53cb7945dabf922642e706ac094e41625de3301789e96ac
resetDictionary
public void resetDictionary()
{    lastUsedDictionaryByteSize = 0;    lastUsedDictionarySize = 0;    dictionaryTooBig = false;    clearDictionaryContent();}
729f860abc36decbc60be91f7b83b54762252f09cb85d7c4e9f7517c5dace502
memUsageString
public String memUsageString(String prefix)
{    return String.format("%s DictionaryValuesWriter{\n" + "%s\n" + "%s\n" + "%s}\n", prefix, prefix + " dict:" + dictionaryByteSize, prefix + " values:" + String.valueOf(encodedValues.size() * 4), prefix);}
8f0216b0899ac492f9af6758d712efeddec16fcf44b260cf6adb8ec61358fd95
writeBytes
public void writeBytes(Binary v)
{    int id = binaryDictionaryContent.getInt(v);    if (id == -1) {        id = binaryDictionaryContent.size();        binaryDictionaryContent.put(v.copy(), id);                dictionaryByteSize += 4 + v.length();    }    encodedValues.add(id);}
3e809661c729299349085dcffce747bcd55283e108fa12d02f6ef024c7df9eaf
toDictPageAndClose
public DictionaryPage toDictPageAndClose()
{    if (lastUsedDictionarySize > 0) {                PlainValuesWriter dictionaryEncoder = new PlainValuesWriter(lastUsedDictionaryByteSize, maxDictionaryByteSize, allocator);        Iterator<Binary> binaryIterator = binaryDictionaryContent.keySet().iterator();                for (int i = 0; i < lastUsedDictionarySize; i++) {            Binary entry = binaryIterator.next();            dictionaryEncoder.writeBytes(entry);        }        return dictPage(dictionaryEncoder);    }    return null;}
e1f28ce1194b6863bdea6cb4c90dd928ace5f30fc468261e7189520cc534c61b
getDictionarySize
public int getDictionarySize()
{    return binaryDictionaryContent.size();}
b8791112bf5cdc6bdd535ba46d81559c50598e7df5826ab8a02ed686d8f1e1f1
clearDictionaryContent
protected void clearDictionaryContent()
{    binaryDictionaryContent.clear();}
827efac621d671f9e73f0d60dbdde0bc8bb7b1a1314e9ee23b11b74dd2f86e1d
fallBackDictionaryEncodedData
public void fallBackDictionaryEncodedData(ValuesWriter writer)
{        Binary[] reverseDictionary = new Binary[getDictionarySize()];    for (Object2IntMap.Entry<Binary> entry : binaryDictionaryContent.object2IntEntrySet()) {        reverseDictionary[entry.getIntValue()] = entry.getKey();    }        IntIterator iterator = encodedValues.iterator();    while (iterator.hasNext()) {        int id = iterator.next();        writer.writeBytes(reverseDictionary[id]);    }}
683fd301a6a971807dc709d60c69147741dfc970375314f928f661a4c0736351
writeBytes
public void writeBytes(Binary value)
{    int id = binaryDictionaryContent.getInt(value);    if (id == -1) {        id = binaryDictionaryContent.size();        binaryDictionaryContent.put(value.copy(), id);        dictionaryByteSize += length;    }    encodedValues.add(id);}
3e809661c729299349085dcffce747bcd55283e108fa12d02f6ef024c7df9eaf
toDictPageAndClose
public DictionaryPage toDictPageAndClose()
{    if (lastUsedDictionarySize > 0) {                FixedLenByteArrayPlainValuesWriter dictionaryEncoder = new FixedLenByteArrayPlainValuesWriter(length, lastUsedDictionaryByteSize, maxDictionaryByteSize, allocator);        Iterator<Binary> binaryIterator = binaryDictionaryContent.keySet().iterator();                for (int i = 0; i < lastUsedDictionarySize; i++) {            Binary entry = binaryIterator.next();            dictionaryEncoder.writeBytes(entry);        }        return dictPage(dictionaryEncoder);    }    return null;}
d2d10759f3f6446c990ff017a3a12bb92aebe7b21235aeec4165a583a5f99843
writeLong
public void writeLong(long v)
{    int id = longDictionaryContent.get(v);    if (id == -1) {        id = longDictionaryContent.size();        longDictionaryContent.put(v, id);        dictionaryByteSize += 8;    }    encodedValues.add(id);}
3e809661c729299349085dcffce747bcd55283e108fa12d02f6ef024c7df9eaf
toDictPageAndClose
public DictionaryPage toDictPageAndClose()
{    if (lastUsedDictionarySize > 0) {                PlainValuesWriter dictionaryEncoder = new PlainValuesWriter(lastUsedDictionaryByteSize, maxDictionaryByteSize, allocator);        LongIterator longIterator = longDictionaryContent.keySet().iterator();                for (int i = 0; i < lastUsedDictionarySize; i++) {            dictionaryEncoder.writeLong(longIterator.nextLong());        }        return dictPage(dictionaryEncoder);    }    return null;}
e1f28ce1194b6863bdea6cb4c90dd928ace5f30fc468261e7189520cc534c61b
getDictionarySize
public int getDictionarySize()
{    return longDictionaryContent.size();}
b8791112bf5cdc6bdd535ba46d81559c50598e7df5826ab8a02ed686d8f1e1f1
clearDictionaryContent
protected void clearDictionaryContent()
{    longDictionaryContent.clear();}
827efac621d671f9e73f0d60dbdde0bc8bb7b1a1314e9ee23b11b74dd2f86e1d
fallBackDictionaryEncodedData
public void fallBackDictionaryEncodedData(ValuesWriter writer)
{        long[] reverseDictionary = new long[getDictionarySize()];    ObjectIterator<Long2IntMap.Entry> entryIterator = longDictionaryContent.long2IntEntrySet().iterator();    while (entryIterator.hasNext()) {        Long2IntMap.Entry entry = entryIterator.next();        reverseDictionary[entry.getIntValue()] = entry.getLongKey();    }        IntIterator iterator = encodedValues.iterator();    while (iterator.hasNext()) {        int id = iterator.next();        writer.writeLong(reverseDictionary[id]);    }}
2b134caba1fc10f0ee1a1e74953ca441e44259f4d1e7999b06f1b84ad6d6360d
writeDouble
public void writeDouble(double v)
{    int id = doubleDictionaryContent.get(v);    if (id == -1) {        id = doubleDictionaryContent.size();        doubleDictionaryContent.put(v, id);        dictionaryByteSize += 8;    }    encodedValues.add(id);}
3e809661c729299349085dcffce747bcd55283e108fa12d02f6ef024c7df9eaf
toDictPageAndClose
public DictionaryPage toDictPageAndClose()
{    if (lastUsedDictionarySize > 0) {                PlainValuesWriter dictionaryEncoder = new PlainValuesWriter(lastUsedDictionaryByteSize, maxDictionaryByteSize, allocator);        DoubleIterator doubleIterator = doubleDictionaryContent.keySet().iterator();                for (int i = 0; i < lastUsedDictionarySize; i++) {            dictionaryEncoder.writeDouble(doubleIterator.nextDouble());        }        return dictPage(dictionaryEncoder);    }    return null;}
e1f28ce1194b6863bdea6cb4c90dd928ace5f30fc468261e7189520cc534c61b
getDictionarySize
public int getDictionarySize()
{    return doubleDictionaryContent.size();}
b8791112bf5cdc6bdd535ba46d81559c50598e7df5826ab8a02ed686d8f1e1f1
clearDictionaryContent
protected void clearDictionaryContent()
{    doubleDictionaryContent.clear();}
827efac621d671f9e73f0d60dbdde0bc8bb7b1a1314e9ee23b11b74dd2f86e1d
fallBackDictionaryEncodedData
public void fallBackDictionaryEncodedData(ValuesWriter writer)
{        double[] reverseDictionary = new double[getDictionarySize()];    ObjectIterator<Double2IntMap.Entry> entryIterator = doubleDictionaryContent.double2IntEntrySet().iterator();    while (entryIterator.hasNext()) {        Double2IntMap.Entry entry = entryIterator.next();        reverseDictionary[entry.getIntValue()] = entry.getDoubleKey();    }        IntIterator iterator = encodedValues.iterator();    while (iterator.hasNext()) {        int id = iterator.next();        writer.writeDouble(reverseDictionary[id]);    }}
c0f4d43203aca7b2bdaaeaea2925c45142a8f4f8ce782e3195685290f3010a85
writeInteger
public void writeInteger(int v)
{    int id = intDictionaryContent.get(v);    if (id == -1) {        id = intDictionaryContent.size();        intDictionaryContent.put(v, id);        dictionaryByteSize += 4;    }    encodedValues.add(id);}
3e809661c729299349085dcffce747bcd55283e108fa12d02f6ef024c7df9eaf
toDictPageAndClose
public DictionaryPage toDictPageAndClose()
{    if (lastUsedDictionarySize > 0) {                PlainValuesWriter dictionaryEncoder = new PlainValuesWriter(lastUsedDictionaryByteSize, maxDictionaryByteSize, allocator);        it.unimi.dsi.fastutil.ints.IntIterator intIterator = intDictionaryContent.keySet().iterator();                for (int i = 0; i < lastUsedDictionarySize; i++) {            dictionaryEncoder.writeInteger(intIterator.nextInt());        }        return dictPage(dictionaryEncoder);    }    return null;}
e1f28ce1194b6863bdea6cb4c90dd928ace5f30fc468261e7189520cc534c61b
getDictionarySize
public int getDictionarySize()
{    return intDictionaryContent.size();}
b8791112bf5cdc6bdd535ba46d81559c50598e7df5826ab8a02ed686d8f1e1f1
clearDictionaryContent
protected void clearDictionaryContent()
{    intDictionaryContent.clear();}
827efac621d671f9e73f0d60dbdde0bc8bb7b1a1314e9ee23b11b74dd2f86e1d
fallBackDictionaryEncodedData
public void fallBackDictionaryEncodedData(ValuesWriter writer)
{        int[] reverseDictionary = new int[getDictionarySize()];    ObjectIterator<Int2IntMap.Entry> entryIterator = intDictionaryContent.int2IntEntrySet().iterator();    while (entryIterator.hasNext()) {        Int2IntMap.Entry entry = entryIterator.next();        reverseDictionary[entry.getIntValue()] = entry.getIntKey();    }        IntIterator iterator = encodedValues.iterator();    while (iterator.hasNext()) {        int id = iterator.next();        writer.writeInteger(reverseDictionary[id]);    }}
6e1945aeb8741d792f7fb70e14deadbc9827e8eec055d14d90f9fa5c8549a12d
writeFloat
public void writeFloat(float v)
{    int id = floatDictionaryContent.get(v);    if (id == -1) {        id = floatDictionaryContent.size();        floatDictionaryContent.put(v, id);        dictionaryByteSize += 4;    }    encodedValues.add(id);}
3e809661c729299349085dcffce747bcd55283e108fa12d02f6ef024c7df9eaf
toDictPageAndClose
public DictionaryPage toDictPageAndClose()
{    if (lastUsedDictionarySize > 0) {                PlainValuesWriter dictionaryEncoder = new PlainValuesWriter(lastUsedDictionaryByteSize, maxDictionaryByteSize, allocator);        FloatIterator floatIterator = floatDictionaryContent.keySet().iterator();                for (int i = 0; i < lastUsedDictionarySize; i++) {            dictionaryEncoder.writeFloat(floatIterator.nextFloat());        }        return dictPage(dictionaryEncoder);    }    return null;}
e1f28ce1194b6863bdea6cb4c90dd928ace5f30fc468261e7189520cc534c61b
getDictionarySize
public int getDictionarySize()
{    return floatDictionaryContent.size();}
b8791112bf5cdc6bdd535ba46d81559c50598e7df5826ab8a02ed686d8f1e1f1
clearDictionaryContent
protected void clearDictionaryContent()
{    floatDictionaryContent.clear();}
827efac621d671f9e73f0d60dbdde0bc8bb7b1a1314e9ee23b11b74dd2f86e1d
fallBackDictionaryEncodedData
public void fallBackDictionaryEncodedData(ValuesWriter writer)
{        float[] reverseDictionary = new float[getDictionarySize()];    ObjectIterator<Float2IntMap.Entry> entryIterator = floatDictionaryContent.float2IntEntrySet().iterator();    while (entryIterator.hasNext()) {        Float2IntMap.Entry entry = entryIterator.next();        reverseDictionary[entry.getIntValue()] = entry.getFloatKey();    }        IntIterator iterator = encodedValues.iterator();    while (iterator.hasNext()) {        int id = iterator.next();        writer.writeFloat(reverseDictionary[id]);    }}
0d82b2a359857279cb17e2303ad561bdf4060b15300996302bd73afb4f175499
getCurrentSlabSize
 int getCurrentSlabSize()
{    return currentSlabSize;}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return current < count;}
f7e4a65e9ca0ca8ae39533d35b53fe23abc4747f9f7ecc0cce3ca9426fd315a9
next
public int next()
{    final int result = slabs[currentRow][currentCol];    incrementPosition();    return result;}
eeae314a7cf8629c4b56cfdbe2f4d6ff5f510e3a62c276d828e3e268d305d3ed
incrementPosition
private void incrementPosition()
{    current++;    currentCol++;    if (currentCol >= slabs[currentRow].length) {        currentCol = 0;        currentRow++;    }}
0b2ad8f896d89ddd1c9d5f70394c5154e26865b48ca603f770dae93e0b998248
allocateSlab
private void allocateSlab()
{    currentSlab = new int[currentSlabSize];    currentSlabPos = 0;}
4c29730bf0234acfb054590a9de22aff92ecc9f637c3a883af97c38277f8b96f
updateCurrentSlabSize
private void updateCurrentSlabSize()
{    if (currentSlabSize < MAX_SLAB_SIZE) {        currentSlabSize *= 2;        if (currentSlabSize > MAX_SLAB_SIZE) {            currentSlabSize = MAX_SLAB_SIZE;        }    }}
f1a15e76aa0a8f928caf1c779e22860e2516289993b6f8cc7cefd1945fc02397
add
public void add(int i)
{    if (currentSlab == null) {        allocateSlab();    } else if (currentSlabPos == currentSlab.length) {        slabs.add(currentSlab);        updateCurrentSlabSize();        allocateSlab();    }    currentSlab[currentSlabPos] = i;    ++currentSlabPos;}
1f9edc4e027b7ed473778c04dd00e3091872686a09f583020c15236a08bd709f
iterator
public IntIterator iterator()
{    if (currentSlab == null) {        allocateSlab();    }    int[][] itSlabs = slabs.toArray(new int[slabs.size() + 1][]);    itSlabs[slabs.size()] = currentSlab;    return new IntIterator(itSlabs, size());}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    int size = currentSlabPos;    for (int[] slab : slabs) {        size += slab.length;    }    return size;}
b00e20c49a32493ce96ac3b89f88c9a13234490f84b0fbfdec93097eeb85ec08
decodeToBinary
public Binary decodeToBinary(int id)
{    return binaryDictionaryContent[id];}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder("PlainBinaryDictionary {\n");    for (int i = 0; i < binaryDictionaryContent.length; i++) {        sb.append(i).append(" => ").append(binaryDictionaryContent[i]).append("\n");    }    return sb.append("}").toString();}
ce85c30ff00f8c9e4bd1e0acab33508ecd8e4b6570d21aaa0794d4d8bf4562ab
getMaxId
public int getMaxId()
{    return binaryDictionaryContent.length - 1;}
b5a7b61bd38029ed0086954c8ee8bcfebb82fdea35be39bf9fd37e017d559192
decodeToLong
public long decodeToLong(int id)
{    return longDictionaryContent[id];}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder("PlainLongDictionary {\n");    for (int i = 0; i < longDictionaryContent.length; i++) {        sb.append(i).append(" => ").append(longDictionaryContent[i]).append("\n");    }    return sb.append("}").toString();}
ce85c30ff00f8c9e4bd1e0acab33508ecd8e4b6570d21aaa0794d4d8bf4562ab
getMaxId
public int getMaxId()
{    return longDictionaryContent.length - 1;}
898abecc3f64d2e322d4edddeb13ff3701ae7e4df4d59819aca79c856dde6c37
decodeToDouble
public double decodeToDouble(int id)
{    return doubleDictionaryContent[id];}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder("PlainDoubleDictionary {\n");    for (int i = 0; i < doubleDictionaryContent.length; i++) {        sb.append(i).append(" => ").append(doubleDictionaryContent[i]).append("\n");    }    return sb.append("}").toString();}
ce85c30ff00f8c9e4bd1e0acab33508ecd8e4b6570d21aaa0794d4d8bf4562ab
getMaxId
public int getMaxId()
{    return doubleDictionaryContent.length - 1;}
caae8c699f20855cb64238fe71be69fd13a6827032cb3487c492c4f3b959bc01
decodeToInt
public int decodeToInt(int id)
{    return intDictionaryContent[id];}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder("PlainIntegerDictionary {\n");    for (int i = 0; i < intDictionaryContent.length; i++) {        sb.append(i).append(" => ").append(intDictionaryContent[i]).append("\n");    }    return sb.append("}").toString();}
ce85c30ff00f8c9e4bd1e0acab33508ecd8e4b6570d21aaa0794d4d8bf4562ab
getMaxId
public int getMaxId()
{    return intDictionaryContent.length - 1;}
33a64d0d3ef4ee2cb0d0804e6f57c749fb04087526df2d648737714c60ba842e
decodeToFloat
public float decodeToFloat(int id)
{    return floatDictionaryContent[id];}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder("PlainFloatDictionary {\n");    for (int i = 0; i < floatDictionaryContent.length; i++) {        sb.append(i).append(" => ").append(floatDictionaryContent[i]).append("\n");    }    return sb.append("}").toString();}
ce85c30ff00f8c9e4bd1e0acab33508ecd8e4b6570d21aaa0794d4d8bf4562ab
getMaxId
public int getMaxId()
{    return floatDictionaryContent.length - 1;}
9ae42bcb191becbfc70a151cdb8b290f4701b73cf290fb37748f7886d219dfa3
initialize
public void initialize(ParquetProperties properties)
{    this.parquetProperties = properties;}
e3a815b13de6bcfda859d16dbe5e228b04b9e6fcb88f1c3bb47d1e69ac4c6ed6
getEncodingForDataPage
private Encoding getEncodingForDataPage()
{    return PLAIN_DICTIONARY;}
868e27dfb6c3244ffc34446d1bb2194b2a6a9221d50f00426663900fe6d2a1b4
getEncodingForDictionaryPage
private Encoding getEncodingForDictionaryPage()
{    return PLAIN_DICTIONARY;}
de4adb133e05e2c6d99a54afc0de7cd59ca4c351a3048b14fc1ae251e15a34e0
newValuesWriter
public ValuesWriter newValuesWriter(ColumnDescriptor descriptor)
{    switch(descriptor.getType()) {        case BOOLEAN:            return getBooleanValuesWriter();        case FIXED_LEN_BYTE_ARRAY:            return getFixedLenByteArrayValuesWriter(descriptor);        case BINARY:            return getBinaryValuesWriter(descriptor);        case INT32:            return getInt32ValuesWriter(descriptor);        case INT64:            return getInt64ValuesWriter(descriptor);        case INT96:            return getInt96ValuesWriter(descriptor);        case DOUBLE:            return getDoubleValuesWriter(descriptor);        case FLOAT:            return getFloatValuesWriter(descriptor);        default:            throw new IllegalArgumentException("Unknown type " + descriptor.getType());    }}
e410b80cd61fa51806f83b92f63603cd92731e2b92683b1e16c1c748c3fe8b02
getBooleanValuesWriter
private ValuesWriter getBooleanValuesWriter()
{        return new BooleanPlainValuesWriter();}
9943d97e4c4cf78b3ced734b5c08bb4cf47d0e05bf0847e41dffc92ce21b6ced
getFixedLenByteArrayValuesWriter
private ValuesWriter getFixedLenByteArrayValuesWriter(ColumnDescriptor path)
{        return new FixedLenByteArrayPlainValuesWriter(path.getTypeLength(), parquetProperties.getInitialSlabSize(), parquetProperties.getPageSizeThreshold(), parquetProperties.getAllocator());}
5fa07e303b749904274f183ad2202c974e1da6894f0b30ac36f6f56b6aaa62f6
getBinaryValuesWriter
private ValuesWriter getBinaryValuesWriter(ColumnDescriptor path)
{    ValuesWriter fallbackWriter = new PlainValuesWriter(parquetProperties.getInitialSlabSize(), parquetProperties.getPageSizeThreshold(), parquetProperties.getAllocator());    return DefaultValuesWriterFactory.dictWriterWithFallBack(path, parquetProperties, getEncodingForDictionaryPage(), getEncodingForDataPage(), fallbackWriter);}
cd7051bd68526ee60c6100524e35fcc63d5418517cebe8809a61fdbd5a3cdbff
getInt32ValuesWriter
private ValuesWriter getInt32ValuesWriter(ColumnDescriptor path)
{    ValuesWriter fallbackWriter = new PlainValuesWriter(parquetProperties.getInitialSlabSize(), parquetProperties.getPageSizeThreshold(), parquetProperties.getAllocator());    return DefaultValuesWriterFactory.dictWriterWithFallBack(path, parquetProperties, getEncodingForDictionaryPage(), getEncodingForDataPage(), fallbackWriter);}
5223901f9a96aadc5067381fb6527a0190fd8fd0d81fe5dae7b7f326424ddc0b
getInt64ValuesWriter
private ValuesWriter getInt64ValuesWriter(ColumnDescriptor path)
{    ValuesWriter fallbackWriter = new PlainValuesWriter(parquetProperties.getInitialSlabSize(), parquetProperties.getPageSizeThreshold(), parquetProperties.getAllocator());    return DefaultValuesWriterFactory.dictWriterWithFallBack(path, parquetProperties, getEncodingForDictionaryPage(), getEncodingForDataPage(), fallbackWriter);}
be50f531b8f0d8d116f24b7cc7b611d98b25aa217e748ca81c63b1baca9377af
getInt96ValuesWriter
private ValuesWriter getInt96ValuesWriter(ColumnDescriptor path)
{    ValuesWriter fallbackWriter = new FixedLenByteArrayPlainValuesWriter(12, parquetProperties.getInitialSlabSize(), parquetProperties.getPageSizeThreshold(), parquetProperties.getAllocator());    return DefaultValuesWriterFactory.dictWriterWithFallBack(path, parquetProperties, getEncodingForDictionaryPage(), getEncodingForDataPage(), fallbackWriter);}
be32eb855638c6867fd214dee7a427c39eb496b266ce3590ee0955001b1784ae
getDoubleValuesWriter
private ValuesWriter getDoubleValuesWriter(ColumnDescriptor path)
{    ValuesWriter fallbackWriter = new PlainValuesWriter(parquetProperties.getInitialSlabSize(), parquetProperties.getPageSizeThreshold(), parquetProperties.getAllocator());    return DefaultValuesWriterFactory.dictWriterWithFallBack(path, parquetProperties, getEncodingForDictionaryPage(), getEncodingForDataPage(), fallbackWriter);}
5865c38b9d9ea9ebbfd9027b1eb8f760a7866df22604e9c1b4d8a029da8a7ac0
getFloatValuesWriter
private ValuesWriter getFloatValuesWriter(ColumnDescriptor path)
{    ValuesWriter fallbackWriter = new PlainValuesWriter(parquetProperties.getInitialSlabSize(), parquetProperties.getPageSizeThreshold(), parquetProperties.getAllocator());    return DefaultValuesWriterFactory.dictWriterWithFallBack(path, parquetProperties, getEncodingForDictionaryPage(), getEncodingForDataPage(), fallbackWriter);}
9ae42bcb191becbfc70a151cdb8b290f4701b73cf290fb37748f7886d219dfa3
initialize
public void initialize(ParquetProperties properties)
{    this.parquetProperties = properties;}
e3a815b13de6bcfda859d16dbe5e228b04b9e6fcb88f1c3bb47d1e69ac4c6ed6
getEncodingForDataPage
private Encoding getEncodingForDataPage()
{    return RLE_DICTIONARY;}
868e27dfb6c3244ffc34446d1bb2194b2a6a9221d50f00426663900fe6d2a1b4
getEncodingForDictionaryPage
private Encoding getEncodingForDictionaryPage()
{    return PLAIN;}
de4adb133e05e2c6d99a54afc0de7cd59ca4c351a3048b14fc1ae251e15a34e0
newValuesWriter
public ValuesWriter newValuesWriter(ColumnDescriptor descriptor)
{    switch(descriptor.getType()) {        case BOOLEAN:            return getBooleanValuesWriter();        case FIXED_LEN_BYTE_ARRAY:            return getFixedLenByteArrayValuesWriter(descriptor);        case BINARY:            return getBinaryValuesWriter(descriptor);        case INT32:            return getInt32ValuesWriter(descriptor);        case INT64:            return getInt64ValuesWriter(descriptor);        case INT96:            return getInt96ValuesWriter(descriptor);        case DOUBLE:            return getDoubleValuesWriter(descriptor);        case FLOAT:            return getFloatValuesWriter(descriptor);        default:            throw new IllegalArgumentException("Unknown type " + descriptor.getType());    }}
e410b80cd61fa51806f83b92f63603cd92731e2b92683b1e16c1c748c3fe8b02
getBooleanValuesWriter
private ValuesWriter getBooleanValuesWriter()
{        return new RunLengthBitPackingHybridValuesWriter(1, parquetProperties.getInitialSlabSize(), parquetProperties.getPageSizeThreshold(), parquetProperties.getAllocator());}
9943d97e4c4cf78b3ced734b5c08bb4cf47d0e05bf0847e41dffc92ce21b6ced
getFixedLenByteArrayValuesWriter
private ValuesWriter getFixedLenByteArrayValuesWriter(ColumnDescriptor path)
{    ValuesWriter fallbackWriter = new DeltaByteArrayWriter(parquetProperties.getInitialSlabSize(), parquetProperties.getPageSizeThreshold(), parquetProperties.getAllocator());    return DefaultValuesWriterFactory.dictWriterWithFallBack(path, parquetProperties, getEncodingForDictionaryPage(), getEncodingForDataPage(), fallbackWriter);}
5fa07e303b749904274f183ad2202c974e1da6894f0b30ac36f6f56b6aaa62f6
getBinaryValuesWriter
private ValuesWriter getBinaryValuesWriter(ColumnDescriptor path)
{    ValuesWriter fallbackWriter = new DeltaByteArrayWriter(parquetProperties.getInitialSlabSize(), parquetProperties.getPageSizeThreshold(), parquetProperties.getAllocator());    return DefaultValuesWriterFactory.dictWriterWithFallBack(path, parquetProperties, getEncodingForDictionaryPage(), getEncodingForDataPage(), fallbackWriter);}
cd7051bd68526ee60c6100524e35fcc63d5418517cebe8809a61fdbd5a3cdbff
getInt32ValuesWriter
private ValuesWriter getInt32ValuesWriter(ColumnDescriptor path)
{    ValuesWriter fallbackWriter = new DeltaBinaryPackingValuesWriterForInteger(parquetProperties.getInitialSlabSize(), parquetProperties.getPageSizeThreshold(), parquetProperties.getAllocator());    return DefaultValuesWriterFactory.dictWriterWithFallBack(path, parquetProperties, getEncodingForDictionaryPage(), getEncodingForDataPage(), fallbackWriter);}
5223901f9a96aadc5067381fb6527a0190fd8fd0d81fe5dae7b7f326424ddc0b
getInt64ValuesWriter
private ValuesWriter getInt64ValuesWriter(ColumnDescriptor path)
{    ValuesWriter fallbackWriter = new DeltaBinaryPackingValuesWriterForLong(parquetProperties.getInitialSlabSize(), parquetProperties.getPageSizeThreshold(), parquetProperties.getAllocator());    return DefaultValuesWriterFactory.dictWriterWithFallBack(path, parquetProperties, getEncodingForDictionaryPage(), getEncodingForDataPage(), fallbackWriter);}
be50f531b8f0d8d116f24b7cc7b611d98b25aa217e748ca81c63b1baca9377af
getInt96ValuesWriter
private ValuesWriter getInt96ValuesWriter(ColumnDescriptor path)
{    ValuesWriter fallbackWriter = new FixedLenByteArrayPlainValuesWriter(12, parquetProperties.getInitialSlabSize(), parquetProperties.getPageSizeThreshold(), parquetProperties.getAllocator());    return DefaultValuesWriterFactory.dictWriterWithFallBack(path, parquetProperties, getEncodingForDictionaryPage(), getEncodingForDataPage(), fallbackWriter);}
be32eb855638c6867fd214dee7a427c39eb496b266ce3590ee0955001b1784ae
getDoubleValuesWriter
private ValuesWriter getDoubleValuesWriter(ColumnDescriptor path)
{    ValuesWriter fallbackWriter = new PlainValuesWriter(parquetProperties.getInitialSlabSize(), parquetProperties.getPageSizeThreshold(), parquetProperties.getAllocator());    return DefaultValuesWriterFactory.dictWriterWithFallBack(path, parquetProperties, getEncodingForDictionaryPage(), getEncodingForDataPage(), fallbackWriter);}
5865c38b9d9ea9ebbfd9027b1eb8f760a7866df22604e9c1b4d8a029da8a7ac0
getFloatValuesWriter
private ValuesWriter getFloatValuesWriter(ColumnDescriptor path)
{    ValuesWriter fallbackWriter = new PlainValuesWriter(parquetProperties.getInitialSlabSize(), parquetProperties.getPageSizeThreshold(), parquetProperties.getAllocator());    return DefaultValuesWriterFactory.dictWriterWithFallBack(path, parquetProperties, getEncodingForDictionaryPage(), getEncodingForDataPage(), fallbackWriter);}
9ae42bcb191becbfc70a151cdb8b290f4701b73cf290fb37748f7886d219dfa3
initialize
public void initialize(ParquetProperties properties)
{    if (properties.getWriterVersion() == WriterVersion.PARQUET_1_0) {        delegateFactory = DEFAULT_V1_WRITER_FACTORY;    } else {        delegateFactory = DEFAULT_V2_WRITER_FACTORY;    }    delegateFactory.initialize(properties);}
de4adb133e05e2c6d99a54afc0de7cd59ca4c351a3048b14fc1ae251e15a34e0
newValuesWriter
public ValuesWriter newValuesWriter(ColumnDescriptor descriptor)
{    return delegateFactory.newValuesWriter(descriptor);}
5aae2469bf5a14f3fdecf520ed63e342e5114178b99813063cb6b4b80b7c9752
dictionaryWriter
 static DictionaryValuesWriter dictionaryWriter(ColumnDescriptor path, ParquetProperties properties, Encoding dictPageEncoding, Encoding dataPageEncoding)
{    switch(path.getType()) {        case BOOLEAN:            throw new IllegalArgumentException("no dictionary encoding for BOOLEAN");        case BINARY:            return new DictionaryValuesWriter.PlainBinaryDictionaryValuesWriter(properties.getDictionaryPageSizeThreshold(), dataPageEncoding, dictPageEncoding, properties.getAllocator());        case INT32:            return new DictionaryValuesWriter.PlainIntegerDictionaryValuesWriter(properties.getDictionaryPageSizeThreshold(), dataPageEncoding, dictPageEncoding, properties.getAllocator());        case INT64:            return new DictionaryValuesWriter.PlainLongDictionaryValuesWriter(properties.getDictionaryPageSizeThreshold(), dataPageEncoding, dictPageEncoding, properties.getAllocator());        case INT96:            return new DictionaryValuesWriter.PlainFixedLenArrayDictionaryValuesWriter(properties.getDictionaryPageSizeThreshold(), 12, dataPageEncoding, dictPageEncoding, properties.getAllocator());        case DOUBLE:            return new DictionaryValuesWriter.PlainDoubleDictionaryValuesWriter(properties.getDictionaryPageSizeThreshold(), dataPageEncoding, dictPageEncoding, properties.getAllocator());        case FLOAT:            return new DictionaryValuesWriter.PlainFloatDictionaryValuesWriter(properties.getDictionaryPageSizeThreshold(), dataPageEncoding, dictPageEncoding, properties.getAllocator());        case FIXED_LEN_BYTE_ARRAY:            return new DictionaryValuesWriter.PlainFixedLenArrayDictionaryValuesWriter(properties.getDictionaryPageSizeThreshold(), path.getTypeLength(), dataPageEncoding, dictPageEncoding, properties.getAllocator());        default:            throw new IllegalArgumentException("Unknown type " + path.getType());    }}
10efc6040b1bb1949e77544e0d7522bc27fd0dc749f723142ffc96fa60e1cd8e
dictWriterWithFallBack
 static ValuesWriter dictWriterWithFallBack(ColumnDescriptor path, ParquetProperties parquetProperties, Encoding dictPageEncoding, Encoding dataPageEncoding, ValuesWriter writerToFallBackTo)
{    if (parquetProperties.isEnableDictionary()) {        return FallbackValuesWriter.of(dictionaryWriter(path, parquetProperties, dictPageEncoding, dataPageEncoding), writerToFallBackTo);    } else {        return writerToFallBackTo;    }}
41521c24ac02f2a9277ea1536e0e6c83bb1b929002fd3a17c35d22d543ea2b63
of
public static FallbackValuesWriter<I, F> of(I initialWriter, F fallBackWriter)
{    return new FallbackValuesWriter<I, F>(initialWriter, fallBackWriter);}
0c921188cddfdbdd5e940a92767fca400663f7ba7c1b4fbfdb5a2e991b21cb93
getBufferedSize
public long getBufferedSize()
{        return rawDataByteSize;}
318792bb7e7c97eb05ff79e99daac6fe67cad1bfa7ae196cf0f5d3f9cfdfd7b1
getBytes
public BytesInput getBytes()
{    if (!fellBackAlready && firstPage) {                BytesInput bytes = initialWriter.getBytes();        if (!initialWriter.isCompressionSatisfying(rawDataByteSize, bytes.size())) {            fallBack();        } else {            return bytes;        }    }    return currentWriter.getBytes();}
3d8ee53ad91e9129f673687f3d9fcb3f058bc5dc228085fdcc174f07e9247418
getEncoding
public Encoding getEncoding()
{    Encoding encoding = currentWriter.getEncoding();    if (!fellBackAlready && !initialUsedAndHadDictionary) {        initialUsedAndHadDictionary = encoding.usesDictionary();    }    return encoding;}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    rawDataByteSize = 0;    firstPage = false;    currentWriter.reset();}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    initialWriter.close();    fallBackWriter.close();}
3e809661c729299349085dcffce747bcd55283e108fa12d02f6ef024c7df9eaf
toDictPageAndClose
public DictionaryPage toDictPageAndClose()
{    if (initialUsedAndHadDictionary) {        return initialWriter.toDictPageAndClose();    } else {        return currentWriter.toDictPageAndClose();    }}
d34554e133628c3de53cb7945dabf922642e706ac094e41625de3301789e96ac
resetDictionary
public void resetDictionary()
{    if (initialUsedAndHadDictionary) {        initialWriter.resetDictionary();    } else {        currentWriter.resetDictionary();    }    currentWriter = initialWriter;    fellBackAlready = false;    initialUsedAndHadDictionary = false;    firstPage = true;}
3276143416d44249f488f85b127246b083e1e6024d88125aae60e635a8ad8ba7
getAllocatedSize
public long getAllocatedSize()
{    return currentWriter.getAllocatedSize();}
729f860abc36decbc60be91f7b83b54762252f09cb85d7c4e9f7517c5dace502
memUsageString
public String memUsageString(String prefix)
{    return String.format("%s FallbackValuesWriter{\n" + "%s\n" + "%s\n" + "%s}\n", prefix, initialWriter.memUsageString(prefix + " initial:"), fallBackWriter.memUsageString(prefix + " fallback:"), prefix);}
3c1828c18df11cf1dc4c52543329b8970292d1a8c05ef1f3807f65a4925bf619
checkFallback
private void checkFallback()
{    if (!fellBackAlready && initialWriter.shouldFallBack()) {        fallBack();    }}
7048e56fbce22d7353ec7149a06788b1905e8ec5757e513b71659134081589af
fallBack
private void fallBack()
{    fellBackAlready = true;    initialWriter.fallBackAllValuesTo(fallBackWriter);    currentWriter = fallBackWriter;}
644b5c9971438561394a816247116e501f32c7e55e2546a4568d0db0454d8779
writeByte
public void writeByte(int value)
{    rawDataByteSize += 1;    currentWriter.writeByte(value);    checkFallback();}
8f0216b0899ac492f9af6758d712efeddec16fcf44b260cf6adb8ec61358fd95
writeBytes
public void writeBytes(Binary v)
{        rawDataByteSize += v.length() + 4;    currentWriter.writeBytes(v);    checkFallback();}
c0f4d43203aca7b2bdaaeaea2925c45142a8f4f8ce782e3195685290f3010a85
writeInteger
public void writeInteger(int v)
{    rawDataByteSize += 4;    currentWriter.writeInteger(v);    checkFallback();}
d2d10759f3f6446c990ff017a3a12bb92aebe7b21235aeec4165a583a5f99843
writeLong
public void writeLong(long v)
{    rawDataByteSize += 8;    currentWriter.writeLong(v);    checkFallback();}
6e1945aeb8741d792f7fb70e14deadbc9827e8eec055d14d90f9fa5c8549a12d
writeFloat
public void writeFloat(float v)
{    rawDataByteSize += 4;    currentWriter.writeFloat(v);    checkFallback();}
2b134caba1fc10f0ee1a1e74953ca441e44259f4d1e7999b06f1b84ad6d6360d
writeDouble
public void writeDouble(double v)
{    rawDataByteSize += 8;    currentWriter.writeDouble(v);    checkFallback();}
d4b7df18ce82f584ed081b22220ce7c9d747c434184149ef37e15f72accbd8a5
readBytes
public Binary readBytes()
{    try {        int length = BytesUtils.readIntLittleEndian(in);        return Binary.fromConstantByteBuffer(in.slice(length));    } catch (IOException e) {        throw new ParquetDecodingException("could not read bytes at offset " + in.position(), e);    } catch (RuntimeException e) {        throw new ParquetDecodingException("could not read bytes at offset " + in.position(), e);    }}
895e92fa2273cdf5e5c97c44b286ea867f7a7e0a6106c85286a4176e76e78d9d
skip
public void skip()
{    try {        int length = BytesUtils.readIntLittleEndian(in);        in.skipFully(length);    } catch (IOException e) {        throw new ParquetDecodingException("could not skip bytes at offset " + in.position(), e);    } catch (RuntimeException e) {        throw new ParquetDecodingException("could not skip bytes at offset " + in.position(), e);    }}
01af9a6e21f393adbad03aaaec41ddfd2271cbe7147c3315adc23b32afbd1f1e
initFromPage
public void initFromPage(int valueCount, ByteBufferInputStream stream) throws IOException
{    LOG.debug("init from page at offset {} for length {}", stream.position(), (stream.available() - stream.position()));    this.in = stream.remainingStream();}
adcbc9287c7d7614bb6d66bbb2ec114e0e108fc5fea807c27f74d8b5f1c680ff
readBoolean
public boolean readBoolean()
{    return in.readInteger() == 0 ? false : true;}
895e92fa2273cdf5e5c97c44b286ea867f7a7e0a6106c85286a4176e76e78d9d
skip
public void skip()
{    in.readInteger();}
01af9a6e21f393adbad03aaaec41ddfd2271cbe7147c3315adc23b32afbd1f1e
initFromPage
public void initFromPage(int valueCount, ByteBufferInputStream stream) throws IOException
{    LOG.debug("init from page at offset {} for length {}", stream.position(), stream.available());    this.in.initFromPage(valueCount, stream);}
01f19e0d468c105f2e486aadc403162f24986616e435fe0d756a2c6e5dc4ffd4
getNextOffset
public int getNextOffset()
{    return in.getNextOffset();}
8c095b1c331a0ce67fa641f2d3c8bdbc6db4ba2eddca457e9b9bd8a6dcbe802a
writeBoolean
public final void writeBoolean(boolean v)
{    bitPackingWriter.writeInteger(v ? 1 : 0);}
0c921188cddfdbdd5e940a92767fca400663f7ba7c1b4fbfdb5a2e991b21cb93
getBufferedSize
public long getBufferedSize()
{    return bitPackingWriter.getBufferedSize();}
318792bb7e7c97eb05ff79e99daac6fe67cad1bfa7ae196cf0f5d3f9cfdfd7b1
getBytes
public BytesInput getBytes()
{    return bitPackingWriter.getBytes();}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    bitPackingWriter.reset();}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    bitPackingWriter.close();}
3276143416d44249f488f85b127246b083e1e6024d88125aae60e635a8ad8ba7
getAllocatedSize
public long getAllocatedSize()
{    return bitPackingWriter.getAllocatedSize();}
3d8ee53ad91e9129f673687f3d9fcb3f058bc5dc228085fdcc174f07e9247418
getEncoding
public Encoding getEncoding()
{    return PLAIN;}
729f860abc36decbc60be91f7b83b54762252f09cb85d7c4e9f7517c5dace502
memUsageString
public String memUsageString(String prefix)
{    return bitPackingWriter.memUsageString(prefix);}
d4b7df18ce82f584ed081b22220ce7c9d747c434184149ef37e15f72accbd8a5
readBytes
public Binary readBytes()
{    try {        return Binary.fromConstantByteBuffer(in.slice(length));    } catch (IOException | RuntimeException e) {        throw new ParquetDecodingException("could not read bytes at offset " + in.position(), e);    }}
895e92fa2273cdf5e5c97c44b286ea867f7a7e0a6106c85286a4176e76e78d9d
skip
public void skip()
{    skip(1);}
83659b3f3c32cda5d1e381b9ad4b7db55d1ee8ecce3504ad3c9ad45a376b6f2e
skip
public void skip(int n)
{    try {        in.skipFully(n * length);    } catch (IOException | RuntimeException e) {        throw new ParquetDecodingException("could not skip bytes at offset " + in.position(), e);    }}
01af9a6e21f393adbad03aaaec41ddfd2271cbe7147c3315adc23b32afbd1f1e
initFromPage
public void initFromPage(int valueCount, ByteBufferInputStream stream) throws IOException
{    LOG.debug("init from page at offset {} for length {}", stream.position(), stream.available());    this.in = stream.remainingStream();}
39844f25e96283c67fb5ea65f105178fed9c74d2ad2288fa654b4a6d7cd6755c
writeBytes
public final void writeBytes(Binary v)
{    if (v.length() != length) {        throw new IllegalArgumentException("Fixed Binary size " + v.length() + " does not match field type length " + length);    }    try {        v.writeTo(out);    } catch (IOException e) {        throw new ParquetEncodingException("could not write fixed bytes", e);    }}
0c921188cddfdbdd5e940a92767fca400663f7ba7c1b4fbfdb5a2e991b21cb93
getBufferedSize
public long getBufferedSize()
{    return arrayOut.size();}
318792bb7e7c97eb05ff79e99daac6fe67cad1bfa7ae196cf0f5d3f9cfdfd7b1
getBytes
public BytesInput getBytes()
{    try {        out.flush();    } catch (IOException e) {        throw new ParquetEncodingException("could not write page", e);    }    LOG.debug("writing a buffer of size {}", arrayOut.size());    return BytesInput.from(arrayOut);}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    arrayOut.reset();}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    arrayOut.close();}
3276143416d44249f488f85b127246b083e1e6024d88125aae60e635a8ad8ba7
getAllocatedSize
public long getAllocatedSize()
{    return arrayOut.getCapacity();}
3d8ee53ad91e9129f673687f3d9fcb3f058bc5dc228085fdcc174f07e9247418
getEncoding
public Encoding getEncoding()
{    return Encoding.PLAIN;}
729f860abc36decbc60be91f7b83b54762252f09cb85d7c4e9f7517c5dace502
memUsageString
public String memUsageString(String prefix)
{    return arrayOut.memUsageString(prefix + " PLAIN");}
01af9a6e21f393adbad03aaaec41ddfd2271cbe7147c3315adc23b32afbd1f1e
initFromPage
public void initFromPage(int valueCount, ByteBufferInputStream stream) throws IOException
{    LOG.debug("init from page at offset {} for length {}", stream.position(), stream.available());    this.in = new LittleEndianDataInputStream(stream.remainingStream());}
895e92fa2273cdf5e5c97c44b286ea867f7a7e0a6106c85286a4176e76e78d9d
skip
public void skip()
{    skip(1);}
436aeaeca08106afab3980a1a830a5717bc086ad1710a5e75661a91eb3f9723a
skipBytesFully
 void skipBytesFully(int n) throws IOException
{    int skipped = 0;    while (skipped < n) {        skipped += in.skipBytes(n - skipped);    }}
83659b3f3c32cda5d1e381b9ad4b7db55d1ee8ecce3504ad3c9ad45a376b6f2e
skip
public void skip(int n)
{    try {        skipBytesFully(n * 8);    } catch (IOException e) {        throw new ParquetDecodingException("could not skip " + n + " double values", e);    }}
c9fd13d4898df6fa5844155b1eb3aff624d9da4a466717e380b0eb68932ca73a
readDouble
public double readDouble()
{    try {        return in.readDouble();    } catch (IOException e) {        throw new ParquetDecodingException("could not read double", e);    }}
83659b3f3c32cda5d1e381b9ad4b7db55d1ee8ecce3504ad3c9ad45a376b6f2e
skip
public void skip(int n)
{    try {        skipBytesFully(n * 4);    } catch (IOException e) {        throw new ParquetDecodingException("could not skip " + n + " floats", e);    }}
259231fd3c9d3226ead8aa14f18984f79d990802bee7f1567c1637dfbbcc072a
readFloat
public float readFloat()
{    try {        return in.readFloat();    } catch (IOException e) {        throw new ParquetDecodingException("could not read float", e);    }}
83659b3f3c32cda5d1e381b9ad4b7db55d1ee8ecce3504ad3c9ad45a376b6f2e
skip
public void skip(int n)
{    try {        in.skipBytes(n * 4);    } catch (IOException e) {        throw new ParquetDecodingException("could not skip " + n + " ints", e);    }}
d8df9ef1bfee0aee5f248ce3a8a8027f0467f8a4d006cb1b13c566de23142ce5
readInteger
public int readInteger()
{    try {        return in.readInt();    } catch (IOException e) {        throw new ParquetDecodingException("could not read int", e);    }}
83659b3f3c32cda5d1e381b9ad4b7db55d1ee8ecce3504ad3c9ad45a376b6f2e
skip
public void skip(int n)
{    try {        in.skipBytes(n * 8);    } catch (IOException e) {        throw new ParquetDecodingException("could not skip " + n + " longs", e);    }}
730921a7d0ef2efc7176d3cd9075bfb0f498473ea4299801ce714e8bf53bc895
readLong
public long readLong()
{    try {        return in.readLong();    } catch (IOException e) {        throw new ParquetDecodingException("could not read long", e);    }}
39844f25e96283c67fb5ea65f105178fed9c74d2ad2288fa654b4a6d7cd6755c
writeBytes
public final void writeBytes(Binary v)
{    try {        out.writeInt(v.length());        v.writeTo(out);    } catch (IOException e) {        throw new ParquetEncodingException("could not write bytes", e);    }}
bca33993b6d7b2ed4700c827fa34c02c8eafc80ce95265ac03a808c13c63182c
writeInteger
public final void writeInteger(int v)
{    try {        out.writeInt(v);    } catch (IOException e) {        throw new ParquetEncodingException("could not write int", e);    }}
32534853de27ac4b70759253417725b8b4e1b4e2502561de8f98d8945e742443
writeLong
public final void writeLong(long v)
{    try {        out.writeLong(v);    } catch (IOException e) {        throw new ParquetEncodingException("could not write long", e);    }}
ffcd7a86f41b3525ebb763c61734697f559766a4cd20882d96b387627fc9e5ed
writeFloat
public final void writeFloat(float v)
{    try {        out.writeFloat(v);    } catch (IOException e) {        throw new ParquetEncodingException("could not write float", e);    }}
3343c61c32fdbc80bcb65b602a7d7701efbcaac40f101cd2d3a1a8012a5c0e87
writeDouble
public final void writeDouble(double v)
{    try {        out.writeDouble(v);    } catch (IOException e) {        throw new ParquetEncodingException("could not write double", e);    }}
644b5c9971438561394a816247116e501f32c7e55e2546a4568d0db0454d8779
writeByte
public void writeByte(int value)
{    try {        out.write(value);    } catch (IOException e) {        throw new ParquetEncodingException("could not write byte", e);    }}
0c921188cddfdbdd5e940a92767fca400663f7ba7c1b4fbfdb5a2e991b21cb93
getBufferedSize
public long getBufferedSize()
{    return arrayOut.size();}
318792bb7e7c97eb05ff79e99daac6fe67cad1bfa7ae196cf0f5d3f9cfdfd7b1
getBytes
public BytesInput getBytes()
{    try {        out.flush();    } catch (IOException e) {        throw new ParquetEncodingException("could not write page", e);    }    if (LOG.isDebugEnabled())        LOG.debug("writing a buffer of size {}", arrayOut.size());    return BytesInput.from(arrayOut);}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    arrayOut.reset();}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    arrayOut.close();    out.close();}
3276143416d44249f488f85b127246b083e1e6024d88125aae60e635a8ad8ba7
getAllocatedSize
public long getAllocatedSize()
{    return arrayOut.getCapacity();}
3d8ee53ad91e9129f673687f3d9fcb3f058bc5dc228085fdcc174f07e9247418
getEncoding
public Encoding getEncoding()
{    return Encoding.PLAIN;}
729f860abc36decbc60be91f7b83b54762252f09cb85d7c4e9f7517c5dace502
memUsageString
public String memUsageString(String prefix)
{    return arrayOut.memUsageString(prefix + " PLAIN");}
f236e7fb1e87c9b6c5be0f35fb6c4eb85b118d1b426358e70800a74f43350299
readInt
public int readInt() throws IOException
{    if (currentCount == 0) {        readNext();    }    --currentCount;    int result;    switch(mode) {        case RLE:            result = currentValue;            break;        case PACKED:            result = currentBuffer[currentBuffer.length - 1 - currentCount];            break;        default:            throw new ParquetDecodingException("not a valid mode " + mode);    }    return result;}
4cc56ad9b78699f646c314f9f747410c79714a418a1b4e7a9a1d96053289960f
readNext
private void readNext() throws IOException
{    Preconditions.checkArgument(in.available() > 0, "Reading past RLE/BitPacking stream.");    final int header = BytesUtils.readUnsignedVarInt(in);    mode = (header & 1) == 0 ? MODE.RLE : MODE.PACKED;    switch(mode) {        case RLE:            currentCount = header >>> 1;            LOG.debug("reading {} values RLE", currentCount);            currentValue = BytesUtils.readIntLittleEndianPaddedOnBitWidth(in, bitWidth);            break;        case PACKED:            int numGroups = header >>> 1;            currentCount = numGroups * 8;            LOG.debug("reading {} values BIT PACKED", currentCount);                        currentBuffer = new int[currentCount];            byte[] bytes = new byte[numGroups * bitWidth];                        int bytesToRead = (int) Math.ceil(currentCount * bitWidth / 8.0);            bytesToRead = Math.min(bytesToRead, in.available());            new DataInputStream(in).readFully(bytes, 0, bytesToRead);            for (int valueIndex = 0, byteIndex = 0; valueIndex < currentCount; valueIndex += 8, byteIndex += bitWidth) {                packer.unpack8Values(bytes, byteIndex, currentBuffer, valueIndex);            }            break;        default:            throw new ParquetDecodingException("not a valid mode " + mode);    }}
12ae9b5de3dbfac859dfecec92b1c7950f3b5cdb27471b07642b5aa2a909bba1
reset
private void reset(boolean resetBaos)
{    if (resetBaos) {        this.baos.reset();    }    this.previousValue = 0;    this.numBufferedValues = 0;    this.repeatCount = 0;    this.bitPackedGroupCount = 0;    this.bitPackedRunHeaderPointer = -1;    this.toBytesCalled = false;}
becc5c024a78e36f62372c94a18ad86d7a668c73c902541926c9abb38e6db3c3
writeInt
public void writeInt(int value) throws IOException
{    if (value == previousValue) {                        ++repeatCount;        if (repeatCount >= 8) {                        return;        }    } else {                if (repeatCount >= 8) {                        writeRleRun();        }                repeatCount = 1;                previousValue = value;    }            bufferedValues[numBufferedValues] = value;    ++numBufferedValues;    if (numBufferedValues == 8) {                                writeOrAppendBitPackedRun();    }}
39768edb563765a285abe8ec5fde4a8d455ec4d9bfdfd44f2aa7aa5dbc4a98cc
writeOrAppendBitPackedRun
private void writeOrAppendBitPackedRun() throws IOException
{    if (bitPackedGroupCount >= 63) {                        endPreviousBitPackedRun();    }    if (bitPackedRunHeaderPointer == -1) {                                baos.write(0);        bitPackedRunHeaderPointer = baos.getCurrentIndex();    }    packer.pack8Values(bufferedValues, 0, packBuffer, 0);    baos.write(packBuffer);        numBufferedValues = 0;            repeatCount = 0;    ++bitPackedGroupCount;}
7a8100c0c999c745c09ba9c9713b03d41bcf8f542cc529108629afbe9808359d
endPreviousBitPackedRun
private void endPreviousBitPackedRun()
{    if (bitPackedRunHeaderPointer == -1) {                return;    }        byte bitPackHeader = (byte) ((bitPackedGroupCount << 1) | 1);        baos.setByte(bitPackedRunHeaderPointer, bitPackHeader);        bitPackedRunHeaderPointer = -1;        bitPackedGroupCount = 0;}
ecf0c694cc986180e2ad87b75ef3b84ec38dd247f34e9d752779033e24542edd
writeRleRun
private void writeRleRun() throws IOException
{                endPreviousBitPackedRun();        BytesUtils.writeUnsignedVarInt(repeatCount << 1, baos);        BytesUtils.writeIntLittleEndianPaddedOnBitWidth(baos, previousValue, bitWidth);        repeatCount = 0;        numBufferedValues = 0;}
d5a4162523f7bbffbea0fd20903b6ebeb901ae80867c3cab4cb908f402532c63
toBytes
public BytesInput toBytes() throws IOException
{    Preconditions.checkArgument(!toBytesCalled, "You cannot call toBytes() more than once without calling reset()");        if (repeatCount >= 8) {        writeRleRun();    } else if (numBufferedValues > 0) {        for (int i = numBufferedValues; i < 8; i++) {            bufferedValues[i] = 0;        }        writeOrAppendBitPackedRun();        endPreviousBitPackedRun();    } else {        endPreviousBitPackedRun();    }    toBytesCalled = true;    return BytesInput.from(baos);}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    reset(true);}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    reset(false);    baos.close();}
0c921188cddfdbdd5e940a92767fca400663f7ba7c1b4fbfdb5a2e991b21cb93
getBufferedSize
public long getBufferedSize()
{    return baos.size();}
3276143416d44249f488f85b127246b083e1e6024d88125aae60e635a8ad8ba7
getAllocatedSize
public long getAllocatedSize()
{    return baos.getCapacity();}
8659e0479d5d56d0169e0e8f75920661be76ffbd6c907c93d0298eb14bacf3f3
initFromPage
public void initFromPage(int valueCountL, ByteBufferInputStream stream) throws IOException
{    int length = BytesUtils.readIntLittleEndian(stream);    this.decoder = new RunLengthBitPackingHybridDecoder(bitWidth, stream.sliceStream(length));        updateNextOffset(length + 4);}
d8df9ef1bfee0aee5f248ce3a8a8027f0467f8a4d006cb1b13c566de23142ce5
readInteger
public int readInteger()
{    try {        return decoder.readInt();    } catch (IOException e) {        throw new ParquetDecodingException(e);    }}
adcbc9287c7d7614bb6d66bbb2ec114e0e108fc5fea807c27f74d8b5f1c680ff
readBoolean
public boolean readBoolean()
{    return readInteger() == 0 ? false : true;}
895e92fa2273cdf5e5c97c44b286ea867f7a7e0a6106c85286a4176e76e78d9d
skip
public void skip()
{    readInteger();}
c0f4d43203aca7b2bdaaeaea2925c45142a8f4f8ce782e3195685290f3010a85
writeInteger
public void writeInteger(int v)
{    try {        encoder.writeInt(v);    } catch (IOException e) {        throw new ParquetEncodingException(e);    }}
03850df0dc4909e107d68f02fa0e21869ab47db161066b909cedd886600a3783
writeBoolean
public void writeBoolean(boolean v)
{    writeInteger(v ? 1 : 0);}
0c921188cddfdbdd5e940a92767fca400663f7ba7c1b4fbfdb5a2e991b21cb93
getBufferedSize
public long getBufferedSize()
{    return encoder.getBufferedSize();}
3276143416d44249f488f85b127246b083e1e6024d88125aae60e635a8ad8ba7
getAllocatedSize
public long getAllocatedSize()
{    return encoder.getAllocatedSize();}
318792bb7e7c97eb05ff79e99daac6fe67cad1bfa7ae196cf0f5d3f9cfdfd7b1
getBytes
public BytesInput getBytes()
{    try {                BytesInput rle = encoder.toBytes();        return BytesInput.concat(BytesInput.fromInt(Math.toIntExact(rle.size())), rle);    } catch (IOException e) {        throw new ParquetEncodingException(e);    }}
3d8ee53ad91e9129f673687f3d9fcb3f058bc5dc228085fdcc174f07e9247418
getEncoding
public Encoding getEncoding()
{    return Encoding.RLE;}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    encoder.reset();}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    encoder.close();}
729f860abc36decbc60be91f7b83b54762252f09cb85d7c4e9f7517c5dace502
memUsageString
public String memUsageString(String prefix)
{    return String.format("%s RunLengthBitPackingHybrid %d bytes", prefix, getAllocatedSize());}
d8df9ef1bfee0aee5f248ce3a8a8027f0467f8a4d006cb1b13c566de23142ce5
readInteger
public int readInteger()
{    return 0;}
01af9a6e21f393adbad03aaaec41ddfd2271cbe7147c3315adc23b32afbd1f1e
initFromPage
public void initFromPage(int valueCount, ByteBufferInputStream stream) throws IOException
{    updateNextOffset(0);}
895e92fa2273cdf5e5c97c44b286ea867f7a7e0a6106c85286a4176e76e78d9d
skip
public void skip()
{}
83659b3f3c32cda5d1e381b9ad4b7db55d1ee8ecce3504ad3c9ad45a376b6f2e
skip
public void skip(int n)
{}
a43f6be0a01938ffb60095238f70c76e65b93f404fae492ff841e341ac9b8c3e
initFromPage
public void initFromPage(int valueCount, ByteBuffer page, int offset) throws IOException
{    if (offset < 0) {        throw new IllegalArgumentException("Illegal offset: " + offset);    }    actualOffset = offset;    ByteBuffer pageWithOffset = page.duplicate();    pageWithOffset.position(offset);    initFromPage(valueCount, ByteBufferInputStream.wrap(pageWithOffset));    actualOffset = -1;}
9a14601a4843aa78b5bc0f1cead08d11e6cdd0bbea1f7bfea2d2343072152319
initFromPage
public void initFromPage(int valueCount, byte[] page, int offset) throws IOException
{    this.initFromPage(valueCount, ByteBuffer.wrap(page), offset);}
2b6156253e204e0ba2979426840b1616fbe0cc8fa7774a630596196dd35cc237
initFromPage
public void initFromPage(int valueCount, ByteBufferInputStream in) throws IOException
{    if (actualOffset != -1) {        throw new UnsupportedOperationException("Either initFromPage(int, ByteBuffer, int) or initFromPage(int, ByteBufferInputStream) must be implemented in " + getClass().getName());    }    initFromPage(valueCount, in.slice(valueCount), 0);}
01f19e0d468c105f2e486aadc403162f24986616e435fe0d756a2c6e5dc4ffd4
getNextOffset
public int getNextOffset()
{    if (nextOffset == -1) {        throw new ParquetDecodingException("Unsupported: cannot get offset of the next section.");    } else {        return nextOffset;    }}
beb6c214e613a2451c4546ede394d34950ba3c25bfed1845e8f25b2b020f7c76
updateNextOffset
protected void updateNextOffset(int bytesRead)
{    nextOffset = actualOffset == -1 ? -1 : actualOffset + bytesRead;}
43e2732541efcf41e0296bfe8823bc201ca2305ae0426fa9cd8524eff48b292d
readValueDictionaryId
public int readValueDictionaryId()
{    throw new UnsupportedOperationException();}
adcbc9287c7d7614bb6d66bbb2ec114e0e108fc5fea807c27f74d8b5f1c680ff
readBoolean
public boolean readBoolean()
{    throw new UnsupportedOperationException();}
d4b7df18ce82f584ed081b22220ce7c9d747c434184149ef37e15f72accbd8a5
readBytes
public Binary readBytes()
{    throw new UnsupportedOperationException();}
259231fd3c9d3226ead8aa14f18984f79d990802bee7f1567c1637dfbbcc072a
readFloat
public float readFloat()
{    throw new UnsupportedOperationException();}
c9fd13d4898df6fa5844155b1eb3aff624d9da4a466717e380b0eb68932ca73a
readDouble
public double readDouble()
{    throw new UnsupportedOperationException();}
d8df9ef1bfee0aee5f248ce3a8a8027f0467f8a4d006cb1b13c566de23142ce5
readInteger
public int readInteger()
{    throw new UnsupportedOperationException();}
730921a7d0ef2efc7176d3cd9075bfb0f498473ea4299801ce714e8bf53bc895
readLong
public long readLong()
{    throw new UnsupportedOperationException();}
83659b3f3c32cda5d1e381b9ad4b7db55d1ee8ecce3504ad3c9ad45a376b6f2e
skip
public void skip(int n)
{    for (int i = 0; i < n; ++i) {        skip();    }}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{}
3e809661c729299349085dcffce747bcd55283e108fa12d02f6ef024c7df9eaf
toDictPageAndClose
public DictionaryPage toDictPageAndClose()
{    return null;}
d34554e133628c3de53cb7945dabf922642e706ac094e41625de3301789e96ac
resetDictionary
public void resetDictionary()
{}
644b5c9971438561394a816247116e501f32c7e55e2546a4568d0db0454d8779
writeByte
public void writeByte(int value)
{    throw new UnsupportedOperationException(getClass().getName());}
03850df0dc4909e107d68f02fa0e21869ab47db161066b909cedd886600a3783
writeBoolean
public void writeBoolean(boolean v)
{    throw new UnsupportedOperationException(getClass().getName());}
8f0216b0899ac492f9af6758d712efeddec16fcf44b260cf6adb8ec61358fd95
writeBytes
public void writeBytes(Binary v)
{    throw new UnsupportedOperationException(getClass().getName());}
c0f4d43203aca7b2bdaaeaea2925c45142a8f4f8ce782e3195685290f3010a85
writeInteger
public void writeInteger(int v)
{    throw new UnsupportedOperationException(getClass().getName());}
d2d10759f3f6446c990ff017a3a12bb92aebe7b21235aeec4165a583a5f99843
writeLong
public void writeLong(long v)
{    throw new UnsupportedOperationException(getClass().getName());}
2b134caba1fc10f0ee1a1e74953ca441e44259f4d1e7999b06f1b84ad6d6360d
writeDouble
public void writeDouble(double v)
{    throw new UnsupportedOperationException(getClass().getName());}
6e1945aeb8741d792f7fb70e14deadbc9827e8eec055d14d90f9fa5c8549a12d
writeFloat
public void writeFloat(float v)
{    throw new UnsupportedOperationException(getClass().getName());}
e72e877e91d5452d0b15e2cef39715ef19c832fee9d8dc737300e571d7170a7f
requiresSequentialReads
public static boolean requiresSequentialReads(ParsedVersion version, Encoding encoding)
{    if (encoding != Encoding.DELTA_BYTE_ARRAY) {        return false;    }    if (version == null) {        return true;    }    if (!"parquet-mr".equals(version.application)) {                return false;    }    if (!version.hasSemanticVersion()) {        LOG.warn("Requiring sequential reads because created_by did not " + "contain a valid version (see PARQUET-246): {}", version.version);        return true;    }    return requiresSequentialReads(version.getSemanticVersion(), encoding);}
af5d35bbb970c618727d93f139af0a9b362e3ae5465ad4cfd0ec4a55084c2049
requiresSequentialReads
public static boolean requiresSequentialReads(SemanticVersion semver, Encoding encoding)
{    if (encoding != Encoding.DELTA_BYTE_ARRAY) {        return false;    }    if (semver == null) {        return true;    }    if (semver.compareTo(PARQUET_246_FIXED_VERSION) < 0) {        LOG.info("Requiring sequential reads because this file was created " + "prior to {}. See PARQUET-246", PARQUET_246_FIXED_VERSION);        return true;    }        return false;}
00e061dade6364fa1a949f084c96e8abcdff87773e32f4c098d3eab5b7a80a2c
requiresSequentialReads
public static boolean requiresSequentialReads(String createdBy, Encoding encoding)
{    if (encoding != Encoding.DELTA_BYTE_ARRAY) {        return false;    }    if (Strings.isNullOrEmpty(createdBy)) {        LOG.info("Requiring sequential reads because file version is empty. See PARQUET-246");        return true;    }    try {        return requiresSequentialReads(VersionParser.parse(createdBy), encoding);    } catch (RuntimeException e) {        warnParseError(createdBy, e);        return true;    } catch (VersionParser.VersionParseException e) {        warnParseError(createdBy, e);        return true;    }}
03a3f07c2d5819b88eec3f9cb26785964ca69002cda751734552c58fd4277674
warnParseError
private static void warnParseError(String createdBy, Throwable e)
{    LOG.warn("Requiring sequential reads because created_by could not be " + "parsed (see PARQUET-246): " + createdBy, e);}
7a0b0e8dbd8aeea6d0c076b4c01df1fe81db60699c8d0281e5eab0c9a59c691d
shouldIgnoreStatistics
public static boolean shouldIgnoreStatistics(String createdBy, PrimitiveTypeName columnType)
{    if (columnType != PrimitiveTypeName.BINARY && columnType != PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY) {                return false;    }    if (Strings.isNullOrEmpty(createdBy)) {                        warnOnce("Ignoring statistics because created_by is null or empty! See PARQUET-251 and PARQUET-297");        return true;    }    try {        ParsedVersion version = VersionParser.parse(createdBy);        if (!"parquet-mr".equals(version.application)) {                        return false;        }        if (Strings.isNullOrEmpty(version.version)) {            warnOnce("Ignoring statistics because created_by did not contain a semver (see PARQUET-251): " + createdBy);            return true;        }        SemanticVersion semver = SemanticVersion.parse(version.version);        if (semver.compareTo(PARQUET_251_FIXED_VERSION) < 0 && !(semver.compareTo(CDH_5_PARQUET_251_FIXED_START) >= 0 && semver.compareTo(CDH_5_PARQUET_251_FIXED_END) < 0)) {            warnOnce("Ignoring statistics because this file was created prior to " + PARQUET_251_FIXED_VERSION + ", see PARQUET-251");            return true;        }                return false;    } catch (RuntimeException e) {                        warnParseErrorOnce(createdBy, e);        return true;    } catch (SemanticVersionParseException e) {                        warnParseErrorOnce(createdBy, e);        return true;    } catch (VersionParseException e) {                        warnParseErrorOnce(createdBy, e);        return true;    }}
9d31f2e3203de93b802d2327243726fb0b18e3ead9ca1a91b87f63808be2234d
warnParseErrorOnce
private static void warnParseErrorOnce(String createdBy, Throwable e)
{    if (!alreadyLogged.getAndSet(true)) {        LOG.warn("Ignoring statistics because created_by could not be parsed (see PARQUET-251): " + createdBy, e);    }}
4999171de4d68d6a28c47daf0bb581beeae1d6a4777aaf89001a47411b4385e7
warnOnce
private static void warnOnce(String message)
{    if (!alreadyLogged.getAndSet(true)) {        LOG.warn(message);    }}
d3634bb737c04c96c82e04f2023ea99717564e51421fa6b3df8ff0c20cbe7a9a
add
public void add(String field, int value)
{    add(getType().getFieldIndex(field), value);}
d84d3d4af4ecd1be78b4ab80438c754756b9bcc2768eada71777e44a35055eef
add
public void add(String field, long value)
{    add(getType().getFieldIndex(field), value);}
6149ee2c8220cdf51aa0a8d4ed0feaef7b25b08fe59fa2a733a24a981b9a6e0a
add
public void add(String field, float value)
{    add(getType().getFieldIndex(field), value);}
4d6cc5b155909ba54797e975f290959fc76bc4f66d30efb2e763bae0b56df341
add
public void add(String field, double value)
{    add(getType().getFieldIndex(field), value);}
175939a37884c5d2ed98a7c3c8bf31631fa1034ce0e37fdcb28f4ea7540a98e0
add
public void add(String field, String value)
{    add(getType().getFieldIndex(field), value);}
84f8726f4425d49a61dd1dd3e36320482b9e1299fe22a24aa2008ec20e5629d7
add
public void add(String field, NanoTime value)
{    add(getType().getFieldIndex(field), value);}
534c89b3c63f6703d82744e2c71833303108db9d1e8624309fdfdcd9ff527883
add
public void add(String field, boolean value)
{    add(getType().getFieldIndex(field), value);}
345509f9a654e1e939371d5f4e920c7ccfd9ab121274876fca69e07a455a0ccb
add
public void add(String field, Binary value)
{    add(getType().getFieldIndex(field), value);}
1d778ec31ae135fea9aea04df504151890c55728d572d1ff8e024225d02a8aa4
add
public void add(String field, Group value)
{    add(getType().getFieldIndex(field), value);}
2032749c7abfde6245b5b79bfe115cdd8e1b1b5711230c4b3da2935a22eac2e8
addGroup
public Group addGroup(String field)
{    if (LOG.isDebugEnabled()) {        LOG.debug("add group {} to {}", field, getType().getName());    }    return addGroup(getType().getFieldIndex(field));}
d8fadefa2645414426eea4f9707d8ee12c9d0874a4c7c00920de2a6f15da6dec
getGroup
public Group getGroup(String field, int index)
{    return getGroup(getType().getFieldIndex(field), index);}
b456561daceae09cba477661533f7ba20c962f26e655f931b010431eb3919020
asGroup
public Group asGroup()
{    return this;}
17aa1140013221ad00b98aa76c1419673a8941fbc245a8f0dda239de69dd51b4
append
public Group append(String fieldName, int value)
{    add(fieldName, value);    return this;}
9b5fdcaecb49bb2d467dba3f7bab362b062be32c045bd8bfbcac91737560bb66
append
public Group append(String fieldName, float value)
{    add(fieldName, value);    return this;}
d14364e383070578910bde7929ee36a08200dde1f0263a9b77b0547d983883ad
append
public Group append(String fieldName, double value)
{    add(fieldName, value);    return this;}
2c610e6b57b9161ab0c379a6674eeca748ff94428b912b0ab3fe10612b300052
append
public Group append(String fieldName, long value)
{    add(fieldName, value);    return this;}
73d60950aeff9b27a111ead0c92d25fa0240c6522f95c1c9bf394cb162641f3a
append
public Group append(String fieldName, NanoTime value)
{    add(fieldName, value);    return this;}
1b00d84188820c1ab6cf373035130df4427078c72b27fa6e435c3917790e963e
append
public Group append(String fieldName, String value)
{    add(fieldName, Binary.fromString(value));    return this;}
4cc4763925e7da661c7c24a12e54daf50d767f002c2d42e7f63dd19f5ef12ea8
append
public Group append(String fieldName, boolean value)
{    add(fieldName, value);    return this;}
a7de5b82dc3385b2a6f69c5becd368a12d88e08165a7ad18284523981e29f5af
append
public Group append(String fieldName, Binary value)
{    add(fieldName, value);    return this;}
5f6a849ee4271102cc6375cd6f2b3f0ddd43f489fb9ffc060486b9cbd1db08ff
getFieldRepetitionCount
public int getFieldRepetitionCount(String field)
{    return getFieldRepetitionCount(getType().getFieldIndex(field));}
1c7504efa26c2add8e9c43bc4351b1bfae9644c65d09d82e800ed79859bbbafe
getGroup
public GroupValueSource getGroup(String field, int index)
{    return getGroup(getType().getFieldIndex(field), index);}
56be8e31006c69c8f8704e406de4fe54d21d7a7192fd349a42e56115178d320b
getString
public String getString(String field, int index)
{    return getString(getType().getFieldIndex(field), index);}
675040a3f0badb2eb278b5edfd87845cc3d539a014dc5f6369bc5947819fcbba
getInteger
public int getInteger(String field, int index)
{    return getInteger(getType().getFieldIndex(field), index);}
c8e889a33f5dbeb3d775bbdc07d8f19601105c8e4c09a89cdcabf728f2f7f032
getLong
public long getLong(String field, int index)
{    return getLong(getType().getFieldIndex(field), index);}
0f69910cba463e330c5a7a3734fa006d0ab4c81d7a30f1bcbf7e4a2fd18f8889
getDouble
public double getDouble(String field, int index)
{    return getDouble(getType().getFieldIndex(field), index);}
47816b994e7d9237385d6de98a8c2c41c4ec3cd98bfdb39667968a41a0290aa7
getFloat
public float getFloat(String field, int index)
{    return getFloat(getType().getFieldIndex(field), index);}
b899d052fde44dbedfe1a924782157450442c9350770b447bd62e95dad380fbb
getBoolean
public boolean getBoolean(String field, int index)
{    return getBoolean(getType().getFieldIndex(field), index);}
dc3fbbf8ceae93e01f2237b8f4415c7a0c3870ccac6d8cf9b915692bee884367
getBinary
public Binary getBinary(String field, int index)
{    return getBinary(getType().getFieldIndex(field), index);}
9f27efa2fd326b1bc9cd5def14d048802287c6d2c7c0fb0b36b36fee05951f78
getInt96
public Binary getInt96(String field, int index)
{    return getInt96(getType().getFieldIndex(field), index);}
c8956f85aad42eaa62f1ed792eb699cdd3ce238b9d44983b792a79bf06bd5e00
write
public void write(Group group)
{    recordConsumer.startMessage();    writeGroup(group, schema);    recordConsumer.endMessage();}
f4fa7350ddb70d2096a7f8c836e31805ceafdaa286f94321d1efaaaa94024cb7
writeGroup
private void writeGroup(Group group, GroupType type)
{    int fieldCount = type.getFieldCount();    for (int field = 0; field < fieldCount; ++field) {        int valueCount = group.getFieldRepetitionCount(field);        if (valueCount > 0) {            Type fieldType = type.getType(field);            String fieldName = fieldType.getName();            recordConsumer.startField(fieldName, field);            for (int index = 0; index < valueCount; ++index) {                if (fieldType.isPrimitive()) {                    group.writeValue(field, index, recordConsumer);                } else {                    recordConsumer.startGroup();                    writeGroup(group.getGroup(field, index), fieldType.asGroupType());                    recordConsumer.endGroup();                }            }            recordConsumer.endField(fieldName, field);        }    }}
fd68727d3aeb8910ee68424dda540731d6f823400b40902c0535e9527a64331d
getBinary
public Binary getBinary()
{    return binary;}
6f98cfba8fd1113c0670baa214bd66d71beaef8f7140e311bc823c3ff4e19591
getString
public String getString()
{    return binary.toStringUsingUTF8();}
5a5472c6d0d1da50080be983b26c3038dcb8b0ed3a47e734d8a6505e4403b0bc
writeValue
public void writeValue(RecordConsumer recordConsumer)
{    recordConsumer.addBinary(binary);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return getString();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.valueOf(bool);}
9c78019fc3aab731a329d8a65bf42ad673e51e48f8d63cf0a35f18fdfe6787f2
getBoolean
public boolean getBoolean()
{    return bool;}
5a5472c6d0d1da50080be983b26c3038dcb8b0ed3a47e734d8a6505e4403b0bc
writeValue
public void writeValue(RecordConsumer recordConsumer)
{    recordConsumer.addBoolean(bool);}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    this.current = simpleGroupFactory.newGroup();}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{}
b1f2f87d387166646cf5a293ddeb275f012746f1f2bcc6351eac3c7797494569
getCurrentRecord
public Group getCurrentRecord()
{    return root.getCurrentRecord();}
92fd854c4aebb01be238d83e407159211ea5cf60b5efd6fc7db8904dba13699b
getRootConverter
public GroupConverter getRootConverter()
{    return root;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    current = parent.getCurrentRecord().addGroup(index);}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    return converters[fieldIndex];}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{}
b1f2f87d387166646cf5a293ddeb275f012746f1f2bcc6351eac3c7797494569
getCurrentRecord
public Group getCurrentRecord()
{    return current;}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    parent.getCurrentRecord().add(index, value);}
23123f6657c241ab9b9f31f8efedc28a553ed91046d705121ce2667b065d6c17
addBoolean
public void addBoolean(boolean value)
{    parent.getCurrentRecord().add(index, value);}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    parent.getCurrentRecord().add(index, value);}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    parent.getCurrentRecord().add(index, value);}
a2ac1f40a6e220ec515710128c8baf77a725ad0b9f1767a998f776f27fff6cf6
addInt
public void addInt(int value)
{    parent.getCurrentRecord().add(index, value);}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    parent.getCurrentRecord().add(index, value);}
95f35c6fbf999bf94e0a9c9c5fa482ed65318ab2572fb3b51e8c181fc2611e97
getDouble
public double getDouble()
{    return value;}
5a5472c6d0d1da50080be983b26c3038dcb8b0ed3a47e734d8a6505e4403b0bc
writeValue
public void writeValue(RecordConsumer recordConsumer)
{    recordConsumer.addDouble(value);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.valueOf(value);}
ee9a51dbf95b211d37a60138ffb4deb11942d61f5c9721afa1016727fb401415
getFloat
public float getFloat()
{    return value;}
5a5472c6d0d1da50080be983b26c3038dcb8b0ed3a47e734d8a6505e4403b0bc
writeValue
public void writeValue(RecordConsumer recordConsumer)
{    recordConsumer.addFloat(value);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.valueOf(value);}
d54061a9ca8c0ce31445790aca62bd0eb6de78eb35324819b045cd82c104c7be
getInt96
public Binary getInt96()
{    return value;}
5a5472c6d0d1da50080be983b26c3038dcb8b0ed3a47e734d8a6505e4403b0bc
writeValue
public void writeValue(RecordConsumer recordConsumer)
{    recordConsumer.addBinary(value);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "Int96Value{" + String.valueOf(value) + "}";}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.valueOf(value);}
bba4ad1e0d7fde16938e3092d7ee00bd94f6edb268f1b0b7927bf2ada4410224
getInteger
public int getInteger()
{    return value;}
5a5472c6d0d1da50080be983b26c3038dcb8b0ed3a47e734d8a6505e4403b0bc
writeValue
public void writeValue(RecordConsumer recordConsumer)
{    recordConsumer.addInteger(value);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.valueOf(value);}
aa8a7e95569508772b5a86c662e4e16f24d5d8b09b7c2a751260288d63aa45ff
getLong
public long getLong()
{    return value;}
5a5472c6d0d1da50080be983b26c3038dcb8b0ed3a47e734d8a6505e4403b0bc
writeValue
public void writeValue(RecordConsumer recordConsumer)
{    recordConsumer.addLong(value);}
612b01be1d5e15f9755d32b794b75cc731bdfb0537bf8a3b5981d1abac977504
fromBinary
public static NanoTime fromBinary(Binary bytes)
{    Preconditions.checkArgument(bytes.length() == 12, "Must be 12 bytes");    ByteBuffer buf = bytes.toByteBuffer();    buf.order(ByteOrder.LITTLE_ENDIAN);    long timeOfDayNanos = buf.getLong();    int julianDay = buf.getInt();    return new NanoTime(julianDay, timeOfDayNanos);}
dd782be50006059a877efefc4af3f4470308141348dfa59d893ee303d517e76f
fromInt96
public static NanoTime fromInt96(Int96Value int96)
{    ByteBuffer buf = int96.getInt96().toByteBuffer();    return new NanoTime(buf.getInt(), buf.getLong());}
667fad50fa0b47227f89aceef807c089f82c0048c434ff8bf9ddc17796601581
getJulianDay
public int getJulianDay()
{    return julianDay;}
a0a4bd199bfdcc89bf5f52daa55800d02bec27a52885e9c6dbc7d542c575cba0
getTimeOfDayNanos
public long getTimeOfDayNanos()
{    return timeOfDayNanos;}
a9d651d0cfc40598b9be17d6a0a915670666a206eddf214a0eba3f43e6156bc6
toBinary
public Binary toBinary()
{    ByteBuffer buf = ByteBuffer.allocate(12);    buf.order(ByteOrder.LITTLE_ENDIAN);    buf.putLong(timeOfDayNanos);    buf.putInt(julianDay);    buf.flip();    return Binary.fromConstantByteBuffer(buf);}
e0dc30feecc4b661db5e2d3b013cd36e2ff79a99b81f74e85d13ca97f72b9412
toInt96
public Int96Value toInt96()
{    return new Int96Value(toBinary());}
5a5472c6d0d1da50080be983b26c3038dcb8b0ed3a47e734d8a6505e4403b0bc
writeValue
public void writeValue(RecordConsumer recordConsumer)
{    recordConsumer.addBinary(toBinary());}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "NanoTime{julianDay=" + julianDay + ", timeOfDayNanos=" + timeOfDayNanos + "}";}
6f98cfba8fd1113c0670baa214bd66d71beaef8f7140e311bc823c3ff4e19591
getString
public String getString()
{    throw new UnsupportedOperationException();}
bba4ad1e0d7fde16938e3092d7ee00bd94f6edb268f1b0b7927bf2ada4410224
getInteger
public int getInteger()
{    throw new UnsupportedOperationException();}
aa8a7e95569508772b5a86c662e4e16f24d5d8b09b7c2a751260288d63aa45ff
getLong
public long getLong()
{    throw new UnsupportedOperationException();}
9c78019fc3aab731a329d8a65bf42ad673e51e48f8d63cf0a35f18fdfe6787f2
getBoolean
public boolean getBoolean()
{    throw new UnsupportedOperationException();}
fd68727d3aeb8910ee68424dda540731d6f823400b40902c0535e9527a64331d
getBinary
public Binary getBinary()
{    throw new UnsupportedOperationException();}
d54061a9ca8c0ce31445790aca62bd0eb6de78eb35324819b045cd82c104c7be
getInt96
public Binary getInt96()
{    throw new UnsupportedOperationException();}
ee9a51dbf95b211d37a60138ffb4deb11942d61f5c9721afa1016727fb401415
getFloat
public float getFloat()
{    throw new UnsupportedOperationException();}
95f35c6fbf999bf94e0a9c9c5fa482ed65318ab2572fb3b51e8c181fc2611e97
getDouble
public double getDouble()
{    throw new UnsupportedOperationException();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return toString("");}
c4898fab21fe5ba21199bbb4fcf370ceb58a853578956ff5ffb79973e86f9851
toString
public String toString(String indent)
{    String result = "";    int i = 0;    for (Type field : schema.getFields()) {        String name = field.getName();        List<Object> values = data[i];        ++i;        if (values != null) {            if (values.size() > 0) {                for (Object value : values) {                    result += indent + name;                    if (value == null) {                        result += ": NULL\n";                    } else if (value instanceof Group) {                        result += "\n" + ((SimpleGroup) value).toString(indent + "  ");                    } else {                        result += ": " + value.toString() + "\n";                    }                }            }        }    }    return result;}
bbc6e2fc86536304a2c867155d9f6191131dd900b474d8ccafb3021af35f3f9e
addGroup
public Group addGroup(int fieldIndex)
{    SimpleGroup g = new SimpleGroup(schema.getType(fieldIndex).asGroupType());    add(fieldIndex, g);    return g;}
b113d5b68fbb576c314414bf5d6ce075c3717a86d6c80c683dc6739c349bed28
getGroup
public Group getGroup(int fieldIndex, int index)
{    return (Group) getValue(fieldIndex, index);}
5b13a356f6f27ae91369299f83525a9e69096c7731c12d987d0a321fe3881b7b
getValue
private Object getValue(int fieldIndex, int index)
{    List<Object> list;    try {        list = data[fieldIndex];    } catch (IndexOutOfBoundsException e) {        throw new RuntimeException("not found " + fieldIndex + "(" + schema.getFieldName(fieldIndex) + ") in group:\n" + this);    }    try {        return list.get(index);    } catch (IndexOutOfBoundsException e) {        throw new RuntimeException("not found " + fieldIndex + "(" + schema.getFieldName(fieldIndex) + ") element number " + index + " in group:\n" + this);    }}
69aac1635e42d32a1829e1eedea1720ef76abfd1a10226f5b1e8040d9ebe630b
add
private void add(int fieldIndex, Primitive value)
{    Type type = schema.getType(fieldIndex);    List<Object> list = data[fieldIndex];    if (!type.isRepetition(Type.Repetition.REPEATED) && !list.isEmpty()) {        throw new IllegalStateException("field " + fieldIndex + " (" + type.getName() + ") can not have more than one value: " + list);    }    list.add(value);}
c9e3e3c9f7b3b8de8aa32d213119fdc0bf2f1f03ace53d7acdfd10e7bb53b7a1
getFieldRepetitionCount
public int getFieldRepetitionCount(int fieldIndex)
{    List<Object> list = data[fieldIndex];    return list == null ? 0 : list.size();}
57667ea991d819131da1080e10bbbdec344128bf6c4e5c77950737c1e601f559
getValueToString
public String getValueToString(int fieldIndex, int index)
{    return String.valueOf(getValue(fieldIndex, index));}
4b2466672710058d9fc0e16c3f178a35d0b7be0f7a0f820ff21a4d7d30145501
getString
public String getString(int fieldIndex, int index)
{    return ((BinaryValue) getValue(fieldIndex, index)).getString();}
885263564fdc20ff5501bf532703d75117948e28022142d270b54eb4198e31a5
getInteger
public int getInteger(int fieldIndex, int index)
{    return ((IntegerValue) getValue(fieldIndex, index)).getInteger();}
4dc4510ceef640ddd9c986c0dd7a0b596d32482f2f595f8693d9262e9e9de877
getLong
public long getLong(int fieldIndex, int index)
{    return ((LongValue) getValue(fieldIndex, index)).getLong();}
086412a7b6b1edc15dd86b6542fb5cd4ebe89e52b83c347d2e33f598b3d51127
getDouble
public double getDouble(int fieldIndex, int index)
{    return ((DoubleValue) getValue(fieldIndex, index)).getDouble();}
1e39ae4c04ee3512f2c82ee62d333f45ac8ac8e85c18995ed9ad7e5fba330223
getFloat
public float getFloat(int fieldIndex, int index)
{    return ((FloatValue) getValue(fieldIndex, index)).getFloat();}
b75febf4d0cee0988f3db45cc112c1be2b8c33243314fa8f44db23b5c3aebc92
getBoolean
public boolean getBoolean(int fieldIndex, int index)
{    return ((BooleanValue) getValue(fieldIndex, index)).getBoolean();}
21076b25b72acb4193cc7e05b6226d59b03eb4df915c06b9c75c7d2b9b9c6323
getBinary
public Binary getBinary(int fieldIndex, int index)
{    return ((BinaryValue) getValue(fieldIndex, index)).getBinary();}
92a440a283a216971d3ce6ae3dccb289f602df70e87298825315bbf695d0c1da
getTimeNanos
public NanoTime getTimeNanos(int fieldIndex, int index)
{    return NanoTime.fromInt96((Int96Value) getValue(fieldIndex, index));}
4e92a1a5109bd72a07adfc5c17d269fe0d27d53903322dcdae809319d13a2c56
getInt96
public Binary getInt96(int fieldIndex, int index)
{    return ((Int96Value) getValue(fieldIndex, index)).getInt96();}
9bfc78c0c710d4c105ef16ede2bba73832c31f4d3efa649075f535f335224ebe
add
public void add(int fieldIndex, int value)
{    add(fieldIndex, new IntegerValue(value));}
fd7b2690c12e11e069b3d153a02582d5e45f488ce160d131a0a83c8e3e505b21
add
public void add(int fieldIndex, long value)
{    add(fieldIndex, new LongValue(value));}
16306a1bf4d688dc611ae3a1cf813433f24efe49f042a070bb639d9492dee397
add
public void add(int fieldIndex, String value)
{    add(fieldIndex, new BinaryValue(Binary.fromString(value)));}
04e998651151792cad8292fdd63ac7a05fe4d65f949ee5a6f8589a4c80d184bd
add
public void add(int fieldIndex, NanoTime value)
{    add(fieldIndex, value.toInt96());}
0a1713ecc9b4e7990980074ab17202cb2ebc0439a84f03ae51827f74ecb207e4
add
public void add(int fieldIndex, boolean value)
{    add(fieldIndex, new BooleanValue(value));}
3066dae5256fa0cb5ef894152c6a88dbe66e0ae85ca331641eb1e91187719877
add
public void add(int fieldIndex, Binary value)
{    switch(getType().getType(fieldIndex).asPrimitiveType().getPrimitiveTypeName()) {        case BINARY:        case FIXED_LEN_BYTE_ARRAY:            add(fieldIndex, new BinaryValue(value));            break;        case INT96:            add(fieldIndex, new Int96Value(value));            break;        default:            throw new UnsupportedOperationException(getType().asPrimitiveType().getName() + " not supported for Binary");    }}
f822065e93ececa334fc64be78b1d0be722bec269240b48bc4c92359169a6f14
add
public void add(int fieldIndex, float value)
{    add(fieldIndex, new FloatValue(value));}
01631e1c674bbf4b42481637933a58913a4c48645792383853481b72cb1e693d
add
public void add(int fieldIndex, double value)
{    add(fieldIndex, new DoubleValue(value));}
1bb9570d92f9076b29b2638bee83536300332acdf7c8db59b42bd52c85ec5d8d
add
public void add(int fieldIndex, Group value)
{    data[fieldIndex].add(value);}
19a4c3a29f3de136fbe1e955e35811d19dcb8410e0522b303cbd93f2b5a53ce3
getType
public GroupType getType()
{    return schema;}
ec5dce192feb43fcd1aeb7e11d1c8de3535ee1e3d58cd50a830657417bc6133d
writeValue
public void writeValue(int field, int index, RecordConsumer recordConsumer)
{    ((Primitive) getValue(field, index)).writeValue(recordConsumer);}
cb96e837946b16642f020eba5eb910e844a77b51a99f86c8cf8c6f99806a0817
newGroup
public Group newGroup()
{    return new SimpleGroup(schema);}
8188eec8f81b184c2c824d6927f46ab798540709fd918313fd1d70eadf6529f9
convertPrimitiveType
public Converter convertPrimitiveType(List<GroupType> path, PrimitiveType primitiveType)
{    return new PrimitiveConverter() {        @Override        public void addBinary(Binary value) {            a = value;        }        @Override        public void addBoolean(boolean value) {            a = value;        }        @Override        public void addDouble(double value) {            a = value;        }        @Override        public void addFloat(float value) {            a = value;        }        @Override        public void addInt(int value) {            a = value;        }        @Override        public void addLong(long value) {            a = value;        }    };}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    a = value;}
23123f6657c241ab9b9f31f8efedc28a553ed91046d705121ce2667b065d6c17
addBoolean
public void addBoolean(boolean value)
{    a = value;}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    a = value;}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    a = value;}
a2ac1f40a6e220ec515710128c8baf77a725ad0b9f1767a998f776f27fff6cf6
addInt
public void addInt(int value)
{    a = value;}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    a = value;}
715f35bc2c3a0b39e2a0bb191c9fc431b978e5277c11865c51b5231df9eff509
convertGroupType
public Converter convertGroupType(List<GroupType> path, GroupType groupType, final List<Converter> converters)
{    return new GroupConverter() {        public Converter getConverter(int fieldIndex) {            return converters.get(fieldIndex);        }        public void start() {            a = "start()";        }        public void end() {            a = "end()";        }    };}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    return converters.get(fieldIndex);}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    a = "start()";}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    a = "end()";}
6c784c7727b56233a3400a77e9d599f9dcf1230184d25ae872ac77b861af8e74
convertMessageType
public Converter convertMessageType(MessageType messageType, List<Converter> children)
{    return convertGroupType(null, messageType, children);}
58403499c90fec6a0fde46c22f55e9fa59559c3422239392ed92d0011a8c812d
getCurrentRecord
public Object getCurrentRecord()
{    return a;}
92fd854c4aebb01be238d83e407159211ea5cf60b5efd6fc7db8904dba13699b
getRootConverter
public GroupConverter getRootConverter()
{    return root;}
db16ed2605c79c8abaf73e5e335dfbbb94729cb2ce36b02d63ebf9d97884417d
and
public static final UnboundRecordFilter and(final UnboundRecordFilter filter1, final UnboundRecordFilter filter2)
{    Preconditions.checkNotNull(filter1, "filter1");    Preconditions.checkNotNull(filter2, "filter2");    return new UnboundRecordFilter() {        @Override        public RecordFilter bind(Iterable<ColumnReader> readers) {            return new AndRecordFilter(filter1.bind(readers), filter2.bind(readers));        }    };}
2cb2b8c29fc2760c915562b8d3ac4268c4018003c9027c17b546700c2a89961d
bind
public RecordFilter bind(Iterable<ColumnReader> readers)
{    return new AndRecordFilter(filter1.bind(readers), filter2.bind(readers));}
15318b438d8294817635482063ed53216b886b96d8dbf7da2344b4151ea8d569
isMatch
public boolean isMatch()
{    return boundFilter1.isMatch() && boundFilter2.isMatch();}
05e14dfa6ca231c5f70b74cd74e3580315b3287b82b406537b6bbef62b45cd50
equalTo
public static Predicate equalTo(final String target)
{    Preconditions.checkNotNull(target, "target");    return new Predicate() {        @Override        public boolean apply(ColumnReader input) {            return target.equals(input.getBinary().toStringUsingUTF8());        }    };}
1145498f64211f2f320ca433ea85369c524557c39cb4039f71b5291218b8c947
apply
public boolean apply(ColumnReader input)
{    return target.equals(input.getBinary().toStringUsingUTF8());}
6818c442893bf54858ea3cd9ad2b5c869f78c203347800bf838e612a7134e8be
applyFunctionToString
public static Predicate applyFunctionToString(final PredicateFunction<String> fn)
{    return new Predicate() {        @Override        public boolean apply(ColumnReader input) {            return fn.functionToApply(input.getBinary().toStringUsingUTF8());        }    };}
1145498f64211f2f320ca433ea85369c524557c39cb4039f71b5291218b8c947
apply
public boolean apply(ColumnReader input)
{    return fn.functionToApply(input.getBinary().toStringUsingUTF8());}
26fecbbbfa1ddd47e3f93d00a81dbda80854978ebcc5a05f7229b1947e70a5b0
equalTo
public static Predicate equalTo(final int target)
{    return new Predicate() {        @Override        public boolean apply(ColumnReader input) {            return input.getInteger() == target;        }    };}
1145498f64211f2f320ca433ea85369c524557c39cb4039f71b5291218b8c947
apply
public boolean apply(ColumnReader input)
{    return input.getInteger() == target;}
e69d8afb14f02270536364e8c2ea36bae398994710db505ed743235bea12e10e
applyFunctionToInteger
public static Predicate applyFunctionToInteger(final IntegerPredicateFunction fn)
{    return new Predicate() {        @Override        public boolean apply(ColumnReader input) {            return fn.functionToApply(input.getInteger());        }    };}
1145498f64211f2f320ca433ea85369c524557c39cb4039f71b5291218b8c947
apply
public boolean apply(ColumnReader input)
{    return fn.functionToApply(input.getInteger());}
a01a0242742acd3f93d7c2ec78e4767f8e10d6d26aa1ed1dc67b50975e822f52
equalTo
public static Predicate equalTo(final long target)
{    return new Predicate() {        @Override        public boolean apply(ColumnReader input) {            return input.getLong() == target;        }    };}
1145498f64211f2f320ca433ea85369c524557c39cb4039f71b5291218b8c947
apply
public boolean apply(ColumnReader input)
{    return input.getLong() == target;}
2414a367a6d0e3cadc3c419da9bbbcfb5c9d8825c8ecc66b6f1e609acb6f51f1
applyFunctionToLong
public static Predicate applyFunctionToLong(final LongPredicateFunction fn)
{    return new Predicate() {        @Override        public boolean apply(ColumnReader input) {            return fn.functionToApply(input.getLong());        }    };}
1145498f64211f2f320ca433ea85369c524557c39cb4039f71b5291218b8c947
apply
public boolean apply(ColumnReader input)
{    return fn.functionToApply(input.getLong());}
4a895fdd12e1ea8801fcffc380c139675ebb888bc0f7e437eef54102866923d0
equalTo
public static Predicate equalTo(final float target)
{    return new Predicate() {        @Override        public boolean apply(ColumnReader input) {            return input.getFloat() == target;        }    };}
1145498f64211f2f320ca433ea85369c524557c39cb4039f71b5291218b8c947
apply
public boolean apply(ColumnReader input)
{    return input.getFloat() == target;}
49161551ff3459d6968ffa6337a1cb712184a7fb8d878a0eb031d6356a6d68a2
applyFunctionToFloat
public static Predicate applyFunctionToFloat(final FloatPredicateFunction fn)
{    return new Predicate() {        @Override        public boolean apply(ColumnReader input) {            return fn.functionToApply(input.getFloat());        }    };}
1145498f64211f2f320ca433ea85369c524557c39cb4039f71b5291218b8c947
apply
public boolean apply(ColumnReader input)
{    return fn.functionToApply(input.getFloat());}
570b1e690b0fd315574e10520e6a343027bad3a64f426ef32dcc4081c6197e3d
equalTo
public static Predicate equalTo(final double target)
{    return new Predicate() {        @Override        public boolean apply(ColumnReader input) {            return input.getDouble() == target;        }    };}
1145498f64211f2f320ca433ea85369c524557c39cb4039f71b5291218b8c947
apply
public boolean apply(ColumnReader input)
{    return input.getDouble() == target;}
0103085f47f60b155ef395f074e5d1092ee6848862b29eeb7db757c7fa03850d
applyFunctionToDouble
public static Predicate applyFunctionToDouble(final DoublePredicateFunction fn)
{    return new Predicate() {        @Override        public boolean apply(ColumnReader input) {            return fn.functionToApply(input.getDouble());        }    };}
1145498f64211f2f320ca433ea85369c524557c39cb4039f71b5291218b8c947
apply
public boolean apply(ColumnReader input)
{    return fn.functionToApply(input.getDouble());}
01c87b947868793a23c760698a3ac03419f2212994827f8997435d62548c32e0
equalTo
public static Predicate equalTo(final boolean target)
{    return new Predicate() {        @Override        public boolean apply(ColumnReader input) {            return input.getBoolean() == target;        }    };}
1145498f64211f2f320ca433ea85369c524557c39cb4039f71b5291218b8c947
apply
public boolean apply(ColumnReader input)
{    return input.getBoolean() == target;}
4041535f8f9b30c5764c8d9f236a2f6ad6bc7ef6ba6b240deed49b4fb19b36bf
applyFunctionToBoolean
public static Predicate applyFunctionToBoolean(final BooleanPredicateFunction fn)
{    return new Predicate() {        @Override        public boolean apply(ColumnReader input) {            return fn.functionToApply(input.getBoolean());        }    };}
1145498f64211f2f320ca433ea85369c524557c39cb4039f71b5291218b8c947
apply
public boolean apply(ColumnReader input)
{    return fn.functionToApply(input.getBoolean());}
a1c3fa1ee57283b77769681501709a23b11423c5d249fade3756b484f7bd2ed2
equalTo
public static Predicate equalTo(final E target)
{    Preconditions.checkNotNull(target, "target");    final String targetAsString = target.name();    return new Predicate() {        @Override        public boolean apply(ColumnReader input) {            return targetAsString.equals(input.getBinary().toStringUsingUTF8());        }    };}
1145498f64211f2f320ca433ea85369c524557c39cb4039f71b5291218b8c947
apply
public boolean apply(ColumnReader input)
{    return targetAsString.equals(input.getBinary().toStringUsingUTF8());}
c79943d882f8d11b871ef7f490dde730badcdf951ee887259231ad266d4d27ed
applyFunctionToBinary
public static Predicate applyFunctionToBinary(final PredicateFunction<Binary> fn)
{    return new Predicate() {        @Override        public boolean apply(ColumnReader input) {            return fn.functionToApply(input.getBinary());        }    };}
1145498f64211f2f320ca433ea85369c524557c39cb4039f71b5291218b8c947
apply
public boolean apply(ColumnReader input)
{    return fn.functionToApply(input.getBinary());}
d99a6735645129e4b5511ba680e542813742df00e6c5e5ddff4108e0527b88bc
column
public static final UnboundRecordFilter column(final String columnPath, final ColumnPredicates.Predicate predicate)
{    checkNotNull(columnPath, "columnPath");    checkNotNull(predicate, "predicate");    return new UnboundRecordFilter() {        final String[] filterPath = columnPath.split("\\.");        @Override        public RecordFilter bind(Iterable<ColumnReader> readers) {            for (ColumnReader reader : readers) {                if (Arrays.equals(reader.getDescriptor().getPath(), filterPath)) {                    return new ColumnRecordFilter(reader, predicate);                }            }            throw new IllegalArgumentException("Column " + columnPath + " does not exist.");        }    };}
2cb2b8c29fc2760c915562b8d3ac4268c4018003c9027c17b546700c2a89961d
bind
public RecordFilter bind(Iterable<ColumnReader> readers)
{    for (ColumnReader reader : readers) {        if (Arrays.equals(reader.getDescriptor().getPath(), filterPath)) {            return new ColumnRecordFilter(reader, predicate);        }    }    throw new IllegalArgumentException("Column " + columnPath + " does not exist.");}
15318b438d8294817635482063ed53216b886b96d8dbf7da2344b4151ea8d569
isMatch
public boolean isMatch()
{    return filterPredicate.apply(filterOnColumn);}
73c0c2830c95b6fb74bcd1aa6c918334bb576f1dd34819d0fc91114863be9465
not
public static final UnboundRecordFilter not(final UnboundRecordFilter filter)
{    Preconditions.checkNotNull(filter, "filter");    return new UnboundRecordFilter() {        @Override        public RecordFilter bind(Iterable<ColumnReader> readers) {            return new NotRecordFilter(filter.bind(readers));        }    };}
2cb2b8c29fc2760c915562b8d3ac4268c4018003c9027c17b546700c2a89961d
bind
public RecordFilter bind(Iterable<ColumnReader> readers)
{    return new NotRecordFilter(filter.bind(readers));}
15318b438d8294817635482063ed53216b886b96d8dbf7da2344b4151ea8d569
isMatch
public boolean isMatch()
{    return !(boundFilter.isMatch());}
6b7b9a915bd262ed889cc9d3ef624b3329771b0c04a201e3a46358db70f35984
or
public static final UnboundRecordFilter or(final UnboundRecordFilter filter1, final UnboundRecordFilter filter2)
{    Preconditions.checkNotNull(filter1, "filter1");    Preconditions.checkNotNull(filter2, "filter2");    return new UnboundRecordFilter() {        @Override        public RecordFilter bind(Iterable<ColumnReader> readers) {            return new OrRecordFilter(filter1.bind(readers), filter2.bind(readers));        }    };}
2cb2b8c29fc2760c915562b8d3ac4268c4018003c9027c17b546700c2a89961d
bind
public RecordFilter bind(Iterable<ColumnReader> readers)
{    return new OrRecordFilter(filter1.bind(readers), filter2.bind(readers));}
15318b438d8294817635482063ed53216b886b96d8dbf7da2344b4151ea8d569
isMatch
public boolean isMatch()
{    return boundFilter1.isMatch() || boundFilter2.isMatch();}
ca181ab3a6fd2f4c59cf80a97ce2dd49f8d4707fe9985feeccaea90cb93f4675
page
public static final UnboundRecordFilter page(final long startPos, final long pageSize)
{    return new UnboundRecordFilter() {        @Override        public RecordFilter bind(Iterable<ColumnReader> readers) {            return new PagedRecordFilter(startPos, pageSize);        }    };}
2cb2b8c29fc2760c915562b8d3ac4268c4018003c9027c17b546700c2a89961d
bind
public RecordFilter bind(Iterable<ColumnReader> readers)
{    return new PagedRecordFilter(startPos, pageSize);}
15318b438d8294817635482063ed53216b886b96d8dbf7da2344b4151ea8d569
isMatch
public boolean isMatch()
{    currentPos++;    return ((currentPos >= startPos) && (currentPos < endPos));}
688a4bb6492561c65cdde605095409c085bd97831e72fdccb99af8d30d33ed5c
get
public static Filter get(FilterPredicate filterPredicate)
{    checkNotNull(filterPredicate, "filterPredicate");    LOG.info("Filtering using predicate: {}", filterPredicate);        FilterPredicate collapsedPredicate = LogicalInverseRewriter.rewrite(filterPredicate);    if (!filterPredicate.equals(collapsedPredicate)) {        LOG.info("Predicate has been collapsed to: {}", collapsedPredicate);    }    return new FilterPredicateCompat(collapsedPredicate);}
90f8523d710bde7886f2f54fb6faae5fe1c184cd8f3a3d07f8fc37762df3c3c1
get
public static Filter get(UnboundRecordFilter unboundRecordFilter)
{    return new UnboundRecordFilterCompat(unboundRecordFilter);}
b1bcc0bbd51c6cc5be8dfccd7caff04e34199190cbcd589ab04840207771be16
get
public static Filter get(FilterPredicate filterPredicate, UnboundRecordFilter unboundRecordFilter)
{    checkArgument(filterPredicate == null || unboundRecordFilter == null, "Cannot provide both a FilterPredicate and an UnboundRecordFilter");    if (filterPredicate != null) {        return get(filterPredicate);    }    if (unboundRecordFilter != null) {        return get(unboundRecordFilter);    }    return NOOP;}
663542e9b7d6cfa68d7e9788994e0382d1a188d471f35eec88b068eb9a181b79
getFilterPredicate
public FilterPredicate getFilterPredicate()
{    return filterPredicate;}
abab9921ffe7366a52406f9bbae13e33613f8fd08c0606a4a323a8912f6bcd5d
accept
public R accept(Visitor<R> visitor)
{    return visitor.visit(this);}
74c649c2b54c91726f4f95e1731bd3a5914cae048a3c64c2850ec8708229fa16
getUnboundRecordFilter
public UnboundRecordFilter getUnboundRecordFilter()
{    return unboundRecordFilter;}
abab9921ffe7366a52406f9bbae13e33613f8fd08c0606a4a323a8912f6bcd5d
accept
public R accept(Visitor<R> visitor)
{    return visitor.visit(this);}
abab9921ffe7366a52406f9bbae13e33613f8fd08c0606a4a323a8912f6bcd5d
accept
public R accept(Visitor<R> visitor)
{    return visitor.visit(this);}
202dd8de7462f4accdc7e3730877291a6527dfb32fe895365a370c72b1e9e144
intColumn
public static IntColumn intColumn(String columnPath)
{    return new IntColumn(ColumnPath.fromDotString(columnPath));}
23fd12280ea55e323e57f487f1d7c9200823812b35775df17fe311b6d38b819a
longColumn
public static LongColumn longColumn(String columnPath)
{    return new LongColumn(ColumnPath.fromDotString(columnPath));}
c9c8361e9fb237c3c1a4ce61456388df13c6a374e711f8d490f2fa0de41eb13c
floatColumn
public static FloatColumn floatColumn(String columnPath)
{    return new FloatColumn(ColumnPath.fromDotString(columnPath));}
604f061da62ebc371a57c34be610f1090a13907a5c16697f36e3ff2330606249
doubleColumn
public static DoubleColumn doubleColumn(String columnPath)
{    return new DoubleColumn(ColumnPath.fromDotString(columnPath));}
a41a86c7a5faf6410216a3323e4c10f15d6e9ee2c57c122e6bcef5ef303f7e40
booleanColumn
public static BooleanColumn booleanColumn(String columnPath)
{    return new BooleanColumn(ColumnPath.fromDotString(columnPath));}
0dcd3ea75733262ab91f4b3fa688b080dc006e3bf532154e1896297f332c4eef
binaryColumn
public static BinaryColumn binaryColumn(String columnPath)
{    return new BinaryColumn(ColumnPath.fromDotString(columnPath));}
bc7094aaf14905ac4ae557ad9f204fac3589a9009d5aa50909e437462290cc39
eq
public static Eq<T> eq(C column, T value)
{    return new Eq<T>(column, value);}
958534d45d97739304f09e5a52525b644b52a5b199c4f0f49e899c31fa44de58
notEq
public static NotEq<T> notEq(C column, T value)
{    return new NotEq<T>(column, value);}
6bb6b0aaf3b3ed432190b2dfedd4fc3011203fd0f5313860ad41369276d32327
lt
public static Lt<T> lt(C column, T value)
{    return new Lt<T>(column, value);}
df185c30ec3674b2c123650c48f61bc37aed367925d745a3214a74fe14aa0df7
ltEq
public static LtEq<T> ltEq(C column, T value)
{    return new LtEq<T>(column, value);}
f2e3dc4b1f19a2fde265683d5886da38e54f6f7c3fae263be728c90993670297
gt
public static Gt<T> gt(C column, T value)
{    return new Gt<T>(column, value);}
2d74546850ea37536262e23059157e3c696d34529b9e711a845a54ff239391b8
gtEq
public static GtEq<T> gtEq(C column, T value)
{    return new GtEq<T>(column, value);}
10ac0aaead8379ad5f7628e0b76207eb30ddc0a0519dc1f8f7d18792bad21ba1
userDefined
public static UserDefined<T, U> userDefined(Column<T> column, Class<U> clazz)
{    return new UserDefinedByClass<T, U>(column, clazz);}
d3ac936d41216aabaf22a7c75bf7697b92bb81dc94b4b7ca4d9d810fd79acebc
userDefined
public static UserDefined<T, U> userDefined(Column<T> column, U udp)
{    return new UserDefinedByInstance<T, U>(column, udp);}
2055170da422c76cbb5c53543bf8bea9ff0c07c99a718d8fafe674465869d4c2
and
public static FilterPredicate and(FilterPredicate left, FilterPredicate right)
{    return new And(left, right);}
52413631c884876ef94b209fd088c44a506ed131decc1903b297e28ddb86fd4b
or
public static FilterPredicate or(FilterPredicate left, FilterPredicate right)
{    return new Or(left, right);}
5b28415061b9e9db2c532bf474c6871426371d771ffff54de19abc00bcab6f45
not
public static FilterPredicate not(FilterPredicate predicate)
{    return new Not(predicate);}
984f14965e79862c8a7eba1b90d3827095f5d49ec865a0063eea6eb091975956
rewrite
public static FilterPredicate rewrite(FilterPredicate pred)
{    checkNotNull(pred, "pred");    return pred.accept(INSTANCE);}
86a4c64340f07b9931e52ec343caca6c3692fece481ebdb279b0f5c2f717a04b
visit
public FilterPredicate visit(Eq<T> eq)
{    return eq;}
cd233bb5cf9463636276dbe766f4e34b6d4a8d7ad5013ff6e57dfd47639ede9d
visit
public FilterPredicate visit(NotEq<T> notEq)
{    return notEq;}
d5aeb2e797b574348d0ae60f96845c0ae940f7e8d70df023c648f745e831583e
visit
public FilterPredicate visit(Lt<T> lt)
{    return lt;}
2534cb31f1e25eb1ab1e046d9b165a6a9556c2118edbb55791c813f20a21210d
visit
public FilterPredicate visit(LtEq<T> ltEq)
{    return ltEq;}
2b50ddc3387736d292740ed7833aa15c0e9ceef65bfb9f05d79d4b830faf3247
visit
public FilterPredicate visit(Gt<T> gt)
{    return gt;}
7ada9a4eaef351c7fdb8c368729c0c5e01197a77e3d808580d534450a9b7517d
visit
public FilterPredicate visit(GtEq<T> gtEq)
{    return gtEq;}
5889fb4c6b0be8bfbac7794c94e41e202812258c5611fe5451409df99e6a8cd4
visit
public FilterPredicate visit(And and)
{    return and(and.getLeft().accept(this), and.getRight().accept(this));}
a704840f57fda55770217b860f43b32dc6bf2fd45ccc8a0956bc0f91cc3ec2fd
visit
public FilterPredicate visit(Or or)
{    return or(or.getLeft().accept(this), or.getRight().accept(this));}
cde00786e5f83028626d20b66063ceebd42948e78fa48cfbac8412f2284c89f4
visit
public FilterPredicate visit(Not not)
{    return LogicalInverter.invert(not.getPredicate().accept(this));}
f832dd319146ab2ac14a715216e7f208c7cfd17e0db09cb6dad28e3306973366
visit
public FilterPredicate visit(UserDefined<T, U> udp)
{    return udp;}
e903815d0b6fc0a225b63a9e26b096f993e9e86102945cd640bf473207a66e51
visit
public FilterPredicate visit(LogicalNotUserDefined<T, U> udp)
{    return udp;}
e265548199061cfbdbff967e2c42437a8aa2b83e07f21a0538e686f386e6b5d6
invert
public static FilterPredicate invert(FilterPredicate pred)
{    checkNotNull(pred, "pred");    return pred.accept(INSTANCE);}
86a4c64340f07b9931e52ec343caca6c3692fece481ebdb279b0f5c2f717a04b
visit
public FilterPredicate visit(Eq<T> eq)
{    return new NotEq<T>(eq.getColumn(), eq.getValue());}
cd233bb5cf9463636276dbe766f4e34b6d4a8d7ad5013ff6e57dfd47639ede9d
visit
public FilterPredicate visit(NotEq<T> notEq)
{    return new Eq<T>(notEq.getColumn(), notEq.getValue());}
d5aeb2e797b574348d0ae60f96845c0ae940f7e8d70df023c648f745e831583e
visit
public FilterPredicate visit(Lt<T> lt)
{    return new GtEq<T>(lt.getColumn(), lt.getValue());}
2534cb31f1e25eb1ab1e046d9b165a6a9556c2118edbb55791c813f20a21210d
visit
public FilterPredicate visit(LtEq<T> ltEq)
{    return new Gt<T>(ltEq.getColumn(), ltEq.getValue());}
2b50ddc3387736d292740ed7833aa15c0e9ceef65bfb9f05d79d4b830faf3247
visit
public FilterPredicate visit(Gt<T> gt)
{    return new LtEq<T>(gt.getColumn(), gt.getValue());}
7ada9a4eaef351c7fdb8c368729c0c5e01197a77e3d808580d534450a9b7517d
visit
public FilterPredicate visit(GtEq<T> gtEq)
{    return new Lt<T>(gtEq.getColumn(), gtEq.getValue());}
5889fb4c6b0be8bfbac7794c94e41e202812258c5611fe5451409df99e6a8cd4
visit
public FilterPredicate visit(And and)
{    return new Or(and.getLeft().accept(this), and.getRight().accept(this));}
a704840f57fda55770217b860f43b32dc6bf2fd45ccc8a0956bc0f91cc3ec2fd
visit
public FilterPredicate visit(Or or)
{    return new And(or.getLeft().accept(this), or.getRight().accept(this));}
cde00786e5f83028626d20b66063ceebd42948e78fa48cfbac8412f2284c89f4
visit
public FilterPredicate visit(Not not)
{    return not.getPredicate();}
f832dd319146ab2ac14a715216e7f208c7cfd17e0db09cb6dad28e3306973366
visit
public FilterPredicate visit(UserDefined<T, U> udp)
{    return new LogicalNotUserDefined<T, U>(udp);}
e903815d0b6fc0a225b63a9e26b096f993e9e86102945cd640bf473207a66e51
visit
public FilterPredicate visit(LogicalNotUserDefined<T, U> udp)
{    return udp.getUserDefined();}
fe2861811678a6295919e7c0397e81b138396352290044423bb5cf85fcb9f723
getColumnType
public Class<T> getColumnType()
{    return columnType;}
f7ac3302472827844d7237f6be9200ae517711cf0a4614d7a8051e52dfffa52b
getColumnPath
public ColumnPath getColumnPath()
{    return columnPath;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "column(" + columnPath.toDotString() + ")";}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    Column column = (Column) o;    if (!columnType.equals(column.columnType))        return false;    if (!columnPath.equals(column.columnPath))        return false;    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = columnPath.hashCode();    result = 31 * result + columnType.hashCode();    return result;}
38903c1d2c51abf5fa5d2f364654d5872939985066c7013e48439dd48413d1ab
getColumn
public Column<T> getColumn()
{    return column;}
5d1a642cd3f56327936f74c7e42620bdce9a2aa959d5c16e15c526e66eba684a
getValue
public T getValue()
{    return value;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return toString;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    ColumnFilterPredicate that = (ColumnFilterPredicate) o;    if (!column.equals(that.column))        return false;    if (value != null ? !value.equals(that.value) : that.value != null)        return false;    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = column.hashCode();    result = 31 * result + (value != null ? value.hashCode() : 0);    result = 31 * result + getClass().hashCode();    return result;}
abab9921ffe7366a52406f9bbae13e33613f8fd08c0606a4a323a8912f6bcd5d
accept
public R accept(Visitor<R> visitor)
{    return visitor.visit(this);}
abab9921ffe7366a52406f9bbae13e33613f8fd08c0606a4a323a8912f6bcd5d
accept
public R accept(Visitor<R> visitor)
{    return visitor.visit(this);}
abab9921ffe7366a52406f9bbae13e33613f8fd08c0606a4a323a8912f6bcd5d
accept
public R accept(Visitor<R> visitor)
{    return visitor.visit(this);}
abab9921ffe7366a52406f9bbae13e33613f8fd08c0606a4a323a8912f6bcd5d
accept
public R accept(Visitor<R> visitor)
{    return visitor.visit(this);}
abab9921ffe7366a52406f9bbae13e33613f8fd08c0606a4a323a8912f6bcd5d
accept
public R accept(Visitor<R> visitor)
{    return visitor.visit(this);}
abab9921ffe7366a52406f9bbae13e33613f8fd08c0606a4a323a8912f6bcd5d
accept
public R accept(Visitor<R> visitor)
{    return visitor.visit(this);}
afa481039868b7ac38d2de8fe5d34a0b810270a7282686c65517a7f98d47b51b
getLeft
public FilterPredicate getLeft()
{    return left;}
2035fa2fdb6c30d47e0d1f268cd058eebb0aa18ab669a1592a42bdd39a0c52b9
getRight
public FilterPredicate getRight()
{    return right;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return toString;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    BinaryLogicalFilterPredicate that = (BinaryLogicalFilterPredicate) o;    if (!left.equals(that.left))        return false;    if (!right.equals(that.right))        return false;    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = left.hashCode();    result = 31 * result + right.hashCode();    result = 31 * result + getClass().hashCode();    return result;}
abab9921ffe7366a52406f9bbae13e33613f8fd08c0606a4a323a8912f6bcd5d
accept
public R accept(Visitor<R> visitor)
{    return visitor.visit(this);}
abab9921ffe7366a52406f9bbae13e33613f8fd08c0606a4a323a8912f6bcd5d
accept
public R accept(Visitor<R> visitor)
{    return visitor.visit(this);}
14a84f5624f57dad1fe903fb80f4ff323c23af49e5deeae36f172cdb6078122c
getPredicate
public FilterPredicate getPredicate()
{    return predicate;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return toString;}
abab9921ffe7366a52406f9bbae13e33613f8fd08c0606a4a323a8912f6bcd5d
accept
public R accept(Visitor<R> visitor)
{    return visitor.visit(this);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    Not not = (Not) o;    return predicate.equals(not.predicate);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return predicate.hashCode() * 31 + getClass().hashCode();}
38903c1d2c51abf5fa5d2f364654d5872939985066c7013e48439dd48413d1ab
getColumn
public Column<T> getColumn()
{    return column;}
abab9921ffe7366a52406f9bbae13e33613f8fd08c0606a4a323a8912f6bcd5d
accept
public R accept(Visitor<R> visitor)
{    return visitor.visit(this);}
a8498942a879efc54fdedeebae99221c94d04b51c80c17ac5c44a3701542ccfd
getUserDefinedPredicateClass
public Class<U> getUserDefinedPredicateClass()
{    return udpClass;}
b27e95e7439eaca003415977a067271016649ff1e1a43cc8851af573654109d6
getUserDefinedPredicate
public U getUserDefinedPredicate()
{    try {        return udpClass.newInstance();    } catch (InstantiationException e) {        throw new RuntimeException(String.format(INSTANTIATION_ERROR_MESSAGE, udpClass), e);    } catch (IllegalAccessException e) {        throw new RuntimeException(String.format(INSTANTIATION_ERROR_MESSAGE, udpClass), e);    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return toString;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    UserDefinedByClass that = (UserDefinedByClass) o;    if (!column.equals(that.column))        return false;    if (!udpClass.equals(that.udpClass))        return false;    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = column.hashCode();    result = 31 * result + udpClass.hashCode();    result = result * 31 + getClass().hashCode();    return result;}
b27e95e7439eaca003415977a067271016649ff1e1a43cc8851af573654109d6
getUserDefinedPredicate
public U getUserDefinedPredicate()
{    return udpInstance;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return toString;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    UserDefinedByInstance that = (UserDefinedByInstance) o;    if (!column.equals(that.column))        return false;    if (!udpInstance.equals(that.udpInstance))        return false;    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = column.hashCode();    result = 31 * result + udpInstance.hashCode();    result = result * 31 + getClass().hashCode();    return result;}
e18f2463c3cb584c30824cdea4a99e9a1192f8f13df33cd90662fd4f62d74e00
getUserDefined
public UserDefined<T, U> getUserDefined()
{    return udp;}
abab9921ffe7366a52406f9bbae13e33613f8fd08c0606a4a323a8912f6bcd5d
accept
public R accept(Visitor<R> visitor)
{    return visitor.visit(this);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return toString;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    LogicalNotUserDefined that = (LogicalNotUserDefined) o;    if (!udp.equals(that.udp))        return false;    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = udp.hashCode();    result = result * 31 + getClass().hashCode();    return result;}
5ae9150cefcfca12a6eeef86023b4af2a0f5e866e78e3f29df1adfee82e6b7f2
get
public static Class<?> get(Class<?> c)
{    checkArgument(c.isPrimitive(), "Class " + c + " is not primitive!");    return primitiveToBoxed.get(c);}
80cbbd31a3e7195849db1c843fd884160542f0b95cc29a8f919c1a38dbf73243
validate
public static void validate(FilterPredicate predicate, MessageType schema)
{    checkNotNull(predicate, "predicate");    checkNotNull(schema, "schema");    predicate.accept(new SchemaCompatibilityValidator(schema));}
52b757fb904bce4507ab621e4322cbfddcc2e2fcefc7f23a42d33bffb056df00
visit
public Void visit(Eq<T> pred)
{    validateColumnFilterPredicate(pred);    return null;}
df946b22d448c8f906ec1749c97c2d5da54d6cfb482d5659835830600019eab4
visit
public Void visit(NotEq<T> pred)
{    validateColumnFilterPredicate(pred);    return null;}
984b169e8a086bbfe25b467ce9b5d8bf964769a616203ea36c4038a929e19686
visit
public Void visit(Lt<T> pred)
{    validateColumnFilterPredicate(pred);    return null;}
50ea94f80d990961dedc97dd16c0e4076293cc9552b35e5485c66423e84bbdd2
visit
public Void visit(LtEq<T> pred)
{    validateColumnFilterPredicate(pred);    return null;}
0f01c0d27652774b3a21672683e1cef6eacc7422ad95e4bba38cbd7e16fe7f4e
visit
public Void visit(Gt<T> pred)
{    validateColumnFilterPredicate(pred);    return null;}
eec20a0f23606ab489cc6b6a6d56f89db7b5b2df5f638007c68da68ab886b9ad
visit
public Void visit(GtEq<T> pred)
{    validateColumnFilterPredicate(pred);    return null;}
594e7c1fe3ddfa9b71badb27372dd3c4722dd3cde9b4f2ae74e8bb16c18637a0
visit
public Void visit(And and)
{    and.getLeft().accept(this);    and.getRight().accept(this);    return null;}
7f44c52233c5a5806fee0a11e4ede38f51b4bbf7d22ca8665173102efffb13d4
visit
public Void visit(Or or)
{    or.getLeft().accept(this);    or.getRight().accept(this);    return null;}
3614a7c9a57a8a325aa24ebfd613957bfd958708e2c37922d494f1a4c4fdaed4
visit
public Void visit(Not not)
{    not.getPredicate().accept(this);    return null;}
11b5e17e2bfedf05b901351a750764be06f3d785af8c6144a0fcfa02f3f9d039
visit
public Void visit(UserDefined<T, U> udp)
{    validateColumn(udp.getColumn());    return null;}
5906f4f3648db786b8e9aeabd6a5d10d52feda3b5ba4bea75249c2c92c880445
visit
public Void visit(LogicalNotUserDefined<T, U> udp)
{    return udp.getUserDefined().accept(this);}
621f95f17c2002a059bfb50c0c5c9fdfb40643da2c14f1504b680062d317a818
validateColumnFilterPredicate
private void validateColumnFilterPredicate(ColumnFilterPredicate<T> pred)
{    validateColumn(pred.getColumn());}
d349903402619aee7600b6bd3510008bff85177cd56fb591f6441321e54d01aa
validateColumn
private void validateColumn(Column<T> column)
{    ColumnPath path = column.getColumnPath();    Class<?> alreadySeen = columnTypesEncountered.get(path);    if (alreadySeen != null && !alreadySeen.equals(column.getColumnType())) {        throw new IllegalArgumentException("Column: " + path.toDotString() + " was provided with different types in the same predicate." + " Found both: (" + alreadySeen + ", " + column.getColumnType() + ")");    }    if (alreadySeen == null) {        columnTypesEncountered.put(path, column.getColumnType());    }    ColumnDescriptor descriptor = getColumnDescriptor(path);    if (descriptor == null) {                return;    }    if (descriptor.getMaxRepetitionLevel() > 0) {        throw new IllegalArgumentException("FilterPredicates do not currently support repeated columns. " + "Column " + path.toDotString() + " is repeated.");    }    ValidTypeMap.assertTypeValid(column, descriptor.getType());}
be18b9844cfb637e9fec59e7ba8879e103e7951571cc98db13087906dd8d8060
getColumnDescriptor
private ColumnDescriptor getColumnDescriptor(ColumnPath columnPath)
{    return columnsAccordingToSchema.get(columnPath);}
a88ec6a53f1bd807d7abfdf160a919f0249a6f9484ea47f75a56ad4736fe0089
getMin
public T getMin()
{    return min;}
f0ce3dfd58bc40aebb57c90ff6034f14e718018261b8971e4a1d024bf2dcd77d
getMax
public T getMax()
{    return max;}
a403f912764f55bf745642c85865ddc67ea196862155aa6ed6ba6ecd6f6fb13c
getComparator
public Comparator<T> getComparator()
{    return comparator;}
a03ec388cb7aac6023b6c9da79530a4bc90c74e7a8aacbac01d857d839b06468
acceptsNullValue
public boolean acceptsNullValue()
{    try {        return keep(null);    } catch (NullPointerException e) {                return false;    }}
ef0a10f067188c84cb9a3cb1b1575004f1d7fca7748ccc6841c690a19ee0fbbd
add
private static void add(Class<?> c, PrimitiveTypeName p)
{    Set<PrimitiveTypeName> descriptors = classToParquetType.get(c);    if (descriptors == null) {        descriptors = new HashSet<PrimitiveTypeName>();        classToParquetType.put(c, descriptors);    }    descriptors.add(p);    Set<Class<?>> classes = parquetTypeToClass.get(p);    if (classes == null) {        classes = new HashSet<Class<?>>();        parquetTypeToClass.put(p, classes);    }    classes.add(c);}
411baf80c944e99ed47f3abb2218c01f3c687c34702f999b49bdb3a2ddf6faf1
assertTypeValid
public static void assertTypeValid(Column<T> foundColumn, PrimitiveTypeName primitiveType)
{    Class<T> foundColumnType = foundColumn.getColumnType();    ColumnPath columnPath = foundColumn.getColumnPath();    Set<PrimitiveTypeName> validTypeDescriptors = classToParquetType.get(foundColumnType);    if (validTypeDescriptors == null) {        StringBuilder message = new StringBuilder();        message.append("Column ").append(columnPath.toDotString()).append(" was declared as type: ").append(foundColumnType.getName()).append(" which is not supported in FilterPredicates.");        Set<Class<?>> supportedTypes = parquetTypeToClass.get(primitiveType);        if (supportedTypes != null) {            message.append(" Supported types for this column are: ").append(supportedTypes);        } else {            message.append(" There are no supported types for columns of " + primitiveType);        }        throw new IllegalArgumentException(message.toString());    }    if (!validTypeDescriptors.contains(primitiveType)) {        StringBuilder message = new StringBuilder();        message.append("FilterPredicate column: ").append(columnPath.toDotString()).append("'s declared type (").append(foundColumnType.getName()).append(") does not match the schema found in file metadata. Column ").append(columnPath.toDotString()).append(" is of type: ").append(primitiveType).append("\nValid types for this column are: ").append(parquetTypeToClass.get(primitiveType));        throw new IllegalArgumentException(message.toString());    }}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{        Converter delegateConverter = checkNotNull(delegate.getConverter(fieldIndex), "delegate converter");            List<Integer> newIndexFieldPath = new ArrayList<Integer>(indexFieldPath.size() + 1);    newIndexFieldPath.addAll(indexFieldPath);    newIndexFieldPath.add(fieldIndex);    if (delegateConverter.isPrimitive()) {        PrimitiveColumnIO columnIO = getColumnIO(newIndexFieldPath);        ColumnPath columnPath = ColumnPath.get(columnIO.getColumnDescriptor().getPath());        ValueInspector[] valueInspectors = getValueInspectors(columnPath);        return new FilteringPrimitiveConverter(delegateConverter.asPrimitiveConverter(), valueInspectors);    } else {        return new FilteringGroupConverter(delegateConverter.asGroupConverter(), newIndexFieldPath, valueInspectorsByColumn, columnIOsByIndexFieldPath);    }}
68753632f096598a1e9be3b58b9eea1a72baef5353d09da2ae8966d7194bd6dd
getColumnIO
private PrimitiveColumnIO getColumnIO(List<Integer> indexFieldPath)
{    PrimitiveColumnIO found = columnIOsByIndexFieldPath.get(indexFieldPath);    checkArgument(found != null, "Did not find PrimitiveColumnIO for index field path" + indexFieldPath);    return found;}
f9069292264a13d86bb39cf914b02fd7b75a6873084d76638fc083662c97596a
getValueInspectors
private ValueInspector[] getValueInspectors(ColumnPath columnPath)
{    List<ValueInspector> inspectorsList = valueInspectorsByColumn.get(columnPath);    if (inspectorsList == null) {        return new ValueInspector[] {};    } else {        return inspectorsList.toArray(new ValueInspector[inspectorsList.size()]);    }}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    delegate.start();}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    delegate.end();}
7c3f73c96e69cb35837e756142746fd240f40ccf1d7d310c2436e6b135fe196b
hasDictionarySupport
public boolean hasDictionarySupport()
{    return false;}
5edde50d3cb88777a151a88dae34321ada39b284501a5295564b122126c5c393
setDictionary
public void setDictionary(Dictionary dictionary)
{    throw new UnsupportedOperationException("FilteringPrimitiveConverter doesn't have dictionary support");}
f1649786c3679c86c0157574e47953673714091cc71d598cedff963593010d98
addValueFromDictionary
public void addValueFromDictionary(int dictionaryId)
{    throw new UnsupportedOperationException("FilteringPrimitiveConverter doesn't have dictionary support");}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    for (ValueInspector valueInspector : valueInspectors) {        valueInspector.update(value);    }    delegate.addBinary(value);}
23123f6657c241ab9b9f31f8efedc28a553ed91046d705121ce2667b065d6c17
addBoolean
public void addBoolean(boolean value)
{    for (ValueInspector valueInspector : valueInspectors) {        valueInspector.update(value);    }    delegate.addBoolean(value);}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    for (ValueInspector valueInspector : valueInspectors) {        valueInspector.update(value);    }    delegate.addDouble(value);}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    for (ValueInspector valueInspector : valueInspectors) {        valueInspector.update(value);    }    delegate.addFloat(value);}
a2ac1f40a6e220ec515710128c8baf77a725ad0b9f1767a998f776f27fff6cf6
addInt
public void addInt(int value)
{    for (ValueInspector valueInspector : valueInspectors) {        valueInspector.update(value);    }    delegate.addInt(value);}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    for (ValueInspector valueInspector : valueInspectors) {        valueInspector.update(value);    }    delegate.addLong(value);}
f2542e4caf455edc6d5f8012d66d3358c3c9e1e9815b2b014cbc819942371e56
getIndexFieldPathList
public static List<Integer> getIndexFieldPathList(PrimitiveColumnIO c)
{    return intArrayToList(c.getIndexFieldPath());}
11e019975b54938daced1c21a68ad337ce92e4a08470f07e3980a7f9c7100659
intArrayToList
public static List<Integer> intArrayToList(int[] arr)
{    List<Integer> list = new ArrayList<Integer>(arr.length);    for (int i : arr) {        list.add(i);    }    return list;}
4da3915efeb45bd522ec756d13523540a507279d9a0b787efd2cafb4356363d1
getCurrentRecord
public T getCurrentRecord()
{        boolean keep = IncrementallyUpdatedFilterPredicateEvaluator.evaluate(filterPredicate);        IncrementallyUpdatedFilterPredicateResetter.reset(filterPredicate);    if (keep) {        return delegate.getCurrentRecord();    } else {                return null;    }}
52337910a1f4ce802e2fe6041829534330913357c00d4735ce0fa742f5c3df17
skipCurrentRecord
public void skipCurrentRecord()
{    delegate.skipCurrentRecord();}
92fd854c4aebb01be238d83e407159211ea5cf60b5efd6fc7db8904dba13699b
getRootConverter
public GroupConverter getRootConverter()
{    return rootConverter;}
e2ad11a16cdc3bb63def4c96f6278da7be6b19bbbbb7b3b31e99bf7fdc83edad
updateNull
public void updateNull()
{    throw new UnsupportedOperationException();}
7d630ab84a82142fdaf1528f2bcc2cec2c8f672a645aa065a9afce31f57b8e78
update
public void update(int value)
{    throw new UnsupportedOperationException();}
a584b6622a7dc27bba2e1c8ea31dd391bcb4d672d8fd5b9e53d751ac750924c5
update
public void update(long value)
{    throw new UnsupportedOperationException();}
9816736c0b0bcc70e8ebae510d041f2a0524be549ab3fbdba000ec7ae3903048
update
public void update(double value)
{    throw new UnsupportedOperationException();}
f5d0e65c8bd85a0970c77be8d5a6723e24b06dedde7e9e828e96c7502e29deb1
update
public void update(float value)
{    throw new UnsupportedOperationException();}
c69774df52a161f61658f6908ab067fb7d8e25cd4e8d37f2552760b76f620f63
update
public void update(boolean value)
{    throw new UnsupportedOperationException();}
3dcaad6e92572064bc4bc6e0d924321ed373bdfbdeabb2d6437b276435f763de
update
public void update(Binary value)
{    throw new UnsupportedOperationException();}
133af37a12c95974e34d537fbbde5dfc5984ef5d84826ee981caa7b5c18428d9
reset
public final void reset()
{    isKnown = false;    result = false;}
879b7f5b3b5728bd562d94bbe4501b6c7b90e2fa1f3a4ea6ee65a3481806f5dd
setResult
protected final void setResult(boolean result)
{    if (isKnown) {        throw new IllegalStateException("setResult() called on a ValueInspector whose result is already known!" + " Did you forget to call reset()?");    }    this.result = result;    this.isKnown = true;}
afc1879a1d5fbcc9e677eb83d2c2db1be6a0496f21305e87e937d1c10cdbdac5
getResult
public final boolean getResult()
{    if (!isKnown) {        throw new IllegalStateException("getResult() called on a ValueInspector whose result is not yet known!");    }    return result;}
2c255380e84c9d0452703ec8163f2de63025d0c600e8845aad5f38ce5ac380b4
isKnown
public final boolean isKnown()
{    return isKnown;}
97adbf4630b0d771ecd2d45ee820dd6808014cf6c408782a05144f45e382b7bb
accept
public boolean accept(Visitor visitor)
{    return visitor.visit(this);}
ce19fe49c11f75f991e2d15a355e26aac96760482886d895e094295c9bfba85a
getLeft
public final IncrementallyUpdatedFilterPredicate getLeft()
{    return left;}
4cc765ea3dda8bae590434d986c44cfa30dfaeac48bff49735c6b8f9b08e5740
getRight
public final IncrementallyUpdatedFilterPredicate getRight()
{    return right;}
97adbf4630b0d771ecd2d45ee820dd6808014cf6c408782a05144f45e382b7bb
accept
public boolean accept(Visitor visitor)
{    return visitor.visit(this);}
97adbf4630b0d771ecd2d45ee820dd6808014cf6c408782a05144f45e382b7bb
accept
public boolean accept(Visitor visitor)
{    return visitor.visit(this);}
9faa9af47f04175d7ed49caec67321a76659009f277d0695ebafc314b50e1a67
build
public final IncrementallyUpdatedFilterPredicate build(FilterPredicate pred)
{    checkArgument(!built, "This builder has already been used");    IncrementallyUpdatedFilterPredicate incremental = pred.accept(this);    built = true;    return incremental;}
1cc750e71c529074be78ece77291182c4e01ce313705219a62334c2798822054
addValueInspector
protected final void addValueInspector(ColumnPath columnPath, ValueInspector valueInspector)
{    List<ValueInspector> valueInspectors = valueInspectorsByColumn.get(columnPath);    if (valueInspectors == null) {        valueInspectors = new ArrayList<ValueInspector>();        valueInspectorsByColumn.put(columnPath, valueInspectors);    }    valueInspectors.add(valueInspector);}
9d658bc462450df74a4e4bc14430d9d0094557e6dfe538809f2ce52cda0ca2c1
getValueInspectorsByColumn
public Map<ColumnPath, List<ValueInspector>> getValueInspectorsByColumn()
{    return valueInspectorsByColumn;}
3cac28c3b96f0f81070e0f939c755f0e0650710b190f00e399bbdc626f9d7487
getComparator
protected final PrimitiveComparator<T> getComparator(ColumnPath path)
{    return (PrimitiveComparator<T>) comparatorsByColumn.get(path);}
11f521454b0bddb406563d2bd550b4a279e2d2aa586442066fb2873d1a0dd907
visit
public final IncrementallyUpdatedFilterPredicate visit(And and)
{    return new IncrementallyUpdatedFilterPredicate.And(and.getLeft().accept(this), and.getRight().accept(this));}
9944f613c0055588cdc48da04a1b3888e63b041a18aec0576aa524a507ca5f47
visit
public final IncrementallyUpdatedFilterPredicate visit(Or or)
{    return new IncrementallyUpdatedFilterPredicate.Or(or.getLeft().accept(this), or.getRight().accept(this));}
aad42a904415803216260e7a97f10359c925ea6a696d742f373a590e2bfa839e
visit
public final IncrementallyUpdatedFilterPredicate visit(Not not)
{    throw new IllegalArgumentException("This predicate contains a not! Did you forget to run this predicate through LogicalInverseRewriter? " + not);}
337cabf913d265d649ef2954555b7dcc2c1cfd7d72adde3e74a42288c7c69797
evaluate
public static boolean evaluate(IncrementallyUpdatedFilterPredicate pred)
{    checkNotNull(pred, "pred");    return pred.accept(INSTANCE);}
c0a4a3a2ba24ce8eb26c42540bc8a9a82d739a5828c4c39c6b899117c645119b
visit
public boolean visit(ValueInspector p)
{    if (!p.isKnown()) {        p.updateNull();    }    return p.getResult();}
4c5c16db9fbedc5100e3684d6d7a41e757194efe8f353fdc818f37753282b3d5
visit
public boolean visit(And and)
{    return and.getLeft().accept(this) && and.getRight().accept(this);}
266ab5a7f53de9781cd3beea6b2bbda1f7596da11f03256d8f18ff021eaa8bc6
visit
public boolean visit(Or or)
{    return or.getLeft().accept(this) || or.getRight().accept(this);}
4578660d2fd95801144d51445aea98f5414942ebc00459fd3db886a844548a42
reset
public static void reset(IncrementallyUpdatedFilterPredicate pred)
{    checkNotNull(pred, "pred");    pred.accept(INSTANCE);}
c0a4a3a2ba24ce8eb26c42540bc8a9a82d739a5828c4c39c6b899117c645119b
visit
public boolean visit(ValueInspector p)
{    p.reset();    return false;}
4c5c16db9fbedc5100e3684d6d7a41e757194efe8f353fdc818f37753282b3d5
visit
public boolean visit(And and)
{    and.getLeft().accept(this);    and.getRight().accept(this);    return false;}
266ab5a7f53de9781cd3beea6b2bbda1f7596da11f03256d8f18ff021eaa8bc6
visit
public boolean visit(Or or)
{    or.getLeft().accept(this);    or.getRight().accept(this);    return false;}
824c2b83fa6b1e51b9cc89c987535aa95ca31fbbe1eb47d08016e88967f57d23
getMinValueAsBytes
 ByteBuffer getMinValueAsBytes(int pageIndex)
{    return convert(minValues[pageIndex]);}
c0c36f001908f0854faf9be18b4347d4ca8cfbd52e517e414881f3a2de3547a3
getMaxValueAsBytes
 ByteBuffer getMaxValueAsBytes(int pageIndex)
{    return convert(maxValues[pageIndex]);}
466b0cecf1fca0dc50fc06caadc9c6d08eff5b3904d238cd72030b9d4731934d
getMinValueAsString
 String getMinValueAsString(int pageIndex)
{    return stringifier.stringify(minValues[pageIndex]);}
25bab5ca2629a3c12f43af3438df1aed3b78f53b3bfef8d239a96e77671c6ad1
getMaxValueAsString
 String getMaxValueAsString(int pageIndex)
{    return stringifier.stringify(maxValues[pageIndex]);}
dbb47bfa3fc3babcd2c9fc5f9a8f5110c40dfcb253787fcff8290e856e529531
createStats
 Statistics<T> createStats(int arrayIndex)
{    return (Statistics<T>) new Statistics<Binary>(minValues[arrayIndex], maxValues[arrayIndex], comparator);}
b9366c4f329eb4a966a78f329676307669364a6869f719704d65a1612162a5cb
createValueComparator
 ValueComparator createValueComparator(Object value)
{    final Binary v = (Binary) value;    return new ValueComparator() {        @Override        int compareValueToMin(int arrayIndex) {            return comparator.compare(v, minValues[arrayIndex]);        }        @Override        int compareValueToMax(int arrayIndex) {            return comparator.compare(v, maxValues[arrayIndex]);        }    };}
f7f1613a5a9b756d47d040806e393daa82861f5c91f959be8e9bd0d67ccca7e4
compareValueToMin
 int compareValueToMin(int arrayIndex)
{    return comparator.compare(v, minValues[arrayIndex]);}
53bda0d4b3c5362b9a0b6c9323504ee84d319757ab6c7200d75062c650b3b52e
compareValueToMax
 int compareValueToMax(int arrayIndex)
{    return comparator.compare(v, maxValues[arrayIndex]);}
8e220be2c5c48f51db68c92f20f33ae7cb097834fe4830ec8588ad9b59030b65
convert
private static Binary convert(ByteBuffer buffer)
{    return Binary.fromReusedByteBuffer(buffer);}
8a2edb88caaeec252c7c9e258beaac336155cb54def95d8bb6f17cbb487d7366
convert
private static ByteBuffer convert(Binary value)
{    return value.toByteBuffer();}
377701fb57562457e368b02d6ac9d3bea4d844843a16b47f53a0528bcbedc1ab
addMinMaxFromBytes
 void addMinMaxFromBytes(ByteBuffer min, ByteBuffer max)
{    minValues.add(convert(min));    maxValues.add(convert(max));}
78fc636293154ee2c1381862ccf0a91976be78af9cec5ce65aa92c67496e8fcd
addMinMax
 void addMinMax(Object min, Object max)
{    minValues.add(min == null ? null : truncator.truncateMin((Binary) min, truncateLength));    maxValues.add(max == null ? null : truncator.truncateMax((Binary) max, truncateLength));}
3ff80f00deb983408f70b7dc02b321bed3c61ecda40aa682f7e7dd43261b1429
createColumnIndex
 ColumnIndexBase<Binary> createColumnIndex(PrimitiveType type)
{    BinaryColumnIndex columnIndex = new BinaryColumnIndex(type);    columnIndex.minValues = minValues.toArray(new Binary[minValues.size()]);    columnIndex.maxValues = maxValues.toArray(new Binary[maxValues.size()]);    return columnIndex;}
fe4d5e9d733c675cd3b9d16fd2ed50c1af39ab1623f65576a09048d5f092add3
clearMinMax
 void clearMinMax()
{    minValues.clear();    maxValues.clear();}
050f1020e7efba9621022e6951f45c0185e01f4b8fcc17683a61c9da0dc6b360
compareMinValues
 int compareMinValues(PrimitiveComparator<Binary> comparator, int index1, int index2)
{    return comparator.compare(minValues.get(index1), minValues.get(index2));}
068375cf50de0bb1da67d3760e1af00badcc90f7606112c4f54ac42e0e5fe590
compareMaxValues
 int compareMaxValues(PrimitiveComparator<Binary> comparator, int index1, int index2)
{    return comparator.compare(maxValues.get(index1), maxValues.get(index2));}
86c509251b2b5b46817de96adccc2d3bba4c02cf759d03b328949ec3d211f7f9
sizeOf
 int sizeOf(Object value)
{    return ((Binary) value).length();}
92fedbf58e50ae473780b24aa5e8dcf87a0506260a3f635142a1dd27f52550a6
checkValidity
 Validity checkValidity(ByteBuffer buffer)
{    int pos = buffer.position();    CoderResult result = CoderResult.OVERFLOW;    while (result.isOverflow()) {        dummyBuffer.clear();        result = decoder.decode(buffer, dummyBuffer, true);    }    buffer.position(pos);    if (result.isUnderflow()) {        return Validity.VALID;    } else if (result.isMalformed()) {        return Validity.MALFORMED;    } else {        return Validity.UNMAPPABLE;    }}
0f306094986159addd8f6e0470de870a55cc21830be431bba4ae4e969d113021
truncateMin
 Binary truncateMin(Binary minValue, int length)
{    return minValue;}
06f89b141c3b81c8ea74a69e0d13d32921f32c525743b8eed221f830ddc00a09
truncateMax
 Binary truncateMax(Binary maxValue, int length)
{    return maxValue;}
0f306094986159addd8f6e0470de870a55cc21830be431bba4ae4e969d113021
truncateMin
 Binary truncateMin(Binary minValue, int length)
{    if (minValue.length() <= length) {        return minValue;    }    ByteBuffer buffer = minValue.toByteBuffer();    byte[] array;    if (validator.checkValidity(buffer) == Validity.VALID) {        array = truncateUtf8(buffer, length);    } else {        array = truncate(buffer, length);    }    return array == null ? minValue : Binary.fromConstantByteArray(array);}
06f89b141c3b81c8ea74a69e0d13d32921f32c525743b8eed221f830ddc00a09
truncateMax
 Binary truncateMax(Binary maxValue, int length)
{    if (maxValue.length() <= length) {        return maxValue;    }    byte[] array;    ByteBuffer buffer = maxValue.toByteBuffer();    if (validator.checkValidity(buffer) == Validity.VALID) {        array = incrementUtf8(truncateUtf8(buffer, length));    } else {        array = increment(truncate(buffer, length));    }    return array == null ? maxValue : Binary.fromConstantByteArray(array);}
cf7f207a6c4f0b1af39fb5c8a630e5a37d30c6771d7020106c2889d1d9f525a0
truncate
private byte[] truncate(ByteBuffer buffer, int length)
{    assert length < buffer.remaining();    byte[] array = new byte[length];    buffer.get(array);    return array;}
89a41c21beb73b58153b67daa867a18691b80b2c88fd482b200de14403e67532
increment
private byte[] increment(byte[] array)
{    for (int i = array.length - 1; i >= 0; --i) {        byte elem = array[i];        ++elem;        array[i] = elem;        if (elem != 0) {                        return array;        }    }    return null;}
283111d53648227829ed1c52ec77ad379edc87395b32c5ac8098f16f6e0dbc3b
truncateUtf8
private byte[] truncateUtf8(ByteBuffer buffer, int length)
{    assert length < buffer.remaining();    ByteBuffer newBuffer = buffer.slice();    newBuffer.limit(newBuffer.position() + length);    while (validator.checkValidity(newBuffer) != Validity.VALID) {        newBuffer.limit(newBuffer.limit() - 1);        if (newBuffer.remaining() == 0) {            return null;        }    }    byte[] array = new byte[newBuffer.remaining()];    newBuffer.get(array);    return array;}
f828ea2a91c588f5b33e7b4cf76623361a8701924ec4483111353ab86952ce6a
incrementUtf8
private byte[] incrementUtf8(byte[] array)
{    if (array == null) {        return null;    }    ByteBuffer buffer = ByteBuffer.wrap(array);    for (int i = array.length - 1; i >= 0; --i) {        byte prev = array[i];        byte inc = prev;        while (++inc != 0) {                        array[i] = inc;            switch(validator.checkValidity(buffer)) {                case VALID:                    return array;                case UNMAPPABLE:                                        continue;                case MALFORMED:                                        break;            }                        break;        }        array[i] = prev;    }        return null;}
719284f1525ef6677a6757fc5602e88beda7505245c25104487c4691fdb3509c
getTruncator
 static BinaryTruncator getTruncator(PrimitiveType type)
{    if (type == null) {        return NO_OP_TRUNCATOR;    }    switch(type.getPrimitiveTypeName()) {        case INT96:            return NO_OP_TRUNCATOR;        case BINARY:        case FIXED_LEN_BYTE_ARRAY:            LogicalTypeAnnotation logicalTypeAnnotation = type.getLogicalTypeAnnotation();            if (logicalTypeAnnotation == null) {                return DEFAULT_UTF8_TRUNCATOR;            }            return logicalTypeAnnotation.accept(new LogicalTypeAnnotation.LogicalTypeAnnotationVisitor<BinaryTruncator>() {                @Override                public Optional<BinaryTruncator> visit(LogicalTypeAnnotation.StringLogicalTypeAnnotation stringLogicalType) {                    return Optional.of(DEFAULT_UTF8_TRUNCATOR);                }                @Override                public Optional<BinaryTruncator> visit(LogicalTypeAnnotation.EnumLogicalTypeAnnotation enumLogicalType) {                    return Optional.of(DEFAULT_UTF8_TRUNCATOR);                }                @Override                public Optional<BinaryTruncator> visit(LogicalTypeAnnotation.JsonLogicalTypeAnnotation jsonLogicalType) {                    return Optional.of(DEFAULT_UTF8_TRUNCATOR);                }                @Override                public Optional<BinaryTruncator> visit(LogicalTypeAnnotation.BsonLogicalTypeAnnotation bsonLogicalType) {                    return Optional.of(DEFAULT_UTF8_TRUNCATOR);                }            }).orElse(NO_OP_TRUNCATOR);        default:            throw new IllegalArgumentException("No truncator is available for the type: " + type);    }}
3a63ec1146bb44fe3205957a19f0c9fcb909fed78ff45c4c1c0e23c627cd5120
visit
public Optional<BinaryTruncator> visit(LogicalTypeAnnotation.StringLogicalTypeAnnotation stringLogicalType)
{    return Optional.of(DEFAULT_UTF8_TRUNCATOR);}
01c264141c8e390b0562fc65a6e7ecdbe64e3deb395dd62bf35670ea4023342c
visit
public Optional<BinaryTruncator> visit(LogicalTypeAnnotation.EnumLogicalTypeAnnotation enumLogicalType)
{    return Optional.of(DEFAULT_UTF8_TRUNCATOR);}
31312cf0cea71bf024b337b38d31b62d59a6f9a831bfb0d49d6c30bffe5f634b
visit
public Optional<BinaryTruncator> visit(LogicalTypeAnnotation.JsonLogicalTypeAnnotation jsonLogicalType)
{    return Optional.of(DEFAULT_UTF8_TRUNCATOR);}
648526bf471b1df6719c53f07adc6d4702aa74472f67b65a6795294c8cc42b91
visit
public Optional<BinaryTruncator> visit(LogicalTypeAnnotation.BsonLogicalTypeAnnotation bsonLogicalType)
{    return Optional.of(DEFAULT_UTF8_TRUNCATOR);}
824c2b83fa6b1e51b9cc89c987535aa95ca31fbbe1eb47d08016e88967f57d23
getMinValueAsBytes
 ByteBuffer getMinValueAsBytes(int pageIndex)
{    return convert(minValues[pageIndex]);}
c0c36f001908f0854faf9be18b4347d4ca8cfbd52e517e414881f3a2de3547a3
getMaxValueAsBytes
 ByteBuffer getMaxValueAsBytes(int pageIndex)
{    return convert(maxValues[pageIndex]);}
466b0cecf1fca0dc50fc06caadc9c6d08eff5b3904d238cd72030b9d4731934d
getMinValueAsString
 String getMinValueAsString(int pageIndex)
{    return stringifier.stringify(minValues[pageIndex]);}
25bab5ca2629a3c12f43af3438df1aed3b78f53b3bfef8d239a96e77671c6ad1
getMaxValueAsString
 String getMaxValueAsString(int pageIndex)
{    return stringifier.stringify(maxValues[pageIndex]);}
dbb47bfa3fc3babcd2c9fc5f9a8f5110c40dfcb253787fcff8290e856e529531
createStats
 Statistics<T> createStats(int arrayIndex)
{    return (Statistics<T>) new Statistics<Boolean>(minValues[arrayIndex], maxValues[arrayIndex], comparator);}
b9366c4f329eb4a966a78f329676307669364a6869f719704d65a1612162a5cb
createValueComparator
 ValueComparator createValueComparator(Object value)
{    final boolean v = (boolean) value;    return new ValueComparator() {        @Override        int compareValueToMin(int arrayIndex) {            return comparator.compare(v, minValues[arrayIndex]);        }        @Override        int compareValueToMax(int arrayIndex) {            return comparator.compare(v, maxValues[arrayIndex]);        }    };}
f7f1613a5a9b756d47d040806e393daa82861f5c91f959be8e9bd0d67ccca7e4
compareValueToMin
 int compareValueToMin(int arrayIndex)
{    return comparator.compare(v, minValues[arrayIndex]);}
53bda0d4b3c5362b9a0b6c9323504ee84d319757ab6c7200d75062c650b3b52e
compareValueToMax
 int compareValueToMax(int arrayIndex)
{    return comparator.compare(v, maxValues[arrayIndex]);}
fec412e3007e49625ff9de3170451a218794fb1e2c8db5fdd5db31c5d5062466
convert
private static boolean convert(ByteBuffer buffer)
{    return buffer.get(0) != 0;}
4674fb1d36f9e31356df35a64a25a14e04563705f6d2ae14a1d740f0468d0d0e
convert
private static ByteBuffer convert(boolean value)
{    return ByteBuffer.allocate(1).put(0, value ? (byte) 1 : 0);}
377701fb57562457e368b02d6ac9d3bea4d844843a16b47f53a0528bcbedc1ab
addMinMaxFromBytes
 void addMinMaxFromBytes(ByteBuffer min, ByteBuffer max)
{    minValues.add(convert(min));    maxValues.add(convert(max));}
78fc636293154ee2c1381862ccf0a91976be78af9cec5ce65aa92c67496e8fcd
addMinMax
 void addMinMax(Object min, Object max)
{    minValues.add((boolean) min);    maxValues.add((boolean) max);}
871364342161b324e064ba699c89e2afe08c0c3691eca9bfadbe4c0f362bce67
createColumnIndex
 ColumnIndexBase<Boolean> createColumnIndex(PrimitiveType type)
{    BooleanColumnIndex columnIndex = new BooleanColumnIndex(type);    columnIndex.minValues = minValues.toBooleanArray();    columnIndex.maxValues = maxValues.toBooleanArray();    return columnIndex;}
fe4d5e9d733c675cd3b9d16fd2ed50c1af39ab1623f65576a09048d5f092add3
clearMinMax
 void clearMinMax()
{    minValues.clear();    maxValues.clear();}
050f1020e7efba9621022e6951f45c0185e01f4b8fcc17683a61c9da0dc6b360
compareMinValues
 int compareMinValues(PrimitiveComparator<Binary> comparator, int index1, int index2)
{    return comparator.compare(minValues.get(index1), minValues.get(index2));}
068375cf50de0bb1da67d3760e1af00badcc90f7606112c4f54ac42e0e5fe590
compareMaxValues
 int compareMaxValues(PrimitiveComparator<Binary> comparator, int index1, int index2)
{    return comparator.compare(maxValues.get(index1), maxValues.get(index2));}
86c509251b2b5b46817de96adccc2d3bba4c02cf759d03b328949ec3d211f7f9
sizeOf
 int sizeOf(Object value)
{    return 1;}
217946336756e4d57325ebbc4662fae4d164f1ab389fdc07da5d05cbae582603
floorMid
private static int floorMid(int left, int right)
{        return left + ((right - left) / 2);}
e1a907a286a9e1cb025d7cb594349159f6439006423bea62bb4e2b10cf015abe
ceilingMid
private static int ceilingMid(int left, int right)
{        return left + ((right - left + 1) / 2);}
ea4f3b91ab7bb99204ed3079785cba6c091c31f7f92fe530483caf1176db7f88
eq
 PrimitiveIterator.OfInt eq(ColumnIndexBase<?>.ValueComparator comparator)
{    return IndexIterator.filterTranslate(comparator.arrayLength(), arrayIndex -> comparator.compareValueToMin(arrayIndex) >= 0 && comparator.compareValueToMax(arrayIndex) <= 0, comparator::translate);}
fe4949a819e7b20f4f9cc9c46152410fc444dd2ffc8af6874911170bae7865a0
gt
 PrimitiveIterator.OfInt gt(ColumnIndexBase<?>.ValueComparator comparator)
{    return IndexIterator.filterTranslate(comparator.arrayLength(), arrayIndex -> comparator.compareValueToMax(arrayIndex) < 0, comparator::translate);}
d43010105934b3d6c038fa7da1a4741c4399df652cbf209d26996b6f9e3d7401
gtEq
 PrimitiveIterator.OfInt gtEq(ColumnIndexBase<?>.ValueComparator comparator)
{    return IndexIterator.filterTranslate(comparator.arrayLength(), arrayIndex -> comparator.compareValueToMax(arrayIndex) <= 0, comparator::translate);}
1e49bac79b12e9015fbdad320eeb30ea68b07dc58dccc276f24f82b2ddc2bce5
lt
 PrimitiveIterator.OfInt lt(ColumnIndexBase<?>.ValueComparator comparator)
{    return IndexIterator.filterTranslate(comparator.arrayLength(), arrayIndex -> comparator.compareValueToMin(arrayIndex) > 0, comparator::translate);}
d7179a981824156128d65ab79cb05b4dc83d9d35dbb5cec7fe386b4fbce4af80
ltEq
 PrimitiveIterator.OfInt ltEq(ColumnIndexBase<?>.ValueComparator comparator)
{    return IndexIterator.filterTranslate(comparator.arrayLength(), arrayIndex -> comparator.compareValueToMin(arrayIndex) >= 0, comparator::translate);}
3729e62e0125c73e70fbfdd2676c1fc763bac21fc221478ee96123706943cb4b
notEq
 PrimitiveIterator.OfInt notEq(ColumnIndexBase<?>.ValueComparator comparator)
{    return IndexIterator.filterTranslate(comparator.arrayLength(), arrayIndex -> comparator.compareValueToMin(arrayIndex) != 0 || comparator.compareValueToMax(arrayIndex) != 0, comparator::translate);}
b72944df56d18c3dff5b2252d5c5a9d956ceb87b822828e3b26c2125a2190d1e
eq
 OfInt eq(ColumnIndexBase<?>.ValueComparator comparator)
{    Bounds bounds = findBounds(comparator);    if (bounds == null) {        return IndexIterator.EMPTY;    }    return IndexIterator.rangeTranslate(bounds.lower, bounds.upper, comparator::translate);}
f423781d94d53d4452c6a4acb3e37427141ea12a4cb1ac77f8dd10945326f6ec
gt
 OfInt gt(ColumnIndexBase<?>.ValueComparator comparator)
{    int length = comparator.arrayLength();    int left = 0;    int right = length;    do {        int i = floorMid(left, right);        if (comparator.compareValueToMax(i) >= 0) {            left = i + 1;        } else {            right = i;        }    } while (left < right);    return IndexIterator.rangeTranslate(right, length - 1, comparator::translate);}
cc7dcf516e27a5eb78c6736fbc9f4f74377586906a70fc7a7c9bf11398b11373
gtEq
 OfInt gtEq(ColumnIndexBase<?>.ValueComparator comparator)
{    int length = comparator.arrayLength();    int left = 0;    int right = length;    do {        int i = floorMid(left, right);        if (comparator.compareValueToMax(i) > 0) {            left = i + 1;        } else {            right = i;        }    } while (left < right);    return IndexIterator.rangeTranslate(right, length - 1, comparator::translate);}
35d5de7d9d03466e99ccaf39e0c45127cb888a212a2bbde4970c857b095982f3
lt
 OfInt lt(ColumnIndexBase<?>.ValueComparator comparator)
{    int length = comparator.arrayLength();    int left = -1;    int right = length - 1;    do {        int i = ceilingMid(left, right);        if (comparator.compareValueToMin(i) <= 0) {            right = i - 1;        } else {            left = i;        }    } while (left < right);    return IndexIterator.rangeTranslate(0, left, comparator::translate);}
77415bdc746c9b5b0cd3e6d79f8b1d7e53200fec4eb435303452de0eff90fba8
ltEq
 OfInt ltEq(ColumnIndexBase<?>.ValueComparator comparator)
{    int length = comparator.arrayLength();    int left = -1;    int right = length - 1;    do {        int i = ceilingMid(left, right);        if (comparator.compareValueToMin(i) < 0) {            right = i - 1;        } else {            left = i;        }    } while (left < right);    return IndexIterator.rangeTranslate(0, left, comparator::translate);}
68e7ef5449d72c0ee2654f2c59411d83a2f6257fd4ad09344ad7b3718313ae34
notEq
 OfInt notEq(ColumnIndexBase<?>.ValueComparator comparator)
{    Bounds bounds = findBounds(comparator);    int length = comparator.arrayLength();    if (bounds == null) {        return IndexIterator.all(comparator);    }    return IndexIterator.filterTranslate(length, i -> i < bounds.lower || i > bounds.upper || comparator.compareValueToMin(i) != 0 || comparator.compareValueToMax(i) != 0, comparator::translate);}
9defb9b8554c3861fbdceb25088ca267c3d47110f1ce58bafd46002b58970796
findBounds
private Bounds findBounds(ColumnIndexBase<?>.ValueComparator comparator)
{    int length = comparator.arrayLength();    int lowerLeft = 0;    int upperLeft = 0;    int lowerRight = length - 1;    int upperRight = length - 1;    do {        if (lowerLeft > lowerRight) {            return null;        }        int i = floorMid(lowerLeft, lowerRight);        if (comparator.compareValueToMin(i) < 0) {            lowerRight = upperRight = i - 1;        } else if (comparator.compareValueToMax(i) > 0) {            lowerLeft = upperLeft = i + 1;        } else {            lowerRight = upperLeft = i;        }    } while (lowerLeft != lowerRight);    do {        if (upperLeft > upperRight) {            return null;        }        int i = ceilingMid(upperLeft, upperRight);        if (comparator.compareValueToMin(i) < 0) {            upperRight = i - 1;        } else if (comparator.compareValueToMax(i) > 0) {            upperLeft = i + 1;        } else {            upperLeft = i;        }    } while (upperLeft != upperRight);    return new Bounds(lowerLeft, upperRight);}
b72944df56d18c3dff5b2252d5c5a9d956ceb87b822828e3b26c2125a2190d1e
eq
 OfInt eq(ColumnIndexBase<?>.ValueComparator comparator)
{    Bounds bounds = findBounds(comparator);    if (bounds == null) {        return IndexIterator.EMPTY;    }    return IndexIterator.rangeTranslate(bounds.lower, bounds.upper, comparator::translate);}
f423781d94d53d4452c6a4acb3e37427141ea12a4cb1ac77f8dd10945326f6ec
gt
 OfInt gt(ColumnIndexBase<?>.ValueComparator comparator)
{    int length = comparator.arrayLength();    int left = -1;    int right = length - 1;    do {        int i = ceilingMid(left, right);        if (comparator.compareValueToMax(i) >= 0) {            right = i - 1;        } else {            left = i;        }    } while (left < right);    return IndexIterator.rangeTranslate(0, left, comparator::translate);}
cc7dcf516e27a5eb78c6736fbc9f4f74377586906a70fc7a7c9bf11398b11373
gtEq
 OfInt gtEq(ColumnIndexBase<?>.ValueComparator comparator)
{    int length = comparator.arrayLength();    int left = -1;    int right = length - 1;    do {        int i = ceilingMid(left, right);        if (comparator.compareValueToMax(i) > 0) {            right = i - 1;        } else {            left = i;        }    } while (left < right);    return IndexIterator.rangeTranslate(0, left, comparator::translate);}
35d5de7d9d03466e99ccaf39e0c45127cb888a212a2bbde4970c857b095982f3
lt
 OfInt lt(ColumnIndexBase<?>.ValueComparator comparator)
{    int length = comparator.arrayLength();    int left = 0;    int right = length;    do {        int i = floorMid(left, right);        if (comparator.compareValueToMin(i) <= 0) {            left = i + 1;        } else {            right = i;        }    } while (left < right);    return IndexIterator.rangeTranslate(right, length - 1, comparator::translate);}
77415bdc746c9b5b0cd3e6d79f8b1d7e53200fec4eb435303452de0eff90fba8
ltEq
 OfInt ltEq(ColumnIndexBase<?>.ValueComparator comparator)
{    int length = comparator.arrayLength();    int left = 0;    int right = length;    do {        int i = floorMid(left, right);        if (comparator.compareValueToMin(i) < 0) {            left = i + 1;        } else {            right = i;        }    } while (left < right);    return IndexIterator.rangeTranslate(right, length - 1, comparator::translate);}
68e7ef5449d72c0ee2654f2c59411d83a2f6257fd4ad09344ad7b3718313ae34
notEq
 OfInt notEq(ColumnIndexBase<?>.ValueComparator comparator)
{    Bounds bounds = findBounds(comparator);    int length = comparator.arrayLength();    if (bounds == null) {        return IndexIterator.all(comparator);    }    return IndexIterator.filterTranslate(length, i -> i < bounds.lower || i > bounds.upper || comparator.compareValueToMin(i) != 0 || comparator.compareValueToMax(i) != 0, comparator::translate);}
9defb9b8554c3861fbdceb25088ca267c3d47110f1ce58bafd46002b58970796
findBounds
private Bounds findBounds(ColumnIndexBase<?>.ValueComparator comparator)
{    int length = comparator.arrayLength();    int lowerLeft = 0;    int upperLeft = 0;    int lowerRight = length - 1;    int upperRight = length - 1;    do {        if (lowerLeft > lowerRight) {            return null;        }        int i = floorMid(lowerLeft, lowerRight);        if (comparator.compareValueToMax(i) > 0) {            lowerRight = upperRight = i - 1;        } else if (comparator.compareValueToMin(i) < 0) {            lowerLeft = upperLeft = i + 1;        } else {            lowerRight = upperLeft = i;        }    } while (lowerLeft != lowerRight);    do {        if (upperLeft > upperRight) {            return null;        }        int i = ceilingMid(upperLeft, upperRight);        if (comparator.compareValueToMax(i) > 0) {            upperRight = i - 1;        } else if (comparator.compareValueToMin(i) < 0) {            upperLeft = i + 1;        } else {            upperLeft = i;        }    } while (upperLeft != upperRight);    return new Bounds(lowerLeft, upperRight);}
8cf76a482c4011a4192268aebcfbb208b2654bfbfe0119b790f97d3a5a91f929
arrayLength
 int arrayLength()
{    return pageIndexes.length;}
f6887b616bdeca5fd6a6cf32967ec2c07a17b3376bfd11fb9db03153f652e245
translate
 int translate(int arrayIndex)
{    return pageIndexes[arrayIndex];}
18a3d0301450c39c1df5f7f26cf4dfb619778f4676b103626de5831cab475941
truncate
 static String truncate(String str)
{    if (str.length() <= MAX_VALUE_LENGTH_FOR_TOSTRING) {        return str;    }    return str.substring(0, TOSTRING_TRUNCATION_START_POS) + TOSTRING_TRUNCATION_MARKER + str.substring(str.length() - TOSTRING_TRUNCATION_END_POS);}
015efef19b115633eeb8b0dd582eb80e717963f7ea5dea32ae22a3cf5b435fcf
getBoundaryOrder
public BoundaryOrder getBoundaryOrder()
{    return boundaryOrder;}
b92b3b82e82fe0e55787be617c3f1168ef57312c6e21affbc44597596829d2c8
getNullCounts
public List<Long> getNullCounts()
{    if (nullCounts == null) {        return null;    }    return LongLists.unmodifiable(LongArrayList.wrap(nullCounts));}
75d1bbe0924e6db4676397664e25422e22b3e584deae4f58afcaa01d25378862
getNullPages
public List<Boolean> getNullPages()
{    return BooleanLists.unmodifiable(BooleanArrayList.wrap(nullPages));}
86a4526a8ba9756aac34319157ada1faed24baa89045eae269692e1628461d6c
getMinValues
public List<ByteBuffer> getMinValues()
{    List<ByteBuffer> list = new ArrayList<>(getPageCount());    int arrayIndex = 0;    for (int i = 0, n = getPageCount(); i < n; ++i) {        if (isNullPage(i)) {            list.add(EMPTY_BYTE_BUFFER);        } else {            list.add(getMinValueAsBytes(arrayIndex++));        }    }    return list;}
121a20bcaffecada1888396c9280933b369203d01bb3a585026a8011d3ba7976
getMaxValues
public List<ByteBuffer> getMaxValues()
{    List<ByteBuffer> list = new ArrayList<>(getPageCount());    int arrayIndex = 0;    for (int i = 0, n = getPageCount(); i < n; ++i) {        if (isNullPage(i)) {            list.add(EMPTY_BYTE_BUFFER);        } else {            list.add(getMaxValueAsBytes(arrayIndex++));        }    }    return list;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    try (Formatter formatter = new Formatter()) {        formatter.format("Boudary order: %s\n", boundaryOrder);        String minMaxPart = "  %-" + MAX_VALUE_LENGTH_FOR_TOSTRING + "s  %-" + MAX_VALUE_LENGTH_FOR_TOSTRING + "s\n";        formatter.format("%-10s  %20s" + minMaxPart, "", "null count", "min", "max");        String format = "page-%-5d  %20s" + minMaxPart;        int arrayIndex = 0;        for (int i = 0, n = nullPages.length; i < n; ++i) {            String nullCount = nullCounts == null ? TOSTRING_MISSING_VALUE_MARKER : Long.toString(nullCounts[i]);            String min, max;            if (nullPages[i]) {                min = max = TOSTRING_MISSING_VALUE_MARKER;            } else {                min = truncate(getMinValueAsString(arrayIndex));                max = truncate(getMaxValueAsString(arrayIndex++));            }            formatter.format(format, i, nullCount, min, max);        }        return formatter.toString();    }}
67809f164bc10e8b8c5c62739664665dac6f717e93dbce72381ab4110ed78cbf
getPageCount
 int getPageCount()
{    return nullPages.length;}
c1c8e67dbd0ccf9b74c93e036dc193e7c24a5de9f3621d8bab02bb331c9d9452
isNullPage
 boolean isNullPage(int pageIndex)
{    return nullPages[pageIndex];}
419b54fa218a36ef6f2a2ea8af15eeadf084ceed434c23475809f348390692ea
visit
public PrimitiveIterator.OfInt visit(And and)
{    throw new UnsupportedOperationException("AND shall not be used on column index directly");}
8afc58ec9a8d86bafc2801471d350029026c977beca7dca8258f3fc98daa4f26
visit
public PrimitiveIterator.OfInt visit(Not not)
{    throw new UnsupportedOperationException("NOT shall not be used on column index directly");}
b891b4c86a750349552bab352e734d4b00f7505dec0f35021813c3475abee1a2
visit
public PrimitiveIterator.OfInt visit(Or or)
{    throw new UnsupportedOperationException("OR shall not be used on column index directly");}
88568669796d9240398027dd1ec00e142189eedaf53e1157003defe20cfcd174
visit
public PrimitiveIterator.OfInt visit(Eq<T> eq)
{    T value = eq.getValue();    if (value == null) {        if (nullCounts == null) {                        return IndexIterator.all(getPageCount());        } else {            return IndexIterator.filter(getPageCount(), pageIndex -> nullCounts[pageIndex] > 0);        }    }    return getBoundaryOrder().eq(createValueComparator(value));}
f4c3a3c44701257858e0f1a8d655d986b33de2c30d7b1df1360be4fe8913b215
visit
public PrimitiveIterator.OfInt visit(Gt<T> gt)
{    return getBoundaryOrder().gt(createValueComparator(gt.getValue()));}
23d6fd732ba428fdda568c325bf7f9285eb940be5ea742d7e64e6251c9242039
visit
public PrimitiveIterator.OfInt visit(GtEq<T> gtEq)
{    return getBoundaryOrder().gtEq(createValueComparator(gtEq.getValue()));}
c27b78b6b99b241e1af21974f03c2651ef6ba36bace70af8bab93d0db741ea00
visit
public PrimitiveIterator.OfInt visit(Lt<T> lt)
{    return getBoundaryOrder().lt(createValueComparator(lt.getValue()));}
1a146963cfd88a14dfdef1366f8bae5f28ce8ed40c08ce13597d026553c37703
visit
public PrimitiveIterator.OfInt visit(LtEq<T> ltEq)
{    return getBoundaryOrder().ltEq(createValueComparator(ltEq.getValue()));}
826dd01e2c7d10c55b383364245527b321694b58c8d290fd2ddf17f8749e5434
visit
public PrimitiveIterator.OfInt visit(NotEq<T> notEq)
{    T value = notEq.getValue();    if (value == null) {        return IndexIterator.filter(getPageCount(), pageIndex -> !nullPages[pageIndex]);    }    if (nullCounts == null) {                return IndexIterator.all(getPageCount());    }        IntSet matchingIndexes = new IntOpenHashSet();    getBoundaryOrder().notEq(createValueComparator(value)).forEachRemaining((int index) -> matchingIndexes.add(index));    return IndexIterator.filter(getPageCount(), pageIndex -> nullCounts[pageIndex] > 0 || matchingIndexes.contains(pageIndex));}
c9fba07ef583275b7628e059ed04dc420a8827755b5f8f2f00d9fc5535b5c911
visit
public PrimitiveIterator.OfInt visit(UserDefined<T, U> udp)
{    final UserDefinedPredicate<T> predicate = udp.getUserDefinedPredicate();    final boolean acceptNulls = predicate.acceptsNullValue();    if (acceptNulls && nullCounts == null) {                return IndexIterator.all(getPageCount());    }    return IndexIterator.filter(getPageCount(), new IntPredicate() {        private int arrayIndex = -1;        @Override        public boolean test(int pageIndex) {            if (isNullPage(pageIndex)) {                return acceptNulls;            } else {                ++arrayIndex;                if (acceptNulls && nullCounts[pageIndex] > 0) {                    return true;                }                org.apache.parquet.filter2.predicate.Statistics<T> stats = createStats(arrayIndex);                return !predicate.canDrop(stats);            }        }    });}
fd5f0c4c5b5c40c47126a27a6c784a6be06de1e8f134c1fa0bdb5c9ec842a88d
test
public boolean test(int pageIndex)
{    if (isNullPage(pageIndex)) {        return acceptNulls;    } else {        ++arrayIndex;        if (acceptNulls && nullCounts[pageIndex] > 0) {            return true;        }        org.apache.parquet.filter2.predicate.Statistics<T> stats = createStats(arrayIndex);        return !predicate.canDrop(stats);    }}
2fa1c8cf9d722340af27c996336072e96c713daf10cf285c5b98173a966b6c7b
visit
public PrimitiveIterator.OfInt visit(LogicalNotUserDefined<T, U> udp)
{    final UserDefinedPredicate<T> inversePredicate = udp.getUserDefined().getUserDefinedPredicate();    final boolean acceptNulls = !inversePredicate.acceptsNullValue();    if (acceptNulls && nullCounts == null) {                return IndexIterator.all(getPageCount());    }    return IndexIterator.filter(getPageCount(), new IntPredicate() {        private int arrayIndex = -1;        @Override        public boolean test(int pageIndex) {            if (isNullPage(pageIndex)) {                return acceptNulls;            } else {                ++arrayIndex;                if (acceptNulls && nullCounts[pageIndex] > 0) {                    return true;                }                org.apache.parquet.filter2.predicate.Statistics<T> stats = createStats(arrayIndex);                return !inversePredicate.inverseCanDrop(stats);            }        }    });}
fd5f0c4c5b5c40c47126a27a6c784a6be06de1e8f134c1fa0bdb5c9ec842a88d
test
public boolean test(int pageIndex)
{    if (isNullPage(pageIndex)) {        return acceptNulls;    } else {        ++arrayIndex;        if (acceptNulls && nullCounts[pageIndex] > 0) {            return true;        }        org.apache.parquet.filter2.predicate.Statistics<T> stats = createStats(arrayIndex);        return !inversePredicate.inverseCanDrop(stats);    }}
2ca881af358eb43d9f355a85b0567085d1f208d17b1598e31d3b75a1f88bbdcc
build
public ColumnIndex build()
{    return null;}
71c890d22d562fc9fcab778891fbe813b61d3f20e5dcbfc5133bc36b0cb939c5
add
public void add(Statistics<?> stats)
{}
78fc636293154ee2c1381862ccf0a91976be78af9cec5ce65aa92c67496e8fcd
addMinMax
 void addMinMax(Object min, Object max)
{}
7366d814b49757ef093dbab97fbe5c78fcef08f333a26cc388000ed9fff0a7a9
createColumnIndex
 ColumnIndexBase<?> createColumnIndex(PrimitiveType type)
{    return null;}
fe4d5e9d733c675cd3b9d16fd2ed50c1af39ab1623f65576a09048d5f092add3
clearMinMax
 void clearMinMax()
{}
377701fb57562457e368b02d6ac9d3bea4d844843a16b47f53a0528bcbedc1ab
addMinMaxFromBytes
 void addMinMaxFromBytes(ByteBuffer min, ByteBuffer max)
{}
050f1020e7efba9621022e6951f45c0185e01f4b8fcc17683a61c9da0dc6b360
compareMinValues
 int compareMinValues(PrimitiveComparator<Binary> comparator, int index1, int index2)
{    return 0;}
068375cf50de0bb1da67d3760e1af00badcc90f7606112c4f54ac42e0e5fe590
compareMaxValues
 int compareMaxValues(PrimitiveComparator<Binary> comparator, int index1, int index2)
{    return 0;}
86c509251b2b5b46817de96adccc2d3bba4c02cf759d03b328949ec3d211f7f9
sizeOf
 int sizeOf(Object value)
{    return 0;}
fba661c8392de81a7e0a62a95e75aae27ae50b92697fab97d1c00173aa9f4b04
getNoOpBuilder
public static ColumnIndexBuilder getNoOpBuilder()
{    return NO_OP_BUILDER;}
af5fc517d15be1bf86e42cf5fe9db63b942735a4e293bd3406f260e1bdae404b
getBuilder
public static ColumnIndexBuilder getBuilder(PrimitiveType type, int truncateLength)
{    ColumnIndexBuilder builder = createNewBuilder(type, truncateLength);    builder.type = type;    return builder;}
a7bb1f69c67ebc4367a3d59a32ac3f6540d25b49ec7a466fd7e1e2608d26f9b1
createNewBuilder
private static ColumnIndexBuilder createNewBuilder(PrimitiveType type, int truncateLength)
{    switch(type.getPrimitiveTypeName()) {        case BINARY:        case FIXED_LEN_BYTE_ARRAY:        case INT96:            return new BinaryColumnIndexBuilder(type, truncateLength);        case BOOLEAN:            return new BooleanColumnIndexBuilder();        case DOUBLE:            return new DoubleColumnIndexBuilder();        case FLOAT:            return new FloatColumnIndexBuilder();        case INT32:            return new IntColumnIndexBuilder();        case INT64:            return new LongColumnIndexBuilder();        default:            throw new IllegalArgumentException("Unsupported type for column index: " + type);    }}
681bf1c5a1cc5efcff82147e840d05324b24b72fbbc3a424f8e5bd0e60342854
build
public static ColumnIndex build(PrimitiveType type, BoundaryOrder boundaryOrder, List<Boolean> nullPages, List<Long> nullCounts, List<ByteBuffer> minValues, List<ByteBuffer> maxValues)
{    ColumnIndexBuilder builder = createNewBuilder(type, Integer.MAX_VALUE);    builder.fill(nullPages, nullCounts, minValues, maxValues);    ColumnIndexBase<?> columnIndex = builder.build(type);    columnIndex.boundaryOrder = requireNonNull(boundaryOrder);    return columnIndex;}
71c890d22d562fc9fcab778891fbe813b61d3f20e5dcbfc5133bc36b0cb939c5
add
public void add(Statistics<?> stats)
{    if (stats.hasNonNullValue()) {        nullPages.add(false);        Object min = stats.genericGetMin();        Object max = stats.genericGetMax();        addMinMax(min, max);        pageIndexes.add(nextPageIndex);        minMaxSize += sizeOf(min);        minMaxSize += sizeOf(max);    } else {        nullPages.add(true);    }    nullCounts.add(stats.getNumNulls());    ++nextPageIndex;}
d27de21057e445f1105c4e9dcf8276752fc2565a193d97940fa630929bd77c2c
fill
private void fill(List<Boolean> nullPages, List<Long> nullCounts, List<ByteBuffer> minValues, List<ByteBuffer> maxValues)
{    clear();    int pageCount = nullPages.size();    if ((nullCounts != null && nullCounts.size() != pageCount) || minValues.size() != pageCount || maxValues.size() != pageCount) {        throw new IllegalArgumentException(String.format("Not all sizes are equal (nullPages:%d, nullCounts:%s, minValues:%d, maxValues:%d", nullPages.size(), nullCounts == null ? "null" : nullCounts.size(), minValues.size(), maxValues.size()));    }    this.nullPages.addAll(nullPages);        if (nullCounts != null) {        this.nullCounts.addAll(nullCounts);    }    for (int i = 0; i < pageCount; ++i) {        if (!nullPages.get(i)) {            ByteBuffer min = minValues.get(i);            ByteBuffer max = maxValues.get(i);            addMinMaxFromBytes(min, max);            pageIndexes.add(i);            minMaxSize += min.remaining();            minMaxSize += max.remaining();        }    }}
2ca881af358eb43d9f355a85b0567085d1f208d17b1598e31d3b75a1f88bbdcc
build
public ColumnIndex build()
{    ColumnIndexBase<?> columnIndex = build(type);    if (columnIndex == null) {        return null;    }    columnIndex.boundaryOrder = calculateBoundaryOrder(type.comparator());    return columnIndex;}
0717d66c7aa214fa12d24aca254dd9eef1d4cb3ee8a076344449316670c2573a
build
private ColumnIndexBase<?> build(PrimitiveType type)
{    if (nullPages.isEmpty()) {        return null;    }    ColumnIndexBase<?> columnIndex = createColumnIndex(type);    if (columnIndex == null) {                return null;    }    columnIndex.nullPages = nullPages.toBooleanArray();        if (!nullCounts.isEmpty()) {        columnIndex.nullCounts = nullCounts.toLongArray();    }    columnIndex.pageIndexes = pageIndexes.toIntArray();    return columnIndex;}
77fe6af747d02d4cd843ea82938e53326594f263d43baa86d302d5e826f3bde7
calculateBoundaryOrder
private BoundaryOrder calculateBoundaryOrder(PrimitiveComparator<Binary> comparator)
{    if (isAscending(comparator)) {        return BoundaryOrder.ASCENDING;    } else if (isDescending(comparator)) {        return BoundaryOrder.DESCENDING;    } else {        return BoundaryOrder.UNORDERED;    }}
b9213899bd4b1232683ac937f40152fc89d87ea353647b52c4291c8827958693
isAscending
private boolean isAscending(PrimitiveComparator<Binary> comparator)
{    for (int i = 1, n = pageIndexes.size(); i < n; ++i) {        if (compareMinValues(comparator, i - 1, i) > 0 || compareMaxValues(comparator, i - 1, i) > 0) {            return false;        }    }    return true;}
765ad305b0bd58c158f5af4cd7edb6a6b0671e6f5a7373930a703ad4847c3968
isDescending
private boolean isDescending(PrimitiveComparator<Binary> comparator)
{    for (int i = 1, n = pageIndexes.size(); i < n; ++i) {        if (compareMinValues(comparator, i - 1, i) < 0 || compareMaxValues(comparator, i - 1, i) < 0) {            return false;        }    }    return true;}
b3e79869c74977c719c14b7eabf310dd0a6e88ee53d46bbcceb8b8839243798e
clear
private void clear()
{    nullPages.clear();    nullCounts.clear();    clearMinMax();    minMaxSize = 0;    nextPageIndex = 0;    pageIndexes.clear();}
6e0494c1557afad1c50045b01e6e6e5185f541d78e0c3325387bf572d4b6c90c
getPageCount
public int getPageCount()
{    return nullPages.size();}
303bbb40ca71bef40a2ecf6916c51ac6c26d9368df891f221f9ac2078df6315e
getMinMaxSize
public long getMinMaxSize()
{    return minMaxSize;}
824c2b83fa6b1e51b9cc89c987535aa95ca31fbbe1eb47d08016e88967f57d23
getMinValueAsBytes
 ByteBuffer getMinValueAsBytes(int pageIndex)
{    return convert(minValues[pageIndex]);}
c0c36f001908f0854faf9be18b4347d4ca8cfbd52e517e414881f3a2de3547a3
getMaxValueAsBytes
 ByteBuffer getMaxValueAsBytes(int pageIndex)
{    return convert(maxValues[pageIndex]);}
466b0cecf1fca0dc50fc06caadc9c6d08eff5b3904d238cd72030b9d4731934d
getMinValueAsString
 String getMinValueAsString(int pageIndex)
{    return stringifier.stringify(minValues[pageIndex]);}
25bab5ca2629a3c12f43af3438df1aed3b78f53b3bfef8d239a96e77671c6ad1
getMaxValueAsString
 String getMaxValueAsString(int pageIndex)
{    return stringifier.stringify(maxValues[pageIndex]);}
dbb47bfa3fc3babcd2c9fc5f9a8f5110c40dfcb253787fcff8290e856e529531
createStats
 Statistics<T> createStats(int arrayIndex)
{    return (Statistics<T>) new Statistics<Double>(minValues[arrayIndex], maxValues[arrayIndex], comparator);}
b9366c4f329eb4a966a78f329676307669364a6869f719704d65a1612162a5cb
createValueComparator
 ValueComparator createValueComparator(Object value)
{    final double v = (double) value;    return new ValueComparator() {        @Override        int compareValueToMin(int arrayIndex) {            return comparator.compare(v, minValues[arrayIndex]);        }        @Override        int compareValueToMax(int arrayIndex) {            return comparator.compare(v, maxValues[arrayIndex]);        }    };}
f7f1613a5a9b756d47d040806e393daa82861f5c91f959be8e9bd0d67ccca7e4
compareValueToMin
 int compareValueToMin(int arrayIndex)
{    return comparator.compare(v, minValues[arrayIndex]);}
53bda0d4b3c5362b9a0b6c9323504ee84d319757ab6c7200d75062c650b3b52e
compareValueToMax
 int compareValueToMax(int arrayIndex)
{    return comparator.compare(v, maxValues[arrayIndex]);}
709a5ba36305c7e8ea8ead2cf780d7eff5f4490d0fcb1e1b6d4c367e0f9e65fe
convert
private static double convert(ByteBuffer buffer)
{    return buffer.order(LITTLE_ENDIAN).getDouble(0);}
970c7b8e3840627598a73f480fcb07fa1ef7115faeac1f557f3c6a2ea7212d29
convert
private static ByteBuffer convert(double value)
{    return ByteBuffer.allocate(Double.BYTES).order(LITTLE_ENDIAN).putDouble(0, value);}
377701fb57562457e368b02d6ac9d3bea4d844843a16b47f53a0528bcbedc1ab
addMinMaxFromBytes
 void addMinMaxFromBytes(ByteBuffer min, ByteBuffer max)
{    minValues.add(convert(min));    maxValues.add(convert(max));}
78fc636293154ee2c1381862ccf0a91976be78af9cec5ce65aa92c67496e8fcd
addMinMax
 void addMinMax(Object min, Object max)
{    double dMin = (double) min;    double dMax = (double) max;    if (Double.isNaN(dMin) || Double.isNaN(dMax)) {                invalid = true;    }        if (Double.compare(dMin, +0.0) == 0) {        dMin = -0.0;    }    if (Double.compare(dMax, -0.0) == 0) {        dMax = +0.0;    }    minValues.add(dMin);    maxValues.add(dMax);}
b9ceec302303e4ed7f79dbdb24b53800f46b2a9548568ad4861fc807baedbfc9
createColumnIndex
 ColumnIndexBase<Double> createColumnIndex(PrimitiveType type)
{    if (invalid) {        return null;    }    DoubleColumnIndex columnIndex = new DoubleColumnIndex(type);    columnIndex.minValues = minValues.toDoubleArray();    columnIndex.maxValues = maxValues.toDoubleArray();    return columnIndex;}
fe4d5e9d733c675cd3b9d16fd2ed50c1af39ab1623f65576a09048d5f092add3
clearMinMax
 void clearMinMax()
{    minValues.clear();    maxValues.clear();}
050f1020e7efba9621022e6951f45c0185e01f4b8fcc17683a61c9da0dc6b360
compareMinValues
 int compareMinValues(PrimitiveComparator<Binary> comparator, int index1, int index2)
{    return comparator.compare(minValues.get(index1), minValues.get(index2));}
068375cf50de0bb1da67d3760e1af00badcc90f7606112c4f54ac42e0e5fe590
compareMaxValues
 int compareMaxValues(PrimitiveComparator<Binary> comparator, int index1, int index2)
{    return comparator.compare(maxValues.get(index1), maxValues.get(index2));}
86c509251b2b5b46817de96adccc2d3bba4c02cf759d03b328949ec3d211f7f9
sizeOf
 int sizeOf(Object value)
{    return Double.BYTES;}
824c2b83fa6b1e51b9cc89c987535aa95ca31fbbe1eb47d08016e88967f57d23
getMinValueAsBytes
 ByteBuffer getMinValueAsBytes(int pageIndex)
{    return convert(minValues[pageIndex]);}
c0c36f001908f0854faf9be18b4347d4ca8cfbd52e517e414881f3a2de3547a3
getMaxValueAsBytes
 ByteBuffer getMaxValueAsBytes(int pageIndex)
{    return convert(maxValues[pageIndex]);}
466b0cecf1fca0dc50fc06caadc9c6d08eff5b3904d238cd72030b9d4731934d
getMinValueAsString
 String getMinValueAsString(int pageIndex)
{    return stringifier.stringify(minValues[pageIndex]);}
25bab5ca2629a3c12f43af3438df1aed3b78f53b3bfef8d239a96e77671c6ad1
getMaxValueAsString
 String getMaxValueAsString(int pageIndex)
{    return stringifier.stringify(maxValues[pageIndex]);}
dbb47bfa3fc3babcd2c9fc5f9a8f5110c40dfcb253787fcff8290e856e529531
createStats
 Statistics<T> createStats(int arrayIndex)
{    return (Statistics<T>) new Statistics<Float>(minValues[arrayIndex], maxValues[arrayIndex], comparator);}
b9366c4f329eb4a966a78f329676307669364a6869f719704d65a1612162a5cb
createValueComparator
 ValueComparator createValueComparator(Object value)
{    final float v = (float) value;    return new ValueComparator() {        @Override        int compareValueToMin(int arrayIndex) {            return comparator.compare(v, minValues[arrayIndex]);        }        @Override        int compareValueToMax(int arrayIndex) {            return comparator.compare(v, maxValues[arrayIndex]);        }    };}
f7f1613a5a9b756d47d040806e393daa82861f5c91f959be8e9bd0d67ccca7e4
compareValueToMin
 int compareValueToMin(int arrayIndex)
{    return comparator.compare(v, minValues[arrayIndex]);}
53bda0d4b3c5362b9a0b6c9323504ee84d319757ab6c7200d75062c650b3b52e
compareValueToMax
 int compareValueToMax(int arrayIndex)
{    return comparator.compare(v, maxValues[arrayIndex]);}
789685fee610dcd93197bd2333c7763bd3df19f2106cdf5ffe774e46c69e4d80
convert
private static float convert(ByteBuffer buffer)
{    return buffer.order(LITTLE_ENDIAN).getFloat(0);}
0105f65a552a9b97062dccc79b5f40d85185c5331003c811e116c30f5e28d8cc
convert
private static ByteBuffer convert(float value)
{    return ByteBuffer.allocate(Float.BYTES).order(LITTLE_ENDIAN).putFloat(0, value);}
377701fb57562457e368b02d6ac9d3bea4d844843a16b47f53a0528bcbedc1ab
addMinMaxFromBytes
 void addMinMaxFromBytes(ByteBuffer min, ByteBuffer max)
{    minValues.add(convert(min));    maxValues.add(convert(max));}
78fc636293154ee2c1381862ccf0a91976be78af9cec5ce65aa92c67496e8fcd
addMinMax
 void addMinMax(Object min, Object max)
{    float fMin = (float) min;    float fMax = (float) max;    if (Float.isNaN(fMin) || Float.isNaN(fMax)) {                invalid = true;    }        if (Float.compare(fMin, +0.0f) == 0) {        fMin = -0.0f;    }    if (Float.compare(fMax, -0.0f) == 0) {        fMax = +0.0f;    }    minValues.add(fMin);    maxValues.add(fMax);}
d0bfce4f0543305c2966d9c18d80bf14c46e777302678a7b2374207bad465869
createColumnIndex
 ColumnIndexBase<Float> createColumnIndex(PrimitiveType type)
{    if (invalid) {        return null;    }    FloatColumnIndex columnIndex = new FloatColumnIndex(type);    columnIndex.minValues = minValues.toFloatArray();    columnIndex.maxValues = maxValues.toFloatArray();    return columnIndex;}
fe4d5e9d733c675cd3b9d16fd2ed50c1af39ab1623f65576a09048d5f092add3
clearMinMax
 void clearMinMax()
{    minValues.clear();    maxValues.clear();}
050f1020e7efba9621022e6951f45c0185e01f4b8fcc17683a61c9da0dc6b360
compareMinValues
 int compareMinValues(PrimitiveComparator<Binary> comparator, int index1, int index2)
{    return comparator.compare(minValues.get(index1), minValues.get(index2));}
068375cf50de0bb1da67d3760e1af00badcc90f7606112c4f54ac42e0e5fe590
compareMaxValues
 int compareMaxValues(PrimitiveComparator<Binary> comparator, int index1, int index2)
{    return comparator.compare(maxValues.get(index1), maxValues.get(index2));}
86c509251b2b5b46817de96adccc2d3bba4c02cf759d03b328949ec3d211f7f9
sizeOf
 int sizeOf(Object value)
{    return Float.BYTES;}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return false;}
fdad8c53e4cb93ac9606cf0b9361af34b8b3fd5bb4f6e88ad403d16c89019543
nextInt
public int nextInt()
{    throw new NoSuchElementException();}
a9638ab52f163d1a9659139b5fc316d0f57f554b776dc8975c313c565a597adf
all
 static PrimitiveIterator.OfInt all(int pageCount)
{    return new IndexIterator(0, pageCount, i -> true, i -> i);}
4b7989d1dc97036f20b03e98d11796569a2c8bd8ec61d735a3c271128e71101e
all
 static PrimitiveIterator.OfInt all(ColumnIndexBase<?>.ValueComparator comparator)
{    return new IndexIterator(0, comparator.arrayLength(), i -> true, comparator::translate);}
ae2acadc870b6adb07d32b3c800c87a346e9d861fa1676e26a080354d581e0a8
filter
 static PrimitiveIterator.OfInt filter(int pageCount, IntPredicate filter)
{    return new IndexIterator(0, pageCount, filter, i -> i);}
e24adce056c63cfa90d2ee807fb9786551d619e34d8d95fc26be07d0f4c517ea
filterTranslate
 static PrimitiveIterator.OfInt filterTranslate(int arrayLength, IntPredicate filter, IntUnaryOperator translator)
{    return new IndexIterator(0, arrayLength, filter, translator);}
94e5344e73aa1bf91083ba6cc61809bdaeacfae1b2735abfb44b8eb9876e8ea8
rangeTranslate
 static PrimitiveIterator.OfInt rangeTranslate(int from, int to, IntUnaryOperator translator)
{    return new IndexIterator(from, to + 1, i -> true, translator);}
88c97d6b2d8abacc6ecffb4e3bdf88e1870ea546400f66721e1739a2d3b64ba0
nextPageIndex
private int nextPageIndex(int startIndex)
{    for (int i = startIndex; i < endIndex; ++i) {        if (filter.test(i)) {            return i;        }    }    return -1;}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return index >= 0;}
fdad8c53e4cb93ac9606cf0b9361af34b8b3fd5bb4f6e88ad403d16c89019543
nextInt
public int nextInt()
{    if (hasNext()) {        int ret = index;        index = nextPageIndex(index + 1);        return translator.applyAsInt(ret);    }    throw new NoSuchElementException();}
824c2b83fa6b1e51b9cc89c987535aa95ca31fbbe1eb47d08016e88967f57d23
getMinValueAsBytes
 ByteBuffer getMinValueAsBytes(int pageIndex)
{    return convert(minValues[pageIndex]);}
c0c36f001908f0854faf9be18b4347d4ca8cfbd52e517e414881f3a2de3547a3
getMaxValueAsBytes
 ByteBuffer getMaxValueAsBytes(int pageIndex)
{    return convert(maxValues[pageIndex]);}
466b0cecf1fca0dc50fc06caadc9c6d08eff5b3904d238cd72030b9d4731934d
getMinValueAsString
 String getMinValueAsString(int pageIndex)
{    return stringifier.stringify(minValues[pageIndex]);}
25bab5ca2629a3c12f43af3438df1aed3b78f53b3bfef8d239a96e77671c6ad1
getMaxValueAsString
 String getMaxValueAsString(int pageIndex)
{    return stringifier.stringify(maxValues[pageIndex]);}
dbb47bfa3fc3babcd2c9fc5f9a8f5110c40dfcb253787fcff8290e856e529531
createStats
 Statistics<T> createStats(int arrayIndex)
{    return (Statistics<T>) new Statistics<Integer>(minValues[arrayIndex], maxValues[arrayIndex], comparator);}
b9366c4f329eb4a966a78f329676307669364a6869f719704d65a1612162a5cb
createValueComparator
 ValueComparator createValueComparator(Object value)
{    final int v = (int) value;    return new ValueComparator() {        @Override        int compareValueToMin(int arrayIndex) {            return comparator.compare(v, minValues[arrayIndex]);        }        @Override        int compareValueToMax(int arrayIndex) {            return comparator.compare(v, maxValues[arrayIndex]);        }    };}
f7f1613a5a9b756d47d040806e393daa82861f5c91f959be8e9bd0d67ccca7e4
compareValueToMin
 int compareValueToMin(int arrayIndex)
{    return comparator.compare(v, minValues[arrayIndex]);}
53bda0d4b3c5362b9a0b6c9323504ee84d319757ab6c7200d75062c650b3b52e
compareValueToMax
 int compareValueToMax(int arrayIndex)
{    return comparator.compare(v, maxValues[arrayIndex]);}
8a51335969fb060bff90fc649a459a0c127d766460bb48431dbe0d6585f3163e
convert
private static int convert(ByteBuffer buffer)
{    return buffer.order(LITTLE_ENDIAN).getInt(0);}
75e33d5a8c4af4271fec53398aa9da59c88a5480676aa0b217cafac39e461f16
convert
private static ByteBuffer convert(int value)
{    return ByteBuffer.allocate(Integer.BYTES).order(LITTLE_ENDIAN).putInt(0, value);}
377701fb57562457e368b02d6ac9d3bea4d844843a16b47f53a0528bcbedc1ab
addMinMaxFromBytes
 void addMinMaxFromBytes(ByteBuffer min, ByteBuffer max)
{    minValues.add(convert(min));    maxValues.add(convert(max));}
78fc636293154ee2c1381862ccf0a91976be78af9cec5ce65aa92c67496e8fcd
addMinMax
 void addMinMax(Object min, Object max)
{    minValues.add((int) min);    maxValues.add((int) max);}
e1371bdc218fb731bdc125eb2ae3266e7be9ec270fc2875d1f225dc9e3ab8cfd
createColumnIndex
 ColumnIndexBase<Integer> createColumnIndex(PrimitiveType type)
{    IntColumnIndex columnIndex = new IntColumnIndex(type);    columnIndex.minValues = minValues.toIntArray();    columnIndex.maxValues = maxValues.toIntArray();    return columnIndex;}
fe4d5e9d733c675cd3b9d16fd2ed50c1af39ab1623f65576a09048d5f092add3
clearMinMax
 void clearMinMax()
{    minValues.clear();    maxValues.clear();}
050f1020e7efba9621022e6951f45c0185e01f4b8fcc17683a61c9da0dc6b360
compareMinValues
 int compareMinValues(PrimitiveComparator<Binary> comparator, int index1, int index2)
{    return comparator.compare(minValues.get(index1), minValues.get(index2));}
068375cf50de0bb1da67d3760e1af00badcc90f7606112c4f54ac42e0e5fe590
compareMaxValues
 int compareMaxValues(PrimitiveComparator<Binary> comparator, int index1, int index2)
{    return comparator.compare(maxValues.get(index1), maxValues.get(index2));}
86c509251b2b5b46817de96adccc2d3bba4c02cf759d03b328949ec3d211f7f9
sizeOf
 int sizeOf(Object value)
{    return Integer.BYTES;}
824c2b83fa6b1e51b9cc89c987535aa95ca31fbbe1eb47d08016e88967f57d23
getMinValueAsBytes
 ByteBuffer getMinValueAsBytes(int pageIndex)
{    return convert(minValues[pageIndex]);}
c0c36f001908f0854faf9be18b4347d4ca8cfbd52e517e414881f3a2de3547a3
getMaxValueAsBytes
 ByteBuffer getMaxValueAsBytes(int pageIndex)
{    return convert(maxValues[pageIndex]);}
466b0cecf1fca0dc50fc06caadc9c6d08eff5b3904d238cd72030b9d4731934d
getMinValueAsString
 String getMinValueAsString(int pageIndex)
{    return stringifier.stringify(minValues[pageIndex]);}
25bab5ca2629a3c12f43af3438df1aed3b78f53b3bfef8d239a96e77671c6ad1
getMaxValueAsString
 String getMaxValueAsString(int pageIndex)
{    return stringifier.stringify(maxValues[pageIndex]);}
dbb47bfa3fc3babcd2c9fc5f9a8f5110c40dfcb253787fcff8290e856e529531
createStats
 Statistics<T> createStats(int arrayIndex)
{    return (Statistics<T>) new Statistics<Long>(minValues[arrayIndex], maxValues[arrayIndex], comparator);}
b9366c4f329eb4a966a78f329676307669364a6869f719704d65a1612162a5cb
createValueComparator
 ValueComparator createValueComparator(Object value)
{    final long v = (long) value;    return new ValueComparator() {        @Override        int compareValueToMin(int arrayIndex) {            return comparator.compare(v, minValues[arrayIndex]);        }        @Override        int compareValueToMax(int arrayIndex) {            return comparator.compare(v, maxValues[arrayIndex]);        }    };}
f7f1613a5a9b756d47d040806e393daa82861f5c91f959be8e9bd0d67ccca7e4
compareValueToMin
 int compareValueToMin(int arrayIndex)
{    return comparator.compare(v, minValues[arrayIndex]);}
53bda0d4b3c5362b9a0b6c9323504ee84d319757ab6c7200d75062c650b3b52e
compareValueToMax
 int compareValueToMax(int arrayIndex)
{    return comparator.compare(v, maxValues[arrayIndex]);}
4d7128d59b33edef39efc0be393fa3356cfbf9a5422a418f8a18324aaa2fce0a
convert
private static long convert(ByteBuffer buffer)
{    return buffer.order(LITTLE_ENDIAN).getLong(0);}
a3864272a139852355a116eb350b9363adfa63e80384078584f1ccfac2c45943
convert
private static ByteBuffer convert(long value)
{    return ByteBuffer.allocate(Long.BYTES).order(LITTLE_ENDIAN).putLong(0, value);}
377701fb57562457e368b02d6ac9d3bea4d844843a16b47f53a0528bcbedc1ab
addMinMaxFromBytes
 void addMinMaxFromBytes(ByteBuffer min, ByteBuffer max)
{    minValues.add(convert(min));    maxValues.add(convert(max));}
78fc636293154ee2c1381862ccf0a91976be78af9cec5ce65aa92c67496e8fcd
addMinMax
 void addMinMax(Object min, Object max)
{    minValues.add((long) min);    maxValues.add((long) max);}
2811cab00dece26e356a4402f9fd401d463c3304fda2409cf52df0eac9d899ea
createColumnIndex
 ColumnIndexBase<Long> createColumnIndex(PrimitiveType type)
{    LongColumnIndex columnIndex = new LongColumnIndex(type);    columnIndex.minValues = minValues.toLongArray();    columnIndex.maxValues = maxValues.toLongArray();    return columnIndex;}
fe4d5e9d733c675cd3b9d16fd2ed50c1af39ab1623f65576a09048d5f092add3
clearMinMax
 void clearMinMax()
{    minValues.clear();    maxValues.clear();}
050f1020e7efba9621022e6951f45c0185e01f4b8fcc17683a61c9da0dc6b360
compareMinValues
 int compareMinValues(PrimitiveComparator<Binary> comparator, int index1, int index2)
{    return comparator.compare(minValues.get(index1), minValues.get(index2));}
068375cf50de0bb1da67d3760e1af00badcc90f7606112c4f54ac42e0e5fe590
compareMaxValues
 int compareMaxValues(PrimitiveComparator<Binary> comparator, int index1, int index2)
{    return comparator.compare(maxValues.get(index1), maxValues.get(index2));}
86c509251b2b5b46817de96adccc2d3bba4c02cf759d03b328949ec3d211f7f9
sizeOf
 int sizeOf(Object value)
{    return Long.BYTES;}
5e9ff972fc4ce428d54e742bbdccaf675fd5f0bf00c119fe70da8c357da12a24
getLastRowIndex
public long getLastRowIndex(int pageIndex, long rowGroupRowCount)
{    int nextPageIndex = pageIndex + 1;    return (nextPageIndex >= getPageCount() ? rowGroupRowCount : getFirstRowIndex(nextPageIndex)) - 1;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    try (Formatter formatter = new Formatter()) {        formatter.format("%-10s  %20s  %16s  %20s\n", "", "offset", "compressed size", "first row index");        for (int i = 0, n = offsets.length; i < n; ++i) {            formatter.format("page-%-5d  %20d  %16d  %20d\n", i, offsets[i], compressedPageSizes[i], firstRowIndexes[i]);        }        return formatter.toString();    }}
6e0494c1557afad1c50045b01e6e6e5185f541d78e0c3325387bf572d4b6c90c
getPageCount
public int getPageCount()
{    return offsets.length;}
91b7d33d27aa553842f84b87c8bb8d2a2db45dfe426c7b0e968cf71617c750da
getOffset
public long getOffset(int pageIndex)
{    return offsets[pageIndex];}
c23a85cdce0a6a62b73c30026554f81704999c625bd65684ad67c5414d4b17a9
getCompressedPageSize
public int getCompressedPageSize(int pageIndex)
{    return compressedPageSizes[pageIndex];}
2be9fde157325d17c973f350ff7e74ca384485421f5a7fff047acf1a30b5ed9a
getFirstRowIndex
public long getFirstRowIndex(int pageIndex)
{    return firstRowIndexes[pageIndex];}
63848ec3457792bc3bb700483edd4294924a589e287f20a83b8e4d47af79a408
add
public void add(int compressedPageSize, long rowCount)
{}
ba85bad4e5ed1e728de78922f3d6a452ee3db91681815d1bded6aca99ce99e11
add
public void add(long offset, int compressedPageSize, long rowCount)
{}
70a90da962b202fedb2a89e0f241298f57f83fa243eaedc14227d2ff9cfad56b
getNoOpBuilder
public static OffsetIndexBuilder getNoOpBuilder()
{    return NO_OP_BUILDER;}
1aa32e005866b38a25420e5ab0a3debce0511fa4f7c4f482373a6bc1aaf144c1
getBuilder
public static OffsetIndexBuilder getBuilder()
{    return new OffsetIndexBuilder();}
63848ec3457792bc3bb700483edd4294924a589e287f20a83b8e4d47af79a408
add
public void add(int compressedPageSize, long rowCount)
{    add(previousOffset + previousPageSize, compressedPageSize, previousRowIndex + previousRowCount);    previousRowCount = rowCount;}
c9720f19c19cd0b53ae40ed1b4e403d926de7d0eefee82d104fca28e720f7933
add
public void add(long offset, int compressedPageSize, long firstRowIndex)
{    previousOffset = offset;    offsets.add(offset);    previousPageSize = compressedPageSize;    compressedPageSizes.add(compressedPageSize);    previousRowIndex = firstRowIndex;    firstRowIndexes.add(firstRowIndex);}
23295126124930d1265619383dd8bbd847df8de21bedfd0beff3edbfc283b8ec
build
public OffsetIndex build()
{    return build(0);}
02e4afa4507fc4108be14caed18f9dc0bb8d508f4fe5076726763bdd078008a4
build
public OffsetIndex build(long firstPageOffset)
{    if (compressedPageSizes.isEmpty()) {        return null;    }    long[] offsets = this.offsets.toLongArray();    if (firstPageOffset != 0) {        for (int i = 0, n = offsets.length; i < n; ++i) {            offsets[i] += firstPageOffset;        }    }    OffsetIndexImpl offsetIndex = new OffsetIndexImpl();    offsetIndex.offsets = offsets;    offsetIndex.compressedPageSizes = compressedPageSizes.toIntArray();    offsetIndex.firstRowIndexes = firstRowIndexes.toLongArray();    return offsetIndex;}
9c6fd5346eb6293da34b338eb3468791e04457302f880e4cfc820768d4230bf4
calculateRowRanges
public static RowRanges calculateRowRanges(FilterCompat.Filter filter, ColumnIndexStore columnIndexStore, Set<ColumnPath> paths, long rowCount)
{    return filter.accept(new FilterCompat.Visitor<RowRanges>() {        @Override        public RowRanges visit(FilterPredicateCompat filterPredicateCompat) {            try {                return filterPredicateCompat.getFilterPredicate().accept(new ColumnIndexFilter(columnIndexStore, paths, rowCount));            } catch (MissingOffsetIndexException e) {                LOGGER.info(e.getMessage());                return RowRanges.createSingle(rowCount);            }        }        @Override        public RowRanges visit(UnboundRecordFilterCompat unboundRecordFilterCompat) {            return RowRanges.createSingle(rowCount);        }        @Override        public RowRanges visit(NoOpFilter noOpFilter) {            return RowRanges.createSingle(rowCount);        }    });}
30736442a46656b9db4cf6e56b9b52b77b0f3641ff2375de4bb81dc7a054cb6a
visit
public RowRanges visit(FilterPredicateCompat filterPredicateCompat)
{    try {        return filterPredicateCompat.getFilterPredicate().accept(new ColumnIndexFilter(columnIndexStore, paths, rowCount));    } catch (MissingOffsetIndexException e) {        LOGGER.info(e.getMessage());        return RowRanges.createSingle(rowCount);    }}
c22249ccd23749730f9f5c9d871aaaa93c9edf6f647bb1975f6e842b842ed606
visit
public RowRanges visit(UnboundRecordFilterCompat unboundRecordFilterCompat)
{    return RowRanges.createSingle(rowCount);}
e24f288c3b528cd792d5c134198389cdd78d8a0fe27aca4f4464a9722251f785
visit
public RowRanges visit(NoOpFilter noOpFilter)
{    return RowRanges.createSingle(rowCount);}
83442cd3dab0519e9920ea583687466e1c17aadefe7554b228d81ed8ae4dbc18
allRows
private RowRanges allRows()
{    if (allRows == null) {        allRows = RowRanges.createSingle(rowCount);    }    return allRows;}
8600ba3d3ed3e137abeb7820bea9bb9c1fbbaaf6998e29118b696fbf4b73103d
visit
public RowRanges visit(Eq<T> eq)
{    return applyPredicate(eq.getColumn(), ci -> ci.visit(eq), eq.getValue() == null ? allRows() : RowRanges.EMPTY);}
2df7953d01d0683abb526c7fb93fcd393daaac7e7d2c62fd842e3b30c0cf3295
visit
public RowRanges visit(NotEq<T> notEq)
{    return applyPredicate(notEq.getColumn(), ci -> ci.visit(notEq), notEq.getValue() == null ? RowRanges.EMPTY : allRows());}
ac68dd3df5fa805e4572346e77d0b0143b632703481f31d5ae46485d5e055b28
visit
public RowRanges visit(Lt<T> lt)
{    return applyPredicate(lt.getColumn(), ci -> ci.visit(lt), RowRanges.EMPTY);}
d4e2edd524cad5068d8afb3f0705cc3c4da49036ca4fc9349251bb2cbe4acda7
visit
public RowRanges visit(LtEq<T> ltEq)
{    return applyPredicate(ltEq.getColumn(), ci -> ci.visit(ltEq), RowRanges.EMPTY);}
1d264612bf2bfae004e1e18bcfb3d03017e3d2b5075b129225b61cab6e467763
visit
public RowRanges visit(Gt<T> gt)
{    return applyPredicate(gt.getColumn(), ci -> ci.visit(gt), RowRanges.EMPTY);}
f5b352812262b82976a458c426ff04a4d338666ed385025a4dd7f46331ca134a
visit
public RowRanges visit(GtEq<T> gtEq)
{    return applyPredicate(gtEq.getColumn(), ci -> ci.visit(gtEq), RowRanges.EMPTY);}
b9a45567aea27c08b994f50e389d9075bb99397cfb5a167191930ceabef8a5c7
visit
public RowRanges visit(UserDefined<T, U> udp)
{    return applyPredicate(udp.getColumn(), ci -> ci.visit(udp), udp.getUserDefinedPredicate().acceptsNullValue() ? allRows() : RowRanges.EMPTY);}
8e88354480ea93108ef129b449da08fe4129ba49267e7c01caba12df508ea70d
visit
public RowRanges visit(LogicalNotUserDefined<T, U> udp)
{    return applyPredicate(udp.getUserDefined().getColumn(), ci -> ci.visit(udp), udp.getUserDefined().getUserDefinedPredicate().acceptsNullValue() ? RowRanges.EMPTY : allRows());}
323d6143e7ceaa9da17449bc5e88206daa1e6059eac706e45f6cbbffb76a4050
applyPredicate
private RowRanges applyPredicate(Column<?> column, Function<ColumnIndex, PrimitiveIterator.OfInt> func, RowRanges rangesForMissingColumns)
{    ColumnPath columnPath = column.getColumnPath();    if (!columns.contains(columnPath)) {        return rangesForMissingColumns;    }    OffsetIndex oi = columnIndexStore.getOffsetIndex(columnPath);    ColumnIndex ci = columnIndexStore.getColumnIndex(columnPath);    if (ci == null) {        LOGGER.info("No column index for column {} is available; Unable to filter on this column", columnPath);        return allRows();    }    return RowRanges.create(rowCount, func.apply(ci), oi);}
e61f98311e9287563fea70add7c5a0218a65a5e204f37f4cdb4375b4a02f3c4e
visit
public RowRanges visit(And and)
{    return RowRanges.intersection(and.getLeft().accept(this), and.getRight().accept(this));}
d23de0fa80a06de751fa2d0741f4edcaafd9df29a5e6e4ea27d35f77292179b9
visit
public RowRanges visit(Or or)
{    return RowRanges.union(or.getLeft().accept(this), or.getRight().accept(this));}
26c5c603f7a4689325b49dbd0250000cfd3e5b419b1cef53c7909d12a0bae1fd
visit
public RowRanges visit(Not not)
{    throw new IllegalArgumentException("Predicates containing a NOT must be run through LogicalInverseRewriter. " + not);}
103d1b0771914bc9f07eaf312677576375ddcbf645ea9435db2e792417546e13
union
private static Range union(Range left, Range right)
{    if (left.from <= right.from) {        if (left.to + 1 >= right.from) {            return new Range(left.from, Math.max(left.to, right.to));        }    } else if (right.to + 1 >= left.from) {        return new Range(right.from, Math.max(left.to, right.to));    }    return null;}
ab8c4af796485e42e7bef1fd1d03dcfbe7c2117b9705f569957db72850522734
intersection
private static Range intersection(Range left, Range right)
{    if (left.from <= right.from) {        if (left.to >= right.from) {            return new Range(right.from, Math.min(left.to, right.to));        }    } else if (right.to >= left.from) {        return new Range(left.from, Math.min(left.to, right.to));    }    return null;}
29759036e87e702b2038cc6480a013b3b95308c3114787380bde4367ce08e741
count
 long count()
{    return to - from + 1;}
684c01463dd2bbf19fbebf483d5682344289669d44a458f77fe548306d17fb85
isBefore
 boolean isBefore(Range other)
{    return to < other.from;}
3062a2e51aa53c5c491095bbeaa6961a4b2c6974c0166cee1bbeedf0e51bda7b
isAfter
 boolean isAfter(Range other)
{    return from > other.to;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "[" + from + ", " + to + ']';}
f872693343cc5a1ac55ca9db94d1e8398cd0ef4d609bcf00f651d83bc74911b4
createSingle
 static RowRanges createSingle(long rowCount)
{    RowRanges ranges = new RowRanges();    ranges.add(new Range(0, rowCount - 1));    return ranges;}
55b9c57c07b148e9af9b422db12cc9477ea7b6501461b91da2d2bd0ce4524d12
create
 static RowRanges create(long rowCount, PrimitiveIterator.OfInt pageIndexes, OffsetIndex offsetIndex)
{    RowRanges ranges = new RowRanges();    while (pageIndexes.hasNext()) {        int pageIndex = pageIndexes.nextInt();        ranges.add(new Range(offsetIndex.getFirstRowIndex(pageIndex), offsetIndex.getLastRowIndex(pageIndex, rowCount)));    }    return ranges;}
9ddc1a0a4816ee21d2506bf92dc617935f20abb888c5233a588d901789f1c6a3
union
 static RowRanges union(RowRanges left, RowRanges right)
{    RowRanges result = new RowRanges();    Iterator<Range> it1 = left.ranges.iterator();    Iterator<Range> it2 = right.ranges.iterator();    if (it2.hasNext()) {        Range range2 = it2.next();        while (it1.hasNext()) {            Range range1 = it1.next();            if (range1.isAfter(range2)) {                result.add(range2);                range2 = range1;                Iterator<Range> tmp = it1;                it1 = it2;                it2 = tmp;            } else {                result.add(range1);            }        }        result.add(range2);    } else {        it2 = it1;    }    while (it2.hasNext()) {        result.add(it2.next());    }    return result;}
5f0acc3a3222ae8f6b7eaec820c93dba26d9c0a96baeb99319759b9101ab2025
intersection
 static RowRanges intersection(RowRanges left, RowRanges right)
{    RowRanges result = new RowRanges();    int rightIndex = 0;    for (Range l : left.ranges) {        for (int i = rightIndex, n = right.ranges.size(); i < n; ++i) {            Range r = right.ranges.get(i);            if (l.isBefore(r)) {                break;            } else if (l.isAfter(r)) {                rightIndex = i + 1;                continue;            }            result.add(Range.intersection(l, r));        }    }    return result;}
89327302a52c26b253d874379097c3960f5bed96c4c0a1cbb6cee97b8b872fd5
add
private void add(Range range)
{    Range rangeToAdd = range;    for (int i = ranges.size() - 1; i >= 0; --i) {        Range last = ranges.get(i);        assert !last.isAfter(range);        Range u = Range.union(last, rangeToAdd);        if (u == null) {            break;        }        rangeToAdd = u;        ranges.remove(i);    }    ranges.add(rangeToAdd);}
0a5bef6327d77ee04cff6327dab7ba65830e0d4ee496be11ec68bbb4c8dc39e1
rowCount
public long rowCount()
{    long cnt = 0;    for (Range range : ranges) {        cnt += range.count();    }    return cnt;}
cbeeeafaf34c7ab5d174a45d35c0a2f8c27bd1b4b73c69fb45b3c000815af690
iterator
public PrimitiveIterator.OfLong iterator()
{    return new PrimitiveIterator.OfLong() {        private int currentRangeIndex = -1;        private Range currentRange;        private long next = findNext();        private long findNext() {            if (currentRange == null || next + 1 > currentRange.to) {                if (currentRangeIndex + 1 < ranges.size()) {                    currentRange = ranges.get(++currentRangeIndex);                    next = currentRange.from;                } else {                    return -1;                }            } else {                ++next;            }            return next;        }        @Override        public boolean hasNext() {            return next >= 0;        }        @Override        public long nextLong() {            long ret = next;            if (ret < 0) {                throw new NoSuchElementException();            }            next = findNext();            return ret;        }    };}
36b2cca0b99e6a365eea8dbb13b6604c1517a615f46f6a303491d21e70da14d0
findNext
private long findNext()
{    if (currentRange == null || next + 1 > currentRange.to) {        if (currentRangeIndex + 1 < ranges.size()) {            currentRange = ranges.get(++currentRangeIndex);            next = currentRange.from;        } else {            return -1;        }    } else {        ++next;    }    return next;}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return next >= 0;}
c07ff43a11a0fd30355c754b084700be1eadeb6e7293cc052804e1ca4dba70c9
nextLong
public long nextLong()
{    long ret = next;    if (ret < 0) {        throw new NoSuchElementException();    }    next = findNext();    return ret;}
ea9eb9f32f4bad171112723f75e731262ab968aa24e8f52876bbe002ce53009a
isOverlapping
public boolean isOverlapping(long from, long to)
{    return Collections.binarySearch(ranges, new Range(from, to), (r1, r2) -> r1.isBefore(r2) ? -1 : r1.isAfter(r2) ? 1 : 0) >= 0;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return ranges.toString();}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (obj == null) {        return false;    }    if (obj instanceof Binary) {        return equals((Binary) obj);    }    return false;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "Binary{" + length() + (isBackingBytesReused ? " reused" : " constant") + " bytes, " + Arrays.toString(getBytesUnsafe()) + "}";}
de4871a67ac55ffcb38c33f766e52a0170ee1c4006f1ffdaf3e16caea3d5ac47
copy
public Binary copy()
{    if (isBackingBytesReused) {        return Binary.fromConstantByteArray(getBytes());    } else {        return this;    }}
dcb8e81b9de453f96c35ac46202cb0ccb5afe77b6e5f9f49c2da1a7749f6e467
isBackingBytesReused
public boolean isBackingBytesReused()
{    return isBackingBytesReused;}
7e6edc113e869966dd53fa7643f6db4ee8a9442ddffb37900db36485a7152238
toStringUsingUTF8
public String toStringUsingUTF8()
{        return StandardCharsets.UTF_8.decode(ByteBuffer.wrap(value, offset, length)).toString();}
1d1ebdb99c526da23d9a06ed6c089d39abc457289b7aff9cbe5f58a377b283b2
length
public int length()
{    return length;}
7dc6be4554c74a17fd17d70feb1dc3c6f61c5fa8dae9c84dbc82b8c7a8ae9a29
writeTo
public void writeTo(OutputStream out) throws IOException
{    out.write(value, offset, length);}
c159a0fb57e2ba9a7fb373b47eabbc552079ef89a4a50bbca7903b879542d25a
getBytes
public byte[] getBytes()
{    return Arrays.copyOfRange(value, offset, offset + length);}
67bec6ca7ec026cc3351c7d0f8ced5cd7ac27b76de4c74ed885fc53939cb34ad
getBytesUnsafe
public byte[] getBytesUnsafe()
{        return getBytes();}
ea46adb58e3684414ebb7963e972a668f30ace6f0fb3c300453382a1444f4114
slice
public Binary slice(int start, int length)
{    if (isBackingBytesReused) {        return Binary.fromReusedByteArray(value, offset + start, length);    } else {        return Binary.fromConstantByteArray(value, offset + start, length);    }}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return Binary.hashCode(value, offset, length);}
b685a4d30a48716bdcfaeb2f8631339b0e3a8e877f6aa120073b3e68ad8b138c
equals
 boolean equals(Binary other)
{    return other.equals(value, offset, length);}
b89e152cb579c9e055be762fe2a199f7a94bc63170738cfe182142d1c0b66ff4
equals
 boolean equals(byte[] other, int otherOffset, int otherLength)
{    return Binary.equals(value, offset, length, other, otherOffset, otherLength);}
070025d4a07b61badd8ac4d21604e0c0226ff47557f02ea0d49f2ed3d49a2ae3
equals
 boolean equals(ByteBuffer bytes, int otherOffset, int otherLength)
{    return Binary.equals(value, offset, length, bytes, otherOffset, otherLength);}
bd0c4c8fcd3b3d61a325a9f4b8a66b3c805eb3eb20080ef808c1b7df8bfc8b44
compareTo
public int compareTo(Binary other)
{    return PrimitiveComparator.UNSIGNED_LEXICOGRAPHICAL_BINARY_COMPARATOR.compare(this, other);}
ead687f9007d16fe8de2c376f5517d30f8d6937095c5cc7805e37f274364bba4
toByteBuffer
public ByteBuffer toByteBuffer()
{    return ByteBuffer.wrap(value, offset, length);}
7887f82b27857d0e9fe624a1d6709954d5c6d82d8e2dd4c1a1a821de70bd129b
writeTo
public void writeTo(DataOutput out) throws IOException
{    out.write(value, offset, length);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "Binary{\"" + toStringUsingUTF8() + "\"}";}
73ccee6d201b6c0b12bbdc21f75903b96fd5adbc41db389d642158ea2c2db4a3
encodeUTF8
private static ByteBuffer encodeUTF8(String value)
{    return ByteBuffer.wrap(value.getBytes(StandardCharsets.UTF_8));}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "Binary{\"" + toStringUsingUTF8() + "\"}";}
6dac62144a58c0d357f96738d43a8c01c7b222b2e917d3ae9f8f4c917c780c74
encodeUTF8
private static ByteBuffer encodeUTF8(CharSequence value)
{    try {        return ENCODER.get().encode(CharBuffer.wrap(value));    } catch (CharacterCodingException e) {        throw new ParquetEncodingException("UTF-8 not supported.", e);    }}
5b976880bdb0762f8d5882311a21b5e580a112973bba923da9da0477b2f34f0c
fromReusedByteArray
public static Binary fromReusedByteArray(final byte[] value, final int offset, final int length)
{    return new ByteArraySliceBackedBinary(value, offset, length, true);}
1f0e0a5c2b785069a0f7c2786224fe1df3dbdef561469e0823c44c5b3db5a71b
fromConstantByteArray
public static Binary fromConstantByteArray(final byte[] value, final int offset, final int length)
{    return new ByteArraySliceBackedBinary(value, offset, length, false);}
3007a92d850fc23ed3390e1920dd5a0e0c0e21eb178c2c6c0e8cf44dc0dbd05c
fromByteArray
public static Binary fromByteArray(final byte[] value, final int offset, final int length)
{        return fromReusedByteArray(value, offset, length);}
7e6edc113e869966dd53fa7643f6db4ee8a9442ddffb37900db36485a7152238
toStringUsingUTF8
public String toStringUsingUTF8()
{    return StandardCharsets.UTF_8.decode(ByteBuffer.wrap(value)).toString();}
1d1ebdb99c526da23d9a06ed6c089d39abc457289b7aff9cbe5f58a377b283b2
length
public int length()
{    return value.length;}
7dc6be4554c74a17fd17d70feb1dc3c6f61c5fa8dae9c84dbc82b8c7a8ae9a29
writeTo
public void writeTo(OutputStream out) throws IOException
{    out.write(value);}
c159a0fb57e2ba9a7fb373b47eabbc552079ef89a4a50bbca7903b879542d25a
getBytes
public byte[] getBytes()
{    return Arrays.copyOfRange(value, 0, value.length);}
67bec6ca7ec026cc3351c7d0f8ced5cd7ac27b76de4c74ed885fc53939cb34ad
getBytesUnsafe
public byte[] getBytesUnsafe()
{    return value;}
ea46adb58e3684414ebb7963e972a668f30ace6f0fb3c300453382a1444f4114
slice
public Binary slice(int start, int length)
{    if (isBackingBytesReused) {        return Binary.fromReusedByteArray(value, start, length);    } else {        return Binary.fromConstantByteArray(value, start, length);    }}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return Binary.hashCode(value, 0, value.length);}
b685a4d30a48716bdcfaeb2f8631339b0e3a8e877f6aa120073b3e68ad8b138c
equals
 boolean equals(Binary other)
{    return other.equals(value, 0, value.length);}
b89e152cb579c9e055be762fe2a199f7a94bc63170738cfe182142d1c0b66ff4
equals
 boolean equals(byte[] other, int otherOffset, int otherLength)
{    return Binary.equals(value, 0, value.length, other, otherOffset, otherLength);}
070025d4a07b61badd8ac4d21604e0c0226ff47557f02ea0d49f2ed3d49a2ae3
equals
 boolean equals(ByteBuffer bytes, int otherOffset, int otherLength)
{    return Binary.equals(value, 0, value.length, bytes, otherOffset, otherLength);}
bd0c4c8fcd3b3d61a325a9f4b8a66b3c805eb3eb20080ef808c1b7df8bfc8b44
compareTo
public int compareTo(Binary other)
{    return PrimitiveComparator.UNSIGNED_LEXICOGRAPHICAL_BINARY_COMPARATOR.compare(this, other);}
ead687f9007d16fe8de2c376f5517d30f8d6937095c5cc7805e37f274364bba4
toByteBuffer
public ByteBuffer toByteBuffer()
{    return ByteBuffer.wrap(value);}
7887f82b27857d0e9fe624a1d6709954d5c6d82d8e2dd4c1a1a821de70bd129b
writeTo
public void writeTo(DataOutput out) throws IOException
{    out.write(value);}
466c4e7770bcc228e4292568b63429491a584d2cc2f2e790deb3fb9e3b0d04d1
fromReusedByteArray
public static Binary fromReusedByteArray(final byte[] value)
{    return new ByteArrayBackedBinary(value, true);}
daa928334b25ca54387fb5d2eb3855f50726a29a96b5c88f339c0160c3e16317
fromConstantByteArray
public static Binary fromConstantByteArray(final byte[] value)
{    return new ByteArrayBackedBinary(value, false);}
55e5c08c8ef8a1bead6e40e182ea314feeac157bdb703b93e158cb223fc2884f
fromByteArray
public static Binary fromByteArray(final byte[] value)
{        return fromReusedByteArray(value);}
7e6edc113e869966dd53fa7643f6db4ee8a9442ddffb37900db36485a7152238
toStringUsingUTF8
public String toStringUsingUTF8()
{    String ret;    if (value.hasArray()) {        ret = new String(value.array(), value.arrayOffset() + offset, length, StandardCharsets.UTF_8);    } else {        int limit = value.limit();        value.limit(offset + length);        int position = value.position();        value.position(offset);                                ret = StandardCharsets.UTF_8.decode(value).toString();        value.limit(limit);        value.position(position);    }    return ret;}
1d1ebdb99c526da23d9a06ed6c089d39abc457289b7aff9cbe5f58a377b283b2
length
public int length()
{    return length;}
7dc6be4554c74a17fd17d70feb1dc3c6f61c5fa8dae9c84dbc82b8c7a8ae9a29
writeTo
public void writeTo(OutputStream out) throws IOException
{    if (value.hasArray()) {        out.write(value.array(), value.arrayOffset() + offset, length);    } else {        out.write(getBytesUnsafe(), 0, length);    }}
c159a0fb57e2ba9a7fb373b47eabbc552079ef89a4a50bbca7903b879542d25a
getBytes
public byte[] getBytes()
{    byte[] bytes = new byte[length];    int limit = value.limit();    value.limit(offset + length);    int position = value.position();    value.position(offset);    value.get(bytes);    value.limit(limit);    value.position(position);    if (!isBackingBytesReused) {                cachedBytes = bytes;    }    return bytes;}
67bec6ca7ec026cc3351c7d0f8ced5cd7ac27b76de4c74ed885fc53939cb34ad
getBytesUnsafe
public byte[] getBytesUnsafe()
{    return cachedBytes != null ? cachedBytes : getBytes();}
ea46adb58e3684414ebb7963e972a668f30ace6f0fb3c300453382a1444f4114
slice
public Binary slice(int start, int length)
{    return Binary.fromConstantByteArray(getBytesUnsafe(), start, length);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    if (value.hasArray()) {        return Binary.hashCode(value.array(), value.arrayOffset() + offset, length);    } else {        return Binary.hashCode(value, offset, length);    }}
b685a4d30a48716bdcfaeb2f8631339b0e3a8e877f6aa120073b3e68ad8b138c
equals
 boolean equals(Binary other)
{    if (value.hasArray()) {        return other.equals(value.array(), value.arrayOffset() + offset, length);    } else {        return other.equals(value, offset, length);    }}
b89e152cb579c9e055be762fe2a199f7a94bc63170738cfe182142d1c0b66ff4
equals
 boolean equals(byte[] other, int otherOffset, int otherLength)
{    if (value.hasArray()) {        return Binary.equals(value.array(), value.arrayOffset() + offset, length, other, otherOffset, otherLength);    } else {        return Binary.equals(other, otherOffset, otherLength, value, offset, length);    }}
aa062346e5d708d401d2f3fdf1fb9b100a09f2f98c621d3ecb73540011fdaefd
equals
 boolean equals(ByteBuffer otherBytes, int otherOffset, int otherLength)
{    return Binary.equals(value, 0, length, otherBytes, otherOffset, otherLength);}
bd0c4c8fcd3b3d61a325a9f4b8a66b3c805eb3eb20080ef808c1b7df8bfc8b44
compareTo
public int compareTo(Binary other)
{    return PrimitiveComparator.UNSIGNED_LEXICOGRAPHICAL_BINARY_COMPARATOR.compare(this, other);}
ead687f9007d16fe8de2c376f5517d30f8d6937095c5cc7805e37f274364bba4
toByteBuffer
public ByteBuffer toByteBuffer()
{    ByteBuffer ret = value.duplicate();    ret.position(offset);    ret.limit(offset + length);    return ret;}
7887f82b27857d0e9fe624a1d6709954d5c6d82d8e2dd4c1a1a821de70bd129b
writeTo
public void writeTo(DataOutput out) throws IOException
{        out.write(getBytesUnsafe());}
b227bba1913203777451ec88ec7b9d154f36c5dd06ad5ec6e48200cbb13d6c09
writeObject
private void writeObject(java.io.ObjectOutputStream out) throws IOException
{    byte[] bytes = getBytesUnsafe();    out.writeInt(bytes.length);    out.write(bytes);}
7ef2dfa4d3f9da40dbae587aec03f8b1c632854ed60c8f230f2ee88aee81cc34
readObject
private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException
{    int length = in.readInt();    byte[] bytes = new byte[length];    in.readFully(bytes, 0, length);    this.value = ByteBuffer.wrap(bytes);    this.offset = 0;    this.length = length;}
c5d50ba22277f1faa64d0a72cb075331e0c7cd409177b4ccfe77a122f72c6e17
readObjectNoData
private void readObjectNoData() throws ObjectStreamException
{    this.value = ByteBuffer.wrap(new byte[0]);}
681bd60854f0f3d30d1d83a1bf2b44a3de7633f893f7fea638ea7c561dcdf544
fromReusedByteBuffer
public static Binary fromReusedByteBuffer(final ByteBuffer value, int offset, int length)
{    return new ByteBufferBackedBinary(value, offset, length, true);}
94dea2bc9359d01344fd874861bac5f7870aa2b861a625b7aca24d2f55e3f5ef
fromConstantByteBuffer
public static Binary fromConstantByteBuffer(final ByteBuffer value, int offset, int length)
{    return new ByteBufferBackedBinary(value, offset, length, false);}
7c70d54955436f74bd14adf95bf353c8f4acf389d091d99d3f6dd7aa78da2b1f
fromReusedByteBuffer
public static Binary fromReusedByteBuffer(final ByteBuffer value)
{    return new ByteBufferBackedBinary(value, true);}
db5effa183eb414cb321605b8e4922e82542395bfa627e93eb546f61655971a8
fromConstantByteBuffer
public static Binary fromConstantByteBuffer(final ByteBuffer value)
{    return new ByteBufferBackedBinary(value, false);}
954da36c82f5bc87014791725c7a3587559f36ef7ffc39587ef10065716c9aeb
fromByteBuffer
public static Binary fromByteBuffer(final ByteBuffer value)
{        return fromReusedByteBuffer(value);}
31d72da4c0a8396a1aaf7799ddd637feabc965ede38df1800507923d573af268
fromString
public static Binary fromString(String value)
{    return new FromStringBinary(value);}
b8fd685fe879fbe1e36998871f4e21a68e4428c5bd69d3cd9ffe08753d4b5067
fromCharSequence
public static Binary fromCharSequence(CharSequence value)
{    return new FromCharSequenceBinary(value);}
6c008ee2dcb326bdcc59522c6fe1588312ffdcf9f8c265a6664d3b0f463bcf05
hashCode
private static final int hashCode(byte[] array, int offset, int length)
{    int result = 1;    for (int i = offset; i < offset + length; i++) {        byte b = array[i];        result = 31 * result + b;    }    return result;}
402b960229c98784071ff5b597b150b1e52d3e88ddec0fa13898a457f81488da
hashCode
private static final int hashCode(ByteBuffer buf, int offset, int length)
{    int result = 1;    for (int i = offset; i < offset + length; i++) {        byte b = buf.get(i);        result = 31 * result + b;    }    return result;}
61833115c5d580ca04703ab84d2a2261a08a28fa6d1ce57787415de1d11dabdf
equals
private static final boolean equals(ByteBuffer buf1, int offset1, int length1, ByteBuffer buf2, int offset2, int length2)
{    if (buf1 == null && buf2 == null)        return true;    if (buf1 == null || buf2 == null)        return false;    if (length1 != length2)        return false;    for (int i = 0; i < length1; i++) {        if (buf1.get(i + offset1) != buf2.get(i + offset2)) {            return false;        }    }    return true;}
8c367a8ae58c67be75c473da2cc855cef2037b7c46b4160c54df77f2c960d0d1
equals
private static final boolean equals(byte[] array1, int offset1, int length1, ByteBuffer buf, int offset2, int length2)
{    if (array1 == null && buf == null)        return true;    if (array1 == null || buf == null)        return false;    if (length1 != length2)        return false;    for (int i = 0; i < length1; i++) {        if (array1[i + offset1] != buf.get(i + offset2)) {            return false;        }    }    return true;}
35ec2708ce5fcf954cd4ccaaa01d8a538e5f3ed1489080a263797e927e43264a
equals
private static final boolean equals(byte[] array1, int offset1, int length1, byte[] array2, int offset2, int length2)
{    if (array1 == null && array2 == null)        return true;    if (array1 == null || array2 == null)        return false;    if (length1 != length2)        return false;    if (array1 == array2 && offset1 == offset2)        return true;    for (int i = 0; i < length1; i++) {        if (array1[i + offset1] != array2[i + offset2]) {            return false;        }    }    return true;}
ba29d50443801efea264e23369a4b4db7856290e3949c20f0e394cd2d7fce66e
asPrimitiveConverter
public PrimitiveConverter asPrimitiveConverter()
{    throw new ClassCastException("Expected instance of primitive converter but got \"" + getClass().getName() + "\"");}
341d5da74353d6912781bcc5ff7e4f63d6afaa99f5625d597ad0200315691ac3
asGroupConverter
public GroupConverter asGroupConverter()
{    throw new ClassCastException("Expected instance of group converter but got \"" + getClass().getName() + "\"");}
64b386a1706abe6de0c11f54f47cc84c8f77c5767e36fb8f820311d6c95a4a53
isPrimitive
public boolean isPrimitive()
{    return false;}
341d5da74353d6912781bcc5ff7e4f63d6afaa99f5625d597ad0200315691ac3
asGroupConverter
public GroupConverter asGroupConverter()
{    return this;}
64b386a1706abe6de0c11f54f47cc84c8f77c5767e36fb8f820311d6c95a4a53
isPrimitive
public boolean isPrimitive()
{    return true;}
ba29d50443801efea264e23369a4b4db7856290e3949c20f0e394cd2d7fce66e
asPrimitiveConverter
public PrimitiveConverter asPrimitiveConverter()
{    return this;}
7c3f73c96e69cb35837e756142746fd240f40ccf1d7d310c2436e6b135fe196b
hasDictionarySupport
public boolean hasDictionarySupport()
{    return false;}
5edde50d3cb88777a151a88dae34321ada39b284501a5295564b122126c5c393
setDictionary
public void setDictionary(Dictionary dictionary)
{    throw new UnsupportedOperationException(getClass().getName());}
f1649786c3679c86c0157574e47953673714091cc71d598cedff963593010d98
addValueFromDictionary
public void addValueFromDictionary(int dictionaryId)
{    throw new UnsupportedOperationException(getClass().getName());}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    throw new UnsupportedOperationException(getClass().getName());}
23123f6657c241ab9b9f31f8efedc28a553ed91046d705121ce2667b065d6c17
addBoolean
public void addBoolean(boolean value)
{    throw new UnsupportedOperationException(getClass().getName());}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    throw new UnsupportedOperationException(getClass().getName());}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    throw new UnsupportedOperationException(getClass().getName());}
a2ac1f40a6e220ec515710128c8baf77a725ad0b9f1767a998f776f27fff6cf6
addInt
public void addInt(int value)
{    throw new UnsupportedOperationException(getClass().getName());}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    throw new UnsupportedOperationException(getClass().getName());}
ea956eca0ceec4b07db63def8a0f238be4f058fb174f02b053447578581df262
flush
public void flush()
{}
52337910a1f4ce802e2fe6041829534330913357c00d4735ce0fa742f5c3df17
skipCurrentRecord
public void skipCurrentRecord()
{}
81f24bd44baa674cd407f366492db0a1c8f1e3e77f9695c4d167fbf53309aba4
read
public T read()
{    readOneRecord();    return recordMaterializer.getCurrentRecord();}
9da19fa302b9a48c006a4ad43ef1253e348ee77879f3fe4e2ef5d9fdbc306d9a
currentLevel
protected void currentLevel(int currentLevel)
{    LOG.debug("currentLevel: {}", currentLevel);}
bb57ad604420dd8549bf1f88f73fa7bf4af786639b0f51f9274a507a01c286dd
log
protected void log(String message)
{    LOG.debug("bc: {}", message);}
36234d18026325c3d598073a3016dcf76f827e60bbab5fb17d34c1ebd2b566b2
getCaseId
protected final int getCaseId(int state, int currentLevel, int d, int nextR)
{    return caseLookup[state].getCase(currentLevel, d, nextR).getID();}
4522b8d7b540c04b967d5ebd1c9fb6f8dfa256c821a3e18e4e210b92c6c411e0
startMessage
protected final void startMessage()
{        endField = null;    LOG.debug("startMessage()");    recordConsumer.startMessage();}
78a8ff5bdf1111500ee3220621defa9bc99019346104278401dda2cedf7f2bcd
startGroup
protected final void startGroup(String field, int index)
{    startField(field, index);    LOG.debug("startGroup()");    recordConsumer.startGroup();}
95468470f074bb002c364164f5d028e1796b3dfc3867cdfed254139d790cea96
startField
private void startField(String field, int index)
{    LOG.debug("startField({},{})", field, index);    if (endField != null && index == endIndex) {                endField = null;    } else {        if (endField != null) {                        recordConsumer.endField(endField, endIndex);            endField = null;        }        recordConsumer.startField(field, index);    }}
fedd4d04f696a5b85f5a9ef873577874868ae466c3042366198be13c8e63e854
addPrimitiveINT64
protected final void addPrimitiveINT64(String field, int index, long value)
{    startField(field, index);    LOG.debug("addLong({})", value);    recordConsumer.addLong(value);    endField(field, index);}
f8dd55910e71d971bf61c1257977cf3ca20e015be46f87bf764b2c805c6c6917
endField
private void endField(String field, int index)
{    LOG.debug("endField({},{})", field, index);    if (endField != null) {        recordConsumer.endField(endField, endIndex);    }    endField = field;    endIndex = index;}
60b96543804082661e5f00a1d6ce89827ff04f6f0913ee1a8885dec20e2a17a9
addPrimitiveBINARY
protected final void addPrimitiveBINARY(String field, int index, Binary value)
{    startField(field, index);    LOG.debug("addBinary({})", value);    recordConsumer.addBinary(value);    endField(field, index);}
5afecbb340b65e218aa04773a15b712d798eb350f74710aeb1bfdc978efc5d68
addPrimitiveINT32
protected final void addPrimitiveINT32(String field, int index, int value)
{    startField(field, index);    LOG.debug("addInteger({})", value);    recordConsumer.addInteger(value);    endField(field, index);}
3e1fa44309666e2efabb7581de1d7d3626f491b5f8b2309cb6c739041f6bfcee
endGroup
protected final void endGroup(String field, int index)
{    if (endField != null) {                recordConsumer.endField(endField, endIndex);        endField = null;    }    LOG.debug("endGroup()");    recordConsumer.endGroup();    endField(field, index);}
340a4e6d80d814b264b12ddd211b43af09fc3fe79c2ec929fc7d6d6a1873210e
endMessage
protected final void endMessage()
{    if (endField != null) {                recordConsumer.endField(endField, endIndex);        endField = null;    }    LOG.debug("endMessage()");    recordConsumer.endMessage();}
d49f4cbe421517f8eaa1f9a51487f7abb186e365b71a29e6500875503188b741
error
protected void error(String message)
{    throw new ParquetDecodingException(message);}
e4a03198875e726822d05e42dd2fac0d972d6472e1d6f2942f8acb2abb465794
getFieldPath
 String[] getFieldPath()
{    return fieldPath;}
ecb3d87fba4322971e3b0f5ab430b4fae60be22ee72226240f52d59d017ed212
getFieldPath
public String getFieldPath(int level)
{    return fieldPath[level];}
3807d110f1b8b9bc446333e873aaa9b3588b40339af59725b4d538a23c952a41
getIndexFieldPath
public int[] getIndexFieldPath()
{    return indexFieldPath;}
fac124d1d18805b42a8925c2ed021f1cc8926c366df84fe60e8c783261290ad3
getIndexFieldPath
public int getIndexFieldPath(int level)
{    return indexFieldPath[level];}
d4663f435afd6a88c00a18d16d8d8e2fe6c896dd995d5906395fd4ddbb8b7760
getIndex
public int getIndex()
{    return this.index;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
c202c606159d838499129959d85b59a97c4545239d34f9e19cb53a2d257980d2
getRepetitionLevel
 int getRepetitionLevel()
{    return repetitionLevel;}
f098455e1e1c72ac35e458a0d8bb230453c7e846b3101c86862fedc7c3ef341f
getDefinitionLevel
 int getDefinitionLevel()
{    return definitionLevel;}
6d1dbd21f582515def922045b8cfbf282a82ba415efd111663652a981a39837d
setRepetitionLevel
 void setRepetitionLevel(int repetitionLevel)
{    this.repetitionLevel = repetitionLevel;}
3d0c09a0a2d9b7f64f68d1e2563dc6e1710677968262771d9a5c26ffd14d1028
setDefinitionLevel
 void setDefinitionLevel(int definitionLevel)
{    this.definitionLevel = definitionLevel;}
8d168fc71bd2a2d15d9a4ed8dd3053a029441fd83b7104dbc72df4c0e86b31be
setFieldPath
 void setFieldPath(String[] fieldPath, int[] indexFieldPath)
{    this.fieldPath = fieldPath;    this.indexFieldPath = indexFieldPath;}
b36c0cb78d388571653840506cba5d90e12b262c755658912fc2224c314bcbf6
getType
public Type getType()
{    return type;}
d3270400899bfac1c097da557d80c360ea86095ac6976d40b3cb8392c78bcdba
setLevels
 void setLevels(int r, int d, String[] fieldPath, int[] indexFieldPath, List<ColumnIO> repetition, List<ColumnIO> path)
{    setRepetitionLevel(r);    setDefinitionLevel(d);    setFieldPath(fieldPath, indexFieldPath);}
d03d86a4a23916838a7c0d8292abf1b08f58073839a5182b3f9cc9175becf386
getParent
public GroupColumnIO getParent()
{    return parent;}
9d48e7bab6289e0f3c10f4af06bab092dfd13471c6ca10c411d1250cc269cd34
getParent
 ColumnIO getParent(int r)
{    if (getRepetitionLevel() == r && getType().isRepetition(Repetition.REPEATED)) {        return this;    } else if (getParent() != null && getParent().getDefinitionLevel() >= r) {        return getParent().getParent(r);    } else {        throw new InvalidRecordException("no parent(" + r + ") for " + Arrays.toString(this.getFieldPath()));    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return this.getClass().getSimpleName() + " " + type.getName() + " r:" + repetitionLevel + " d:" + definitionLevel + " " + Arrays.toString(fieldPath);}
e183e50c625f3005b23a9727bd6a0d4ad3baa292e6b90993c782af03766328a8
visit
public void visit(MessageType messageType)
{    columnIO = new MessageColumnIO(requestedSchema, validating, createdBy);    visitChildren(columnIO, messageType, requestedSchema);    columnIO.setLevels();    columnIO.setLeaves(leaves);}
6ae94c927875668c171f00a4537468b9128fa1e640c0eb0d44c672494f97ea30
visit
public void visit(GroupType groupType)
{    if (currentRequestedType.isPrimitive()) {        incompatibleSchema(groupType, currentRequestedType);    }    GroupColumnIO newIO = new GroupColumnIO(groupType, current, currentRequestedIndex);    current.add(newIO);    visitChildren(newIO, groupType, currentRequestedType.asGroupType());}
eca48fb977b521b3e44906fa0aedfe674ac32ccffdaeb8539d51ab1f1d9d489b
visitChildren
private void visitChildren(GroupColumnIO newIO, GroupType groupType, GroupType requestedGroupType)
{    GroupColumnIO oldIO = current;    current = newIO;    for (Type type : groupType.getFields()) {                if (requestedGroupType.containsField(type.getName())) {            currentRequestedIndex = requestedGroupType.getFieldIndex(type.getName());            currentRequestedType = requestedGroupType.getType(currentRequestedIndex);            if (currentRequestedType.getRepetition().isMoreRestrictiveThan(type.getRepetition())) {                incompatibleSchema(type, currentRequestedType);            }            type.accept(this);        }    }    current = oldIO;}
d786d00215ab65b41fff4db7542dd376f5c3b9f2b7c11065b6f1a5b3a4feb8b0
visit
public void visit(PrimitiveType primitiveType)
{    if (!currentRequestedType.isPrimitive() || (this.strictTypeChecking && currentRequestedType.asPrimitiveType().getPrimitiveTypeName() != primitiveType.getPrimitiveTypeName())) {        incompatibleSchema(primitiveType, currentRequestedType);    }    PrimitiveColumnIO newIO = new PrimitiveColumnIO(primitiveType, current, currentRequestedIndex, leaves.size());    current.add(newIO);    leaves.add(newIO);}
4167f2fe9d057be6a71ae711b50e29792e2dc92d65a2ada4a020b86ef4eadc39
incompatibleSchema
private void incompatibleSchema(Type fileType, Type requestedType)
{    throw new ParquetDecodingException("The requested schema is not compatible with the file schema. incompatible types: " + requestedType + " != " + fileType);}
99d554027cf19f91cfc307f9008897733eb2b9e14ff1c6711af95b14663a864f
getColumnIO
public MessageColumnIO getColumnIO()
{    return columnIO;}
2ae913f2df6cd34fdf426a72b90aed06fee10577946791669977b19624edb73a
getColumnIO
public MessageColumnIO getColumnIO(MessageType requestedSchema, MessageType fileSchema)
{    return getColumnIO(requestedSchema, fileSchema, true);}
72f5808abd15572015870a3408259ac91647f343c0115daad9bd02b6274df870
getColumnIO
public MessageColumnIO getColumnIO(MessageType requestedSchema, MessageType fileSchema, boolean strict)
{    ColumnIOCreatorVisitor visitor = new ColumnIOCreatorVisitor(validating, requestedSchema, createdBy, strict);    fileSchema.accept(visitor);    return visitor.getColumnIO();}
c6e8f3b97b0c7e245ebe1e5896805e21866072d044a076b08d0f5a2f01cf14d9
getColumnIO
public MessageColumnIO getColumnIO(MessageType schema)
{    return this.getColumnIO(schema, schema);}
81f24bd44baa674cd407f366492db0a1c8f1e3e77f9695c4d167fbf53309aba4
read
public T read()
{    recordConsumer.start();    recordConsumer.end();    return recordMaterializer.getCurrentRecord();}
81f24bd44baa674cd407f366492db0a1c8f1e3e77f9695c4d167fbf53309aba4
read
public T read()
{    skipToMatch();    if (recordsRead == recordCount) {        return null;    }    ++recordsRead;    return super.read();}
a6d3e8b0ee240d2c6f0405a7ead6d2efee133c0961f1702c4070422a47021f44
shouldSkipCurrentRecord
public boolean shouldSkipCurrentRecord()
{    return false;}
fbd62f53fa0cc5899de2f5de552e9d963b2e82ec2825542eab7ca69048929000
skipToMatch
private void skipToMatch()
{    while (recordsRead < recordCount && !recordFilter.isMatch()) {        State currentState = getState(0);        do {            ColumnReader columnReader = currentState.column;                        if (columnReader.getCurrentDefinitionLevel() >= currentState.maxDefinitionLevel) {                columnReader.skip();            }            columnReader.consume();                        int nextR = currentState.maxRepetitionLevel == 0 ? 0 : columnReader.getCurrentRepetitionLevel();            currentState = currentState.getNextState(nextR);        } while (currentState != null);        ++recordsRead;    }}
e964d3e6f5bafe44429e49ff38c2f1a35d2848c16e9868f82f28a507b50fc56f
add
 void add(ColumnIO child)
{    children.add(child);    childrenByName.put(child.getType().getName(), child);    ++childrenSize;}
d3270400899bfac1c097da557d80c360ea86095ac6976d40b3cb8392c78bcdba
setLevels
 void setLevels(int r, int d, String[] fieldPath, int[] indexFieldPath, List<ColumnIO> repetition, List<ColumnIO> path)
{    super.setLevels(r, d, fieldPath, indexFieldPath, repetition, path);    for (ColumnIO child : this.children) {        String[] newFieldPath = Arrays.copyOf(fieldPath, fieldPath.length + 1);        int[] newIndexFieldPath = Arrays.copyOf(indexFieldPath, indexFieldPath.length + 1);        newFieldPath[fieldPath.length] = child.getType().getName();        newIndexFieldPath[indexFieldPath.length] = child.getIndex();        List<ColumnIO> newRepetition;        if (child.getType().isRepetition(REPEATED)) {            newRepetition = new ArrayList<ColumnIO>(repetition);            newRepetition.add(child);        } else {            newRepetition = repetition;        }        List<ColumnIO> newPath = new ArrayList<ColumnIO>(path);        newPath.add(child);        child.setLevels(        child.getType().isRepetition(REPEATED) ? r + 1 : r,         !child.getType().isRepetition(REQUIRED) ? d + 1 : d, newFieldPath, newIndexFieldPath, newRepetition, newPath);    }}
fbdb90b02539aa32efd3ed165e367c3d76e82c8979f30024cb2f7c9d57b20777
getColumnNames
 List<String[]> getColumnNames()
{    ArrayList<String[]> result = new ArrayList<String[]>();    for (ColumnIO c : children) {        result.addAll(c.getColumnNames());    }    return result;}
3744d393d185326a29e4062d0cd41a4b7362bc59a26d0dbd050a212aff916322
getLast
 PrimitiveColumnIO getLast()
{    return children.get(children.size() - 1).getLast();}
9f9814ba1d5f54b9a27b8e7046d1412f08e50cbf7ddf3a6f2f88275e40f4330f
getFirst
 PrimitiveColumnIO getFirst()
{    return children.get(0).getFirst();}
1ac8b08bc4a03a4ae7e245c46af6040942621281b555903a72eb1b47e7e4fb3c
getChild
public ColumnIO getChild(String name)
{    return childrenByName.get(name);}
e07720abeb042a4c8b40fe441b16144b5189df9e36f126a6cdc98bf590955121
getChild
public ColumnIO getChild(int fieldIndex)
{    try {        return children.get(fieldIndex);    } catch (IndexOutOfBoundsException e) {        throw new InvalidRecordException("could not get child " + fieldIndex + " from " + children, e);    }}
dd2097449ca0f3c85acd638543fdcfe9d0e66e66aa255f08daf24bb931d06b06
getChildrenCount
public int getChildrenCount()
{    return childrenSize;}
71bd554e7c56efaee8be9907dfb3c9ea56c0b7e9d417fc5573c96f3ba3dfa93a
getColumnNames
public List<String[]> getColumnNames()
{    return super.getColumnNames();}
b242ad052dc7f7b9c91d9a0be1841c57ae802fb7c1904c57ee685d86953f9f23
getRecordReader
public RecordReader<T> getRecordReader(PageReadStore columns, RecordMaterializer<T> recordMaterializer)
{    return getRecordReader(columns, recordMaterializer, FilterCompat.NOOP);}
4e48ba824b7997a057264d7848c2fe9db025c62e160c4d19317b0bb5f113c3e1
getRecordReader
public RecordReader<T> getRecordReader(PageReadStore columns, RecordMaterializer<T> recordMaterializer, UnboundRecordFilter filter)
{    return getRecordReader(columns, recordMaterializer, FilterCompat.get(filter));}
6c121af08ec0912621b177061b8870a4090bc099c61ec13b63a83eff187b838d
getRecordReader
public RecordReader<T> getRecordReader(final PageReadStore columns, final RecordMaterializer<T> recordMaterializer, final Filter filter)
{    checkNotNull(columns, "columns");    checkNotNull(recordMaterializer, "recordMaterializer");    checkNotNull(filter, "filter");    if (leaves.isEmpty()) {        return new EmptyRecordReader<T>(recordMaterializer);    }    return filter.accept(new Visitor<RecordReader<T>>() {        @Override        public RecordReader<T> visit(FilterPredicateCompat filterPredicateCompat) {            FilterPredicate predicate = filterPredicateCompat.getFilterPredicate();            IncrementallyUpdatedFilterPredicateBuilder builder = new IncrementallyUpdatedFilterPredicateBuilder(leaves);            IncrementallyUpdatedFilterPredicate streamingPredicate = builder.build(predicate);            RecordMaterializer<T> filteringRecordMaterializer = new FilteringRecordMaterializer<T>(recordMaterializer, leaves, builder.getValueInspectorsByColumn(), streamingPredicate);            return new RecordReaderImplementation<T>(MessageColumnIO.this, filteringRecordMaterializer, validating, new ColumnReadStoreImpl(columns, filteringRecordMaterializer.getRootConverter(), getType(), createdBy));        }        @Override        public RecordReader<T> visit(UnboundRecordFilterCompat unboundRecordFilterCompat) {            return new FilteredRecordReader<T>(MessageColumnIO.this, recordMaterializer, validating, new ColumnReadStoreImpl(columns, recordMaterializer.getRootConverter(), getType(), createdBy), unboundRecordFilterCompat.getUnboundRecordFilter(), columns.getRowCount());        }        @Override        public RecordReader<T> visit(NoOpFilter noOpFilter) {            return new RecordReaderImplementation<T>(MessageColumnIO.this, recordMaterializer, validating, new ColumnReadStoreImpl(columns, recordMaterializer.getRootConverter(), getType(), createdBy));        }    });}
6fcebc016c6e5da2f99f1d73384415b731e974731f45ef779a2b6a4686b50b55
visit
public RecordReader<T> visit(FilterPredicateCompat filterPredicateCompat)
{    FilterPredicate predicate = filterPredicateCompat.getFilterPredicate();    IncrementallyUpdatedFilterPredicateBuilder builder = new IncrementallyUpdatedFilterPredicateBuilder(leaves);    IncrementallyUpdatedFilterPredicate streamingPredicate = builder.build(predicate);    RecordMaterializer<T> filteringRecordMaterializer = new FilteringRecordMaterializer<T>(recordMaterializer, leaves, builder.getValueInspectorsByColumn(), streamingPredicate);    return new RecordReaderImplementation<T>(MessageColumnIO.this, filteringRecordMaterializer, validating, new ColumnReadStoreImpl(columns, filteringRecordMaterializer.getRootConverter(), getType(), createdBy));}
e0e8f7f59485d0a15ae5dbe4478759682eda1b607bc9089978315d7f35bde672
visit
public RecordReader<T> visit(UnboundRecordFilterCompat unboundRecordFilterCompat)
{    return new FilteredRecordReader<T>(MessageColumnIO.this, recordMaterializer, validating, new ColumnReadStoreImpl(columns, recordMaterializer.getRootConverter(), getType(), createdBy), unboundRecordFilterCompat.getUnboundRecordFilter(), columns.getRowCount());}
62c67683a37183fa72a48166cfee212e7d7b49c369f779981867038fa52efba3
visit
public RecordReader<T> visit(NoOpFilter noOpFilter)
{    return new RecordReaderImplementation<T>(MessageColumnIO.this, recordMaterializer, validating, new ColumnReadStoreImpl(columns, recordMaterializer.getRootConverter(), getType(), createdBy));}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "VistedIndex{" + "vistedIndexes=" + vistedIndexes + '}';}
9773bd1c4662f3dd98581ff62ed1cbbea7b47fe0e141af850e13e26159aee050
reset
public void reset(int fieldsCount)
{    this.vistedIndexes.clear(0, fieldsCount);}
d71f70c154d2a37c467c20f244fee8dda7961281983548aadab1146f16a9cb02
markWritten
public void markWritten(int i)
{    vistedIndexes.set(i);}
c2d3090081fd24db8f925819d4382c71efe212ee63ae72c7cfaee0b582f8d600
isWritten
public boolean isWritten(int i)
{    return vistedIndexes.get(i);}
19b249566f6cb13099425db544a59fdc03d2977315e9f65ce48256a900b63fe6
buildGroupToLeafWriterMap
private void buildGroupToLeafWriterMap(PrimitiveColumnIO primitive, ColumnWriter writer)
{    GroupColumnIO parent = primitive.getParent();    do {        getLeafWriters(parent).add(writer);        parent = parent.getParent();    } while (parent != null);}
2dc6ed81522f0f06753e68382f23d9a5bff03575648789480893db71538e9d93
getLeafWriters
private List<ColumnWriter> getLeafWriters(GroupColumnIO group)
{    List<ColumnWriter> writers = groupToLeafWriter.get(group);    if (writers == null) {        writers = new ArrayList<ColumnWriter>();        groupToLeafWriter.put(group, writers);    }    return writers;}
374401622e25fde431076da7a533255c08bfb7abe2ce6e909d07864370f8e2a4
printState
private void printState()
{    if (DEBUG) {        log(currentLevel + ", " + fieldsWritten[currentLevel] + ": " + Arrays.toString(currentColumnIO.getFieldPath()) + " r:" + r[currentLevel]);        if (r[currentLevel] > currentColumnIO.getRepetitionLevel()) {                        throw new InvalidRecordException(r[currentLevel] + "(r) > " + currentColumnIO.getRepetitionLevel() + " ( schema r)");        }    }}
3a5e7c6f424997b609fa1e48485635d2123740f218326465993ec7f39e9e6e57
log
private void log(Object message, Object... parameters)
{    if (DEBUG) {        String indent = "";        for (int i = 0; i < currentLevel; ++i) {            indent += "  ";        }        LOG.debug(indent + message, parameters);    }}
e5e2c9b58121c7b8e63436a9e7031931166ce2bd9376140b1790d59ac20dcfbe
startMessage
public void startMessage()
{    if (DEBUG)        log("< MESSAGE START >");    currentColumnIO = MessageColumnIO.this;    r[0] = 0;    int numberOfFieldsToVisit = ((GroupColumnIO) currentColumnIO).getChildrenCount();    fieldsWritten[0].reset(numberOfFieldsToVisit);    if (DEBUG)        printState();}
c0050e156bf5e112b0554bf9524370c3e6283a1c5ae4b1604d4372dd52f52bf9
endMessage
public void endMessage()
{    writeNullForMissingFieldsAtCurrentLevel();        if (columns.isColumnFlushNeeded()) {        flush();    }    columns.endRecord();    if (DEBUG)        log("< MESSAGE END >");    if (DEBUG)        printState();}
236c79d8ba13d45c1abe57e04adf551d76dcb00c9a850a52081487fd2a43a22f
startField
public void startField(String field, int index)
{    try {        if (DEBUG)            log("startField({}, {})", field, index);        currentColumnIO = ((GroupColumnIO) currentColumnIO).getChild(index);        emptyField = true;        if (DEBUG)            printState();    } catch (RuntimeException e) {        throw new ParquetEncodingException("error starting field " + field + " at " + index, e);    }}
727a571f26f4770f35d9e03a67bbd8f2ba8b89efb3ee6a0616432db5d5f26dc0
endField
public void endField(String field, int index)
{    if (DEBUG)        log("endField({}, {})", field, index);    currentColumnIO = currentColumnIO.getParent();    if (emptyField) {        throw new ParquetEncodingException("empty fields are illegal, the field should be ommited completely instead");    }    fieldsWritten[currentLevel].markWritten(index);    r[currentLevel] = currentLevel == 0 ? 0 : r[currentLevel - 1];    if (DEBUG)        printState();}
677d907c8ef84614ac6316af2b3d41e32e6ad1b8221cc20f4faa287c8496ad4a
writeNullForMissingFieldsAtCurrentLevel
private void writeNullForMissingFieldsAtCurrentLevel()
{    int currentFieldsCount = ((GroupColumnIO) currentColumnIO).getChildrenCount();    for (int i = 0; i < currentFieldsCount; i++) {        if (!fieldsWritten[currentLevel].isWritten(i)) {            try {                ColumnIO undefinedField = ((GroupColumnIO) currentColumnIO).getChild(i);                int d = currentColumnIO.getDefinitionLevel();                if (DEBUG)                    log(Arrays.toString(undefinedField.getFieldPath()) + ".writeNull(" + r[currentLevel] + "," + d + ")");                writeNull(undefinedField, r[currentLevel], d);            } catch (RuntimeException e) {                throw new ParquetEncodingException("error while writing nulls for fields of indexes " + i + " . current index: " + fieldsWritten[currentLevel], e);            }        }    }}
96c81977a4ad76a2d9d071a84e73ee08ad11bd260489a323e7681673da6ec78d
writeNull
private void writeNull(ColumnIO undefinedField, int r, int d)
{    if (undefinedField.getType().isPrimitive()) {        columnWriter[((PrimitiveColumnIO) undefinedField).getId()].writeNull(r, d);    } else {        GroupColumnIO groupColumnIO = (GroupColumnIO) undefinedField;                cacheNullForGroup(groupColumnIO, r);    }}
0b90dcb909bfb658c90d45a351b4f70877deda5d54b969e83abf741391a69731
cacheNullForGroup
private void cacheNullForGroup(GroupColumnIO group, int r)
{    IntArrayList nulls = groupNullCache.get(group);    if (nulls == null) {        nulls = new IntArrayList();        groupNullCache.put(group, nulls);    }    nulls.add(r);}
f8e3d4dce824f9d80df187ed6f06dd8d4af15157d6998931d168d7024ac6d0d3
writeNullToLeaves
private void writeNullToLeaves(GroupColumnIO group)
{    IntArrayList nullCache = groupNullCache.get(group);    if (nullCache == null || nullCache.isEmpty())        return;    int parentDefinitionLevel = group.getParent().getDefinitionLevel();    for (ColumnWriter leafWriter : groupToLeafWriter.get(group)) {        for (IntIterator iter = nullCache.iterator(); iter.hasNext(); ) {            int repetitionLevel = iter.nextInt();            leafWriter.writeNull(repetitionLevel, parentDefinitionLevel);        }    }    nullCache.clear();}
ba4b9705cfec81462309ec05a2f5e6c924825470f273f46ef9694316b7e4860f
setRepetitionLevel
private void setRepetitionLevel()
{    r[currentLevel] = currentColumnIO.getRepetitionLevel();    if (DEBUG)        log("r: {}", r[currentLevel]);}
bfaaecdf8637c04369d0caed5ce7be12b1f042c05c383dc5f56a16cbd1691cc5
startGroup
public void startGroup()
{    if (DEBUG)        log("startGroup()");    GroupColumnIO group = (GroupColumnIO) currentColumnIO;        if (hasNullCache(group)) {        flushCachedNulls(group);    }    ++currentLevel;    r[currentLevel] = r[currentLevel - 1];    int fieldsCount = ((GroupColumnIO) currentColumnIO).getChildrenCount();    fieldsWritten[currentLevel].reset(fieldsCount);    if (DEBUG)        printState();}
de94ab2a29528e40e51b968247fd77edc458e8ee0416affaa21c032b7155313d
hasNullCache
private boolean hasNullCache(GroupColumnIO group)
{    IntArrayList nulls = groupNullCache.get(group);    return nulls != null && !nulls.isEmpty();}
049f0d2a9ee9c87ff25bebf7bbe6ae1ff09d4e0f03e40de84fb7c84b58f92056
flushCachedNulls
private void flushCachedNulls(GroupColumnIO group)
{        for (int i = 0; i < group.getChildrenCount(); i++) {        ColumnIO child = group.getChild(i);        if (child instanceof GroupColumnIO) {            flushCachedNulls((GroupColumnIO) child);        }    }        writeNullToLeaves(group);}
dfc16afb5d0316137d8951a7e04ed7d4672d9248b3dddee0a28c6939f9c45eaf
endGroup
public void endGroup()
{    if (DEBUG)        log("endGroup()");    emptyField = false;    writeNullForMissingFieldsAtCurrentLevel();    --currentLevel;    setRepetitionLevel();    if (DEBUG)        printState();}
4d0de39521e4a15e636424efde910bd84c3861485be2a4714557d22b194e2593
getColumnWriter
private ColumnWriter getColumnWriter()
{    return columnWriter[((PrimitiveColumnIO) currentColumnIO).getId()];}
eb80b1067a5ffb5802b37913bc5fed8ff814c76a74fa1b038fa559d98f1f8f4b
addInteger
public void addInteger(int value)
{    if (DEBUG)        log("addInt({})", value);    emptyField = false;    getColumnWriter().write(value, r[currentLevel], currentColumnIO.getDefinitionLevel());    setRepetitionLevel();    if (DEBUG)        printState();}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    if (DEBUG)        log("addLong({})", value);    emptyField = false;    getColumnWriter().write(value, r[currentLevel], currentColumnIO.getDefinitionLevel());    setRepetitionLevel();    if (DEBUG)        printState();}
23123f6657c241ab9b9f31f8efedc28a553ed91046d705121ce2667b065d6c17
addBoolean
public void addBoolean(boolean value)
{    if (DEBUG)        log("addBoolean({})", value);    emptyField = false;    getColumnWriter().write(value, r[currentLevel], currentColumnIO.getDefinitionLevel());    setRepetitionLevel();    if (DEBUG)        printState();}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    if (DEBUG)        log("addBinary({} bytes)", value.length());    emptyField = false;    getColumnWriter().write(value, r[currentLevel], currentColumnIO.getDefinitionLevel());    setRepetitionLevel();    if (DEBUG)        printState();}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    if (DEBUG)        log("addFloat({})", value);    emptyField = false;    getColumnWriter().write(value, r[currentLevel], currentColumnIO.getDefinitionLevel());    setRepetitionLevel();    if (DEBUG)        printState();}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    if (DEBUG)        log("addDouble({})", value);    emptyField = false;    getColumnWriter().write(value, r[currentLevel], currentColumnIO.getDefinitionLevel());    setRepetitionLevel();    if (DEBUG)        printState();}
ea956eca0ceec4b07db63def8a0f238be4f058fb174f02b053447578581df262
flush
public void flush()
{    flushCachedNulls(MessageColumnIO.this);}
5c8d809e4c14bd05e83a0f78365667a52913cbbeed638ec215ee60eb8da3306c
getRecordWriter
public RecordConsumer getRecordWriter(ColumnWriteStore columns)
{    RecordConsumer recordWriter = new MessageColumnIORecordConsumer(columns);    if (DEBUG)        recordWriter = new RecordConsumerLoggingWrapper(recordWriter);    return validating ? new ValidatingRecordConsumer(recordWriter, getType()) : recordWriter;}
31e11e74b135a25a01270bc18e56ff1f69c91a7136af46b3e0e577bb0f78d84e
setLevels
 void setLevels()
{    setLevels(0, 0, new String[0], new int[0], Arrays.<ColumnIO>asList(this), Arrays.<ColumnIO>asList(this));}
a722c59b2713da009b1ca18e242a9206d477a397d84c123e5c9be41cf46ba3f2
setLeaves
 void setLeaves(List<PrimitiveColumnIO> leaves)
{    this.leaves = leaves;}
b8e74dd8e891d852fcc2b2ac5331c7447e49a193d3e98a5aceb1c7086a078aec
getLeaves
public List<PrimitiveColumnIO> getLeaves()
{    return this.leaves;}
5b2bd7fe1500a6179d00a6681979b69bff9e085453546a5d01ccc13d4359c01f
getType
public MessageType getType()
{    return (MessageType) super.getType();}
f16fd5e398d4d020e50f9f473c68d7f5c432a9658b255e7f99946e74f229c140
setLevels
 void setLevels(int r, int d, String[] fieldPath, int[] fieldIndexPath, List<ColumnIO> repetition, List<ColumnIO> path)
{    super.setLevels(r, d, fieldPath, fieldIndexPath, repetition, path);    PrimitiveType type = getType().asPrimitiveType();    this.columnDescriptor = new ColumnDescriptor(fieldPath, type, getRepetitionLevel(), getDefinitionLevel());    this.path = path.toArray(new ColumnIO[path.size()]);}
fbdb90b02539aa32efd3ed165e367c3d76e82c8979f30024cb2f7c9d57b20777
getColumnNames
 List<String[]> getColumnNames()
{    return Arrays.asList(new String[][] { getFieldPath() });}
d8db5900afaa66f4d3978ec44b53251d1f8ef38e6c8259248b6c94ad6fb91dbc
getColumnDescriptor
public ColumnDescriptor getColumnDescriptor()
{    return columnDescriptor;}
e4a9c3bd661611e2f9210c346f9d3ce627d714b555f3d5b41fd4b558e077f4e1
getPath
public ColumnIO[] getPath()
{    return path;}
feb6ad0d50177326d06a90e596af91404dff9d8bb63dffe533e1775b03c0ff1f
isLast
public boolean isLast(int r)
{    return getLast(r) == this;}
494eb63471db54ee28e3fff3c5a7f20bf0658036c7b43ac7fbe469892139c1d5
getLast
private PrimitiveColumnIO getLast(int r)
{    ColumnIO parent = getParent(r);    PrimitiveColumnIO last = parent.getLast();    return last;}
3744d393d185326a29e4062d0cd41a4b7362bc59a26d0dbd050a212aff916322
getLast
 PrimitiveColumnIO getLast()
{    return this;}
9f9814ba1d5f54b9a27b8e7046d1412f08e50cbf7ddf3a6f2f88275e40f4330f
getFirst
 PrimitiveColumnIO getFirst()
{    return this;}
ab9e85c8060d0f8e4cdc1e0e61743cdf35a86e32a614c265c52dee40a06d0f12
isFirst
public boolean isFirst(int r)
{    return getFirst(r) == this;}
b110096ea5a546a075c183acedc505afb47b1f1580553ad5174ff58743d4a691
getFirst
private PrimitiveColumnIO getFirst(int r)
{    ColumnIO parent = getParent(r);    return parent.getFirst();}
a9ea8198c4becef27facaa911336a7150f4cda024aa5d015378fd0ea0697dd55
getPrimitive
public PrimitiveTypeName getPrimitive()
{    return getType().asPrimitiveType().getPrimitiveTypeName();}
cea1c2c1f10d4b97004da212612fc3f2159fe44d7c7e24cd3c5e70653f0143a5
getId
public int getId()
{    return id;}
236c79d8ba13d45c1abe57e04adf551d76dcb00c9a850a52081487fd2a43a22f
startField
public void startField(String field, int index)
{    logOpen(field);    delegate.startField(field, index);}
e935d7eda88237fd90f479e4da67669d85e2039d6f0caf3ee72f5934bb95ff6e
logOpen
private void logOpen(String field)
{    log("<{}>", field);}
3ad3db5f0f5c19e0eda72663840f2779fbd59cc515de50f5edbb557bb29d3879
indent
private String indent()
{    StringBuilder result = new StringBuilder();    for (int i = 0; i < indent; i++) {        result.append("  ");    }    return result.toString();}
bea3bc6474b20b8c121b8d23e127609472e905bb837d1cddf1860508c8202194
log
private void log(Object value, Object... parameters)
{    if (LOG.isDebugEnabled()) {        LOG.debug(indent() + value, parameters);    }}
bfaaecdf8637c04369d0caed5ce7be12b1f042c05c383dc5f56a16cbd1691cc5
startGroup
public void startGroup()
{    ++indent;    log("<!-- start group -->");    delegate.startGroup();}
eb80b1067a5ffb5802b37913bc5fed8ff814c76a74fa1b038fa559d98f1f8f4b
addInteger
public void addInteger(int value)
{    log(value);    delegate.addInteger(value);}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    log(value);    delegate.addLong(value);}
23123f6657c241ab9b9f31f8efedc28a553ed91046d705121ce2667b065d6c17
addBoolean
public void addBoolean(boolean value)
{    log(value);    delegate.addBoolean(value);}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    if (LOG.isDebugEnabled())        log(Arrays.toString(value.getBytesUnsafe()));    delegate.addBinary(value);}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    log(value);    delegate.addFloat(value);}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    log(value);    delegate.addDouble(value);}
ea956eca0ceec4b07db63def8a0f238be4f058fb174f02b053447578581df262
flush
public void flush()
{    log("<!-- flush -->");    delegate.flush();}
dfc16afb5d0316137d8951a7e04ed7d4672d9248b3dddee0a28c6939f9c45eaf
endGroup
public void endGroup()
{    log("<!-- end group -->");    --indent;    delegate.endGroup();}
727a571f26f4770f35d9e03a67bbd8f2ba8b89efb3ee6a0616432db5d5f26dc0
endField
public void endField(String field, int index)
{    logClose(field);    delegate.endField(field, index);}
b6d8f06b2a1b32eac8f0f9d320ece6297c101fe6085b64f057f9cc030aeb61dd
logClose
private void logClose(String field)
{    log("</{}>", field);}
e5e2c9b58121c7b8e63436a9e7031931166ce2bd9376140b1790d59ac20dcfbe
startMessage
public void startMessage()
{    log("<!-- start message -->");    delegate.startMessage();}
c0050e156bf5e112b0554bf9524370c3e6283a1c5ae4b1604d4372dd52f52bf9
endMessage
public void endMessage()
{    delegate.endMessage();    log("<!-- end message -->");}
a6d3e8b0ee240d2c6f0405a7ead6d2efee133c0961f1702c4070422a47021f44
shouldSkipCurrentRecord
public boolean shouldSkipCurrentRecord()
{    return false;}
f35654c66337514ded4f3a269f0135bf7068b7b0420061c97ead4ad7292aa711
setID
public void setID(int id)
{    this.id = id;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int hashCode = 17;    hashCode += 31 * startLevel;    hashCode += 31 * depth;    hashCode += 31 * nextLevel;    hashCode += 31 * nextState;    hashCode += 31 * (defined ? 0 : 1);    return hashCode;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (obj instanceof Case) {        return equals((Case) obj);    }    return false;}
c39acbfb91986124866b80632c5c0ed621e6fac2d95eb415ca440c6e45de753a
equals
public boolean equals(Case other)
{    return other != null && startLevel == other.startLevel && depth == other.depth && nextLevel == other.nextLevel && nextState == other.nextState && ((defined && other.defined) || (!defined && !other.defined));}
003433aa83500f3ce61d939f5d33099b383cdfa01df66de90f82c422360e69e2
getID
public int getID()
{    return id;}
c4136005483dc9ab730d3f6c344a37ed23698a6f615d1f1dbd73dead9919c99f
getStartLevel
public int getStartLevel()
{    return startLevel;}
bf59abd5eadbc4a8a91e7c05be9505c15b915c4238866a6dfb81b4ad63852244
getDepth
public int getDepth()
{    return depth;}
8582bff1d5ff8c0232ffe0ed0a5b075484616b9e5e63712bdabb182fd48d04ee
getNextLevel
public int getNextLevel()
{    return nextLevel;}
4986e4b6d295e63fffd700c2db4c8bb059bac6aa7f045db1aa50feb78af902bf
getNextState
public int getNextState()
{    return nextState;}
f34416364d234bf67d0d5e82dfcf8745cafbc91f87097dd50adb03cc8272f7c3
isGoingUp
public boolean isGoingUp()
{    return goingUp;}
df76940453379b697f37dff4edf94db507d8e46d604f43e054f5bf9d7cf0db7d
isGoingDown
public boolean isGoingDown()
{    return goingDown;}
36443a8a9542e2889371fc9e2d5fd8df6018f7ab1cad1b224369f34e606af1dd
isDefined
public boolean isDefined()
{    return defined;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "Case " + startLevel + " -> " + depth + " -> " + nextLevel + "; goto sate_" + getNextState();}
32b8bcbf13c4644916f18bc2a49950d50b8eb36b1eac7b8cc8c73dff438baf1e
getDepth
public int getDepth(int definitionLevel)
{    return definitionLevelToDepth[definitionLevel];}
eb2f24d572b91381cdddcdd7c66556a00eb7af6ff0ff1b05b4ce6c17a3ca737c
getDefinedCases
public List<Case> getDefinedCases()
{    return definedCases;}
47ecc82302f8d173084a168e53a887d6dae9aacb76ad64005cf5058272502413
getUndefinedCases
public List<Case> getUndefinedCases()
{    return undefinedCases;}
0284e0101926ef7aa238b56c6955173d8a9dd7a043230fd129baf1faecb97ee9
getCase
public Case getCase(int currentLevel, int d, int nextR)
{    return caseLookup[currentLevel][d][nextR];}
52fa680566811bf59c6d6f0eb803ed73c0f202fef48372cbdb0a865979d5a81c
getNextState
public State getNextState(int nextR)
{    return nextState[nextR];}
99668b26c60fd54eece73aa91f8b5c754d3d54df958d315a04bf39a9ae9e3531
compare
public int compare(Case o1, Case o2)
{    return o1.id - o2.id;}
a636c40941246497fb0922eeb3f221096fd351cfdada8ada441afb633caf7925
validator
private RecordConsumer validator(RecordConsumer recordConsumer, boolean validating, MessageType schema)
{    return validating ? new ValidatingRecordConsumer(recordConsumer, schema) : recordConsumer;}
d61f1e415e4c694a4771b17d8c097c574c9b2bbba2e36fdcf0a268fa14f6e4e3
wrap
private RecordConsumer wrap(RecordConsumer recordConsumer)
{    if (LOG.isDebugEnabled()) {        return new RecordConsumerLoggingWrapper(recordConsumer);    }    return recordConsumer;}
81f24bd44baa674cd407f366492db0a1c8f1e3e77f9695c4d167fbf53309aba4
read
public T read()
{    int currentLevel = 0;    recordRootConverter.start();    State currentState = states[0];    do {        ColumnReader columnReader = currentState.column;        int d = columnReader.getCurrentDefinitionLevel();                int depth = currentState.definitionLevelToDepth[d];        for (; currentLevel <= depth; ++currentLevel) {            currentState.groupConverterPath[currentLevel].start();        }                if (d >= currentState.maxDefinitionLevel) {                        columnReader.writeCurrentValueToConverter();        }        columnReader.consume();        int nextR = currentState.maxRepetitionLevel == 0 ? 0 : columnReader.getCurrentRepetitionLevel();                int next = currentState.nextLevel[nextR];        for (; currentLevel > next; currentLevel--) {            currentState.groupConverterPath[currentLevel - 1].end();        }        currentState = currentState.nextState[nextR];    } while (currentState != null);    recordRootConverter.end();    T record = recordMaterializer.getCurrentRecord();    shouldSkipCurrentRecord = record == null;    if (shouldSkipCurrentRecord) {        recordMaterializer.skipCurrentRecord();    }    return record;}
a6d3e8b0ee240d2c6f0405a7ead6d2efee133c0961f1702c4070422a47021f44
shouldSkipCurrentRecord
public boolean shouldSkipCurrentRecord()
{    return shouldSkipCurrentRecord;}
a9d4c8249c415284be07de6b22aaaf8b4eaf54f6fdf1848caa92817f1c9319c8
log
private static void log(String string)
{    LOG.debug(string);}
06da579553a673ff20d23a22b66db52196c309ebff2752ff29314c9b040bd01d
getNextReader
 int getNextReader(int current, int nextRepetitionLevel)
{    State nextState = states[current].nextState[nextRepetitionLevel];    return nextState == null ? states.length : nextState.id;}
d6383d0bd52e479dd03af761791fce883b949cadf522748e1ecfec4c4376a040
getNextLevel
 int getNextLevel(int current, int nextRepetitionLevel)
{    return states[current].nextLevel[nextRepetitionLevel];}
b133d54994a114a9064c0c1b473aebfd039be03bd0d2a6467e48c77adb3bbba6
getCommonParentLevel
private int getCommonParentLevel(String[] previous, String[] next)
{    int i = 0;    while (i < Math.min(previous.length, next.length) && previous[i].equals(next[i])) {        ++i;    }    return i;}
5154abaa811085929041068d6592af80a63526764e1462db072e18412ce9c31b
getStateCount
protected int getStateCount()
{    return states.length;}
5f55f30d21b2965351bd71fcf161768ab4a275ed1df826d8c6ab564045f6c540
getState
protected State getState(int i)
{    return states[i];}
73334aa9e8c67568cce89cfd61aa116bbb81310826dc839078bc6292c97653c0
getMaterializer
protected RecordMaterializer<T> getMaterializer()
{    return recordMaterializer;}
d775172d418b5e79d7acdee66b9a26aff5a611d80d0f7aef4fdb3cf1aa3f05cc
getRecordConsumer
protected Converter getRecordConsumer()
{    return recordRootConverter;}
d06b9b7d99432a307a7750ad464b8f42e5dea47882279c1d3dcb6e40c4b20385
getColumnReaders
protected Iterable<ColumnReader> getColumnReaders()
{        return Arrays.asList(columnReaders);}
e5e2c9b58121c7b8e63436a9e7031931166ce2bd9376140b1790d59ac20dcfbe
startMessage
public void startMessage()
{    previousField.push(-1);    delegate.startMessage();}
c0050e156bf5e112b0554bf9524370c3e6283a1c5ae4b1604d4372dd52f52bf9
endMessage
public void endMessage()
{    delegate.endMessage();    validateMissingFields(types.peek().asGroupType().getFieldCount());    previousField.pop();}
236c79d8ba13d45c1abe57e04adf551d76dcb00c9a850a52081487fd2a43a22f
startField
public void startField(String field, int index)
{    if (index <= previousField.peek()) {        throw new InvalidRecordException("fields must be added in order " + field + " index " + index + " is before previous field " + previousField.peek());    }    validateMissingFields(index);    fields.push(index);    fieldValueCount.push(0);    delegate.startField(field, index);}
adb20db9a9f05ae11219f6d013d1c524ec1a5500a92e62da76b48a43689c84af
validateMissingFields
private void validateMissingFields(int index)
{    for (int i = previousField.peek() + 1; i < index; i++) {        Type type = types.peek().asGroupType().getType(i);        if (type.isRepetition(Repetition.REQUIRED)) {            throw new InvalidRecordException("required field is missing " + type);        }    }}
727a571f26f4770f35d9e03a67bbd8f2ba8b89efb3ee6a0616432db5d5f26dc0
endField
public void endField(String field, int index)
{    delegate.endField(field, index);    fieldValueCount.pop();    previousField.push(fields.pop());}
bfaaecdf8637c04369d0caed5ce7be12b1f042c05c383dc5f56a16cbd1691cc5
startGroup
public void startGroup()
{    previousField.push(-1);    types.push(types.peek().asGroupType().getType(fields.peek()));    delegate.startGroup();}
dfc16afb5d0316137d8951a7e04ed7d4672d9248b3dddee0a28c6939f9c45eaf
endGroup
public void endGroup()
{    delegate.endGroup();    validateMissingFields(types.peek().asGroupType().getFieldCount());    types.pop();    previousField.pop();}
ea956eca0ceec4b07db63def8a0f238be4f058fb174f02b053447578581df262
flush
public void flush()
{    delegate.flush();}
66d821fdecf8088b536227938ecc8a46017ecb31fbbf2d943dcea9b9b3fd8e72
validate
private void validate(PrimitiveTypeName p)
{    Type currentType = types.peek().asGroupType().getType(fields.peek());    int c = fieldValueCount.pop() + 1;    fieldValueCount.push(c);    LOG.debug("validate {} for {}", p, currentType.getName());    switch(currentType.getRepetition()) {        case OPTIONAL:        case REQUIRED:            if (c > 1) {                throw new InvalidRecordException("repeated value when the type is not repeated in " + currentType);            }            break;        case REPEATED:            break;        default:            throw new InvalidRecordException("unknown repetition " + currentType.getRepetition() + " in " + currentType);    }    if (!currentType.isPrimitive() || currentType.asPrimitiveType().getPrimitiveTypeName() != p) {        throw new InvalidRecordException("expected type " + p + " but got " + currentType);    }}
0f9417ad7e3b64205cb43b0d95e71c964da156490b0143737063125c84323f63
validate
private void validate(PrimitiveTypeName... ptypes)
{    Type currentType = types.peek().asGroupType().getType(fields.peek());    int c = fieldValueCount.pop() + 1;    fieldValueCount.push(c);    if (LOG.isDebugEnabled())        LOG.debug("validate " + Arrays.toString(ptypes) + " for " + currentType.getName());    switch(currentType.getRepetition()) {        case OPTIONAL:        case REQUIRED:            if (c > 1) {                throw new InvalidRecordException("repeated value when the type is not repeated in " + currentType);            }            break;        case REPEATED:            break;        default:            throw new InvalidRecordException("unknown repetition " + currentType.getRepetition() + " in " + currentType);    }    if (!currentType.isPrimitive()) {        throw new InvalidRecordException("expected type in " + Arrays.toString(ptypes) + " but got " + currentType);    }    for (PrimitiveTypeName p : ptypes) {        if (currentType.asPrimitiveType().getPrimitiveTypeName() == p) {                        return;        }    }    throw new InvalidRecordException("expected type in " + Arrays.toString(ptypes) + " but got " + currentType);}
eb80b1067a5ffb5802b37913bc5fed8ff814c76a74fa1b038fa559d98f1f8f4b
addInteger
public void addInteger(int value)
{    validate(INT32);    delegate.addInteger(value);}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    validate(INT64);    delegate.addLong(value);}
23123f6657c241ab9b9f31f8efedc28a553ed91046d705121ce2667b065d6c17
addBoolean
public void addBoolean(boolean value)
{    validate(BOOLEAN);    delegate.addBoolean(value);}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    validate(BINARY, INT96, FIXED_LEN_BYTE_ARRAY);    delegate.addBinary(value);}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    validate(FLOAT);    delegate.addFloat(value);}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    validate(DOUBLE);    delegate.addDouble(value);}
dead3a9ebeec8bb618faf897b2d38e7fd15d11930bbf75b024c38ed7c198bd16
undefined
public static ColumnOrder undefined()
{    return UNDEFINED_COLUMN_ORDER;}
967b09676308edcac0681378a886b900f8f149384e3e674b5255b5da11514594
typeDefined
public static ColumnOrder typeDefined()
{    return TYPE_DEFINED_COLUMN_ORDER;}
ae6dcf1015ff1c7b01ba2b5ca6b726f189e33ab4c2c3c8589ec4454bd9d1df1d
getColumnOrderName
public ColumnOrderName getColumnOrderName()
{    return columnOrderName;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (obj instanceof ColumnOrder) {        return columnOrderName == ((ColumnOrder) obj).columnOrderName;    }    return false;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return columnOrderName.hashCode();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return columnOrderName.toString();}
4c12f3172546db5527d99e7f6e592228a40fec2dcbc246d953e08e7071f36331
listWrapper
private static GroupType listWrapper(Repetition repetition, String alias, LogicalTypeAnnotation logicalTypeAnnotation, Type nested)
{    if (!nested.isRepetition(Repetition.REPEATED)) {        throw new IllegalArgumentException("Nested type should be repeated: " + nested);    }    return new GroupType(repetition, alias, logicalTypeAnnotation, nested);}
4b4fc81d6c765ac25e810cd57a312df83b0520bbaff50afa07ebe0aea42174a7
mapType
public static GroupType mapType(Repetition repetition, String alias, Type keyType, Type valueType)
{    return mapType(repetition, alias, "map", keyType, valueType);}
7631ba3757d82c3fe15998d010e9db7f23cd7a29608bac1aa3fb7d8b2907561a
stringKeyMapType
public static GroupType stringKeyMapType(Repetition repetition, String alias, String mapAlias, Type valueType)
{    return mapType(repetition, alias, mapAlias, new PrimitiveType(Repetition.REQUIRED, PrimitiveTypeName.BINARY, "key", stringType()), valueType);}
b137cb799dd009d6d8ad0b44559c323443eedd40353a48b0587e7ac1280c7952
stringKeyMapType
public static GroupType stringKeyMapType(Repetition repetition, String alias, Type valueType)
{    return stringKeyMapType(repetition, alias, "map", valueType);}
e205f8ed91af26cbe6d6dba3a9488cf5d39237a2fe4d110aa060e409b11133c8
mapType
public static GroupType mapType(Repetition repetition, String alias, String mapAlias, Type keyType, Type valueType)
{        if (valueType == null) {        return listWrapper(repetition, alias, LogicalTypeAnnotation.mapType(), new GroupType(Repetition.REPEATED, mapAlias, LogicalTypeAnnotation.MapKeyValueTypeAnnotation.getInstance(), keyType));    } else {        if (!valueType.getName().equals("value")) {            throw new RuntimeException(valueType.getName() + " should be value");        }        return listWrapper(repetition, alias, LogicalTypeAnnotation.mapType(), new GroupType(Repetition.REPEATED, mapAlias, LogicalTypeAnnotation.MapKeyValueTypeAnnotation.getInstance(), keyType, valueType));    }}
be0abc025c197e6f7cbf159f20426790db5a533b87fce0d3d045ff7a8aabf3c3
listType
public static GroupType listType(Repetition repetition, String alias, Type nestedType)
{    return listWrapper(repetition, alias, LogicalTypeAnnotation.listType(), nestedType);}
b318e447b2aea534d04692dae23fa2ce033e79c70d6de4f450b8d065008f5084
listOfElements
public static GroupType listOfElements(Repetition listRepetition, String name, Type elementType)
{    Preconditions.checkArgument(elementType.getName().equals(ELEMENT_NAME), "List element type must be named 'element'");    return listWrapper(listRepetition, name, LogicalTypeAnnotation.listType(), new GroupType(Repetition.REPEATED, "list", elementType));}
04b0d6ce48769ecd57e9f98b18b0ae90ce26ff84d57caeb757b661ab95767ae9
getPrecision
public int getPrecision()
{    return precision;}
ea33ee7ee3f2a787129440e365474df599156f24ce9f2ea68dbbefd7f8f25d0a
getScale
public int getScale()
{    return scale;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    DecimalMetadata that = (DecimalMetadata) o;    if (precision != that.precision)        return false;    if (scale != that.scale)        return false;    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = precision;    result = 31 * result + scale;    return result;}
0474adb1906504660c75fcef113ddef2746e867fd88ea98e6d0e78ecbbd11e60
withId
public GroupType withId(int id)
{    return new GroupType(getRepetition(), getName(), getLogicalTypeAnnotation(), fields, new ID(id));}
d749acc91bd916e27e2ec18d7353be12111f2d4b11cc3b7e46c27a5ba621f854
withNewFields
public GroupType withNewFields(List<Type> newFields)
{    return new GroupType(getRepetition(), getName(), getLogicalTypeAnnotation(), newFields, getId());}
2f096b19a90fbac05c975660d409d2ce322111c1921300c11e149e6eae73e0b5
withNewFields
public GroupType withNewFields(Type... newFields)
{    return withNewFields(asList(newFields));}
34d8ad3f894ab65b556b94c2420341c9b94253747c2ae0215bc44640480ee4b3
getFieldName
public String getFieldName(int index)
{    return fields.get(index).getName();}
5c45ff6773840f9b2054262487c1007215a8594efbf66d99e39f837315b82db8
containsField
public boolean containsField(String name)
{    return indexByName.containsKey(name);}
612a3b9ecfb79e4e3121e22742ae44de7f70393bb759c6ee75b9a5df0d2440eb
getFieldIndex
public int getFieldIndex(String name)
{    if (!indexByName.containsKey(name)) {        throw new InvalidRecordException(name + " not found in " + this);    }    return indexByName.get(name);}
0409f18b0749c18805963eea4f1269a07f79a6e861f724dff01dddbac5c977a5
getFields
public List<Type> getFields()
{    return fields;}
910758f7f0f22b0baa18afdb66d1380a61dd91848ed2577825e1a612ec37ea4f
getFieldCount
public int getFieldCount()
{    return fields.size();}
64b386a1706abe6de0c11f54f47cc84c8f77c5767e36fb8f820311d6c95a4a53
isPrimitive
public boolean isPrimitive()
{    return false;}
8e03a0b971c1f56b81c7aaaa64d00c814fd8ee692479a5d861b5c3e50b156b1d
getType
public Type getType(String fieldName)
{    return getType(getFieldIndex(fieldName));}
50d581e25577e73255a7f67ee6f8d46ee72c2105bbc4f913950b70075d605cb6
getType
public Type getType(int index)
{    return fields.get(index);}
fe27fc38ee2461d52346e9dfc89eb5e39333c1d0dc34f12548a78ae52b8edb2a
membersDisplayString
 void membersDisplayString(StringBuilder sb, String indent)
{    for (Type field : fields) {        field.writeToStringBuilder(sb, indent);        if (field.isPrimitive()) {            sb.append(";");        }        sb.append("\n");    }}
570d63fa9161ce008cc98d277ee34a13e1e542dbd5d92f09aca9a175e0a6a4ec
writeToStringBuilder
public void writeToStringBuilder(StringBuilder sb, String indent)
{    sb.append(indent).append(getRepetition().name().toLowerCase(Locale.ENGLISH)).append(" group ").append(getName()).append(getLogicalTypeAnnotation() == null ? "" : " (" + getLogicalTypeAnnotation().toString() + ")").append(getId() == null ? "" : " = " + getId()).append(" {\n");    membersDisplayString(sb, indent + "  ");    sb.append(indent).append("}");}
2ad4b24ef83d8afa81e2d7b1e6065156660a84c40b37119571edf7a59e7a5faa
accept
public void accept(TypeVisitor visitor)
{    visitor.visit(this);}
b695161937f56f11b33dc6daabe8047ae45cb84ba3d956fdd0bd870677ce1a1f
typeHashCode
protected int typeHashCode()
{    return hashCode();}
e2a6f02e8d484cb4743d48aef56cdd15a05308f099fb0949572d3b4e4f7b3a8b
typeEquals
protected boolean typeEquals(Type other)
{    return equals(other);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return Objects.hash(getLogicalTypeAnnotation(), getFields());}
a3cd06296c159b8a9706eacd0e27fc85dd48b44316a6fcda24d2e50062413aae
equals
protected boolean equals(Type otherType)
{    return !otherType.isPrimitive() && super.equals(otherType) && Objects.equals(getLogicalTypeAnnotation(), otherType.getLogicalTypeAnnotation()) && getFields().equals(otherType.asGroupType().getFields());}
82ba0e67e7b3aae7176d34f9cd76a5cc51d43e32526cd0e1263d43d6c0d7a873
getMaxRepetitionLevel
protected int getMaxRepetitionLevel(String[] path, int depth)
{    int myVal = isRepetition(Repetition.REPEATED) ? 1 : 0;    if (depth == path.length) {        return myVal;    }    return myVal + getType(path[depth]).getMaxRepetitionLevel(path, depth + 1);}
30962333b7cd1e525b70c3770d4f6f40b6c2745f81e8556a3ab9e8ac91d92676
getMaxDefinitionLevel
protected int getMaxDefinitionLevel(String[] path, int depth)
{    int myVal = !isRepetition(Repetition.REQUIRED) ? 1 : 0;    if (depth == path.length) {        return myVal;    }    return myVal + getType(path[depth]).getMaxDefinitionLevel(path, depth + 1);}
438c79a15cb130a39e19a33d5dd05b2dd369342548b5ffcc42112835412c0eb2
getType
protected Type getType(String[] path, int depth)
{    if (depth == path.length) {        return this;    }    return getType(path[depth]).getType(path, depth + 1);}
1262e7fc42cd901269c3df711f8e81798a5a5c1bb9c6c43c92a2e5a78d45e938
containsPath
protected boolean containsPath(String[] path, int depth)
{    if (depth == path.length) {        return false;    }    return containsField(path[depth]) && getType(path[depth]).containsPath(path, depth + 1);}
847d08310ad3a43210eb37221a4a840c2d254855161bbdaf6afc974c9c40f40f
getPaths
protected List<String[]> getPaths(int depth)
{    List<String[]> result = new ArrayList<String[]>();    for (Type field : fields) {        List<String[]> paths = field.getPaths(depth + 1);        for (String[] path : paths) {            path[depth] = field.getName();            result.add(path);        }    }    return result;}
49ab76876c091464c2cbd59a15c8cd1bc0d1de302dd739e09cf4d50ef9d48c01
checkContains
 void checkContains(Type subType)
{    super.checkContains(subType);    checkGroupContains(subType);}
7e8888b6fcec6d551ca9ffa76b88a6dbee4f163ce89b9d76bab4552c9c29a134
checkGroupContains
 void checkGroupContains(Type subType)
{    if (subType.isPrimitive()) {        throw new InvalidRecordException(subType + " found: expected " + this);    }    List<Type> fields = subType.asGroupType().getFields();    for (Type otherType : fields) {        Type thisType = this.getType(otherType.getName());        thisType.checkContains(otherType);    }}
ded28c32f9e20d8961d256afd5f58da6bf521b433551c44808bee8d4f2b45e6e
convert
 T convert(List<GroupType> path, TypeConverter<T> converter)
{    List<GroupType> childrenPath = new ArrayList<GroupType>(path);    childrenPath.add(this);    final List<T> children = convertChildren(childrenPath, converter);    return converter.convertGroupType(path, this, children);}
7e169cb4009f41c0fc20e3125552d9f22369a2461787d455326d09c05b864b2f
convertChildren
protected List<T> convertChildren(List<GroupType> path, TypeConverter<T> converter)
{    List<T> children = new ArrayList<T>(fields.size());    for (Type field : fields) {        children.add(field.convert(path, converter));    }    return children;}
d966b5390003baeb4fea1b04eb1ea49d077ca302c5aad973f0b18753d637d922
union
protected Type union(Type toMerge)
{    return union(toMerge, true);}
20c2a1b030e0df8b9e83ef8192d32104a0e25404f00b6dabcfcc7fbb2078f0f2
union
protected Type union(Type toMerge, boolean strict)
{    if (toMerge.isPrimitive()) {        throw new IncompatibleSchemaModificationException("can not merge primitive type " + toMerge + " into group type " + this);    }    return new GroupType(toMerge.getRepetition(), getName(), toMerge.getLogicalTypeAnnotation(), mergeFields(toMerge.asGroupType()), getId());}
d1736168e3d51370d4368378a8caf9fbcf1e0545a3ad5ebe747c22efed2f65b0
mergeFields
 List<Type> mergeFields(GroupType toMerge)
{    return mergeFields(toMerge, true);}
838e241d5f75d64ce0a12e5b604ec63baba5cfd6a80bc54ca741a0241b886c21
mergeFields
 List<Type> mergeFields(GroupType toMerge, boolean strict)
{    List<Type> newFields = new ArrayList<Type>();        for (Type type : this.getFields()) {        Type merged;        if (toMerge.containsField(type.getName())) {            Type fieldToMerge = toMerge.getType(type.getName());            if (type.getLogicalTypeAnnotation() != null && !type.getLogicalTypeAnnotation().equals(fieldToMerge.getLogicalTypeAnnotation())) {                throw new IncompatibleSchemaModificationException("cannot merge logical type " + fieldToMerge.getLogicalTypeAnnotation() + " into " + type.getLogicalTypeAnnotation());            }            merged = type.union(fieldToMerge, strict);        } else {            merged = type;        }        newFields.add(merged);    }        for (Type type : toMerge.getFields()) {        if (!this.containsField(type.getName())) {            newFields.add(type);        }    }    return newFields;}
fd52234a1a752354e7476bd664b7fdda80278571e22832a16548eee4c40bdfbe
fromString
protected LogicalTypeAnnotation fromString(List<String> params)
{    return mapType();}
fd52234a1a752354e7476bd664b7fdda80278571e22832a16548eee4c40bdfbe
fromString
protected LogicalTypeAnnotation fromString(List<String> params)
{    return listType();}
fd52234a1a752354e7476bd664b7fdda80278571e22832a16548eee4c40bdfbe
fromString
protected LogicalTypeAnnotation fromString(List<String> params)
{    return stringType();}
fd52234a1a752354e7476bd664b7fdda80278571e22832a16548eee4c40bdfbe
fromString
protected LogicalTypeAnnotation fromString(List<String> params)
{    return MapKeyValueTypeAnnotation.getInstance();}
fd52234a1a752354e7476bd664b7fdda80278571e22832a16548eee4c40bdfbe
fromString
protected LogicalTypeAnnotation fromString(List<String> params)
{    return enumType();}
fd52234a1a752354e7476bd664b7fdda80278571e22832a16548eee4c40bdfbe
fromString
protected LogicalTypeAnnotation fromString(List<String> params)
{    if (params.size() != 2) {        throw new RuntimeException("Expecting 2 parameters for decimal logical type, got " + params.size());    }    return decimalType(Integer.valueOf(params.get(1)), Integer.valueOf(params.get(0)));}
fd52234a1a752354e7476bd664b7fdda80278571e22832a16548eee4c40bdfbe
fromString
protected LogicalTypeAnnotation fromString(List<String> params)
{    return dateType();}
fd52234a1a752354e7476bd664b7fdda80278571e22832a16548eee4c40bdfbe
fromString
protected LogicalTypeAnnotation fromString(List<String> params)
{    if (params.size() != 2) {        throw new RuntimeException("Expecting 2 parameters for time logical type, got " + params.size());    }    return timeType(Boolean.parseBoolean(params.get(1)), TimeUnit.valueOf(params.get(0)));}
fd52234a1a752354e7476bd664b7fdda80278571e22832a16548eee4c40bdfbe
fromString
protected LogicalTypeAnnotation fromString(List<String> params)
{    if (params.size() != 2) {        throw new RuntimeException("Expecting 2 parameters for timestamp logical type, got " + params.size());    }    return timestampType(Boolean.parseBoolean(params.get(1)), TimeUnit.valueOf(params.get(0)));}
fd52234a1a752354e7476bd664b7fdda80278571e22832a16548eee4c40bdfbe
fromString
protected LogicalTypeAnnotation fromString(List<String> params)
{    if (params.size() != 2) {        throw new RuntimeException("Expecting 2 parameters for integer logical type, got " + params.size());    }    return intType(Integer.valueOf(params.get(0)), Boolean.parseBoolean(params.get(1)));}
fd52234a1a752354e7476bd664b7fdda80278571e22832a16548eee4c40bdfbe
fromString
protected LogicalTypeAnnotation fromString(List<String> params)
{    return jsonType();}
fd52234a1a752354e7476bd664b7fdda80278571e22832a16548eee4c40bdfbe
fromString
protected LogicalTypeAnnotation fromString(List<String> params)
{    return bsonType();}
fd52234a1a752354e7476bd664b7fdda80278571e22832a16548eee4c40bdfbe
fromString
protected LogicalTypeAnnotation fromString(List<String> params)
{    return IntervalLogicalTypeAnnotation.getInstance();}
4985128bfee579b5f462b74f57cba94adf6560e439ad6e8d3484fe074c5d5367
typeParametersAsString
 String typeParametersAsString()
{    return "";}
a8d5b7f9f3281be4bf07f61dd2251733b8edfd30c529d79313003bac262f2f90
isValidColumnOrder
 boolean isValidColumnOrder(ColumnOrder columnOrder)
{    return columnOrder.getColumnOrderName() == UNDEFINED || columnOrder.getColumnOrderName() == TYPE_DEFINED_ORDER;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder();    sb.append(getType());    sb.append(typeParametersAsString());    return sb.toString();}
5dad89505256a0f8389fd86fd96ea6d61b5c94a99ac28b0a3ed3bf844bfdc6dc
valueStringifier
 PrimitiveStringifier valueStringifier(PrimitiveType primitiveType)
{    throw new UnsupportedOperationException("Stringifier is not supported for the logical type: " + this);}
68caad3a81f981aeb436d411b040fe08b77d8a53864899450cf9e83bdace69a6
fromOriginalType
public static LogicalTypeAnnotation fromOriginalType(OriginalType originalType, DecimalMetadata decimalMetadata)
{    if (originalType == null) {        return null;    }    switch(originalType) {        case UTF8:            return stringType();        case MAP:            return mapType();        case DECIMAL:            int scale = (decimalMetadata == null ? 0 : decimalMetadata.getScale());            int precision = (decimalMetadata == null ? 0 : decimalMetadata.getPrecision());            return decimalType(scale, precision);        case LIST:            return listType();        case DATE:            return dateType();        case INTERVAL:            return IntervalLogicalTypeAnnotation.getInstance();        case TIMESTAMP_MILLIS:            return timestampType(true, LogicalTypeAnnotation.TimeUnit.MILLIS);        case TIMESTAMP_MICROS:            return timestampType(true, LogicalTypeAnnotation.TimeUnit.MICROS);        case TIME_MILLIS:            return timeType(true, LogicalTypeAnnotation.TimeUnit.MILLIS);        case TIME_MICROS:            return timeType(true, LogicalTypeAnnotation.TimeUnit.MICROS);        case UINT_8:            return intType(8, false);        case UINT_16:            return intType(16, false);        case UINT_32:            return intType(32, false);        case UINT_64:            return intType(64, false);        case INT_8:            return intType(8, true);        case INT_16:            return intType(16, true);        case INT_32:            return intType(32, true);        case INT_64:            return intType(64, true);        case ENUM:            return enumType();        case JSON:            return jsonType();        case BSON:            return bsonType();        case MAP_KEY_VALUE:            return MapKeyValueTypeAnnotation.getInstance();        default:            throw new RuntimeException("Can't convert original type to logical type, unknown original type " + originalType);    }}
f7ed29c6a9dc25fecb7137e883041ed6a6bc73e227f8041f7c5a16753b8f905c
stringType
public static StringLogicalTypeAnnotation stringType()
{    return StringLogicalTypeAnnotation.INSTANCE;}
8c96c2c80fa4250853ba1c6d9c3f5440088eac81f74be9fcaf09929bfe47307a
mapType
public static MapLogicalTypeAnnotation mapType()
{    return MapLogicalTypeAnnotation.INSTANCE;}
37e2aff5826548dd7084bbd9ce9ed0be3a61691d50ac2e256e5147cd2cbcca71
listType
public static ListLogicalTypeAnnotation listType()
{    return ListLogicalTypeAnnotation.INSTANCE;}
9792d5e5bede2489dfb1eacd894af324b4ccbf05b59ced45248368a07a1d35c0
enumType
public static EnumLogicalTypeAnnotation enumType()
{    return EnumLogicalTypeAnnotation.INSTANCE;}
8a11c42e3ccaa5fa50ed838f2f49985aa4e75e1f660341b2c3f1e5c0d62018ff
decimalType
public static DecimalLogicalTypeAnnotation decimalType(final int scale, final int precision)
{    return new DecimalLogicalTypeAnnotation(scale, precision);}
e63d80dd87b0e1d9a1bbb386e2e66b34abc57364d13ea90db9a211150cca857b
dateType
public static DateLogicalTypeAnnotation dateType()
{    return DateLogicalTypeAnnotation.INSTANCE;}
41c79741db308b9664f8bca513e7786b179bc17b6433a404b65be7d74ec018e6
timeType
public static TimeLogicalTypeAnnotation timeType(final boolean isAdjustedToUTC, final TimeUnit unit)
{    return new TimeLogicalTypeAnnotation(isAdjustedToUTC, unit);}
488525bba4eaa6cd7f785142d9ec2c08ae7bd9d1988ba64b5c78d6bb7821c414
timestampType
public static TimestampLogicalTypeAnnotation timestampType(final boolean isAdjustedToUTC, final TimeUnit unit)
{    return new TimestampLogicalTypeAnnotation(isAdjustedToUTC, unit);}
4f2987257a56a66d2211e3012bf4c81f5278d6cf3c11f9c48e59d6d47c353a7f
intType
public static IntLogicalTypeAnnotation intType(final int bitWidth, final boolean isSigned)
{    Preconditions.checkArgument(bitWidth == 8 || bitWidth == 16 || bitWidth == 32 || bitWidth == 64, "Invalid bit width for integer logical type, " + bitWidth + " is not allowed, " + "valid bit width values: 8, 16, 32, 64");    return new IntLogicalTypeAnnotation(bitWidth, isSigned);}
894fe52c8d1540d4c075141d8c87cd2d1df316e36ec16339de7a8fb220685047
jsonType
public static JsonLogicalTypeAnnotation jsonType()
{    return JsonLogicalTypeAnnotation.INSTANCE;}
f1a798c083bcb641225f7755a1c79822fbcff5e5b47f360e9e1e57e972421ed1
bsonType
public static BsonLogicalTypeAnnotation bsonType()
{    return BsonLogicalTypeAnnotation.INSTANCE;}
372c6d47bdf6c353a6fb49b361e57d4a9e00700d8ff774a3f8f463c1dfe55fda
toOriginalType
public OriginalType toOriginalType()
{    return OriginalType.UTF8;}
34da2838b36c00c21f964f6edb351a2761a54959ff77997fa40fc62a8aa95117
accept
public Optional<T> accept(LogicalTypeAnnotationVisitor<T> logicalTypeAnnotationVisitor)
{    return logicalTypeAnnotationVisitor.visit(this);}
9f8e7632898605031c07f87070d8844099d8828c373a0726fe874eaa2e56b4bd
getType
 LogicalTypeToken getType()
{    return LogicalTypeToken.STRING;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    return obj instanceof StringLogicalTypeAnnotation;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{        return getClass().hashCode();}
5dad89505256a0f8389fd86fd96ea6d61b5c94a99ac28b0a3ed3bf844bfdc6dc
valueStringifier
 PrimitiveStringifier valueStringifier(PrimitiveType primitiveType)
{    return PrimitiveStringifier.UTF8_STRINGIFIER;}
372c6d47bdf6c353a6fb49b361e57d4a9e00700d8ff774a3f8f463c1dfe55fda
toOriginalType
public OriginalType toOriginalType()
{    return OriginalType.MAP;}
34da2838b36c00c21f964f6edb351a2761a54959ff77997fa40fc62a8aa95117
accept
public Optional<T> accept(LogicalTypeAnnotationVisitor<T> logicalTypeAnnotationVisitor)
{    return logicalTypeAnnotationVisitor.visit(this);}
9f8e7632898605031c07f87070d8844099d8828c373a0726fe874eaa2e56b4bd
getType
 LogicalTypeToken getType()
{    return LogicalTypeToken.MAP;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    return obj instanceof MapLogicalTypeAnnotation;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{        return getClass().hashCode();}
372c6d47bdf6c353a6fb49b361e57d4a9e00700d8ff774a3f8f463c1dfe55fda
toOriginalType
public OriginalType toOriginalType()
{    return OriginalType.LIST;}
34da2838b36c00c21f964f6edb351a2761a54959ff77997fa40fc62a8aa95117
accept
public Optional<T> accept(LogicalTypeAnnotationVisitor<T> logicalTypeAnnotationVisitor)
{    return logicalTypeAnnotationVisitor.visit(this);}
9f8e7632898605031c07f87070d8844099d8828c373a0726fe874eaa2e56b4bd
getType
 LogicalTypeToken getType()
{    return LogicalTypeToken.LIST;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    return obj instanceof ListLogicalTypeAnnotation;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{        return getClass().hashCode();}
372c6d47bdf6c353a6fb49b361e57d4a9e00700d8ff774a3f8f463c1dfe55fda
toOriginalType
public OriginalType toOriginalType()
{    return OriginalType.ENUM;}
34da2838b36c00c21f964f6edb351a2761a54959ff77997fa40fc62a8aa95117
accept
public Optional<T> accept(LogicalTypeAnnotationVisitor<T> logicalTypeAnnotationVisitor)
{    return logicalTypeAnnotationVisitor.visit(this);}
9f8e7632898605031c07f87070d8844099d8828c373a0726fe874eaa2e56b4bd
getType
 LogicalTypeToken getType()
{    return LogicalTypeToken.ENUM;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    return obj instanceof EnumLogicalTypeAnnotation;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{        return getClass().hashCode();}
5dad89505256a0f8389fd86fd96ea6d61b5c94a99ac28b0a3ed3bf844bfdc6dc
valueStringifier
 PrimitiveStringifier valueStringifier(PrimitiveType primitiveType)
{    return PrimitiveStringifier.UTF8_STRINGIFIER;}
04b0d6ce48769ecd57e9f98b18b0ae90ce26ff84d57caeb757b661ab95767ae9
getPrecision
public int getPrecision()
{    return precision;}
ea33ee7ee3f2a787129440e365474df599156f24ce9f2ea68dbbefd7f8f25d0a
getScale
public int getScale()
{    return scale;}
372c6d47bdf6c353a6fb49b361e57d4a9e00700d8ff774a3f8f463c1dfe55fda
toOriginalType
public OriginalType toOriginalType()
{    return OriginalType.DECIMAL;}
34da2838b36c00c21f964f6edb351a2761a54959ff77997fa40fc62a8aa95117
accept
public Optional<T> accept(LogicalTypeAnnotationVisitor<T> logicalTypeAnnotationVisitor)
{    return logicalTypeAnnotationVisitor.visit(this);}
9f8e7632898605031c07f87070d8844099d8828c373a0726fe874eaa2e56b4bd
getType
 LogicalTypeToken getType()
{    return LogicalTypeToken.DECIMAL;}
887e581bc9f0818362b190c8c81fc82a8aa4eb0d1b01b4582e138bca22d1b6c1
typeParametersAsString
protected String typeParametersAsString()
{    StringBuilder sb = new StringBuilder();    sb.append("(");    sb.append(precision);    sb.append(",");    sb.append(scale);    sb.append(")");    return sb.toString();}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (!(obj instanceof DecimalLogicalTypeAnnotation)) {        return false;    }    DecimalLogicalTypeAnnotation other = (DecimalLogicalTypeAnnotation) obj;    return scale == other.scale && precision == other.precision;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return Objects.hash(scale, precision);}
5dad89505256a0f8389fd86fd96ea6d61b5c94a99ac28b0a3ed3bf844bfdc6dc
valueStringifier
 PrimitiveStringifier valueStringifier(PrimitiveType primitiveType)
{    return stringifier;}
372c6d47bdf6c353a6fb49b361e57d4a9e00700d8ff774a3f8f463c1dfe55fda
toOriginalType
public OriginalType toOriginalType()
{    return OriginalType.DATE;}
34da2838b36c00c21f964f6edb351a2761a54959ff77997fa40fc62a8aa95117
accept
public Optional<T> accept(LogicalTypeAnnotationVisitor<T> logicalTypeAnnotationVisitor)
{    return logicalTypeAnnotationVisitor.visit(this);}
9f8e7632898605031c07f87070d8844099d8828c373a0726fe874eaa2e56b4bd
getType
 LogicalTypeToken getType()
{    return LogicalTypeToken.DATE;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    return obj instanceof DateLogicalTypeAnnotation;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{        return getClass().hashCode();}
5dad89505256a0f8389fd86fd96ea6d61b5c94a99ac28b0a3ed3bf844bfdc6dc
valueStringifier
 PrimitiveStringifier valueStringifier(PrimitiveType primitiveType)
{    return PrimitiveStringifier.DATE_STRINGIFIER;}
372c6d47bdf6c353a6fb49b361e57d4a9e00700d8ff774a3f8f463c1dfe55fda
toOriginalType
public OriginalType toOriginalType()
{    if (!isAdjustedToUTC) {        return null;    }    switch(unit) {        case MILLIS:            return OriginalType.TIME_MILLIS;        case MICROS:            return OriginalType.TIME_MICROS;        default:            return null;    }}
34da2838b36c00c21f964f6edb351a2761a54959ff77997fa40fc62a8aa95117
accept
public Optional<T> accept(LogicalTypeAnnotationVisitor<T> logicalTypeAnnotationVisitor)
{    return logicalTypeAnnotationVisitor.visit(this);}
9f8e7632898605031c07f87070d8844099d8828c373a0726fe874eaa2e56b4bd
getType
 LogicalTypeToken getType()
{    return LogicalTypeToken.TIME;}
887e581bc9f0818362b190c8c81fc82a8aa4eb0d1b01b4582e138bca22d1b6c1
typeParametersAsString
protected String typeParametersAsString()
{    StringBuilder sb = new StringBuilder();    sb.append("(");    sb.append(unit);    sb.append(",");    sb.append(isAdjustedToUTC);    sb.append(")");    return sb.toString();}
5fd85406721f112735ed88b4d7938e612a4bf55e94d25f23ab7f9c1a6aea7fd1
getUnit
public TimeUnit getUnit()
{    return unit;}
fbbfe4f9f353d53f7ecbcd32fe450a044a1df25dc561fa8836b469a7a7310651
isAdjustedToUTC
public boolean isAdjustedToUTC()
{    return isAdjustedToUTC;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (!(obj instanceof TimeLogicalTypeAnnotation)) {        return false;    }    TimeLogicalTypeAnnotation other = (TimeLogicalTypeAnnotation) obj;    return isAdjustedToUTC == other.isAdjustedToUTC && unit == other.unit;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return Objects.hash(isAdjustedToUTC, unit);}
5dad89505256a0f8389fd86fd96ea6d61b5c94a99ac28b0a3ed3bf844bfdc6dc
valueStringifier
 PrimitiveStringifier valueStringifier(PrimitiveType primitiveType)
{    switch(unit) {        case MICROS:        case MILLIS:            return isAdjustedToUTC ? TIME_UTC_STRINGIFIER : TIME_STRINGIFIER;        case NANOS:            return isAdjustedToUTC ? TIME_NANOS_UTC_STRINGIFIER : TIME_NANOS_STRINGIFIER;        default:            return super.valueStringifier(primitiveType);    }}
372c6d47bdf6c353a6fb49b361e57d4a9e00700d8ff774a3f8f463c1dfe55fda
toOriginalType
public OriginalType toOriginalType()
{    if (!isAdjustedToUTC) {        return null;    }    switch(unit) {        case MILLIS:            return OriginalType.TIMESTAMP_MILLIS;        case MICROS:            return OriginalType.TIMESTAMP_MICROS;        default:            return null;    }}
34da2838b36c00c21f964f6edb351a2761a54959ff77997fa40fc62a8aa95117
accept
public Optional<T> accept(LogicalTypeAnnotationVisitor<T> logicalTypeAnnotationVisitor)
{    return logicalTypeAnnotationVisitor.visit(this);}
9f8e7632898605031c07f87070d8844099d8828c373a0726fe874eaa2e56b4bd
getType
 LogicalTypeToken getType()
{    return LogicalTypeToken.TIMESTAMP;}
887e581bc9f0818362b190c8c81fc82a8aa4eb0d1b01b4582e138bca22d1b6c1
typeParametersAsString
protected String typeParametersAsString()
{    StringBuilder sb = new StringBuilder();    sb.append("(");    sb.append(unit);    sb.append(",");    sb.append(isAdjustedToUTC);    sb.append(")");    return sb.toString();}
5fd85406721f112735ed88b4d7938e612a4bf55e94d25f23ab7f9c1a6aea7fd1
getUnit
public TimeUnit getUnit()
{    return unit;}
fbbfe4f9f353d53f7ecbcd32fe450a044a1df25dc561fa8836b469a7a7310651
isAdjustedToUTC
public boolean isAdjustedToUTC()
{    return isAdjustedToUTC;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (!(obj instanceof TimestampLogicalTypeAnnotation)) {        return false;    }    TimestampLogicalTypeAnnotation other = (TimestampLogicalTypeAnnotation) obj;    return (isAdjustedToUTC == other.isAdjustedToUTC) && (unit == other.unit);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return Objects.hash(isAdjustedToUTC, unit);}
5dad89505256a0f8389fd86fd96ea6d61b5c94a99ac28b0a3ed3bf844bfdc6dc
valueStringifier
 PrimitiveStringifier valueStringifier(PrimitiveType primitiveType)
{    switch(unit) {        case MICROS:            return isAdjustedToUTC ? TIMESTAMP_MICROS_UTC_STRINGIFIER : TIMESTAMP_MICROS_STRINGIFIER;        case MILLIS:            return isAdjustedToUTC ? TIMESTAMP_MILLIS_UTC_STRINGIFIER : TIMESTAMP_MILLIS_STRINGIFIER;        case NANOS:            return isAdjustedToUTC ? TIMESTAMP_NANOS_UTC_STRINGIFIER : TIMESTAMP_NANOS_STRINGIFIER;        default:            return super.valueStringifier(primitiveType);    }}
372c6d47bdf6c353a6fb49b361e57d4a9e00700d8ff774a3f8f463c1dfe55fda
toOriginalType
public OriginalType toOriginalType()
{    switch(bitWidth) {        case 8:            return isSigned ? OriginalType.INT_8 : OriginalType.UINT_8;        case 16:            return isSigned ? OriginalType.INT_16 : OriginalType.UINT_16;        case 32:            return isSigned ? OriginalType.INT_32 : OriginalType.UINT_32;        case 64:            return isSigned ? OriginalType.INT_64 : OriginalType.UINT_64;        default:            return null;    }}
34da2838b36c00c21f964f6edb351a2761a54959ff77997fa40fc62a8aa95117
accept
public Optional<T> accept(LogicalTypeAnnotationVisitor<T> logicalTypeAnnotationVisitor)
{    return logicalTypeAnnotationVisitor.visit(this);}
9f8e7632898605031c07f87070d8844099d8828c373a0726fe874eaa2e56b4bd
getType
 LogicalTypeToken getType()
{    return LogicalTypeToken.INTEGER;}
887e581bc9f0818362b190c8c81fc82a8aa4eb0d1b01b4582e138bca22d1b6c1
typeParametersAsString
protected String typeParametersAsString()
{    StringBuilder sb = new StringBuilder();    sb.append("(");    sb.append(bitWidth);    sb.append(",");    sb.append(isSigned);    sb.append(")");    return sb.toString();}
633370e7ce2cff034d8750e434c2fec5965fb581ba433342b5c11d28f6895499
getBitWidth
public int getBitWidth()
{    return bitWidth;}
706b5b397559bf53f31bcd4717bb4b536d71c4ef6804e61c59188558ba0edcbf
isSigned
public boolean isSigned()
{    return isSigned;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (!(obj instanceof IntLogicalTypeAnnotation)) {        return false;    }    IntLogicalTypeAnnotation other = (IntLogicalTypeAnnotation) obj;    return (bitWidth == other.bitWidth) && (isSigned == other.isSigned);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return Objects.hash(bitWidth, isSigned);}
5dad89505256a0f8389fd86fd96ea6d61b5c94a99ac28b0a3ed3bf844bfdc6dc
valueStringifier
 PrimitiveStringifier valueStringifier(PrimitiveType primitiveType)
{    return isSigned ? PrimitiveStringifier.DEFAULT_STRINGIFIER : PrimitiveStringifier.UNSIGNED_STRINGIFIER;}
372c6d47bdf6c353a6fb49b361e57d4a9e00700d8ff774a3f8f463c1dfe55fda
toOriginalType
public OriginalType toOriginalType()
{    return OriginalType.JSON;}
34da2838b36c00c21f964f6edb351a2761a54959ff77997fa40fc62a8aa95117
accept
public Optional<T> accept(LogicalTypeAnnotationVisitor<T> logicalTypeAnnotationVisitor)
{    return logicalTypeAnnotationVisitor.visit(this);}
9f8e7632898605031c07f87070d8844099d8828c373a0726fe874eaa2e56b4bd
getType
 LogicalTypeToken getType()
{    return LogicalTypeToken.JSON;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    return obj instanceof JsonLogicalTypeAnnotation;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{        return getClass().hashCode();}
5dad89505256a0f8389fd86fd96ea6d61b5c94a99ac28b0a3ed3bf844bfdc6dc
valueStringifier
 PrimitiveStringifier valueStringifier(PrimitiveType primitiveType)
{    return PrimitiveStringifier.UTF8_STRINGIFIER;}
372c6d47bdf6c353a6fb49b361e57d4a9e00700d8ff774a3f8f463c1dfe55fda
toOriginalType
public OriginalType toOriginalType()
{    return OriginalType.BSON;}
34da2838b36c00c21f964f6edb351a2761a54959ff77997fa40fc62a8aa95117
accept
public Optional<T> accept(LogicalTypeAnnotationVisitor<T> logicalTypeAnnotationVisitor)
{    return logicalTypeAnnotationVisitor.visit(this);}
9f8e7632898605031c07f87070d8844099d8828c373a0726fe874eaa2e56b4bd
getType
 LogicalTypeToken getType()
{    return LogicalTypeToken.BSON;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    return obj instanceof BsonLogicalTypeAnnotation;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{        return getClass().hashCode();}
5dad89505256a0f8389fd86fd96ea6d61b5c94a99ac28b0a3ed3bf844bfdc6dc
valueStringifier
 PrimitiveStringifier valueStringifier(PrimitiveType primitiveType)
{    return PrimitiveStringifier.DEFAULT_STRINGIFIER;}
ffcc507ab7bc043faafcc7fec3d52759f1ef5f2a1d185c4a2b86d7a6d5b2b588
getInstance
public static LogicalTypeAnnotation getInstance()
{    return INSTANCE;}
372c6d47bdf6c353a6fb49b361e57d4a9e00700d8ff774a3f8f463c1dfe55fda
toOriginalType
public OriginalType toOriginalType()
{    return OriginalType.INTERVAL;}
34da2838b36c00c21f964f6edb351a2761a54959ff77997fa40fc62a8aa95117
accept
public Optional<T> accept(LogicalTypeAnnotationVisitor<T> logicalTypeAnnotationVisitor)
{    return logicalTypeAnnotationVisitor.visit(this);}
9f8e7632898605031c07f87070d8844099d8828c373a0726fe874eaa2e56b4bd
getType
 LogicalTypeToken getType()
{    return LogicalTypeToken.INTERVAL;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    return obj instanceof IntervalLogicalTypeAnnotation;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{        return getClass().hashCode();}
5dad89505256a0f8389fd86fd96ea6d61b5c94a99ac28b0a3ed3bf844bfdc6dc
valueStringifier
 PrimitiveStringifier valueStringifier(PrimitiveType primitiveType)
{    return PrimitiveStringifier.INTERVAL_STRINGIFIER;}
a8d5b7f9f3281be4bf07f61dd2251733b8edfd30c529d79313003bac262f2f90
isValidColumnOrder
 boolean isValidColumnOrder(ColumnOrder columnOrder)
{    return columnOrder.getColumnOrderName() == UNDEFINED;}
7fc4f891f214fe1f8153ac761efe621bf6795a026083ea04c159ca58522b0baf
getInstance
public static MapKeyValueTypeAnnotation getInstance()
{    return INSTANCE;}
372c6d47bdf6c353a6fb49b361e57d4a9e00700d8ff774a3f8f463c1dfe55fda
toOriginalType
public OriginalType toOriginalType()
{    return OriginalType.MAP_KEY_VALUE;}
34da2838b36c00c21f964f6edb351a2761a54959ff77997fa40fc62a8aa95117
accept
public Optional<T> accept(LogicalTypeAnnotationVisitor<T> logicalTypeAnnotationVisitor)
{    return logicalTypeAnnotationVisitor.visit(this);}
9f8e7632898605031c07f87070d8844099d8828c373a0726fe874eaa2e56b4bd
getType
 LogicalTypeToken getType()
{    return LogicalTypeToken.MAP_KEY_VALUE;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    return obj instanceof MapKeyValueTypeAnnotation;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{        return getClass().hashCode();}
e5a277c4a706bcccf2c281945d19b9d15a4236e3ac2862b19b48d0fb4aebcce3
visit
 Optional<T> visit(StringLogicalTypeAnnotation stringLogicalType)
{    return empty();}
af296a02cf3af070e0aafd9047e76f0043d6981ba4046345cd6db2af86356f1d
visit
 Optional<T> visit(MapLogicalTypeAnnotation mapLogicalType)
{    return empty();}
b58a301c5f59181228e050362388b1853758dc160943117c12ef73bda8d33f55
visit
 Optional<T> visit(ListLogicalTypeAnnotation listLogicalType)
{    return empty();}
f4ef7327e11596810222862f9145c1f7edffca7ec587ee8f687470971eea6549
visit
 Optional<T> visit(EnumLogicalTypeAnnotation enumLogicalType)
{    return empty();}
6ad8e527fe9d270826c747519c68f779f9d99bc84a8fa8d93846b3b57c46ac74
visit
 Optional<T> visit(DecimalLogicalTypeAnnotation decimalLogicalType)
{    return empty();}
28e80d8b9ef1dccb2f51379c30e165bf72f0629d5f7698549651bfeaa9cffa4b
visit
 Optional<T> visit(DateLogicalTypeAnnotation dateLogicalType)
{    return empty();}
f3f9ae4c13b366cdb262c0e995bdb5c6565aea821a115163231b774e1d2c4a2d
visit
 Optional<T> visit(TimeLogicalTypeAnnotation timeLogicalType)
{    return empty();}
ad121bd843780a57db15b3f4abf719d4f74a003a616e21f4a9a72a1fd2b1ea28
visit
 Optional<T> visit(TimestampLogicalTypeAnnotation timestampLogicalType)
{    return empty();}
48486ff5fb637060bbad27d738bbe1cd690e0be503fc4bc4d0be85b16e3548fb
visit
 Optional<T> visit(IntLogicalTypeAnnotation intLogicalType)
{    return empty();}
f42a7ded5ae065963cb393c7be43d39f6dbc49ccb072dc1ad4ee42e295345bd0
visit
 Optional<T> visit(JsonLogicalTypeAnnotation jsonLogicalType)
{    return empty();}
a57398887a5a57a6e2cd4b5c617da1b2681caf1e93f895d603cd27f37f395424
visit
 Optional<T> visit(BsonLogicalTypeAnnotation bsonLogicalType)
{    return empty();}
0260d9303ac0f0a03d2c47aa4e73404935aa9f7ad43e979731d772d95974a71f
visit
 Optional<T> visit(IntervalLogicalTypeAnnotation intervalLogicalType)
{    return empty();}
9d44f18a67a78eb2f6eae66cb88d952ad95970183b253a3b3ee4ad62148d2172
visit
 Optional<T> visit(MapKeyValueTypeAnnotation mapKeyValueLogicalType)
{    return empty();}
2ad4b24ef83d8afa81e2d7b1e6065156660a84c40b37119571edf7a59e7a5faa
accept
public void accept(TypeVisitor visitor)
{    visitor.visit(this);}
570d63fa9161ce008cc98d277ee34a13e1e542dbd5d92f09aca9a175e0a6a4ec
writeToStringBuilder
public void writeToStringBuilder(StringBuilder sb, String indent)
{    sb.append("message ").append(getName()).append(getLogicalTypeAnnotation() == null ? "" : " (" + getLogicalTypeAnnotation().toString() + ")").append(" {\n");    membersDisplayString(sb, "  ");    sb.append("}\n");}
370c57d896da88581d4fc208a6a434bcb1a81f4a3201e47565aaa1fa880f770f
getMaxRepetitionLevel
public int getMaxRepetitionLevel(String... path)
{    return getMaxRepetitionLevel(path, 0) - 1;}
836cc2f38cdf3d7b3f89d4988e3b306e7c381a2c13aa9acd35c7676b35e066f6
getMaxDefinitionLevel
public int getMaxDefinitionLevel(String... path)
{    return getMaxDefinitionLevel(path, 0) - 1;}
a02a1e5e25cd918485d665dd630490c3c118036ef64f2f3ddc4c51f4bad70295
getType
public Type getType(String... path)
{    return getType(path, 0);}
f0718883de6259f59b3872c2f3e913d01d0377a760f721334bd40a305bfa5bb4
getColumnDescription
public ColumnDescriptor getColumnDescription(String[] path)
{    int maxRep = getMaxRepetitionLevel(path);    int maxDef = getMaxDefinitionLevel(path);    PrimitiveType type = getType(path).asPrimitiveType();    return new ColumnDescriptor(path, type, maxRep, maxDef);}
25820ce1829067103f0879684979a3feecf3974f3ed5095ce05f0ad9d982b376
getPaths
public List<String[]> getPaths()
{    return this.getPaths(0);}
c2b50f56cd065bca52dc778adc9f736882aa84df1f9c826aa4d62f1200e10483
getColumns
public List<ColumnDescriptor> getColumns()
{    List<String[]> paths = this.getPaths(0);    List<ColumnDescriptor> columns = new ArrayList<ColumnDescriptor>(paths.size());    for (String[] path : paths) {                PrimitiveType primitiveType = getType(path).asPrimitiveType();        columns.add(new ColumnDescriptor(path, primitiveType, getMaxRepetitionLevel(path), getMaxDefinitionLevel(path)));    }    return columns;}
6fa1ce097c109a171ce8f3194c8ebd11eae02a81d5c62061d649e639fddef804
checkContains
public void checkContains(Type subType)
{    if (!(subType instanceof MessageType)) {        throw new InvalidRecordException(subType + " found: expected " + this);    }    checkGroupContains(subType);}
c185a440cf8e457c546e6b1c0194b9c069cf1096bdb42ab69df263700be9e55d
convertWith
public T convertWith(TypeConverter<T> converter)
{    final ArrayList<GroupType> path = new ArrayList<GroupType>();    path.add(this);    return converter.convertMessageType(this, convertChildren(path, converter));}
f1c8c8c8f94dce3507abc2e4382c6775d0fce5d174d34b845e77a31522267675
containsPath
public boolean containsPath(String[] path)
{    return containsPath(path, 0);}
9f8ee0d509bc973acebb3ecebfda3375e149df3041ff29797df22d9d16b3b1e0
union
public MessageType union(MessageType toMerge)
{    return union(toMerge, true);}
ccabf96dbf0b3bdaa64f2f587701326746178fe67a6026f9e5604772847ec7ea
union
public MessageType union(MessageType toMerge, boolean strict)
{    return new MessageType(this.getName(), mergeFields(toMerge, strict));}
658953d60efa2230888009b6f3112a63ece2fd3ab95e7a9e48ef0e38d3f4b088
nextToken
public String nextToken()
{    while (st.hasMoreTokens()) {        String t = st.nextToken();        if (t.equals("\n")) {            ++line;            currentLine.setLength(0);        } else {            currentLine.append(t);        }        if (!isWhitespace(t)) {            return t;        }    }    throw new IllegalArgumentException("unexpected end of schema");}
f8be7e72502b63d39e66d9b035ba4e8f92b23fa02e5ef980082f4d97366d9311
isWhitespace
private boolean isWhitespace(String t)
{    return t.equals(" ") || t.equals("\t") || t.equals("\n");}
d6b2b74a2eb99011e24a11bb553f993c1e375e7bd0d404de22eea5d649fedf64
getLocationString
public String getLocationString()
{    return "line " + line + ": " + currentLine.toString();}
4903908ebed14a2816cf5c60892edb1686b1c7dab371c8fe654fb9b270ffb6fe
parseMessageType
public static MessageType parseMessageType(String input)
{    return parse(input);}
7711f44da9098ec86300f955dc51c9c15785a637937f3f6ec1fde934a594a68d
parse
private static MessageType parse(String schemaString)
{    Tokenizer st = new Tokenizer(schemaString, " ;{}()\n\t");    Types.MessageTypeBuilder builder = Types.buildMessage();    String t = st.nextToken();    check(t, "message", "start with 'message'", st);    String name = st.nextToken();    addGroupTypeFields(st.nextToken(), st, builder);    return builder.named(name);}
24e61a5ce751e8959798183046b2033666ea1c2cdc63a9b4aac7103d0c777075
addGroupTypeFields
private static void addGroupTypeFields(String t, Tokenizer st, Types.GroupBuilder builder)
{    check(t, "{", "start of message", st);    while (!(t = st.nextToken()).equals("}")) {        addType(t, st, builder);    }}
2557623b3bfdd5830eeded9ad05c23668524e3056ec14a66698d049aba46fe32
addType
private static void addType(String t, Tokenizer st, Types.GroupBuilder builder)
{    Repetition repetition = asRepetition(t, st);        String type = st.nextToken();    if ("group".equalsIgnoreCase(type)) {        addGroupType(st, repetition, builder);    } else {        addPrimitiveType(st, asPrimitive(type, st), repetition, builder);    }}
c124eee902f43dd2454858a13180973439ef3665688031981099ba67a912ad4a
addGroupType
private static void addGroupType(Tokenizer st, Repetition r, GroupBuilder<?> builder)
{    GroupBuilder<?> childBuilder = builder.group(r);    String t;    String name = st.nextToken();        t = st.nextToken();    OriginalType originalType = null;    if (t.equalsIgnoreCase("(")) {        originalType = OriginalType.valueOf(st.nextToken());        childBuilder.as(originalType);        check(st.nextToken(), ")", "original type ended by )", st);        t = st.nextToken();    }    if (t.equals("=")) {        childBuilder.id(Integer.parseInt(st.nextToken()));        t = st.nextToken();    }    try {        addGroupTypeFields(t, st, childBuilder);    } catch (IllegalArgumentException e) {        throw new IllegalArgumentException("problem reading type: type = group, name = " + name + ", original type = " + originalType, e);    }    childBuilder.named(name);}
22571555ecfceeafbf4511856008e744845e38a2e83330a1a311e2e9a40b4c27
addPrimitiveType
private static void addPrimitiveType(Tokenizer st, PrimitiveTypeName type, Repetition r, Types.GroupBuilder<?> builder)
{    PrimitiveBuilder<?> childBuilder = builder.primitive(type, r);    String t;    if (type == PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY) {        t = st.nextToken();                if (!t.equalsIgnoreCase("(")) {            throw new IllegalArgumentException("expecting (length) for field of type fixed_len_byte_array");        }        childBuilder.length(Integer.parseInt(st.nextToken()));        check(st.nextToken(), ")", "type length ended by )", st);    }    String name = st.nextToken();        t = st.nextToken();    OriginalType originalType = null;    if (t.equalsIgnoreCase("(")) {        t = st.nextToken();        if (isLogicalType(t)) {            LogicalTypeAnnotation.LogicalTypeToken logicalType = LogicalTypeAnnotation.LogicalTypeToken.valueOf(t);            t = st.nextToken();            List<String> tokens = new ArrayList<>();            if ("(".equals(t)) {                while (!")".equals(t)) {                    if (!(",".equals(t) || "(".equals(t) || ")".equals(t))) {                        tokens.add(t);                    }                    t = st.nextToken();                }                t = st.nextToken();            }            LogicalTypeAnnotation logicalTypeAnnotation = logicalType.fromString(tokens);            childBuilder.as(logicalTypeAnnotation);        } else {                        originalType = OriginalType.valueOf(t);            childBuilder.as(originalType);            if (OriginalType.DECIMAL == originalType) {                t = st.nextToken();                                if (t.equalsIgnoreCase("(")) {                    childBuilder.precision(Integer.parseInt(st.nextToken()));                    t = st.nextToken();                    if (t.equalsIgnoreCase(",")) {                        childBuilder.scale(Integer.parseInt(st.nextToken()));                        t = st.nextToken();                    }                    check(t, ")", "decimal type ended by )", st);                    t = st.nextToken();                }            } else {                t = st.nextToken();            }        }        check(t, ")", "logical type ended by )", st);        t = st.nextToken();    }    if (t.equals("=")) {        childBuilder.id(Integer.parseInt(st.nextToken()));        t = st.nextToken();    }    check(t, ";", "field ended by ';'", st);    try {        childBuilder.named(name);    } catch (IllegalArgumentException e) {        throw new IllegalArgumentException("problem reading type: type = " + type + ", name = " + name + ", original type = " + originalType, e);    }}
e48646ab30726b4d6fd23c62778a7e40ff42a198b3ce198ee06b617687caac88
isLogicalType
private static boolean isLogicalType(String t)
{    return Arrays.stream(LogicalTypeAnnotation.LogicalTypeToken.values()).anyMatch((type) -> type.name().equals(t));}
e1b7093d6eca9162fd4ea3c233cb470530b9afc3765ce624f55c1f2c6d223ebb
asPrimitive
private static PrimitiveTypeName asPrimitive(String t, Tokenizer st)
{    try {        return PrimitiveTypeName.valueOf(t.toUpperCase(Locale.ENGLISH));    } catch (IllegalArgumentException e) {        throw new IllegalArgumentException("expected one of " + Arrays.toString(PrimitiveTypeName.values()) + " got " + t + " at " + st.getLocationString(), e);    }}
2d71addf1aa64fc9005f5d7ac8f6f9719f66a4a20593b7c9ad7bdd9f909ef6ce
asRepetition
private static Repetition asRepetition(String t, Tokenizer st)
{    try {        return Repetition.valueOf(t.toUpperCase(Locale.ENGLISH));    } catch (IllegalArgumentException e) {        throw new IllegalArgumentException("expected one of " + Arrays.toString(Repetition.values()) + " got " + t + " at " + st.getLocationString(), e);    }}
279c72affc46ab2778e73b03907b82b11832d3e35dbe760cd7e69edf8ad66ae6
check
private static void check(String t, String expected, String message, Tokenizer tokenizer)
{    if (!t.equalsIgnoreCase(expected)) {        throw new IllegalArgumentException(message + ": expected '" + expected + "' but got '" + t + "' at " + tokenizer.getLocationString());    }}
1911109eb4d187d51f33932bcd2d129f91c70f7e9f7624be5895ddbe4397db26
compare
public int compare(boolean b1, boolean b2)
{    throw new UnsupportedOperationException("compare(boolean, boolean) was called on a non-boolean comparator: " + toString());}
161cca9e9cf8f9524f92477438ea2171ce61eee11d269654b20074cf04bd2f65
compare
public int compare(int i1, int i2)
{    throw new UnsupportedOperationException("compare(int, int) was called on a non-int comparator: " + toString());}
4a3a79e57923a8297242c4e47526097269992c855bd2127c624a396407b06c0b
compare
public int compare(long l1, long l2)
{    throw new UnsupportedOperationException("compare(long, long) was called on a non-long comparator: " + toString());}
74b4277799c79ba23c27e6fa7c542895abe0c34ba1c98b62367054014e47127f
compare
public int compare(float f1, float f2)
{    throw new UnsupportedOperationException("compare(float, float) was called on a non-float comparator: " + toString());}
667c806bcf47316c44f5217da2c1bc9c530adfc94abc33237b55a7b9dcee66d7
compare
public int compare(double d1, double d2)
{    throw new UnsupportedOperationException("compare(double, double) was called on a non-double comparator: " + toString());}
2c0f6abf4930f79370cf52a6da2b8fb44bd11cbcfbecd7ea6a208a11c2bfa3db
compare
public final int compare(T o1, T o2)
{    if (o1 == null) {        return o2 == null ? 0 : -1;    }    return o2 == null ? 1 : compareNotNulls(o1, o2);}
6c804424482402bae0ec5df6849454c996312b78200e175f61ec818d73109dbc
compareNotNulls
 int compareNotNulls(Boolean o1, Boolean o2)
{    return compare(o1.booleanValue(), o2.booleanValue());}
1911109eb4d187d51f33932bcd2d129f91c70f7e9f7624be5895ddbe4397db26
compare
public int compare(boolean b1, boolean b2)
{    return Boolean.compare(b1, b2);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "BOOLEAN_COMPARATOR";}
09ec6e3e761b86618c91f8f98ff1d48c0fbb94fc38722bc0e52f06c9a1cd0879
compareNotNulls
 int compareNotNulls(Integer o1, Integer o2)
{    return compare(o1.intValue(), o2.intValue());}
161cca9e9cf8f9524f92477438ea2171ce61eee11d269654b20074cf04bd2f65
compare
public int compare(int i1, int i2)
{    return Integer.compare(i1, i2);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "SIGNED_INT32_COMPARATOR";}
161cca9e9cf8f9524f92477438ea2171ce61eee11d269654b20074cf04bd2f65
compare
public int compare(int i1, int i2)
{        return Integer.compare(i1 ^ Integer.MIN_VALUE, i2 ^ Integer.MIN_VALUE);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "UNSIGNED_INT32_COMPARATOR";}
1d485e27f9b7b18527e1479d6ebbd514231e82f4267decfcf837d16739250528
compareNotNulls
 int compareNotNulls(Long o1, Long o2)
{    return compare(o1.longValue(), o2.longValue());}
4a3a79e57923a8297242c4e47526097269992c855bd2127c624a396407b06c0b
compare
public int compare(long l1, long l2)
{    return Long.compare(l1, l2);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "SIGNED_INT64_COMPARATOR";}
4a3a79e57923a8297242c4e47526097269992c855bd2127c624a396407b06c0b
compare
public int compare(long l1, long l2)
{        return Long.compare(l1 ^ Long.MIN_VALUE, l2 ^ Long.MIN_VALUE);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "UNSIGNED_INT64_COMPARATOR";}
d744756552595d43d8fda8f2b5e7dbcfc55343d5e87565005529c6e92e9c7e0b
compareNotNulls
 int compareNotNulls(Float o1, Float o2)
{    return compare(o1.floatValue(), o2.floatValue());}
74b4277799c79ba23c27e6fa7c542895abe0c34ba1c98b62367054014e47127f
compare
public int compare(float f1, float f2)
{    return Float.compare(f1, f2);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "FLOAT_COMPARATOR";}
ce29f6cfbcc6fc570ad37e624b79a82c9e29b23c916e202734ea0ff7f5a91ed0
compareNotNulls
 int compareNotNulls(Double o1, Double o2)
{    return compare(o1.doubleValue(), o2.doubleValue());}
667c806bcf47316c44f5217da2c1bc9c530adfc94abc33237b55a7b9dcee66d7
compare
public int compare(double d1, double d2)
{    return Double.compare(d1, d2);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "DOUBLE_COMPARATOR";}
f9df852e8e3b4038dacf8060fdb68e3659aa15500c871f9e876aa3593156fcfe
compareNotNulls
 int compareNotNulls(Binary o1, Binary o2)
{    return compare(o1.toByteBuffer(), o2.toByteBuffer());}
48c287aaae2b7c7ecb3e08180944ade6513ae66cad7c10fea3520b1f39b0949b
toUnsigned
 final int toUnsigned(byte b)
{    return b & 0xFF;}
f4079a2667bb70958832c2cfda60319594cc40e08a4f8fc41fe08bf6e9576b66
compare
 int compare(ByteBuffer b1, ByteBuffer b2)
{    int l1 = b1.remaining();    int l2 = b2.remaining();    int p1 = b1.position();    int p2 = b2.position();    int minL = Math.min(l1, l2);    for (int i = 0; i < minL; ++i) {        int result = unsignedCompare(b1.get(p1 + i), b2.get(p2 + i));        if (result != 0) {            return result;        }    }    return l1 - l2;}
64b51a7d92416981513c58819b6bd8f0c044c37b2202cb68671f2cdb644fe079
unsignedCompare
private int unsignedCompare(byte b1, byte b2)
{    return toUnsigned(b1) - toUnsigned(b2);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "UNSIGNED_LEXICOGRAPHICAL_BINARY_COMPARATOR";}
f4079a2667bb70958832c2cfda60319594cc40e08a4f8fc41fe08bf6e9576b66
compare
 int compare(ByteBuffer b1, ByteBuffer b2)
{    int l1 = b1.remaining();    int l2 = b2.remaining();    int p1 = b1.position();    int p2 = b2.position();    boolean isNegative1 = l1 > 0 && b1.get(p1) < 0;    boolean isNegative2 = l2 > 0 && b2.get(p2) < 0;    if (isNegative1 != isNegative2) {        return isNegative1 ? -1 : 1;    }    int result = 0;        if (l1 < l2) {        int lengthDiff = l2 - l1;        result = -compareWithPadding(lengthDiff, b2, p2, isNegative1 ? NEGATIVE_PADDING : POSITIVE_PADDING);        p2 += lengthDiff;    } else if (l1 > l2) {        int lengthDiff = l1 - l2;        result = compareWithPadding(lengthDiff, b1, p1, isNegative2 ? NEGATIVE_PADDING : POSITIVE_PADDING);        p1 += lengthDiff;    }        if (result == 0) {        result = compare(Math.min(l1, l2), b1, p1, b2, p2);    }    return result;}
5fb165774ee7655d0e708c58bb31e38a0e5b4a1550c22d464a241dfd27930055
compareWithPadding
private int compareWithPadding(int length, ByteBuffer b, int p, int paddingByte)
{    for (int i = p, n = p + length; i < n; ++i) {        int result = toUnsigned(b.get(i)) - paddingByte;        if (result != 0) {            return result;        }    }    return 0;}
89b773b89f64609ea710cb87119cdee58c8aded0ddda746c2109ddd66797ff78
compare
private int compare(int length, ByteBuffer b1, int p1, ByteBuffer b2, int p2)
{    for (int i = 0; i < length; ++i) {        int result = toUnsigned(b1.get(p1 + i)) - toUnsigned(b2.get(p2 + i));        if (result != 0) {            return result;        }    }    return 0;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "BINARY_AS_SIGNED_INTEGER_COMPARATOR";}
30c5449c6b5eb9c7f0a380bfd47f034e2fb127c28cd09faea4b05291405320a0
toString
public final String toString()
{    return name;}
7a5a5b24857841e06c470852f7ae068802bb9d89de0a8833044237db94b7dd4a
stringify
public String stringify(boolean value)
{    throw new UnsupportedOperationException("stringify(boolean) was called on a non-boolean stringifier: " + toString());}
ec2a670a52a82012b1cdeda7322e3cd191f85ecf9adbb26cee2e8683155c9710
stringify
public String stringify(int value)
{    throw new UnsupportedOperationException("stringify(int) was called on a non-int stringifier: " + toString());}
c3e37031cdd244ade1a25c8c9b9370f9aaff92757418788291e71a701e5c2cf0
stringify
public String stringify(long value)
{    throw new UnsupportedOperationException("stringify(long) was called on a non-long stringifier: " + toString());}
f44a58147df04368090a4106e5ed314e5cb56f4aefad88fec54c371e89b0a5d0
stringify
public String stringify(float value)
{    throw new UnsupportedOperationException("stringify(float) was called on a non-float stringifier: " + toString());}
31bc20cdae8fc3c5ba1ba071ebfb502a8599229c4478746c0e4e57ff9a4cb7b0
stringify
public String stringify(double value)
{    throw new UnsupportedOperationException("stringify(double) was called on a non-double stringifier: " + toString());}
eb2603e16863f42d0fb54376a1690baf58b1365e70ef424766f4afc0bb827704
stringify
public String stringify(Binary value)
{    throw new UnsupportedOperationException("stringify(Binary) was called on a non-Binary stringifier: " + toString());}
08743b06b5f0115b135109d5c2ef92d2bc6d4197a71a2570296de5282d3e18a9
stringify
public final String stringify(Binary value)
{    return value == null ? BINARY_NULL : stringifyNotNull(value);}
7a5a5b24857841e06c470852f7ae068802bb9d89de0a8833044237db94b7dd4a
stringify
public String stringify(boolean value)
{    return Boolean.toString(value);}
ec2a670a52a82012b1cdeda7322e3cd191f85ecf9adbb26cee2e8683155c9710
stringify
public String stringify(int value)
{    return Integer.toString(value);}
c3e37031cdd244ade1a25c8c9b9370f9aaff92757418788291e71a701e5c2cf0
stringify
public String stringify(long value)
{    return Long.toString(value);}
f44a58147df04368090a4106e5ed314e5cb56f4aefad88fec54c371e89b0a5d0
stringify
public String stringify(float value)
{    return Float.toString(value);}
31bc20cdae8fc3c5ba1ba071ebfb502a8599229c4478746c0e4e57ff9a4cb7b0
stringify
public String stringify(double value)
{    return Double.toString(value);}
599c75836062535d967f5669f91761da0152f50b6b3f5c134d2fbf3dcbb030ac
stringifyNotNull
 String stringifyNotNull(Binary value)
{    ByteBuffer buffer = value.toByteBuffer();    StringBuilder builder = new StringBuilder(2 + buffer.remaining() * 2);    builder.append(BINARY_HEXA_PREFIX);    for (int i = buffer.position(), n = buffer.limit(); i < n; ++i) {        byte b = buffer.get(i);        builder.append(digits[(b >>> 4) & 0x0F]);        builder.append(digits[b & 0x0F]);    }    return builder.toString();}
ec2a670a52a82012b1cdeda7322e3cd191f85ecf9adbb26cee2e8683155c9710
stringify
public String stringify(int value)
{    return Long.toString(value & INT_MASK);}
c3e37031cdd244ade1a25c8c9b9370f9aaff92757418788291e71a701e5c2cf0
stringify
public String stringify(long value)
{    if (value == 0) {                return "0";    } else if (value > 0) {        return Long.toString(value);    } else {        char[] buf = new char[64];        int i = buf.length;                                long top = value >>> 32;        long bot = (value & INT_MASK) + ((top % 10) << 32);        top /= 10;        while ((bot > 0) || (top > 0)) {            buf[--i] = Character.forDigit((int) (bot % 10), 10);            bot = (bot / 10) + ((top % 10) << 32);            top /= 10;        }                return new String(buf, i, buf.length - i);    }}
599c75836062535d967f5669f91761da0152f50b6b3f5c134d2fbf3dcbb030ac
stringifyNotNull
 String stringifyNotNull(Binary value)
{    return value.toStringUsingUTF8();}
599c75836062535d967f5669f91761da0152f50b6b3f5c134d2fbf3dcbb030ac
stringifyNotNull
 String stringifyNotNull(Binary value)
{    if (value.length() != 12) {        return BINARY_INVALID;    }    ByteBuffer buffer = value.toByteBuffer().order(ByteOrder.LITTLE_ENDIAN);    int pos = buffer.position();    String months = UNSIGNED_STRINGIFIER.stringify(buffer.getInt(pos));    String days = UNSIGNED_STRINGIFIER.stringify(buffer.getInt(pos + 4));    String millis = UNSIGNED_STRINGIFIER.stringify(buffer.getInt(pos + 8));    return "interval(" + months + " months, " + days + " days, " + millis + " millis)";}
ec2a670a52a82012b1cdeda7322e3cd191f85ecf9adbb26cee2e8683155c9710
stringify
public String stringify(int value)
{    return toFormattedString(getInstant(value));}
c3e37031cdd244ade1a25c8c9b9370f9aaff92757418788291e71a701e5c2cf0
stringify
public String stringify(long value)
{    return toFormattedString(getInstant(value));}
c6fe0cdcb236cd2ef6e5bc5a3a775235d11dadfcecf475989ca478e19df92455
toFormattedString
private String toFormattedString(Instant instant)
{    return formatter.format(instant);}
a910df68e1f3628756405f1dd734a2a685f1cdddc88916c061bd64e6b59f11e0
getInstant
 Instant getInstant(int value)
{        super.stringify(value);    return null;}
17796fae5ff3ee76619bb4548183670e71715f767148c920f2bba6f31890c5d2
getInstant
 Instant getInstant(long value)
{        super.stringify(value);    return null;}
a910df68e1f3628756405f1dd734a2a685f1cdddc88916c061bd64e6b59f11e0
getInstant
 Instant getInstant(int value)
{    return Instant.ofEpochMilli(TimeUnit.DAYS.toMillis(value));}
17796fae5ff3ee76619bb4548183670e71715f767148c920f2bba6f31890c5d2
getInstant
 Instant getInstant(long value)
{    return Instant.ofEpochMilli(value);}
17796fae5ff3ee76619bb4548183670e71715f767148c920f2bba6f31890c5d2
getInstant
 Instant getInstant(long value)
{    return Instant.ofEpochSecond(MICROSECONDS.toSeconds(value), MICROSECONDS.toNanos(value % SECONDS.toMicros(1)));}
17796fae5ff3ee76619bb4548183670e71715f767148c920f2bba6f31890c5d2
getInstant
 Instant getInstant(long value)
{    return Instant.ofEpochSecond(NANOSECONDS.toSeconds(value), NANOSECONDS.toNanos(value % SECONDS.toNanos(1)));}
17796fae5ff3ee76619bb4548183670e71715f767148c920f2bba6f31890c5d2
getInstant
 Instant getInstant(long value)
{    return Instant.ofEpochMilli(value);}
17796fae5ff3ee76619bb4548183670e71715f767148c920f2bba6f31890c5d2
getInstant
 Instant getInstant(long value)
{    return Instant.ofEpochSecond(MICROSECONDS.toSeconds(value), MICROSECONDS.toNanos(value % SECONDS.toMicros(1)));}
17796fae5ff3ee76619bb4548183670e71715f767148c920f2bba6f31890c5d2
getInstant
 Instant getInstant(long value)
{    return Instant.ofEpochSecond(NANOSECONDS.toSeconds(value), NANOSECONDS.toNanos(value % SECONDS.toNanos(1)));}
53524fda84b0c4a48899447afd835f61e766206c05d2f67a5ccfa166638fa297
toTimeString
protected String toTimeString(long duration, TimeUnit unit)
{    String additionalFormat = (unit == MILLISECONDS ? "3d" : unit == MICROSECONDS ? "6d" : "9d");    String timeZone = withZone ? "+0000" : "";    String format = "%02d:%02d:%02d.%0" + additionalFormat + timeZone;    return String.format(format, unit.toHours(duration), convert(duration, unit, MINUTES, HOURS), convert(duration, unit, SECONDS, MINUTES), convert(duration, unit, unit, SECONDS));}
0a57a1f0d39059675fbcdcc282a6c20863bc040b90d8ee3b27396a12b6165fa8
convert
protected long convert(long duration, TimeUnit from, TimeUnit to, TimeUnit higher)
{    return Math.abs(to.convert(duration, from) % to.convert(1, higher));}
23bca4500ac725536b65de5f6a2acfc6f2a9bb23b72a4cf66a4c16c661224621
stringify
public String stringify(int millis)
{    return toTimeString(millis, MILLISECONDS);}
73c7924ce74ffb1fb39cbe9d60e5921bad78f139d794f33ab95fe7db42107d87
stringify
public String stringify(long micros)
{    return toTimeString(micros, MICROSECONDS);}
830e68cee5ff7caeeb196400b25ed2969baba24e89dcc830a0df6be0cf00bc89
stringify
public String stringify(long nanos)
{    return toTimeString(nanos, NANOSECONDS);}
23bca4500ac725536b65de5f6a2acfc6f2a9bb23b72a4cf66a4c16c661224621
stringify
public String stringify(int millis)
{    return toTimeString(millis, MILLISECONDS);}
73c7924ce74ffb1fb39cbe9d60e5921bad78f139d794f33ab95fe7db42107d87
stringify
public String stringify(long micros)
{    return toTimeString(micros, MICROSECONDS);}
830e68cee5ff7caeeb196400b25ed2969baba24e89dcc830a0df6be0cf00bc89
stringify
public String stringify(long nanos)
{    return toTimeString(nanos, NANOSECONDS);}
9bec7b47c1e239bceead75d0728982e90f30cd7f9d51d2fcf8dadc9f5e8755f1
createDecimalStringifier
 static PrimitiveStringifier createDecimalStringifier(final int scale)
{    return new BinaryStringifierBase("DECIMAL_STRINGIFIER(scale: " + scale + ")") {        @Override        public String stringify(int value) {            return stringifyWithScale(BigInteger.valueOf(value));        }        @Override        public String stringify(long value) {            return stringifyWithScale(BigInteger.valueOf(value));        }        @Override        String stringifyNotNull(Binary value) {            try {                return stringifyWithScale(new BigInteger(value.getBytesUnsafe()));            } catch (NumberFormatException e) {                return BINARY_INVALID;            }        }        private String stringifyWithScale(BigInteger i) {            return new BigDecimal(i, scale).toString();        }    };}
ec2a670a52a82012b1cdeda7322e3cd191f85ecf9adbb26cee2e8683155c9710
stringify
public String stringify(int value)
{    return stringifyWithScale(BigInteger.valueOf(value));}
c3e37031cdd244ade1a25c8c9b9370f9aaff92757418788291e71a701e5c2cf0
stringify
public String stringify(long value)
{    return stringifyWithScale(BigInteger.valueOf(value));}
599c75836062535d967f5669f91761da0152f50b6b3f5c134d2fbf3dcbb030ac
stringifyNotNull
 String stringifyNotNull(Binary value)
{    try {        return stringifyWithScale(new BigInteger(value.getBytesUnsafe()));    } catch (NumberFormatException e) {        return BINARY_INVALID;    }}
d625a86c330b98cbff2da0df38161b03421bb797ec6de2598ab12bd4916d5bf3
stringifyWithScale
private String stringifyWithScale(BigInteger i)
{    return new BigDecimal(i, scale).toString();}
f607fa3620ba77a249defb6d5daea6abfaa5dad38e7a78aeecd5022e790a1934
toString
public String toString(ColumnReader columnReader)
{    return String.valueOf(columnReader.getLong());}
40e3309b06e540c9ea0085e7097a2cd81230e84a687d5c183bbe6fa7a88dd073
addValueToRecordConsumer
public void addValueToRecordConsumer(RecordConsumer recordConsumer, ColumnReader columnReader)
{    recordConsumer.addLong(columnReader.getLong());}
b64c0d7cd0dcef111e8c0315064bd3d5ed08ab9fa3be5c08c5e77f55e210ee82
addValueToPrimitiveConverter
public void addValueToPrimitiveConverter(PrimitiveConverter primitiveConverter, ColumnReader columnReader)
{    primitiveConverter.addLong(columnReader.getLong());}
68379e2568daf3f6bdcc3d1d4225c8e269d30c5aaa52cc18df0a2dbf7d207160
convert
public T convert(PrimitiveTypeNameConverter<T, E> converter) throws E
{    return converter.convertINT64(this);}
307199be2311599a65feb443179569a860be63cf06fc66d71f2e94b599a51346
comparator
 PrimitiveComparator<?> comparator(LogicalTypeAnnotation logicalType)
{    if (logicalType == null) {        return PrimitiveComparator.SIGNED_INT64_COMPARATOR;    }    return logicalType.accept(new LogicalTypeAnnotation.LogicalTypeAnnotationVisitor<PrimitiveComparator>() {        @Override        public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.IntLogicalTypeAnnotation intLogicalType) {            return intLogicalType.isSigned() ? of(PrimitiveComparator.SIGNED_INT64_COMPARATOR) : of(PrimitiveComparator.UNSIGNED_INT64_COMPARATOR);        }        @Override        public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType) {            return of(PrimitiveComparator.SIGNED_INT64_COMPARATOR);        }        @Override        public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.TimeLogicalTypeAnnotation timeLogicalType) {            return of(PrimitiveComparator.SIGNED_INT64_COMPARATOR);        }        @Override        public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.TimestampLogicalTypeAnnotation timestampLogicalType) {            return of(PrimitiveComparator.SIGNED_INT64_COMPARATOR);        }    }).orElseThrow(() -> new ShouldNeverHappenException("No comparator logic implemented for INT64 logical type: " + logicalType));}
fe302d2ccb1f97b209bd7eecda044ae19ad9fdfbdd5046a7081611038ee8b5bd
visit
public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.IntLogicalTypeAnnotation intLogicalType)
{    return intLogicalType.isSigned() ? of(PrimitiveComparator.SIGNED_INT64_COMPARATOR) : of(PrimitiveComparator.UNSIGNED_INT64_COMPARATOR);}
3b039db18293eb729cc45b0e7e304d254bab66f40e6549d10efd16550745403a
visit
public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType)
{    return of(PrimitiveComparator.SIGNED_INT64_COMPARATOR);}
d3f9a9f5a115b88b62d9dd1d629bdec2600639a20bc1c69a30a51a60cf2a9e54
visit
public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.TimeLogicalTypeAnnotation timeLogicalType)
{    return of(PrimitiveComparator.SIGNED_INT64_COMPARATOR);}
ffb812ea7222d91a9b5bd33d1aed4c4f4eabb1b34feeb4b601f3c8bb00fe6f60
visit
public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.TimestampLogicalTypeAnnotation timestampLogicalType)
{    return of(PrimitiveComparator.SIGNED_INT64_COMPARATOR);}
f607fa3620ba77a249defb6d5daea6abfaa5dad38e7a78aeecd5022e790a1934
toString
public String toString(ColumnReader columnReader)
{    return String.valueOf(columnReader.getInteger());}
40e3309b06e540c9ea0085e7097a2cd81230e84a687d5c183bbe6fa7a88dd073
addValueToRecordConsumer
public void addValueToRecordConsumer(RecordConsumer recordConsumer, ColumnReader columnReader)
{    recordConsumer.addInteger(columnReader.getInteger());}
b64c0d7cd0dcef111e8c0315064bd3d5ed08ab9fa3be5c08c5e77f55e210ee82
addValueToPrimitiveConverter
public void addValueToPrimitiveConverter(PrimitiveConverter primitiveConverter, ColumnReader columnReader)
{    primitiveConverter.addInt(columnReader.getInteger());}
68379e2568daf3f6bdcc3d1d4225c8e269d30c5aaa52cc18df0a2dbf7d207160
convert
public T convert(PrimitiveTypeNameConverter<T, E> converter) throws E
{    return converter.convertINT32(this);}
307199be2311599a65feb443179569a860be63cf06fc66d71f2e94b599a51346
comparator
 PrimitiveComparator<?> comparator(LogicalTypeAnnotation logicalType)
{    if (logicalType == null) {        return PrimitiveComparator.SIGNED_INT32_COMPARATOR;    }    return logicalType.accept(new LogicalTypeAnnotation.LogicalTypeAnnotationVisitor<PrimitiveComparator>() {        @Override        public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.IntLogicalTypeAnnotation intLogicalType) {            if (intLogicalType.getBitWidth() == 64) {                return empty();            }            return intLogicalType.isSigned() ? of(PrimitiveComparator.SIGNED_INT32_COMPARATOR) : of(PrimitiveComparator.UNSIGNED_INT32_COMPARATOR);        }        @Override        public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType) {            return of(PrimitiveComparator.SIGNED_INT32_COMPARATOR);        }        @Override        public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.DateLogicalTypeAnnotation dateLogicalType) {            return of(PrimitiveComparator.SIGNED_INT32_COMPARATOR);        }        @Override        public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.TimeLogicalTypeAnnotation timeLogicalType) {            if (timeLogicalType.getUnit() == MILLIS) {                return of(PrimitiveComparator.SIGNED_INT32_COMPARATOR);            }            return empty();        }    }).orElseThrow(() -> new ShouldNeverHappenException("No comparator logic implemented for INT32 logical type: " + logicalType));}
fe302d2ccb1f97b209bd7eecda044ae19ad9fdfbdd5046a7081611038ee8b5bd
visit
public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.IntLogicalTypeAnnotation intLogicalType)
{    if (intLogicalType.getBitWidth() == 64) {        return empty();    }    return intLogicalType.isSigned() ? of(PrimitiveComparator.SIGNED_INT32_COMPARATOR) : of(PrimitiveComparator.UNSIGNED_INT32_COMPARATOR);}
3b039db18293eb729cc45b0e7e304d254bab66f40e6549d10efd16550745403a
visit
public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType)
{    return of(PrimitiveComparator.SIGNED_INT32_COMPARATOR);}
1370ceac13acc7157124919c01bf471edb5b510f87dcc97149ac3692f4ac33b5
visit
public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.DateLogicalTypeAnnotation dateLogicalType)
{    return of(PrimitiveComparator.SIGNED_INT32_COMPARATOR);}
d3f9a9f5a115b88b62d9dd1d629bdec2600639a20bc1c69a30a51a60cf2a9e54
visit
public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.TimeLogicalTypeAnnotation timeLogicalType)
{    if (timeLogicalType.getUnit() == MILLIS) {        return of(PrimitiveComparator.SIGNED_INT32_COMPARATOR);    }    return empty();}
f607fa3620ba77a249defb6d5daea6abfaa5dad38e7a78aeecd5022e790a1934
toString
public String toString(ColumnReader columnReader)
{    return String.valueOf(columnReader.getBoolean());}
40e3309b06e540c9ea0085e7097a2cd81230e84a687d5c183bbe6fa7a88dd073
addValueToRecordConsumer
public void addValueToRecordConsumer(RecordConsumer recordConsumer, ColumnReader columnReader)
{    recordConsumer.addBoolean(columnReader.getBoolean());}
b64c0d7cd0dcef111e8c0315064bd3d5ed08ab9fa3be5c08c5e77f55e210ee82
addValueToPrimitiveConverter
public void addValueToPrimitiveConverter(PrimitiveConverter primitiveConverter, ColumnReader columnReader)
{    primitiveConverter.addBoolean(columnReader.getBoolean());}
68379e2568daf3f6bdcc3d1d4225c8e269d30c5aaa52cc18df0a2dbf7d207160
convert
public T convert(PrimitiveTypeNameConverter<T, E> converter) throws E
{    return converter.convertBOOLEAN(this);}
307199be2311599a65feb443179569a860be63cf06fc66d71f2e94b599a51346
comparator
 PrimitiveComparator<?> comparator(LogicalTypeAnnotation logicalType)
{    return PrimitiveComparator.BOOLEAN_COMPARATOR;}
f607fa3620ba77a249defb6d5daea6abfaa5dad38e7a78aeecd5022e790a1934
toString
public String toString(ColumnReader columnReader)
{    return String.valueOf(columnReader.getBinary());}
40e3309b06e540c9ea0085e7097a2cd81230e84a687d5c183bbe6fa7a88dd073
addValueToRecordConsumer
public void addValueToRecordConsumer(RecordConsumer recordConsumer, ColumnReader columnReader)
{    recordConsumer.addBinary(columnReader.getBinary());}
b64c0d7cd0dcef111e8c0315064bd3d5ed08ab9fa3be5c08c5e77f55e210ee82
addValueToPrimitiveConverter
public void addValueToPrimitiveConverter(PrimitiveConverter primitiveConverter, ColumnReader columnReader)
{    primitiveConverter.addBinary(columnReader.getBinary());}
68379e2568daf3f6bdcc3d1d4225c8e269d30c5aaa52cc18df0a2dbf7d207160
convert
public T convert(PrimitiveTypeNameConverter<T, E> converter) throws E
{    return converter.convertBINARY(this);}
307199be2311599a65feb443179569a860be63cf06fc66d71f2e94b599a51346
comparator
 PrimitiveComparator<?> comparator(LogicalTypeAnnotation logicalType)
{    if (logicalType == null) {        return PrimitiveComparator.UNSIGNED_LEXICOGRAPHICAL_BINARY_COMPARATOR;    }    return logicalType.accept(new LogicalTypeAnnotation.LogicalTypeAnnotationVisitor<PrimitiveComparator>() {        @Override        public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType) {            return of(PrimitiveComparator.BINARY_AS_SIGNED_INTEGER_COMPARATOR);        }        @Override        public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.StringLogicalTypeAnnotation stringLogicalType) {            return of(PrimitiveComparator.UNSIGNED_LEXICOGRAPHICAL_BINARY_COMPARATOR);        }        @Override        public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.EnumLogicalTypeAnnotation enumLogicalType) {            return of(PrimitiveComparator.UNSIGNED_LEXICOGRAPHICAL_BINARY_COMPARATOR);        }        @Override        public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.JsonLogicalTypeAnnotation jsonLogicalType) {            return of(PrimitiveComparator.UNSIGNED_LEXICOGRAPHICAL_BINARY_COMPARATOR);        }        @Override        public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.BsonLogicalTypeAnnotation bsonLogicalType) {            return of(PrimitiveComparator.UNSIGNED_LEXICOGRAPHICAL_BINARY_COMPARATOR);        }    }).orElseThrow(() -> new ShouldNeverHappenException("No comparator logic implemented for BINARY logical type: " + logicalType));}
3b039db18293eb729cc45b0e7e304d254bab66f40e6549d10efd16550745403a
visit
public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType)
{    return of(PrimitiveComparator.BINARY_AS_SIGNED_INTEGER_COMPARATOR);}
614caf954a2818d582efb43fcc8b18e921b7e2468be17bdae45a74b2504d54fa
visit
public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.StringLogicalTypeAnnotation stringLogicalType)
{    return of(PrimitiveComparator.UNSIGNED_LEXICOGRAPHICAL_BINARY_COMPARATOR);}
bdd5ede8b736f78575bc0aa3cda7d06235ab22c474fc3496b98924275804f0aa
visit
public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.EnumLogicalTypeAnnotation enumLogicalType)
{    return of(PrimitiveComparator.UNSIGNED_LEXICOGRAPHICAL_BINARY_COMPARATOR);}
7cde777019ebab45ff99a99aa6a610bfed13079a82183cec0ed860bc6253aeec
visit
public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.JsonLogicalTypeAnnotation jsonLogicalType)
{    return of(PrimitiveComparator.UNSIGNED_LEXICOGRAPHICAL_BINARY_COMPARATOR);}
ba8104b1e867b0c3176204a209f00c9205da721a3fbeedde682ff6e9d1c19b82
visit
public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.BsonLogicalTypeAnnotation bsonLogicalType)
{    return of(PrimitiveComparator.UNSIGNED_LEXICOGRAPHICAL_BINARY_COMPARATOR);}
f607fa3620ba77a249defb6d5daea6abfaa5dad38e7a78aeecd5022e790a1934
toString
public String toString(ColumnReader columnReader)
{    return String.valueOf(columnReader.getFloat());}
40e3309b06e540c9ea0085e7097a2cd81230e84a687d5c183bbe6fa7a88dd073
addValueToRecordConsumer
public void addValueToRecordConsumer(RecordConsumer recordConsumer, ColumnReader columnReader)
{    recordConsumer.addFloat(columnReader.getFloat());}
b64c0d7cd0dcef111e8c0315064bd3d5ed08ab9fa3be5c08c5e77f55e210ee82
addValueToPrimitiveConverter
public void addValueToPrimitiveConverter(PrimitiveConverter primitiveConverter, ColumnReader columnReader)
{    primitiveConverter.addFloat(columnReader.getFloat());}
68379e2568daf3f6bdcc3d1d4225c8e269d30c5aaa52cc18df0a2dbf7d207160
convert
public T convert(PrimitiveTypeNameConverter<T, E> converter) throws E
{    return converter.convertFLOAT(this);}
307199be2311599a65feb443179569a860be63cf06fc66d71f2e94b599a51346
comparator
 PrimitiveComparator<?> comparator(LogicalTypeAnnotation logicalType)
{    return PrimitiveComparator.FLOAT_COMPARATOR;}
f607fa3620ba77a249defb6d5daea6abfaa5dad38e7a78aeecd5022e790a1934
toString
public String toString(ColumnReader columnReader)
{    return String.valueOf(columnReader.getDouble());}
40e3309b06e540c9ea0085e7097a2cd81230e84a687d5c183bbe6fa7a88dd073
addValueToRecordConsumer
public void addValueToRecordConsumer(RecordConsumer recordConsumer, ColumnReader columnReader)
{    recordConsumer.addDouble(columnReader.getDouble());}
b64c0d7cd0dcef111e8c0315064bd3d5ed08ab9fa3be5c08c5e77f55e210ee82
addValueToPrimitiveConverter
public void addValueToPrimitiveConverter(PrimitiveConverter primitiveConverter, ColumnReader columnReader)
{    primitiveConverter.addDouble(columnReader.getDouble());}
68379e2568daf3f6bdcc3d1d4225c8e269d30c5aaa52cc18df0a2dbf7d207160
convert
public T convert(PrimitiveTypeNameConverter<T, E> converter) throws E
{    return converter.convertDOUBLE(this);}
307199be2311599a65feb443179569a860be63cf06fc66d71f2e94b599a51346
comparator
 PrimitiveComparator<?> comparator(LogicalTypeAnnotation logicalType)
{    return PrimitiveComparator.DOUBLE_COMPARATOR;}
f607fa3620ba77a249defb6d5daea6abfaa5dad38e7a78aeecd5022e790a1934
toString
public String toString(ColumnReader columnReader)
{    return Arrays.toString(columnReader.getBinary().getBytesUnsafe());}
40e3309b06e540c9ea0085e7097a2cd81230e84a687d5c183bbe6fa7a88dd073
addValueToRecordConsumer
public void addValueToRecordConsumer(RecordConsumer recordConsumer, ColumnReader columnReader)
{    recordConsumer.addBinary(columnReader.getBinary());}
b64c0d7cd0dcef111e8c0315064bd3d5ed08ab9fa3be5c08c5e77f55e210ee82
addValueToPrimitiveConverter
public void addValueToPrimitiveConverter(PrimitiveConverter primitiveConverter, ColumnReader columnReader)
{    primitiveConverter.addBinary(columnReader.getBinary());}
68379e2568daf3f6bdcc3d1d4225c8e269d30c5aaa52cc18df0a2dbf7d207160
convert
public T convert(PrimitiveTypeNameConverter<T, E> converter) throws E
{    return converter.convertINT96(this);}
307199be2311599a65feb443179569a860be63cf06fc66d71f2e94b599a51346
comparator
 PrimitiveComparator<?> comparator(LogicalTypeAnnotation logicalType)
{    return PrimitiveComparator.BINARY_AS_SIGNED_INTEGER_COMPARATOR;}
f607fa3620ba77a249defb6d5daea6abfaa5dad38e7a78aeecd5022e790a1934
toString
public String toString(ColumnReader columnReader)
{    return String.valueOf(columnReader.getBinary());}
40e3309b06e540c9ea0085e7097a2cd81230e84a687d5c183bbe6fa7a88dd073
addValueToRecordConsumer
public void addValueToRecordConsumer(RecordConsumer recordConsumer, ColumnReader columnReader)
{    recordConsumer.addBinary(columnReader.getBinary());}
b64c0d7cd0dcef111e8c0315064bd3d5ed08ab9fa3be5c08c5e77f55e210ee82
addValueToPrimitiveConverter
public void addValueToPrimitiveConverter(PrimitiveConverter primitiveConverter, ColumnReader columnReader)
{    primitiveConverter.addBinary(columnReader.getBinary());}
68379e2568daf3f6bdcc3d1d4225c8e269d30c5aaa52cc18df0a2dbf7d207160
convert
public T convert(PrimitiveTypeNameConverter<T, E> converter) throws E
{    return converter.convertFIXED_LEN_BYTE_ARRAY(this);}
307199be2311599a65feb443179569a860be63cf06fc66d71f2e94b599a51346
comparator
 PrimitiveComparator<?> comparator(LogicalTypeAnnotation logicalType)
{    if (logicalType == null) {        return PrimitiveComparator.UNSIGNED_LEXICOGRAPHICAL_BINARY_COMPARATOR;    }    return logicalType.accept(new LogicalTypeAnnotation.LogicalTypeAnnotationVisitor<PrimitiveComparator>() {        @Override        public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType) {            return of(PrimitiveComparator.BINARY_AS_SIGNED_INTEGER_COMPARATOR);        }        @Override        public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.IntervalLogicalTypeAnnotation intervalLogicalType) {            return of(PrimitiveComparator.UNSIGNED_LEXICOGRAPHICAL_BINARY_COMPARATOR);        }    }).orElseThrow(() -> new ShouldNeverHappenException("No comparator logic implemented for FIXED_LEN_BYTE_ARRAY logical type: " + logicalType));}
3b039db18293eb729cc45b0e7e304d254bab66f40e6549d10efd16550745403a
visit
public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType)
{    return of(PrimitiveComparator.BINARY_AS_SIGNED_INTEGER_COMPARATOR);}
ac54afdf7aa50029bde8cd4d1350c4eb1b1bcafda5b209537a72d53ca6fa13de
visit
public Optional<PrimitiveComparator> visit(LogicalTypeAnnotation.IntervalLogicalTypeAnnotation intervalLogicalType)
{    return of(PrimitiveComparator.UNSIGNED_LEXICOGRAPHICAL_BINARY_COMPARATOR);}
1e18552fa5c94110ca0a6dd43db3fe1f8eefbe15468c3f0db690c5694389d906
requireValidColumnOrder
private ColumnOrder requireValidColumnOrder(ColumnOrder columnOrder)
{    if (primitive == PrimitiveTypeName.INT96) {        Preconditions.checkArgument(columnOrder.getColumnOrderName() == ColumnOrderName.UNDEFINED, "The column order {} is not supported by INT96", columnOrder);    }    if (getLogicalTypeAnnotation() != null) {        Preconditions.checkArgument(getLogicalTypeAnnotation().isValidColumnOrder(columnOrder), "The column order {} is not supported by {} ({})", columnOrder, primitive, getLogicalTypeAnnotation());    }    return columnOrder;}
4c1b118d491a54a4f7c65515155d57e1d96c0927390d8be00a284495da2bdc92
withId
public PrimitiveType withId(int id)
{    return new PrimitiveType(getRepetition(), primitive, length, getName(), getLogicalTypeAnnotation(), new ID(id), columnOrder);}
097b09f7eca0eed84a57c9dd6283922932810bd0f1c292e3112e6fe426c19e9b
getPrimitiveTypeName
public PrimitiveTypeName getPrimitiveTypeName()
{    return primitive;}
8ac76fd8edc40c354d5e8f3ab38abc789c351b489792e4a4341b58f445bb5490
getTypeLength
public int getTypeLength()
{    return length;}
98bc57b38e115c78e49ca42df055c06df0d17069d882077bfdd36782f184f99d
getDecimalMetadata
public DecimalMetadata getDecimalMetadata()
{    return decimalMeta;}
64b386a1706abe6de0c11f54f47cc84c8f77c5767e36fb8f820311d6c95a4a53
isPrimitive
public boolean isPrimitive()
{    return true;}
2ad4b24ef83d8afa81e2d7b1e6065156660a84c40b37119571edf7a59e7a5faa
accept
public void accept(TypeVisitor visitor)
{    visitor.visit(this);}
570d63fa9161ce008cc98d277ee34a13e1e542dbd5d92f09aca9a175e0a6a4ec
writeToStringBuilder
public void writeToStringBuilder(StringBuilder sb, String indent)
{    sb.append(indent).append(getRepetition().name().toLowerCase(Locale.ENGLISH)).append(" ").append(primitive.name().toLowerCase());    if (primitive == PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY) {        sb.append("(" + length + ")");    }    sb.append(" ").append(getName());    if (getLogicalTypeAnnotation() != null) {                sb.append(" (").append(getLogicalTypeAnnotation().toString()).append(")");    }    if (getId() != null) {        sb.append(" = ").append(getId());    }}
b695161937f56f11b33dc6daabe8047ae45cb84ba3d956fdd0bd870677ce1a1f
typeHashCode
protected int typeHashCode()
{    return hashCode();}
e2a6f02e8d484cb4743d48aef56cdd15a05308f099fb0949572d3b4e4f7b3a8b
typeEquals
protected boolean typeEquals(Type other)
{    return equals(other);}
cb0ecaccbf98c1881aa33c360f74e85207c3cc560733e9e09c8731a57c48f5be
equals
protected boolean equals(Type other)
{    if (!other.isPrimitive()) {        return false;    }    PrimitiveType otherPrimitive = other.asPrimitiveType();    return super.equals(other) && primitive == otherPrimitive.getPrimitiveTypeName() && length == otherPrimitive.length && columnOrder.equals(otherPrimitive.columnOrder) && eqOrBothNull(decimalMeta, otherPrimitive.decimalMeta);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int hash = super.hashCode();    hash = hash * 31 + primitive.hashCode();    hash = hash * 31 + length;    hash = hash * 31 + columnOrder.hashCode();    if (decimalMeta != null) {        hash = hash * 31 + decimalMeta.hashCode();    }    return hash;}
f5adda5a2eb8b3c570c6c69c1e23813e6ec8cad1cdff6079691687b7d0f2e779
getMaxRepetitionLevel
public int getMaxRepetitionLevel(String[] path, int i)
{    if (path.length != i) {        throw new InvalidRecordException("Arrived at primitive node, path invalid");    }    return isRepetition(Repetition.REPEATED) ? 1 : 0;}
a246734306034b7f5927287a8628e07eb02c7d281e611e0511b483407174dda5
getMaxDefinitionLevel
public int getMaxDefinitionLevel(String[] path, int i)
{    if (path.length != i) {        throw new InvalidRecordException("Arrived at primitive node, path invalid");    }    return isRepetition(Repetition.REQUIRED) ? 0 : 1;}
d7da6b8853d9c2c0878ea2c317f18756a684f9775746e022ad3f7d63027b8753
getType
public Type getType(String[] path, int i)
{    if (path.length != i) {        throw new InvalidRecordException("Arrived at primitive node at index " + i + " , path invalid: " + Arrays.toString(path));    }    return this;}
847d08310ad3a43210eb37221a4a840c2d254855161bbdaf6afc974c9c40f40f
getPaths
protected List<String[]> getPaths(int depth)
{    return Arrays.<String[]>asList(new String[depth]);}
49ab76876c091464c2cbd59a15c8cd1bc0d1de302dd739e09cf4d50ef9d48c01
checkContains
 void checkContains(Type subType)
{    super.checkContains(subType);    if (!subType.isPrimitive()) {        throw new InvalidRecordException(subType + " found: expected " + this);    }    PrimitiveType primitiveType = subType.asPrimitiveType();    if (this.primitive != primitiveType.primitive) {        throw new InvalidRecordException(subType + " found: expected " + this);    }}
de5e61b345254afe608c0f68453a4f3c72bd96d0962f4b2a54c3cefdabbd644e
convert
public T convert(List<GroupType> path, TypeConverter<T> converter)
{    return converter.convertPrimitiveType(path, this);}
1262e7fc42cd901269c3df711f8e81798a5a5c1bb9c6c43c92a2e5a78d45e938
containsPath
protected boolean containsPath(String[] path, int depth)
{    return path.length == depth;}
d966b5390003baeb4fea1b04eb1ea49d077ca302c5aad973f0b18753d637d922
union
protected Type union(Type toMerge)
{    return union(toMerge, true);}
9740ceed8a5652c940ece23a683164ba2bb37011813fa0aaec2da75d104d4d05
reportSchemaMergeError
private void reportSchemaMergeError(Type toMerge)
{    throw new IncompatibleSchemaModificationException("can not merge type " + toMerge + " into " + this);}
1a8a7c54129df79c76caa459fe4ca62dbd584a8ec514153f075e239bf5f97a2d
reportSchemaMergeErrorWithColumnOrder
private void reportSchemaMergeErrorWithColumnOrder(Type toMerge)
{    throw new IncompatibleSchemaModificationException("can not merge type " + toMerge + " with column order " + toMerge.asPrimitiveType().columnOrder() + " into " + this + " with column order " + columnOrder());}
20c2a1b030e0df8b9e83ef8192d32104a0e25404f00b6dabcfcc7fbb2078f0f2
union
protected Type union(Type toMerge, boolean strict)
{    if (!toMerge.isPrimitive()) {        reportSchemaMergeError(toMerge);    }    if (strict) {                if (!primitive.equals(toMerge.asPrimitiveType().getPrimitiveTypeName()) || !Objects.equals(getLogicalTypeAnnotation(), toMerge.getLogicalTypeAnnotation())) {            reportSchemaMergeError(toMerge);        }                int toMergeLength = toMerge.asPrimitiveType().getTypeLength();        if (primitive == PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY && length != toMergeLength) {            reportSchemaMergeError(toMerge);        }                if (!columnOrder().equals(toMerge.asPrimitiveType().columnOrder())) {            reportSchemaMergeErrorWithColumnOrder(toMerge);        }    }    Repetition repetition = Repetition.leastRestrictive(this.getRepetition(), toMerge.getRepetition());    Types.PrimitiveBuilder<PrimitiveType> builder = Types.primitive(primitive, repetition);    if (PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY == primitive) {        builder.length(length);    }    return builder.as(getLogicalTypeAnnotation()).named(getName());}
e449c50dc3b83cae2ca923891efd6701cabf707a01fbd69aebd7d0a058d87151
comparator
public PrimitiveComparator<T> comparator()
{    return (PrimitiveComparator<T>) getPrimitiveTypeName().comparator(getLogicalTypeAnnotation());}
bec71e2f20c3a8ffb235e1163cd7b9d78547706a59cc5b16a0344f466c805463
columnOrder
public ColumnOrder columnOrder()
{    return columnOrder;}
67b4dad2970752c29ac13ca95c1fe8e971253d0de3cbdbaed0c021e55190ccaa
stringifier
public PrimitiveStringifier stringifier()
{    LogicalTypeAnnotation logicalTypeAnnotation = getLogicalTypeAnnotation();    return logicalTypeAnnotation == null ? PrimitiveStringifier.DEFAULT_STRINGIFIER : logicalTypeAnnotation.valueStringifier(this);}
cea1c2c1f10d4b97004da212612fc3f2159fe44d7c7e24cd3c5e70653f0143a5
getId
public int getId()
{    return id;}
2e357842a94cbe0053b9335d638b77fbb7cf048124996f871e25c3069c81a0b7
intValue
public int intValue()
{    return id;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    return (obj instanceof ID) && ((ID) obj).id == id;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return id;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.valueOf(id);}
61a3316117f1d14d799f5a139ef1b231c28f835124b15f5ce207a9485f75acec
leastRestrictive
public static Repetition leastRestrictive(Repetition... repetitions)
{    boolean hasOptional = false;    for (Repetition repetition : repetitions) {        if (repetition == REPEATED) {            return REPEATED;        } else if (repetition == OPTIONAL) {            hasOptional = true;        }    }    if (hasOptional) {        return OPTIONAL;    }    return REQUIRED;}
342e15d9b0dfe6fad5727eb5db01fd990ed706a1ec7d4751528f8a3ee982a869
isMoreRestrictiveThan
public boolean isMoreRestrictiveThan(Repetition other)
{    return other != REQUIRED;}
342e15d9b0dfe6fad5727eb5db01fd990ed706a1ec7d4751528f8a3ee982a869
isMoreRestrictiveThan
public boolean isMoreRestrictiveThan(Repetition other)
{    return other == REPEATED;}
342e15d9b0dfe6fad5727eb5db01fd990ed706a1ec7d4751528f8a3ee982a869
isMoreRestrictiveThan
public boolean isMoreRestrictiveThan(Repetition other)
{    return false;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
2966341c0d6bcbc49620e5ea1ae7d41cfafa93e978fd202a11c4ac7c9eeb2f86
isRepetition
public boolean isRepetition(Repetition rep)
{    return repetition == rep;}
a7bdec9252df81f10edc7f0c4aac7dcbc53263d2f084e3e5d52b4786a7474443
getRepetition
public Repetition getRepetition()
{    return repetition;}
3fe1144135b88ded4e6c6375eefa8b8e38cb3b6aa0b57406ef84b8bbcaa69f2e
getId
public ID getId()
{    return id;}
f235032e7a775a063f407ecc0e35499e201354c23abd9804d95f3ee0fe25f372
getLogicalTypeAnnotation
public LogicalTypeAnnotation getLogicalTypeAnnotation()
{    return logicalTypeAnnotation;}
6efa35a5ffe2d1fa87778534874d8cee8fc38aac7b47ea854dece2c38c6575a5
getOriginalType
public OriginalType getOriginalType()
{    return logicalTypeAnnotation == null ? null : logicalTypeAnnotation.toOriginalType();}
139855eabdad0ce298f0911c31190bbd2837556b25c13a3e4f014440d1d97c89
asGroupType
public GroupType asGroupType()
{    if (isPrimitive()) {        throw new ClassCastException(this + " is not a group");    }    return (GroupType) this;}
92875207bce70d5fee9b47ce53662d7e64390390f5755707cf57e9ccd8f5e554
asPrimitiveType
public PrimitiveType asPrimitiveType()
{    if (!isPrimitive()) {        throw new ClassCastException(this + " is not primitive");    }    return (PrimitiveType) this;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int c = repetition.hashCode();    c = 31 * c + name.hashCode();    if (logicalTypeAnnotation != null) {        c = 31 * c + logicalTypeAnnotation.hashCode();    }    if (id != null) {        c = 31 * c + id.hashCode();    }    return c;}
cb0ecaccbf98c1881aa33c360f74e85207c3cc560733e9e09c8731a57c48f5be
equals
protected boolean equals(Type other)
{    return name.equals(other.name) && repetition == other.repetition && eqOrBothNull(repetition, other.repetition) && eqOrBothNull(id, other.id) && eqOrBothNull(logicalTypeAnnotation, other.logicalTypeAnnotation);}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    if (!(other instanceof Type) || other == null) {        return false;    }    return equals((Type) other);}
e8277d902129ddb61710b80949a8c2be5b686ad476dfa18510d5498e8e9a460e
eqOrBothNull
protected boolean eqOrBothNull(Object o1, Object o2)
{    return (o1 == null && o2 == null) || (o1 != null && o1.equals(o2));}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder();    writeToStringBuilder(sb, "");    return sb.toString();}
49ab76876c091464c2cbd59a15c8cd1bc0d1de302dd739e09cf4d50ef9d48c01
checkContains
 void checkContains(Type subType)
{    if (!this.name.equals(subType.name) || this.repetition != subType.repetition) {        throw new InvalidRecordException(subType + " found: expected " + this);    }}
830fa07c072077bb0d83929e6166692b512ef92d608eaf9ea8d3c478db285197
repetition
protected final THIS repetition(Type.Repetition repetition)
{    Preconditions.checkArgument(!repetitionAlreadySet, "Repetition has already been set");    Preconditions.checkNotNull(repetition, "Repetition cannot be null");    this.repetition = repetition;    this.repetitionAlreadySet = true;    return self();}
af561fffc26f8bd2ac1dbcee626f32fc1122e94f16265d326651f748dd024d95
as
public THIS as(OriginalType type)
{    this.logicalTypeAnnotation = LogicalTypeAnnotation.fromOriginalType(type, null);    return self();}
87bb21652e531ef3009f0200f22a8cdfda74b7c4882cd0c105eed5e118dc426f
as
public THIS as(LogicalTypeAnnotation type)
{    this.logicalTypeAnnotation = type;    this.newLogicalTypeSet = true;    return self();}
ebb4b81c9bfbd3bc68a9c92f2598e50f37130862c684a5f3904a2eacf317bd9d
id
public THIS id(int id)
{    this.id = new ID(id);    return self();}
7bb82c3aac3fbe53b8c05aa97df34002ea2b4ab5cf6bfaa23e086b51f5713a87
named
public P named(String name)
{    Preconditions.checkNotNull(name, "Name is required");    Preconditions.checkNotNull(repetition, "Repetition is required");    Type type = build(name);    if (parent != null) {                if (BaseGroupBuilder.class.isAssignableFrom(parent.getClass())) {            BaseGroupBuilder.class.cast(parent).addField(type);        }        return parent;    } else if (returnClass != null) {                return returnClass.cast(type);    } else {        throw new IllegalStateException("[BUG] Parent and return type are null: must override named");    }}
fdf4e20ee80c0f50122194c6a10205383d89dd707839af25102e8ef17b1e2c00
getOriginalType
protected OriginalType getOriginalType()
{    return logicalTypeAnnotation == null ? null : logicalTypeAnnotation.toOriginalType();}
91088cea68f4582fcf7bc1d38bfc28d44954b9cddbf5dfb0d9f394e5b110773f
length
public THIS length(int length)
{    this.length = length;    return self();}
47b821bcccebccc8bab6ae22324bdc2c6ddd75ac000b6d0dcf21b531b09f0e53
precision
public THIS precision(int precision)
{    this.precision = precision;    precisionAlreadySet = true;    return self();}
4265891e9f2d900367347bdbe6249310e94738fdfbd0280bdf697a0957fd6e99
scale
public THIS scale(int scale)
{    this.scale = scale;    scaleAlreadySet = true;    return self();}
a6b9cc0e519868f5dc5c929b74fbaa820a93bf421292fc9201d7876a24390f25
columnOrder
public THIS columnOrder(ColumnOrder columnOrder)
{    this.columnOrder = columnOrder;    return self();}
6aeb7ec2f6f9e08ad2d2b151dee55a2efd4ace9b92bb6221b419639f63e30603
build
protected PrimitiveType build(String name)
{    if (PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY == primitiveType) {        Preconditions.checkArgument(length > 0, "Invalid FIXED_LEN_BYTE_ARRAY length: " + length);    }    DecimalMetadata meta = decimalMetadata();        if (logicalTypeAnnotation != null) {        logicalTypeAnnotation.accept(new LogicalTypeAnnotation.LogicalTypeAnnotationVisitor<Boolean>() {            @Override            public Optional<Boolean> visit(LogicalTypeAnnotation.StringLogicalTypeAnnotation stringLogicalType) {                checkBinaryPrimitiveType(stringLogicalType);                return Optional.of(true);            }            @Override            public Optional<Boolean> visit(LogicalTypeAnnotation.JsonLogicalTypeAnnotation jsonLogicalType) {                checkBinaryPrimitiveType(jsonLogicalType);                return Optional.of(true);            }            @Override            public Optional<Boolean> visit(LogicalTypeAnnotation.BsonLogicalTypeAnnotation bsonLogicalType) {                checkBinaryPrimitiveType(bsonLogicalType);                return Optional.of(true);            }            @Override            public Optional<Boolean> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType) {                Preconditions.checkState((primitiveType == PrimitiveTypeName.INT32) || (primitiveType == PrimitiveTypeName.INT64) || (primitiveType == PrimitiveTypeName.BINARY) || (primitiveType == PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY), "DECIMAL can only annotate INT32, INT64, BINARY, and FIXED");                if (primitiveType == PrimitiveTypeName.INT32) {                    Preconditions.checkState(meta.getPrecision() <= MAX_PRECISION_INT32, "INT32 cannot store " + meta.getPrecision() + " digits " + "(max " + MAX_PRECISION_INT32 + ")");                } else if (primitiveType == PrimitiveTypeName.INT64) {                    Preconditions.checkState(meta.getPrecision() <= MAX_PRECISION_INT64, "INT64 cannot store " + meta.getPrecision() + " digits " + "(max " + MAX_PRECISION_INT64 + ")");                    if (meta.getPrecision() <= MAX_PRECISION_INT32) {                        LOGGER.warn("Decimal with {} digits is stored in an INT64, but fits in an INT32. See {}.", precision, LOGICAL_TYPES_DOC_URL);                    }                } else if (primitiveType == PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY) {                    Preconditions.checkState(meta.getPrecision() <= maxPrecision(length), "FIXED(" + length + ") cannot store " + meta.getPrecision() + " digits (max " + maxPrecision(length) + ")");                }                return Optional.of(true);            }            @Override            public Optional<Boolean> visit(LogicalTypeAnnotation.DateLogicalTypeAnnotation dateLogicalType) {                checkInt32PrimitiveType(dateLogicalType);                return Optional.of(true);            }            @Override            public Optional<Boolean> visit(LogicalTypeAnnotation.TimeLogicalTypeAnnotation timeLogicalType) {                LogicalTypeAnnotation.TimeUnit unit = timeLogicalType.getUnit();                switch(unit) {                    case MILLIS:                        checkInt32PrimitiveType(timeLogicalType);                        break;                    case MICROS:                    case NANOS:                        checkInt64PrimitiveType(timeLogicalType);                        break;                    default:                        throw new RuntimeException("Invalid time unit: " + unit);                }                return Optional.of(true);            }            @Override            public Optional<Boolean> visit(LogicalTypeAnnotation.IntLogicalTypeAnnotation intLogicalType) {                int bitWidth = intLogicalType.getBitWidth();                switch(bitWidth) {                    case 8:                    case 16:                    case 32:                        checkInt32PrimitiveType(intLogicalType);                        break;                    case 64:                        checkInt64PrimitiveType(intLogicalType);                        break;                    default:                        throw new RuntimeException("Invalid bit width: " + bitWidth);                }                return Optional.of(true);            }            @Override            public Optional<Boolean> visit(LogicalTypeAnnotation.TimestampLogicalTypeAnnotation timestampLogicalType) {                checkInt64PrimitiveType(timestampLogicalType);                return Optional.of(true);            }            @Override            public Optional<Boolean> visit(LogicalTypeAnnotation.IntervalLogicalTypeAnnotation intervalLogicalType) {                Preconditions.checkState((primitiveType == PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY) && (length == 12), "INTERVAL can only annotate FIXED_LEN_BYTE_ARRAY(12)");                return Optional.of(true);            }            @Override            public Optional<Boolean> visit(LogicalTypeAnnotation.EnumLogicalTypeAnnotation enumLogicalType) {                Preconditions.checkState(primitiveType == PrimitiveTypeName.BINARY, "ENUM can only annotate binary fields");                return Optional.of(true);            }            private void checkBinaryPrimitiveType(LogicalTypeAnnotation logicalTypeAnnotation) {                Preconditions.checkState(primitiveType == PrimitiveTypeName.BINARY, logicalTypeAnnotation.toString() + " can only annotate binary fields");            }            private void checkInt32PrimitiveType(LogicalTypeAnnotation logicalTypeAnnotation) {                Preconditions.checkState(primitiveType == PrimitiveTypeName.INT32, logicalTypeAnnotation.toString() + " can only annotate INT32");            }            private void checkInt64PrimitiveType(LogicalTypeAnnotation logicalTypeAnnotation) {                Preconditions.checkState(primitiveType == PrimitiveTypeName.INT64, logicalTypeAnnotation.toString() + " can only annotate INT64");            }        }).orElseThrow(() -> new IllegalStateException(logicalTypeAnnotation + " can not be applied to a primitive type"));    }    if (newLogicalTypeSet) {        return new PrimitiveType(repetition, primitiveType, length, name, logicalTypeAnnotation, id, columnOrder);    } else {        return new PrimitiveType(repetition, primitiveType, length, name, getOriginalType(), meta, id, columnOrder);    }}
d80b613df9b0ab1e49bb46ebb5a03698d55355bef42c5add11ebf44a13a37f9c
visit
public Optional<Boolean> visit(LogicalTypeAnnotation.StringLogicalTypeAnnotation stringLogicalType)
{    checkBinaryPrimitiveType(stringLogicalType);    return Optional.of(true);}
3dbaf38d6551c8b554cfac8974dd3f05c272611e3cf2e4f62f6fbf1871cca583
visit
public Optional<Boolean> visit(LogicalTypeAnnotation.JsonLogicalTypeAnnotation jsonLogicalType)
{    checkBinaryPrimitiveType(jsonLogicalType);    return Optional.of(true);}
d56c303a26723f33dd815d7577ec60eef6c72145b1f59e56da8daefb5e3ea81f
visit
public Optional<Boolean> visit(LogicalTypeAnnotation.BsonLogicalTypeAnnotation bsonLogicalType)
{    checkBinaryPrimitiveType(bsonLogicalType);    return Optional.of(true);}
32f57f28254ea8e3938fe66b1013fe61c1f8efe476e99b38a71412facd0694de
visit
public Optional<Boolean> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType)
{    Preconditions.checkState((primitiveType == PrimitiveTypeName.INT32) || (primitiveType == PrimitiveTypeName.INT64) || (primitiveType == PrimitiveTypeName.BINARY) || (primitiveType == PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY), "DECIMAL can only annotate INT32, INT64, BINARY, and FIXED");    if (primitiveType == PrimitiveTypeName.INT32) {        Preconditions.checkState(meta.getPrecision() <= MAX_PRECISION_INT32, "INT32 cannot store " + meta.getPrecision() + " digits " + "(max " + MAX_PRECISION_INT32 + ")");    } else if (primitiveType == PrimitiveTypeName.INT64) {        Preconditions.checkState(meta.getPrecision() <= MAX_PRECISION_INT64, "INT64 cannot store " + meta.getPrecision() + " digits " + "(max " + MAX_PRECISION_INT64 + ")");        if (meta.getPrecision() <= MAX_PRECISION_INT32) {            LOGGER.warn("Decimal with {} digits is stored in an INT64, but fits in an INT32. See {}.", precision, LOGICAL_TYPES_DOC_URL);        }    } else if (primitiveType == PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY) {        Preconditions.checkState(meta.getPrecision() <= maxPrecision(length), "FIXED(" + length + ") cannot store " + meta.getPrecision() + " digits (max " + maxPrecision(length) + ")");    }    return Optional.of(true);}
723122d8afc8fb75ed5d55ee7dfae0c477b325de6be3012d9d21256ea0cbaa3f
visit
public Optional<Boolean> visit(LogicalTypeAnnotation.DateLogicalTypeAnnotation dateLogicalType)
{    checkInt32PrimitiveType(dateLogicalType);    return Optional.of(true);}
53171cff378369baa24042838c3186061828f13ff7c15f7d5062bc72172e001a
visit
public Optional<Boolean> visit(LogicalTypeAnnotation.TimeLogicalTypeAnnotation timeLogicalType)
{    LogicalTypeAnnotation.TimeUnit unit = timeLogicalType.getUnit();    switch(unit) {        case MILLIS:            checkInt32PrimitiveType(timeLogicalType);            break;        case MICROS:        case NANOS:            checkInt64PrimitiveType(timeLogicalType);            break;        default:            throw new RuntimeException("Invalid time unit: " + unit);    }    return Optional.of(true);}
2c61ff4c842a38f2e72e511bed00038c33fcf6e6d2badbbf7c4269901eb8d1f2
visit
public Optional<Boolean> visit(LogicalTypeAnnotation.IntLogicalTypeAnnotation intLogicalType)
{    int bitWidth = intLogicalType.getBitWidth();    switch(bitWidth) {        case 8:        case 16:        case 32:            checkInt32PrimitiveType(intLogicalType);            break;        case 64:            checkInt64PrimitiveType(intLogicalType);            break;        default:            throw new RuntimeException("Invalid bit width: " + bitWidth);    }    return Optional.of(true);}
665c85eede9df4cc01c6f8b630c214da656f3e8f7ef7136bb7ae2b4667f3ec7e
visit
public Optional<Boolean> visit(LogicalTypeAnnotation.TimestampLogicalTypeAnnotation timestampLogicalType)
{    checkInt64PrimitiveType(timestampLogicalType);    return Optional.of(true);}
1afd93c2ead01ed6dc3dfe7611d01be6324eab3fe9bd29be1c1c64003c77972f
visit
public Optional<Boolean> visit(LogicalTypeAnnotation.IntervalLogicalTypeAnnotation intervalLogicalType)
{    Preconditions.checkState((primitiveType == PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY) && (length == 12), "INTERVAL can only annotate FIXED_LEN_BYTE_ARRAY(12)");    return Optional.of(true);}
8fa25eb776fc95ada4c27821dacc427734d0467530a2b86f4743bc1f4573c74f
visit
public Optional<Boolean> visit(LogicalTypeAnnotation.EnumLogicalTypeAnnotation enumLogicalType)
{    Preconditions.checkState(primitiveType == PrimitiveTypeName.BINARY, "ENUM can only annotate binary fields");    return Optional.of(true);}
2014fd67607b1cfb018110c09dfc423588476d2c6e480d72a1f2b2c66c41cabb
checkBinaryPrimitiveType
private void checkBinaryPrimitiveType(LogicalTypeAnnotation logicalTypeAnnotation)
{    Preconditions.checkState(primitiveType == PrimitiveTypeName.BINARY, logicalTypeAnnotation.toString() + " can only annotate binary fields");}
858c36d22646dd8e1fcc126f775558345c438680e5ca275c558c0c0818c89f6a
checkInt32PrimitiveType
private void checkInt32PrimitiveType(LogicalTypeAnnotation logicalTypeAnnotation)
{    Preconditions.checkState(primitiveType == PrimitiveTypeName.INT32, logicalTypeAnnotation.toString() + " can only annotate INT32");}
00b2329e116d748bba4b0b6de6da266b921a4c7cbaae0d4613944e8447fac231
checkInt64PrimitiveType
private void checkInt64PrimitiveType(LogicalTypeAnnotation logicalTypeAnnotation)
{    Preconditions.checkState(primitiveType == PrimitiveTypeName.INT64, logicalTypeAnnotation.toString() + " can only annotate INT64");}
be18e8a1a58e5561fe838522879a9c14c5374d75aa9b886e703d90cbd2abcc4b
maxPrecision
private static long maxPrecision(int numBytes)
{    return     Math.round(Math.floor(    Math.log10(    Math.pow(2, 8 * numBytes - 1) - 1)));}
ccbd1b96c74a6d47d0b779fb1853477974c550b2e4be6a1105fe0a96953025b4
decimalMetadata
protected DecimalMetadata decimalMetadata()
{    DecimalMetadata meta = null;    if (logicalTypeAnnotation instanceof LogicalTypeAnnotation.DecimalLogicalTypeAnnotation) {        LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalType = (LogicalTypeAnnotation.DecimalLogicalTypeAnnotation) logicalTypeAnnotation;        if (newLogicalTypeSet) {            if (scaleAlreadySet) {                Preconditions.checkArgument(this.scale == decimalType.getScale(), "Decimal scale should match with the scale of the logical type");            }            if (precisionAlreadySet) {                Preconditions.checkArgument(this.precision == decimalType.getPrecision(), "Decimal precision should match with the precision of the logical type");            }            scale = decimalType.getScale();            precision = decimalType.getPrecision();        }        Preconditions.checkArgument(precision > 0, "Invalid DECIMAL precision: " + precision);        Preconditions.checkArgument(this.scale >= 0, "Invalid DECIMAL scale: " + this.scale);        Preconditions.checkArgument(this.scale <= precision, "Invalid DECIMAL scale: cannot be greater than precision");        meta = new DecimalMetadata(precision, scale);    }    return meta;}
307e4a29a3b3ed64a9e20768d68cb934a1410db22bf2d87f6b8dcc8876871bfa
self
protected PrimitiveBuilder<P> self()
{    return this;}
22232e411081c837760c7bcccdfd7be943876d2be98cba3e4790f21be955d56d
primitive
public PrimitiveBuilder<THIS> primitive(PrimitiveTypeName type, Type.Repetition repetition)
{    return new PrimitiveBuilder<THIS>(self(), type).repetition(repetition);}
7d0ae3aec95d00548455bf62b32cf3e0dfaf3bfaaa878b58b3c6c677ea87de95
required
public PrimitiveBuilder<THIS> required(PrimitiveTypeName type)
{    return new PrimitiveBuilder<THIS>(self(), type).repetition(Type.Repetition.REQUIRED);}
747ddbcbf80917b4de822436536a465284ab8ad04425b41e5a93900186a4365a
optional
public PrimitiveBuilder<THIS> optional(PrimitiveTypeName type)
{    return new PrimitiveBuilder<THIS>(self(), type).repetition(Type.Repetition.OPTIONAL);}
d8e1635b7a24cd220ae833edccace1c263e839d316716a08fe40af07fac44422
repeated
public PrimitiveBuilder<THIS> repeated(PrimitiveTypeName type)
{    return new PrimitiveBuilder<THIS>(self(), type).repetition(Type.Repetition.REPEATED);}
b56e55d47b742a4a53bf7d22b13921aa1bccf85cdea5224d12a614610763b9cb
group
public GroupBuilder<THIS> group(Type.Repetition repetition)
{    return new GroupBuilder<THIS>(self()).repetition(repetition);}
807aa9b610c852ed156691e81f0ce630737342b836e4ffb6e4730de0db428b9b
requiredGroup
public GroupBuilder<THIS> requiredGroup()
{    return new GroupBuilder<THIS>(self()).repetition(Type.Repetition.REQUIRED);}
2b019050ac17ee21e980706ee58d72bb755ad91389110eb8ee802f5424b2b2f0
optionalGroup
public GroupBuilder<THIS> optionalGroup()
{    return new GroupBuilder<THIS>(self()).repetition(Type.Repetition.OPTIONAL);}
438c3b95b317b7b63ae42bccb114a9ab1ea5f8eb2cc29988a309589d7c917222
repeatedGroup
public GroupBuilder<THIS> repeatedGroup()
{    return new GroupBuilder<THIS>(self()).repetition(Type.Repetition.REPEATED);}
8c24d5913dc16e5604679d0723ff085afe5a31efc945e373c927d46f0dbf60a6
addField
public THIS addField(Type type)
{    fields.add(type);    return self();}
ae778f46b63f0e2c55ecefcef75831614e33c81570ddfee2ac92b5540688fc7e
addFields
public THIS addFields(Type... types)
{    Collections.addAll(fields, types);    return self();}
aa2be9eb9408aa0e1deeb61a3f65a966690b2710c13224e5f6ea9412b37710c5
build
protected GroupType build(String name)
{    if (newLogicalTypeSet) {        return new GroupType(repetition, name, logicalTypeAnnotation, fields, id);    } else {        return new GroupType(repetition, name, getOriginalType(), fields, id);    }}
f0726e6d27c6e80ac9e21714f8e36c97aa89fb681ba47bb73c00e70d1a5bb0aa
map
public MapBuilder<THIS> map(Type.Repetition repetition)
{    return new MapBuilder<THIS>(self()).repetition(repetition);}
9bec8fd1470b8d9c89fe9d005e6728a0412a8d0bb7707323e476b2be18761c18
requiredMap
public MapBuilder<THIS> requiredMap()
{    return new MapBuilder<THIS>(self()).repetition(Type.Repetition.REQUIRED);}
d8ee1f5f3149fd796843ee97f57a4c349ac88b3549170e190077d5ee0d249b8b
optionalMap
public MapBuilder<THIS> optionalMap()
{    return new MapBuilder<THIS>(self()).repetition(Type.Repetition.OPTIONAL);}
352eb94549ae7aa2001f9536022b75b50f2de962b5de32f45e4105111d81844e
list
public ListBuilder<THIS> list(Type.Repetition repetition)
{    return new ListBuilder<THIS>(self()).repetition(repetition);}
1a6281a54752f4fc7ce82f0a24414f4f1dcec797523538c0a21de7d6ab463d48
requiredList
public ListBuilder<THIS> requiredList()
{    return list(Type.Repetition.REQUIRED);}
189918afb01d5bf886097a9ae014453e9c6865303cb43c8b1002a9483d758c6a
optionalList
public ListBuilder<THIS> optionalList()
{    return list(Type.Repetition.OPTIONAL);}
2341a3034eb72f65dab0bf712dfc6ce17a23408218c46db4acab8da571c066f5
self
protected GroupBuilder<P> self()
{    return this;}
efde0904ce0d833686e1b5583687275677621390d13dc4876e592b87a896733d
value
public ValueBuilder<MP, M> value(PrimitiveTypeName type, Type.Repetition repetition)
{    mapBuilder.setKeyType(build("key"));    return new ValueBuilder<MP, M>(mapBuilder, type).repetition(repetition);}
b6d35e0a383d1b360d44bd1e423ef0e52118be197c45e011d73b4c7396761b95
requiredValue
public ValueBuilder<MP, M> requiredValue(PrimitiveTypeName type)
{    return value(type, Type.Repetition.REQUIRED);}
3d48c2c2c8ac45b34e23d081783e7a27a31c1fa64a900a882cfe9e3b747c7915
optionalValue
public ValueBuilder<MP, M> optionalValue(PrimitiveTypeName type)
{    return value(type, Type.Repetition.OPTIONAL);}
fe1f5f55a23d1d09216bcf8299b0b038e5884625e11f513dae246631d1c115c5
groupValue
public GroupValueBuilder<MP, M> groupValue(Type.Repetition repetition)
{    mapBuilder.setKeyType(build("key"));    return new GroupValueBuilder<MP, M>(mapBuilder).repetition(repetition);}
350df983330e4ac814ab8e2579c361f64cf98be9f0fef62b2811501415a74afb
requiredGroupValue
public GroupValueBuilder<MP, M> requiredGroupValue()
{    return groupValue(Type.Repetition.REQUIRED);}
c95a348970cff7ed24f2f924b8a83f87649a9e91508f9cafd36f3f01462dedb0
optionalGroupValue
public GroupValueBuilder<MP, M> optionalGroupValue()
{    return groupValue(Type.Repetition.OPTIONAL);}
263f2b23dc181a1d9b64d3f90984b74334007bb375db0c59d684b7288585291a
mapValue
public MapValueBuilder<MP, M> mapValue(Type.Repetition repetition)
{    mapBuilder.setKeyType(build("key"));    return new MapValueBuilder<MP, M>(mapBuilder).repetition(repetition);}
77b2e22ccb86bd2c89a35f106cf49475e162a07cb1fb30d8651781a328aebff7
requiredMapValue
public MapValueBuilder<MP, M> requiredMapValue()
{    return mapValue(Type.Repetition.REQUIRED);}
8396768d11de78adfd74a94aac3f3db79598539862a9f98f6c4dab259edad7f8
optionalMapValue
public MapValueBuilder<MP, M> optionalMapValue()
{    return mapValue(Type.Repetition.OPTIONAL);}
baf9823c09af628ba0345912b0c69f00dc49b18637cf78a39f9480ed4bda00e9
listValue
public ListValueBuilder<MP, M> listValue(Type.Repetition repetition)
{    mapBuilder.setKeyType(build("key"));    return new ListValueBuilder<MP, M>(mapBuilder).repetition(repetition);}
2a1a56c758431e8faec67a2f523e266f92208fa0b0f264ad250f33cb31a821d9
requiredListValue
public ListValueBuilder<MP, M> requiredListValue()
{    return listValue(Type.Repetition.REQUIRED);}
095632329a02c5af23ff21c5105caa43cb0bcd8685e559bb855ba3a0b487cecf
optionalListValue
public ListValueBuilder<MP, M> optionalListValue()
{    return listValue(Type.Repetition.OPTIONAL);}
16731bead74d03f135e790afd1a44274319b766649196a4ac5452a05f5df75ad
value
public M value(Type type)
{    mapBuilder.setKeyType(build("key"));    mapBuilder.setValueType(type);    return this.mapBuilder;}
86fbc1de9c077a8f055ee4d89dad69d5b352eb3261d3f8ff4ebc7d2fe554c488
named
public MP named(String name)
{    mapBuilder.setKeyType(build("key"));    return mapBuilder.named(name);}
c155aba023aa2e7fcbe6b2bc04d30df6cb7e01cb48fd1559dcba8fd75282c3be
self
protected KeyBuilder<MP, M> self()
{    return this;}
86fbc1de9c077a8f055ee4d89dad69d5b352eb3261d3f8ff4ebc7d2fe554c488
named
public MP named(String name)
{    mapBuilder.setValueType(build("value"));    return mapBuilder.named(name);}
528e1412d09bae8307da5a89d16fb44c44fd4f65f9e1da4bbe6768502c391afc
self
protected ValueBuilder<MP, M> self()
{    return this;}
482835e4c664e7c9668e8c23d0df567b8cd5c0e6e7b364e7575b0d8e37ba098f
self
protected GroupKeyBuilder<MP, M> self()
{    return this;}
efde0904ce0d833686e1b5583687275677621390d13dc4876e592b87a896733d
value
public ValueBuilder<MP, M> value(PrimitiveTypeName type, Type.Repetition repetition)
{    mapBuilder.setKeyType(build("key"));    return new ValueBuilder<MP, M>(mapBuilder, type).repetition(repetition);}
b6d35e0a383d1b360d44bd1e423ef0e52118be197c45e011d73b4c7396761b95
requiredValue
public ValueBuilder<MP, M> requiredValue(PrimitiveTypeName type)
{    return value(type, Type.Repetition.REQUIRED);}
3d48c2c2c8ac45b34e23d081783e7a27a31c1fa64a900a882cfe9e3b747c7915
optionalValue
public ValueBuilder<MP, M> optionalValue(PrimitiveTypeName type)
{    return value(type, Type.Repetition.OPTIONAL);}
fe1f5f55a23d1d09216bcf8299b0b038e5884625e11f513dae246631d1c115c5
groupValue
public GroupValueBuilder<MP, M> groupValue(Type.Repetition repetition)
{    mapBuilder.setKeyType(build("key"));    return new GroupValueBuilder<MP, M>(mapBuilder).repetition(repetition);}
350df983330e4ac814ab8e2579c361f64cf98be9f0fef62b2811501415a74afb
requiredGroupValue
public GroupValueBuilder<MP, M> requiredGroupValue()
{    return groupValue(Type.Repetition.REQUIRED);}
c95a348970cff7ed24f2f924b8a83f87649a9e91508f9cafd36f3f01462dedb0
optionalGroupValue
public GroupValueBuilder<MP, M> optionalGroupValue()
{    return groupValue(Type.Repetition.OPTIONAL);}
263f2b23dc181a1d9b64d3f90984b74334007bb375db0c59d684b7288585291a
mapValue
public MapValueBuilder<MP, M> mapValue(Type.Repetition repetition)
{    mapBuilder.setKeyType(build("key"));    return new MapValueBuilder<MP, M>(mapBuilder).repetition(repetition);}
77b2e22ccb86bd2c89a35f106cf49475e162a07cb1fb30d8651781a328aebff7
requiredMapValue
public MapValueBuilder<MP, M> requiredMapValue()
{    return mapValue(Type.Repetition.REQUIRED);}
8396768d11de78adfd74a94aac3f3db79598539862a9f98f6c4dab259edad7f8
optionalMapValue
public MapValueBuilder<MP, M> optionalMapValue()
{    return mapValue(Type.Repetition.OPTIONAL);}
baf9823c09af628ba0345912b0c69f00dc49b18637cf78a39f9480ed4bda00e9
listValue
public ListValueBuilder<MP, M> listValue(Type.Repetition repetition)
{    mapBuilder.setKeyType(build("key"));    return new ListValueBuilder<MP, M>(mapBuilder).repetition(repetition);}
2a1a56c758431e8faec67a2f523e266f92208fa0b0f264ad250f33cb31a821d9
requiredListValue
public ListValueBuilder<MP, M> requiredListValue()
{    return listValue(Type.Repetition.REQUIRED);}
095632329a02c5af23ff21c5105caa43cb0bcd8685e559bb855ba3a0b487cecf
optionalListValue
public ListValueBuilder<MP, M> optionalListValue()
{    return listValue(Type.Repetition.OPTIONAL);}
16731bead74d03f135e790afd1a44274319b766649196a4ac5452a05f5df75ad
value
public M value(Type type)
{    mapBuilder.setKeyType(build("key"));    mapBuilder.setValueType(type);    return this.mapBuilder;}
86fbc1de9c077a8f055ee4d89dad69d5b352eb3261d3f8ff4ebc7d2fe554c488
named
public MP named(String name)
{    mapBuilder.setKeyType(build("key"));    return mapBuilder.named(name);}
86fbc1de9c077a8f055ee4d89dad69d5b352eb3261d3f8ff4ebc7d2fe554c488
named
public MP named(String name)
{    mapBuilder.setValueType(build("value"));    return mapBuilder.named(name);}
4d81822834b663cbd80cf85950f87daca7a3db8664acc2a5b6a26b712fd95db3
self
protected GroupValueBuilder<MP, M> self()
{    return this;}
86fbc1de9c077a8f055ee4d89dad69d5b352eb3261d3f8ff4ebc7d2fe554c488
named
public MP named(String name)
{    mapBuilder.setValueType(build("value"));    return mapBuilder.named(name);}
f77c8a82d91df889b7df6398de66a8a9ef4c00d2b57a20ad48d31226429fb4a6
self
protected MapValueBuilder<MP, M> self()
{    return this;}
86fbc1de9c077a8f055ee4d89dad69d5b352eb3261d3f8ff4ebc7d2fe554c488
named
public MP named(String name)
{    mapBuilder.setValueType(build("value"));    return mapBuilder.named(name);}
b51fd0a28f06ea43a44a53fea41d13015ffc520fd5293d1da3a96743cb390bf6
self
protected ListValueBuilder<MP, M> self()
{    return this;}
53eefed7fc4a62cb11c71b1b4b9eed98a616edf966c892102e85c79a6fc345f4
setKeyType
protected void setKeyType(Type keyType)
{    Preconditions.checkState(this.keyType == null, "Only one key type can be built with a MapBuilder");    this.keyType = keyType;}
be542b949ea8e196760abe6b997930cdd9502a019c40cd014aff3b718392b69e
setValueType
protected void setValueType(Type valueType)
{    Preconditions.checkState(this.valueType == null, "Only one key type can be built with a ValueBuilder");    this.valueType = valueType;}
2291795e2fa1642471f47da9cbcbde7c7bd512a60c386c2293bb966e8d7b85fb
key
public KeyBuilder<P, THIS> key(PrimitiveTypeName type)
{    return new KeyBuilder<P, THIS>(self(), type);}
57315e1675271a3917415e26b8d4633027aa97ffa921c64b4c233dd432c62f14
key
public THIS key(Type type)
{    setKeyType(type);    return self();}
4be355acdae2e1cbc30bb7190a8c5e858d4e73ed8b6285eaa1a9fa092a168958
groupKey
public GroupKeyBuilder<P, THIS> groupKey()
{    return new GroupKeyBuilder<P, THIS>(self());}
f1d92ce7e765b8a1e2c88197de1584b0448ddde6a0028ef4f33e8ba14ac2108e
value
public ValueBuilder<P, THIS> value(PrimitiveTypeName type, Type.Repetition repetition)
{    return new ValueBuilder<P, THIS>(self(), type).repetition(repetition);}
e646a831f1b77a1cca068796e454e6888bdc2af6a8cc60ea8fdb3c14f97dd37a
requiredValue
public ValueBuilder<P, THIS> requiredValue(PrimitiveTypeName type)
{    return value(type, Type.Repetition.REQUIRED);}
ca685cdd8c7a56d8aa34bf5ba15d7bfdc03646fc1eefc445a15091813b66bd02
optionalValue
public ValueBuilder<P, THIS> optionalValue(PrimitiveTypeName type)
{    return value(type, Type.Repetition.OPTIONAL);}
5238fa49455760dfed826b5b0aad6e4ee98c891ec5366d6fd2f3abd6b029c327
groupValue
public GroupValueBuilder<P, THIS> groupValue(Type.Repetition repetition)
{    return new GroupValueBuilder<P, THIS>(self()).repetition(repetition);}
b834592ce9b6abfc17a6374ae145b4d6e52a81ef71d15c24e58d24c3aa2e2b77
requiredGroupValue
public GroupValueBuilder<P, THIS> requiredGroupValue()
{    return groupValue(Type.Repetition.REQUIRED);}
a168697830a2c79fdc87cc67afd4ee71dc1119c013997b3651b718acc850cdb3
optionalGroupValue
public GroupValueBuilder<P, THIS> optionalGroupValue()
{    return groupValue(Type.Repetition.OPTIONAL);}
ede6dc7a38776e9f5d897f774090f54fc737525e0e8789c7ed55fb0d920e0f38
mapValue
public MapValueBuilder<P, THIS> mapValue(Type.Repetition repetition)
{    return new MapValueBuilder<P, THIS>(self()).repetition(repetition);}
7811ad28f3f844284763ec6ccac068835833ffe36387220126f62dc03ad59506
requiredMapValue
public MapValueBuilder<P, THIS> requiredMapValue()
{    return mapValue(Type.Repetition.REQUIRED);}
0332037c57d7a80c0f7a87eff191f52192302e8f91d637991028cf47534bcf76
optionalMapValue
public MapValueBuilder<P, THIS> optionalMapValue()
{    return mapValue(Type.Repetition.OPTIONAL);}
60099274e6da70ae2c8276f169549fc8ce49d664e12da9819ad0963f5285740d
listValue
public ListValueBuilder<P, THIS> listValue(Type.Repetition repetition)
{    return new ListValueBuilder<P, THIS>(self()).repetition(repetition);}
c5aa3105092a17238a4f6c7793af3c19f57e43e53895505f30fcd53771a097dc
requiredListValue
public ListValueBuilder<P, THIS> requiredListValue()
{    return listValue(Type.Repetition.REQUIRED);}
4232e569dd24a927bc606cdb77a02badee043aab39b4652eb451a7bde54f5159
optionalListValue
public ListValueBuilder<P, THIS> optionalListValue()
{    return listValue(Type.Repetition.OPTIONAL);}
5c910b656127034cdc40ba3f57b74b2e5737ea468d820ed309f2393704f4b6dd
value
public THIS value(Type type)
{    setValueType(type);    return self();}
1174221e15c332f37b62716b35423e476596cf65f8218dc602d87470c88c5ca1
build
protected Type build(String name)
{    Preconditions.checkState(logicalTypeAnnotation == null, "MAP is already a logical type and can't be changed.");    if (keyType == null) {        keyType = STRING_KEY;    }    GroupBuilder<GroupType> builder = buildGroup(repetition).as(OriginalType.MAP);    if (id != null) {        builder.id(id.intValue());    }    if (valueType != null) {        return builder.repeatedGroup().addFields(keyType, valueType).named("map").named(name);    } else {        return builder.repeatedGroup().addFields(keyType).named("map").named(name);    }}
2b4fe3fb6293541806443aabd18a1f12d7e4befc15fb8a3dde7b49e8188b71d2
self
protected MapBuilder<P> self()
{    return this;}
97eeccc308c46052f9c8434ebb410c9ac3ce52da7543c2470e81dd555b10470c
setElementType
public THIS setElementType(Type elementType)
{    Preconditions.checkState(this.elementType == null, "Only one element can be built with a ListBuilder");    this.elementType = elementType;    return self();}
768e9929b28814d1b41e08a6c4cc04a2cdfac263171a34f216d4d8ebcffb33aa
named
public LP named(String name)
{    listBuilder.setElementType(build("element"));    return listBuilder.named(name);}
8ba94ef227b016919ff1dd9fadd695c73a69c09ce3a39e4c230ab6bab75404ea
self
protected ElementBuilder<LP, L> self()
{    return this;}
768e9929b28814d1b41e08a6c4cc04a2cdfac263171a34f216d4d8ebcffb33aa
named
public LP named(String name)
{    listBuilder.setElementType(build("element"));    return listBuilder.named(name);}
d42364a689f3beb470d9684bda40ee726103a123bbd9a195fec70292f1ce2364
self
protected GroupElementBuilder<LP, L> self()
{    return this;}
28210ff199e4470d841593e5a644e3d8ce3e5c08391cd12b80c14f8fc32439e7
self
protected MapElementBuilder<LP, L> self()
{    return this;}
768e9929b28814d1b41e08a6c4cc04a2cdfac263171a34f216d4d8ebcffb33aa
named
public LP named(String name)
{    listBuilder.setElementType(build("element"));    return listBuilder.named(name);}
b2798233a7ff8e38d997a0ecd8d831d7feb18031e1770d3ca9023aa7d2c4518c
self
protected ListElementBuilder<LP, L> self()
{    return this;}
768e9929b28814d1b41e08a6c4cc04a2cdfac263171a34f216d4d8ebcffb33aa
named
public LP named(String name)
{    listBuilder.setElementType(build("element"));    return listBuilder.named(name);}
1174221e15c332f37b62716b35423e476596cf65f8218dc602d87470c88c5ca1
build
protected Type build(String name)
{    Preconditions.checkState(logicalTypeAnnotation == null, "LIST is already the logical type and can't be changed");    Preconditions.checkNotNull(elementType, "List element type");    GroupBuilder<GroupType> builder = buildGroup(repetition).as(OriginalType.LIST);    if (id != null) {        builder.id(id.intValue());    }    return builder.repeatedGroup().addFields(elementType).named("list").named(name);}
106bf68c77a723a166fba4578eebb16297a28e8c960372d4225822a0a4e942df
element
public ElementBuilder<P, THIS> element(PrimitiveTypeName type, Type.Repetition repetition)
{    return new ElementBuilder<P, THIS>(self(), type).repetition(repetition);}
d35487be75b5678d9508508cb9a7ef081eef3711534b8e01637e2d9321720561
requiredElement
public ElementBuilder<P, THIS> requiredElement(PrimitiveTypeName type)
{    return element(type, Type.Repetition.REQUIRED);}
d0b7a5da9219f10d9996e9c37cfdf6acd73fad730c2a053adaa5e0893bb07427
optionalElement
public ElementBuilder<P, THIS> optionalElement(PrimitiveTypeName type)
{    return element(type, Type.Repetition.OPTIONAL);}
95898de0b0a253cd55fbbbd8d61a3a001fcccfd7df5bf178a058b5903775bd50
groupElement
public GroupElementBuilder<P, THIS> groupElement(Type.Repetition repetition)
{    return new GroupElementBuilder<P, THIS>(self()).repetition(repetition);}
bdc88afa644caba9c2cdf6b8523e5318b39121e22b5aa726455ca18fb5f7610c
requiredGroupElement
public GroupElementBuilder<P, THIS> requiredGroupElement()
{    return groupElement(Type.Repetition.REQUIRED);}
0188b5366e6dfd1aa71873aec23a7e25e7e398e18d06cd23a16e225c4804a77e
optionalGroupElement
public GroupElementBuilder<P, THIS> optionalGroupElement()
{    return groupElement(Type.Repetition.OPTIONAL);}
6ba68c61e233205d3155e1e6f1ff50f9a9a159f62fa619bc9b0eac36b3914187
mapElement
public MapElementBuilder<P, THIS> mapElement(Type.Repetition repetition)
{    return new MapElementBuilder<P, THIS>(self()).repetition(repetition);}
c6e7d717ac49b86bf9bca8f5ec9faad7049141423d66d0348c9622c4f8a4ee7e
requiredMapElement
public MapElementBuilder<P, THIS> requiredMapElement()
{    return mapElement(Type.Repetition.REQUIRED);}
cbcc01e460ffa1b46995657b44ef9da9f0455d8b5115bdc8f0ff789c9854eabc
optionalMapElement
public MapElementBuilder<P, THIS> optionalMapElement()
{    return mapElement(Type.Repetition.OPTIONAL);}
7e2698899ac4a4262d06595cd492285cb8e7f6cf970c8baa4904f5e83f1aa9da
listElement
public ListElementBuilder<P, THIS> listElement(Type.Repetition repetition)
{    return new ListElementBuilder<P, THIS>(self()).repetition(repetition);}
cbed92f1bd6111d1fccf7b415e1b27bd3bcddb3321c48a68803e6cec677f3ea3
requiredListElement
public ListElementBuilder<P, THIS> requiredListElement()
{    return listElement(Type.Repetition.REQUIRED);}
ff8c6052596ed2ecdcdaf768a41b4b42f733f8aaa83f378c3a3ba932a4d7d82e
optionalListElement
public ListElementBuilder<P, THIS> optionalListElement()
{    return listElement(Type.Repetition.OPTIONAL);}
a36b5722415aad5771266efb904ed437dd8a7b97b94b0512d94f0c3989eaeb9c
element
public BaseListBuilder<P, THIS> element(Type type)
{    setElementType(type);    return self();}
a76d4df80994f2e75606f32fa0fbe1fb80c32088a630c77e15f9816887acf7a7
self
protected ListBuilder<P> self()
{    return this;}
50ccbd99226d8e6483a7c508ac473d19a7d9d45c74a7bbd6ce0fd1f2421cdb4e
named
public MessageType named(String name)
{    Preconditions.checkNotNull(name, "Name is required");    return new MessageType(name, fields);}
1064ad2113486829ce66ae2e504eeb399077013a4fe8ebc2b11625a5d9a20d79
buildMessage
public static MessageTypeBuilder buildMessage()
{    return new MessageTypeBuilder();}
d571bba61efe88a32fef52a69fc0a45e7d4be4c5f5d422fdfb00d80c7dc48ea3
primitive
public static PrimitiveBuilder<PrimitiveType> primitive(PrimitiveTypeName type, Type.Repetition repetition)
{    return new PrimitiveBuilder<PrimitiveType>(PrimitiveType.class, type).repetition(repetition);}
7a347c7d035033f9c2db1d3ac0da788355200d7dd7ee548634339c846bae8add
required
public static PrimitiveBuilder<PrimitiveType> required(PrimitiveTypeName type)
{    return new PrimitiveBuilder<PrimitiveType>(PrimitiveType.class, type).repetition(Type.Repetition.REQUIRED);}
e1886048e4c728259748de34c43b98a8504ef7fa29d8d529d72a714684d37f4d
optional
public static PrimitiveBuilder<PrimitiveType> optional(PrimitiveTypeName type)
{    return new PrimitiveBuilder<PrimitiveType>(PrimitiveType.class, type).repetition(Type.Repetition.OPTIONAL);}
9ed0e0dd16ee4fa2619458b81b99747fedc1a8dc1f78f65cc093a1e81f7064a7
repeated
public static PrimitiveBuilder<PrimitiveType> repeated(PrimitiveTypeName type)
{    return new PrimitiveBuilder<PrimitiveType>(PrimitiveType.class, type).repetition(Type.Repetition.REPEATED);}
20f5a6b59e5c76ef1166581b030341ae9c5297b22849f4b431732376818cc976
buildGroup
public static GroupBuilder<GroupType> buildGroup(Type.Repetition repetition)
{    return new GroupBuilder<GroupType>(GroupType.class).repetition(repetition);}
8dafaee3ea1500eefa6d093db0d17d18dfe9218a708527ed3e84441688b64aa4
requiredGroup
public static GroupBuilder<GroupType> requiredGroup()
{    return new GroupBuilder<GroupType>(GroupType.class).repetition(Type.Repetition.REQUIRED);}
c2019e31d4417800d196f530940a3220e1d0979b2d85b68a613ff38cfda884bc
optionalGroup
public static GroupBuilder<GroupType> optionalGroup()
{    return new GroupBuilder<GroupType>(GroupType.class).repetition(Type.Repetition.OPTIONAL);}
5aa888b3dbe9d51c06a365a243bdbbc0172e22e49b076f78ddaf37a2dd666f72
repeatedGroup
public static GroupBuilder<GroupType> repeatedGroup()
{    return new GroupBuilder<GroupType>(GroupType.class).repetition(Type.Repetition.REPEATED);}
a8b1c2fbf29448e9113f7d64318bdb723b0746722f52fcaef033d142ff70276d
map
public static MapBuilder<GroupType> map(Type.Repetition repetition)
{    return new MapBuilder<GroupType>(GroupType.class).repetition(repetition);}
6d5657a966a003a4ebd1803ab737a829c2c821f3d3a0d62771d76ba904a7fdb6
requiredMap
public static MapBuilder<GroupType> requiredMap()
{    return map(Type.Repetition.REQUIRED);}
d5cd04ddbce0b0c08f8884aca78f12130633b22b9bd989a3af4f700427972f69
optionalMap
public static MapBuilder<GroupType> optionalMap()
{    return map(Type.Repetition.OPTIONAL);}
79148a212eb9d587569c4436f5117f9e3638b886fa896e0acd4f2f9bd2cbd640
list
public static ListBuilder<GroupType> list(Type.Repetition repetition)
{    return new ListBuilder<GroupType>(GroupType.class).repetition(repetition);}
1cb08ddef3fb54380efd48a93268fc568de26074e46a835716ba1e61c582e419
requiredList
public static ListBuilder<GroupType> requiredList()
{    return list(Type.Repetition.REQUIRED);}
0c9d916fc6e166ffdc99e0589b52f4e27bcc69db80fd48b8547bc7f5e44aef9b
optionalList
public static ListBuilder<GroupType> optionalList()
{    return list(Type.Repetition.OPTIONAL);}
9fc3d2c3438fb25c296f78ab616ec3e70b49ba140e92c35d9d721c624680a1d6
checkValidWriteSchema
public static void checkValidWriteSchema(GroupType schema)
{    schema.accept(new TypeVisitor() {        @Override        public void visit(GroupType groupType) {            if (groupType.getFieldCount() <= 0) {                throw new InvalidSchemaException("Cannot write a schema with an empty group: " + groupType);            }            for (Type type : groupType.getFields()) {                type.accept(this);            }        }        @Override        public void visit(MessageType messageType) {            visit((GroupType) messageType);        }        @Override        public void visit(PrimitiveType primitiveType) {        }    });}
6ae94c927875668c171f00a4537468b9128fa1e640c0eb0d44c672494f97ea30
visit
public void visit(GroupType groupType)
{    if (groupType.getFieldCount() <= 0) {        throw new InvalidSchemaException("Cannot write a schema with an empty group: " + groupType);    }    for (Type type : groupType.getFields()) {        type.accept(this);    }}
e183e50c625f3005b23a9727bd6a0d4ad3baa292e6b90993c782af03766328a8
visit
public void visit(MessageType messageType)
{    visit((GroupType) messageType);}
d786d00215ab65b41fff4db7542dd376f5c3b9f2b7c11065b6f1a5b3a4feb8b0
visit
public void visit(PrimitiveType primitiveType)
{}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    assertEquals("bar" + count % 10, value.toStringUsingUTF8());    ++count;}
ced3637227837bc8935023b279f6d11e541ba2dd6bbaff26ba3afa81b2fd1240
test
public void test() throws Exception
{    MessageType schema = MessageTypeParser.parseMessageType("message test { required binary foo; }");    ColumnDescriptor col = schema.getColumns().get(0);    MemPageWriter pageWriter = new MemPageWriter();    ColumnWriterV2 columnWriterV2 = new ColumnWriterV2(col, pageWriter, ParquetProperties.builder().withDictionaryPageSize(1024).withWriterVersion(PARQUET_2_0).withPageSize(2048).build());    for (int i = 0; i < rows; i++) {        columnWriterV2.write(Binary.fromString("bar" + i % 10), 0, 0);        if ((i + 1) % 1000 == 0) {            columnWriterV2.writePage();        }    }    columnWriterV2.writePage();    columnWriterV2.finalizeColumnChunk();    List<DataPage> pages = pageWriter.getPages();    int valueCount = 0;    int rowCount = 0;    for (DataPage dataPage : pages) {        valueCount += dataPage.getValueCount();        rowCount += ((DataPageV2) dataPage).getRowCount();    }    assertEquals(rows, rowCount);    assertEquals(rows, valueCount);    MemPageReader pageReader = new MemPageReader((long) rows, pages.iterator(), pageWriter.getDictionaryPage());    ValidatingConverter converter = new ValidatingConverter();    ColumnReader columnReader = new ColumnReaderImpl(col, pageReader, converter, VersionParser.parse(Version.FULL_VERSION));    for (int i = 0; i < rows; i++) {        assertEquals(0, columnReader.getCurrentRepetitionLevel());        assertEquals(0, columnReader.getCurrentDefinitionLevel());        columnReader.writeCurrentValueToConverter();        columnReader.consume();    }    assertEquals(rows, converter.count);}
819c942ff34b55f8ec369998440bc77ac3e47eb12314572001c207bba28edf47
testOptional
public void testOptional() throws Exception
{    MessageType schema = MessageTypeParser.parseMessageType("message test { optional binary foo; }");    ColumnDescriptor col = schema.getColumns().get(0);    MemPageWriter pageWriter = new MemPageWriter();    ColumnWriterV2 columnWriterV2 = new ColumnWriterV2(col, pageWriter, ParquetProperties.builder().withDictionaryPageSize(1024).withWriterVersion(PARQUET_2_0).withPageSize(2048).build());    for (int i = 0; i < rows; i++) {        columnWriterV2.writeNull(0, 0);        if ((i + 1) % 1000 == 0) {            columnWriterV2.writePage();        }    }    columnWriterV2.writePage();    columnWriterV2.finalizeColumnChunk();    List<DataPage> pages = pageWriter.getPages();    int valueCount = 0;    int rowCount = 0;    for (DataPage dataPage : pages) {        valueCount += dataPage.getValueCount();        rowCount += ((DataPageV2) dataPage).getRowCount();    }    assertEquals(rows, rowCount);    assertEquals(rows, valueCount);    MemPageReader pageReader = new MemPageReader((long) rows, pages.iterator(), pageWriter.getDictionaryPage());    ValidatingConverter converter = new ValidatingConverter();    ColumnReader columnReader = new ColumnReaderImpl(col, pageReader, converter, VersionParser.parse(Version.FULL_VERSION));    for (int i = 0; i < rows; i++) {        assertEquals(0, columnReader.getCurrentRepetitionLevel());        assertEquals(0, columnReader.getCurrentDefinitionLevel());        columnReader.consume();    }    assertEquals(0, converter.count);}
7bc786ef688c3b15643c703bf4a779491966e8ea4a10286725ce96299845b444
testCorruptDeltaByteArrayVerisons
public void testCorruptDeltaByteArrayVerisons()
{    assertTrue(CorruptDeltaByteArrays.requiresSequentialReads("parquet-mr version 1.6.0 (build abcd)", Encoding.DELTA_BYTE_ARRAY));    assertTrue(CorruptDeltaByteArrays.requiresSequentialReads((String) null, Encoding.DELTA_BYTE_ARRAY));    assertTrue(CorruptDeltaByteArrays.requiresSequentialReads((ParsedVersion) null, Encoding.DELTA_BYTE_ARRAY));    assertTrue(CorruptDeltaByteArrays.requiresSequentialReads((SemanticVersion) null, Encoding.DELTA_BYTE_ARRAY));    assertTrue(CorruptDeltaByteArrays.requiresSequentialReads("parquet-mr version 1.8.0-SNAPSHOT (build abcd)", Encoding.DELTA_BYTE_ARRAY));    assertFalse(CorruptDeltaByteArrays.requiresSequentialReads("parquet-mr version 1.6.0 (build abcd)", Encoding.DELTA_BINARY_PACKED));    assertFalse(CorruptDeltaByteArrays.requiresSequentialReads((String) null, Encoding.DELTA_LENGTH_BYTE_ARRAY));    assertFalse(CorruptDeltaByteArrays.requiresSequentialReads((ParsedVersion) null, Encoding.PLAIN));    assertFalse(CorruptDeltaByteArrays.requiresSequentialReads((SemanticVersion) null, Encoding.RLE));    assertFalse(CorruptDeltaByteArrays.requiresSequentialReads("parquet-mr version 1.8.0-SNAPSHOT (build abcd)", Encoding.RLE_DICTIONARY));    assertFalse(CorruptDeltaByteArrays.requiresSequentialReads("parquet-mr version 1.8.0-SNAPSHOT (build abcd)", Encoding.PLAIN_DICTIONARY));    assertFalse(CorruptDeltaByteArrays.requiresSequentialReads("parquet-mr version 1.8.0-SNAPSHOT (build abcd)", Encoding.BIT_PACKED));    assertFalse(CorruptDeltaByteArrays.requiresSequentialReads("parquet-mr version 1.8.0 (build abcd)", Encoding.DELTA_BYTE_ARRAY));}
7043307bb94f244cd029ab2f1e70a6a07e9d3c2c2469ea9a3e8ff3f63781e3db
testEncodingRequiresSequentailRead
public void testEncodingRequiresSequentailRead()
{    ParsedVersion impala = new ParsedVersion("impala", "1.2.0", "abcd");    assertFalse(CorruptDeltaByteArrays.requiresSequentialReads(impala, Encoding.DELTA_BYTE_ARRAY));    ParsedVersion broken = new ParsedVersion("parquet-mr", "1.8.0-SNAPSHOT", "abcd");    assertTrue(CorruptDeltaByteArrays.requiresSequentialReads(broken, Encoding.DELTA_BYTE_ARRAY));    ParsedVersion fixed = new ParsedVersion("parquet-mr", "1.8.0", "abcd");    assertFalse(CorruptDeltaByteArrays.requiresSequentialReads(fixed, Encoding.DELTA_BYTE_ARRAY));}
b09f964c2702e0c9868d9e045b4f3373e0d0949204041a14f9e06a7066ff111b
getDeltaByteArrayWriter
private DeltaByteArrayWriter getDeltaByteArrayWriter()
{    return new DeltaByteArrayWriter(10, 100, new HeapByteBufferAllocator());}
b30bf1d8a08fc3bb67dde56f54c249340fc9af5c1427b41c4c42aafd26770579
testReassemblyWithCorruptPage
public void testReassemblyWithCorruptPage() throws Exception
{    DeltaByteArrayWriter writer = getDeltaByteArrayWriter();    String lastValue = null;    for (int i = 0; i < 10; i += 1) {        lastValue = str(i);        writer.writeBytes(Binary.fromString(lastValue));    }    ByteBuffer firstPageBytes = writer.getBytes().toByteBuffer();        writer.reset();    corruptWriter(writer, lastValue);    for (int i = 10; i < 20; i += 1) {        writer.writeBytes(Binary.fromString(str(i)));    }    ByteBuffer corruptPageBytes = writer.getBytes().toByteBuffer();    DeltaByteArrayReader firstPageReader = new DeltaByteArrayReader();    firstPageReader.initFromPage(10, ByteBufferInputStream.wrap(firstPageBytes));    for (int i = 0; i < 10; i += 1) {        assertEquals(str(i), firstPageReader.readBytes().toStringUsingUTF8());    }    DeltaByteArrayReader corruptPageReader = new DeltaByteArrayReader();    corruptPageReader.initFromPage(10, ByteBufferInputStream.wrap(corruptPageBytes));    try {        corruptPageReader.readBytes();        fail("Corrupt page did not throw an exception when read");    } catch (ArrayIndexOutOfBoundsException e) {        }    DeltaByteArrayReader secondPageReader = new DeltaByteArrayReader();    secondPageReader.initFromPage(10, ByteBufferInputStream.wrap(corruptPageBytes));    secondPageReader.setPreviousReader(firstPageReader);    for (int i = 10; i < 20; i += 1) {        assertEquals(secondPageReader.readBytes().toStringUsingUTF8(), str(i));    }}
e150db28fc711f0749462e50e93c247a6de1bc129bf09d9f5a79b5a1c191dcf7
testReassemblyWithoutCorruption
public void testReassemblyWithoutCorruption() throws Exception
{    DeltaByteArrayWriter writer = getDeltaByteArrayWriter();    for (int i = 0; i < 10; i += 1) {        writer.writeBytes(Binary.fromString(str(i)));    }    ByteBuffer firstPageBytes = writer.getBytes().toByteBuffer();        writer.reset();    for (int i = 10; i < 20; i += 1) {        writer.writeBytes(Binary.fromString(str(i)));    }    ByteBuffer secondPageBytes = writer.getBytes().toByteBuffer();    DeltaByteArrayReader firstPageReader = new DeltaByteArrayReader();    firstPageReader.initFromPage(10, ByteBufferInputStream.wrap(firstPageBytes));    for (int i = 0; i < 10; i += 1) {        assertEquals(firstPageReader.readBytes().toStringUsingUTF8(), str(i));    }    DeltaByteArrayReader secondPageReader = new DeltaByteArrayReader();    secondPageReader.initFromPage(10, ByteBufferInputStream.wrap(secondPageBytes));    secondPageReader.setPreviousReader(firstPageReader);    for (int i = 10; i < 20; i += 1) {        assertEquals(secondPageReader.readBytes().toStringUsingUTF8(), str(i));    }}
8a768507207120ec3411ca51cad67d599d1e3544d55a0e2626ba422ded5395c9
testOldReassemblyWithoutCorruption
public void testOldReassemblyWithoutCorruption() throws Exception
{    DeltaByteArrayWriter writer = getDeltaByteArrayWriter();    for (int i = 0; i < 10; i += 1) {        writer.writeBytes(Binary.fromString(str(i)));    }    ByteBuffer firstPageBytes = writer.getBytes().toByteBuffer();        writer.reset();    for (int i = 10; i < 20; i += 1) {        writer.writeBytes(Binary.fromString(str(i)));    }    ByteBuffer secondPageBytes = writer.getBytes().toByteBuffer();    DeltaByteArrayReader firstPageReader = new DeltaByteArrayReader();    firstPageReader.initFromPage(10, ByteBufferInputStream.wrap(firstPageBytes));    for (int i = 0; i < 10; i += 1) {        assertEquals(firstPageReader.readBytes().toStringUsingUTF8(), str(i));    }    DeltaByteArrayReader secondPageReader = new DeltaByteArrayReader();    secondPageReader.initFromPage(10, ByteBufferInputStream.wrap(secondPageBytes));    for (int i = 10; i < 20; i += 1) {        assertEquals(secondPageReader.readBytes().toStringUsingUTF8(), str(i));    }}
4f4eae239c83621d886089bda339b9d40845c1d287b91ae51c0b7388d5208ecc
testColumnReaderImplWithCorruptPage
public void testColumnReaderImplWithCorruptPage() throws Exception
{    ColumnDescriptor column = new ColumnDescriptor(new String[] { "s" }, PrimitiveType.PrimitiveTypeName.BINARY, 0, 0);    MemPageStore pages = new MemPageStore(0);    PageWriter memWriter = pages.getPageWriter(column);    ParquetProperties parquetProps = ParquetProperties.builder().withDictionaryEncoding(false).build();        ValuesWriter rdValues = parquetProps.newDefinitionLevelWriter(column);    for (int i = 0; i < 10; i += 1) {        rdValues.writeInteger(0);    }        BytesInput rd = BytesInput.from(rdValues.getBytes().toByteArray());    DeltaByteArrayWriter writer = getDeltaByteArrayWriter();    String lastValue = null;    List<String> values = new ArrayList<String>();    for (int i = 0; i < 10; i += 1) {        lastValue = str(i);        writer.writeBytes(Binary.fromString(lastValue));        values.add(lastValue);    }    memWriter.writePage(BytesInput.concat(rd, rd, writer.getBytes()), 10, /* number of values in the page */    new BinaryStatistics(), rdValues.getEncoding(), rdValues.getEncoding(), writer.getEncoding());    pages.addRowCount(10);        writer.reset();    corruptWriter(writer, lastValue);    for (int i = 10; i < 20; i += 1) {        String value = str(i);        writer.writeBytes(Binary.fromString(value));        values.add(value);    }    memWriter.writePage(BytesInput.concat(rd, rd, writer.getBytes()), 10, /* number of values in the page */    new BinaryStatistics(), rdValues.getEncoding(), rdValues.getEncoding(), writer.getEncoding());    pages.addRowCount(10);    final List<String> actualValues = new ArrayList<String>();    PrimitiveConverter converter = new PrimitiveConverter() {        @Override        public void addBinary(Binary value) {            actualValues.add(value.toStringUsingUTF8());        }    };    ColumnReaderImpl columnReader = new ColumnReaderImpl(column, pages.getPageReader(column), converter, new ParsedVersion("parquet-mr", "1.6.0", "abcd"));    while (actualValues.size() < columnReader.getTotalValueCount()) {        columnReader.writeCurrentValueToConverter();        columnReader.consume();    }    Assert.assertEquals(values, actualValues);}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    actualValues.add(value.toStringUsingUTF8());}
0dea25596a1b77fca934944318c7da3e352d9a7f8fddeccb6c5ba84ed2eb26fd
corruptWriter
public void corruptWriter(DeltaByteArrayWriter writer, String data) throws Exception
{    Field previous = writer.getClass().getDeclaredField("previous");    previous.setAccessible(true);    previous.set(writer, Binary.fromString(data).getBytesUnsafe());}
abd37bd680190f3a94ed3bc17142f374daeeeb1e05bbc1db162830eb51366be1
str
public String str(int i)
{    char c = 'a';    return "aaaaaaaaaaa" + (char) (c + i);}
f120f7c551f50fe42c2308a0027f7485e578416816b01a3a90be543acac48bc7
testMemColumn
public void testMemColumn() throws Exception
{    MessageType schema = MessageTypeParser.parseMessageType("message msg { required group foo { required int64 bar; } }");    ColumnDescriptor path = schema.getColumnDescription(new String[] { "foo", "bar" });    MemPageStore memPageStore = new MemPageStore(10);    ColumnWriteStoreV1 memColumnsStore = newColumnWriteStoreImpl(memPageStore);    ColumnWriter columnWriter = memColumnsStore.getColumnWriter(path);    columnWriter.write(42l, 0, 0);    memColumnsStore.endRecord();    memColumnsStore.flush();    ColumnReader columnReader = getColumnReader(memPageStore, path, schema);    for (int i = 0; i < columnReader.getTotalValueCount(); i++) {        assertEquals(columnReader.getCurrentRepetitionLevel(), 0);        assertEquals(columnReader.getCurrentDefinitionLevel(), 0);        assertEquals(columnReader.getLong(), 42);        columnReader.consume();    }}
9271bce87a601bd010b3caae49b52247b0f625944545e85df8c21681d46a357d
getColumnWriter
private ColumnWriter getColumnWriter(ColumnDescriptor path, MemPageStore memPageStore)
{    ColumnWriteStoreV1 memColumnsStore = newColumnWriteStoreImpl(memPageStore);    ColumnWriter columnWriter = memColumnsStore.getColumnWriter(path);    return columnWriter;}
ba49350c71b9c7474c54d40b7fd6662113c6f0fd505e14b18fd0d9bb2c4e2ff8
getColumnReader
private ColumnReader getColumnReader(MemPageStore memPageStore, ColumnDescriptor path, MessageType schema)
{    return new ColumnReadStoreImpl(memPageStore, new DummyRecordConverter(schema).getRootConverter(), schema, null).getColumnReader(path);}
90db9a4b3e3b11432ea42835be7112958f6392ed237b179151e2b0eb16dd3dcb
testMemColumnBinary
public void testMemColumnBinary() throws Exception
{    MessageType mt = MessageTypeParser.parseMessageType("message msg { required group foo { required binary bar; } }");    String[] col = new String[] { "foo", "bar" };    MemPageStore memPageStore = new MemPageStore(10);    ColumnWriteStoreV1 memColumnsStore = newColumnWriteStoreImpl(memPageStore);    ColumnDescriptor path1 = mt.getColumnDescription(col);    ColumnDescriptor path = path1;    ColumnWriter columnWriter = memColumnsStore.getColumnWriter(path);    columnWriter.write(Binary.fromString("42"), 0, 0);    memColumnsStore.endRecord();    memColumnsStore.flush();    ColumnReader columnReader = getColumnReader(memPageStore, path, mt);    for (int i = 0; i < columnReader.getTotalValueCount(); i++) {        assertEquals(columnReader.getCurrentRepetitionLevel(), 0);        assertEquals(columnReader.getCurrentDefinitionLevel(), 0);        assertEquals(columnReader.getBinary().toStringUsingUTF8(), "42");        columnReader.consume();    }}
b6941715fd8aa28dcc92d7dd985f7eb2b2f16aff01259a890d9afe0641a88cd1
testMemColumnSeveralPages
public void testMemColumnSeveralPages() throws Exception
{    MessageType mt = MessageTypeParser.parseMessageType("message msg { required group foo { required int64 bar; } }");    String[] col = new String[] { "foo", "bar" };    MemPageStore memPageStore = new MemPageStore(10);    ColumnWriteStoreV1 memColumnsStore = newColumnWriteStoreImpl(memPageStore);    ColumnDescriptor path1 = mt.getColumnDescription(col);    ColumnDescriptor path = path1;    ColumnWriter columnWriter = memColumnsStore.getColumnWriter(path);    for (int i = 0; i < 2000; i++) {        columnWriter.write(42l, 0, 0);        memColumnsStore.endRecord();    }    memColumnsStore.flush();    ColumnReader columnReader = getColumnReader(memPageStore, path, mt);    for (int i = 0; i < columnReader.getTotalValueCount(); i++) {        assertEquals(columnReader.getCurrentRepetitionLevel(), 0);        assertEquals(columnReader.getCurrentDefinitionLevel(), 0);        assertEquals(columnReader.getLong(), 42);        columnReader.consume();    }}
184082eaec21bab2a357a754ca26829d7b6f89cae48615995e61d4144cc99a5a
testMemColumnSeveralPagesRepeated
public void testMemColumnSeveralPagesRepeated() throws Exception
{    MessageType mt = MessageTypeParser.parseMessageType("message msg { repeated group foo { repeated int64 bar; } }");    String[] col = new String[] { "foo", "bar" };    MemPageStore memPageStore = new MemPageStore(10);    ColumnWriteStoreV1 memColumnsStore = newColumnWriteStoreImpl(memPageStore);    ColumnDescriptor path1 = mt.getColumnDescription(col);    ColumnDescriptor path = path1;    ColumnWriter columnWriter = memColumnsStore.getColumnWriter(path);    int[] rs = { 0, 0, 0, 1, 1, 1, 2, 2, 2 };    int[] ds = { 0, 1, 2, 0, 1, 2, 0, 1, 2 };    for (int i = 0; i < 837; i++) {        int r = rs[i % rs.length];        int d = ds[i % ds.length];        LOG.debug("write i: {}", i);        if (i != 0 && r == 0) {            memColumnsStore.endRecord();        }        if (d == 2) {            columnWriter.write((long) i, r, d);        } else {            columnWriter.writeNull(r, d);        }    }    memColumnsStore.endRecord();    memColumnsStore.flush();    ColumnReader columnReader = getColumnReader(memPageStore, path, mt);    int i = 0;    for (int j = 0; j < columnReader.getTotalValueCount(); j++) {        int r = rs[i % rs.length];        int d = ds[i % ds.length];        LOG.debug("read i: {}", i);        assertEquals("r row " + i, r, columnReader.getCurrentRepetitionLevel());        assertEquals("d row " + i, d, columnReader.getCurrentDefinitionLevel());        if (d == 2) {            assertEquals("data row " + i, (long) i, columnReader.getLong());        }        columnReader.consume();        ++i;    }}
4ab49ebd3e4025831681aef6d939d57bc374a669f2ecff8f3a7e137c9c56adc4
testPageSize
public void testPageSize()
{    MessageType schema = Types.buildMessage().requiredList().requiredElement(BINARY).named("binary_col").requiredList().requiredElement(INT32).named("int32_col").named("msg");    System.out.println(schema);    MemPageStore memPageStore = new MemPageStore(123);        ColumnWriteStore writeStore = new ColumnWriteStoreV2(schema, memPageStore, ParquetProperties.builder().withPageSize(    1024).withMinRowCountForPageSizeCheck(    1).withPageRowCountLimit(10).withDictionaryEncoding(    false).build());    ColumnDescriptor binaryCol = schema.getColumnDescription(new String[] { "binary_col", "list", "element" });    ColumnWriter binaryColWriter = writeStore.getColumnWriter(binaryCol);    ColumnDescriptor int32Col = schema.getColumnDescription(new String[] { "int32_col", "list", "element" });    ColumnWriter int32ColWriter = writeStore.getColumnWriter(int32Col);        for (int i = 0; i < 123; ++i) {                for (int j = 0; j < 10; ++j) {            binaryColWriter.write(Binary.fromString("aaaaaaaaaaaa"), j == 0 ? 0 : 2, 2);            int32ColWriter.write(42, j == 0 ? 0 : 2, 2);        }        writeStore.endRecord();    }    writeStore.flush();        {        PageReader binaryColPageReader = memPageStore.getPageReader(binaryCol);        assertEquals(1230, binaryColPageReader.getTotalValueCount());        int pageCnt = 0;        int valueCnt = 0;        while (valueCnt < binaryColPageReader.getTotalValueCount()) {            DataPage page = binaryColPageReader.readPage();            ++pageCnt;            valueCnt += page.getValueCount();            LOG.info("binary_col page-{}: {} bytes, {} rows", pageCnt, page.getCompressedSize(), page.getIndexRowCount().get());            assertTrue("Compressed size should be less than 1024", page.getCompressedSize() <= 1024);        }    }        {        PageReader int32ColPageReader = memPageStore.getPageReader(int32Col);        assertEquals(1230, int32ColPageReader.getTotalValueCount());        int pageCnt = 0;        int valueCnt = 0;        while (valueCnt < int32ColPageReader.getTotalValueCount()) {            DataPage page = int32ColPageReader.readPage();            ++pageCnt;            valueCnt += page.getValueCount();            LOG.info("int32_col page-{}: {} bytes, {} rows", pageCnt, page.getCompressedSize(), page.getIndexRowCount().get());            assertTrue("Row count should be less than 10", page.getIndexRowCount().get() <= 10);        }    }}
83d38bce4aede9e243480a611adfdabda4cd85de3e5091fa17bfcfe51c309a89
newColumnWriteStoreImpl
private ColumnWriteStoreV1 newColumnWriteStoreImpl(MemPageStore memPageStore)
{    return new ColumnWriteStoreV1(memPageStore, ParquetProperties.builder().withPageSize(2048).withDictionaryEncoding(false).build());}
a2a314ef22554dd92e27423b4f2d7f98b9f605698c00bf86585d1f2c50b7ab22
test
public void test() throws IOException
{    MemPageStore memPageStore = new MemPageStore(10);    ColumnDescriptor col = new ColumnDescriptor(path, PrimitiveTypeName.INT64, 2, 2);    LongStatistics stats = new LongStatistics();    PageWriter pageWriter = memPageStore.getPageWriter(col);    pageWriter.writePage(BytesInput.from(new byte[735]), 209, stats, BIT_PACKED, BIT_PACKED, PLAIN);    pageWriter.writePage(BytesInput.from(new byte[743]), 209, stats, BIT_PACKED, BIT_PACKED, PLAIN);    pageWriter.writePage(BytesInput.from(new byte[743]), 209, stats, BIT_PACKED, BIT_PACKED, PLAIN);    pageWriter.writePage(BytesInput.from(new byte[735]), 209, stats, BIT_PACKED, BIT_PACKED, PLAIN);    PageReader pageReader = memPageStore.getPageReader(col);    long totalValueCount = pageReader.getTotalValueCount();    System.out.println(totalValueCount);    int total = 0;    do {        DataPage readPage = pageReader.readPage();        total += readPage.getValueCount();        System.out.println(readPage);        } while (total < totalValueCount);}
a44ab89ac1bd1c96a51dfa0d50dcc13fd7563de2e02c8e8f8722aff5468302dd
getTotalValueCount
public long getTotalValueCount()
{    return totalValueCount;}
9cb4eeb0904f10d1d5e6bace639960ffa54293753cf81bf158838b756b0b9925
readPage
public DataPage readPage()
{    if (pages.hasNext()) {        DataPage next = pages.next();        LOG.debug("read page {}", next);        return next;    } else {        throw new ParquetDecodingException("after last page");    }}
c912f40c38afde0ef75b8d08ab2c675551c383cef1763b349d2cf096213fb12d
readDictionaryPage
public DictionaryPage readDictionaryPage()
{    return dictionaryPage;}
49c948b863e8c6ae55cc16f5e5ada03850af9ce16ffe3f2f06d54af573345c22
getPageWriter
public PageWriter getPageWriter(ColumnDescriptor path)
{    MemPageWriter pageWriter = pageWriters.get(path);    if (pageWriter == null) {        pageWriter = new MemPageWriter();        pageWriters.put(path, pageWriter);    }    return pageWriter;}
e975b006c573b475b71e6a52c61374f8d88e9c40997443d04866726cfd7b3e3c
getPageReader
public PageReader getPageReader(ColumnDescriptor descriptor)
{    MemPageWriter pageWriter = pageWriters.get(descriptor);    if (pageWriter == null) {        throw new UnknownColumnException(descriptor);    }    List<DataPage> pages = new ArrayList<DataPage>(pageWriter.getPages());    LOG.debug("initialize page reader with {} values and {} pages", pageWriter.getTotalValueCount(), pages.size());    return new MemPageReader(pageWriter.getTotalValueCount(), pages.iterator(), pageWriter.getDictionaryPage());}
a3384eda6088ab785128d7d88a9af55e07543a5e59774f8c7f30961ef025e4f5
getRowCount
public long getRowCount()
{    return rowCount;}
0099e61c4cd2968f760027d7fb8a9c1a9288d89b1abacc8d31b1d0749d52f44c
addRowCount
public void addRowCount(long count)
{    rowCount += count;}
60231e4ceb2b65fbfa4d57be0337ce7110f0647bf5d43074a0dda0d356bd53b4
writePage
public void writePage(BytesInput bytesInput, int valueCount, Statistics statistics, Encoding rlEncoding, Encoding dlEncoding, Encoding valuesEncoding) throws IOException
{    if (valueCount == 0) {        throw new ParquetEncodingException("illegal page of 0 values");    }    memSize += bytesInput.size();    pages.add(new DataPageV1(BytesInput.copy(bytesInput), valueCount, (int) bytesInput.size(), statistics, rlEncoding, dlEncoding, valuesEncoding));    totalValueCount += valueCount;    LOG.debug("page written for {} bytes and {} records", bytesInput.size(), valueCount);}
6e93b0aae7cab9d97b07fe3287a1660aceeb7ce12d2ea4082761c4ed0864a8ef
writePage
public void writePage(BytesInput bytesInput, int valueCount, int rowCount, Statistics<?> statistics, Encoding rlEncoding, Encoding dlEncoding, Encoding valuesEncoding) throws IOException
{    writePage(bytesInput, valueCount, statistics, rlEncoding, dlEncoding, valuesEncoding);}
826a0908c0c09aa6f50aff7b6b7d4e389c1b9aa775b04cb02885f45a0e83ad2d
writePageV2
public void writePageV2(int rowCount, int nullCount, int valueCount, BytesInput repetitionLevels, BytesInput definitionLevels, Encoding dataEncoding, BytesInput data, Statistics<?> statistics) throws IOException
{    if (valueCount == 0) {        throw new ParquetEncodingException("illegal page of 0 values");    }    long size = repetitionLevels.size() + definitionLevels.size() + data.size();    memSize += size;    pages.add(DataPageV2.uncompressed(rowCount, nullCount, valueCount, copy(repetitionLevels), copy(definitionLevels), dataEncoding, copy(data), statistics));    totalValueCount += valueCount;    LOG.debug("page written for {} bytes and {} records", size, valueCount);}
6a6d96a7d5cb6e49f470f1cd037acc9fc797a8452a905cfabb5dd9fec40874d4
getMemSize
public long getMemSize()
{    return memSize;}
c2a636a2b5967967d8bb0b7b8b197cc3f92d67f9f5b992f347e7e1ef4c0a87e6
getPages
public List<DataPage> getPages()
{    return pages;}
bba7bf81505b55306d97134c6b019e5ca193a53d807f1a2bd25816af0c3ae871
getDictionaryPage
public DictionaryPage getDictionaryPage()
{    return dictionaryPage;}
a44ab89ac1bd1c96a51dfa0d50dcc13fd7563de2e02c8e8f8722aff5468302dd
getTotalValueCount
public long getTotalValueCount()
{    return totalValueCount;}
878d1060df6bc5af3d1f5d5388cfa4f6715bcc9c71ff30801f3696b5b8cc3ba2
allocatedSize
public long allocatedSize()
{        return memSize;}
979a9e010c509f63ed8210f83e5e4d7838052d7f5e3bbb4e9c3797d5de3ea217
writeDictionaryPage
public void writeDictionaryPage(DictionaryPage dictionaryPage) throws IOException
{    if (this.dictionaryPage != null) {        throw new ParquetEncodingException("Only one dictionary page per block");    }    this.memSize += dictionaryPage.getBytes().size();    this.dictionaryPage = dictionaryPage.copy();    LOG.debug("dictionary page written for {} bytes and {} records", dictionaryPage.getBytes().size(), dictionaryPage.getDictionarySize());}
729f860abc36decbc60be91f7b83b54762252f09cb85d7c4e9f7517c5dace502
memUsageString
public String memUsageString(String prefix)
{    return String.format("%s %,d bytes", prefix, memSize);}
41b6dd4b8225875828a1ae78bc309d19a160b65d7c0f912ba8e75da679ad5092
testNumNulls
public void testNumNulls()
{    IntStatistics stats = new IntStatistics();    assertTrue(stats.isNumNullsSet());    assertEquals(stats.getNumNulls(), 0);    stats.incrementNumNulls();    stats.incrementNumNulls();    stats.incrementNumNulls();    stats.incrementNumNulls();    assertEquals(stats.getNumNulls(), 4);    stats.incrementNumNulls(5);    assertEquals(stats.getNumNulls(), 9);    stats.setNumNulls(22);    assertEquals(stats.getNumNulls(), 22);}
02029ca5228bd59eed0cb8e8f026db161b661673c201b194e7daee6087cf3058
testIntMinMax
public void testIntMinMax()
{        integerArray = new int[] { 1, 3, 14, 54, 66, 8, 0, 23, 54 };    IntStatistics stats = new IntStatistics();    for (int i : integerArray) {        stats.updateStats(i);    }    assertEquals(stats.getMax(), 66);    assertEquals(stats.getMin(), 0);        integerArray = new int[] { -11, 3, -14, 54, -66, 8, 0, -23, 54 };    IntStatistics statsNeg = new IntStatistics();    for (int i : integerArray) {        statsNeg.updateStats(i);    }    assertEquals(statsNeg.getMax(), 54);    assertEquals(statsNeg.getMin(), -66);    assertTrue(statsNeg.compareMaxToValue(55) < 0);    assertTrue(statsNeg.compareMaxToValue(54) == 0);    assertTrue(statsNeg.compareMaxToValue(5) > 0);    assertTrue(statsNeg.compareMinToValue(0) < 0);    assertTrue(statsNeg.compareMinToValue(-66) == 0);    assertTrue(statsNeg.compareMinToValue(-67) > 0);        byte[] intMaxBytes = statsNeg.getMaxBytes();    byte[] intMinBytes = statsNeg.getMinBytes();    assertEquals(ByteBuffer.wrap(intMaxBytes).order(java.nio.ByteOrder.LITTLE_ENDIAN).getInt(), 54);    assertEquals(ByteBuffer.wrap(intMinBytes).order(java.nio.ByteOrder.LITTLE_ENDIAN).getInt(), -66);    IntStatistics statsFromBytes = new IntStatistics();    statsFromBytes.setMinMaxFromBytes(intMinBytes, intMaxBytes);    assertEquals(statsFromBytes.getMax(), 54);    assertEquals(statsFromBytes.getMin(), -66);    integerArray = new int[] { Integer.MAX_VALUE, Integer.MIN_VALUE };    IntStatistics minMaxValues = new IntStatistics();    for (int i : integerArray) {        minMaxValues.updateStats(i);    }    assertEquals(minMaxValues.getMax(), Integer.MAX_VALUE);    assertEquals(minMaxValues.getMin(), Integer.MIN_VALUE);        byte[] intMaxBytesMinMax = minMaxValues.getMaxBytes();    byte[] intMinBytesMinMax = minMaxValues.getMinBytes();    assertEquals(ByteBuffer.wrap(intMaxBytesMinMax).order(java.nio.ByteOrder.LITTLE_ENDIAN).getInt(), Integer.MAX_VALUE);    assertEquals(ByteBuffer.wrap(intMinBytesMinMax).order(java.nio.ByteOrder.LITTLE_ENDIAN).getInt(), Integer.MIN_VALUE);    IntStatistics statsFromBytesMinMax = new IntStatistics();    statsFromBytesMinMax.setMinMaxFromBytes(intMinBytesMinMax, intMaxBytesMinMax);    assertEquals(statsFromBytesMinMax.getMax(), Integer.MAX_VALUE);    assertEquals(statsFromBytesMinMax.getMin(), Integer.MIN_VALUE);        assertEquals(stats.toString(), "min: 0, max: 66, num_nulls: 0");}
b74233113eccb39b99617e7af0bb53f9134fc6990d9b6c0a4e792c390768a9fc
testLongMinMax
public void testLongMinMax()
{        longArray = new long[] { 9, 39, 99, 3, 0, 12, 1000, 65, 542 };    LongStatistics stats = new LongStatistics();    for (long l : longArray) {        stats.updateStats(l);    }    assertEquals(stats.getMax(), 1000);    assertEquals(stats.getMin(), 0);        longArray = new long[] { -101, 993, -9914, 54, -9, 89, 0, -23, 90 };    LongStatistics statsNeg = new LongStatistics();    for (long l : longArray) {        statsNeg.updateStats(l);    }    assertEquals(statsNeg.getMax(), 993);    assertEquals(statsNeg.getMin(), -9914);    assertTrue(statsNeg.compareMaxToValue(994) < 0);    assertTrue(statsNeg.compareMaxToValue(993) == 0);    assertTrue(statsNeg.compareMaxToValue(-1000) > 0);    assertTrue(statsNeg.compareMinToValue(10000) < 0);    assertTrue(statsNeg.compareMinToValue(-9914) == 0);    assertTrue(statsNeg.compareMinToValue(-9915) > 0);        byte[] longMaxBytes = statsNeg.getMaxBytes();    byte[] longMinBytes = statsNeg.getMinBytes();    assertEquals(ByteBuffer.wrap(longMaxBytes).order(java.nio.ByteOrder.LITTLE_ENDIAN).getLong(), 993);    assertEquals(ByteBuffer.wrap(longMinBytes).order(java.nio.ByteOrder.LITTLE_ENDIAN).getLong(), -9914);    LongStatistics statsFromBytes = new LongStatistics();    statsFromBytes.setMinMaxFromBytes(longMinBytes, longMaxBytes);    assertEquals(statsFromBytes.getMax(), 993);    assertEquals(statsFromBytes.getMin(), -9914);    longArray = new long[] { Long.MAX_VALUE, Long.MIN_VALUE };    LongStatistics minMaxValues = new LongStatistics();    for (long l : longArray) {        minMaxValues.updateStats(l);    }    assertEquals(minMaxValues.getMax(), Long.MAX_VALUE);    assertEquals(minMaxValues.getMin(), Long.MIN_VALUE);        byte[] longMaxBytesMinMax = minMaxValues.getMaxBytes();    byte[] longMinBytesMinMax = minMaxValues.getMinBytes();    assertEquals(ByteBuffer.wrap(longMaxBytesMinMax).order(java.nio.ByteOrder.LITTLE_ENDIAN).getLong(), Long.MAX_VALUE);    assertEquals(ByteBuffer.wrap(longMinBytesMinMax).order(java.nio.ByteOrder.LITTLE_ENDIAN).getLong(), Long.MIN_VALUE);    LongStatistics statsFromBytesMinMax = new LongStatistics();    statsFromBytesMinMax.setMinMaxFromBytes(longMinBytesMinMax, longMaxBytesMinMax);    assertEquals(statsFromBytesMinMax.getMax(), Long.MAX_VALUE);    assertEquals(statsFromBytesMinMax.getMin(), Long.MIN_VALUE);        assertEquals(stats.toString(), "min: 0, max: 1000, num_nulls: 0");}
a56c0cbeb745540f9077e0a73dbae4561f64fecb7646ae0fbf4a3da108a8caa4
testFloatMinMax
public void testFloatMinMax()
{        floatArray = new float[] { 1.5f, 44.5f, 412.99f, 0.65f, 5.6f, 100.6f, 0.0001f, 23.0f, 553.6f };    FloatStatistics stats = new FloatStatistics();    for (float f : floatArray) {        stats.updateStats(f);    }    assertEquals(stats.getMax(), 553.6f, 1e-10);    assertEquals(stats.getMin(), 0.0001f, 1e-10);        floatArray = new float[] { -1.5f, -44.5f, -412.99f, 0.65f, -5.6f, -100.6f, 0.0001f, -23.0f, -3.6f };    FloatStatistics statsNeg = new FloatStatistics();    for (float f : floatArray) {        statsNeg.updateStats(f);    }    assertEquals(statsNeg.getMax(), 0.65f, 1e-10);    assertEquals(statsNeg.getMin(), -412.99f, 1e-10);    assertTrue(statsNeg.compareMaxToValue(1) < 0);    assertTrue(statsNeg.compareMaxToValue(0.65F) == 0);    assertTrue(statsNeg.compareMaxToValue(0.649F) > 0);    assertTrue(statsNeg.compareMinToValue(-412.98F) < 0);    assertTrue(statsNeg.compareMinToValue(-412.99F) == 0);    assertTrue(statsNeg.compareMinToValue(-450) > 0);        byte[] floatMaxBytes = statsNeg.getMaxBytes();    byte[] floatMinBytes = statsNeg.getMinBytes();    assertEquals(ByteBuffer.wrap(floatMaxBytes).order(java.nio.ByteOrder.LITTLE_ENDIAN).getFloat(), 0.65f, 1e-10);    assertEquals(ByteBuffer.wrap(floatMinBytes).order(java.nio.ByteOrder.LITTLE_ENDIAN).getFloat(), -412.99f, 1e-10);    FloatStatistics statsFromBytes = new FloatStatistics();    statsFromBytes.setMinMaxFromBytes(floatMinBytes, floatMaxBytes);    assertEquals(statsFromBytes.getMax(), 0.65f, 1e-10);    assertEquals(statsFromBytes.getMin(), -412.99f, 1e-10);    floatArray = new float[] { Float.MAX_VALUE, Float.MIN_VALUE };    FloatStatistics minMaxValues = new FloatStatistics();    for (float f : floatArray) {        minMaxValues.updateStats(f);    }    assertEquals(minMaxValues.getMax(), Float.MAX_VALUE, 1e-10);    assertEquals(minMaxValues.getMin(), Float.MIN_VALUE, 1e-10);        byte[] floatMaxBytesMinMax = minMaxValues.getMaxBytes();    byte[] floatMinBytesMinMax = minMaxValues.getMinBytes();    assertEquals(ByteBuffer.wrap(floatMaxBytesMinMax).order(java.nio.ByteOrder.LITTLE_ENDIAN).getFloat(), Float.MAX_VALUE, 1e-10);    assertEquals(ByteBuffer.wrap(floatMinBytesMinMax).order(java.nio.ByteOrder.LITTLE_ENDIAN).getFloat(), Float.MIN_VALUE, 1e-10);    FloatStatistics statsFromBytesMinMax = new FloatStatistics();    statsFromBytesMinMax.setMinMaxFromBytes(floatMinBytesMinMax, floatMaxBytesMinMax);    assertEquals(statsFromBytesMinMax.getMax(), Float.MAX_VALUE, 1e-10);    assertEquals(statsFromBytesMinMax.getMin(), Float.MIN_VALUE, 1e-10);        assertEquals("min: 1.0E-4, max: 553.6, num_nulls: 0", stats.toString());}
07671dd4fd731ec6ef4a6411a038896250ff78dbe2931129c31ca9fb8be21a88
testDoubleMinMax
public void testDoubleMinMax()
{        doubleArray = new double[] { 81.5d, 944.5f, 2.002d, 334.5d, 5.6d, 0.001d, 0.00001d, 23.0d, 553.6d };    DoubleStatistics stats = new DoubleStatistics();    for (double d : doubleArray) {        stats.updateStats(d);    }    assertEquals(stats.getMax(), 944.5d, 1e-10);    assertEquals(stats.getMin(), 0.00001d, 1e-10);        doubleArray = new double[] { -81.5d, -944.5d, 2.002d, -334.5d, -5.6d, -0.001d, -0.00001d, 23.0d, -3.6d };    DoubleStatistics statsNeg = new DoubleStatistics();    for (double d : doubleArray) {        statsNeg.updateStats(d);    }    assertEquals(statsNeg.getMax(), 23.0d, 1e-10);    assertEquals(statsNeg.getMin(), -944.5d, 1e-10);    assertTrue(statsNeg.compareMaxToValue(23.0001D) < 0);    assertTrue(statsNeg.compareMaxToValue(23D) == 0);    assertTrue(statsNeg.compareMaxToValue(0D) > 0);    assertTrue(statsNeg.compareMinToValue(-400D) < 0);    assertTrue(statsNeg.compareMinToValue(-944.5D) == 0);    assertTrue(statsNeg.compareMinToValue(-944.500001D) > 0);        byte[] doubleMaxBytes = statsNeg.getMaxBytes();    byte[] doubleMinBytes = statsNeg.getMinBytes();    assertEquals(ByteBuffer.wrap(doubleMaxBytes).order(java.nio.ByteOrder.LITTLE_ENDIAN).getDouble(), 23.0d, 1e-10);    assertEquals(ByteBuffer.wrap(doubleMinBytes).order(java.nio.ByteOrder.LITTLE_ENDIAN).getDouble(), -944.5d, 1e-10);    DoubleStatistics statsFromBytes = new DoubleStatistics();    statsFromBytes.setMinMaxFromBytes(doubleMinBytes, doubleMaxBytes);    assertEquals(statsFromBytes.getMax(), 23.0d, 1e-10);    assertEquals(statsFromBytes.getMin(), -944.5d, 1e-10);    doubleArray = new double[] { Double.MAX_VALUE, Double.MIN_VALUE };    DoubleStatistics minMaxValues = new DoubleStatistics();    for (double d : doubleArray) {        minMaxValues.updateStats(d);    }    assertEquals(minMaxValues.getMax(), Double.MAX_VALUE, 1e-10);    assertEquals(minMaxValues.getMin(), Double.MIN_VALUE, 1e-10);        byte[] doubleMaxBytesMinMax = minMaxValues.getMaxBytes();    byte[] doubleMinBytesMinMax = minMaxValues.getMinBytes();    assertEquals(ByteBuffer.wrap(doubleMaxBytesMinMax).order(java.nio.ByteOrder.LITTLE_ENDIAN).getDouble(), Double.MAX_VALUE, 1e-10);    assertEquals(ByteBuffer.wrap(doubleMinBytesMinMax).order(java.nio.ByteOrder.LITTLE_ENDIAN).getDouble(), Double.MIN_VALUE, 1e-10);    DoubleStatistics statsFromBytesMinMax = new DoubleStatistics();    statsFromBytesMinMax.setMinMaxFromBytes(doubleMinBytesMinMax, doubleMaxBytesMinMax);    assertEquals(statsFromBytesMinMax.getMax(), Double.MAX_VALUE, 1e-10);    assertEquals(statsFromBytesMinMax.getMin(), Double.MIN_VALUE, 1e-10);        assertEquals("min: 1.0E-5, max: 944.5, num_nulls: 0", stats.toString());}
cc7807bd20905c29d28b868ea84e653b895f7863044e500d78d6667445db5592
testFloatingPointStringIndependentFromLocale
public void testFloatingPointStringIndependentFromLocale()
{    Statistics<?> floatStats = Statistics.createStats(Types.optional(PrimitiveTypeName.FLOAT).named("test-float"));    floatStats.updateStats(123.456f);    Statistics<?> doubleStats = Statistics.createStats(Types.optional(PrimitiveTypeName.DOUBLE).named("test-double"));    doubleStats.updateStats(12345.6789);    Locale defaultLocale = Locale.getDefault();    try {                Locale.setDefault(Locale.FRENCH);        assertEquals("min: 123.456, max: 123.456, num_nulls: 0", floatStats.toString());        assertEquals("min: 12345.6789, max: 12345.6789, num_nulls: 0", doubleStats.toString());    } finally {        Locale.setDefault(defaultLocale);    }}
656ae3b283545ba105a6404349ceb07473304235aeaac4c81c779c52c7e236dd
testBooleanMinMax
public void testBooleanMinMax()
{        booleanArray = new boolean[] { true, true, true };    BooleanStatistics statsTrue = new BooleanStatistics();    for (boolean i : booleanArray) {        statsTrue.updateStats(i);    }    assertTrue(statsTrue.getMax());    assertTrue(statsTrue.getMin());        booleanArray = new boolean[] { false, false, false };    BooleanStatistics statsFalse = new BooleanStatistics();    for (boolean i : booleanArray) {        statsFalse.updateStats(i);    }    assertFalse(statsFalse.getMax());    assertFalse(statsFalse.getMin());    booleanArray = new boolean[] { false, true, false };    BooleanStatistics statsBoth = new BooleanStatistics();    for (boolean i : booleanArray) {        statsBoth.updateStats(i);    }    assertTrue(statsBoth.getMax());    assertFalse(statsBoth.getMin());        byte[] boolMaxBytes = statsBoth.getMaxBytes();    byte[] boolMinBytes = statsBoth.getMinBytes();    assertEquals((int) (boolMaxBytes[0] & 255), 1);    assertEquals((int) (boolMinBytes[0] & 255), 0);    BooleanStatistics statsFromBytes = new BooleanStatistics();    statsFromBytes.setMinMaxFromBytes(boolMinBytes, boolMaxBytes);    assertTrue(statsFromBytes.getMax());    assertFalse(statsFromBytes.getMin());        assertEquals(statsBoth.toString(), "min: false, max: true, num_nulls: 0");}
93e508a58cb8cd9da4a2f276823423a519cd1271bc0a985ee4e7c7e6eaa8d3f7
testBinaryMinMax
public void testBinaryMinMax()
{        stringArray = new String[] { "hello", "world", "this", "is", "a", "test", "of", "the", "stats", "class" };    PrimitiveType type = Types.optional(PrimitiveTypeName.BINARY).as(OriginalType.UTF8).named("test_binary_utf8");    BinaryStatistics stats = (BinaryStatistics) Statistics.createStats(type);    for (String s : stringArray) {        stats.updateStats(Binary.fromString(s));    }    assertEquals(stats.genericGetMax(), Binary.fromString("world"));    assertEquals(stats.genericGetMin(), Binary.fromString("a"));        stringArray = new String[] { "", "", "", "", "" };    BinaryStatistics statsEmpty = (BinaryStatistics) Statistics.createStats(type);    for (String s : stringArray) {        statsEmpty.updateStats(Binary.fromString(s));    }    assertEquals(statsEmpty.genericGetMax(), Binary.fromString(""));    assertEquals(statsEmpty.genericGetMin(), Binary.fromString(""));        byte[] stringMaxBytes = stats.getMaxBytes();    byte[] stringMinBytes = stats.getMinBytes();    assertEquals(new String(stringMaxBytes), "world");    assertEquals(new String(stringMinBytes), "a");    BinaryStatistics statsFromBytes = (BinaryStatistics) Statistics.createStats(type);    statsFromBytes.setMinMaxFromBytes(stringMinBytes, stringMaxBytes);    assertEquals(statsFromBytes.genericGetMax(), Binary.fromString("world"));    assertEquals(statsFromBytes.genericGetMin(), Binary.fromString("a"));        assertEquals(stats.toString(), "min: a, max: world, num_nulls: 0");}
514033c04fa7c7cfbcf58ae8751edde0f2e0766ffe3b9862b50e05379121f7a9
testBinaryMinMaxForReusedBackingByteArray
public void testBinaryMinMaxForReusedBackingByteArray()
{    BinaryStatistics stats = new BinaryStatistics();    byte[] bytes = new byte[] { 10 };    final Binary value = Binary.fromReusedByteArray(bytes);    stats.updateStats(value);    bytes[0] = 20;    stats.updateStats(value);    bytes[0] = 15;    stats.updateStats(value);    assertArrayEquals(new byte[] { 20 }, stats.getMaxBytes());    assertArrayEquals(new byte[] { 10 }, stats.getMinBytes());}
486f5dbeb14761aea3d73bb2b6d232d18bd8db1b43450bce1e3eccad427bb2e9
testMergingStatistics
public void testMergingStatistics()
{    testMergingIntStats();    testMergingLongStats();    testMergingFloatStats();    testMergingDoubleStats();    testMergingBooleanStats();    testMergingStringStats();}
a308983358b26e8aad79e08a4c088139189a33093183d47afb44ffd2ec73368c
testMergingIntStats
private void testMergingIntStats()
{    integerArray = new int[] { 1, 2, 3, 4, 5 };    IntStatistics intStats = new IntStatistics();    for (int s : integerArray) {        intStats.updateStats(s);    }    integerArray = new int[] { 0, 3, 3 };    IntStatistics intStats2 = new IntStatistics();    for (int s : integerArray) {        intStats2.updateStats(s);    }    intStats.mergeStatistics(intStats2);    assertEquals(intStats.getMax(), 5);    assertEquals(intStats.getMin(), 0);    integerArray = new int[] { -1, -100, 100 };    IntStatistics intStats3 = new IntStatistics();    for (int s : integerArray) {        intStats3.updateStats(s);    }    intStats.mergeStatistics(intStats3);    assertEquals(intStats.getMax(), 100);    assertEquals(intStats.getMin(), -100);}
711887ebf603d102ee39d2ad038aa8b5aeb112768ec847dab2ae6e8e9e41f3c5
testMergingLongStats
private void testMergingLongStats()
{    longArray = new long[] { 1l, 2l, 3l, 4l, 5l };    LongStatistics longStats = new LongStatistics();    for (long s : longArray) {        longStats.updateStats(s);    }    longArray = new long[] { 0l, 3l, 3l };    LongStatistics longStats2 = new LongStatistics();    for (long s : longArray) {        longStats2.updateStats(s);    }    longStats.mergeStatistics(longStats2);    assertEquals(longStats.getMax(), 5l);    assertEquals(longStats.getMin(), 0l);    longArray = new long[] { -1l, -100l, 100l };    LongStatistics longStats3 = new LongStatistics();    for (long s : longArray) {        longStats3.updateStats(s);    }    longStats.mergeStatistics(longStats3);    assertEquals(longStats.getMax(), 100l);    assertEquals(longStats.getMin(), -100l);}
ce79d35f9f969bc731ee87a999142bdfa01a21df9e8041c118100f4fbcdd1d5a
testMergingFloatStats
private void testMergingFloatStats()
{    floatArray = new float[] { 1.44f, 12.2f, 98.3f, 1.4f, 0.05f };    FloatStatistics floatStats = new FloatStatistics();    for (float s : floatArray) {        floatStats.updateStats(s);    }    floatArray = new float[] { 0.0001f, 9.9f, 3.1f };    FloatStatistics floatStats2 = new FloatStatistics();    for (float s : floatArray) {        floatStats2.updateStats(s);    }    floatStats.mergeStatistics(floatStats2);    assertEquals(floatStats.getMax(), 98.3f, 1e-10);    assertEquals(floatStats.getMin(), 0.0001f, 1e-10);    floatArray = new float[] { -1.91f, -100.9f, 100.54f };    FloatStatistics floatStats3 = new FloatStatistics();    for (float s : floatArray) {        floatStats3.updateStats(s);    }    floatStats.mergeStatistics(floatStats3);    assertEquals(floatStats.getMax(), 100.54f, 1e-10);    assertEquals(floatStats.getMin(), -100.9f, 1e-10);}
6f237648c140e946147ac91e1cf88892836e0e6f5b098c2971d46c56ac9973ab
testMergingDoubleStats
private void testMergingDoubleStats()
{    doubleArray = new double[] { 1.44d, 12.2d, 98.3d, 1.4d, 0.05d };    DoubleStatistics doubleStats = new DoubleStatistics();    for (double s : doubleArray) {        doubleStats.updateStats(s);    }    doubleArray = new double[] { 0.0001d, 9.9d, 3.1d };    DoubleStatistics doubleStats2 = new DoubleStatistics();    for (double s : doubleArray) {        doubleStats2.updateStats(s);    }    doubleStats.mergeStatistics(doubleStats2);    assertEquals(doubleStats.getMax(), 98.3d, 1e-10);    assertEquals(doubleStats.getMin(), 0.0001d, 1e-10);    doubleArray = new double[] { -1.91d, -100.9d, 100.54d };    DoubleStatistics doubleStats3 = new DoubleStatistics();    for (double s : doubleArray) {        doubleStats3.updateStats(s);    }    doubleStats.mergeStatistics(doubleStats3);    assertEquals(doubleStats.getMax(), 100.54d, 1e-10);    assertEquals(doubleStats.getMin(), -100.9d, 1e-10);}
d7e9c2c47a384d00dc23a3eaf48aa009d8e4815f3e04b5a840512b7f97c38039
testMergingBooleanStats
private void testMergingBooleanStats()
{    booleanArray = new boolean[] { true, true, true };    BooleanStatistics booleanStats = new BooleanStatistics();    for (boolean s : booleanArray) {        booleanStats.updateStats(s);    }    booleanArray = new boolean[] { true, false };    BooleanStatistics booleanStats2 = new BooleanStatistics();    for (boolean s : booleanArray) {        booleanStats2.updateStats(s);    }    booleanStats.mergeStatistics(booleanStats2);    assertEquals(booleanStats.getMax(), true);    assertEquals(booleanStats.getMin(), false);    booleanArray = new boolean[] { false, false, false, false };    BooleanStatistics booleanStats3 = new BooleanStatistics();    for (boolean s : booleanArray) {        booleanStats3.updateStats(s);    }    booleanStats.mergeStatistics(booleanStats3);    assertEquals(booleanStats.getMax(), true);    assertEquals(booleanStats.getMin(), false);}
16879504bb59efdbbdafbba5a39df443641ef84453c59050d53dc8b045d5f44e
testMergingStringStats
private void testMergingStringStats()
{    stringArray = new String[] { "hello", "world", "this", "is", "a", "test", "of", "the", "stats", "class" };    BinaryStatistics stats = new BinaryStatistics();    for (String s : stringArray) {        stats.updateStats(Binary.fromString(s));    }    stringArray = new String[] { "zzzz", "asdf", "testing" };    BinaryStatistics stats2 = new BinaryStatistics();    for (String s : stringArray) {        stats2.updateStats(Binary.fromString(s));    }    stats.mergeStatistics(stats2);    assertEquals(stats.getMax(), Binary.fromString("zzzz"));    assertEquals(stats.getMin(), Binary.fromString("a"));    stringArray = new String[] { "", "good", "testing" };    BinaryStatistics stats3 = new BinaryStatistics();    for (String s : stringArray) {        stats3.updateStats(Binary.fromString(s));    }    stats.mergeStatistics(stats3);    assertEquals(stats.getMax(), Binary.fromString("zzzz"));    assertEquals(stats.getMin(), Binary.fromString(""));}
451db4fbfcb6dfe9a2be41eed244ba4f1a08529d9703f1371311afff5b107a57
testBuilder
public void testBuilder()
{    testBuilder(Types.required(BOOLEAN).named("test_boolean"), false, new byte[] { 0 }, true, new byte[] { 1 });    testBuilder(Types.required(INT32).named("test_int32"), -42, intToBytes(-42), 42, intToBytes(42));    testBuilder(Types.required(INT64).named("test_int64"), -42l, longToBytes(-42), 42l, longToBytes(42));    testBuilder(Types.required(FLOAT).named("test_float"), -42.0f, intToBytes(floatToIntBits(-42.0f)), 42.0f, intToBytes(floatToIntBits(42.0f)));    testBuilder(Types.required(DOUBLE).named("test_double"), -42.0, longToBytes(doubleToLongBits(-42.0)), 42.0, longToBytes(Double.doubleToLongBits(42.0f)));    byte[] min = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };    byte[] max = { 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24 };    testBuilder(Types.required(INT96).named("test_int96"), Binary.fromConstantByteArray(min), min, Binary.fromConstantByteArray(max), max);    testBuilder(Types.required(FIXED_LEN_BYTE_ARRAY).length(12).named("test_fixed"), Binary.fromConstantByteArray(min), min, Binary.fromConstantByteArray(max), max);    testBuilder(Types.required(BINARY).named("test_binary"), Binary.fromConstantByteArray(min), min, Binary.fromConstantByteArray(max), max);}
a06497282b5fc6215933965ffedb50e719168effeaba9e6279398a53095bcd93
testBuilder
private void testBuilder(PrimitiveType type, Object min, byte[] minBytes, Object max, byte[] maxBytes)
{    Statistics.Builder builder = Statistics.getBuilderForReading(type);    Statistics<?> stats = builder.build();    assertTrue(stats.isEmpty());    assertFalse(stats.isNumNullsSet());    assertFalse(stats.hasNonNullValue());    builder = Statistics.getBuilderForReading(type);    stats = builder.withNumNulls(0).withMin(minBytes).build();    assertFalse(stats.isEmpty());    assertTrue(stats.isNumNullsSet());    assertFalse(stats.hasNonNullValue());    assertEquals(0, stats.getNumNulls());    builder = Statistics.getBuilderForReading(type);    stats = builder.withNumNulls(11).withMax(maxBytes).build();    assertFalse(stats.isEmpty());    assertTrue(stats.isNumNullsSet());    assertFalse(stats.hasNonNullValue());    assertEquals(11, stats.getNumNulls());    builder = Statistics.getBuilderForReading(type);    stats = builder.withNumNulls(42).withMin(minBytes).withMax(maxBytes).build();    assertFalse(stats.isEmpty());    assertTrue(stats.isNumNullsSet());    assertTrue(stats.hasNonNullValue());    assertEquals(42, stats.getNumNulls());    assertEquals(min, stats.genericGetMin());    assertEquals(max, stats.genericGetMax());}
2d9aee52c5bb980f142cbff94440db006e1c5cd248eb03887261f0ff80487498
testSpecBuilderForFloat
public void testSpecBuilderForFloat()
{    PrimitiveType type = Types.required(FLOAT).named("test_float");    Statistics.Builder builder = Statistics.getBuilderForReading(type);    Statistics<?> stats = builder.withMin(intToBytes(floatToIntBits(Float.NaN))).withMax(intToBytes(floatToIntBits(42.0f))).withNumNulls(0).build();    assertTrue(stats.isNumNullsSet());    assertEquals(0, stats.getNumNulls());    assertFalse(stats.hasNonNullValue());    builder = Statistics.getBuilderForReading(type);    stats = builder.withMin(intToBytes(floatToIntBits(-42.0f))).withMax(intToBytes(floatToIntBits(Float.NaN))).withNumNulls(11).build();    assertTrue(stats.isNumNullsSet());    assertEquals(11, stats.getNumNulls());    assertFalse(stats.hasNonNullValue());    builder = Statistics.getBuilderForReading(type);    stats = builder.withMin(intToBytes(floatToIntBits(Float.NaN))).withMax(intToBytes(floatToIntBits(Float.NaN))).withNumNulls(42).build();    assertTrue(stats.isNumNullsSet());    assertEquals(42, stats.getNumNulls());    assertFalse(stats.hasNonNullValue());    builder = Statistics.getBuilderForReading(type);    stats = builder.withMin(intToBytes(floatToIntBits(0.0f))).withMax(intToBytes(floatToIntBits(42.0f))).build();    assertEquals(0, Float.compare(-0.0f, (Float) stats.genericGetMin()));    assertEquals(0, Float.compare(42.0f, (Float) stats.genericGetMax()));    builder = Statistics.getBuilderForReading(type);    stats = builder.withMin(intToBytes(floatToIntBits(-42.0f))).withMax(intToBytes(floatToIntBits(-0.0f))).build();    assertEquals(0, Float.compare(-42.0f, (Float) stats.genericGetMin()));    assertEquals(0, Float.compare(0.0f, (Float) stats.genericGetMax()));    builder = Statistics.getBuilderForReading(type);    stats = builder.withMin(intToBytes(floatToIntBits(0.0f))).withMax(intToBytes(floatToIntBits(-0.0f))).build();    assertEquals(0, Float.compare(-0.0f, (Float) stats.genericGetMin()));    assertEquals(0, Float.compare(0.0f, (Float) stats.genericGetMax()));}
72cb3823f1f2a4b2a49023982b06bdec3c8614e88070cac0d101452d64db1b8d
testSpecBuilderForDouble
public void testSpecBuilderForDouble()
{    PrimitiveType type = Types.required(DOUBLE).named("test_double");    Statistics.Builder builder = Statistics.getBuilderForReading(type);    Statistics<?> stats = builder.withMin(longToBytes(doubleToLongBits(Double.NaN))).withMax(longToBytes(doubleToLongBits(42.0))).withNumNulls(0).build();    assertTrue(stats.isNumNullsSet());    assertEquals(0, stats.getNumNulls());    assertFalse(stats.hasNonNullValue());    builder = Statistics.getBuilderForReading(type);    stats = builder.withMin(longToBytes(doubleToLongBits(-42.0))).withMax(longToBytes(doubleToLongBits(Double.NaN))).withNumNulls(11).build();    assertTrue(stats.isNumNullsSet());    assertEquals(11, stats.getNumNulls());    assertFalse(stats.hasNonNullValue());    builder = Statistics.getBuilderForReading(type);    stats = builder.withMin(longToBytes(doubleToLongBits(Double.NaN))).withMax(longToBytes(doubleToLongBits(Double.NaN))).withNumNulls(42).build();    assertTrue(stats.isNumNullsSet());    assertEquals(42, stats.getNumNulls());    assertFalse(stats.hasNonNullValue());    builder = Statistics.getBuilderForReading(type);    stats = builder.withMin(longToBytes(doubleToLongBits(0.0))).withMax(longToBytes(doubleToLongBits(42.0))).build();    assertEquals(0, Double.compare(-0.0, (Double) stats.genericGetMin()));    assertEquals(0, Double.compare(42.0, (Double) stats.genericGetMax()));    builder = Statistics.getBuilderForReading(type);    stats = builder.withMin(longToBytes(doubleToLongBits(-42.0))).withMax(longToBytes(doubleToLongBits(-0.0))).build();    assertEquals(0, Double.compare(-42.0, (Double) stats.genericGetMin()));    assertEquals(0, Double.compare(0.0, (Double) stats.genericGetMax()));    builder = Statistics.getBuilderForReading(type);    stats = builder.withMin(longToBytes(doubleToLongBits(0.0))).withMax(longToBytes(doubleToLongBits(-0.0))).build();    assertEquals(0, Double.compare(-0.0, (Double) stats.genericGetMin()));    assertEquals(0, Double.compare(0.0, (Double) stats.genericGetMax()));}
fa5d30c73caf639b4ea027b795302409623821b9dc86c882a2c8098c4b277a1b
column
private ColumnDescriptor column(String... path)
{    return new ColumnDescriptor(path, PrimitiveType.PrimitiveTypeName.INT32, 0, 0);}
9be32f41ad293be37b7d6d0a8bd834b136e4f7966c6442f4c22f71a5742c0706
testComparesTo
public void testComparesTo() throws Exception
{    assertEquals(column("a").compareTo(column("a")), 0);    assertEquals(column("a", "b").compareTo(column("a", "b")), 0);    assertEquals(column("a").compareTo(column("b")), -1);    assertEquals(column("b").compareTo(column("a")), 1);    assertEquals(column("a", "a").compareTo(column("a", "b")), -1);    assertEquals(column("b", "a").compareTo(column("a", "a")), 1);    assertEquals(column("a").compareTo(column("a", "b")), -1);    assertEquals(column("b").compareTo(column("a", "b")), 1);    assertEquals(column("a", "b").compareTo(column("a")), 1);    assertEquals(column("a", "b").compareTo(column("b")), -1);    assertEquals(column("").compareTo(column("")), 0);    assertEquals(column("").compareTo(column("a")), -1);    assertEquals(column("a").compareTo(column("")), 1);}
c67f8bfbc6e0e6e9d0ab8b7b19dea0aef97497e0f20ce75b39bc5a2f10d241a9
testReusedBuilder
public void testReusedBuilder()
{    EncodingStats.Builder builder = new EncodingStats.Builder();    builder.withV2Pages();    builder.addDictEncoding(Encoding.PLAIN);    builder.addDataEncoding(Encoding.RLE_DICTIONARY, 3);    builder.addDataEncoding(Encoding.DELTA_BYTE_ARRAY);    builder.addDataEncoding(Encoding.DELTA_BYTE_ARRAY);    EncodingStats stats1 = builder.build();    Map<Encoding, Integer> expectedDictStats1 = new HashMap<Encoding, Integer>();    expectedDictStats1.put(Encoding.PLAIN, 1);    Map<Encoding, Integer> expectedDataStats1 = new HashMap<Encoding, Integer>();    expectedDataStats1.put(Encoding.RLE_DICTIONARY, 3);    expectedDataStats1.put(Encoding.DELTA_BYTE_ARRAY, 2);    builder.clear();    builder.addDataEncoding(Encoding.PLAIN);    builder.addDataEncoding(Encoding.PLAIN);    builder.addDataEncoding(Encoding.PLAIN);    builder.addDataEncoding(Encoding.PLAIN);    EncodingStats stats2 = builder.build();    Map<Encoding, Integer> expectedDictStats2 = new HashMap<Encoding, Integer>();    Map<Encoding, Integer> expectedDataStats2 = new HashMap<Encoding, Integer>();    expectedDataStats2.put(Encoding.PLAIN, 4);    assertEquals("Dictionary stats should be correct", expectedDictStats2, stats2.dictStats);    assertEquals("Data stats should be correct", expectedDataStats2, stats2.dataStats);    assertEquals("Dictionary stats should be correct after reuse", expectedDictStats1, stats1.dictStats);    assertEquals("Data stats should be correct after reuse", expectedDataStats1, stats1.dataStats);}
62da382d6503552feda5fa3ebd401422592e2d0ead54c9976038440b624fefbf
testNoPages
public void testNoPages()
{    EncodingStats.Builder builder = new EncodingStats.Builder();    EncodingStats stats = builder.build();    assertFalse(stats.usesV2Pages());    assertFalse("Should not have dictionary-encoded pages", stats.hasDictionaryEncodedPages());    assertFalse("Should not have non-dictionary pages", stats.hasNonDictionaryEncodedPages());    assertFalse("Should not have dictionary pages", stats.hasDictionaryPages());}
289390ca198e1b824dcaf915596ed00dfcdb8aecf4e20021237e93fdcc48c825
testNoDataPages
public void testNoDataPages()
{    EncodingStats.Builder builder = new EncodingStats.Builder();    builder.addDictEncoding(Encoding.PLAIN_DICTIONARY);    EncodingStats stats = builder.build();    assertFalse(stats.usesV2Pages());    assertFalse("Should not have dictionary-encoded pages", stats.hasDictionaryEncodedPages());    assertFalse("Should not have non-dictionary pages", stats.hasNonDictionaryEncodedPages());    assertTrue("Should have dictionary pages", stats.hasDictionaryPages());}
620bc92fdd12f084e383b2bce2931694e6bc4936eccac78862d80ae31675603b
testV1AllDictionary
public void testV1AllDictionary()
{    EncodingStats.Builder builder = new EncodingStats.Builder();    builder.addDictEncoding(Encoding.PLAIN_DICTIONARY);    builder.addDataEncoding(Encoding.PLAIN_DICTIONARY);    builder.addDataEncoding(Encoding.PLAIN_DICTIONARY);    EncodingStats stats = builder.build();    assertFalse(stats.usesV2Pages());    assertTrue("Should have dictionary-encoded pages", stats.hasDictionaryEncodedPages());    assertFalse("Should not have non-dictionary pages", stats.hasNonDictionaryEncodedPages());    assertTrue("Should have dictionary pages", stats.hasDictionaryPages());}
a16605fe99a3d65375ae88447c7a8c2e6364ba3f106f171144063e95b449af8f
testV1NoDictionary
public void testV1NoDictionary()
{    EncodingStats.Builder builder = new EncodingStats.Builder();    builder.addDataEncoding(Encoding.PLAIN);    EncodingStats stats = builder.build();    assertFalse(stats.usesV2Pages());    assertFalse("Should not have dictionary-encoded pages", stats.hasDictionaryEncodedPages());    assertTrue("Should have non-dictionary pages", stats.hasNonDictionaryEncodedPages());    assertFalse("Should not have dictionary pages", stats.hasDictionaryPages());}
c38ceaaa3d31ccc4c5a02d929be94a823af767692ca1c024c6877d854f184d4c
testV1Fallback
public void testV1Fallback()
{    EncodingStats.Builder builder = new EncodingStats.Builder();    builder.addDictEncoding(Encoding.PLAIN_DICTIONARY);    builder.addDataEncoding(Encoding.PLAIN_DICTIONARY);    builder.addDataEncoding(Encoding.PLAIN_DICTIONARY);    builder.addDataEncoding(Encoding.PLAIN);    EncodingStats stats = builder.build();    assertFalse(stats.usesV2Pages());    assertTrue("Should have dictionary-encoded pages", stats.hasDictionaryEncodedPages());    assertTrue("Should have non-dictionary pages", stats.hasNonDictionaryEncodedPages());    assertTrue("Should have dictionary pages", stats.hasDictionaryPages());}
dd52aa754225c9053a9ac604e16c14ea572f22ad54f3f84d42dcfffdb9f0a4d6
testV2AllDictionary
public void testV2AllDictionary()
{    EncodingStats.Builder builder = new EncodingStats.Builder();    builder.withV2Pages();    builder.addDictEncoding(Encoding.PLAIN);    builder.addDataEncoding(Encoding.RLE_DICTIONARY);    EncodingStats stats = builder.build();    assertTrue(stats.usesV2Pages());    assertTrue("Should have dictionary-encoded pages", stats.hasDictionaryEncodedPages());    assertFalse("Should not have non-dictionary pages", stats.hasNonDictionaryEncodedPages());    assertTrue("Should have dictionary pages", stats.hasDictionaryPages());}
d21f537e3d4071e27d87e3693b1a7c8f34571082e352187aa0f958a4e8d42801
testV2NoDictionary
public void testV2NoDictionary()
{    EncodingStats.Builder builder = new EncodingStats.Builder();    builder.withV2Pages();    builder.addDataEncoding(Encoding.DELTA_BINARY_PACKED);    builder.addDataEncoding(Encoding.DELTA_BINARY_PACKED);    EncodingStats stats = builder.build();    assertTrue(stats.usesV2Pages());    assertFalse("Should not have dictionary-encoded pages", stats.hasDictionaryEncodedPages());    assertTrue("Should have non-dictionary pages", stats.hasNonDictionaryEncodedPages());    assertFalse("Should not have dictionary pages", stats.hasDictionaryPages());}
fb84f129c306b4bf3f55e2c46d333175258b4bf05b3ee52faedc42781796b866
testV2Fallback
public void testV2Fallback()
{    EncodingStats.Builder builder = new EncodingStats.Builder();    builder.withV2Pages();    builder.addDictEncoding(Encoding.PLAIN);    builder.addDataEncoding(Encoding.RLE_DICTIONARY);    builder.addDataEncoding(Encoding.DELTA_BYTE_ARRAY);    builder.addDataEncoding(Encoding.DELTA_BYTE_ARRAY);    EncodingStats stats = builder.build();    assertTrue(stats.usesV2Pages());    assertTrue("Should have dictionary-encoded pages", stats.hasDictionaryEncodedPages());    assertTrue("Should have non-dictionary pages", stats.hasNonDictionaryEncodedPages());    assertTrue("Should have dictionary pages", stats.hasDictionaryPages());}
90c74de1445b35f5b5b2180c1668f7db7fa20ff965a8c53eda25a59b6e3cff32
testCounts
public void testCounts()
{    EncodingStats.Builder builder = new EncodingStats.Builder();    builder.withV2Pages();    builder.addDictEncoding(Encoding.PLAIN);    builder.addDataEncoding(Encoding.RLE_DICTIONARY, 4);    builder.addDataEncoding(Encoding.RLE_DICTIONARY);    builder.addDataEncoding(Encoding.DELTA_BYTE_ARRAY);    builder.addDataEncoding(Encoding.DELTA_BYTE_ARRAY);    EncodingStats stats = builder.build();    assertEquals("Count should match", 1, stats.getNumDictionaryPagesEncodedAs(Encoding.PLAIN));    assertEquals("Count should match", 0, stats.getNumDictionaryPagesEncodedAs(Encoding.PLAIN_DICTIONARY));    assertEquals("Count should match", 0, stats.getNumDictionaryPagesEncodedAs(Encoding.RLE));    assertEquals("Count should match", 0, stats.getNumDictionaryPagesEncodedAs(Encoding.BIT_PACKED));    assertEquals("Count should match", 0, stats.getNumDictionaryPagesEncodedAs(Encoding.DELTA_BYTE_ARRAY));    assertEquals("Count should match", 0, stats.getNumDictionaryPagesEncodedAs(Encoding.DELTA_BINARY_PACKED));    assertEquals("Count should match", 0, stats.getNumDictionaryPagesEncodedAs(Encoding.DELTA_LENGTH_BYTE_ARRAY));    assertEquals("Count should match", 5, stats.getNumDataPagesEncodedAs(Encoding.RLE_DICTIONARY));    assertEquals("Count should match", 2, stats.getNumDataPagesEncodedAs(Encoding.DELTA_BYTE_ARRAY));    assertEquals("Count should match", 0, stats.getNumDataPagesEncodedAs(Encoding.RLE));    assertEquals("Count should match", 0, stats.getNumDataPagesEncodedAs(Encoding.BIT_PACKED));    assertEquals("Count should match", 0, stats.getNumDataPagesEncodedAs(Encoding.PLAIN));    assertEquals("Count should match", 0, stats.getNumDataPagesEncodedAs(Encoding.PLAIN_DICTIONARY));    assertEquals("Count should match", 0, stats.getNumDataPagesEncodedAs(Encoding.DELTA_BINARY_PACKED));    assertEquals("Count should match", 0, stats.getNumDataPagesEncodedAs(Encoding.DELTA_LENGTH_BYTE_ARRAY));}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    int COUNT = 800000;    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BitPackingWriter w = BitPacking.getBitPackingWriter(1, baos);    long t0 = System.currentTimeMillis();    for (int i = 0; i < COUNT; ++i) {        w.write(i % 2);    }    w.finish();    long t1 = System.currentTimeMillis();    System.out.println("written in " + (t1 - t0) + "ms");    System.out.println();    byte[] bytes = baos.toByteArray();    System.out.println(bytes.length);    int[] result = new int[COUNT];    for (int l = 0; l < 5; l++) {        long s = manual(bytes, result);        long b = generated(bytes, result);        float ratio = (float) b / s;        System.out.println("                                             " + ratio + (ratio < 1 ? " < 1 => GOOD" : " >= 1 => BAD"));    }}
a7650b4e59065b3be91994deed9f3311e453b52d09e26a38a7d35d956a2036c7
verify
private static void verify(int[] result)
{    int error = 0;    for (int i = 0; i < result.length; ++i) {        if (result[i] != i % 2) {            error++;        }    }    if (error != 0) {        throw new RuntimeException("errors: " + error + " / " + result.length);    }}
cb14f7b252cac9edf8220954af48c32518767f9d0aba361f700e5fde04af203c
manual
private static long manual(byte[] bytes, int[] result) throws IOException
{    return readNTimes(bytes, result, new BitPackingValuesReader(1));}
85f77fe997ee57a422ec0f1ea183ecacaf190db055e05dacfac45194f6b49c7c
generated
private static long generated(byte[] bytes, int[] result) throws IOException
{    return readNTimes(bytes, result, new ByteBitPackingValuesReader(1, Packer.BIG_ENDIAN));}
281fb82dc1ee4493c31100b0025887932d9623633084974f85bf4b824f055014
readNTimes
private static long readNTimes(byte[] bytes, int[] result, ValuesReader r) throws IOException
{    System.out.println();    long t = 0;    int N = 10;    System.gc();    System.out.print("                                             " + r.getClass().getSimpleName());    System.out.print(" no gc <");    for (int k = 0; k < N; k++) {        long t2 = System.nanoTime();        r.initFromPage(result.length, ByteBufferInputStream.wrap(ByteBuffer.wrap(bytes)));        for (int i = 0; i < result.length; i++) {            result[i] = r.readInteger();        }        long t3 = System.nanoTime();        t += t3 - t2;    }    System.out.println("> read in " + t / 1000 + "s " + (N * result.length / (t / 1000)) + " values per s");    verify(result);    return t;}
5630f560aa182ff99a0dde428f64803fb0c325c25e9cad41ea2da67399b094ca
testZero
public void testZero() throws IOException
{    int bitLength = 0;    int[] vals = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };    String expected = "";    validateEncodeDecode(bitLength, vals, expected);}
1394e88db5506af6ddeb2f5491662107a6d13332c1ae291b5a73d367d2bbddda
testOne_0
public void testOne_0() throws IOException
{    int[] vals = { 0 };    String expected = "00000000";    validateEncodeDecode(1, vals, expected);}
c15b58b737217fa89703024cb421cfa028b2b28d6e61a11804c5c9e255994842
testOne_1
public void testOne_1() throws IOException
{    int[] vals = { 1 };    String expected = "10000000";    validateEncodeDecode(1, vals, expected);}
a2ee7c84c62d7a85298d00bac2e8762a8d0d83cfe395ce1757b28d8cc8a3c23a
testOne_0_0
public void testOne_0_0() throws IOException
{    int[] vals = { 0, 0 };    String expected = "00000000";    validateEncodeDecode(1, vals, expected);}
42857fffdaa7724e34dff4097c170af0de5ce90c00f37c8368bcf79a16c3a450
testOne_1_1
public void testOne_1_1() throws IOException
{    int[] vals = { 1, 1 };    String expected = "11000000";    validateEncodeDecode(1, vals, expected);}
74ef617f73f5eb132e8a374e4026f15b88fe383842b338282457fb916f621e28
testOne_9_1s
public void testOne_9_1s() throws IOException
{    int[] vals = { 1, 1, 1, 1, 1, 1, 1, 1, 1 };    String expected = "11111111 10000000";    validateEncodeDecode(1, vals, expected);}
8f5aa40d6bcc56c886231c63162f885c8dae19e04abb704637facf36b599d6fd
testOne_9_0s
public void testOne_9_0s() throws IOException
{    int[] vals = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };    String expected = "00000000 00000000";    validateEncodeDecode(1, vals, expected);}
f6a4525ef820cfd8a1e7ab487c1cb14c4f268f3725d750d3a29a7ca8ceb6edbe
testOne_7_0s_1_1
public void testOne_7_0s_1_1() throws IOException
{    int[] vals = { 0, 0, 0, 0, 0, 0, 0, 1 };    String expected = "00000001";    validateEncodeDecode(1, vals, expected);}
027b49680baddba2e863d6eb1ed8093050dfc932fdf218a1e844899bb32af7a1
testOne_9_0s_1_1
public void testOne_9_0s_1_1() throws IOException
{    int[] vals = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 };    String expected = "00000000 01000000";    validateEncodeDecode(1, vals, expected);}
eab8d4d3e2375d6f62c3e9786473d36cd0cff0ed6904410fe8a489a57c65d6a2
testOne
public void testOne() throws IOException
{    int[] vals = { 0, 1, 0, 0, 1, 1, 1, 0, 0, 1 };    String expected = "01001110 01000000";    validateEncodeDecode(1, vals, expected);}
3d4e618f65eff917e616a3b799bc55ec1cb5ed45ed7e80d2e56d03b81e16a9c7
testTwo
public void testTwo() throws IOException
{    int[] vals = { 0, 1, 2, 3, 3, 3, 2, 1, 1, 0, 0, 0, 1 };    String expected = "00011011 11111001 01000000 01000000";    validateEncodeDecode(2, vals, expected);}
a6311870f518a302ef942c253b77dbe9ecd4bb7a3ff7b743e9bae63b59ed1bb8
testThree
public void testThree() throws IOException
{    int[] vals = { 0, 1, 2, 3, 4, 5, 6, 7, 1 };    String expected = "00000101 00111001 01110111 " + "00100000";    validateEncodeDecode(3, vals, expected);}
098b6fe03a658953a4fc82785d520ea2fc6eae7e2918a762ac2252c35ace593b
testFour
public void testFour() throws IOException
{    int[] vals = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1 };    String expected = "00000001 00100011 01000101 01100111 10001001 10101011 11001101 11101111 00010000";    validateEncodeDecode(4, vals, expected);}
61b7cc4a0b46d978d99184561c59a23f0415748a413a25cd682702cd16f33430
testFive
public void testFive() throws IOException
{    int[] vals = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 1 };    String expected = "00000000 01000100 00110010 00010100 11000111 " + "01000010 01010100 10110110 00110101 11001111 " + "10000100 01100101 00111010 01010110 11010111 " + "11000110 01110101 10111110 01110111 11011111 " + "00001000";    validateEncodeDecode(5, vals, expected);}
2e8e5de9853a51714f775cdf535f190799d4157c5d00b51f7ec06bf373a96672
testSix
public void testSix() throws IOException
{    int[] vals = { 0, 28, 34, 35, 63, 1 };        String expected = "00000001 11001000 10100011 " + "11111100 00010000";    validateEncodeDecode(6, vals, expected);}
6b4634c8635be36cfd07b28bdbde77a35899030d94a28aa2ee6a0e43df58254e
testSeven
public void testSeven() throws IOException
{    int[] vals = { 0, 28, 34, 35, 63, 1, 125, 1, 1 };        String expected = "00000000 01110001 00010010 00110111 11100000 01111110 10000001 " + "00000010";    validateEncodeDecode(7, vals, expected);}
9f7b708d559e516ef201460d896f024a543b1ca2085fe385569e8e68426c0f24
validateEncodeDecode
private void validateEncodeDecode(int bitLength, int[] vals, String expected) throws IOException
{    for (PACKING_TYPE type : PACKING_TYPE.values()) {        LOG.debug("{}", type);        final int bound = (int) Math.pow(2, bitLength) - 1;        ValuesWriter w = type.getWriter(bound);        for (int i : vals) {            w.writeInteger(i);        }        byte[] bytes = w.getBytes().toByteArray();        LOG.debug("vals (" + bitLength + "): " + TestBitPacking.toString(vals));        LOG.debug("bytes: {}", TestBitPacking.toString(bytes));        assertEquals(type.toString(), expected, TestBitPacking.toString(bytes));        ValuesReader r = type.getReader(bound);        r.initFromPage(vals.length, ByteBufferInputStream.wrap(ByteBuffer.wrap(bytes)));        int[] result = new int[vals.length];        for (int i = 0; i < result.length; i++) {            result[i] = r.readInteger();        }        LOG.debug("result: {}", TestBitPacking.toString(result));        assertArrayEquals(type + " result: " + TestBitPacking.toString(result), vals, result);                r.initFromPage(vals.length, ByteBufferInputStream.wrap(ByteBuffer.wrap(bytes)));        for (int i = 0; i < vals.length; i += 2) {            assertEquals(vals[i], r.readInteger());            r.skip();        }                r.initFromPage(vals.length, ByteBufferInputStream.wrap(ByteBuffer.wrap(bytes)));        int skipCount;        for (int i = 0; i < vals.length; i += skipCount + 1) {            skipCount = (vals.length - i) / 2;            assertEquals(vals[i], r.readInteger());            r.skip(skipCount);        }    }}
cf705809b61bc6a972e24cd059acc529f1c5eb7584b032cb51361a8d3960bbbc
getReader
public ValuesReader getReader(final int bound)
{    return new BitPackingValuesReader(bound);}
2b81843efe75c869bba6470d08b2f61f91fe3a829428698687e7eda7b4d9bac0
getWriter
public ValuesWriter getWriter(final int bound)
{    return new BitPackingValuesWriter(bound, 32 * 1024, 64 * 1024, new DirectByteBufferAllocator());}
cf705809b61bc6a972e24cd059acc529f1c5eb7584b032cb51361a8d3960bbbc
getReader
public ValuesReader getReader(final int bound)
{    return new ByteBitPackingValuesReader(bound, BIG_ENDIAN);}
2b81843efe75c869bba6470d08b2f61f91fe3a829428698687e7eda7b4d9bac0
getWriter
public ValuesWriter getWriter(final int bound)
{    return new ByteBitPackingValuesWriter(bound, BIG_ENDIAN);}
8bb066d270cf1721b9f219a0e0dfb93af63e8b091add87465891f46aa439a52a
testBigNumbers
public void testBigNumbers()
{    final Random r = new Random();    testRandomIntegers(new IntFunc() {        @Override        public int getIntValue() {            return r.nextInt();        }    }, 32);}
be5970009ad145a3fce4247f43f7e4e3473858f0d4d6a5d8ae6ef68d7c2dfe62
getIntValue
public int getIntValue()
{    return r.nextInt();}
7813dde051120172d0f7e0fb64a5b3e292eec7e11938fc3ce5b8d02d76543603
testRangedNumbersWithSmallVariations
public void testRangedNumbersWithSmallVariations()
{    final Random r = new Random();    testRandomIntegers(new IntFunc() {        @Override        public int getIntValue() {            return 1000 + r.nextInt(20);        }    }, 10);}
be5970009ad145a3fce4247f43f7e4e3473858f0d4d6a5d8ae6ef68d7c2dfe62
getIntValue
public int getIntValue()
{    return 1000 + r.nextInt(20);}
d838e1a053e8b178244ba5fc012bbe986025956a12249f6ca7099275ef741d6c
testSmallNumbersWithSmallVariations
public void testSmallNumbersWithSmallVariations()
{    final Random r = new Random();    testRandomIntegers(new IntFunc() {        @Override        public int getIntValue() {            return 40 + r.nextInt(20);        }    }, 6);}
be5970009ad145a3fce4247f43f7e4e3473858f0d4d6a5d8ae6ef68d7c2dfe62
getIntValue
public int getIntValue()
{    return 40 + r.nextInt(20);}
c59da22b262fab29f14ecee4322c1b491a57f4515fbd34518810e49cf70d7010
testSmallNumberVariation
public void testSmallNumberVariation()
{    final Random r = new Random();    testRandomIntegers(new IntFunc() {        @Override        public int getIntValue() {            return r.nextInt(20) - 10;        }    }, 4);}
be5970009ad145a3fce4247f43f7e4e3473858f0d4d6a5d8ae6ef68d7c2dfe62
getIntValue
public int getIntValue()
{    return r.nextInt(20) - 10;}
80e633ab50447dc5f9cd3a6cbadd035d4ba127cb4c24a18f78212b7d7259acb5
testRandomIntegers
public void testRandomIntegers(IntFunc func, int bitWidth)
{    DeltaBinaryPackingValuesWriter delta = new DeltaBinaryPackingValuesWriterForInteger(blockSize, miniBlockNum, 100, 20000, new DirectByteBufferAllocator());    RunLengthBitPackingHybridValuesWriter rle = new RunLengthBitPackingHybridValuesWriter(bitWidth, 100, 20000, new DirectByteBufferAllocator());    for (int i = 0; i < dataSize; i++) {        int v = func.getIntValue();        delta.writeInteger(v);        rle.writeInteger(v);    }    System.out.println("delta size: " + delta.getBytes().size());    System.out.println("estimated size" + estimatedSize());    System.out.println("rle size: " + rle.getBytes().size());}
caf9d64ee74de4a1488fd37f69f3d2c0f00a3b2011a1d282d0bfecb225daca08
estimatedSize
private double estimatedSize()
{    int miniBlockSize = blockSize / miniBlockNum;    double miniBlockFlushed = Math.ceil(((double) dataSize - 1) / miniBlockSize);    double blockFlushed = Math.ceil(((double) dataSize - 1) / blockSize);    double estimatedSize =     4 * 5 +     4 * miniBlockFlushed * miniBlockSize +     blockFlushed * miniBlockNum +     (5.0 * blockFlushed);    return estimatedSize;}
9a69d020b8b66d966bd9e60bce69b38bd171f078d310ad817ba207bef2175feb
prepare
public static void prepare() throws IOException
{    Random random = new Random();    data = new int[100000 * blockSize];    for (int i = 0; i < data.length; i++) {        data[i] = random.nextInt(100) - 200;    }    ValuesWriter delta = new DeltaBinaryPackingValuesWriterForInteger(blockSize, miniBlockNum, 100, 20000, new DirectByteBufferAllocator());    ValuesWriter rle = new RunLengthBitPackingHybridValuesWriter(32, 100, 20000, new DirectByteBufferAllocator());    for (int i = 0; i < data.length; i++) {        delta.writeInteger(data[i]);        rle.writeInteger(data[i]);    }    deltaBytes = delta.getBytes().toByteArray();    rleBytes = rle.getBytes().toByteArray();}
fe39d1f5434f0fd58b4719e8f7497be02cc630b26e41e229eb07dd86d73493a9
readingDelta
public void readingDelta() throws IOException
{    for (int j = 0; j < 10; j++) {        DeltaBinaryPackingValuesReader reader = new DeltaBinaryPackingValuesReader();        readData(reader, deltaBytes);    }}
89bf4327c5341ad07a989cbf22b7cf6645e85bb637d90b05948f749bf7f4974b
readingRLE
public void readingRLE() throws IOException
{    for (int j = 0; j < 10; j++) {        ValuesReader reader = new RunLengthBitPackingHybridValuesReader(32);        readData(reader, rleBytes);    }}
2edccb33dceed8d7370bbe1116e00a64d1d9fdc38831086a8df4fb0d14f5c8ea
readData
private void readData(ValuesReader reader, byte[] deltaBytes) throws IOException
{    reader.initFromPage(data.length, ByteBufferInputStream.wrap(ByteBuffer.wrap(deltaBytes)));    for (int i = 0; i < data.length; i++) {        reader.readInteger();    }}
e71ebe6f480fd112b678468e5ac94a3055328dead9f89c0e0acdfeeb8d4a9b36
runWriteTest
protected void runWriteTest(ValuesWriter writer)
{    int pageCount = 10;    double avg = 0.0;    for (int i = 0; i < pageCount; i++) {        writer.reset();        long startTime = System.nanoTime();        for (int item : data) {            writer.writeInteger(item);        }        long endTime = System.nanoTime();        long duration = endTime - startTime;        avg += (double) duration / pageCount;    }    System.out.println("size is " + writer.getBytes().size());}
a0890758569f7e888da4e0477f5f279023cae57de24719a668ea043fc61d4953
prepare
public static void prepare()
{    Random random = new Random();    data = new int[10000 * blockSize];    for (int i = 0; i < data.length; i++) {        data[i] = random.nextInt(100) - 200;    }}
84b0ff30fccb763ab06933c6407523e741d4fd26fd08f882081c87c64c47662f
writeDeltaPackingTest
public void writeDeltaPackingTest()
{    DeltaBinaryPackingValuesWriter writer = new DeltaBinaryPackingValuesWriterForInteger(blockSize, miniBlockNum, 100, 20000, new DirectByteBufferAllocator());    runWriteTest(writer);}
24fb8ae9d1a5f3a888e64df9c83422ed282e284351b056382d50144cb6d8d147
writeRLETest
public void writeRLETest()
{    ValuesWriter writer = new RunLengthBitPackingHybridValuesWriter(32, 100, 20000, new DirectByteBufferAllocator());    runWriteTest(writer);}
bbb72590588514f771e532197f6eeff0e02963685fddc3f8d39a2c113b910855
writeDeltaPackingTest2
public void writeDeltaPackingTest2()
{    DeltaBinaryPackingValuesWriter writer = new DeltaBinaryPackingValuesWriterForInteger(blockSize, miniBlockNum, 100, 20000, new DirectByteBufferAllocator());    runWriteTest(writer);}
a0890758569f7e888da4e0477f5f279023cae57de24719a668ea043fc61d4953
prepare
public static void prepare()
{    Random random = new Random();    data = new int[100000 * blockSize];    for (int i = 0; i < data.length; i++) {        data[i] = random.nextInt(2) - 1;    }}
b2958b51ad364979d2cec0270b29e447855ce64423e84703b945935ef5db7d38
writeRLEWithSmallBitWidthTest
public void writeRLEWithSmallBitWidthTest()
{    ValuesWriter writer = new RunLengthBitPackingHybridValuesWriter(2, 100, 20000, new DirectByteBufferAllocator());    runWriteTest(writer);}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    blockSize = 128;    miniBlockNum = 4;    writer = new DeltaBinaryPackingValuesWriterForInteger(blockSize, miniBlockNum, 100, 200, new DirectByteBufferAllocator());    random = new Random(0);}
09218b0c6f5a36f425313943f03fb78ec8abde65734345271af95328f438d5db
miniBlockSizeShouldBeMultipleOf8
public void miniBlockSizeShouldBeMultipleOf8()
{    new DeltaBinaryPackingValuesWriterForInteger(1281, 4, 100, 100, new DirectByteBufferAllocator());}
09f0c0645c38d6055b777f3378d11ceb3d3fbe8d3309b8e122511673156ef3bd
shouldWriteWhenDataIsAlignedWithBlock
public void shouldWriteWhenDataIsAlignedWithBlock() throws IOException
{    int[] data = new int[5 * blockSize];    for (int i = 0; i < blockSize * 5; i++) {        data[i] = random.nextInt();    }    shouldWriteAndRead(data);}
0fee5c35b455b53bceee916627879d99e70693d1c4edcfc4282261a810390afd
shouldWriteAndReadWhenBlockIsNotFullyWritten
public void shouldWriteAndReadWhenBlockIsNotFullyWritten() throws IOException
{    int[] data = new int[blockSize - 3];    for (int i = 0; i < data.length; i++) {        data[i] = random.nextInt();    }    shouldWriteAndRead(data);}
6053b2a705b75cc71772252eae347ff3cd517171e644b9ffef8df195fe61093c
shouldWriteAndReadWhenAMiniBlockIsNotFullyWritten
public void shouldWriteAndReadWhenAMiniBlockIsNotFullyWritten() throws IOException
{    int miniBlockSize = blockSize / miniBlockNum;    int[] data = new int[miniBlockSize - 3];    for (int i = 0; i < data.length; i++) {        data[i] = random.nextInt();    }    shouldWriteAndRead(data);}
bc72165a89353048cd826bf16de7b805cc5fbd5039d6da738194e769dd772093
shouldWriteNegativeDeltas
public void shouldWriteNegativeDeltas() throws IOException
{    int[] data = new int[blockSize];    for (int i = 0; i < data.length; i++) {        data[i] = 10 - (i * 32 - random.nextInt(6));    }    shouldWriteAndRead(data);}
0e43ddf5c504cd0e31ecd3467cf944e651ff7ef81f63a4b6048f11755b9d3120
shouldWriteAndReadWhenDeltasAreSame
public void shouldWriteAndReadWhenDeltasAreSame() throws IOException
{    int[] data = new int[2 * blockSize];    for (int i = 0; i < blockSize; i++) {        data[i] = i * 32;    }    shouldWriteAndRead(data);}
80ef9b70472b9aaee1783f63ac8d4ae45293ec35160871708d459c4b2cd47c12
shouldWriteAndReadWhenValuesAreSame
public void shouldWriteAndReadWhenValuesAreSame() throws IOException
{    int[] data = new int[2 * blockSize];    for (int i = 0; i < blockSize; i++) {        data[i] = 3;    }    shouldWriteAndRead(data);}
18df7b848e9f70b2a797da2dc64caf39034f5c76c0ea994c0494a2322d6e8eff
shouldWriteWhenDeltaIs0ForEachBlock
public void shouldWriteWhenDeltaIs0ForEachBlock() throws IOException
{    int[] data = new int[5 * blockSize + 1];    for (int i = 0; i < data.length; i++) {        data[i] = (i - 1) / blockSize;    }    shouldWriteAndRead(data);}
335b48fca005ab0d9bbcb930d2be5a3065f43976fb8f54f99d5be6323b42d74a
shouldReadWriteWhenDataIsNotAlignedWithBlock
public void shouldReadWriteWhenDataIsNotAlignedWithBlock() throws IOException
{    int[] data = new int[5 * blockSize + 3];    for (int i = 0; i < data.length; i++) {        data[i] = random.nextInt(20) - 10;    }    shouldWriteAndRead(data);}
afe03b8b355e5ab95a40eb65060b4b5b3c736203daa94db2d56a2af8e696f423
shouldReadMaxMinValue
public void shouldReadMaxMinValue() throws IOException
{    int[] data = new int[10];    for (int i = 0; i < data.length; i++) {        if (i % 2 == 0) {            data[i] = Integer.MIN_VALUE;        } else {            data[i] = Integer.MAX_VALUE;        }    }    shouldWriteAndRead(data);}
b15ef75f37b3590cb68a1f0db5787b97371dc1f041c15a4166d009055343ff3a
shouldConsumePageDataInInitialization
public void shouldConsumePageDataInInitialization() throws IOException
{    int[] data = new int[2 * blockSize + 3];    for (int i = 0; i < data.length; i++) {        data[i] = i * 32;    }    writeData(data);    reader = new DeltaBinaryPackingValuesReader();    BytesInput bytes = writer.getBytes();    byte[] valueContent = bytes.toByteArray();    byte[] pageContent = new byte[valueContent.length * 10];    int contentOffsetInPage = 33;    System.arraycopy(valueContent, 0, pageContent, contentOffsetInPage, valueContent.length);        ByteBufferInputStream stream = ByteBufferInputStream.wrap(ByteBuffer.wrap(pageContent));    stream.skipFully(contentOffsetInPage);    reader.initFromPage(100, stream);    long offset = stream.position();    assertEquals(valueContent.length + contentOffsetInPage, offset);        for (int i : data) {        assertEquals(i, reader.readInteger());    }        reader = new DeltaBinaryPackingValuesReader();    reader.initFromPage(100, pageContent, contentOffsetInPage);    assertEquals(valueContent.length + contentOffsetInPage, reader.getNextOffset());    for (int i : data) {        assertEquals(i, reader.readInteger());    }}
1def2a8394a33e01bf99941628288a1c6b2c03125982a1eb7e865baaa9258f08
shouldThrowExceptionWhenReadMoreThanWritten
public void shouldThrowExceptionWhenReadMoreThanWritten() throws IOException
{    int[] data = new int[5 * blockSize + 1];    for (int i = 0; i < data.length; i++) {        data[i] = i * 32;    }    shouldWriteAndRead(data);    try {        reader.readInteger();    } catch (ParquetDecodingException e) {        assertEquals("no more value to read, total value count is " + data.length, e.getMessage());    }}
b4602e1407d1201fa916cff106ab3d5d55374d3e244191465e58a62e82e5d42e
shouldSkip
public void shouldSkip() throws IOException
{    int[] data = new int[5 * blockSize + 1];    for (int i = 0; i < data.length; i++) {        data[i] = i * 32;    }    writeData(data);    reader = new DeltaBinaryPackingValuesReader();    reader.initFromPage(100, writer.getBytes().toInputStream());    for (int i = 0; i < data.length; i++) {        if (i % 3 == 0) {            reader.skip();        } else {            assertEquals(i * 32, reader.readInteger());        }    }}
098b0716380af1f9c757d9aa4b3b458e331b40620424c4b3410e703b98cbca1a
shouldSkipN
public void shouldSkipN() throws IOException
{    int[] data = new int[5 * blockSize + 1];    for (int i = 0; i < data.length; i++) {        data[i] = i * 32;    }    writeData(data);    reader = new DeltaBinaryPackingValuesReader();    reader.initFromPage(100, writer.getBytes().toInputStream());    int skipCount;    for (int i = 0; i < data.length; i += skipCount + 1) {        skipCount = (data.length - i) / 2;        assertEquals(i * 32, reader.readInteger());        reader.skip(skipCount);    }}
198ef89141d5b75aeca4a702afad76ee9f622fa85ef0cd2e69e4232f7797a401
shouldReset
public void shouldReset() throws IOException
{    shouldReadWriteWhenDataIsNotAlignedWithBlock();    int[] data = new int[5 * blockSize];    for (int i = 0; i < blockSize * 5; i++) {        data[i] = i * 2;    }    writer.reset();    shouldWriteAndRead(data);}
49419db510bfe62b307616a60e3693801c0c043255376cdd66860793a0cf82b1
randomDataTest
public void randomDataTest() throws IOException
{    int maxSize = 1000;    int[] data = new int[maxSize];    for (int round = 0; round < 100000; round++) {        int size = random.nextInt(maxSize);        for (int i = 0; i < size; i++) {            data[i] = random.nextInt();        }        shouldReadAndWrite(data, size);        writer.reset();    }}
70c4006537a0f414d1b22a0da84bbbd645e282793816148b453355ed3f263b4d
shouldWriteAndRead
private void shouldWriteAndRead(int[] data) throws IOException
{    shouldReadAndWrite(data, data.length);}
a32b4a3b0e96f63c96a388de34983044409cb4ab4a15cc16c9c5df0d10f12eea
shouldReadAndWrite
private void shouldReadAndWrite(int[] data, int length) throws IOException
{    writeData(data, length);    reader = new DeltaBinaryPackingValuesReader();    byte[] page = writer.getBytes().toByteArray();    int miniBlockSize = blockSize / miniBlockNum;    double miniBlockFlushed = Math.ceil(((double) length - 1) / miniBlockSize);    double blockFlushed = Math.ceil(((double) length - 1) / blockSize);    double estimatedSize =     4 * 5 +     4 * miniBlockFlushed * miniBlockSize +     blockFlushed * miniBlockNum +     (5.0 * blockFlushed);    assertTrue(estimatedSize >= page.length);    reader.initFromPage(100, ByteBufferInputStream.wrap(ByteBuffer.wrap(page)));    for (int i = 0; i < length; i++) {        assertEquals(data[i], reader.readInteger());    }}
17a70f49f849aa450ea5f9ae01d86a96a8af641c1f91f55ae54a71131fb731b7
writeData
private void writeData(int[] data)
{    writeData(data, data.length);}
f7e5dffbe69064a0f3dda2f2194b5da30a2156e550e8dcac44742a1334fc0391
writeData
private void writeData(int[] data, int length)
{    for (int i = 0; i < length; i++) {        writer.writeInteger(data[i]);    }}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    blockSize = 128;    miniBlockNum = 4;    writer = new DeltaBinaryPackingValuesWriterForLong(blockSize, miniBlockNum, 100, 200, new DirectByteBufferAllocator());    random = new Random(0);}
09218b0c6f5a36f425313943f03fb78ec8abde65734345271af95328f438d5db
miniBlockSizeShouldBeMultipleOf8
public void miniBlockSizeShouldBeMultipleOf8()
{    new DeltaBinaryPackingValuesWriterForLong(1281, 4, 100, 100, new DirectByteBufferAllocator());}
09f0c0645c38d6055b777f3378d11ceb3d3fbe8d3309b8e122511673156ef3bd
shouldWriteWhenDataIsAlignedWithBlock
public void shouldWriteWhenDataIsAlignedWithBlock() throws IOException
{    long[] data = new long[5 * blockSize];    for (int i = 0; i < blockSize * 5; i++) {        data[i] = random.nextLong();    }    shouldWriteAndRead(data);}
0fee5c35b455b53bceee916627879d99e70693d1c4edcfc4282261a810390afd
shouldWriteAndReadWhenBlockIsNotFullyWritten
public void shouldWriteAndReadWhenBlockIsNotFullyWritten() throws IOException
{    long[] data = new long[blockSize - 3];    for (int i = 0; i < data.length; i++) {        data[i] = random.nextLong();    }    shouldWriteAndRead(data);}
6053b2a705b75cc71772252eae347ff3cd517171e644b9ffef8df195fe61093c
shouldWriteAndReadWhenAMiniBlockIsNotFullyWritten
public void shouldWriteAndReadWhenAMiniBlockIsNotFullyWritten() throws IOException
{    int miniBlockSize = blockSize / miniBlockNum;    long[] data = new long[miniBlockSize - 3];    for (int i = 0; i < data.length; i++) {        data[i] = random.nextLong();    }    shouldWriteAndRead(data);}
bc72165a89353048cd826bf16de7b805cc5fbd5039d6da738194e769dd772093
shouldWriteNegativeDeltas
public void shouldWriteNegativeDeltas() throws IOException
{    long[] data = new long[blockSize];    for (int i = 0; i < data.length; i++) {        data[i] = 10 - (i * 32 - random.nextInt(6));    }    shouldWriteAndRead(data);}
0e43ddf5c504cd0e31ecd3467cf944e651ff7ef81f63a4b6048f11755b9d3120
shouldWriteAndReadWhenDeltasAreSame
public void shouldWriteAndReadWhenDeltasAreSame() throws IOException
{    long[] data = new long[2 * blockSize];    for (int i = 0; i < blockSize; i++) {        data[i] = i * 32;    }    shouldWriteAndRead(data);}
80ef9b70472b9aaee1783f63ac8d4ae45293ec35160871708d459c4b2cd47c12
shouldWriteAndReadWhenValuesAreSame
public void shouldWriteAndReadWhenValuesAreSame() throws IOException
{    long[] data = new long[2 * blockSize];    for (int i = 0; i < blockSize; i++) {        data[i] = 3;    }    shouldWriteAndRead(data);}
18df7b848e9f70b2a797da2dc64caf39034f5c76c0ea994c0494a2322d6e8eff
shouldWriteWhenDeltaIs0ForEachBlock
public void shouldWriteWhenDeltaIs0ForEachBlock() throws IOException
{    long[] data = new long[5 * blockSize + 1];    for (int i = 0; i < data.length; i++) {        data[i] = (i - 1) / blockSize;    }    shouldWriteAndRead(data);}
335b48fca005ab0d9bbcb930d2be5a3065f43976fb8f54f99d5be6323b42d74a
shouldReadWriteWhenDataIsNotAlignedWithBlock
public void shouldReadWriteWhenDataIsNotAlignedWithBlock() throws IOException
{    long[] data = new long[5 * blockSize + 3];    for (int i = 0; i < data.length; i++) {        data[i] = random.nextInt(20) - 10;    }    shouldWriteAndRead(data);}
afe03b8b355e5ab95a40eb65060b4b5b3c736203daa94db2d56a2af8e696f423
shouldReadMaxMinValue
public void shouldReadMaxMinValue() throws IOException
{    long[] data = new long[10];    for (int i = 0; i < data.length; i++) {        if (i % 2 == 0) {            data[i] = Long.MIN_VALUE;        } else {            data[i] = Long.MAX_VALUE;        }    }    shouldWriteAndRead(data);}
f2aed674316a3adedfe070fa9904b83fe8b9c65fcb0460054d11115567570ded
shouldReturnCorrectOffsetAfterInitialization
public void shouldReturnCorrectOffsetAfterInitialization() throws IOException
{    long[] data = new long[2 * blockSize + 3];    for (int i = 0; i < data.length; i++) {        data[i] = i * 32;    }    writeData(data);    reader = new DeltaBinaryPackingValuesReader();    BytesInput bytes = writer.getBytes();    byte[] valueContent = bytes.toByteArray();    byte[] pageContent = new byte[valueContent.length * 10];    int contentOffsetInPage = 33;    System.arraycopy(valueContent, 0, pageContent, contentOffsetInPage, valueContent.length);        ByteBufferInputStream stream = ByteBufferInputStream.wrap(ByteBuffer.wrap(pageContent));    stream.skipFully(contentOffsetInPage);    reader.initFromPage(100, stream);    long offset = stream.position();    assertEquals(valueContent.length + contentOffsetInPage, offset);        for (long i : data) {        assertEquals(i, reader.readLong());    }        reader = new DeltaBinaryPackingValuesReader();    reader.initFromPage(100, pageContent, contentOffsetInPage);    assertEquals(valueContent.length + contentOffsetInPage, reader.getNextOffset());    for (long i : data) {        assertEquals(i, reader.readLong());    }}
1def2a8394a33e01bf99941628288a1c6b2c03125982a1eb7e865baaa9258f08
shouldThrowExceptionWhenReadMoreThanWritten
public void shouldThrowExceptionWhenReadMoreThanWritten() throws IOException
{    long[] data = new long[5 * blockSize + 1];    for (int i = 0; i < data.length; i++) {        data[i] = i * 32;    }    shouldWriteAndRead(data);    try {        reader.readLong();    } catch (ParquetDecodingException e) {        assertEquals("no more value to read, total value count is " + data.length, e.getMessage());    }}
b4602e1407d1201fa916cff106ab3d5d55374d3e244191465e58a62e82e5d42e
shouldSkip
public void shouldSkip() throws IOException
{    long[] data = new long[5 * blockSize + 1];    for (int i = 0; i < data.length; i++) {        data[i] = i * 32;    }    writeData(data);    reader = new DeltaBinaryPackingValuesReader();    reader.initFromPage(100, writer.getBytes().toInputStream());    for (int i = 0; i < data.length; i++) {        if (i % 3 == 0) {            reader.skip();        } else {            assertEquals(i * 32, reader.readLong());        }    }}
098b0716380af1f9c757d9aa4b3b458e331b40620424c4b3410e703b98cbca1a
shouldSkipN
public void shouldSkipN() throws IOException
{    long[] data = new long[5 * blockSize + 1];    for (int i = 0; i < data.length; i++) {        data[i] = i * 32;    }    writeData(data);    reader = new DeltaBinaryPackingValuesReader();    reader.initFromPage(100, writer.getBytes().toInputStream());    int skipCount;    for (int i = 0; i < data.length; i += skipCount + 1) {        skipCount = (data.length - i) / 2;        assertEquals(i * 32, reader.readLong());        reader.skip(skipCount);    }}
198ef89141d5b75aeca4a702afad76ee9f622fa85ef0cd2e69e4232f7797a401
shouldReset
public void shouldReset() throws IOException
{    shouldReadWriteWhenDataIsNotAlignedWithBlock();    long[] data = new long[5 * blockSize];    for (int i = 0; i < blockSize * 5; i++) {        data[i] = i * 2;    }    writer.reset();    shouldWriteAndRead(data);}
49419db510bfe62b307616a60e3693801c0c043255376cdd66860793a0cf82b1
randomDataTest
public void randomDataTest() throws IOException
{    int maxSize = 1000;    long[] data = new long[maxSize];    for (int round = 0; round < 100000; round++) {        int size = random.nextInt(maxSize);        for (int i = 0; i < size; i++) {            data[i] = random.nextLong();        }        shouldReadAndWrite(data, size);        writer.reset();    }}
371a618f77c0d1643806967593084b867600533beb8218e4cb248639e4616781
shouldWriteAndRead
private void shouldWriteAndRead(long[] data) throws IOException
{    shouldReadAndWrite(data, data.length);}
2638c8be329e3ca7aabf3a9534c0c7126f968173ab6eed93fc447b6271e106e6
shouldReadAndWrite
private void shouldReadAndWrite(long[] data, int length) throws IOException
{    writeData(data, length);    reader = new DeltaBinaryPackingValuesReader();    byte[] page = writer.getBytes().toByteArray();    int miniBlockSize = blockSize / miniBlockNum;    double miniBlockFlushed = Math.ceil(((double) length - 1) / miniBlockSize);    double blockFlushed = Math.ceil(((double) length - 1) / blockSize);    double estimatedSize =     3 * 5 + 1 * 10 +     8 * miniBlockFlushed * miniBlockSize +     blockFlushed * miniBlockNum +     (10.0 * blockFlushed);    assertTrue(estimatedSize >= page.length);    reader.initFromPage(100, ByteBufferInputStream.wrap(ByteBuffer.wrap(page)));    for (int i = 0; i < length; i++) {        assertEquals(data[i], reader.readLong());    }}
43a14f6784eefabd4aa0338f274b23902a7529aaf2aceddc18d90c7a89836a37
writeData
private void writeData(long[] data)
{    writeData(data, data.length);}
6dd847652fbf4b62fb08f5430121b1c9918c81ba5ed4a66c90e5860b5e7695a4
writeData
private void writeData(long[] data, int length)
{    for (int i = 0; i < length; i++) {        writer.writeLong(data[i]);    }}
d966f98f07b204c600168d9b8e262b26a431655777582eeead3d6ada4f18e7a3
benchmarkRandomStringsWithPlainValuesWriter
public void benchmarkRandomStringsWithPlainValuesWriter() throws IOException
{    PlainValuesWriter writer = new PlainValuesWriter(64 * 1024, 64 * 1024, new DirectByteBufferAllocator());    BinaryPlainValuesReader reader = new BinaryPlainValuesReader();    Utils.writeData(writer, values);    ByteBufferInputStream data = writer.getBytes().toInputStream();    Binary[] bin = Utils.readData(reader, data, values.length);    System.out.println("size " + data.position());}
b136ffa4bd0f3143381624a9dd766d6db0a71a6d0e4a6526f10b3c9b85248796
benchmarkRandomStringsWithDeltaLengthByteArrayValuesWriter
public void benchmarkRandomStringsWithDeltaLengthByteArrayValuesWriter() throws IOException
{    DeltaLengthByteArrayValuesWriter writer = new DeltaLengthByteArrayValuesWriter(64 * 1024, 64 * 1024, new DirectByteBufferAllocator());    DeltaLengthByteArrayValuesReader reader = new DeltaLengthByteArrayValuesReader();    Utils.writeData(writer, values);    ByteBufferInputStream data = writer.getBytes().toInputStream();    Binary[] bin = Utils.readData(reader, data, values.length);    System.out.println("size " + data.position());}
40c9923e66478e40c70172986e7593e2218fa33981e6911a2785f0a1452aac2e
getDeltaLengthByteArrayValuesWriter
private DeltaLengthByteArrayValuesWriter getDeltaLengthByteArrayValuesWriter()
{    return new DeltaLengthByteArrayValuesWriter(64 * 1024, 64 * 1024, new DirectByteBufferAllocator());}
1192794e64aea8c7b542cde309f1c91028423a3d7da09e14ee39125a501edbbd
testSerialization
public void testSerialization() throws IOException
{    DeltaLengthByteArrayValuesWriter writer = getDeltaLengthByteArrayValuesWriter();    DeltaLengthByteArrayValuesReader reader = new DeltaLengthByteArrayValuesReader();    Utils.writeData(writer, values);    Binary[] bin = Utils.readData(reader, writer.getBytes().toInputStream(), values.length);    for (int i = 0; i < bin.length; i++) {        Assert.assertEquals(Binary.fromString(values[i]), bin[i]);    }}
e1eccdc81398490d48c0ccfda5425783dc43ab6ff3f0bbf851959f7e2023cbb2
testRandomStrings
public void testRandomStrings() throws IOException
{    DeltaLengthByteArrayValuesWriter writer = getDeltaLengthByteArrayValuesWriter();    DeltaLengthByteArrayValuesReader reader = new DeltaLengthByteArrayValuesReader();    String[] values = Utils.getRandomStringSamples(1000, 32);    Utils.writeData(writer, values);    Binary[] bin = Utils.readData(reader, writer.getBytes().toInputStream(), values.length);    for (int i = 0; i < bin.length; i++) {        Assert.assertEquals(Binary.fromString(values[i]), bin[i]);    }}
5d846393971073e384cf8ed2b07fe9fdacee1da1612bd12d9b45493ba76465d5
testSkipWithRandomStrings
public void testSkipWithRandomStrings() throws IOException
{    DeltaLengthByteArrayValuesWriter writer = getDeltaLengthByteArrayValuesWriter();    DeltaLengthByteArrayValuesReader reader = new DeltaLengthByteArrayValuesReader();    String[] values = Utils.getRandomStringSamples(1000, 32);    Utils.writeData(writer, values);    reader.initFromPage(values.length, writer.getBytes().toInputStream());    for (int i = 0; i < values.length; i += 2) {        Assert.assertEquals(Binary.fromString(values[i]), reader.readBytes());        reader.skip();    }    reader = new DeltaLengthByteArrayValuesReader();    reader.initFromPage(values.length, writer.getBytes().toInputStream());    int skipCount;    for (int i = 0; i < values.length; i += skipCount + 1) {        skipCount = (values.length - i) / 2;        Assert.assertEquals(Binary.fromString(values[i]), reader.readBytes());        reader.skip(skipCount);    }}
5b8d7b0474071afd8957b354cb1ce7650b43012f935ddb80773cece07ea4df69
testLengths
public void testLengths() throws IOException
{    DeltaLengthByteArrayValuesWriter writer = getDeltaLengthByteArrayValuesWriter();    ValuesReader reader = new DeltaBinaryPackingValuesReader();    Utils.writeData(writer, values);    int[] bin = Utils.readInts(reader, writer.getBytes().toInputStream(), values.length);    for (int i = 0; i < bin.length; i++) {        Assert.assertEquals(values[i].length(), bin[i]);    }}
d966f98f07b204c600168d9b8e262b26a431655777582eeead3d6ada4f18e7a3
benchmarkRandomStringsWithPlainValuesWriter
public void benchmarkRandomStringsWithPlainValuesWriter() throws IOException
{    PlainValuesWriter writer = new PlainValuesWriter(64 * 1024, 64 * 1024, new DirectByteBufferAllocator());    BinaryPlainValuesReader reader = new BinaryPlainValuesReader();    Utils.writeData(writer, values);    ByteBufferInputStream data = writer.getBytes().toInputStream();    Binary[] bin = Utils.readData(reader, data, values.length);    System.out.println("size " + data.position());}
b136ffa4bd0f3143381624a9dd766d6db0a71a6d0e4a6526f10b3c9b85248796
benchmarkRandomStringsWithDeltaLengthByteArrayValuesWriter
public void benchmarkRandomStringsWithDeltaLengthByteArrayValuesWriter() throws IOException
{    DeltaByteArrayWriter writer = new DeltaByteArrayWriter(64 * 1024, 64 * 1024, new DirectByteBufferAllocator());    DeltaByteArrayReader reader = new DeltaByteArrayReader();    Utils.writeData(writer, values);    ByteBufferInputStream data = writer.getBytes().toInputStream();    Binary[] bin = Utils.readData(reader, data, values.length);    System.out.println("size " + data.position());}
f2f1f667441bbfe7ac6abb1469f693b6380f338836eafb7e978abaed14503fe7
benchmarkSortedStringsWithPlainValuesWriter
public void benchmarkSortedStringsWithPlainValuesWriter() throws IOException
{    PlainValuesWriter writer = new PlainValuesWriter(64 * 1024, 64 * 1024, new DirectByteBufferAllocator());    BinaryPlainValuesReader reader = new BinaryPlainValuesReader();    Utils.writeData(writer, sortedVals);    ByteBufferInputStream data = writer.getBytes().toInputStream();    Binary[] bin = Utils.readData(reader, data, values.length);    System.out.println("size " + data.position());}
764cc40b4cad2558a1f7e333db637bff999d1424f2044869e3c2dc003e8f74de
benchmarkSortedStringsWithDeltaLengthByteArrayValuesWriter
public void benchmarkSortedStringsWithDeltaLengthByteArrayValuesWriter() throws IOException
{    DeltaByteArrayWriter writer = new DeltaByteArrayWriter(64 * 1024, 64 * 1024, new DirectByteBufferAllocator());    DeltaByteArrayReader reader = new DeltaByteArrayReader();    Utils.writeData(writer, sortedVals);    ByteBufferInputStream data = writer.getBytes().toInputStream();    Binary[] bin = Utils.readData(reader, data, values.length);    System.out.println("size " + data.position());}
201ceaeec1d6c505857a11e3f4b3b5be8dba93fda85e1105434de73759a3825a
testSerialization
public void testSerialization() throws Exception
{    DeltaByteArrayWriter writer = new DeltaByteArrayWriter(64 * 1024, 64 * 1024, new DirectByteBufferAllocator());    DeltaByteArrayReader reader = new DeltaByteArrayReader();    assertReadWrite(writer, reader, values);}
39d1345b84b945631a2ead56228932fc07527f97cbfdba19d2ecb99a35af999e
testRandomStrings
public void testRandomStrings() throws Exception
{    DeltaByteArrayWriter writer = new DeltaByteArrayWriter(64 * 1024, 64 * 1024, new DirectByteBufferAllocator());    DeltaByteArrayReader reader = new DeltaByteArrayReader();    assertReadWrite(writer, reader, randvalues);}
46287ae2b0e1afe62de9aec410acca8c2e6cf647512dda3e82e691bc5c95f543
testRandomStringsWithSkip
public void testRandomStringsWithSkip() throws Exception
{    DeltaByteArrayWriter writer = new DeltaByteArrayWriter(64 * 1024, 64 * 1024, new DirectByteBufferAllocator());    DeltaByteArrayReader reader = new DeltaByteArrayReader();    assertReadWriteWithSkip(writer, reader, randvalues);}
6ba7215447e8489fa6a1c7023b3e50960996a0ff72f47c5439bd4cb1d9957321
testRandomStringsWithSkipN
public void testRandomStringsWithSkipN() throws Exception
{    DeltaByteArrayWriter writer = new DeltaByteArrayWriter(64 * 1024, 64 * 1024, new DirectByteBufferAllocator());    DeltaByteArrayReader reader = new DeltaByteArrayReader();    assertReadWriteWithSkipN(writer, reader, randvalues);}
5b8d7b0474071afd8957b354cb1ce7650b43012f935ddb80773cece07ea4df69
testLengths
public void testLengths() throws IOException
{    DeltaByteArrayWriter writer = new DeltaByteArrayWriter(64 * 1024, 64 * 1024, new DirectByteBufferAllocator());    ValuesReader reader = new DeltaBinaryPackingValuesReader();    Utils.writeData(writer, values);    ByteBufferInputStream data = writer.getBytes().toInputStream();    int[] bin = Utils.readInts(reader, data, values.length);        Assert.assertEquals(0, bin[0]);    Assert.assertEquals(7, bin[1]);    Assert.assertEquals(7, bin[2]);    reader = new DeltaBinaryPackingValuesReader();    bin = Utils.readInts(reader, data, values.length);        Assert.assertEquals(10, bin[0]);    Assert.assertEquals(0, bin[1]);    Assert.assertEquals(7, bin[2]);}
020334d1cdb5a0565ecd3e10bc39ee65b33e1588f55c4ac28c43603a593fa89c
assertReadWrite
private void assertReadWrite(DeltaByteArrayWriter writer, DeltaByteArrayReader reader, String[] vals) throws Exception
{    Utils.writeData(writer, vals);    Binary[] bin = Utils.readData(reader, writer.getBytes().toInputStream(), vals.length);    for (int i = 0; i < bin.length; i++) {        Assert.assertEquals(Binary.fromString(vals[i]), bin[i]);    }}
0a9d99ecc19360cc9c0a79b625d637ea0bf337bb08dddd847ad137f97a21d3de
assertReadWriteWithSkip
private void assertReadWriteWithSkip(DeltaByteArrayWriter writer, DeltaByteArrayReader reader, String[] vals) throws Exception
{    Utils.writeData(writer, vals);    reader.initFromPage(vals.length, writer.getBytes().toInputStream());    for (int i = 0; i < vals.length; i += 2) {        Assert.assertEquals(Binary.fromString(vals[i]), reader.readBytes());        reader.skip();    }}
09b7bea8fe4e78af5d8dec90b66b49eb85e837b4aecbec5156c3d3d60c106f2e
assertReadWriteWithSkipN
private void assertReadWriteWithSkipN(DeltaByteArrayWriter writer, DeltaByteArrayReader reader, String[] vals) throws Exception
{    Utils.writeData(writer, vals);    reader.initFromPage(vals.length, writer.getBytes().toInputStream());    int skipCount;    for (int i = 0; i < vals.length; i += skipCount + 1) {        skipCount = (vals.length - i) / 2;        Assert.assertEquals(Binary.fromString(vals[i]), reader.readBytes());        reader.skip(skipCount);    }}
a6b07dfb9d92f6d465645fb2d741d15f7b3bc61becbb09f5d4921eb461a2305d
testWriterReset
public void testWriterReset() throws Exception
{    DeltaByteArrayWriter writer = new DeltaByteArrayWriter(64 * 1024, 64 * 1024, new DirectByteBufferAllocator());    assertReadWrite(writer, new DeltaByteArrayReader(), values);    writer.reset();    assertReadWrite(writer, new DeltaByteArrayReader(), values);}
e1afccb4fd8d7b5f2659f296ea74ea82fb3f902a38bacfc71733b664e0cff010
testSmallList
public void testSmallList()
{    int testSize = IntList.INITIAL_SLAB_SIZE - 100;    doTestIntList(testSize, IntList.INITIAL_SLAB_SIZE);}
f30059238300205a0bd14586782fabb4b3f1fe637ddf800c4abd45891daccc6f
testListGreaterThanInitialSlabSize
public void testListGreaterThanInitialSlabSize()
{    int testSize = IntList.INITIAL_SLAB_SIZE + 100;    doTestIntList(testSize, IntList.INITIAL_SLAB_SIZE * 2);}
36fe4069d3b5469f6ea68994a812672a422d8ab76ae4a321165c1ecde7cc7b3f
testListGreaterThanMaxSlabSize
public void testListGreaterThanMaxSlabSize()
{    int testSize = IntList.MAX_SLAB_SIZE * 4 + 100;    doTestIntList(testSize, IntList.MAX_SLAB_SIZE);}
f40cc5033e270f704430b803f0e16bd53810c25193aad14e93fd4d92c350f204
doTestIntList
private void doTestIntList(int testSize, int expectedSlabSize)
{    IntList testList = new IntList();    populateList(testList, testSize);    verifyIteratorResults(testSize, testList);        Assert.assertEquals(expectedSlabSize, testList.getCurrentSlabSize());}
7463d1a331b102dff5d4a37590167a4e48faa7564364c09f6b4c17c47dafc8f2
populateList
private void populateList(IntList testList, int size)
{    for (int i = 0; i < size; i++) {        testList.add(i);    }}
c861edc3d51a7c003375656a4993ca525ab178d0bce552840c3e7cea245aa42b
verifyIteratorResults
private void verifyIteratorResults(int testSize, IntList testList)
{    IntList.IntIterator iterator = testList.iterator();    int expected = 0;    while (iterator.hasNext()) {        int val = iterator.next();        Assert.assertEquals(expected, val);        expected++;    }        Assert.assertEquals(testSize, expected);}
6cac07fa140a9854006ae8a1f842ee75c5a96e3d44f3db641e5bebd2948e7362
plainFallBack
private FallbackValuesWriter<I, PlainValuesWriter> plainFallBack(I dvw, int initialSize)
{    return FallbackValuesWriter.of(dvw, new PlainValuesWriter(initialSize, initialSize * 5, new DirectByteBufferAllocator()));}
55a9dd0adb7d9f3a29bf43f1fb97f4f401689bf7fc67792f5548f885f9d002f9
newPlainBinaryDictionaryValuesWriter
private FallbackValuesWriter<PlainBinaryDictionaryValuesWriter, PlainValuesWriter> newPlainBinaryDictionaryValuesWriter(int maxDictionaryByteSize, int initialSize)
{    return plainFallBack(new PlainBinaryDictionaryValuesWriter(maxDictionaryByteSize, PLAIN_DICTIONARY, PLAIN_DICTIONARY, new DirectByteBufferAllocator()), initialSize);}
7b40e1428e28db398db1e20df24e2d628620e7fcd6fcb0e229d052579631856c
newPlainLongDictionaryValuesWriter
private FallbackValuesWriter<PlainLongDictionaryValuesWriter, PlainValuesWriter> newPlainLongDictionaryValuesWriter(int maxDictionaryByteSize, int initialSize)
{    return plainFallBack(new PlainLongDictionaryValuesWriter(maxDictionaryByteSize, PLAIN_DICTIONARY, PLAIN_DICTIONARY, new DirectByteBufferAllocator()), initialSize);}
95fc3144dc07645c792d6f629926651b57c6ae9d145e02877c9dd4c100c01a11
newPlainIntegerDictionaryValuesWriter
private FallbackValuesWriter<PlainIntegerDictionaryValuesWriter, PlainValuesWriter> newPlainIntegerDictionaryValuesWriter(int maxDictionaryByteSize, int initialSize)
{    return plainFallBack(new PlainIntegerDictionaryValuesWriter(maxDictionaryByteSize, PLAIN_DICTIONARY, PLAIN_DICTIONARY, new DirectByteBufferAllocator()), initialSize);}
1217bff88dadc7229eeff16cb979c20ea150746786f6050e8a42a0e146611b7c
newPlainDoubleDictionaryValuesWriter
private FallbackValuesWriter<PlainDoubleDictionaryValuesWriter, PlainValuesWriter> newPlainDoubleDictionaryValuesWriter(int maxDictionaryByteSize, int initialSize)
{    return plainFallBack(new PlainDoubleDictionaryValuesWriter(maxDictionaryByteSize, PLAIN_DICTIONARY, PLAIN_DICTIONARY, new DirectByteBufferAllocator()), initialSize);}
872d58a601c6c4d762fe0e4f3cc4ebbab6cb8248659c807abdab743c22b5f1ed
newPlainFloatDictionaryValuesWriter
private FallbackValuesWriter<PlainFloatDictionaryValuesWriter, PlainValuesWriter> newPlainFloatDictionaryValuesWriter(int maxDictionaryByteSize, int initialSize)
{    return plainFallBack(new PlainFloatDictionaryValuesWriter(maxDictionaryByteSize, PLAIN_DICTIONARY, PLAIN_DICTIONARY, new DirectByteBufferAllocator()), initialSize);}
fe737dab6d323bd8ad76bee1a79a5cf7c2bc549e259d4b4ea4dd07961e43c3fd
testBinaryDictionary
public void testBinaryDictionary() throws IOException
{    int COUNT = 100;    ValuesWriter cw = newPlainBinaryDictionaryValuesWriter(200, 10000);    writeRepeated(COUNT, cw, "a");    BytesInput bytes1 = getBytesAndCheckEncoding(cw, PLAIN_DICTIONARY);    writeRepeated(COUNT, cw, "b");    BytesInput bytes2 = getBytesAndCheckEncoding(cw, PLAIN_DICTIONARY);        writeDistinct(COUNT, cw, "c");    BytesInput bytes3 = getBytesAndCheckEncoding(cw, PLAIN);    DictionaryValuesReader cr = initDicReader(cw, BINARY);    checkRepeated(COUNT, bytes1, cr, "a");    checkRepeated(COUNT, bytes2, cr, "b");    BinaryPlainValuesReader cr2 = new BinaryPlainValuesReader();    checkDistinct(COUNT, bytes3, cr2, "c");}
629084c034d2795953190f5d7cb2f62984932630bc9e557c083fc6e74efe6e7c
testSkipInBinaryDictionary
public void testSkipInBinaryDictionary() throws Exception
{    ValuesWriter cw = newPlainBinaryDictionaryValuesWriter(1000, 10000);    writeRepeated(100, cw, "a");    writeDistinct(100, cw, "b");    assertEquals(PLAIN_DICTIONARY, cw.getEncoding());        ByteBufferInputStream stream = cw.getBytes().toInputStream();    DictionaryValuesReader cr = initDicReader(cw, BINARY);    cr.initFromPage(200, stream);    for (int i = 0; i < 100; i += 2) {        assertEquals(Binary.fromString("a" + i % 10), cr.readBytes());        cr.skip();    }    int skipCount;    for (int i = 0; i < 100; i += skipCount + 1) {        skipCount = (100 - i) / 2;        assertEquals(Binary.fromString("b" + i), cr.readBytes());        cr.skip(skipCount);    }        writeDistinct(1000, cw, "c");    assertEquals(PLAIN, cw.getEncoding());        ValuesReader plainReader = new BinaryPlainValuesReader();    plainReader.initFromPage(1200, cw.getBytes().toInputStream());    plainReader.skip(200);    for (int i = 0; i < 100; i += 2) {        assertEquals("c" + i, plainReader.readBytes().toStringUsingUTF8());        plainReader.skip();    }    for (int i = 100; i < 1000; i += skipCount + 1) {        skipCount = (1000 - i) / 2;        assertEquals(Binary.fromString("c" + i), plainReader.readBytes());        plainReader.skip(skipCount);    }}
aa93588a71fdbfe8b5fd856461ef3794e71438728a7b74eccdfa734bfe36a7f5
testBinaryDictionaryFallBack
public void testBinaryDictionaryFallBack() throws IOException
{    int slabSize = 100;    int maxDictionaryByteSize = 50;    final ValuesWriter cw = newPlainBinaryDictionaryValuesWriter(maxDictionaryByteSize, slabSize);    int fallBackThreshold = maxDictionaryByteSize;    int dataSize = 0;    for (long i = 0; i < 100; i++) {        Binary binary = Binary.fromString("str" + i);        cw.writeBytes(binary);        dataSize += (binary.length() + 4);        if (dataSize < fallBackThreshold) {            assertEquals(PLAIN_DICTIONARY, cw.getEncoding());        } else {            assertEquals(PLAIN, cw.getEncoding());        }    }        ValuesReader reader = new BinaryPlainValuesReader();    reader.initFromPage(100, cw.getBytes().toInputStream());    for (long i = 0; i < 100; i++) {        assertEquals(Binary.fromString("str" + i), reader.readBytes());    }        cw.reset();    assertEquals(0, cw.getBufferedSize());}
4171cd0c65f6aeeeb9fb6475c8c9af683fe03a3b48e1b3aec8e660d2ce0df565
testBinaryDictionaryChangedValues
public void testBinaryDictionaryChangedValues() throws IOException
{    int COUNT = 100;    ValuesWriter cw = newPlainBinaryDictionaryValuesWriter(200, 10000);    writeRepeatedWithReuse(COUNT, cw, "a");    BytesInput bytes1 = getBytesAndCheckEncoding(cw, PLAIN_DICTIONARY);    writeRepeatedWithReuse(COUNT, cw, "b");    BytesInput bytes2 = getBytesAndCheckEncoding(cw, PLAIN_DICTIONARY);        writeDistinct(COUNT, cw, "c");    BytesInput bytes3 = getBytesAndCheckEncoding(cw, PLAIN);    DictionaryValuesReader cr = initDicReader(cw, BINARY);    checkRepeated(COUNT, bytes1, cr, "a");    checkRepeated(COUNT, bytes2, cr, "b");    BinaryPlainValuesReader cr2 = new BinaryPlainValuesReader();    checkDistinct(COUNT, bytes3, cr2, "c");}
903bdeb59b956ee1697a89b8dc7345803778d935e269d7281492d7f4348c24d2
testFirstPageFallBack
public void testFirstPageFallBack() throws IOException
{    int COUNT = 1000;    ValuesWriter cw = newPlainBinaryDictionaryValuesWriter(10000, 10000);    writeDistinct(COUNT, cw, "a");        BytesInput bytes1 = getBytesAndCheckEncoding(cw, PLAIN);    writeRepeated(COUNT, cw, "b");        BytesInput bytes2 = getBytesAndCheckEncoding(cw, PLAIN);    ValuesReader cr = new BinaryPlainValuesReader();    checkDistinct(COUNT, bytes1, cr, "a");    checkRepeated(COUNT, bytes2, cr, "b");}
12ede18eee8ad418b70fb0e0c847bd3aa0610792357bd7ce80c798d090920577
testSecondPageFallBack
public void testSecondPageFallBack() throws IOException
{    int COUNT = 1000;    ValuesWriter cw = newPlainBinaryDictionaryValuesWriter(1000, 10000);    writeRepeated(COUNT, cw, "a");    BytesInput bytes1 = getBytesAndCheckEncoding(cw, PLAIN_DICTIONARY);    writeDistinct(COUNT, cw, "b");        BytesInput bytes2 = getBytesAndCheckEncoding(cw, PLAIN);    writeRepeated(COUNT, cw, "a");        BytesInput bytes3 = getBytesAndCheckEncoding(cw, PLAIN);    ValuesReader cr = initDicReader(cw, BINARY);    checkRepeated(COUNT, bytes1, cr, "a");    cr = new BinaryPlainValuesReader();    checkDistinct(COUNT, bytes2, cr, "b");    checkRepeated(COUNT, bytes3, cr, "a");}
4e88f384c434984ead97fc9728a783344b61ac6897a510668232131152d3ac68
testLongDictionary
public void testLongDictionary() throws IOException
{    int COUNT = 1000;    int COUNT2 = 2000;    final FallbackValuesWriter<PlainLongDictionaryValuesWriter, PlainValuesWriter> cw = newPlainLongDictionaryValuesWriter(10000, 10000);    for (long i = 0; i < COUNT; i++) {        cw.writeLong(i % 50);    }    BytesInput bytes1 = getBytesAndCheckEncoding(cw, PLAIN_DICTIONARY);    assertEquals(50, cw.initialWriter.getDictionarySize());    for (long i = COUNT2; i > 0; i--) {        cw.writeLong(i % 50);    }    BytesInput bytes2 = getBytesAndCheckEncoding(cw, PLAIN_DICTIONARY);    assertEquals(50, cw.initialWriter.getDictionarySize());    DictionaryValuesReader cr = initDicReader(cw, PrimitiveTypeName.INT64);    cr.initFromPage(COUNT, bytes1.toInputStream());    for (long i = 0; i < COUNT; i++) {        long back = cr.readLong();        assertEquals(i % 50, back);    }    cr.initFromPage(COUNT2, bytes2.toInputStream());    for (long i = COUNT2; i > 0; i--) {        long back = cr.readLong();        assertEquals(i % 50, back);    }}
6fb58475b1ded704eaa404cd4d15f57fbcda763e5f644f62022caacd7dbf67d4
roundTripLong
private void roundTripLong(FallbackValuesWriter<PlainLongDictionaryValuesWriter, PlainValuesWriter> cw, ValuesReader reader, int maxDictionaryByteSize) throws IOException
{    int fallBackThreshold = maxDictionaryByteSize / 8;    for (long i = 0; i < 100; i++) {        cw.writeLong(i);        if (i < fallBackThreshold) {            assertEquals(cw.getEncoding(), PLAIN_DICTIONARY);        } else {            assertEquals(cw.getEncoding(), PLAIN);        }    }    reader.initFromPage(100, cw.getBytes().toInputStream());    for (long i = 0; i < 100; i++) {        assertEquals(i, reader.readLong());    }        reader.initFromPage(100, cw.getBytes().toInputStream());    for (int i = 0; i < 100; i += 2) {        assertEquals(i, reader.readLong());        reader.skip();    }        reader.initFromPage(100, cw.getBytes().toInputStream());    int skipCount;    for (int i = 0; i < 100; i += skipCount + 1) {        skipCount = (100 - i) / 2;        assertEquals(i, reader.readLong());        reader.skip(skipCount);    }}
da641ad58ca7756a59fe7386a65109567ea2ecec2d35c8feb5d2e65dd487ac69
testLongDictionaryFallBack
public void testLongDictionaryFallBack() throws IOException
{    int slabSize = 100;    int maxDictionaryByteSize = 50;    final FallbackValuesWriter<PlainLongDictionaryValuesWriter, PlainValuesWriter> cw = newPlainLongDictionaryValuesWriter(maxDictionaryByteSize, slabSize);        ValuesReader reader = new PlainValuesReader.LongPlainValuesReader();    roundTripLong(cw, reader, maxDictionaryByteSize);        cw.reset();    assertEquals(0, cw.getBufferedSize());    cw.resetDictionary();    roundTripLong(cw, reader, maxDictionaryByteSize);}
1e6fd10c3424a586fdfb05f536fbd4d44576666a1b83d83ca4a43857a23b5837
testDoubleDictionary
public void testDoubleDictionary() throws IOException
{    int COUNT = 1000;    int COUNT2 = 2000;    final FallbackValuesWriter<PlainDoubleDictionaryValuesWriter, PlainValuesWriter> cw = newPlainDoubleDictionaryValuesWriter(10000, 10000);    for (double i = 0; i < COUNT; i++) {        cw.writeDouble(i % 50);    }    BytesInput bytes1 = getBytesAndCheckEncoding(cw, PLAIN_DICTIONARY);    assertEquals(50, cw.initialWriter.getDictionarySize());    for (double i = COUNT2; i > 0; i--) {        cw.writeDouble(i % 50);    }    BytesInput bytes2 = getBytesAndCheckEncoding(cw, PLAIN_DICTIONARY);    assertEquals(50, cw.initialWriter.getDictionarySize());    final DictionaryValuesReader cr = initDicReader(cw, DOUBLE);    cr.initFromPage(COUNT, bytes1.toInputStream());    for (double i = 0; i < COUNT; i++) {        double back = cr.readDouble();        assertEquals(i % 50, back, 0.0);    }    cr.initFromPage(COUNT2, bytes2.toInputStream());    for (double i = COUNT2; i > 0; i--) {        double back = cr.readDouble();        assertEquals(i % 50, back, 0.0);    }}
ff2702786f30e61ed8a715199b7943a5ad6c268e5193808218b3b37047968a00
roundTripDouble
private void roundTripDouble(FallbackValuesWriter<PlainDoubleDictionaryValuesWriter, PlainValuesWriter> cw, ValuesReader reader, int maxDictionaryByteSize) throws IOException
{    int fallBackThreshold = maxDictionaryByteSize / 8;    for (double i = 0; i < 100; i++) {        cw.writeDouble(i);        if (i < fallBackThreshold) {            assertEquals(cw.getEncoding(), PLAIN_DICTIONARY);        } else {            assertEquals(cw.getEncoding(), PLAIN);        }    }    reader.initFromPage(100, cw.getBytes().toInputStream());    for (double i = 0; i < 100; i++) {        assertEquals(i, reader.readDouble(), 0.00001);    }        reader.initFromPage(100, cw.getBytes().toInputStream());    for (int i = 0; i < 100; i += 2) {        assertEquals(i, reader.readDouble(), 0.0);        reader.skip();    }        reader.initFromPage(100, cw.getBytes().toInputStream());    int skipCount;    for (int i = 0; i < 100; i += skipCount + 1) {        skipCount = (100 - i) / 2;        assertEquals(i, reader.readDouble(), 0.0);        reader.skip(skipCount);    }}
9befa54b1bed7e48326d16c6722ead9c954667c403b4e56e1164895dc682c820
testDoubleDictionaryFallBack
public void testDoubleDictionaryFallBack() throws IOException
{    int slabSize = 100;    int maxDictionaryByteSize = 50;    final FallbackValuesWriter<PlainDoubleDictionaryValuesWriter, PlainValuesWriter> cw = newPlainDoubleDictionaryValuesWriter(maxDictionaryByteSize, slabSize);        ValuesReader reader = new PlainValuesReader.DoublePlainValuesReader();    roundTripDouble(cw, reader, maxDictionaryByteSize);        cw.reset();    assertEquals(0, cw.getBufferedSize());    cw.resetDictionary();    roundTripDouble(cw, reader, maxDictionaryByteSize);}
b0e5969be79874d862363c88355faa6a75525eff6d801930360bba61e99c69ef
testIntDictionary
public void testIntDictionary() throws IOException
{    int COUNT = 2000;    int COUNT2 = 4000;    final FallbackValuesWriter<PlainIntegerDictionaryValuesWriter, PlainValuesWriter> cw = newPlainIntegerDictionaryValuesWriter(10000, 10000);    for (int i = 0; i < COUNT; i++) {        cw.writeInteger(i % 50);    }    BytesInput bytes1 = getBytesAndCheckEncoding(cw, PLAIN_DICTIONARY);    assertEquals(50, cw.initialWriter.getDictionarySize());    for (int i = COUNT2; i > 0; i--) {        cw.writeInteger(i % 50);    }    BytesInput bytes2 = getBytesAndCheckEncoding(cw, PLAIN_DICTIONARY);    assertEquals(50, cw.initialWriter.getDictionarySize());    DictionaryValuesReader cr = initDicReader(cw, INT32);    cr.initFromPage(COUNT, bytes1.toInputStream());    for (int i = 0; i < COUNT; i++) {        int back = cr.readInteger();        assertEquals(i % 50, back);    }    cr.initFromPage(COUNT2, bytes2.toInputStream());    for (int i = COUNT2; i > 0; i--) {        int back = cr.readInteger();        assertEquals(i % 50, back);    }}
fb5e7cebf7a86f904ff581808e87364eb3322d76111f5869674fe1432ed7cb85
roundTripInt
private void roundTripInt(FallbackValuesWriter<PlainIntegerDictionaryValuesWriter, PlainValuesWriter> cw, ValuesReader reader, int maxDictionaryByteSize) throws IOException
{    int fallBackThreshold = maxDictionaryByteSize / 4;    for (int i = 0; i < 100; i++) {        cw.writeInteger(i);        if (i < fallBackThreshold) {            assertEquals(cw.getEncoding(), PLAIN_DICTIONARY);        } else {            assertEquals(cw.getEncoding(), PLAIN);        }    }    reader.initFromPage(100, cw.getBytes().toInputStream());    for (int i = 0; i < 100; i++) {        assertEquals(i, reader.readInteger());    }        reader.initFromPage(100, cw.getBytes().toInputStream());    for (int i = 0; i < 100; i += 2) {        assertEquals(i, reader.readInteger());        reader.skip();    }        reader.initFromPage(100, cw.getBytes().toInputStream());    int skipCount;    for (int i = 0; i < 100; i += skipCount + 1) {        skipCount = (100 - i) / 2;        assertEquals(i, reader.readInteger());        reader.skip(skipCount);    }}
74c9913f5eb6f6f929b8155551b2c52f473167381e1eb4fbe2fa17ce047cae44
testIntDictionaryFallBack
public void testIntDictionaryFallBack() throws IOException
{    int slabSize = 100;    int maxDictionaryByteSize = 50;    final FallbackValuesWriter<PlainIntegerDictionaryValuesWriter, PlainValuesWriter> cw = newPlainIntegerDictionaryValuesWriter(maxDictionaryByteSize, slabSize);        ValuesReader reader = new PlainValuesReader.IntegerPlainValuesReader();    roundTripInt(cw, reader, maxDictionaryByteSize);        cw.reset();    assertEquals(0, cw.getBufferedSize());    cw.resetDictionary();    roundTripInt(cw, reader, maxDictionaryByteSize);}
a05046195934a6f3656e1b536f8da66d3df397938520b8d09a05f0efc6160d7a
testFloatDictionary
public void testFloatDictionary() throws IOException
{    int COUNT = 2000;    int COUNT2 = 4000;    final FallbackValuesWriter<PlainFloatDictionaryValuesWriter, PlainValuesWriter> cw = newPlainFloatDictionaryValuesWriter(10000, 10000);    for (float i = 0; i < COUNT; i++) {        cw.writeFloat(i % 50);    }    BytesInput bytes1 = getBytesAndCheckEncoding(cw, PLAIN_DICTIONARY);    assertEquals(50, cw.initialWriter.getDictionarySize());    for (float i = COUNT2; i > 0; i--) {        cw.writeFloat(i % 50);    }    BytesInput bytes2 = getBytesAndCheckEncoding(cw, PLAIN_DICTIONARY);    assertEquals(50, cw.initialWriter.getDictionarySize());    DictionaryValuesReader cr = initDicReader(cw, FLOAT);    cr.initFromPage(COUNT, bytes1.toInputStream());    for (float i = 0; i < COUNT; i++) {        float back = cr.readFloat();        assertEquals(i % 50, back, 0.0f);    }    cr.initFromPage(COUNT2, bytes2.toInputStream());    for (float i = COUNT2; i > 0; i--) {        float back = cr.readFloat();        assertEquals(i % 50, back, 0.0f);    }}
cf9ebeb900dd1f75c855fe72ed21588abe4b837c58cb12f08d219884dd34191b
roundTripFloat
private void roundTripFloat(FallbackValuesWriter<PlainFloatDictionaryValuesWriter, PlainValuesWriter> cw, ValuesReader reader, int maxDictionaryByteSize) throws IOException
{    int fallBackThreshold = maxDictionaryByteSize / 4;    for (float i = 0; i < 100; i++) {        cw.writeFloat(i);        if (i < fallBackThreshold) {            assertEquals(cw.getEncoding(), PLAIN_DICTIONARY);        } else {            assertEquals(cw.getEncoding(), PLAIN);        }    }    reader.initFromPage(100, cw.getBytes().toInputStream());    for (float i = 0; i < 100; i++) {        assertEquals(i, reader.readFloat(), 0.00001);    }        reader.initFromPage(100, cw.getBytes().toInputStream());    for (int i = 0; i < 100; i += 2) {        assertEquals(i, reader.readFloat(), 0.0f);        reader.skip();    }        reader.initFromPage(100, cw.getBytes().toInputStream());    int skipCount;    for (int i = 0; i < 100; i += skipCount + 1) {        skipCount = (100 - i) / 2;        assertEquals(i, reader.readFloat(), 0.0f);        reader.skip(skipCount);    }}
0a7188749ac768b784ed2955280ded677fbbf92962422b2ddf609d445ff141e7
testFloatDictionaryFallBack
public void testFloatDictionaryFallBack() throws IOException
{    int slabSize = 100;    int maxDictionaryByteSize = 50;    final FallbackValuesWriter<PlainFloatDictionaryValuesWriter, PlainValuesWriter> cw = newPlainFloatDictionaryValuesWriter(maxDictionaryByteSize, slabSize);        ValuesReader reader = new PlainValuesReader.FloatPlainValuesReader();    roundTripFloat(cw, reader, maxDictionaryByteSize);        cw.reset();    assertEquals(0, cw.getBufferedSize());    cw.resetDictionary();    roundTripFloat(cw, reader, maxDictionaryByteSize);}
712ab295b56c1e3ab0a0b00b0019513e901f921f8f469ef4fc1a3ed372567864
testZeroValues
public void testZeroValues() throws IOException
{    FallbackValuesWriter<PlainIntegerDictionaryValuesWriter, PlainValuesWriter> cw = newPlainIntegerDictionaryValuesWriter(100, 100);    cw.writeInteger(34);    cw.writeInteger(34);    getBytesAndCheckEncoding(cw, PLAIN_DICTIONARY);    DictionaryValuesReader reader = initDicReader(cw, INT32);            ByteBuffer bytes = ByteBuffer.wrap(new byte[] { 0x00, 0x01, 0x02, 0x03 });    ByteBufferInputStream stream = ByteBufferInputStream.wrap(bytes);    stream.skipFully(stream.available());    reader.initFromPage(100, stream);        reader = initDicReader(cw, INT32);    int offset = bytes.remaining();    reader.initFromPage(100, bytes, offset);}
fd8cf9c1f146804254209ddc3fb31f17c167cccf127ca3d17530003a061ff577
initDicReader
private DictionaryValuesReader initDicReader(ValuesWriter cw, PrimitiveTypeName type) throws IOException
{    final DictionaryPage dictionaryPage = cw.toDictPageAndClose().copy();    final ColumnDescriptor descriptor = new ColumnDescriptor(new String[] { "foo" }, type, 0, 0);    final Dictionary dictionary = PLAIN.initDictionary(descriptor, dictionaryPage);    final DictionaryValuesReader cr = new DictionaryValuesReader(dictionary);    return cr;}
8efe352062cd75242432248c30e5c389991389c2956fd66da5fb43ef2521bf8c
checkDistinct
private void checkDistinct(int COUNT, BytesInput bytes, ValuesReader cr, String prefix) throws IOException
{    cr.initFromPage(COUNT, bytes.toInputStream());    for (int i = 0; i < COUNT; i++) {        Assert.assertEquals(prefix + i, cr.readBytes().toStringUsingUTF8());    }}
652ff91b6442eb35618fd23e65b143778f4e1f542a40ad665df245471d12e032
checkRepeated
private void checkRepeated(int COUNT, BytesInput bytes, ValuesReader cr, String prefix) throws IOException
{    cr.initFromPage(COUNT, bytes.toInputStream());    for (int i = 0; i < COUNT; i++) {        Assert.assertEquals(prefix + i % 10, cr.readBytes().toStringUsingUTF8());    }}
fb7b966e6aeea9e29f53f726a7590e583e45422d2857bcbabb232c128d73a401
writeDistinct
private void writeDistinct(int COUNT, ValuesWriter cw, String prefix)
{    for (int i = 0; i < COUNT; i++) {        cw.writeBytes(Binary.fromString(prefix + i));    }}
b75f4fe866d6c5529a8e55bac1e5326a11e27f935ae03529c5772a957c773699
writeRepeated
private void writeRepeated(int COUNT, ValuesWriter cw, String prefix)
{    for (int i = 0; i < COUNT; i++) {        cw.writeBytes(Binary.fromString(prefix + i % 10));    }}
af15921a30488776761ac8a478c3caf214bd174513465536cf1bf4caebf42469
writeRepeatedWithReuse
private void writeRepeatedWithReuse(int COUNT, ValuesWriter cw, String prefix)
{    Binary reused = Binary.fromReusedByteArray((prefix + "0").getBytes(StandardCharsets.UTF_8));    for (int i = 0; i < COUNT; i++) {        Binary content = Binary.fromString(prefix + i % 10);        System.arraycopy(content.getBytesUnsafe(), 0, reused.getBytesUnsafe(), 0, reused.length());        cw.writeBytes(reused);    }}
5c14c6afd0f796476b7cc680d3b6ee6e361ccbec4e68b0072525df3ea5165442
getBytesAndCheckEncoding
private BytesInput getBytesAndCheckEncoding(ValuesWriter cw, Encoding encoding) throws IOException
{    BytesInput bytes = BytesInput.copy(cw.getBytes());    assertEquals(encoding, cw.getEncoding());    cw.reset();    return bytes;}
f7309da99bbf2f65fcc40413a07dc3116033c984e29575452667e56d8c0af727
testBoolean
public void testBoolean()
{    doTestValueWriter(PrimitiveTypeName.BOOLEAN, WriterVersion.PARQUET_1_0, true, BooleanPlainValuesWriter.class);}
3f8766046d0e6849e8e83d2abed6e128db92944dbfec5f44f097093ac15dd935
testBoolean_V2
public void testBoolean_V2()
{    doTestValueWriter(PrimitiveTypeName.BOOLEAN, WriterVersion.PARQUET_2_0, true, RunLengthBitPackingHybridValuesWriter.class);}
4e8ea2962222aea8f9f9cf36543b1b04e6e5bced698f6ab86d37ab0a17aceb0b
testFixedLenByteArray
public void testFixedLenByteArray()
{    doTestValueWriter(PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY, WriterVersion.PARQUET_1_0, true, FixedLenByteArrayPlainValuesWriter.class);}
0a330d9ce285f2dff1fe1b59c0b8be82545797b3642670544725534645c21dde
testFixedLenByteArray_V2
public void testFixedLenByteArray_V2()
{    doTestValueWriter(PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY, WriterVersion.PARQUET_2_0, true, DictionaryValuesWriter.class, DeltaByteArrayWriter.class);}
3a8abd2b4fec752ca05ff68eb4b806ec98672c26a8eaefa3ee6a4d97e8c8c1b1
testFixedLenByteArray_V2_NoDict
public void testFixedLenByteArray_V2_NoDict()
{    doTestValueWriter(PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY, WriterVersion.PARQUET_2_0, false, DeltaByteArrayWriter.class);}
0df33d62278751dafad149c380795c8df5f490e8b87ac24bdfd5e17cb7832db9
testBinary
public void testBinary()
{    doTestValueWriter(PrimitiveTypeName.BINARY, WriterVersion.PARQUET_1_0, true, PlainBinaryDictionaryValuesWriter.class, PlainValuesWriter.class);}
a22fb3bec4fc1e55382ced5f3357e7fb0844f53e1e5d40d4f7f79f87730d21d4
testBinary_NoDict
public void testBinary_NoDict()
{    doTestValueWriter(PrimitiveTypeName.BINARY, WriterVersion.PARQUET_1_0, false, PlainValuesWriter.class);}
1e4e237cca114e3dd30157080fa3b2440140670d1080e1ac8c5e85cba35fabc9
testBinary_V2
public void testBinary_V2()
{    doTestValueWriter(PrimitiveTypeName.BINARY, WriterVersion.PARQUET_2_0, true, PlainBinaryDictionaryValuesWriter.class, DeltaByteArrayWriter.class);}
bdc6e69039906dfbba0a6e06a99add0e8b6f6c90c6cc0644ec9149d72d938170
testBinary_V2_NoDict
public void testBinary_V2_NoDict()
{    doTestValueWriter(PrimitiveTypeName.BINARY, WriterVersion.PARQUET_2_0, false, DeltaByteArrayWriter.class);}
70ee06d0a6830a9c28886074e71c13740dbde2aefc9491caf5acfe4cff13c1e8
testInt32
public void testInt32()
{    doTestValueWriter(PrimitiveTypeName.INT32, WriterVersion.PARQUET_1_0, true, PlainIntegerDictionaryValuesWriter.class, PlainValuesWriter.class);}
c498410a41395f818f376e69fbb33ff97a2d7914870801a625fbbdcab47b7cf9
testInt32_NoDict
public void testInt32_NoDict()
{    doTestValueWriter(PrimitiveTypeName.INT32, WriterVersion.PARQUET_1_0, false, PlainValuesWriter.class);}
bcb6f5b142df8e95c17c7925f30bc91120bbc21914701b030197370764ac7e38
testInt32_V2
public void testInt32_V2()
{    doTestValueWriter(PrimitiveTypeName.INT32, WriterVersion.PARQUET_2_0, true, PlainIntegerDictionaryValuesWriter.class, DeltaBinaryPackingValuesWriter.class);}
2c99e1b6f4534aba35e2314e31726a8ba201a8326987483ea51cd06b593f2c2e
testInt32_V2_NoDict
public void testInt32_V2_NoDict()
{    doTestValueWriter(PrimitiveTypeName.INT32, WriterVersion.PARQUET_2_0, false, DeltaBinaryPackingValuesWriter.class);}
00963e5b428525ddb70df65a8b5bcd84ea9805e43d1c58be8a61b77c0441bc95
testInt64
public void testInt64()
{    doTestValueWriter(PrimitiveTypeName.INT64, WriterVersion.PARQUET_1_0, true, PlainLongDictionaryValuesWriter.class, PlainValuesWriter.class);}
10e980e2d4c85aa3be7bb441c34fbf3cea9c707664df81a268a4ed761d7a7f1e
testInt64_NoDict
public void testInt64_NoDict()
{    doTestValueWriter(PrimitiveTypeName.INT64, WriterVersion.PARQUET_1_0, false, PlainValuesWriter.class);}
8cd0de74cc79bc7b215858cea698bfd10c729fc4b5ff89173f82eaefbefe3af7
testInt64_V2
public void testInt64_V2()
{    doTestValueWriter(PrimitiveTypeName.INT64, WriterVersion.PARQUET_2_0, true, PlainLongDictionaryValuesWriter.class, DeltaBinaryPackingValuesWriterForLong.class);}
eb57b2665c9c6b007b9672f31f547256efd125a232a312ba002e90db1a2aa964
testInt64_V2_NoDict
public void testInt64_V2_NoDict()
{    doTestValueWriter(PrimitiveTypeName.INT64, WriterVersion.PARQUET_2_0, false, DeltaBinaryPackingValuesWriterForLong.class);}
6c36ea7de3ceca088a74d3d1d8add056acda9f4d58109f8221f7365b448711d8
testInt96
public void testInt96()
{    doTestValueWriter(PrimitiveTypeName.INT96, WriterVersion.PARQUET_1_0, true, PlainFixedLenArrayDictionaryValuesWriter.class, FixedLenByteArrayPlainValuesWriter.class);}
885bd5cc80ff845ef68ac476b2d2aa788497027c01ccfed15ffde036aa913c72
testInt96_NoDict
public void testInt96_NoDict()
{    doTestValueWriter(PrimitiveTypeName.INT96, WriterVersion.PARQUET_1_0, false, FixedLenByteArrayPlainValuesWriter.class);}
049320c4b1218213fc88209ed1d84682a0a44c99a2e37c8183e2208d565d4722
testInt96_V2
public void testInt96_V2()
{    doTestValueWriter(PrimitiveTypeName.INT96, WriterVersion.PARQUET_2_0, true, PlainFixedLenArrayDictionaryValuesWriter.class, FixedLenByteArrayPlainValuesWriter.class);}
71cbd921ec4c717be148df7372731d26865383971a605a1c27da5ffb5d541eb7
testInt96_V2_NoDict
public void testInt96_V2_NoDict()
{    doTestValueWriter(PrimitiveTypeName.INT96, WriterVersion.PARQUET_2_0, false, FixedLenByteArrayPlainValuesWriter.class);}
c5220b2b43a81a5c3331a84039191e97649ce2b6be86398d7d8981dd5be2fff4
testDouble
public void testDouble()
{    doTestValueWriter(PrimitiveTypeName.DOUBLE, WriterVersion.PARQUET_1_0, true, PlainDoubleDictionaryValuesWriter.class, PlainValuesWriter.class);}
1b7e1b262daffdbb5be7203e880c00d5321a0b330ad0c3cd38059ed55008eab6
testDouble_NoDict
public void testDouble_NoDict()
{    doTestValueWriter(PrimitiveTypeName.DOUBLE, WriterVersion.PARQUET_1_0, false, PlainValuesWriter.class);}
5aaa67f3397d137e5d9d21272bc1388cde50b20fdf0fe3122f99c442168bb1b4
testDouble_V2
public void testDouble_V2()
{    doTestValueWriter(PrimitiveTypeName.DOUBLE, WriterVersion.PARQUET_2_0, true, PlainDoubleDictionaryValuesWriter.class, PlainValuesWriter.class);}
58f07fc0d4d3107a779fc95c63e5732f51e94b0a1c25a9ce1ba35c6a184399ca
testDouble_V2_NoDict
public void testDouble_V2_NoDict()
{    doTestValueWriter(PrimitiveTypeName.DOUBLE, WriterVersion.PARQUET_2_0, false, PlainValuesWriter.class);}
305242112461377069be291ad69495bf1e1db9d018e7721514c34899670969e1
testFloat
public void testFloat()
{    doTestValueWriter(PrimitiveTypeName.FLOAT, WriterVersion.PARQUET_1_0, true, PlainFloatDictionaryValuesWriter.class, PlainValuesWriter.class);}
216f5c3c8b0d97721741ee25ba5e664a1f5d72646676efbc10a7a9c3c35afc30
testFloat_NoDict
public void testFloat_NoDict()
{    doTestValueWriter(PrimitiveTypeName.FLOAT, WriterVersion.PARQUET_1_0, false, PlainValuesWriter.class);}
057fe038ffe934b87f7554284cef843d5191cc652610f691420b0c858ab94569
testFloat_V2
public void testFloat_V2()
{    doTestValueWriter(PrimitiveTypeName.FLOAT, WriterVersion.PARQUET_2_0, true, PlainFloatDictionaryValuesWriter.class, PlainValuesWriter.class);}
6d7477a9749125b43a67bfb14aa0977b49c6985a561b10e463ab9d6c50328ea3
testFloat_V2_NoDict
public void testFloat_V2_NoDict()
{    doTestValueWriter(PrimitiveTypeName.FLOAT, WriterVersion.PARQUET_2_0, false, PlainValuesWriter.class);}
1ede082912c8c7348dd4163a7447fae537376b6cb0b766d91264a2ae8436fe1f
doTestValueWriter
private void doTestValueWriter(PrimitiveTypeName typeName, WriterVersion version, boolean enableDictionary, Class<? extends ValuesWriter> expectedValueWriterClass)
{    ColumnDescriptor mockPath = getMockColumn(typeName);    ValuesWriterFactory factory = getDefaultFactory(version, enableDictionary);    ValuesWriter writer = factory.newValuesWriter(mockPath);    validateWriterType(writer, expectedValueWriterClass);}
e2530a788d50e2a39b4905d39e8c33fc11aefa96d46eb26637b70c358a544913
doTestValueWriter
private void doTestValueWriter(PrimitiveTypeName typeName, WriterVersion version, boolean enableDictionary, Class<? extends ValuesWriter> initialValueWriterClass, Class<? extends ValuesWriter> fallbackValueWriterClass)
{    ColumnDescriptor mockPath = getMockColumn(typeName);    ValuesWriterFactory factory = getDefaultFactory(version, enableDictionary);    ValuesWriter writer = factory.newValuesWriter(mockPath);    validateFallbackWriter(writer, initialValueWriterClass, fallbackValueWriterClass);}
418bcf81422660cdf7888d6d55172e788f1aab9e7cac8120cd0d225b0f814d48
getMockColumn
private ColumnDescriptor getMockColumn(PrimitiveTypeName typeName)
{    ColumnDescriptor mockPath = mock(ColumnDescriptor.class);    when(mockPath.getType()).thenReturn(typeName);    return mockPath;}
60dbc86360e0e9d02d0014fe707018ab0073571959c94c1e07afa7f2c840b3b9
getDefaultFactory
private ValuesWriterFactory getDefaultFactory(WriterVersion writerVersion, boolean enableDictionary)
{    ValuesWriterFactory factory = new DefaultValuesWriterFactory();    ParquetProperties.builder().withDictionaryEncoding(enableDictionary).withWriterVersion(writerVersion).withValuesWriterFactory(factory).build();    return factory;}
dc82f982677a826da2b7d840e4e5e8e35d98c214203c705bcc8086b725142999
validateWriterType
private void validateWriterType(ValuesWriter writer, Class<? extends ValuesWriter> valuesWriterClass)
{    assertTrue("Not instance of: " + valuesWriterClass.getName(), valuesWriterClass.isInstance(writer));}
73e182a6e2c5411fffda2c8bb5746835996d9b56375a275f44ae6a7d1ed546cf
validateFallbackWriter
private void validateFallbackWriter(ValuesWriter writer, Class<? extends ValuesWriter> initialWriterClass, Class<? extends ValuesWriter> fallbackWriterClass)
{    validateWriterType(writer, FallbackValuesWriter.class);    FallbackValuesWriter wr = (FallbackValuesWriter) writer;    validateWriterType(wr.initialWriter, initialWriterClass);    validateWriterType(wr.fallBackWriter, fallbackWriterClass);}
1abad2790b4f2c9262b2f7a47a86bd3cd572f036e004b12868c20124a17d1e0d
get
public String get(int len)
{    StringBuffer out = new StringBuffer();    while (out.length() < len) {        int idx = Math.abs((rand.nextInt() % alphanumeric.length));        out.append(alphanumeric[idx]);    }    return out.toString();}
2bd356d79533484174c68b56f2b82620afd0b48443eb19d07baf019908e07615
alphanumeric
private char[] alphanumeric()
{    StringBuffer buf = new StringBuffer(128);        for (int i = 48; i <= 57; i++) buf.append((char) i);        for (int i = 65; i <= 90; i++) buf.append((char) i);        for (int i = 97; i <= 122; i++) buf.append((char) i);    return buf.toString().toCharArray();}
bf2e622fe3f60ed69276e4e0fc4d2e90459247a448298a7d381d179e1878bba3
integrationTest
public void integrationTest() throws Exception
{    for (int i = 0; i <= 32; i++) {        doIntegrationTest(i);    }}
7714d0536bcf6b92d778d2653dc3ce63c5bfadd5ac523a8a364060c2f25ac2ad
doIntegrationTest
private void doIntegrationTest(int bitWidth) throws Exception
{    long modValue = 1L << bitWidth;    RunLengthBitPackingHybridEncoder encoder = new RunLengthBitPackingHybridEncoder(bitWidth, 1000, 64000, new DirectByteBufferAllocator());    int numValues = 0;    for (int i = 0; i < 100; i++) {        encoder.writeInt((int) (i % modValue));    }    numValues += 100;    for (int i = 0; i < 100; i++) {        encoder.writeInt((int) (77 % modValue));    }    numValues += 100;    for (int i = 0; i < 100; i++) {        encoder.writeInt((int) (88 % modValue));    }    numValues += 100;    for (int i = 0; i < 1000; i++) {        encoder.writeInt((int) (i % modValue));        encoder.writeInt((int) (i % modValue));        encoder.writeInt((int) (i % modValue));    }    numValues += 3000;    for (int i = 0; i < 1000; i++) {        encoder.writeInt((int) (17 % modValue));    }    numValues += 1000;    ByteBuffer encodedBytes = encoder.toBytes().toByteBuffer();    ByteBufferInputStream in = ByteBufferInputStream.wrap(encodedBytes);    RunLengthBitPackingHybridDecoder decoder = new RunLengthBitPackingHybridDecoder(bitWidth, in);    for (int i = 0; i < 100; i++) {        assertEquals(i % modValue, decoder.readInt());    }    for (int i = 0; i < 100; i++) {        assertEquals(77 % modValue, decoder.readInt());    }    for (int i = 0; i < 100; i++) {        assertEquals(88 % modValue, decoder.readInt());    }    for (int i = 0; i < 1000; i++) {        assertEquals(i % modValue, decoder.readInt());        assertEquals(i % modValue, decoder.readInt());        assertEquals(i % modValue, decoder.readInt());    }    for (int i = 0; i < 1000; i++) {        assertEquals(17 % modValue, decoder.readInt());    }}
b298880bdf4afc16594001c895cbebcb24e543da127805a100512a0d2105a2fc
getRunLengthBitPackingHybridEncoder
private RunLengthBitPackingHybridEncoder getRunLengthBitPackingHybridEncoder()
{    return getRunLengthBitPackingHybridEncoder(3, 5, 10);}
bd426bf9a913f21b522db58a70d8997acf2e34cfde4f69742eeb5f7a2b5dfd29
getRunLengthBitPackingHybridEncoder
private RunLengthBitPackingHybridEncoder getRunLengthBitPackingHybridEncoder(int bitWidth, int initialCapacity, int pageSize)
{    return new RunLengthBitPackingHybridEncoder(bitWidth, initialCapacity, pageSize, new DirectByteBufferAllocator());}
3dadb204ad36bc97472ad8fff6cb7ce7f0f91f238a1709e8ead62adf61f37ef3
testRLEOnly
public void testRLEOnly() throws Exception
{    RunLengthBitPackingHybridEncoder encoder = getRunLengthBitPackingHybridEncoder();    for (int i = 0; i < 100; i++) {        encoder.writeInt(4);    }    for (int i = 0; i < 100; i++) {        encoder.writeInt(5);    }    ByteArrayInputStream is = new ByteArrayInputStream(encoder.toBytes().toByteArray());        assertEquals(200, BytesUtils.readUnsignedVarInt(is));        assertEquals(4, BytesUtils.readIntLittleEndianOnOneByte(is));        assertEquals(200, BytesUtils.readUnsignedVarInt(is));        assertEquals(5, BytesUtils.readIntLittleEndianOnOneByte(is));        assertEquals(-1, is.read());}
b3dc461473b8065f5c27eb00ef988964dce3c51cccfefc5bb3c3c22b81ccd1ff
testRepeatedZeros
public void testRepeatedZeros() throws Exception
{                RunLengthBitPackingHybridEncoder encoder = getRunLengthBitPackingHybridEncoder();    for (int i = 0; i < 10; i++) {        encoder.writeInt(0);    }    ByteArrayInputStream is = new ByteArrayInputStream(encoder.toBytes().toByteArray());        assertEquals(20, BytesUtils.readUnsignedVarInt(is));        assertEquals(0, BytesUtils.readIntLittleEndianOnOneByte(is));        assertEquals(-1, is.read());}
7f12061b349b3d40cd6c44220e61037c9cb85a329797e5bd927fbadd553540d2
testBitWidthZero
public void testBitWidthZero() throws Exception
{    RunLengthBitPackingHybridEncoder encoder = getRunLengthBitPackingHybridEncoder(0, 5, 10);    for (int i = 0; i < 10; i++) {        encoder.writeInt(0);    }    ByteArrayInputStream is = new ByteArrayInputStream(encoder.toBytes().toByteArray());        assertEquals(20, BytesUtils.readUnsignedVarInt(is));        assertEquals(-1, is.read());}
625f3532ccaa4ed09ab6f78b63c51549bb6773d1872da8fd12b3ec0249d0ab57
testBitPackingOnly
public void testBitPackingOnly() throws Exception
{    RunLengthBitPackingHybridEncoder encoder = getRunLengthBitPackingHybridEncoder();    for (int i = 0; i < 100; i++) {        encoder.writeInt(i % 3);    }    ByteArrayInputStream is = new ByteArrayInputStream(encoder.toBytes().toByteArray());        assertEquals(27, BytesUtils.readUnsignedVarInt(is));    List<Integer> values = unpack(3, 104, is);    for (int i = 0; i < 100; i++) {        assertEquals(i % 3, (int) values.get(i));    }        assertEquals(-1, is.read());}
5861f71398f1810c9948e5a04ed0aba7a307b2b5cd3e2c2efd8fd1cfaa1538cc
testBitPackingOverflow
public void testBitPackingOverflow() throws Exception
{    RunLengthBitPackingHybridEncoder encoder = getRunLengthBitPackingHybridEncoder();    for (int i = 0; i < 1000; i++) {        encoder.writeInt(i % 3);    }    ByteArrayInputStream is = new ByteArrayInputStream(encoder.toBytes().toByteArray());                assertEquals(127, BytesUtils.readUnsignedVarInt(is));    List<Integer> values = unpack(3, 504, is);    for (int i = 0; i < 504; i++) {        assertEquals(i % 3, (int) values.get(i));    }            assertEquals(125, BytesUtils.readUnsignedVarInt(is));    values = unpack(3, 496, is);    for (int i = 0; i < 496; i++) {        assertEquals((i + 504) % 3, (int) values.get(i));    }        assertEquals(-1, is.read());}
ec50874057dd84927248c07a6069ad760ac6bfb4cbded026d829f2257362bede
testTransitionFromBitPackingToRle
public void testTransitionFromBitPackingToRle() throws Exception
{    RunLengthBitPackingHybridEncoder encoder = getRunLengthBitPackingHybridEncoder();        encoder.writeInt(0);    encoder.writeInt(1);    encoder.writeInt(0);    encoder.writeInt(1);    encoder.writeInt(0);        encoder.writeInt(2);    encoder.writeInt(2);    encoder.writeInt(2);        for (int i = 0; i < 100; i++) {        encoder.writeInt(2);    }    ByteArrayInputStream is = new ByteArrayInputStream(encoder.toBytes().toByteArray());        assertEquals(3, BytesUtils.readUnsignedVarInt(is));    List<Integer> values = unpack(3, 8, is);    assertEquals(Arrays.asList(0, 1, 0, 1, 0, 2, 2, 2), values);        assertEquals(200, BytesUtils.readUnsignedVarInt(is));        assertEquals(2, BytesUtils.readIntLittleEndianOnOneByte(is));        assertEquals(-1, is.read());}
998ece92b424cfae142b46bf2796f4962006eccda4fc0fccab8f26c3b33b3989
testPaddingZerosOnUnfinishedBitPackedRuns
public void testPaddingZerosOnUnfinishedBitPackedRuns() throws Exception
{    RunLengthBitPackingHybridEncoder encoder = getRunLengthBitPackingHybridEncoder(5, 5, 10);    for (int i = 0; i < 9; i++) {        encoder.writeInt(i + 1);    }    ByteArrayInputStream is = new ByteArrayInputStream(encoder.toBytes().toByteArray());        assertEquals(5, BytesUtils.readUnsignedVarInt(is));    List<Integer> values = unpack(5, 16, is);    assertEquals(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0), values);    assertEquals(-1, is.read());}
c07f846a2b9b5df404c08265f6e8842ff4c7a502a73b1f32e14594f24aa99553
testSwitchingModes
public void testSwitchingModes() throws Exception
{    RunLengthBitPackingHybridEncoder encoder = getRunLengthBitPackingHybridEncoder(9, 100, 1000);        for (int i = 0; i < 25; i++) {        encoder.writeInt(17);    }        for (int i = 0; i < 7; i++) {        encoder.writeInt(7);    }    encoder.writeInt(8);    encoder.writeInt(9);    encoder.writeInt(10);        for (int i = 0; i < 25; i++) {        encoder.writeInt(6);    }        for (int i = 0; i < 8; i++) {        encoder.writeInt(5);    }    ByteArrayInputStream is = new ByteArrayInputStream(encoder.toBytes().toByteArray());        assertEquals(50, BytesUtils.readUnsignedVarInt(is));        assertEquals(17, BytesUtils.readIntLittleEndianOnTwoBytes(is));        assertEquals(5, BytesUtils.readUnsignedVarInt(is));    List<Integer> values = unpack(9, 16, is);    int v = 0;    for (int i = 0; i < 7; i++) {        assertEquals(7, (int) values.get(v));        v++;    }    assertEquals(8, (int) values.get(v++));    assertEquals(9, (int) values.get(v++));    assertEquals(10, (int) values.get(v++));    for (int i = 0; i < 6; i++) {        assertEquals(6, (int) values.get(v));        v++;    }        assertEquals(38, BytesUtils.readUnsignedVarInt(is));        assertEquals(6, BytesUtils.readIntLittleEndianOnTwoBytes(is));        assertEquals(16, BytesUtils.readUnsignedVarInt(is));        assertEquals(5, BytesUtils.readIntLittleEndianOnTwoBytes(is));        assertEquals(-1, is.read());}
dca539618a9596de2124dd12b7d564a5da62438f113f69bf9889a2f48e1ed0df
testGroupBoundary
public void testGroupBoundary() throws Exception
{    byte[] bytes = new byte[2];            bytes[0] = (1 << 1) | 1;    bytes[1] = (1 << 0) | (2 << 2) | (3 << 4);    ByteArrayInputStream stream = new ByteArrayInputStream(bytes);    RunLengthBitPackingHybridDecoder decoder = new RunLengthBitPackingHybridDecoder(2, stream);    assertEquals(decoder.readInt(), 1);    assertEquals(decoder.readInt(), 2);    assertEquals(decoder.readInt(), 3);    assertEquals(stream.available(), 0);}
e8981ef77b0ce79740951056773bbbe3e1157b8eb6fbe75e559449e5bc2194c9
unpack
private static List<Integer> unpack(int bitWidth, int numValues, ByteArrayInputStream is) throws Exception
{    BytePacker packer = Packer.LITTLE_ENDIAN.newBytePacker(bitWidth);    int[] unpacked = new int[8];    byte[] next8Values = new byte[bitWidth];    List<Integer> values = new ArrayList<Integer>(numValues);    while (values.size() < numValues) {        for (int i = 0; i < bitWidth; i++) {            next8Values[i] = (byte) is.read();        }        packer.unpack8Values(next8Values, 0, unpacked, 0);        for (int v = 0; v < 8; v++) {            values.add(unpacked[v]);        }    }    return values;}
895e92fa2273cdf5e5c97c44b286ea867f7a7e0a6106c85286a4176e76e78d9d
skip
public void skip()
{}
a43f6be0a01938ffb60095238f70c76e65b93f404fae492ff841e341ac9b8c3e
initFromPage
public void initFromPage(int valueCount, ByteBuffer page, int offset) throws IOException
{    data = new byte[valueCount];    ByteBuffer buffer = page.duplicate();    buffer.position(offset);    buffer.get(data);}
7d2c831943b734d6ce3fe2b51c47f1474ae26498095516f6cc1d0638020d4a18
assertPageEquals
public void assertPageEquals(String expected)
{    Assert.assertEquals(expected, new String(data));}
895e92fa2273cdf5e5c97c44b286ea867f7a7e0a6106c85286a4176e76e78d9d
skip
public void skip()
{}
d4b7df18ce82f584ed081b22220ce7c9d747c434184149ef37e15f72accbd8a5
readBytes
public Binary readBytes()
{    return Binary.fromConstantByteArray(data);}
2b6156253e204e0ba2979426840b1616fbe0cc8fa7774a630596196dd35cc237
initFromPage
public void initFromPage(int valueCount, ByteBufferInputStream in) throws IOException
{    data = new byte[valueCount];    int off = 0;    int len = valueCount;    int read;    while ((read = in.read(data, off, len)) != -1 && len > 0) {        off += read;        len -= read;    }}
895e92fa2273cdf5e5c97c44b286ea867f7a7e0a6106c85286a4176e76e78d9d
skip
public void skip()
{}
d4b7df18ce82f584ed081b22220ce7c9d747c434184149ef37e15f72accbd8a5
readBytes
public Binary readBytes()
{    return Binary.fromConstantByteArray(data);}
93d6959ac7b3cbeb47b039f291013c2dc4245fdb4d6e9ea50800233805d2826a
testInvalidValuesReaderImpl
public void testInvalidValuesReaderImpl() throws IOException
{    ValuesReader reader = new InvalidValuesReaderImpl();    try {        validateWithByteArray(reader);        fail("An UnsupportedOperationException should have been thrown");    } catch (UnsupportedOperationException e) {    }    try {        validateWithByteBuffer(reader);        fail("An UnsupportedOperationException should have been thrown");    } catch (UnsupportedOperationException e) {    }    try {        validateWithByteBufferInputStream(reader);        fail("An UnsupportedOperationException should have been thrown");    } catch (UnsupportedOperationException e) {    }}
890a1bbdbd59722a8d5bdd24af500741768810ddb4a814c25b5ea234ee7a8ab7
testByteBufferValuesReaderImpl
public void testByteBufferValuesReaderImpl() throws IOException
{    ValuesReader reader = new ByteBufferValuesReaderImpl();    validateWithByteArray(reader);    validateWithByteBuffer(reader);    validateWithByteBufferInputStream(reader);}
7c3139b57c1fe739dc2e2aa781d0661a08eefc1202f3de8a384fdca78c3a61cb
testByteBufferInputStreamValuesReaderImpl
public void testByteBufferInputStreamValuesReaderImpl() throws IOException
{    ValuesReader reader = new ByteBufferInputStreamValuesReaderImpl();    validateWithByteArray(reader);    validateWithByteBuffer(reader);    validateWithByteBufferInputStream(reader);}
96563ee1f37e133deb5902ab79f029e2bad550e3dec6588a4af275a851d65c9e
validateWithByteArray
private void validateWithByteArray(ValuesReader reader) throws IOException
{    reader.initFromPage(25, "==padding==The expected page content".getBytes(), 11);    assertEquals("The expected page content", reader.readBytes().toStringUsingUTF8());}
48ed1ee92f9c2b10883d1526feed3947e8c329e332c8eef24f2c797df265f0d1
validateWithByteBuffer
private void validateWithByteBuffer(ValuesReader reader) throws IOException
{    reader.initFromPage(25, ByteBuffer.wrap("==padding==The expected page content".getBytes()), 11);    assertEquals("The expected page content", reader.readBytes().toStringUsingUTF8());}
40947a11adb9addcb00f69b52d856c0b89579091bae94d50be389194aa103758
validateWithByteBufferInputStream
private void validateWithByteBufferInputStream(ValuesReader reader) throws IOException
{    ByteBufferInputStream bbis = ByteBufferInputStream.wrap(ByteBuffer.wrap("==padding==".getBytes()), ByteBuffer.wrap("The expected ".getBytes()), ByteBuffer.wrap("page content".getBytes()));    bbis.skipFully(11);    reader.initFromPage(25, bbis);    assertEquals("The expected page content", reader.readBytes().toStringUsingUTF8());}
8f5fe522c834b75afdee4557f8a4d7d735d6bff20fdb95a92db68fe05511ee99
getRandomStringSamples
public static String[] getRandomStringSamples(int numSamples, int maxLength)
{    String[] samples = new String[numSamples];    for (int i = 0; i < numSamples; i++) {        int len = randomLen.nextInt(maxLength);        samples[i] = randomStr.get(len);    }    return samples;}
11d70daca9be76e3a2a3aa120ace2dcc925ed3ba0ad05cb796a92f1e6bea1354
writeInts
public static void writeInts(ValuesWriter writer, int[] ints) throws IOException
{    for (int i = 0; i < ints.length; i++) {        writer.writeInteger(ints[i]);    }}
9666a3e95fb1f68b54984f4780beb35de0157caf8400fd08a1714be1314fcd89
writeData
public static void writeData(ValuesWriter writer, String[] strings) throws IOException
{    for (int i = 0; i < strings.length; i++) {        writer.writeBytes(Binary.fromString(strings[i]));    }}
77dde39bf8d5eea6970d86932d4d0f25e22009b004a902e042c702a76ef566f8
readData
public static Binary[] readData(ValuesReader reader, ByteBufferInputStream stream, int length) throws IOException
{    Binary[] bins = new Binary[length];    reader.initFromPage(length, stream);    for (int i = 0; i < length; i++) {        bins[i] = reader.readBytes();    }    return bins;}
762417fe48e09c8e35fb32b126e90a6ee5a992d21f53ec13b777090795560ad7
readInts
public static int[] readInts(ValuesReader reader, ByteBufferInputStream stream, int length) throws IOException
{    int[] ints = new int[length];    reader.initFromPage(length, stream);    for (int i = 0; i < length; i++) {        ints[i] = reader.readInteger();    }    return ints;}
aff342348c433e3fb3542c788818ac19ddb70cb73eb7742dcfd795dfb64e5350
testOnlyAppliesToBinary
public void testOnlyAppliesToBinary()
{    assertTrue(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.6.0 (build abcd)", PrimitiveTypeName.BINARY));    assertTrue(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.6.0 (build abcd)", PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY));    assertFalse(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.6.0 (build abcd)", PrimitiveTypeName.DOUBLE));}
b020d7dda49da7529e4200b388a7522226b81f754db940fbda441a3388f23cd1
testCorruptStatistics
public void testCorruptStatistics()
{    assertTrue(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.6.0 (build abcd)", PrimitiveTypeName.BINARY));    assertTrue(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.4.2 (build abcd)", PrimitiveTypeName.BINARY));    assertTrue(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.6.100 (build abcd)", PrimitiveTypeName.BINARY));    assertTrue(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.7.999 (build abcd)", PrimitiveTypeName.BINARY));    assertTrue(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.6.22rc99 (build abcd)", PrimitiveTypeName.BINARY));    assertTrue(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.6.22rc99-SNAPSHOT (build abcd)", PrimitiveTypeName.BINARY));    assertTrue(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.6.1-SNAPSHOT (build abcd)", PrimitiveTypeName.BINARY));    assertTrue(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.6.0t-01-abcdefg (build abcd)", PrimitiveTypeName.BINARY));    assertTrue(CorruptStatistics.shouldIgnoreStatistics("unparseable string", PrimitiveTypeName.BINARY));        assertTrue(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version (build abcd)", PrimitiveTypeName.BINARY));    assertTrue(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version  (build abcd)", PrimitiveTypeName.BINARY));        assertTrue(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.6.0 (build )", PrimitiveTypeName.BINARY));    assertTrue(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.6.0 (build)", PrimitiveTypeName.BINARY));    assertTrue(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version (build)", PrimitiveTypeName.BINARY));    assertFalse(CorruptStatistics.shouldIgnoreStatistics("imapla version 1.6.0 (build abcd)", PrimitiveTypeName.BINARY));    assertFalse(CorruptStatistics.shouldIgnoreStatistics("imapla version 1.10.0 (build abcd)", PrimitiveTypeName.BINARY));    assertFalse(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.8.0 (build abcd)", PrimitiveTypeName.BINARY));    assertFalse(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.8.1 (build abcd)", PrimitiveTypeName.BINARY));    assertFalse(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.8.1rc3 (build abcd)", PrimitiveTypeName.BINARY));    assertFalse(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.8.1rc3-SNAPSHOT (build abcd)", PrimitiveTypeName.BINARY));    assertFalse(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.9.0 (build abcd)", PrimitiveTypeName.BINARY));    assertFalse(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 2.0.0 (build abcd)", PrimitiveTypeName.BINARY));    assertFalse(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.9.0t-01-abcdefg (build abcd)", PrimitiveTypeName.BINARY));        assertFalse(CorruptStatistics.shouldIgnoreStatistics("impala version (build abcd)", PrimitiveTypeName.BINARY));    assertFalse(CorruptStatistics.shouldIgnoreStatistics("impala version  (build abcd)", PrimitiveTypeName.BINARY));        assertFalse(CorruptStatistics.shouldIgnoreStatistics("impala version 1.6.0 (build )", PrimitiveTypeName.BINARY));    assertFalse(CorruptStatistics.shouldIgnoreStatistics("impala version 1.6.0 (build)", PrimitiveTypeName.BINARY));    assertFalse(CorruptStatistics.shouldIgnoreStatistics("impala version (build)", PrimitiveTypeName.BINARY));}
27f8ff0420dda188b4517d21798c76d65b9bb80178814ff6b5d47130b200f2fa
testDistributionCorruptStatistics
public void testDistributionCorruptStatistics()
{    assertTrue(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.5.0-cdh5.4.999 (build abcd)", PrimitiveTypeName.BINARY));    assertFalse(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.5.0-cdh5.5.0-SNAPSHOT (build 956ed6c14c611b4c4eaaa1d6e5b9a9c6d4dfa336)", PrimitiveTypeName.BINARY));    assertFalse(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.5.0-cdh5.5.0 (build abcd)", PrimitiveTypeName.BINARY));    assertFalse(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.5.0-cdh5.5.1 (build abcd)", PrimitiveTypeName.BINARY));    assertFalse(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.5.0-cdh5.6.0 (build abcd)", PrimitiveTypeName.BINARY));    assertTrue(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.4.10 (build abcd)", PrimitiveTypeName.BINARY));    assertTrue(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.5.0 (build abcd)", PrimitiveTypeName.BINARY));    assertTrue(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.5.1 (build abcd)", PrimitiveTypeName.BINARY));    assertTrue(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.6.0 (build abcd)", PrimitiveTypeName.BINARY));    assertTrue(CorruptStatistics.shouldIgnoreStatistics("parquet-mr version 1.7.0 (build abcd)", PrimitiveTypeName.BINARY));}
7f7f3f19704e2a738e37683ea1e845cc8989f3ea09f4b8dd10734db5795ded63
keep
public boolean keep(Integer value)
{    return false;}
c7a72c7a33471a778e8b2a612fa9450efb2b3f8c5a5ec016b75b49a1a893850b
canDrop
public boolean canDrop(Statistics<Integer> statistics)
{    return false;}
ebdbd08b714a5ea0982d87cfe65d5c0cbd451cc408d5f216453963845d6ce249
inverseCanDrop
public boolean inverseCanDrop(Statistics<Integer> statistics)
{    return false;}
f74876f1a2d65643cdd757d8fd84abffe88c40a790e9693dac122c6bb8a43c02
testFilterPredicateCreation
public void testFilterPredicateCreation()
{    FilterPredicate outerAnd = predicate;    assertTrue(outerAnd instanceof And);    FilterPredicate not = ((And) outerAnd).getLeft();    FilterPredicate gt = ((And) outerAnd).getRight();    assertTrue(not instanceof Not);    FilterPredicate or = ((Not) not).getPredicate();    assertTrue(or instanceof Or);    FilterPredicate leftEq = ((Or) or).getLeft();    FilterPredicate rightNotEq = ((Or) or).getRight();    assertTrue(leftEq instanceof Eq);    assertTrue(rightNotEq instanceof NotEq);    assertEquals(7, ((Eq) leftEq).getValue());    assertEquals(17, ((NotEq) rightNotEq).getValue());    assertEquals(ColumnPath.get("a", "b", "c"), ((Eq) leftEq).getColumn().getColumnPath());    assertEquals(ColumnPath.get("a", "b", "c"), ((NotEq) rightNotEq).getColumn().getColumnPath());    assertTrue(gt instanceof Gt);    assertEquals(100.0, ((Gt) gt).getValue());    assertEquals(ColumnPath.get("x", "y", "z"), ((Gt) gt).getColumn().getColumnPath());}
cd89046fb8911fa4a6595be8ff9a8156398ebfad5d0c95e20ca6a68135c4b5d2
testToString
public void testToString()
{    FilterPredicate pred = or(predicate, notEq(binColumn, Binary.fromString("foobarbaz")));    assertEquals("or(and(not(or(eq(a.b.c, 7), noteq(a.b.c, 17))), gt(x.y.z, 100.0)), " + "noteq(a.string.column, Binary{\"foobarbaz\"}))", pred.toString());}
cc0fcc2577b27f69277ce241caa2ebe9edf24b5a2bcda022d5574f15933c392f
testUdp
public void testUdp()
{    FilterPredicate predicate = or(eq(doubleColumn, 12.0), userDefined(intColumn, DummyUdp.class));    assertTrue(predicate instanceof Or);    FilterPredicate ud = ((Or) predicate).getRight();    assertTrue(ud instanceof UserDefinedByClass);    assertEquals(DummyUdp.class, ((UserDefinedByClass) ud).getUserDefinedPredicateClass());    assertTrue(((UserDefined) ud).getUserDefinedPredicate() instanceof DummyUdp);}
fef6f69467e208066739ab98fb21ea8809b81104932f593b37aaf6b78c5a2446
testSerializable
public void testSerializable() throws Exception
{    BinaryColumn binary = binaryColumn("foo");    FilterPredicate p = and(or(and(userDefined(intColumn, DummyUdp.class), predicate), eq(binary, Binary.fromString("hi"))), userDefined(longColumn, new IsMultipleOf(7)));    ByteArrayOutputStream baos = new ByteArrayOutputStream();    ObjectOutputStream oos = new ObjectOutputStream(baos);    oos.writeObject(p);    oos.close();    ObjectInputStream is = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));    FilterPredicate read = (FilterPredicate) is.readObject();    assertEquals(p, read);}
6a0ad857c4f18f2d64da235f3e095c2ada5780c75df3139c572f63f22a8e65a5
keep
public boolean keep(Long value)
{    if (value == null) {        return false;    }    return value % of == 0;}
9dc064c84e7b360a598629007633ef115befb8e2ff84a21a63d976d15c28aa30
canDrop
public boolean canDrop(Statistics<Long> statistics)
{    return false;}
24d038c437c6c7c61085c1cd71d35f9d7ea6ee4a52d448b6b35d55f55712b809
inverseCanDrop
public boolean inverseCanDrop(Statistics<Long> statistics)
{    return false;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    IsMultipleOf that = (IsMultipleOf) o;    return this.of == that.of;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return new Long(of).hashCode();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "IsMultipleOf(" + of + ")";}
0637d5105a5d3e46dc3f5d5412dbd126216e0fb1de9ac50faf188fd6208ab544
assertNoOp
private static void assertNoOp(FilterPredicate p)
{    assertEquals(p, rewrite(p));}
bf22cc66a265a67181d2d9dbcc0cea51a757f8994639cc163adbce848bb8cfcc
testBaseCases
public void testBaseCases()
{    UserDefined<Integer, DummyUdp> ud = userDefined(intColumn, DummyUdp.class);    assertNoOp(eq(intColumn, 17));    assertNoOp(notEq(intColumn, 17));    assertNoOp(lt(intColumn, 17));    assertNoOp(ltEq(intColumn, 17));    assertNoOp(gt(intColumn, 17));    assertNoOp(gtEq(intColumn, 17));    assertNoOp(and(eq(intColumn, 17), eq(doubleColumn, 12.0)));    assertNoOp(or(eq(intColumn, 17), eq(doubleColumn, 12.0)));    assertNoOp(ud);    assertEquals(notEq(intColumn, 17), rewrite(not(eq(intColumn, 17))));    assertEquals(eq(intColumn, 17), rewrite(not(notEq(intColumn, 17))));    assertEquals(gtEq(intColumn, 17), rewrite(not(lt(intColumn, 17))));    assertEquals(gt(intColumn, 17), rewrite(not(ltEq(intColumn, 17))));    assertEquals(ltEq(intColumn, 17), rewrite(not(gt(intColumn, 17))));    assertEquals(lt(intColumn, 17), rewrite(not(gtEq(intColumn, 17))));    assertEquals(new LogicalNotUserDefined<Integer, DummyUdp>(ud), rewrite(not(ud)));    FilterPredicate notedAnd = not(and(eq(intColumn, 17), eq(doubleColumn, 12.0)));    FilterPredicate distributedAnd = or(notEq(intColumn, 17), notEq(doubleColumn, 12.0));    assertEquals(distributedAnd, rewrite(notedAnd));    FilterPredicate andWithNots = and(not(gtEq(intColumn, 17)), lt(intColumn, 7));    FilterPredicate andWithoutNots = and(lt(intColumn, 17), lt(intColumn, 7));    assertEquals(andWithoutNots, rewrite(andWithNots));}
e38a3b46001aaf1ce6782fff33ac1aa769470d6e918883dbb79c30db295b54df
testComplex
public void testComplex()
{    assertEquals(complexCollapsed, rewrite(complex));}
bf22cc66a265a67181d2d9dbcc0cea51a757f8994639cc163adbce848bb8cfcc
testBaseCases
public void testBaseCases()
{    assertEquals(notEq(intColumn, 17), invert(eq(intColumn, 17)));    assertEquals(eq(intColumn, 17), invert(notEq(intColumn, 17)));    assertEquals(gtEq(intColumn, 17), invert(lt(intColumn, 17)));    assertEquals(gt(intColumn, 17), invert(ltEq(intColumn, 17)));    assertEquals(ltEq(intColumn, 17), invert(gt(intColumn, 17)));    assertEquals(lt(intColumn, 17), invert(gtEq(intColumn, 17)));    FilterPredicate andPos = and(eq(intColumn, 17), eq(doubleColumn, 12.0));    FilterPredicate andInv = or(notEq(intColumn, 17), notEq(doubleColumn, 12.0));    assertEquals(andInv, invert(andPos));    FilterPredicate orPos = or(eq(intColumn, 17), eq(doubleColumn, 12.0));    FilterPredicate orInv = and(notEq(intColumn, 17), notEq(doubleColumn, 12.0));    assertEquals(orPos, invert(orInv));    assertEquals(eq(intColumn, 17), invert(not(eq(intColumn, 17))));    UserDefined<Integer, DummyUdp> ud = userDefined(intColumn, DummyUdp.class);    assertEquals(new LogicalNotUserDefined<Integer, DummyUdp>(ud), invert(ud));    assertEquals(ud, invert(not(ud)));    assertEquals(ud, invert(new LogicalNotUserDefined<Integer, DummyUdp>(ud)));}
e38a3b46001aaf1ce6782fff33ac1aa769470d6e918883dbb79c30db295b54df
testComplex
public void testComplex()
{    assertEquals(complexInverse, invert(complex));}
6a0ad857c4f18f2d64da235f3e095c2ada5780c75df3139c572f63f22a8e65a5
keep
public boolean keep(Long value)
{    return false;}
9dc064c84e7b360a598629007633ef115befb8e2ff84a21a63d976d15c28aa30
canDrop
public boolean canDrop(Statistics<Long> statistics)
{    return false;}
24d038c437c6c7c61085c1cd71d35f9d7ea6ee4a52d448b6b35d55f55712b809
inverseCanDrop
public boolean inverseCanDrop(Statistics<Long> statistics)
{    return false;}
2098e5d6926d7172e77c32789e39c8ccec57bafc0bef2c3bc04c602a1086247c
testValidType
public void testValidType()
{    validate(complexValid, schema);}
7daba6ac534da337b8ff8d8dfebf31c093a3c727668dd66fd0834d3a56afee1a
testFindsInvalidTypes
public void testFindsInvalidTypes()
{    try {        validate(complexWrongType, schema);        fail("this should throw");    } catch (IllegalArgumentException e) {        assertEquals("FilterPredicate column: x.bar's declared type (java.lang.Long) does not match the schema found in file metadata. " + "Column x.bar is of type: INT32\n" + "Valid types for this column are: [class java.lang.Integer]", e.getMessage());    }}
f2b737ebc397eb36fa64dd5a63a3ce8d3cf1a1b4065fa2338aea9ae226a2ba67
testTwiceDeclaredColumn
public void testTwiceDeclaredColumn()
{    validate(eq(stringC, Binary.fromString("larry")), schema);    try {        validate(complexMixedType, schema);        fail("this should throw");    } catch (IllegalArgumentException e) {        assertEquals("Column: x.bar was provided with different types in the same predicate. Found both: (class java.lang.Integer, class java.lang.Long)", e.getMessage());    }}
c19d26c72345700f1f1ccf81b8144df4ef9452383b2f548122973bbe08528f2a
testRepeatedNotSupported
public void testRepeatedNotSupported()
{    try {        validate(eq(lotsOfLongs, 10l), schema);        fail("this should throw");    } catch (IllegalArgumentException e) {        assertEquals("FilterPredicates do not currently support repeated columns. Column lotsOfLongs is repeated.", e.getMessage());    }}
27299a8b239310d11e9ee12718b15d42f5e5c662417423ff28f30a402aeebca3
compareTo
public int compareTo(InvalidColumnType o)
{    return 0;}
0b2c258b28058d0e3634e3f0863ca8d6b4128a3f6ab3debd9374a72fb77fa503
testValidTypes
public void testValidTypes()
{    assertTypeValid(intColumn, PrimitiveTypeName.INT32);    assertTypeValid(longColumn, PrimitiveTypeName.INT64);    assertTypeValid(floatColumn, PrimitiveTypeName.FLOAT);    assertTypeValid(doubleColumn, PrimitiveTypeName.DOUBLE);    assertTypeValid(booleanColumn, PrimitiveTypeName.BOOLEAN);    assertTypeValid(binaryColumn, PrimitiveTypeName.BINARY);    assertTypeValid(binaryColumn, PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY);    assertTypeValid(binaryColumn, PrimitiveTypeName.INT96);}
1efde308ac06253537e5ac4ab1e6c6d497a20c9062ef56ecc3c629113a417513
testMismatchedTypes
public void testMismatchedTypes()
{    try {        assertTypeValid(intColumn, PrimitiveTypeName.DOUBLE);        fail("This should throw!");    } catch (IllegalArgumentException e) {        assertEquals("FilterPredicate column: int.column's declared type (java.lang.Integer) does not match the " + "schema found in file metadata. Column int.column is of type: " + "DOUBLE\n" + "Valid types for this column are: [class java.lang.Double]", e.getMessage());    }}
22928750ec6419b7db0c6ddf5304b4b4372cd8c6b6bdc91a131da00287e63f1e
testUnsupportedType
public void testUnsupportedType()
{    try {        assertTypeValid(invalidColumn, PrimitiveTypeName.INT32);        fail("This should throw!");    } catch (IllegalArgumentException e) {        assertEquals("Column invalid.column was declared as type: " + "org.apache.parquet.filter2.predicate.TestValidTypeMap$InvalidColumnType which is not supported " + "in FilterPredicates. Supported types for this column are: [class java.lang.Integer]", e.getMessage());    }}
4e3805fa82de4291da15b15d092b9d8e9b9abb3977ab43171a459e5a9afe7c71
intIsNull
public static ValueInspector intIsNull()
{    return new ValueInspector() {        @Override        public void updateNull() {            setResult(true);        }        @Override        public void update(int value) {            setResult(false);        }    };}
e2ad11a16cdc3bb63def4c96f6278da7be6b19bbbbb7b3b31e99bf7fdc83edad
updateNull
public void updateNull()
{    setResult(true);}
7d630ab84a82142fdaf1528f2bcc2cec2c8f672a645aa065a9afce31f57b8e78
update
public void update(int value)
{    setResult(false);}
efafaa6a3d71e2232b1af82dd79e047fb712c3065fd2554e672cc55429208b31
intIsEven
public static ValueInspector intIsEven()
{    return new ValueInspector() {        @Override        public void updateNull() {            setResult(false);        }        @Override        public void update(int value) {            setResult(value % 2 == 0);        }    };}
e2ad11a16cdc3bb63def4c96f6278da7be6b19bbbbb7b3b31e99bf7fdc83edad
updateNull
public void updateNull()
{    setResult(false);}
7d630ab84a82142fdaf1528f2bcc2cec2c8f672a645aa065a9afce31f57b8e78
update
public void update(int value)
{    setResult(value % 2 == 0);}
a52d7a0a460ad2ec08ad9e69adc6a13502a770be59d9116296c44cc02b655f0e
doubleMoreThan10
public static ValueInspector doubleMoreThan10()
{    return new ValueInspector() {        @Override        public void updateNull() {            setResult(false);        }        @Override        public void update(double value) {            setResult(value > 10.0);        }    };}
e2ad11a16cdc3bb63def4c96f6278da7be6b19bbbbb7b3b31e99bf7fdc83edad
updateNull
public void updateNull()
{    setResult(false);}
9816736c0b0bcc70e8ebae510d041f2a0524be549ab3fbdba000ec7ae3903048
update
public void update(double value)
{    setResult(value > 10.0);}
9cf6e94d548bfbcdded19fb3fd610a0cda155401e81383348b192824bf823741
testValueInspector
public void testValueInspector()
{        ValueInspector v = intIsEven();    v.update(11);    assertFalse(evaluate(v));    v.reset();        v.update(12);    assertTrue(evaluate(v));    v.reset();        v.updateNull();    assertFalse(evaluate(v));    v.reset();        ValueInspector intIsNull = intIsNull();    intIsNull.update(10);    assertFalse(evaluate(intIsNull));    intIsNull.reset();        intIsNull.updateNull();    assertTrue(evaluate(intIsNull));    intIsNull.reset();        v.reset();    assertFalse(evaluate(v));        intIsNull.reset();    assertTrue(evaluate(intIsNull));}
20fcb84517f06b7a90a30bdac6264fd1e5f76d2e8f2ec5f4c68cd31121a3b3b9
doOrTest
private void doOrTest(ValueInspector v1, ValueInspector v2, int v1Value, int v2Value, boolean expected)
{    v1.update(v1Value);    v2.update(v2Value);    IncrementallyUpdatedFilterPredicate or = new Or(v1, v2);    assertEquals(expected, evaluate(or));    v1.reset();    v2.reset();}
618b2e6ea25764cfbf6c9c51c2adfd4be2ca7ee0e51337505212fe1d8118e40b
doAndTest
private void doAndTest(ValueInspector v1, ValueInspector v2, int v1Value, int v2Value, boolean expected)
{    v1.update(v1Value);    v2.update(v2Value);    IncrementallyUpdatedFilterPredicate and = new And(v1, v2);    assertEquals(expected, evaluate(and));    v1.reset();    v2.reset();}
03468a694e1f76feba169429f64eb0afb2df050c46a06529a9d234068be47808
testOr
public void testOr()
{    ValueInspector v1 = intIsEven();    ValueInspector v2 = intIsEven();    int F = 11;    int T = 12;        doOrTest(v1, v2, F, F, false);        doOrTest(v1, v2, F, T, true);        doOrTest(v1, v2, T, F, true);        doOrTest(v1, v2, T, T, true);}
add54cff8d9e6cbc84149e95c16e650ba05c5e54a19557393f3a6ad198b62cde
testAnd
public void testAnd()
{    ValueInspector v1 = intIsEven();    ValueInspector v2 = intIsEven();    int F = 11;    int T = 12;        doAndTest(v1, v2, F, F, false);        doAndTest(v1, v2, F, T, false);        doAndTest(v1, v2, T, F, false);        doAndTest(v1, v2, T, T, true);}
c2a7832daecf1114f94da8d0712f6742305b5013756ea8db378a4a269795b9de
testShortCircuit
public void testShortCircuit()
{    ValueInspector neverCalled = new ValueInspector() {        @Override        public boolean accept(Visitor visitor) {            throw new ShortCircuitException();        }    };    try {        evaluate(neverCalled);        fail("this should throw");    } catch (ShortCircuitException e) {        }        ValueInspector v = intIsEven();    v.update(10);    IncrementallyUpdatedFilterPredicate or = new Or(v, neverCalled);    assertTrue(evaluate(or));    v.reset();        v.update(11);    IncrementallyUpdatedFilterPredicate and = new And(v, neverCalled);    assertFalse(evaluate(and));    v.reset();}
97adbf4630b0d771ecd2d45ee820dd6808014cf6c408782a05144f45e382b7bb
accept
public boolean accept(Visitor visitor)
{    throw new ShortCircuitException();}
7832dc1ba4ba17b086c699263e0677eed939a45b337037cab9dad1912e5bad76
testReset
public void testReset()
{    ValueInspector intIsNull = intIsNull();    ValueInspector intIsEven = intIsEven();    ValueInspector doubleMoreThan10 = doubleMoreThan10();    IncrementallyUpdatedFilterPredicate pred = new Or(intIsNull, new And(intIsEven, doubleMoreThan10));    intIsNull.updateNull();    intIsEven.update(11);    doubleMoreThan10.update(20.0D);    assertTrue(intIsNull.isKnown());    assertTrue(intIsEven.isKnown());    assertTrue(doubleMoreThan10.isKnown());    IncrementallyUpdatedFilterPredicateResetter.reset(pred);    assertFalse(intIsNull.isKnown());    assertFalse(intIsEven.isKnown());    assertFalse(doubleMoreThan10.isKnown());    intIsNull.updateNull();    assertTrue(intIsNull.isKnown());    assertFalse(intIsEven.isKnown());    assertFalse(doubleMoreThan10.isKnown());    IncrementallyUpdatedFilterPredicateResetter.reset(pred);    assertFalse(intIsNull.isKnown());    assertFalse(intIsEven.isKnown());    assertFalse(doubleMoreThan10.isKnown());}
2be67f9309c3046462d5ff98b212f4fb40acc0f8e8d7d7d923d4c48112b83a91
testLifeCycle
public void testLifeCycle()
{    ValueInspector v = intIsEven();        assertFalse(v.isKnown());        try {        v.getResult();        fail("this should throw");    } catch (IllegalStateException e) {        assertEquals("getResult() called on a ValueInspector whose result is not yet known!", e.getMessage());    }        v.update(10);        assertTrue(v.isKnown());    assertTrue(v.getResult());        try {        v.update(11);        fail("this should throw");    } catch (IllegalStateException e) {        assertEquals("setResult() called on a ValueInspector whose result is already known!" + " Did you forget to call reset()?", e.getMessage());    }        v.reset();    assertFalse(v.isKnown());        try {        v.getResult();        fail("this should throw");    } catch (IllegalStateException e) {        assertEquals("getResult() called on a ValueInspector whose result is not yet known!", e.getMessage());    }        v.update(11);    assertTrue(v.isKnown());    assertFalse(v.getResult());}
e81afe035d64a7f8f2794eaee13f5f3b3e9e10b9dba8d0532ce5999f1d3b528d
testReusable
public void testReusable()
{    List<Integer> values = Arrays.asList(2, 4, 7, 3, 8, 8, 11, 200);    ValueInspector v = intIsEven();    for (Integer x : values) {        v.update(x);        assertEquals(x % 2 == 0, v.getResult());        v.reset();    }}
f6e0b716d3d2b87c4094aa6243335d6a4f66c54896f0d91751293329a932fb34
testNonStringTruncate
public void testNonStringTruncate()
{    BinaryTruncator truncator = BinaryTruncator.getTruncator(Types.required(BINARY).as(DECIMAL).precision(10).scale(2).named("test_binary_decimal"));    assertEquals(binary(0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA), truncator.truncateMin(binary(0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA), 2));    assertEquals(binary(0x01, 0x02, 0x03, 0x04, 0x05, 0x06), truncator.truncateMax(binary(0x01, 0x02, 0x03, 0x04, 0x05, 0x06), 2));}
bb3a8ac41ddc10d6b9bfcade1f31f32c919d8e70ee482169a4b1f626835532d5
testContractNonStringTypes
public void testContractNonStringTypes()
{    testTruncator(Types.required(FIXED_LEN_BYTE_ARRAY).length(8).as(DECIMAL).precision(18).scale(4).named("test_fixed_decimal"), false);    testTruncator(Types.required(FIXED_LEN_BYTE_ARRAY).length(12).as(INTERVAL).named("test_fixed_interval"), false);    testTruncator(Types.required(BINARY).as(DECIMAL).precision(10).scale(2).named("test_binary_decimal"), false);    testTruncator(Types.required(INT96).named("test_int96"), false);}
ac09f6c18def5c352515ffb4d632ad7e82702135fbda0f753a4f50319740a94a
testStringTruncate
public void testStringTruncate()
{    BinaryTruncator truncator = BinaryTruncator.getTruncator(Types.required(BINARY).as(UTF8).named("test_utf8"));        assertEquals(Binary.fromString("abc"), truncator.truncateMin(Binary.fromString("abcdef"), 3));    assertEquals(Binary.fromString("abd"), truncator.truncateMax(Binary.fromString("abcdef"), 3));        assertEquals(Binary.fromString("rvzt"), truncator.truncateMin(Binary.fromString("rvztr"), 9));    assertEquals(Binary.fromString("rvzu"), truncator.truncateMax(Binary.fromString("rvztr"), 9));        assertEquals(Binary.fromString(UTF8_1BYTE_MAX_CHAR + UTF8_2BYTES_MAX_CHAR), truncator.truncateMin(Binary.fromString(UTF8_1BYTE_MAX_CHAR + UTF8_2BYTES_MAX_CHAR + UTF8_3BYTES_MAX_CHAR + UTF8_4BYTES_MAX_CHAR), 5));    assertEquals(Binary.fromString(UTF8_1BYTE_MAX_CHAR + UTF8_2BYTES_MAX_CHAR + UTF8_3BYTES_MAX_CHAR + UTF8_4BYTES_MAX_CHAR), truncator.truncateMax(Binary.fromString(UTF8_1BYTE_MAX_CHAR + UTF8_2BYTES_MAX_CHAR + UTF8_3BYTES_MAX_CHAR + UTF8_4BYTES_MAX_CHAR), 5));        assertEquals(Binary.fromString(UTF8_1BYTE_MAX_CHAR + UTF8_2BYTES_MAX_CHAR + "b" + UTF8_3BYTES_MAX_CHAR), truncator.truncateMax(Binary.fromString(UTF8_1BYTE_MAX_CHAR + UTF8_2BYTES_MAX_CHAR + "a" + UTF8_3BYTES_MAX_CHAR + UTF8_4BYTES_MAX_CHAR), 10));        assertEquals(binary(0xFF, 0xFE, 0xFD), truncator.truncateMin(binary(0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA), 3));    assertEquals(binary(0xFF, 0xFE, 0xFE), truncator.truncateMax(binary(0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA), 3));    assertEquals(binary(0xFF, 0xFE, 0xFE, 0x00, 0x00), truncator.truncateMax(binary(0xFF, 0xFE, 0xFD, 0xFF, 0xFF, 0xFF), 5));}
ae6c094a455fdb65cf323aadb94f284a4ba68156b6a8b470330c4a8922b09372
testContractStringTypes
public void testContractStringTypes()
{    testTruncator(Types.required(BINARY).named("test_binary"), true);    testTruncator(Types.required(BINARY).as(UTF8).named("test_utf8"), true);    testTruncator(Types.required(BINARY).as(ENUM).named("test_enum"), true);    testTruncator(Types.required(BINARY).as(JSON).named("test_json"), true);    testTruncator(Types.required(BINARY).as(BSON).named("test_bson"), true);    testTruncator(Types.required(FIXED_LEN_BYTE_ARRAY).length(5).named("test_fixed"), true);}
34fa85e17ea8c1d7d3642b0ce15e2053956f871ca06e8b61dc48e3a03472f36c
testTruncator
private void testTruncator(PrimitiveType type, boolean strict)
{    BinaryTruncator truncator = BinaryTruncator.getTruncator(type);    Comparator<Binary> comparator = type.comparator();    checkContract(truncator, comparator, Binary.fromString("aaaaaaaaaa"), strict, strict);    checkContract(truncator, comparator, Binary.fromString("rvztr tkrfrgp"), strict, strict);    checkContract(truncator, comparator, Binary.fromString("aaaaaaaaaa" + UTF8_3BYTES_MAX_CHAR), strict, strict);    checkContract(truncator, comparator, Binary.fromString("a" + UTF8_3BYTES_MAX_CHAR + UTF8_1BYTE_MAX_CHAR), strict, strict);    checkContract(truncator, comparator, Binary.fromConstantByteArray(new byte[] { (byte) 0xFE, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, (byte) 0xFF }), strict, strict);        checkContract(truncator, comparator, Binary.fromString(""), false, false);        checkContract(truncator, comparator, Binary.fromString(UTF8_1BYTE_MAX_CHAR + UTF8_4BYTES_MAX_CHAR + UTF8_3BYTES_MAX_CHAR + UTF8_4BYTES_MAX_CHAR + UTF8_2BYTES_MAX_CHAR + UTF8_3BYTES_MAX_CHAR + UTF8_3BYTES_MAX_CHAR + UTF8_1BYTE_MAX_CHAR + UTF8_2BYTES_MAX_CHAR + UTF8_3BYTES_MAX_CHAR + UTF8_4BYTES_MAX_CHAR), strict, false);        checkContract(truncator, comparator, binary(0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF), strict, false);}
c6a84fca13571a4b8046307f3f087a21cb1012984c2da1aadd5378d939f8c30b
checkContract
private void checkContract(BinaryTruncator truncator, Comparator<Binary> comparator, Binary value, boolean strictMin, boolean strictMax)
{    int length = value.length();        assertSame(value, truncator.truncateMin(value, length));    assertSame(value, truncator.truncateMax(value, length));    assertSame(value, truncator.truncateMin(value, random(length + 1, length * 2 + 1)));    assertSame(value, truncator.truncateMax(value, random(length + 1, length * 2 + 1)));    if (length > 1) {        checkMinContract(truncator, comparator, value, length - 1, strictMin);        checkMaxContract(truncator, comparator, value, length - 1, strictMax);        checkMinContract(truncator, comparator, value, random(1, length - 1), strictMin);        checkMaxContract(truncator, comparator, value, random(1, length - 1), strictMax);    }        checkMinContract(truncator, comparator, value, 0, strictMin);        assertSame(value, truncator.truncateMax(value, 0));}
347b51408ef86d8a202b505a2ef6facbd365d03edcc6669525a63e489f091738
checkMinContract
private void checkMinContract(BinaryTruncator truncator, Comparator<Binary> comparator, Binary value, int length, boolean strict)
{    Binary truncated = truncator.truncateMin(value, length);    LOG.debug("\"{}\" --truncMin({})--> \"{}\" [{}]", value.toStringUsingUTF8(), length, truncated.toStringUsingUTF8(), HEXA_STRINGIFIER.stringify(truncated));    assertTrue("truncatedMin(value) should be <= than value", comparator.compare(truncated, value) <= 0);    assertFalse("length of truncateMin(value) should not be > than the length of value", truncated.length() > value.length());    if (isValidUtf8(value)) {        checkValidUtf8(truncated);    }    if (strict) {        assertTrue("length of truncateMin(value) ahould be < than the length of value", truncated.length() < value.length());    }}
69d804d682e66a18d53ef5a4e2fceed6e1c6780e15d8f275c82b805c68048a90
checkMaxContract
private void checkMaxContract(BinaryTruncator truncator, Comparator<Binary> comparator, Binary value, int length, boolean strict)
{    Binary truncated = truncator.truncateMax(value, length);    LOG.debug("\"{}\" --truncMax({})--> \"{}\" [{}]", value.toStringUsingUTF8(), length, truncated.toStringUsingUTF8(), HEXA_STRINGIFIER.stringify(truncated));    assertTrue("truncatedMax(value) should be >= than value", comparator.compare(truncated, value) >= 0);    assertFalse("length of truncateMax(value) should not be > than the length of value", truncated.length() > value.length());    if (isValidUtf8(value)) {        checkValidUtf8(truncated);    }    if (strict) {        assertTrue("length of truncateMax(value) ahould be < than the length of value", truncated.length() < value.length());    }}
56e91663512a3bcef967cf99ea69cfd65b46012e4a032ea328e3eaf621cc0070
isValidUtf8
private static boolean isValidUtf8(Binary binary)
{    try {        UTF8_DECODER.decode(binary.toByteBuffer());        return true;    } catch (CharacterCodingException e) {        return false;    }}
51eb64bcd24ed76c9812bd3ec99ff16dffa81ae73b8cd35e3ae898f2b504f889
checkValidUtf8
private static void checkValidUtf8(Binary binary)
{    try {        UTF8_DECODER.decode(binary.toByteBuffer());    } catch (CharacterCodingException e) {        throw new AssertionError("Truncated value should be a valid UTF-8 string", e);    }}
d3db6cb0335bb7b6bd5b8917ec56a76fcb988d4a3a422898b1c1683499705dac
random
private static int random(int min, int max)
{    return RANDOM.nextInt(max - min + 1) + min;}
dc2bb09630f98aaafa648a046e830805add254f4704b6973a63a89107b28d176
binary
private static Binary binary(int... unsignedBytes)
{    byte[] byteArray = new byte[unsignedBytes.length];    for (int i = 0, n = byteArray.length; i < n; ++i) {        int b = unsignedBytes[i];        assert (0xFFFFFF00 & b) == 0;        byteArray[i] = (byte) b;    }    return Binary.fromConstantByteArray(byteArray);}
d41fd30285685471ecb94aa5e9afe2a8ed329f06b7f206a996c097617f936950
getCompareCount
 int getCompareCount()
{    return compareCount;}
8cf76a482c4011a4192268aebcfbb208b2654bfbfe0119b790f97d3a5a91f929
arrayLength
 int arrayLength()
{    return delegate.arrayLength();}
f6887b616bdeca5fd6a6cf32967ec2c07a17b3376bfd11fb9db03153f652e245
translate
 int translate(int arrayIndex)
{    return delegate.translate(arrayIndex);}
f7f1613a5a9b756d47d040806e393daa82861f5c91f959be8e9bd0d67ccca7e4
compareValueToMin
 int compareValueToMin(int arrayIndex)
{    ++compareCount;    return delegate.compareValueToMin(arrayIndex);}
53bda0d4b3c5362b9a0b6c9323504ee84d319757ab6c7200d75062c650b3b52e
compareValueToMax
 int compareValueToMax(int arrayIndex)
{    ++compareCount;    return delegate.compareValueToMax(arrayIndex);}
c5c08a4a19052b83f85b0824fccd950eccf871b6c6e7c85de65aa90213370bd5
build
 SpyValueComparator build(ColumnIndexBase<?>.ValueComparator comparator)
{    return new SpyValueComparator(comparator);}
f6f553a77cba5519088b58d3878a014ef79ee564b83fdbaab7ca3916f2980914
getMinValueAsBytes
 ByteBuffer getMinValueAsBytes(int arrayIndex)
{    throw new Error("Shall never be invoked");}
de034ca85c97058c6ac74e53bde259106c855a7eda7bbdd838ba81a58e71525f
getMaxValueAsBytes
 ByteBuffer getMaxValueAsBytes(int arrayIndex)
{    throw new Error("Shall never be invoked");}
6bad2bc0827ed24e27432e50b17f808c078ad3bb0ff70c583a66eef4a3a19fed
getMinValueAsString
 String getMinValueAsString(int arrayIndex)
{    throw new Error("Shall never be invoked");}
0b65eafe925ff86ba699e724c6827127837500d281db8ba80cbff3edcf35e064
getMaxValueAsString
 String getMaxValueAsString(int arrayIndex)
{    throw new Error("Shall never be invoked");}
4cb49994730581519a17f3be4d50a9e9caec084503f830938762f80654207058
createStats
 org.apache.parquet.filter2.predicate.Statistics<T> createStats(int arrayIndex)
{    throw new Error("Shall never be invoked");}
16a7a1b7572e0995333d7438dccecd310adeeb676cf2c8e494d7c8ff63be989d
createValueComparator
 ColumnIndexBase<Integer>.ValueComparator createValueComparator(Object value)
{    throw new Error("Shall never be invoked");}
1a816cf1151a4ec7f1b2c0717771958766e1a40bb9978674d2d63041d840afd1
measureLinear
 IntList measureLinear(Function<ColumnIndexBase<?>.ValueComparator, PrimitiveIterator.OfInt> op, ColumnIndexBase<?>.ValueComparator comparator)
{    IntList list = new IntArrayList(comparator.arrayLength());    SpyValueComparatorBuilder.SpyValueComparator spyComparator = SPY_COMPARATOR_BUILDER.build(comparator);    long start = System.nanoTime();    op.apply(spyComparator).forEachRemaining((int value) -> list.add(value));    linearTime = System.nanoTime() - start;    linearCompareCount += spyComparator.getCompareCount();    return list;}
c4c83dc3a1da05141f7ff5bb6136cdaa961011a28cff60844187d15391d3cd5e
measureBinary
 IntList measureBinary(Function<ColumnIndexBase<?>.ValueComparator, PrimitiveIterator.OfInt> op, ColumnIndexBase<?>.ValueComparator comparator)
{    IntList list = new IntArrayList(comparator.arrayLength());    SpyValueComparatorBuilder.SpyValueComparator spyComparator = SPY_COMPARATOR_BUILDER.build(comparator);    long start = System.nanoTime();    op.apply(spyComparator).forEachRemaining((int value) -> list.add(value));    binaryTime = System.nanoTime() - start;    binaryCompareCount += spyComparator.getCompareCount();    return list;}
5582878216cc3ff37f5532702adbf3392204e0fbfa8473c2146b9aa69068331d
add
 void add(ExecStats stats)
{    linearTime += stats.linearTime;    linearCompareCount += stats.linearCompareCount;    binaryTime += stats.binaryTime;    binaryCompareCount += stats.binaryCompareCount;    ++execCount;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    double linearMs = linearTime / 1_000_000.0;    double binaryMs = binaryTime / 1_000_000.0;    return String.format("Linear search: %.2fms (avg: %.6fms); number of compares: %d (avg: %d) [100.00%%]%n" + "Binary search: %.2fms (avg: %.6fms); number of compares: %d (avg: %d) [%.2f%%]", linearMs, linearMs / execCount, linearCompareCount, linearCompareCount / execCount, binaryMs, binaryMs / execCount, binaryCompareCount, binaryCompareCount / execCount, 100.0 * binaryCompareCount / linearCompareCount);}
cf5236489d0d3c6482d732c58b23977d1997876a1e01de09ddc1e716342c2a75
stats
private static Statistics<?> stats(int min, int max)
{    Statistics<?> stats = Statistics.createStats(TYPE);    stats.updateStats(min);    stats.updateStats(max);    return stats;}
11579eb9d034131cd40d6609d336565bcf4a2a16d76080447530b59e0171526c
validateOperator
private static ExecStats validateOperator(String msg, Function<ColumnIndexBase<?>.ValueComparator, PrimitiveIterator.OfInt> validatorOp, Function<ColumnIndexBase<?>.ValueComparator, PrimitiveIterator.OfInt> actualOp, ColumnIndexBase<?>.ValueComparator comparator)
{    ExecStats stats = new ExecStats();    IntList expected = stats.measureLinear(validatorOp, comparator);    IntList actual = stats.measureBinary(actualOp, comparator);    Assert.assertEquals(msg, expected, actual);    return stats;}
8f82c860e79ff306e86674387aafb5e87b1433615e11304954d395f1e0da5cd9
testEq
public void testEq()
{    for (int i = FROM - 1; i <= TO + 1; ++i) {        validateOperator("Mismatching page indexes for value " + i + " with ASCENDING order", BoundaryOrder.UNORDERED::eq, BoundaryOrder.ASCENDING::eq, ASCENDING.createValueComparator(i));        validateOperator("Mismatching page indexes for value " + i + " with DESCENDING order", BoundaryOrder.UNORDERED::eq, BoundaryOrder.DESCENDING::eq, DESCENDING.createValueComparator(i));    }    for (int i = SINGLE_FROM - 1; i <= SINGLE_TO + 1; ++i) {        ColumnIndexBase<?>.ValueComparator singleComparator = SINGLE.createValueComparator(i);        validateOperator("Mismatching page indexes for value " + i + " with ASCENDING order", BoundaryOrder.UNORDERED::eq, BoundaryOrder.ASCENDING::eq, singleComparator);        validateOperator("Mismatching page indexes for value " + i + " with DESCENDING order", BoundaryOrder.UNORDERED::eq, BoundaryOrder.DESCENDING::eq, singleComparator);    }    ExecStats stats = new ExecStats();    for (int i = RAND_FROM - 1; i <= RAND_TO + 1; ++i) {        stats.add(validateOperator("Mismatching page indexes for value " + i + " with ASCENDING order", BoundaryOrder.UNORDERED::eq, BoundaryOrder.ASCENDING::eq, RAND_ASCENDING.createValueComparator(i)));        stats.add(validateOperator("Mismatching page indexes for value " + i + " with DESCENDING order", BoundaryOrder.UNORDERED::eq, BoundaryOrder.DESCENDING::eq, RAND_DESCENDING.createValueComparator(i)));    }    LOGGER.info("Executed eq on random data (page count: {}, values searched: {}):\n{}", RAND_COUNT, RAND_TO - RAND_FROM + 2, stats);}
63d8c41ea734c9a51957a23db78d88c3561159d59894807cf943759eaad8fe57
testGt
public void testGt()
{    for (int i = FROM - 1; i <= TO + 1; ++i) {        validateOperator("Mismatching page indexes for value " + i + " with ASCENDING order", BoundaryOrder.UNORDERED::gt, BoundaryOrder.ASCENDING::gt, ASCENDING.createValueComparator(i));        validateOperator("Mismatching page indexes for value " + i + " with DESCENDING order", BoundaryOrder.UNORDERED::gt, BoundaryOrder.DESCENDING::gt, DESCENDING.createValueComparator(i));    }    for (int i = SINGLE_FROM - 1; i <= SINGLE_TO + 1; ++i) {        ColumnIndexBase<?>.ValueComparator singleComparator = SINGLE.createValueComparator(i);        validateOperator("Mismatching page indexes for value " + i + " with ASCENDING order", BoundaryOrder.UNORDERED::gt, BoundaryOrder.ASCENDING::gt, singleComparator);        validateOperator("Mismatching page indexes for value " + i + " with DESCENDING order", BoundaryOrder.UNORDERED::gt, BoundaryOrder.DESCENDING::gt, singleComparator);    }    ExecStats stats = new ExecStats();    for (int i = RAND_FROM - 1; i <= RAND_TO + 1; ++i) {        stats.add(validateOperator("Mismatching page indexes for value " + i + " with ASCENDING order", BoundaryOrder.UNORDERED::gt, BoundaryOrder.ASCENDING::gt, RAND_ASCENDING.createValueComparator(i)));        stats.add(validateOperator("Mismatching page indexes for value " + i + " with DESCENDING order", BoundaryOrder.UNORDERED::gt, BoundaryOrder.DESCENDING::gt, RAND_DESCENDING.createValueComparator(i)));    }    LOGGER.info("Executed gt on random data (page count: {}, values searched: {}):\n{}", RAND_COUNT, RAND_TO - RAND_FROM + 2, stats);}
d35ff48a2d5bd02cd3df2675d3b8f2d5e92eb53138dd6776f9dce96a107efeb7
testGtEq
public void testGtEq()
{    for (int i = FROM - 1; i <= TO + 1; ++i) {        validateOperator("Mismatching page indexes for value " + i + " with ASCENDING order", BoundaryOrder.UNORDERED::gtEq, BoundaryOrder.ASCENDING::gtEq, ASCENDING.createValueComparator(i));        validateOperator("Mismatching page indexes for value " + i + " with DESCENDING order", BoundaryOrder.UNORDERED::gtEq, BoundaryOrder.DESCENDING::gtEq, DESCENDING.createValueComparator(i));    }    for (int i = SINGLE_FROM - 1; i <= SINGLE_TO + 1; ++i) {        ColumnIndexBase<?>.ValueComparator singleComparator = SINGLE.createValueComparator(i);        validateOperator("Mismatching page indexes for value " + i + " with ASCENDING order", BoundaryOrder.UNORDERED::gtEq, BoundaryOrder.ASCENDING::gtEq, singleComparator);        validateOperator("Mismatching page indexes for value " + i + " with DESCENDING order", BoundaryOrder.UNORDERED::gtEq, BoundaryOrder.DESCENDING::gtEq, singleComparator);    }    ExecStats stats = new ExecStats();    for (int i = RAND_FROM - 1; i <= RAND_TO + 1; ++i) {        stats.add(validateOperator("Mismatching page indexes for value " + i + " with ASCENDING order", BoundaryOrder.UNORDERED::gtEq, BoundaryOrder.ASCENDING::gtEq, RAND_ASCENDING.createValueComparator(i)));        stats.add(validateOperator("Mismatching page indexes for value " + i + " with DESCENDING order", BoundaryOrder.UNORDERED::gtEq, BoundaryOrder.DESCENDING::gtEq, RAND_DESCENDING.createValueComparator(i)));    }    LOGGER.info("Executed gtEq on random data (page count: {}, values searched: {}):\n{}", RAND_COUNT, RAND_TO - RAND_FROM + 2, stats);}
6f76fac7f7bcda177895146ceb552e0c70c6cf47a4d7edc925e16e847d595fcf
testLt
public void testLt()
{    for (int i = FROM - 1; i <= TO + 1; ++i) {        validateOperator("Mismatching page indexes for value " + i + " with ASCENDING order", BoundaryOrder.UNORDERED::lt, BoundaryOrder.ASCENDING::lt, ASCENDING.createValueComparator(i));        validateOperator("Mismatching page indexes for value " + i + " with DESCENDING order", BoundaryOrder.UNORDERED::lt, BoundaryOrder.DESCENDING::lt, DESCENDING.createValueComparator(i));    }    for (int i = SINGLE_FROM - 1; i <= SINGLE_TO + 1; ++i) {        ColumnIndexBase<?>.ValueComparator singleComparator = SINGLE.createValueComparator(i);        validateOperator("Mismatching page indexes for value " + i + " with ASCENDING order", BoundaryOrder.UNORDERED::lt, BoundaryOrder.ASCENDING::lt, singleComparator);        validateOperator("Mismatching page indexes for value " + i + " with DESCENDING order", BoundaryOrder.UNORDERED::lt, BoundaryOrder.DESCENDING::lt, singleComparator);    }    ExecStats stats = new ExecStats();    for (int i = RAND_FROM - 1; i <= RAND_TO + 1; ++i) {        stats.add(validateOperator("Mismatching page indexes for value " + i + " with ASCENDING order", BoundaryOrder.UNORDERED::lt, BoundaryOrder.ASCENDING::lt, RAND_ASCENDING.createValueComparator(i)));        stats.add(validateOperator("Mismatching page indexes for value " + i + " with DESCENDING order", BoundaryOrder.UNORDERED::lt, BoundaryOrder.DESCENDING::lt, RAND_DESCENDING.createValueComparator(i)));    }    LOGGER.info("Executed lt on random data (page count: {}, values searched: {}):\n{}", RAND_COUNT, RAND_TO - RAND_FROM + 2, stats);}
b818f151bcf920cc4b7d4c60d27f67b04e1d1f84ec10bfff0753294d7f73825d
testLtEq
public void testLtEq()
{    for (int i = FROM - 1; i <= TO + 1; ++i) {        validateOperator("Mismatching page indexes for value " + i + " with ASCENDING order", BoundaryOrder.UNORDERED::ltEq, BoundaryOrder.ASCENDING::ltEq, ASCENDING.createValueComparator(i));        validateOperator("Mismatching page indexes for value " + i + " with DESCENDING order", BoundaryOrder.UNORDERED::ltEq, BoundaryOrder.DESCENDING::ltEq, DESCENDING.createValueComparator(i));    }    for (int i = SINGLE_FROM - 1; i <= SINGLE_TO + 1; ++i) {        ColumnIndexBase<?>.ValueComparator singleComparator = SINGLE.createValueComparator(i);        validateOperator("Mismatching page indexes for value " + i + " with ASCENDING order", BoundaryOrder.UNORDERED::ltEq, BoundaryOrder.ASCENDING::ltEq, singleComparator);        validateOperator("Mismatching page indexes for value " + i + " with DESCENDING order", BoundaryOrder.UNORDERED::ltEq, BoundaryOrder.DESCENDING::ltEq, singleComparator);    }    ExecStats stats = new ExecStats();    for (int i = RAND_FROM - 1; i <= RAND_TO + 1; ++i) {        stats.add(validateOperator("Mismatching page indexes for value " + i + " with ASCENDING order", BoundaryOrder.UNORDERED::ltEq, BoundaryOrder.ASCENDING::ltEq, RAND_ASCENDING.createValueComparator(i)));        stats.add(validateOperator("Mismatching page indexes for value " + i + " with DESCENDING order", BoundaryOrder.UNORDERED::ltEq, BoundaryOrder.DESCENDING::ltEq, RAND_DESCENDING.createValueComparator(i)));    }    LOGGER.info("Executed ltEq on random data (page count: {}, values searched: {}):\n{}", RAND_COUNT, RAND_TO - RAND_FROM + 2, stats);}
b5a40dde77c97b7d06d80e47e840f8bbb3fc95b6c30299c7a7d8a2f679da397b
testNotEq
public void testNotEq()
{    for (int i = -16; i <= 16; ++i) {        validateOperator("Mismatching page indexes for value " + i + " with ASCENDING order", BoundaryOrder.UNORDERED::notEq, BoundaryOrder.ASCENDING::notEq, ASCENDING.createValueComparator(i));        validateOperator("Mismatching page indexes for value " + i + " with DESCENDING order", BoundaryOrder.UNORDERED::notEq, BoundaryOrder.DESCENDING::notEq, DESCENDING.createValueComparator(i));    }    for (int i = FROM - 1; i <= TO + 1; ++i) {        ColumnIndexBase<?>.ValueComparator singleComparator = SINGLE.createValueComparator(i);        validateOperator("Mismatching page indexes for value " + i + " with ASCENDING order", BoundaryOrder.UNORDERED::notEq, BoundaryOrder.ASCENDING::notEq, singleComparator);        validateOperator("Mismatching page indexes for value " + i + " with DESCENDING order", BoundaryOrder.UNORDERED::notEq, BoundaryOrder.DESCENDING::notEq, singleComparator);    }    ExecStats stats = new ExecStats();    for (int i = RAND_FROM - 1; i <= RAND_TO + 1; ++i) {        stats.add(validateOperator("Mismatching page indexes for value " + i + " with ASCENDING order", BoundaryOrder.UNORDERED::notEq, BoundaryOrder.ASCENDING::notEq, RAND_ASCENDING.createValueComparator(i)));        stats.add(validateOperator("Mismatching page indexes for value " + i + " with DESCENDING order", BoundaryOrder.UNORDERED::notEq, BoundaryOrder.DESCENDING::notEq, RAND_DESCENDING.createValueComparator(i)));    }    LOGGER.info("Executed notEq on random data (page count: {}, values searched: {}):\n{}", RAND_COUNT, RAND_TO - RAND_FROM + 2, stats);}
1d830f6b642fa3232a3173f18fb7638d7113fe65b683f2be7e994bb1091c6bb1
keep
public boolean keep(Binary value)
{    return value == null || value.equals(ZERO);}
09284a6bda1c0f188886e150d8e6d4aff3345d3e145c1ee582a6fce810b7f60e
canDrop
public boolean canDrop(org.apache.parquet.filter2.predicate.Statistics<Binary> statistics)
{    Comparator<Binary> cmp = statistics.getComparator();    return cmp.compare(statistics.getMin(), ZERO) > 0 || cmp.compare(statistics.getMax(), ZERO) < 0;}
820db89a3ff8f7b3140d9bbff681307e00b238aaf0be2aa63ef78d35f8d1824a
inverseCanDrop
public boolean inverseCanDrop(org.apache.parquet.filter2.predicate.Statistics<Binary> statistics)
{    Comparator<Binary> cmp = statistics.getComparator();    return cmp.compare(statistics.getMin(), ZERO) == 0 && cmp.compare(statistics.getMax(), ZERO) == 0;}
1d830f6b642fa3232a3173f18fb7638d7113fe65b683f2be7e994bb1091c6bb1
keep
public boolean keep(Binary value)
{    return value != null && value.length() > 0 && value.getBytesUnsafe()[0] == 'B';}
09284a6bda1c0f188886e150d8e6d4aff3345d3e145c1ee582a6fce810b7f60e
canDrop
public boolean canDrop(org.apache.parquet.filter2.predicate.Statistics<Binary> statistics)
{    Comparator<Binary> cmp = statistics.getComparator();    return cmp.compare(statistics.getMin(), C) >= 0 || cmp.compare(statistics.getMax(), B) < 0;}
820db89a3ff8f7b3140d9bbff681307e00b238aaf0be2aa63ef78d35f8d1824a
inverseCanDrop
public boolean inverseCanDrop(org.apache.parquet.filter2.predicate.Statistics<Binary> statistics)
{    Comparator<Binary> cmp = statistics.getComparator();    return cmp.compare(statistics.getMin(), B) >= 0 && cmp.compare(statistics.getMax(), C) < 0;}
76c66435ad46ffc44bc1844f719348ef3e11c7958ec3a69763020d9658e9d7be
keep
public boolean keep(Boolean value)
{    return value == null || value;}
59e2e4755c6bb9de2517de0f5e0568fbff10b83a9fca8d361bd43762dbf143a7
canDrop
public boolean canDrop(org.apache.parquet.filter2.predicate.Statistics<Boolean> statistics)
{    return statistics.getComparator().compare(statistics.getMax(), true) != 0;}
c946d68b35bc6bebf4d2a6aae389c1ac64a09fa486ed9f8caa9eefcd81f20380
inverseCanDrop
public boolean inverseCanDrop(org.apache.parquet.filter2.predicate.Statistics<Boolean> statistics)
{    return statistics.getComparator().compare(statistics.getMin(), true) == 0;}
c058f73d6caff4aa161bdd3c24456a287edecb4d1bd073acfc183ec49054ae21
keep
public boolean keep(Double value)
{    return value != null && Math.floor(value) == value;}
356ee1fa8566fb932ec9fe7d70a26141764b41b8080b7101b025d2ceb88f98b7
canDrop
public boolean canDrop(org.apache.parquet.filter2.predicate.Statistics<Double> statistics)
{    double min = statistics.getMin();    double max = statistics.getMax();    Comparator<Double> cmp = statistics.getComparator();    return cmp.compare(Math.floor(min), Math.floor(max)) == 0 && cmp.compare(Math.floor(min), min) != 0 && cmp.compare(Math.floor(max), max) != 0;}
0345c67838430d96636950d913b7b3cdbddd84a5454a50e0c83e8525d96844eb
inverseCanDrop
public boolean inverseCanDrop(org.apache.parquet.filter2.predicate.Statistics<Double> statistics)
{    double min = statistics.getMin();    double max = statistics.getMax();    Comparator<Double> cmp = statistics.getComparator();    return cmp.compare(min, max) == 0 && cmp.compare(Math.floor(min), min) == 0;}
ac61a54e9ed9f99d9f9dbd5f1ea4ee930942bd62a8aa4512617e7c4e335506e3
floor
private static float floor(float value)
{    return (float) Math.floor(value);}
5e3a85643f5e8b0fd75bb281657ee6cbaed63e119f5f42bdf3411cdb01cd419f
keep
public boolean keep(Float value)
{    return value != null && Math.floor(value) == value;}
d581d0236211a4488abf9fbdd31dbe09a1931eb7de6075b743d4dbb2339a002f
canDrop
public boolean canDrop(org.apache.parquet.filter2.predicate.Statistics<Float> statistics)
{    float min = statistics.getMin();    float max = statistics.getMax();    Comparator<Float> cmp = statistics.getComparator();    return cmp.compare(floor(min), floor(max)) == 0 && cmp.compare(floor(min), min) != 0 && cmp.compare(floor(max), max) != 0;}
ab904855ee60e64512cecd0e19d9813d57622e232adc76787b530caf12ad7ba2
inverseCanDrop
public boolean inverseCanDrop(org.apache.parquet.filter2.predicate.Statistics<Float> statistics)
{    float min = statistics.getMin();    float max = statistics.getMax();    Comparator<Float> cmp = statistics.getComparator();    return cmp.compare(min, max) == 0 && cmp.compare(floor(min), min) == 0;}
7f7f3f19704e2a738e37683ea1e845cc8989f3ea09f4b8dd10734db5795ded63
keep
public boolean keep(Integer value)
{    return value != null && value % 3 == 0;}
c1678ddb1b8d8d2a99e4166ad23aace6986592bacd121f683b4e4d0bba0d06df
canDrop
public boolean canDrop(org.apache.parquet.filter2.predicate.Statistics<Integer> statistics)
{    int min = statistics.getMin();    int max = statistics.getMax();    return min % 3 != 0 && max % 3 != 0 && max - min < 3;}
8fdd007daa1a7da078bba45e74b0b14ef60a85f6a023e6677c1511f212e2a365
inverseCanDrop
public boolean inverseCanDrop(org.apache.parquet.filter2.predicate.Statistics<Integer> statistics)
{    int min = statistics.getMin();    int max = statistics.getMax();    return min == max && min % 3 == 0;}
6a0ad857c4f18f2d64da235f3e095c2ada5780c75df3139c572f63f22a8e65a5
keep
public boolean keep(Long value)
{    return value != null && value % 3 == 0;}
2061be6cecec56f614ab8bc2462700880b92e5f4bb887f6980372c954d42f353
canDrop
public boolean canDrop(org.apache.parquet.filter2.predicate.Statistics<Long> statistics)
{    long min = statistics.getMin();    long max = statistics.getMax();    return min % 3 != 0 && max % 3 != 0 && max - min < 3;}
0e00c0aab982c7f2da7078ac268417c947e369847b69039ffbc19c31d45bf962
inverseCanDrop
public boolean inverseCanDrop(org.apache.parquet.filter2.predicate.Statistics<Long> statistics)
{    long min = statistics.getMin();    long max = statistics.getMax();    return min == max && min % 3 == 0;}
2e027875489c64c53b879979aa07a8f9eda341f36b540b4789e58be29f86d513
testBuildBinaryDecimal
public void testBuildBinaryDecimal()
{    PrimitiveType type = Types.required(BINARY).as(DECIMAL).precision(12).scale(2).named("test_binary_decimal");    ColumnIndexBuilder builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    assertThat(builder, instanceOf(BinaryColumnIndexBuilder.class));    assertNull(builder.build());    BinaryColumn col = binaryColumn("test_col");    StatsBuilder sb = new StatsBuilder();    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, decimalBinary("-0.17"), decimalBinary("1234567890.12")));    builder.add(sb.stats(type, decimalBinary("-234.23"), null, null, null));    builder.add(sb.stats(type, null, null, null));    builder.add(sb.stats(type, decimalBinary("-9999293.23"), decimalBinary("2348978.45")));    builder.add(sb.stats(type, null, null, null, null));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, decimalBinary("87656273")));    assertEquals(8, builder.getPageCount());    assertEquals(sb.getMinMaxSize(), builder.getMinMaxSize());    ColumnIndex columnIndex = builder.build();    assertEquals(BoundaryOrder.UNORDERED, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 2, 0, 3, 3, 0, 4, 2, 0);    assertCorrectNullPages(columnIndex, true, false, false, true, false, true, true, false);    assertCorrectValues(columnIndex.getMaxValues(), null, decimalBinary("1234567890.12"), decimalBinary("-234.23"), null, decimalBinary("2348978.45"), null, null, decimalBinary("87656273"));    assertCorrectValues(columnIndex.getMinValues(), null, decimalBinary("-0.17"), decimalBinary("-234.23"), null, decimalBinary("-9999293.23"), null, null, decimalBinary("87656273"));    assertCorrectFiltering(columnIndex, eq(col, decimalBinary("0.0")), 1, 4);    assertCorrectFiltering(columnIndex, eq(col, null), 0, 2, 3, 5, 6);    assertCorrectFiltering(columnIndex, notEq(col, decimalBinary("87656273")), 0, 1, 2, 3, 4, 5, 6);    assertCorrectFiltering(columnIndex, notEq(col, null), 1, 2, 4, 7);    assertCorrectFiltering(columnIndex, gt(col, decimalBinary("2348978.45")), 1);    assertCorrectFiltering(columnIndex, gtEq(col, decimalBinary("2348978.45")), 1, 4);    assertCorrectFiltering(columnIndex, lt(col, decimalBinary("-234.23")), 4);    assertCorrectFiltering(columnIndex, ltEq(col, decimalBinary("-234.23")), 2, 4);    assertCorrectFiltering(columnIndex, userDefined(col, BinaryDecimalIsNullOrZeroUdp.class), 0, 1, 2, 3, 4, 5, 6);    assertCorrectFiltering(columnIndex, invert(userDefined(col, BinaryDecimalIsNullOrZeroUdp.class)), 1, 2, 4, 7);    builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    sb = new StatsBuilder();    builder.add(sb.stats(type, null, null, null, null));    builder.add(sb.stats(type, decimalBinary("-9999293.23"), decimalBinary("-234.23")));    builder.add(sb.stats(type, decimalBinary("-0.17"), decimalBinary("87656273")));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, decimalBinary("87656273")));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, decimalBinary("1234567890.12"), null, null, null));    builder.add(sb.stats(type, null, null, null));    assertEquals(8, builder.getPageCount());    assertEquals(sb.getMinMaxSize(), builder.getMinMaxSize());    columnIndex = builder.build();    assertEquals(BoundaryOrder.ASCENDING, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 4, 0, 0, 2, 0, 2, 3, 3);    assertCorrectNullPages(columnIndex, true, false, false, true, false, true, false, true);    assertCorrectValues(columnIndex.getMaxValues(), null, decimalBinary("-234.23"), decimalBinary("87656273"), null, decimalBinary("87656273"), null, decimalBinary("1234567890.12"), null);    assertCorrectValues(columnIndex.getMinValues(), null, decimalBinary("-9999293.23"), decimalBinary("-0.17"), null, decimalBinary("87656273"), null, decimalBinary("1234567890.12"), null);    assertCorrectFiltering(columnIndex, eq(col, decimalBinary("87656273")), 2, 4);    assertCorrectFiltering(columnIndex, eq(col, null), 0, 3, 5, 6, 7);    assertCorrectFiltering(columnIndex, notEq(col, decimalBinary("87656273")), 0, 1, 2, 3, 5, 6, 7);    assertCorrectFiltering(columnIndex, notEq(col, null), 1, 2, 4, 6);    assertCorrectFiltering(columnIndex, gt(col, decimalBinary("87656273")), 6);    assertCorrectFiltering(columnIndex, gtEq(col, decimalBinary("87656273")), 2, 4, 6);    assertCorrectFiltering(columnIndex, lt(col, decimalBinary("-0.17")), 1);    assertCorrectFiltering(columnIndex, ltEq(col, decimalBinary("-0.17")), 1, 2);    assertCorrectFiltering(columnIndex, userDefined(col, BinaryDecimalIsNullOrZeroUdp.class), 0, 2, 3, 5, 6, 7);    assertCorrectFiltering(columnIndex, invert(userDefined(col, BinaryDecimalIsNullOrZeroUdp.class)), 1, 2, 4, 6);    builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    sb = new StatsBuilder();    builder.add(sb.stats(type, null, null, null));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, decimalBinary("1234567890.12"), null, null, null));    builder.add(sb.stats(type, null, null, null, null));    builder.add(sb.stats(type, decimalBinary("1234567890.12"), decimalBinary("87656273")));    builder.add(sb.stats(type, decimalBinary("987656273"), decimalBinary("-0.17")));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, decimalBinary("-234.23"), decimalBinary("-9999293.23")));    assertEquals(8, builder.getPageCount());    assertEquals(sb.getMinMaxSize(), builder.getMinMaxSize());    columnIndex = builder.build();    assertEquals(BoundaryOrder.DESCENDING, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 3, 2, 3, 4, 0, 0, 2, 0);    assertCorrectNullPages(columnIndex, true, true, false, true, false, false, true, false);    assertCorrectValues(columnIndex.getMaxValues(), null, null, decimalBinary("1234567890.12"), null, decimalBinary("1234567890.12"), decimalBinary("987656273"), null, decimalBinary("-234.23"));    assertCorrectValues(columnIndex.getMinValues(), null, null, decimalBinary("1234567890.12"), null, decimalBinary("87656273"), decimalBinary("-0.17"), null, decimalBinary("-9999293.23"));    assertCorrectFiltering(columnIndex, eq(col, decimalBinary("1234567890.12")), 2, 4);    assertCorrectFiltering(columnIndex, eq(col, null), 0, 1, 2, 3, 6);    assertCorrectFiltering(columnIndex, notEq(col, decimalBinary("0.0")), 0, 1, 2, 3, 4, 5, 6, 7);    assertCorrectFiltering(columnIndex, notEq(col, null), 2, 4, 5, 7);    assertCorrectFiltering(columnIndex, gt(col, decimalBinary("1234567890.12")));    assertCorrectFiltering(columnIndex, gtEq(col, decimalBinary("1234567890.12")), 2, 4);    assertCorrectFiltering(columnIndex, lt(col, decimalBinary("-0.17")), 7);    assertCorrectFiltering(columnIndex, ltEq(col, decimalBinary("-0.17")), 5, 7);    assertCorrectFiltering(columnIndex, userDefined(col, BinaryDecimalIsNullOrZeroUdp.class), 0, 1, 2, 3, 5, 6);    assertCorrectFiltering(columnIndex, invert(userDefined(col, BinaryDecimalIsNullOrZeroUdp.class)), 2, 4, 5, 7);}
b12503bcb08dbdaa5afbc00d0fbc29fe7ebefe1a9547c6c053af55c8ab9f6a9a
testBuildBinaryUtf8
public void testBuildBinaryUtf8()
{    PrimitiveType type = Types.required(BINARY).as(UTF8).named("test_binary_utf8");    ColumnIndexBuilder builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    assertThat(builder, instanceOf(BinaryColumnIndexBuilder.class));    assertNull(builder.build());    BinaryColumn col = binaryColumn("test_col");    StatsBuilder sb = new StatsBuilder();    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, stringBinary("Jeltz"), stringBinary("Slartibartfast"), null, null));    builder.add(sb.stats(type, null, null, null, null, null));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, stringBinary("Beeblebrox"), stringBinary("Prefect")));    builder.add(sb.stats(type, stringBinary("Dent"), stringBinary("Trilian"), null));    builder.add(sb.stats(type, stringBinary("Beeblebrox")));    builder.add(sb.stats(type, null, null));    assertEquals(8, builder.getPageCount());    assertEquals(sb.getMinMaxSize(), builder.getMinMaxSize());    ColumnIndex columnIndex = builder.build();    assertEquals(BoundaryOrder.UNORDERED, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 2, 2, 5, 2, 0, 1, 0, 2);    assertCorrectNullPages(columnIndex, true, false, true, true, false, false, false, true);    assertCorrectValues(columnIndex.getMaxValues(), null, stringBinary("Slartibartfast"), null, null, stringBinary("Prefect"), stringBinary("Trilian"), stringBinary("Beeblebrox"), null);    assertCorrectValues(columnIndex.getMinValues(), null, stringBinary("Jeltz"), null, null, stringBinary("Beeblebrox"), stringBinary("Dent"), stringBinary("Beeblebrox"), null);    assertCorrectFiltering(columnIndex, eq(col, stringBinary("Marvin")), 1, 4, 5);    assertCorrectFiltering(columnIndex, eq(col, null), 0, 1, 2, 3, 5, 7);    assertCorrectFiltering(columnIndex, notEq(col, stringBinary("Beeblebrox")), 0, 1, 2, 3, 4, 5, 7);    assertCorrectFiltering(columnIndex, notEq(col, null), 1, 4, 5, 6);    assertCorrectFiltering(columnIndex, gt(col, stringBinary("Prefect")), 1, 5);    assertCorrectFiltering(columnIndex, gtEq(col, stringBinary("Prefect")), 1, 4, 5);    assertCorrectFiltering(columnIndex, lt(col, stringBinary("Dent")), 4, 6);    assertCorrectFiltering(columnIndex, ltEq(col, stringBinary("Dent")), 4, 5, 6);    assertCorrectFiltering(columnIndex, userDefined(col, BinaryUtf8StartsWithB.class), 4, 6);    assertCorrectFiltering(columnIndex, invert(userDefined(col, BinaryUtf8StartsWithB.class)), 0, 1, 2, 3, 4, 5, 7);    builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    sb = new StatsBuilder();    builder.add(sb.stats(type, stringBinary("Beeblebrox"), stringBinary("Dent"), null, null));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, null, null, null, null, null));    builder.add(sb.stats(type, stringBinary("Dent"), stringBinary("Jeltz")));    builder.add(sb.stats(type, stringBinary("Dent"), stringBinary("Prefect"), null));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, stringBinary("Slartibartfast")));    builder.add(sb.stats(type, null, null));    assertEquals(8, builder.getPageCount());    assertEquals(sb.getMinMaxSize(), builder.getMinMaxSize());    columnIndex = builder.build();    assertEquals(BoundaryOrder.ASCENDING, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 2, 2, 5, 0, 1, 2, 0, 2);    assertCorrectNullPages(columnIndex, false, true, true, false, false, true, false, true);    assertCorrectValues(columnIndex.getMaxValues(), stringBinary("Dent"), null, null, stringBinary("Jeltz"), stringBinary("Prefect"), null, stringBinary("Slartibartfast"), null);    assertCorrectValues(columnIndex.getMinValues(), stringBinary("Beeblebrox"), null, null, stringBinary("Dent"), stringBinary("Dent"), null, stringBinary("Slartibartfast"), null);    assertCorrectFiltering(columnIndex, eq(col, stringBinary("Jeltz")), 3, 4);    assertCorrectFiltering(columnIndex, eq(col, null), 0, 1, 2, 4, 5, 7);    assertCorrectFiltering(columnIndex, notEq(col, stringBinary("Slartibartfast")), 0, 1, 2, 3, 4, 5, 7);    assertCorrectFiltering(columnIndex, notEq(col, null), 0, 3, 4, 6);    assertCorrectFiltering(columnIndex, gt(col, stringBinary("Marvin")), 4, 6);    assertCorrectFiltering(columnIndex, gtEq(col, stringBinary("Marvin")), 4, 6);    assertCorrectFiltering(columnIndex, lt(col, stringBinary("Dent")), 0);    assertCorrectFiltering(columnIndex, ltEq(col, stringBinary("Dent")), 0, 3, 4);    assertCorrectFiltering(columnIndex, userDefined(col, BinaryUtf8StartsWithB.class), 0);    assertCorrectFiltering(columnIndex, invert(userDefined(col, BinaryUtf8StartsWithB.class)), 0, 1, 2, 3, 4, 5, 6, 7);    builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    sb = new StatsBuilder();    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, stringBinary("Slartibartfast")));    builder.add(sb.stats(type, null, null, null, null, null));    builder.add(sb.stats(type, stringBinary("Prefect"), stringBinary("Jeltz"), null));    builder.add(sb.stats(type, stringBinary("Dent"), stringBinary("Dent")));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, stringBinary("Dent"), stringBinary("Beeblebrox"), null, null));    assertEquals(8, builder.getPageCount());    assertEquals(sb.getMinMaxSize(), builder.getMinMaxSize());    columnIndex = builder.build();    assertEquals(BoundaryOrder.DESCENDING, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 2, 0, 5, 1, 0, 2, 2, 2);    assertCorrectNullPages(columnIndex, true, false, true, false, false, true, true, false);    assertCorrectValues(columnIndex.getMaxValues(), null, stringBinary("Slartibartfast"), null, stringBinary("Prefect"), stringBinary("Dent"), null, null, stringBinary("Dent"));    assertCorrectValues(columnIndex.getMinValues(), null, stringBinary("Slartibartfast"), null, stringBinary("Jeltz"), stringBinary("Dent"), null, null, stringBinary("Beeblebrox"));    assertCorrectFiltering(columnIndex, eq(col, stringBinary("Marvin")), 3);    assertCorrectFiltering(columnIndex, eq(col, null), 0, 2, 3, 5, 6, 7);    assertCorrectFiltering(columnIndex, notEq(col, stringBinary("Dent")), 0, 1, 2, 3, 5, 6, 7);    assertCorrectFiltering(columnIndex, notEq(col, null), 1, 3, 4, 7);    assertCorrectFiltering(columnIndex, gt(col, stringBinary("Prefect")), 1);    assertCorrectFiltering(columnIndex, gtEq(col, stringBinary("Prefect")), 1, 3);    assertCorrectFiltering(columnIndex, lt(col, stringBinary("Marvin")), 3, 4, 7);    assertCorrectFiltering(columnIndex, ltEq(col, stringBinary("Marvin")), 3, 4, 7);    assertCorrectFiltering(columnIndex, userDefined(col, BinaryUtf8StartsWithB.class), 7);    assertCorrectFiltering(columnIndex, invert(userDefined(col, BinaryUtf8StartsWithB.class)), 0, 1, 2, 3, 4, 5, 6, 7);}
f6614dde54b48ac1bdd9f34ad653708e0875013690487ccf3164d95fb236d5c0
testStaticBuildBinary
public void testStaticBuildBinary()
{    ColumnIndex columnIndex = ColumnIndexBuilder.build(Types.required(BINARY).as(UTF8).named("test_binary_utf8"), BoundaryOrder.ASCENDING, asList(true, true, false, false, true, false, true, false), asList(1l, 2l, 3l, 4l, 5l, 6l, 7l, 8l), toBBList(null, null, stringBinary("Beeblebrox"), stringBinary("Dent"), null, stringBinary("Jeltz"), null, stringBinary("Slartibartfast")), toBBList(null, null, stringBinary("Dent"), stringBinary("Dent"), null, stringBinary("Prefect"), null, stringBinary("Slartibartfast")));    assertEquals(BoundaryOrder.ASCENDING, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 1, 2, 3, 4, 5, 6, 7, 8);    assertCorrectNullPages(columnIndex, true, true, false, false, true, false, true, false);    assertCorrectValues(columnIndex.getMaxValues(), null, null, stringBinary("Dent"), stringBinary("Dent"), null, stringBinary("Prefect"), null, stringBinary("Slartibartfast"));    assertCorrectValues(columnIndex.getMinValues(), null, null, stringBinary("Beeblebrox"), stringBinary("Dent"), null, stringBinary("Jeltz"), null, stringBinary("Slartibartfast"));}
7199db630e625c13b98dae391ed791cd66228181126764482fb266d007d1373f
testFilterWithoutNullCounts
public void testFilterWithoutNullCounts()
{    ColumnIndex columnIndex = ColumnIndexBuilder.build(Types.required(BINARY).as(UTF8).named("test_binary_utf8"), BoundaryOrder.ASCENDING, asList(true, true, false, false, true, false, true, false), null, toBBList(null, null, stringBinary("Beeblebrox"), stringBinary("Dent"), null, stringBinary("Jeltz"), null, stringBinary("Slartibartfast")), toBBList(null, null, stringBinary("Dent"), stringBinary("Dent"), null, stringBinary("Prefect"), null, stringBinary("Slartibartfast")));    assertEquals(BoundaryOrder.ASCENDING, columnIndex.getBoundaryOrder());    assertNull(columnIndex.getNullCounts());    assertCorrectNullPages(columnIndex, true, true, false, false, true, false, true, false);    assertCorrectValues(columnIndex.getMaxValues(), null, null, stringBinary("Dent"), stringBinary("Dent"), null, stringBinary("Prefect"), null, stringBinary("Slartibartfast"));    assertCorrectValues(columnIndex.getMinValues(), null, null, stringBinary("Beeblebrox"), stringBinary("Dent"), null, stringBinary("Jeltz"), null, stringBinary("Slartibartfast"));    BinaryColumn col = binaryColumn("test_col");    assertCorrectFiltering(columnIndex, eq(col, stringBinary("Dent")), 2, 3);    assertCorrectFiltering(columnIndex, eq(col, null), 0, 1, 2, 3, 4, 5, 6, 7);    assertCorrectFiltering(columnIndex, notEq(col, stringBinary("Dent")), 0, 1, 2, 3, 4, 5, 6, 7);    assertCorrectFiltering(columnIndex, notEq(col, null), 2, 3, 5, 7);    assertCorrectFiltering(columnIndex, userDefined(col, BinaryDecimalIsNullOrZeroUdp.class), 0, 1, 2, 3, 4, 5, 6, 7);    assertCorrectFiltering(columnIndex, invert(userDefined(col, BinaryDecimalIsNullOrZeroUdp.class)), 2, 3, 5, 7);}
e8d9b4c10ef30c9581fac971800293fccb1a28b32ed785339ef5e1523d69dcca
testBuildBoolean
public void testBuildBoolean()
{    PrimitiveType type = Types.required(BOOLEAN).named("test_boolean");    ColumnIndexBuilder builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    assertThat(builder, instanceOf(BooleanColumnIndexBuilder.class));    assertNull(builder.build());    BooleanColumn col = booleanColumn("test_col");    builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    StatsBuilder sb = new StatsBuilder();    builder.add(sb.stats(type, false, true));    builder.add(sb.stats(type, true, false, null));    builder.add(sb.stats(type, true, true, null, null));    builder.add(sb.stats(type, null, null, null));    builder.add(sb.stats(type, false, false));    assertEquals(5, builder.getPageCount());    assertEquals(sb.getMinMaxSize(), builder.getMinMaxSize());    ColumnIndex columnIndex = builder.build();    assertEquals(BoundaryOrder.UNORDERED, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 0, 1, 2, 3, 0);    assertCorrectNullPages(columnIndex, false, false, false, true, false);    assertCorrectValues(columnIndex.getMaxValues(), true, true, true, null, false);    assertCorrectValues(columnIndex.getMinValues(), false, false, true, null, false);    assertCorrectFiltering(columnIndex, eq(col, true), 0, 1, 2);    assertCorrectFiltering(columnIndex, eq(col, null), 1, 2, 3);    assertCorrectFiltering(columnIndex, notEq(col, true), 0, 1, 2, 3, 4);    assertCorrectFiltering(columnIndex, notEq(col, null), 0, 1, 2, 4);    assertCorrectFiltering(columnIndex, userDefined(col, BooleanIsTrueOrNull.class), 0, 1, 2, 3);    assertCorrectFiltering(columnIndex, invert(userDefined(col, BooleanIsTrueOrNull.class)), 0, 1, 4);    builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    sb = new StatsBuilder();    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, false, false));    builder.add(sb.stats(type, null, null, null));    builder.add(sb.stats(type, null, null, null, null));    builder.add(sb.stats(type, false, true, null));    builder.add(sb.stats(type, false, true, null, null));    builder.add(sb.stats(type, null, null, null));    assertEquals(7, builder.getPageCount());    assertEquals(sb.getMinMaxSize(), builder.getMinMaxSize());    columnIndex = builder.build();    assertEquals(BoundaryOrder.ASCENDING, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 2, 0, 3, 4, 1, 2, 3);    assertCorrectNullPages(columnIndex, true, false, true, true, false, false, true);    assertCorrectValues(columnIndex.getMaxValues(), null, false, null, null, true, true, null);    assertCorrectValues(columnIndex.getMinValues(), null, false, null, null, false, false, null);    assertCorrectFiltering(columnIndex, eq(col, true), 4, 5);    assertCorrectFiltering(columnIndex, eq(col, null), 0, 2, 3, 4, 5, 6);    assertCorrectFiltering(columnIndex, notEq(col, true), 0, 1, 2, 3, 4, 5, 6);    assertCorrectFiltering(columnIndex, notEq(col, null), 1, 4, 5);    assertCorrectFiltering(columnIndex, userDefined(col, BooleanIsTrueOrNull.class), 0, 2, 3, 4, 5, 6);    assertCorrectFiltering(columnIndex, invert(userDefined(col, BooleanIsTrueOrNull.class)), 1, 4, 5);    builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    sb = new StatsBuilder();    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, true, true));    builder.add(sb.stats(type, null, null, null));    builder.add(sb.stats(type, null, null, null, null));    builder.add(sb.stats(type, true, false, null));    builder.add(sb.stats(type, false, false, null, null));    builder.add(sb.stats(type, null, null, null));    assertEquals(7, builder.getPageCount());    assertEquals(sb.getMinMaxSize(), builder.getMinMaxSize());    columnIndex = builder.build();    assertEquals(BoundaryOrder.DESCENDING, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 2, 0, 3, 4, 1, 2, 3);    assertCorrectNullPages(columnIndex, true, false, true, true, false, false, true);    assertCorrectValues(columnIndex.getMaxValues(), null, true, null, null, true, false, null);    assertCorrectValues(columnIndex.getMinValues(), null, true, null, null, false, false, null);    assertCorrectFiltering(columnIndex, eq(col, true), 1, 4);    assertCorrectFiltering(columnIndex, eq(col, null), 0, 2, 3, 4, 5, 6);    assertCorrectFiltering(columnIndex, notEq(col, true), 0, 2, 3, 4, 5, 6);    assertCorrectFiltering(columnIndex, notEq(col, null), 1, 4, 5);    assertCorrectFiltering(columnIndex, userDefined(col, BooleanIsTrueOrNull.class), 0, 1, 2, 3, 4, 5, 6);    assertCorrectFiltering(columnIndex, invert(userDefined(col, BooleanIsTrueOrNull.class)), 4, 5);}
cf2215a7f578ffb99a38e171cdc9ad63a1c0ccc41970cc24901b1e562e3f0fd1
testStaticBuildBoolean
public void testStaticBuildBoolean()
{    ColumnIndex columnIndex = ColumnIndexBuilder.build(Types.required(BOOLEAN).named("test_boolean"), BoundaryOrder.DESCENDING, asList(false, true, false, true, false, true), asList(9l, 8l, 7l, 6l, 5l, 0l), toBBList(false, null, false, null, true, null), toBBList(true, null, false, null, true, null));    assertEquals(BoundaryOrder.DESCENDING, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 9, 8, 7, 6, 5, 0);    assertCorrectNullPages(columnIndex, false, true, false, true, false, true);    assertCorrectValues(columnIndex.getMaxValues(), true, null, false, null, true, null);    assertCorrectValues(columnIndex.getMinValues(), false, null, false, null, true, null);}
78af92ec5598ebcb6b6f6dec06d2cd55e53025046e75530494dbdf46dde61f27
testBuildDouble
public void testBuildDouble()
{    PrimitiveType type = Types.required(DOUBLE).named("test_double");    ColumnIndexBuilder builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    assertThat(builder, instanceOf(DoubleColumnIndexBuilder.class));    assertNull(builder.build());    DoubleColumn col = doubleColumn("test_col");    StatsBuilder sb = new StatsBuilder();    builder.add(sb.stats(type, -4.2, -4.1));    builder.add(sb.stats(type, -11.7, 7.0, null));    builder.add(sb.stats(type, 2.2, 2.2, null, null));    builder.add(sb.stats(type, null, null, null));    builder.add(sb.stats(type, 1.9, 2.32));    builder.add(sb.stats(type, -21.0, 8.1));    assertEquals(6, builder.getPageCount());    assertEquals(sb.getMinMaxSize(), builder.getMinMaxSize());    ColumnIndex columnIndex = builder.build();    assertEquals(BoundaryOrder.UNORDERED, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 0, 1, 2, 3, 0, 0);    assertCorrectNullPages(columnIndex, false, false, false, true, false, false);    assertCorrectValues(columnIndex.getMaxValues(), -4.1, 7.0, 2.2, null, 2.32, 8.1);    assertCorrectValues(columnIndex.getMinValues(), -4.2, -11.7, 2.2, null, 1.9, -21.0);    assertCorrectFiltering(columnIndex, eq(col, 0.0), 1, 5);    assertCorrectFiltering(columnIndex, eq(col, null), 1, 2, 3);    assertCorrectFiltering(columnIndex, notEq(col, 2.2), 0, 1, 2, 3, 4, 5);    assertCorrectFiltering(columnIndex, notEq(col, null), 0, 1, 2, 4, 5);    assertCorrectFiltering(columnIndex, gt(col, 2.2), 1, 4, 5);    assertCorrectFiltering(columnIndex, gtEq(col, 2.2), 1, 2, 4, 5);    assertCorrectFiltering(columnIndex, lt(col, -4.2), 1, 5);    assertCorrectFiltering(columnIndex, ltEq(col, -4.2), 0, 1, 5);    assertCorrectFiltering(columnIndex, userDefined(col, DoubleIsInteger.class), 1, 4, 5);    assertCorrectFiltering(columnIndex, invert(userDefined(col, DoubleIsInteger.class)), 0, 1, 2, 3, 4, 5);    builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    sb = new StatsBuilder();    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, -532.3, -345.2, null, null));    builder.add(sb.stats(type, -234.7, -234.6, null));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, null, null, null));    builder.add(sb.stats(type, -234.6, 2.99999));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, 3.0, 42.83));    builder.add(sb.stats(type, null, null));    assertEquals(9, builder.getPageCount());    assertEquals(sb.getMinMaxSize(), builder.getMinMaxSize());    columnIndex = builder.build();    assertEquals(BoundaryOrder.ASCENDING, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 2, 2, 1, 2, 3, 0, 2, 0, 2);    assertCorrectNullPages(columnIndex, true, false, false, true, true, false, true, false, true);    assertCorrectValues(columnIndex.getMaxValues(), null, -345.2, -234.6, null, null, 2.99999, null, 42.83, null);    assertCorrectValues(columnIndex.getMinValues(), null, -532.3, -234.7, null, null, -234.6, null, 3.0, null);    assertCorrectFiltering(columnIndex, eq(col, 0.0), 5);    assertCorrectFiltering(columnIndex, eq(col, null), 0, 1, 2, 3, 4, 6, 8);    assertCorrectFiltering(columnIndex, notEq(col, 0.0), 0, 1, 2, 3, 4, 5, 6, 7, 8);    assertCorrectFiltering(columnIndex, notEq(col, null), 1, 2, 5, 7);    assertCorrectFiltering(columnIndex, gt(col, 2.99999), 7);    assertCorrectFiltering(columnIndex, gtEq(col, 2.99999), 5, 7);    assertCorrectFiltering(columnIndex, lt(col, -234.6), 1, 2);    assertCorrectFiltering(columnIndex, ltEq(col, -234.6), 1, 2, 5);    assertCorrectFiltering(columnIndex, userDefined(col, DoubleIsInteger.class), 1, 5, 7);    assertCorrectFiltering(columnIndex, invert(userDefined(col, DoubleIsInteger.class)), 0, 1, 2, 3, 4, 5, 6, 7, 8);    builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    sb = new StatsBuilder();    builder.add(sb.stats(type, null, null, null, null, null));    builder.add(sb.stats(type, 532.3, 345.2));    builder.add(sb.stats(type, null, null, null));    builder.add(sb.stats(type, 234.7, 234.6, null));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, 234.69, -2.99999));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, -3.0, -42.83));    assertEquals(9, builder.getPageCount());    assertEquals(sb.getMinMaxSize(), builder.getMinMaxSize());    columnIndex = builder.build();    assertEquals(BoundaryOrder.DESCENDING, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 5, 0, 3, 1, 2, 0, 2, 2, 0);    assertCorrectNullPages(columnIndex, true, false, true, false, true, false, true, true, false);    assertCorrectValues(columnIndex.getMaxValues(), null, 532.3, null, 234.7, null, 234.69, null, null, -3.0);    assertCorrectValues(columnIndex.getMinValues(), null, 345.2, null, 234.6, null, -2.99999, null, null, -42.83);    assertCorrectFiltering(columnIndex, eq(col, 234.6), 3, 5);    assertCorrectFiltering(columnIndex, eq(col, null), 0, 2, 3, 4, 6, 7);    assertCorrectFiltering(columnIndex, notEq(col, 2.2), 0, 1, 2, 3, 4, 5, 6, 7, 8);    assertCorrectFiltering(columnIndex, notEq(col, null), 1, 3, 5, 8);    assertCorrectFiltering(columnIndex, gt(col, 2.2), 1, 3, 5);    assertCorrectFiltering(columnIndex, gtEq(col, 234.69), 1, 3, 5);    assertCorrectFiltering(columnIndex, lt(col, -2.99999), 8);    assertCorrectFiltering(columnIndex, ltEq(col, -2.99999), 5, 8);    assertCorrectFiltering(columnIndex, userDefined(col, DoubleIsInteger.class), 1, 5, 8);    assertCorrectFiltering(columnIndex, invert(userDefined(col, DoubleIsInteger.class)), 0, 1, 2, 3, 4, 5, 6, 7, 8);}
7aea0f76481886d98c697d82ecf5cca27a1cf372eff0340d6006c292cb6070f0
testBuildDoubleZeroNaN
public void testBuildDoubleZeroNaN()
{    PrimitiveType type = Types.required(DOUBLE).named("test_double");    ColumnIndexBuilder builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    StatsBuilder sb = new StatsBuilder();    builder.add(sb.stats(type, -1.0, -0.0));    builder.add(sb.stats(type, 0.0, 1.0));    builder.add(sb.stats(type, 1.0, 100.0));    ColumnIndex columnIndex = builder.build();    assertCorrectValues(columnIndex.getMinValues(), -1.0, -0.0, 1.0);    assertCorrectValues(columnIndex.getMaxValues(), 0.0, 1.0, 100.0);    builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    builder.add(sb.stats(type, -1.0, -0.0));    builder.add(sb.stats(type, 0.0, Double.NaN));    builder.add(sb.stats(type, 1.0, 100.0));    assertNull(builder.build());}
909c31fef82fae974beeb4a8575789eb1dc5cb99126e0950970bbc6a21d6eb32
testStaticBuildDouble
public void testStaticBuildDouble()
{    ColumnIndex columnIndex = ColumnIndexBuilder.build(Types.required(DOUBLE).named("test_double"), BoundaryOrder.UNORDERED, asList(false, false, false, false, false, false), asList(0l, 1l, 2l, 3l, 4l, 5l), toBBList(-1.0, -2.0, -3.0, -4.0, -5.0, -6.0), toBBList(1.0, 2.0, 3.0, 4.0, 5.0, 6.0));    assertEquals(BoundaryOrder.UNORDERED, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 0, 1, 2, 3, 4, 5);    assertCorrectNullPages(columnIndex, false, false, false, false, false, false);    assertCorrectValues(columnIndex.getMaxValues(), 1.0, 2.0, 3.0, 4.0, 5.0, 6.0);    assertCorrectValues(columnIndex.getMinValues(), -1.0, -2.0, -3.0, -4.0, -5.0, -6.0);}
695c08004c76eb7ef495277f4081e27b39ace144a82cac0a1f2261c512215a79
testBuildFloat
public void testBuildFloat()
{    PrimitiveType type = Types.required(FLOAT).named("test_float");    ColumnIndexBuilder builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    assertThat(builder, instanceOf(FloatColumnIndexBuilder.class));    assertNull(builder.build());    FloatColumn col = floatColumn("test_col");    StatsBuilder sb = new StatsBuilder();    builder.add(sb.stats(type, -4.2f, -4.1f));    builder.add(sb.stats(type, -11.7f, 7.0f, null));    builder.add(sb.stats(type, 2.2f, 2.2f, null, null));    builder.add(sb.stats(type, null, null, null));    builder.add(sb.stats(type, 1.9f, 2.32f));    builder.add(sb.stats(type, -21.0f, 8.1f));    assertEquals(6, builder.getPageCount());    assertEquals(sb.getMinMaxSize(), builder.getMinMaxSize());    ColumnIndex columnIndex = builder.build();    assertEquals(BoundaryOrder.UNORDERED, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 0, 1, 2, 3, 0, 0);    assertCorrectNullPages(columnIndex, false, false, false, true, false, false);    assertCorrectValues(columnIndex.getMaxValues(), -4.1f, 7.0f, 2.2f, null, 2.32f, 8.1f);    assertCorrectValues(columnIndex.getMinValues(), -4.2f, -11.7f, 2.2f, null, 1.9f, -21.0f);    assertCorrectFiltering(columnIndex, eq(col, 0.0f), 1, 5);    assertCorrectFiltering(columnIndex, eq(col, null), 1, 2, 3);    assertCorrectFiltering(columnIndex, notEq(col, 2.2f), 0, 1, 2, 3, 4, 5);    assertCorrectFiltering(columnIndex, notEq(col, null), 0, 1, 2, 4, 5);    assertCorrectFiltering(columnIndex, gt(col, 2.2f), 1, 4, 5);    assertCorrectFiltering(columnIndex, gtEq(col, 2.2f), 1, 2, 4, 5);    assertCorrectFiltering(columnIndex, lt(col, 0.0f), 0, 1, 5);    assertCorrectFiltering(columnIndex, ltEq(col, 1.9f), 0, 1, 4, 5);    assertCorrectFiltering(columnIndex, userDefined(col, FloatIsInteger.class), 1, 4, 5);    assertCorrectFiltering(columnIndex, invert(userDefined(col, FloatIsInteger.class)), 0, 1, 2, 3, 4, 5);    builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    sb = new StatsBuilder();    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, -532.3f, -345.2f, null, null));    builder.add(sb.stats(type, -300.6f, -234.7f, null));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, null, null, null));    builder.add(sb.stats(type, -234.6f, 2.99999f));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, 3.0f, 42.83f));    builder.add(sb.stats(type, null, null));    assertEquals(9, builder.getPageCount());    assertEquals(sb.getMinMaxSize(), builder.getMinMaxSize());    columnIndex = builder.build();    assertEquals(BoundaryOrder.ASCENDING, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 2, 2, 1, 2, 3, 0, 2, 0, 2);    assertCorrectNullPages(columnIndex, true, false, false, true, true, false, true, false, true);    assertCorrectValues(columnIndex.getMaxValues(), null, -345.2f, -234.7f, null, null, 2.99999f, null, 42.83f, null);    assertCorrectValues(columnIndex.getMinValues(), null, -532.3f, -300.6f, null, null, -234.6f, null, 3.0f, null);    assertCorrectFiltering(columnIndex, eq(col, 0.0f), 5);    assertCorrectFiltering(columnIndex, eq(col, null), 0, 1, 2, 3, 4, 6, 8);    assertCorrectFiltering(columnIndex, notEq(col, 2.2f), 0, 1, 2, 3, 4, 5, 6, 7, 8);    assertCorrectFiltering(columnIndex, notEq(col, null), 1, 2, 5, 7);    assertCorrectFiltering(columnIndex, gt(col, 2.2f), 5, 7);    assertCorrectFiltering(columnIndex, gtEq(col, -234.7f), 2, 5, 7);    assertCorrectFiltering(columnIndex, lt(col, -234.6f), 1, 2);    assertCorrectFiltering(columnIndex, ltEq(col, -234.6f), 1, 2, 5);    assertCorrectFiltering(columnIndex, userDefined(col, FloatIsInteger.class), 1, 2, 5, 7);    assertCorrectFiltering(columnIndex, invert(userDefined(col, FloatIsInteger.class)), 0, 1, 2, 3, 4, 5, 6, 7, 8);    builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    sb = new StatsBuilder();    builder.add(sb.stats(type, null, null, null, null, null));    builder.add(sb.stats(type, 532.3f, 345.2f));    builder.add(sb.stats(type, null, null, null));    builder.add(sb.stats(type, 234.7f, 234.6f, null));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, 234.6f, -2.99999f));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, -3.0f, -42.83f));    assertEquals(9, builder.getPageCount());    assertEquals(sb.getMinMaxSize(), builder.getMinMaxSize());    columnIndex = builder.build();    assertEquals(BoundaryOrder.DESCENDING, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 5, 0, 3, 1, 2, 0, 2, 2, 0);    assertCorrectNullPages(columnIndex, true, false, true, false, true, false, true, true, false);    assertCorrectValues(columnIndex.getMaxValues(), null, 532.3f, null, 234.7f, null, 234.6f, null, null, -3.0f);    assertCorrectValues(columnIndex.getMinValues(), null, 345.2f, null, 234.6f, null, -2.99999f, null, null, -42.83f);    assertCorrectFiltering(columnIndex, eq(col, 234.65f), 3);    assertCorrectFiltering(columnIndex, eq(col, null), 0, 2, 3, 4, 6, 7);    assertCorrectFiltering(columnIndex, notEq(col, 2.2f), 0, 1, 2, 3, 4, 5, 6, 7, 8);    assertCorrectFiltering(columnIndex, notEq(col, null), 1, 3, 5, 8);    assertCorrectFiltering(columnIndex, gt(col, 2.2f), 1, 3, 5);    assertCorrectFiltering(columnIndex, gtEq(col, 2.2f), 1, 3, 5);    assertCorrectFiltering(columnIndex, lt(col, 0.0f), 5, 8);    assertCorrectFiltering(columnIndex, ltEq(col, 0.0f), 5, 8);    assertCorrectFiltering(columnIndex, userDefined(col, FloatIsInteger.class), 1, 5, 8);    assertCorrectFiltering(columnIndex, invert(userDefined(col, FloatIsInteger.class)), 0, 1, 2, 3, 4, 5, 6, 7, 8);}
baac98043558edcc025c3fcfb01fc2b2bc3944e05b993090c0dd359e2e8a9a9f
testBuildFloatZeroNaN
public void testBuildFloatZeroNaN()
{    PrimitiveType type = Types.required(FLOAT).named("test_float");    ColumnIndexBuilder builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    StatsBuilder sb = new StatsBuilder();    builder.add(sb.stats(type, -1.0f, -0.0f));    builder.add(sb.stats(type, 0.0f, 1.0f));    builder.add(sb.stats(type, 1.0f, 100.0f));    ColumnIndex columnIndex = builder.build();    assertCorrectValues(columnIndex.getMinValues(), -1.0f, -0.0f, 1.0f);    assertCorrectValues(columnIndex.getMaxValues(), 0.0f, 1.0f, 100.0f);    builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    builder.add(sb.stats(type, -1.0f, -0.0f));    builder.add(sb.stats(type, 0.0f, Float.NaN));    builder.add(sb.stats(type, 1.0f, 100.0f));    assertNull(builder.build());}
0293fb4d0af452c65def09571e0f3ba0d0bba7d86b3fdb0afbc0a48d35c55d92
testStaticBuildFloat
public void testStaticBuildFloat()
{    ColumnIndex columnIndex = ColumnIndexBuilder.build(Types.required(FLOAT).named("test_float"), BoundaryOrder.ASCENDING, asList(true, true, true, false, false, false), asList(9l, 8l, 7l, 6l, 0l, 0l), toBBList(null, null, null, -3.0f, -2.0f, 0.1f), toBBList(null, null, null, -2.0f, 0.0f, 6.0f));    assertEquals(BoundaryOrder.ASCENDING, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 9, 8, 7, 6, 0, 0);    assertCorrectNullPages(columnIndex, true, true, true, false, false, false);    assertCorrectValues(columnIndex.getMaxValues(), null, null, null, -2.0f, 0.0f, 6.0f);    assertCorrectValues(columnIndex.getMinValues(), null, null, null, -3.0f, -2.0f, 0.1f);}
28ee4a3258c7fd99a9d2167b558bb0badf3078107d20eb01ae7cd374a06778f5
testBuildInt32
public void testBuildInt32()
{    PrimitiveType type = Types.required(INT32).named("test_int32");    ColumnIndexBuilder builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    assertThat(builder, instanceOf(IntColumnIndexBuilder.class));    assertNull(builder.build());    IntColumn col = intColumn("test_col");    StatsBuilder sb = new StatsBuilder();    builder.add(sb.stats(type, -4, 10));    builder.add(sb.stats(type, -11, 7, null));    builder.add(sb.stats(type, 2, 2, null, null));    builder.add(sb.stats(type, null, null, null));    builder.add(sb.stats(type, 1, 2));    builder.add(sb.stats(type, -21, 8));    assertEquals(6, builder.getPageCount());    assertEquals(sb.getMinMaxSize(), builder.getMinMaxSize());    ColumnIndex columnIndex = builder.build();    assertEquals(BoundaryOrder.UNORDERED, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 0, 1, 2, 3, 0, 0);    assertCorrectNullPages(columnIndex, false, false, false, true, false, false);    assertCorrectValues(columnIndex.getMaxValues(), 10, 7, 2, null, 2, 8);    assertCorrectValues(columnIndex.getMinValues(), -4, -11, 2, null, 1, -21);    assertCorrectFiltering(columnIndex, eq(col, 2), 0, 1, 2, 4, 5);    assertCorrectFiltering(columnIndex, eq(col, null), 1, 2, 3);    assertCorrectFiltering(columnIndex, notEq(col, 2), 0, 1, 2, 3, 4, 5);    assertCorrectFiltering(columnIndex, notEq(col, null), 0, 1, 2, 4, 5);    assertCorrectFiltering(columnIndex, gt(col, 2), 0, 1, 5);    assertCorrectFiltering(columnIndex, gtEq(col, 2), 0, 1, 2, 4, 5);    assertCorrectFiltering(columnIndex, lt(col, 2), 0, 1, 4, 5);    assertCorrectFiltering(columnIndex, ltEq(col, 2), 0, 1, 2, 4, 5);    assertCorrectFiltering(columnIndex, userDefined(col, IntegerIsDivisableWith3.class), 0, 1, 5);    assertCorrectFiltering(columnIndex, invert(userDefined(col, IntegerIsDivisableWith3.class)), 0, 1, 2, 3, 4, 5);    builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    sb = new StatsBuilder();    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, -532, -345, null, null));    builder.add(sb.stats(type, -500, -42, null));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, null, null, null));    builder.add(sb.stats(type, -42, 2));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, 3, 42));    builder.add(sb.stats(type, null, null));    assertEquals(9, builder.getPageCount());    assertEquals(sb.getMinMaxSize(), builder.getMinMaxSize());    columnIndex = builder.build();    assertEquals(BoundaryOrder.ASCENDING, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 2, 2, 1, 2, 3, 0, 2, 0, 2);    assertCorrectNullPages(columnIndex, true, false, false, true, true, false, true, false, true);    assertCorrectValues(columnIndex.getMaxValues(), null, -345, -42, null, null, 2, null, 42, null);    assertCorrectValues(columnIndex.getMinValues(), null, -532, -500, null, null, -42, null, 3, null);    assertCorrectFiltering(columnIndex, eq(col, 2), 5);    assertCorrectFiltering(columnIndex, eq(col, null), 0, 1, 2, 3, 4, 6, 8);    assertCorrectFiltering(columnIndex, notEq(col, 2), 0, 1, 2, 3, 4, 5, 6, 7, 8);    assertCorrectFiltering(columnIndex, notEq(col, null), 1, 2, 5, 7);    assertCorrectFiltering(columnIndex, gt(col, 2), 7);    assertCorrectFiltering(columnIndex, gtEq(col, 2), 5, 7);    assertCorrectFiltering(columnIndex, lt(col, 2), 1, 2, 5);    assertCorrectFiltering(columnIndex, ltEq(col, 2), 1, 2, 5);    assertCorrectFiltering(columnIndex, userDefined(col, IntegerIsDivisableWith3.class), 1, 2, 5, 7);    assertCorrectFiltering(columnIndex, invert(userDefined(col, IntegerIsDivisableWith3.class)), 0, 1, 2, 3, 4, 5, 6, 7, 8);    builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    sb = new StatsBuilder();    builder.add(sb.stats(type, null, null, null, null, null));    builder.add(sb.stats(type, 532, 345));    builder.add(sb.stats(type, null, null, null));    builder.add(sb.stats(type, 234, 42, null));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, 42, -2));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, -3, -42));    assertEquals(9, builder.getPageCount());    assertEquals(sb.getMinMaxSize(), builder.getMinMaxSize());    columnIndex = builder.build();    assertEquals(BoundaryOrder.DESCENDING, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 5, 0, 3, 1, 2, 0, 2, 2, 0);    assertCorrectNullPages(columnIndex, true, false, true, false, true, false, true, true, false);    assertCorrectValues(columnIndex.getMaxValues(), null, 532, null, 234, null, 42, null, null, -3);    assertCorrectValues(columnIndex.getMinValues(), null, 345, null, 42, null, -2, null, null, -42);    assertCorrectFiltering(columnIndex, eq(col, 2), 5);    assertCorrectFiltering(columnIndex, eq(col, null), 0, 2, 3, 4, 6, 7);    assertCorrectFiltering(columnIndex, notEq(col, 2), 0, 1, 2, 3, 4, 5, 6, 7, 8);    assertCorrectFiltering(columnIndex, notEq(col, null), 1, 3, 5, 8);    assertCorrectFiltering(columnIndex, gt(col, 2), 1, 3, 5);    assertCorrectFiltering(columnIndex, gtEq(col, 2), 1, 3, 5);    assertCorrectFiltering(columnIndex, lt(col, 2), 5, 8);    assertCorrectFiltering(columnIndex, ltEq(col, 2), 5, 8);    assertCorrectFiltering(columnIndex, userDefined(col, IntegerIsDivisableWith3.class), 1, 3, 5, 8);    assertCorrectFiltering(columnIndex, invert(userDefined(col, IntegerIsDivisableWith3.class)), 0, 1, 2, 3, 4, 5, 6, 7, 8);}
65e2c420971067d47998810e72e377927a7767dac74531475864ff521fb53e40
testStaticBuildInt32
public void testStaticBuildInt32()
{    ColumnIndex columnIndex = ColumnIndexBuilder.build(Types.required(INT32).named("test_int32"), BoundaryOrder.DESCENDING, asList(false, false, false, true, true, true), asList(0l, 10l, 0l, 3l, 5l, 7l), toBBList(10, 8, 6, null, null, null), toBBList(9, 7, 5, null, null, null));    assertEquals(BoundaryOrder.DESCENDING, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 0, 10, 0, 3, 5, 7);    assertCorrectNullPages(columnIndex, false, false, false, true, true, true);    assertCorrectValues(columnIndex.getMaxValues(), 9, 7, 5, null, null, null);    assertCorrectValues(columnIndex.getMinValues(), 10, 8, 6, null, null, null);}
be3de2c171f58ff756ddb665ca3fc2b05d9a3f8f61302c65a43e56fc174f3dc9
testBuildUInt8
public void testBuildUInt8()
{    PrimitiveType type = Types.required(INT32).as(UINT_8).named("test_uint8");    ColumnIndexBuilder builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    assertThat(builder, instanceOf(IntColumnIndexBuilder.class));    assertNull(builder.build());    IntColumn col = intColumn("test_col");    StatsBuilder sb = new StatsBuilder();    builder.add(sb.stats(type, 4, 10));    builder.add(sb.stats(type, 11, 17, null));    builder.add(sb.stats(type, 2, 2, null, null));    builder.add(sb.stats(type, null, null, null));    builder.add(sb.stats(type, 1, 0xFF));    builder.add(sb.stats(type, 0xEF, 0xFA));    assertEquals(6, builder.getPageCount());    assertEquals(sb.getMinMaxSize(), builder.getMinMaxSize());    ColumnIndex columnIndex = builder.build();    assertEquals(BoundaryOrder.UNORDERED, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 0, 1, 2, 3, 0, 0);    assertCorrectNullPages(columnIndex, false, false, false, true, false, false);    assertCorrectValues(columnIndex.getMaxValues(), 10, 17, 2, null, 0xFF, 0xFA);    assertCorrectValues(columnIndex.getMinValues(), 4, 11, 2, null, 1, 0xEF);    assertCorrectFiltering(columnIndex, eq(col, 2), 2, 4);    assertCorrectFiltering(columnIndex, eq(col, null), 1, 2, 3);    assertCorrectFiltering(columnIndex, notEq(col, 2), 0, 1, 2, 3, 4, 5);    assertCorrectFiltering(columnIndex, notEq(col, null), 0, 1, 2, 4, 5);    assertCorrectFiltering(columnIndex, gt(col, 2), 0, 1, 4, 5);    assertCorrectFiltering(columnIndex, gtEq(col, 2), 0, 1, 2, 4, 5);    assertCorrectFiltering(columnIndex, lt(col, 0xEF), 0, 1, 2, 4);    assertCorrectFiltering(columnIndex, ltEq(col, 0xEF), 0, 1, 2, 4, 5);    assertCorrectFiltering(columnIndex, userDefined(col, IntegerIsDivisableWith3.class), 0, 1, 4, 5);    assertCorrectFiltering(columnIndex, invert(userDefined(col, IntegerIsDivisableWith3.class)), 0, 1, 2, 3, 4, 5);    builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    sb = new StatsBuilder();    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, 0, 0, null, null));    builder.add(sb.stats(type, 0, 42, null));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, null, null, null));    builder.add(sb.stats(type, 42, 0xEE));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, 0xEF, 0xFF));    builder.add(sb.stats(type, null, null));    assertEquals(9, builder.getPageCount());    assertEquals(sb.getMinMaxSize(), builder.getMinMaxSize());    columnIndex = builder.build();    assertEquals(BoundaryOrder.ASCENDING, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 2, 2, 1, 2, 3, 0, 2, 0, 2);    assertCorrectNullPages(columnIndex, true, false, false, true, true, false, true, false, true);    assertCorrectValues(columnIndex.getMaxValues(), null, 0, 42, null, null, 0xEE, null, 0xFF, null);    assertCorrectValues(columnIndex.getMinValues(), null, 0, 0, null, null, 42, null, 0xEF, null);    assertCorrectFiltering(columnIndex, eq(col, 2), 2);    assertCorrectFiltering(columnIndex, eq(col, null), 0, 1, 2, 3, 4, 6, 8);    assertCorrectFiltering(columnIndex, notEq(col, 2), 0, 1, 2, 3, 4, 5, 6, 7, 8);    assertCorrectFiltering(columnIndex, notEq(col, null), 1, 2, 5, 7);    assertCorrectFiltering(columnIndex, gt(col, 0xEE), 7);    assertCorrectFiltering(columnIndex, gtEq(col, 0xEE), 5, 7);    assertCorrectFiltering(columnIndex, lt(col, 42), 1, 2);    assertCorrectFiltering(columnIndex, ltEq(col, 42), 1, 2, 5);    assertCorrectFiltering(columnIndex, userDefined(col, IntegerIsDivisableWith3.class), 1, 2, 5, 7);    assertCorrectFiltering(columnIndex, invert(userDefined(col, IntegerIsDivisableWith3.class)), 0, 1, 2, 3, 4, 5, 6, 7, 8);    builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    sb = new StatsBuilder();    builder.add(sb.stats(type, null, null, null, null, null));    builder.add(sb.stats(type, 0xFF, 0xFF));    builder.add(sb.stats(type, null, null, null));    builder.add(sb.stats(type, 0xEF, 0xEA, null));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, 0xEE, 42));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, 41, 0));    assertEquals(9, builder.getPageCount());    assertEquals(sb.getMinMaxSize(), builder.getMinMaxSize());    columnIndex = builder.build();    assertEquals(BoundaryOrder.DESCENDING, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 5, 0, 3, 1, 2, 0, 2, 2, 0);    assertCorrectNullPages(columnIndex, true, false, true, false, true, false, true, true, false);    assertCorrectValues(columnIndex.getMaxValues(), null, 0xFF, null, 0xEF, null, 0xEE, null, null, 41);    assertCorrectValues(columnIndex.getMinValues(), null, 0xFF, null, 0xEA, null, 42, null, null, 0);    assertCorrectFiltering(columnIndex, eq(col, 0xAB), 5);    assertCorrectFiltering(columnIndex, eq(col, null), 0, 2, 3, 4, 6, 7);    assertCorrectFiltering(columnIndex, notEq(col, 0xFF), 0, 2, 3, 4, 5, 6, 7, 8);    assertCorrectFiltering(columnIndex, notEq(col, null), 1, 3, 5, 8);    assertCorrectFiltering(columnIndex, gt(col, 0xFF));    assertCorrectFiltering(columnIndex, gtEq(col, 0xFF), 1);    assertCorrectFiltering(columnIndex, lt(col, 42), 8);    assertCorrectFiltering(columnIndex, ltEq(col, 42), 5, 8);    assertCorrectFiltering(columnIndex, userDefined(col, IntegerIsDivisableWith3.class), 1, 3, 5, 8);    assertCorrectFiltering(columnIndex, invert(userDefined(col, IntegerIsDivisableWith3.class)), 0, 2, 3, 4, 5, 6, 7, 8);}
a5d75fd162f1e0784881c7c2ed8ffd33805fffe1b82b809e2019a3596ee423bc
testBuildInt64
public void testBuildInt64()
{    PrimitiveType type = Types.required(INT64).named("test_int64");    ColumnIndexBuilder builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    assertThat(builder, instanceOf(LongColumnIndexBuilder.class));    assertNull(builder.build());    LongColumn col = longColumn("test_col");    StatsBuilder sb = new StatsBuilder();    builder.add(sb.stats(type, -4l, 10l));    builder.add(sb.stats(type, -11l, 7l, null));    builder.add(sb.stats(type, 2l, 2l, null, null));    builder.add(sb.stats(type, null, null, null));    builder.add(sb.stats(type, 1l, 2l));    builder.add(sb.stats(type, -21l, 8l));    assertEquals(6, builder.getPageCount());    assertEquals(sb.getMinMaxSize(), builder.getMinMaxSize());    ColumnIndex columnIndex = builder.build();    assertEquals(BoundaryOrder.UNORDERED, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 0l, 1l, 2l, 3l, 0l, 0l);    assertCorrectNullPages(columnIndex, false, false, false, true, false, false);    assertCorrectValues(columnIndex.getMaxValues(), 10l, 7l, 2l, null, 2l, 8l);    assertCorrectValues(columnIndex.getMinValues(), -4l, -11l, 2l, null, 1l, -21l);    assertCorrectFiltering(columnIndex, eq(col, 0l), 0, 1, 5);    assertCorrectFiltering(columnIndex, eq(col, null), 1, 2, 3);    assertCorrectFiltering(columnIndex, notEq(col, 0l), 0, 1, 2, 3, 4, 5);    assertCorrectFiltering(columnIndex, notEq(col, null), 0, 1, 2, 4, 5);    assertCorrectFiltering(columnIndex, gt(col, 2l), 0, 1, 5);    assertCorrectFiltering(columnIndex, gtEq(col, 2l), 0, 1, 2, 4, 5);    assertCorrectFiltering(columnIndex, lt(col, -21l));    assertCorrectFiltering(columnIndex, ltEq(col, -21l), 5);    assertCorrectFiltering(columnIndex, userDefined(col, LongIsDivisableWith3.class), 0, 1, 5);    assertCorrectFiltering(columnIndex, invert(userDefined(col, LongIsDivisableWith3.class)), 0, 1, 2, 3, 4, 5);    builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    sb = new StatsBuilder();    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, -532l, -345l, null, null));    builder.add(sb.stats(type, -234l, -42l, null));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, null, null, null));    builder.add(sb.stats(type, -42l, 2l));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, -3l, 42l));    builder.add(sb.stats(type, null, null));    assertEquals(9, builder.getPageCount());    assertEquals(sb.getMinMaxSize(), builder.getMinMaxSize());    columnIndex = builder.build();    assertEquals(BoundaryOrder.ASCENDING, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 2, 2, 1, 2, 3, 0, 2, 0, 2);    assertCorrectNullPages(columnIndex, true, false, false, true, true, false, true, false, true);    assertCorrectValues(columnIndex.getMaxValues(), null, -345l, -42l, null, null, 2l, null, 42l, null);    assertCorrectValues(columnIndex.getMinValues(), null, -532l, -234l, null, null, -42l, null, -3l, null);    assertCorrectFiltering(columnIndex, eq(col, -42l), 2, 5);    assertCorrectFiltering(columnIndex, eq(col, null), 0, 1, 2, 3, 4, 6, 8);    assertCorrectFiltering(columnIndex, notEq(col, -42l), 0, 1, 2, 3, 4, 5, 6, 7, 8);    assertCorrectFiltering(columnIndex, notEq(col, null), 1, 2, 5, 7);    assertCorrectFiltering(columnIndex, gt(col, 2l), 7);    assertCorrectFiltering(columnIndex, gtEq(col, 2l), 5, 7);    assertCorrectFiltering(columnIndex, lt(col, -42l), 1, 2);    assertCorrectFiltering(columnIndex, ltEq(col, -42l), 1, 2, 5);    assertCorrectFiltering(columnIndex, userDefined(col, LongIsDivisableWith3.class), 1, 2, 5, 7);    assertCorrectFiltering(columnIndex, invert(userDefined(col, LongIsDivisableWith3.class)), 0, 1, 2, 3, 4, 5, 6, 7, 8);    builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    sb = new StatsBuilder();    builder.add(sb.stats(type, null, null, null, null, null));    builder.add(sb.stats(type, 532l, 345l));    builder.add(sb.stats(type, null, null, null));    builder.add(sb.stats(type, 234l, 42l, null));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, 42l, -2l));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, null, null));    builder.add(sb.stats(type, -3l, -42l));    assertEquals(9, builder.getPageCount());    assertEquals(sb.getMinMaxSize(), builder.getMinMaxSize());    columnIndex = builder.build();    assertEquals(BoundaryOrder.DESCENDING, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 5, 0, 3, 1, 2, 0, 2, 2, 0);    assertCorrectNullPages(columnIndex, true, false, true, false, true, false, true, true, false);    assertCorrectValues(columnIndex.getMaxValues(), null, 532l, null, 234l, null, 42l, null, null, -3l);    assertCorrectValues(columnIndex.getMinValues(), null, 345l, null, 42l, null, -2l, null, null, -42l);    assertCorrectFiltering(columnIndex, eq(col, 0l), 5);    assertCorrectFiltering(columnIndex, eq(col, null), 0, 2, 3, 4, 6, 7);    assertCorrectFiltering(columnIndex, notEq(col, 0l), 0, 1, 2, 3, 4, 5, 6, 7, 8);    assertCorrectFiltering(columnIndex, notEq(col, null), 1, 3, 5, 8);    assertCorrectFiltering(columnIndex, gt(col, 2l), 1, 3, 5);    assertCorrectFiltering(columnIndex, gtEq(col, 2l), 1, 3, 5);    assertCorrectFiltering(columnIndex, lt(col, -42l));    assertCorrectFiltering(columnIndex, ltEq(col, -42l), 8);    assertCorrectFiltering(columnIndex, userDefined(col, LongIsDivisableWith3.class), 1, 3, 5, 8);    assertCorrectFiltering(columnIndex, invert(userDefined(col, LongIsDivisableWith3.class)), 0, 1, 2, 3, 4, 5, 6, 7, 8);}
46b97316efacd088865e97ecc907da94487e812d3723277139feafdf244951aa
testStaticBuildInt64
public void testStaticBuildInt64()
{    ColumnIndex columnIndex = ColumnIndexBuilder.build(Types.required(INT64).named("test_int64"), BoundaryOrder.UNORDERED, asList(true, false, true, false, true, false), asList(1l, 2l, 3l, 4l, 5l, 6l), toBBList(null, 2l, null, 4l, null, 9l), toBBList(null, 3l, null, 15l, null, 10l));    assertEquals(BoundaryOrder.UNORDERED, columnIndex.getBoundaryOrder());    assertCorrectNullCounts(columnIndex, 1, 2, 3, 4, 5, 6);    assertCorrectNullPages(columnIndex, true, false, true, false, true, false);    assertCorrectValues(columnIndex.getMaxValues(), null, 3l, null, 15l, null, 10l);    assertCorrectValues(columnIndex.getMinValues(), null, 2l, null, 4l, null, 9l);}
02f39555c6c49d7a0a957bb6320ffbcd812aac4bf460aa5d24adda49620ee3a3
testNoOpBuilder
public void testNoOpBuilder()
{    ColumnIndexBuilder builder = ColumnIndexBuilder.getNoOpBuilder();    StatsBuilder sb = new StatsBuilder();    builder.add(sb.stats(Types.required(BINARY).as(UTF8).named("test_binary_utf8"), stringBinary("Jeltz"), stringBinary("Slartibartfast"), null, null));    builder.add(sb.stats(Types.required(BOOLEAN).named("test_boolean"), true, true, null, null));    builder.add(sb.stats(Types.required(DOUBLE).named("test_double"), null, null, null));    builder.add(sb.stats(Types.required(INT32).named("test_int32"), null, null));    builder.add(sb.stats(Types.required(INT64).named("test_int64"), -234l, -42l, null));    assertEquals(0, builder.getPageCount());    assertEquals(0, builder.getMinMaxSize());    assertNull(builder.build());}
4160463e5feb8a3db575c02f39281e4c63fb3cc18008978d9cdabf41666b7e6c
toBBList
private static List<ByteBuffer> toBBList(Binary... values)
{    List<ByteBuffer> buffers = new ArrayList<>(values.length);    for (Binary value : values) {        if (value == null) {            buffers.add(ByteBuffer.allocate(0));        } else {            buffers.add(value.toByteBuffer());        }    }    return buffers;}
cf8928d04179475d20a11a876dc0551d4d9e1c65841737528c975e03d7383b9f
toBBList
private static List<ByteBuffer> toBBList(Boolean... values)
{    List<ByteBuffer> buffers = new ArrayList<>(values.length);    for (Boolean value : values) {        if (value == null) {            buffers.add(ByteBuffer.allocate(0));        } else {            buffers.add(ByteBuffer.wrap(BytesUtils.booleanToBytes(value)));        }    }    return buffers;}
0dd796bd4db10eca3c404eed9dbaea0ffe8e0e840df44f9c2fcc755e71c35ad7
toBBList
private static List<ByteBuffer> toBBList(Double... values)
{    List<ByteBuffer> buffers = new ArrayList<>(values.length);    for (Double value : values) {        if (value == null) {            buffers.add(ByteBuffer.allocate(0));        } else {            buffers.add(ByteBuffer.wrap(BytesUtils.longToBytes(Double.doubleToLongBits(value))));        }    }    return buffers;}
48ebf03271986ea0e047e3f3f6fe43d904c198c89dfd2959f610daff88d7c7ab
toBBList
private static List<ByteBuffer> toBBList(Float... values)
{    List<ByteBuffer> buffers = new ArrayList<>(values.length);    for (Float value : values) {        if (value == null) {            buffers.add(ByteBuffer.allocate(0));        } else {            buffers.add(ByteBuffer.wrap(BytesUtils.intToBytes(Float.floatToIntBits(value))));        }    }    return buffers;}
a5ca8cafa67c021634fb486875fd1c148a351b5163f0edb44c89b472bdc7c801
toBBList
private static List<ByteBuffer> toBBList(Integer... values)
{    List<ByteBuffer> buffers = new ArrayList<>(values.length);    for (Integer value : values) {        if (value == null) {            buffers.add(ByteBuffer.allocate(0));        } else {            buffers.add(ByteBuffer.wrap(BytesUtils.intToBytes(value)));        }    }    return buffers;}
b4a33c2f2865d60a15b74ffd57d2feb22b456ed0346a7ff1f551d401d837cb1b
toBBList
private static List<ByteBuffer> toBBList(Long... values)
{    List<ByteBuffer> buffers = new ArrayList<>(values.length);    for (Long value : values) {        if (value == null) {            buffers.add(ByteBuffer.allocate(0));        } else {            buffers.add(ByteBuffer.wrap(BytesUtils.longToBytes(value)));        }    }    return buffers;}
a46516feb9e6720f99535a60b8131353da507161678f56d786c3591f7337ac37
decimalBinary
private static Binary decimalBinary(String num)
{    return Binary.fromConstantByteArray(new BigDecimal(num).unscaledValue().toByteArray());}
08b37fca1a83f5ca22aa67d8dfd796ba96a6b1de20918f6aa93c1953a8da55ab
stringBinary
private static Binary stringBinary(String str)
{    return Binary.fromString(str);}
47136e73dfdb7e0204e842aa885a9819aaf62669f642674449d8822c915b7329
assertCorrectValues
private static void assertCorrectValues(List<ByteBuffer> values, Binary... expectedValues)
{    assertEquals(expectedValues.length, values.size());    for (int i = 0; i < expectedValues.length; ++i) {        Binary expectedValue = expectedValues[i];        ByteBuffer value = values.get(i);        if (expectedValue == null) {            assertFalse("The byte buffer should be empty for null pages", value.hasRemaining());        } else {            assertArrayEquals("Invalid value for page " + i, expectedValue.getBytesUnsafe(), value.array());        }    }}
788c3fa1de8457e865eebcf837dba47c473e22293573672b1a8a52322a3f9816
assertCorrectValues
private static void assertCorrectValues(List<ByteBuffer> values, Boolean... expectedValues)
{    assertEquals(expectedValues.length, values.size());    for (int i = 0; i < expectedValues.length; ++i) {        Boolean expectedValue = expectedValues[i];        ByteBuffer value = values.get(i);        if (expectedValue == null) {            assertFalse("The byte buffer should be empty for null pages", value.hasRemaining());        } else {            assertEquals("The byte buffer should be 1 byte long for boolean", 1, value.remaining());            assertEquals("Invalid value for page " + i, expectedValue.booleanValue(), value.get(0) != 0);        }    }}
52ce64f5f67bf0933d5b2ca3ea87ae945c4cec773c8290a6da53856f55758ef6
assertCorrectValues
private static void assertCorrectValues(List<ByteBuffer> values, Double... expectedValues)
{    assertEquals(expectedValues.length, values.size());    for (int i = 0; i < expectedValues.length; ++i) {        Double expectedValue = expectedValues[i];        ByteBuffer value = values.get(i);        if (expectedValue == null) {            assertFalse("The byte buffer should be empty for null pages", value.hasRemaining());        } else {            assertEquals("The byte buffer should be 8 bytes long for double", 8, value.remaining());            assertTrue("Invalid value for page " + i, Double.compare(expectedValue.doubleValue(), value.getDouble(0)) == 0);        }    }}
7e370a12660e10a995e10f45c99245097348c3fa9d6e4c85d9319d1a24757a21
assertCorrectValues
private static void assertCorrectValues(List<ByteBuffer> values, Float... expectedValues)
{    assertEquals(expectedValues.length, values.size());    for (int i = 0; i < expectedValues.length; ++i) {        Float expectedValue = expectedValues[i];        ByteBuffer value = values.get(i);        if (expectedValue == null) {            assertFalse("The byte buffer should be empty for null pages", value.hasRemaining());        } else {            assertEquals("The byte buffer should be 4 bytes long for double", 4, value.remaining());            assertTrue("Invalid value for page " + i, Float.compare(expectedValue.floatValue(), value.getFloat(0)) == 0);        }    }}
15d498aec1b3fac8193282be67bc2f96e69c182e5e62b2005815efe326e5df19
assertCorrectValues
private static void assertCorrectValues(List<ByteBuffer> values, Integer... expectedValues)
{    assertEquals(expectedValues.length, values.size());    for (int i = 0; i < expectedValues.length; ++i) {        Integer expectedValue = expectedValues[i];        ByteBuffer value = values.get(i);        if (expectedValue == null) {            assertFalse("The byte buffer should be empty for null pages", value.hasRemaining());        } else {            assertEquals("The byte buffer should be 4 bytes long for int32", 4, value.remaining());            assertEquals("Invalid value for page " + i, expectedValue.intValue(), value.getInt(0));        }    }}
22c1476691023e572c9d0e7494f609a1cae176df17f08b366483af707dd34fcd
assertCorrectValues
private static void assertCorrectValues(List<ByteBuffer> values, Long... expectedValues)
{    assertEquals(expectedValues.length, values.size());    for (int i = 0; i < expectedValues.length; ++i) {        Long expectedValue = expectedValues[i];        ByteBuffer value = values.get(i);        if (expectedValue == null) {            assertFalse("The byte buffer should be empty for null pages", value.hasRemaining());        } else {            assertEquals("The byte buffer should be 8 bytes long for int64", 8, value.remaining());            assertEquals("Invalid value for page " + i, expectedValue.intValue(), value.getLong(0));        }    }}
4c3b7d92ed4ac7e56835b7a0882fe7c59c8f7f7260b9f9ef09cec64a1698fecb
assertCorrectNullCounts
private static void assertCorrectNullCounts(ColumnIndex columnIndex, long... expectedNullCounts)
{    List<Long> nullCounts = columnIndex.getNullCounts();    assertEquals(expectedNullCounts.length, nullCounts.size());    for (int i = 0; i < expectedNullCounts.length; ++i) {        assertEquals("Invalid null count at page " + i, expectedNullCounts[i], nullCounts.get(i).longValue());    }}
a59a329c886617f990c9e9c4d0a7d93f1d319142ebbcdd331eaa97f10db164db
assertCorrectNullPages
private static void assertCorrectNullPages(ColumnIndex columnIndex, boolean... expectedNullPages)
{    List<Boolean> nullPages = columnIndex.getNullPages();    assertEquals(expectedNullPages.length, nullPages.size());    for (int i = 0; i < expectedNullPages.length; ++i) {        assertEquals("Invalid null pages at page " + i, expectedNullPages[i], nullPages.get(i).booleanValue());    }}
ccc25fe7d08c57391906f1b7842a687fa2f0d776de29bc0c0aed039e518b3fff
stats
 Statistics<?> stats(PrimitiveType type, Object... values)
{    Statistics<?> stats = Statistics.createStats(type);    for (Object value : values) {        if (value == null) {            stats.incrementNumNulls();            continue;        }        switch(type.getPrimitiveTypeName()) {            case BINARY:            case FIXED_LEN_BYTE_ARRAY:            case INT96:                stats.updateStats((Binary) value);                break;            case BOOLEAN:                stats.updateStats((boolean) value);                break;            case DOUBLE:                stats.updateStats((double) value);                break;            case FLOAT:                stats.updateStats((float) value);                break;            case INT32:                stats.updateStats((int) value);                break;            case INT64:                stats.updateStats((long) value);                break;            default:                fail("Unsupported value type for stats: " + value.getClass());        }    }    if (stats.hasNonNullValue()) {        minMaxSize += stats.getMinBytes().length;        minMaxSize += stats.getMaxBytes().length;    }    return stats;}
c83b326cd55f5f1fe43e4f9e1f4562885de3d08eb1c4ab2998dede44ddc47c45
getMinMaxSize
 long getMinMaxSize()
{    return minMaxSize;}
3da47e030689c333c822c0001806a16b69f439ce6730453aa83a25babc8c0f14
assertCorrectFiltering
private static void assertCorrectFiltering(ColumnIndex ci, FilterPredicate predicate, int... expectedIndexes)
{    TestIndexIterator.assertEquals(predicate.accept(ci), expectedIndexes);}
58432ca13dcc9a2d8f7cb0c45c65af8d99f3c1cd2607dbd6787a941ae7867341
testAll
public void testAll()
{    assertEquals(IndexIterator.all(10), 0, 1, 2, 3, 4, 5, 6, 7, 8, 9);}
51f2ec73199fee6869aa61086a71a364e7d3951a5551ca3229151e6b11a2c26e
testFilter
public void testFilter()
{    assertEquals(IndexIterator.filter(30, value -> value % 3 == 0), 0, 3, 6, 9, 12, 15, 18, 21, 24, 27);}
04e82fbd46ab7813f2aa77c55cfdeaefeabae3b608e717b49ad5f78e31d89b30
testFilterTranslate
public void testFilterTranslate()
{    assertEquals(IndexIterator.filterTranslate(20, value -> value < 5, Math::negateExact), 0, -1, -2, -3, -4);}
d9e18e03105e8093244e02907af2c2eb03d46b6c6c37f8ef44ae2ff4bd274e84
testRangeTranslate
public void testRangeTranslate()
{    assertEquals(IndexIterator.rangeTranslate(11, 18, i -> i - 10), 1, 2, 3, 4, 5, 6, 7, 8);}
0fa0becb593a054918144b99343ec51e95a452e6853b6906c570feb8aea4ad79
assertEquals
 static void assertEquals(PrimitiveIterator.OfInt actualIt, int... expectedValues)
{    IntList actualList = new IntArrayList();    actualIt.forEachRemaining((int value) -> actualList.add(value));    int[] actualValues = actualList.toIntArray();    assertArrayEquals("ExpectedValues: " + Arrays.toString(expectedValues) + " ActualValues: " + Arrays.toString(actualValues), expectedValues, actualValues);}
737e555b15c6123b98d4c8f4b9696286d0044817abc3dbdf299a0abbe131709f
testBuilderWithSizeAndRowCount
public void testBuilderWithSizeAndRowCount()
{    OffsetIndexBuilder builder = OffsetIndexBuilder.getBuilder();    assertNull(builder.build());    assertNull(builder.build(1234));    builder.add(1000, 10);    builder.add(2000, 19);    builder.add(3000, 27);    builder.add(1200, 9);    assertCorrectValues(builder.build(), 0, 1000, 0, 1000, 2000, 10, 3000, 3000, 29, 6000, 1200, 56);    assertCorrectValues(builder.build(10000), 10000, 1000, 0, 11000, 2000, 10, 13000, 3000, 29, 16000, 1200, 56);}
dff754cdcd42dc3394fd87a4e4da6a65e869a0c17e3af19ca994a3ac266f1110
testNoOpBuilderWithSizeAndRowCount
public void testNoOpBuilderWithSizeAndRowCount()
{    OffsetIndexBuilder builder = OffsetIndexBuilder.getNoOpBuilder();    builder.add(1, 2);    builder.add(3, 4);    builder.add(5, 6);    builder.add(7, 8);    assertNull(builder.build());    assertNull(builder.build(1000));}
03e2530b3545a5b8fc8bea07cbd0e9dc19982cc18d4652025e1b4828d857a3fb
testBuilderWithOffsetSizeIndex
public void testBuilderWithOffsetSizeIndex()
{    OffsetIndexBuilder builder = OffsetIndexBuilder.getBuilder();    assertNull(builder.build());    assertNull(builder.build(1234));    builder.add(1000, 10000, 0);    builder.add(22000, 12000, 100);    builder.add(48000, 22000, 211);    builder.add(90000, 30000, 361);    assertCorrectValues(builder.build(), 1000, 10000, 0, 22000, 12000, 100, 48000, 22000, 211, 90000, 30000, 361);    assertCorrectValues(builder.build(100000), 101000, 10000, 0, 122000, 12000, 100, 148000, 22000, 211, 190000, 30000, 361);}
31bcf6d3ec0f3e3bcfcd647d9575e6332072738dd732a8614aa7b517f22ea5b9
testNoOpBuilderWithOffsetSizeIndex
public void testNoOpBuilderWithOffsetSizeIndex()
{    OffsetIndexBuilder builder = OffsetIndexBuilder.getNoOpBuilder();    builder.add(1, 2, 3);    builder.add(4, 5, 6);    builder.add(7, 8, 9);    builder.add(10, 11, 12);    assertNull(builder.build());    assertNull(builder.build(1000));}
66a371f0e513e0be48c354d29bed1e066458e18bb737c0ea61c4651782328d6d
assertCorrectValues
private void assertCorrectValues(OffsetIndex offsetIndex, long... offset_size_rowIndex_triplets)
{    assertEquals(offset_size_rowIndex_triplets.length % 3, 0);    int pageCount = offset_size_rowIndex_triplets.length / 3;    assertEquals("Invalid pageCount", pageCount, offsetIndex.getPageCount());    for (int i = 0; i < pageCount; ++i) {        assertEquals("Invalid offsetIndex at page " + i, offset_size_rowIndex_triplets[3 * i], offsetIndex.getOffset(i));        assertEquals("Invalid compressedPageSize at page " + i, offset_size_rowIndex_triplets[3 * i + 1], offsetIndex.getCompressedPageSize(i));        assertEquals("Invalid firstRowIndex at page " + i, offset_size_rowIndex_triplets[3 * i + 2], offsetIndex.getFirstRowIndex(i));        long expectedLastPageIndex = (i < pageCount - 1) ? (offset_size_rowIndex_triplets[3 * i + 5] - 1) : 999;        assertEquals("Invalid lastRowIndex at page " + i, expectedLastPageIndex, offsetIndex.getLastRowIndex(i, 1000));    }}
542835adfacb7f13719a3dcdd00f3bb92ab2553223ed65b42faffdb750b802be
addNullPage
 CIBuilder addNullPage(long nullCount)
{    nullPages.add(true);    nullCounts.add(nullCount);    minValues.add(EMPTY);    maxValues.add(EMPTY);    return this;}
d4d174a53b382e794abafc04fbc92b376f18720213ca107052f208423699a243
addPage
 CIBuilder addPage(long nullCount, int min, int max)
{    nullPages.add(false);    nullCounts.add(nullCount);    minValues.add(ByteBuffer.wrap(BytesUtils.intToBytes(min)));    maxValues.add(ByteBuffer.wrap(BytesUtils.intToBytes(max)));    return this;}
77cfaae287edc73fee072dc960b8523b288ef665d1361488186f21ecef620c51
addPage
 CIBuilder addPage(long nullCount, String min, String max)
{    nullPages.add(false);    nullCounts.add(nullCount);    minValues.add(ByteBuffer.wrap(min.getBytes(UTF_8)));    maxValues.add(ByteBuffer.wrap(max.getBytes(UTF_8)));    return this;}
bb8226512641b04fb48f010cdee3c5fd990e4cf71bd69dd27e23f440b4057824
addPage
 CIBuilder addPage(long nullCount, double min, double max)
{    nullPages.add(false);    nullCounts.add(nullCount);    minValues.add(ByteBuffer.wrap(BytesUtils.longToBytes(Double.doubleToLongBits(min))));    maxValues.add(ByteBuffer.wrap(BytesUtils.longToBytes(Double.doubleToLongBits(max))));    return this;}
22215ac3ae664622df551348eca8ec7709ed1fb05a8e2717b07da57831c86cab
build
 ColumnIndex build()
{    return ColumnIndexBuilder.build(type, order, nullPages, nullCounts, minValues, maxValues);}
71f804104577788864443443175d929d77d4c86b28a5bb7600fbbf25155f2b66
addPage
 OIBuilder addPage(long rowCount)
{    builder.add(1234, rowCount);    return this;}
3f07d85d8f66cd7a22937feb6cc678c932f24f4bf92101481027ea785fe06cdf
build
 OffsetIndex build()
{    return builder.build();}
7f7f3f19704e2a738e37683ea1e845cc8989f3ea09f4b8dd10734db5795ded63
keep
public boolean keep(Integer value)
{    return true;}
c7a72c7a33471a778e8b2a612fa9450efb2b3f8c5a5ec016b75b49a1a893850b
canDrop
public boolean canDrop(Statistics<Integer> statistics)
{    return false;}
ebdbd08b714a5ea0982d87cfe65d5c0cbd451cc408d5f216453963845d6ce249
inverseCanDrop
public boolean inverseCanDrop(Statistics<Integer> statistics)
{    return true;}
cf6b81b70343f368ba7363b210bae70f5a21c9c1300b0cf68a80ae4a743cccd1
getColumnIndex
public ColumnIndex getColumnIndex(ColumnPath column)
{    switch(column.toDotString()) {        case "column1":            return COLUMN1_CI;        case "column2":            return COLUMN2_CI;        case "column3":            return COLUMN3_CI;        case "column4":            return COLUMN4_CI;        default:            return null;    }}
2698d03083af88b3c827e603e1f97530dacfdc449ddf9af80c09e43c70676a8e
getOffsetIndex
public OffsetIndex getOffsetIndex(ColumnPath column)
{    switch(column.toDotString()) {        case "column1":            return COLUMN1_OI;        case "column2":            return COLUMN2_OI;        case "column3":            return COLUMN3_OI;        case "column4":            return COLUMN4_OI;        default:            throw new MissingOffsetIndexException(column);    }}
6350f71cff8a5fb3876e38ac2fb6b352a7af8c22c0f1fbf57752235731522902
paths
private static Set<ColumnPath> paths(String... columns)
{    Set<ColumnPath> paths = new HashSet<>();    for (String column : columns) {        paths.add(ColumnPath.fromDotString(column));    }    return paths;}
925c2d77f6779eb4dc554d3bca1bb7e619907564951d7a609e1f1f8b76b5db74
assertAllRows
private static void assertAllRows(RowRanges ranges, long rowCount)
{    LongList actualList = new LongArrayList();    ranges.iterator().forEachRemaining((long value) -> actualList.add(value));    LongList expectedList = new LongArrayList();    LongStream.range(0, rowCount).forEach(expectedList::add);    assertArrayEquals(expectedList + " != " + actualList, expectedList.toLongArray(), actualList.toLongArray());}
fe3b22d1a897318a9c259d848650af0165a3cba6d7a7a360b15305a649e21275
assertRows
private static void assertRows(RowRanges ranges, long... expectedRows)
{    LongList actualList = new LongArrayList();    ranges.iterator().forEachRemaining((long value) -> actualList.add(value));    assertArrayEquals(Arrays.toString(expectedRows) + " != " + actualList, expectedRows, actualList.toLongArray());}
6401ff737098af6dd4d9db42a8de5acf886cff00724da5c13a1df00406712cf8
testFiltering
public void testFiltering()
{    Set<ColumnPath> paths = paths("column1", "column2", "column3", "column4");    assertAllRows(calculateRowRanges(FilterCompat.get(userDefined(intColumn("column1"), AnyInt.class)), STORE, paths, TOTAL_ROW_COUNT), TOTAL_ROW_COUNT);    assertRows(calculateRowRanges(FilterCompat.get(and(and(eq(intColumn("column1"), null), eq(binaryColumn("column2"), null)), and(eq(doubleColumn("column3"), null), eq(booleanColumn("column4"), null)))), STORE, paths, TOTAL_ROW_COUNT), 6, 9);    assertRows(calculateRowRanges(FilterCompat.get(and(and(notEq(intColumn("column1"), null), notEq(binaryColumn("column2"), null)), and(notEq(doubleColumn("column3"), null), notEq(booleanColumn("column4"), null)))), STORE, paths, TOTAL_ROW_COUNT), 0, 1, 2, 3, 4, 5, 6, 7, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25);    assertRows(calculateRowRanges(FilterCompat.get(or(and(lt(intColumn("column1"), 20), gtEq(binaryColumn("column2"), fromString("Quebec"))), and(gt(doubleColumn("column3"), 5.32), ltEq(binaryColumn("column4"), fromString("XYZ"))))), STORE, paths, TOTAL_ROW_COUNT), 0, 1, 2, 3, 4, 5, 6, 7, 10, 11, 12, 13, 14, 15, 23, 24, 25);    assertRows(calculateRowRanges(FilterCompat.get(and(and(gtEq(intColumn("column1"), 7), gt(binaryColumn("column2"), fromString("India"))), and(eq(doubleColumn("column3"), null), notEq(binaryColumn("column4"), null)))), STORE, paths, TOTAL_ROW_COUNT), 7, 16, 17, 18, 19, 20);    assertRows(calculateRowRanges(FilterCompat.get(and(or(invert(userDefined(intColumn("column1"), AnyInt.class)), eq(binaryColumn("column2"), fromString("Echo"))), eq(doubleColumn("column3"), 6.0))), STORE, paths, TOTAL_ROW_COUNT), 23, 24, 25);    assertRows(calculateRowRanges(FilterCompat.get(and(userDefined(intColumn("column1"), IntegerIsDivisableWith3.class), and(userDefined(binaryColumn("column2"), BinaryUtf8StartsWithB.class), userDefined(doubleColumn("column3"), DoubleIsInteger.class)))), STORE, paths, TOTAL_ROW_COUNT), 21, 22, 23, 24, 25);    assertRows(calculateRowRanges(FilterCompat.get(and(and(gtEq(intColumn("column1"), 7), lt(intColumn("column1"), 11)), and(gt(binaryColumn("column2"), fromString("Romeo")), ltEq(binaryColumn("column2"), fromString("Tango"))))), STORE, paths, TOTAL_ROW_COUNT), 7, 11, 12, 13);}
4ce350960ce0be597db779b284049d7791e5a60a31f50f8278ace10035a4bedb
testFilteringOnMissingColumns
public void testFilteringOnMissingColumns()
{    Set<ColumnPath> paths = paths("column1", "column2", "column3", "column4");        assertAllRows(calculateRowRanges(FilterCompat.get(notEq(intColumn("missing_column"), 0)), STORE, paths, TOTAL_ROW_COUNT), TOTAL_ROW_COUNT);    assertRows(calculateRowRanges(FilterCompat.get(and(and(gtEq(intColumn("column1"), 7), lt(intColumn("column1"), 11)), eq(binaryColumn("missing_column"), null))), STORE, paths, TOTAL_ROW_COUNT), 7, 8, 9, 10, 11, 12, 13);        assertRows(calculateRowRanges(FilterCompat.get(or(and(gtEq(intColumn("column1"), 7), lt(intColumn("column1"), 11)), notEq(binaryColumn("missing_column"), null))), STORE, paths, TOTAL_ROW_COUNT), 7, 8, 9, 10, 11, 12, 13);    assertRows(calculateRowRanges(FilterCompat.get(gt(intColumn("missing_column"), 0)), STORE, paths, TOTAL_ROW_COUNT));}
f60bb3373914fa780844463687a0b2ca7344bde25652246b60119a9bd32dba24
testFilteringWithMissingOffsetIndex
public void testFilteringWithMissingOffsetIndex()
{    Set<ColumnPath> paths = paths("column1", "column2", "column3", "column4", "column_wo_oi");    assertAllRows(calculateRowRanges(FilterCompat.get(and(and(gtEq(intColumn("column1"), 7), lt(intColumn("column1"), 11)), and(gt(binaryColumn("column2"), fromString("Romeo")), ltEq(binaryColumn("column_wo_oi"), fromString("Tango"))))), STORE, paths, TOTAL_ROW_COUNT), TOTAL_ROW_COUNT);}
fdc7f6c621d34a772248ec2b8af84c5794292a0da63f66a54746e3effb156947
buildRanges
private static RowRanges buildRanges(long... rowIndexes)
{    if (rowIndexes.length == 0) {        return RowRanges.EMPTY;    }    OffsetIndexBuilder builder = OffsetIndexBuilder.getBuilder();    for (int i = 0, n = rowIndexes.length; i < n; i += 2) {        long from = rowIndexes[i];        long to = rowIndexes[i + 1];        builder.add(0, 0, from);        builder.add(0, 0, to + 1);    }    PrimitiveIterator.OfInt pageIndexes = new PrimitiveIterator.OfInt() {        private int index = 0;        @Override        public boolean hasNext() {            return index < rowIndexes.length;        }        @Override        public int nextInt() {            int ret = index;            index += 2;            return ret;        }    };    return RowRanges.create(rowIndexes[rowIndexes.length - 1], pageIndexes, builder.build());}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return index < rowIndexes.length;}
fdad8c53e4cb93ac9606cf0b9361af34b8b3fd5bb4f6e88ad403d16c89019543
nextInt
public int nextInt()
{    int ret = index;    index += 2;    return ret;}
6d47e2d36d6717b9361d7b3742db75528a9010038f57b2df4bfe9a668e63d84d
assertAllRowsEqual
private static void assertAllRowsEqual(PrimitiveIterator.OfLong actualIt, long... expectedValues)
{    LongList actualList = new LongArrayList();    actualIt.forEachRemaining((long value) -> actualList.add(value));    assertArrayEquals(Arrays.toString(expectedValues) + "!= " + actualList, expectedValues, actualList.toLongArray());}
72a52d27a305f989969fbb38bf660502487d770e572d424973a4e2174d4f0b66
testCreate
public void testCreate()
{    RowRanges ranges = buildRanges(1, 2, 3, 4, 6, 7, 7, 10, 15, 17);    assertAllRowsEqual(ranges.iterator(), 1, 2, 3, 4, 6, 7, 8, 9, 10, 15, 16, 17);    assertEquals(12, ranges.rowCount());    assertTrue(ranges.isOverlapping(4, 5));    assertFalse(ranges.isOverlapping(5, 5));    assertTrue(ranges.isOverlapping(10, 14));    assertFalse(ranges.isOverlapping(11, 14));    assertFalse(ranges.isOverlapping(18, Long.MAX_VALUE));    ranges = RowRanges.createSingle(5);    assertAllRowsEqual(ranges.iterator(), 0, 1, 2, 3, 4);    assertEquals(5, ranges.rowCount());    assertTrue(ranges.isOverlapping(0, 100));    assertFalse(ranges.isOverlapping(5, Long.MAX_VALUE));    ranges = RowRanges.EMPTY;    assertAllRowsEqual(ranges.iterator());    assertEquals(0, ranges.rowCount());    assertFalse(ranges.isOverlapping(0, Long.MAX_VALUE));}
35ffebb40c95612badc82277d2e4ae75cf5398abfd4deeef6627d033ffafeee8
testUnion
public void testUnion()
{    RowRanges ranges1 = buildRanges(2, 5, 7, 9, 14, 14, 20, 24);    RowRanges ranges2 = buildRanges(1, 2, 4, 5, 11, 12, 14, 15, 21, 22);    RowRanges empty = buildRanges();    assertAllRowsEqual(union(ranges1, ranges2).iterator(), 1, 2, 3, 4, 5, 7, 8, 9, 11, 12, 14, 15, 20, 21, 22, 23, 24);    assertAllRowsEqual(union(ranges2, ranges1).iterator(), 1, 2, 3, 4, 5, 7, 8, 9, 11, 12, 14, 15, 20, 21, 22, 23, 24);    assertAllRowsEqual(union(ranges1, ranges1).iterator(), 2, 3, 4, 5, 7, 8, 9, 14, 20, 21, 22, 23, 24);    assertAllRowsEqual(union(ranges1, empty).iterator(), 2, 3, 4, 5, 7, 8, 9, 14, 20, 21, 22, 23, 24);    assertAllRowsEqual(union(empty, ranges1).iterator(), 2, 3, 4, 5, 7, 8, 9, 14, 20, 21, 22, 23, 24);    assertAllRowsEqual(union(ranges2, ranges2).iterator(), 1, 2, 4, 5, 11, 12, 14, 15, 21, 22);    assertAllRowsEqual(union(ranges2, empty).iterator(), 1, 2, 4, 5, 11, 12, 14, 15, 21, 22);    assertAllRowsEqual(union(empty, ranges2).iterator(), 1, 2, 4, 5, 11, 12, 14, 15, 21, 22);    assertAllRowsEqual(union(empty, empty).iterator());}
de691cdf0cec2d4d835fbddde3cf0a4ccc589110a512dcf17533ee9740785fb2
testIntersection
public void testIntersection()
{    RowRanges ranges1 = buildRanges(2, 5, 7, 9, 14, 14, 20, 24);    RowRanges ranges2 = buildRanges(1, 2, 6, 7, 9, 9, 11, 12, 14, 15, 21, 22);    RowRanges empty = buildRanges();    assertAllRowsEqual(intersection(ranges1, ranges2).iterator(), 2, 7, 9, 14, 21, 22);    assertAllRowsEqual(intersection(ranges2, ranges1).iterator(), 2, 7, 9, 14, 21, 22);    assertAllRowsEqual(intersection(ranges1, ranges1).iterator(), 2, 3, 4, 5, 7, 8, 9, 14, 20, 21, 22, 23, 24);    assertAllRowsEqual(intersection(ranges1, empty).iterator());    assertAllRowsEqual(intersection(empty, ranges1).iterator());    assertAllRowsEqual(intersection(ranges2, ranges2).iterator(), 1, 2, 6, 7, 9, 11, 12, 14, 15, 21, 22);    assertAllRowsEqual(intersection(ranges2, empty).iterator());    assertAllRowsEqual(intersection(empty, ranges2).iterator());    assertAllRowsEqual(intersection(empty, empty).iterator());}
d1cffe213157b6c21dfeace8f6b4839ea0533e3cb120da5dff11edfb6fd9cacd
mutate
private static void mutate(byte[] bytes)
{    for (int i = 0; i < bytes.length; i++) {        bytes[i] = (byte) (bytes[i] + 1);    }}
eafafb1cbb05b1ce2750bca9fd6bbe74f635d07fc00ba931d365c54064319e79
get
public BinaryAndOriginal get(byte[] bytes, boolean reused) throws Exception
{    byte[] orig = Arrays.copyOf(bytes, bytes.length);    if (reused) {        return new BinaryAndOriginal(Binary.fromReusedByteArray(orig), orig);    } else {        return new BinaryAndOriginal(Binary.fromConstantByteArray(orig), orig);    }}
eafafb1cbb05b1ce2750bca9fd6bbe74f635d07fc00ba931d365c54064319e79
get
public BinaryAndOriginal get(byte[] bytes, boolean reused) throws Exception
{    byte[] orig = padded(bytes);    Binary b;    if (reused) {        b = Binary.fromReusedByteArray(orig, 5, bytes.length);    } else {        b = Binary.fromConstantByteArray(orig, 5, bytes.length);    }    assertArrayEquals(bytes, b.getBytes());    return new BinaryAndOriginal(b, orig);}
eafafb1cbb05b1ce2750bca9fd6bbe74f635d07fc00ba931d365c54064319e79
get
public BinaryAndOriginal get(byte[] bytes, boolean reused) throws Exception
{    byte[] orig = padded(bytes);    ByteBuffer buff = ByteBuffer.wrap(orig, 5, bytes.length);    Binary b;    if (reused) {        b = Binary.fromReusedByteBuffer(buff);    } else {        b = Binary.fromConstantByteBuffer(buff);    }    buff.mark();    assertArrayEquals(bytes, b.getBytes());    buff.reset();    return new BinaryAndOriginal(b, orig);}
eafafb1cbb05b1ce2750bca9fd6bbe74f635d07fc00ba931d365c54064319e79
get
public BinaryAndOriginal get(byte[] bytes, boolean reused) throws Exception
{    Binary b = Binary.fromString(new String(bytes, UTF8));        return new BinaryAndOriginal(b, b.getBytesUnsafe());}
c7bcde1fa0de445fa78189a1cad476e9074dcc2315cf030cb1ec2a4bc933c9f3
padded
private static byte[] padded(byte[] bytes)
{    byte[] padded = new byte[bytes.length + 10];    for (int i = 0; i < 5; i++) {        padded[i] = (byte) i;    }    System.arraycopy(bytes, 0, padded, 5, bytes.length);    for (int i = 0; i < 5; i++) {        padded[i + 5 + bytes.length] = (byte) i;    }    return padded;}
f793bada02caf1b750dc1f63481523487aa9eae93f98d73a35b794fc793bcf37
testByteArrayBackedBinary
public void testByteArrayBackedBinary() throws Exception
{    testBinary(BYTE_ARRAY_BACKED_BF, true);    testBinary(BYTE_ARRAY_BACKED_BF, false);}
76a8ba2d57a1a07e6d25a43e8f553e607e58dba41ee56b72ce38c0cfb91c597d
testByteArraySliceBackedBinary
public void testByteArraySliceBackedBinary() throws Exception
{    testBinary(BYTE_ARRAY_SLICE_BACKED_BF, true);    testBinary(BYTE_ARRAY_SLICE_BACKED_BF, false);}
e6b78e676181e8c3f018c25ab5698da5fb7e621ab60e1dcd4bcef13b1995e804
testByteBufferBackedBinary
public void testByteBufferBackedBinary() throws Exception
{    testBinary(BUFFER_BF, true);    testBinary(BUFFER_BF, false);}
77d8e18b17928fb9f1056567cd995cee31af39c44bca5c65127ec1c4a438e45f
testEqualityMethods
public void testEqualityMethods() throws Exception
{    Binary bin1 = Binary.fromConstantByteArray("alice".getBytes(), 1, 3);    Binary bin2 = Binary.fromConstantByteBuffer(ByteBuffer.wrap("alice".getBytes(), 1, 3));    assertEquals(bin1, bin2);}
4cac3891718135c58ff5fca41941d08fd0119c9d242ae326a685aae8f0f3b08d
testWriteAllTo
public void testWriteAllTo() throws Exception
{    byte[] orig = { 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 };    testWriteAllToHelper(Binary.fromConstantByteBuffer(ByteBuffer.wrap(orig)), orig);    ByteBuffer buf = ByteBuffer.allocateDirect(orig.length);    buf.put(orig);    buf.flip();    testWriteAllToHelper(Binary.fromConstantByteBuffer(buf), orig);}
1026df1fab3ed217829704702b9b4f8b68076879411162ca924d29bf148ade8c
testWriteAllToHelper
private void testWriteAllToHelper(Binary binary, byte[] orig) throws IOException
{    ByteArrayOutputStream out = new ByteArrayOutputStream(orig.length);    binary.writeTo(out);    assertArrayEquals(orig, out.toByteArray());}
cd6fd511fb12d0d4e2ad6e594beefee9bbf44a7efe1c8ad7fd523c17a877d593
testFromStringBinary
public void testFromStringBinary() throws Exception
{    testBinary(STRING_BF, false);}
e86c9312d07d94f5dfb99e92e8a50f43f0d07efd584e65e2e156b948bfba4848
testSlice
private void testSlice(BinaryFactory bf, boolean reused) throws Exception
{    BinaryAndOriginal bao = bf.get(testString.getBytes(UTF8), reused);    assertArrayEquals(testString.getBytes(UTF8), bao.binary.slice(0, testString.length()).getBytesUnsafe());    assertArrayEquals("123".getBytes(UTF8), bao.binary.slice(5, 3).getBytesUnsafe());}
9355ab699853867c010ef14acc56a08ad54cc24d8b618ed2448f3e75f31c71e8
testConstantCopy
private void testConstantCopy(BinaryFactory bf) throws Exception
{    BinaryAndOriginal bao = bf.get(testString.getBytes(UTF8), false);    assertEquals(false, bao.binary.isBackingBytesReused());    assertArrayEquals(testString.getBytes(UTF8), bao.binary.getBytes());    assertArrayEquals(testString.getBytes(UTF8), bao.binary.getBytesUnsafe());    assertArrayEquals(testString.getBytes(UTF8), bao.binary.copy().getBytesUnsafe());    assertArrayEquals(testString.getBytes(UTF8), bao.binary.copy().getBytes());    bao = bf.get(testString.getBytes(UTF8), false);    assertEquals(false, bao.binary.isBackingBytesReused());    Binary copy = bao.binary.copy();    assertSame(copy, bao.binary);}
2d8eb8b1bb87e17a11c2e718a1ddf14c4857475019f35372e03430117ba3bced
testReusedCopy
private void testReusedCopy(BinaryFactory bf) throws Exception
{    BinaryAndOriginal bao = bf.get(testString.getBytes(UTF8), true);    assertEquals(true, bao.binary.isBackingBytesReused());    assertArrayEquals(testString.getBytes(UTF8), bao.binary.getBytes());    assertArrayEquals(testString.getBytes(UTF8), bao.binary.getBytesUnsafe());    assertArrayEquals(testString.getBytes(UTF8), bao.binary.copy().getBytesUnsafe());    assertArrayEquals(testString.getBytes(UTF8), bao.binary.copy().getBytes());    bao = bf.get(testString.getBytes(UTF8), true);    assertEquals(true, bao.binary.isBackingBytesReused());    Binary copy = bao.binary.copy();    mutate(bao.original);    assertArrayEquals(testString.getBytes(UTF8), copy.getBytes());    assertArrayEquals(testString.getBytes(UTF8), copy.getBytesUnsafe());    assertArrayEquals(testString.getBytes(UTF8), copy.copy().getBytesUnsafe());    assertArrayEquals(testString.getBytes(UTF8), copy.copy().getBytes());}
882f52a8f6aac6530a4e0c2ec4a9f88e7f4f9245ba8be0216b7b66a198fcb9ef
testSerializable
private void testSerializable(BinaryFactory bf, boolean reused) throws Exception
{    BinaryAndOriginal bao = bf.get("polygon".getBytes(UTF8), reused);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    ObjectOutputStream out = new ObjectOutputStream(baos);    out.writeObject(bao.binary);    out.close();    baos.close();    ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));    Object object = in.readObject();    assertTrue(object instanceof Binary);    assertEquals(bao.binary, object);}
f65401c00fd05454a21ac741bbfd40e197923995beddf88d71029b6b93d55e0f
testBinary
private void testBinary(BinaryFactory bf, boolean reused) throws Exception
{    testSlice(bf, reused);    if (reused) {        testReusedCopy(bf);    } else {        testConstantCopy(bf);    }    testSerializable(bf, reused);}
41dd1440e007f2271227d7c71b61d3195aee2817e4050f0a3daaa94d827cbb23
testCompare
public void testCompare()
{    Binary b1 = Binary.fromCharSequence("aaaaaaaa");    Binary b2 = Binary.fromString("aaaaaaab");    Binary b3 = Binary.fromReusedByteArray("aaaaaaaaaaa".getBytes(), 1, 8);    Binary b4 = Binary.fromConstantByteBuffer(ByteBuffer.wrap("aaaaaaac".getBytes()));    assertTrue(b1.compareTo(b2) < 0);    assertTrue(b2.compareTo(b1) > 0);    assertTrue(b3.compareTo(b4) < 0);    assertTrue(b4.compareTo(b3) > 0);    assertTrue(b1.compareTo(b4) < 0);    assertTrue(b4.compareTo(b1) > 0);    assertTrue(b2.compareTo(b4) < 0);    assertTrue(b4.compareTo(b2) > 0);    assertTrue(b1.compareTo(b3) == 0);    assertTrue(b3.compareTo(b1) == 0);}
e5e2c9b58121c7b8e63436a9e7031931166ce2bd9376140b1790d59ac20dcfbe
startMessage
public void startMessage()
{    root.start();    this.currentType = schema;    this.current = root;}
c0050e156bf5e112b0554bf9524370c3e6283a1c5ae4b1604d4372dd52f52bf9
endMessage
public void endMessage()
{    root.end();}
236c79d8ba13d45c1abe57e04adf551d76dcb00c9a850a52081487fd2a43a22f
startField
public void startField(String field, int index)
{    path.push(current);    typePath.push(currentType);    currentType = currentType.asGroupType().getType(index);    if (currentType.isPrimitive()) {        currentPrimitive = current.getConverter(index).asPrimitiveConverter();    } else {        current = current.getConverter(index).asGroupConverter();    }}
727a571f26f4770f35d9e03a67bbd8f2ba8b89efb3ee6a0616432db5d5f26dc0
endField
public void endField(String field, int index)
{    currentType = typePath.pop();    current = path.pop();}
bfaaecdf8637c04369d0caed5ce7be12b1f042c05c383dc5f56a16cbd1691cc5
startGroup
public void startGroup()
{    current.start();}
dfc16afb5d0316137d8951a7e04ed7d4672d9248b3dddee0a28c6939f9c45eaf
endGroup
public void endGroup()
{    current.end();}
eb80b1067a5ffb5802b37913bc5fed8ff814c76a74fa1b038fa559d98f1f8f4b
addInteger
public void addInteger(int value)
{    currentPrimitive.addInt(value);}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    currentPrimitive.addLong(value);}
23123f6657c241ab9b9f31f8efedc28a553ed91046d705121ce2667b065d6c17
addBoolean
public void addBoolean(boolean value)
{    currentPrimitive.addBoolean(value);}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    currentPrimitive.addBinary(value);}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    currentPrimitive.addFloat(value);}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    currentPrimitive.addDouble(value);}
ea956eca0ceec4b07db63def8a0f238be4f058fb174f02b053447578581df262
flush
public void flush()
{}
ca304a350854acdf244a2cf74c3388249f16ba00d3b44a3458dc1856b85240ef
validate
public void validate(String got)
{    assertEquals("event #" + count, expectations.pop(), got);    ++count;}
9fddadc133465bcc205e37664d9c24f54616a2bad48f393b5278fa8a250dca5d
convertPrimitiveType
public Converter convertPrimitiveType(final List<GroupType> path, final PrimitiveType primitiveType)
{    return new PrimitiveConverter() {        private void validate(String message) {            ExpectationValidatingConverter.this.validate(path(path, primitiveType) + message);        }        @Override        public void addBinary(Binary value) {            validate("addBinary(" + value.toStringUsingUTF8() + ")");        }        @Override        public void addBoolean(boolean value) {            validate("addBoolean(" + value + ")");        }        @Override        public void addDouble(double value) {            validate("addDouble(" + value + ")");        }        @Override        public void addFloat(float value) {            validate("addFloat(" + value + ")");        }        @Override        public void addInt(int value) {            validate("addInt(" + value + ")");        }        @Override        public void addLong(long value) {            validate("addLong(" + value + ")");        }    };}
29730d87b140677f9369f49d653fed33c3b3499e0681a941429908549277d4f5
validate
private void validate(String message)
{    ExpectationValidatingConverter.this.validate(path(path, primitiveType) + message);}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    validate("addBinary(" + value.toStringUsingUTF8() + ")");}
23123f6657c241ab9b9f31f8efedc28a553ed91046d705121ce2667b065d6c17
addBoolean
public void addBoolean(boolean value)
{    validate("addBoolean(" + value + ")");}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    validate("addDouble(" + value + ")");}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    validate("addFloat(" + value + ")");}
a2ac1f40a6e220ec515710128c8baf77a725ad0b9f1767a998f776f27fff6cf6
addInt
public void addInt(int value)
{    validate("addInt(" + value + ")");}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    validate("addLong(" + value + ")");}
2a91c3445463fe02c56eda820877f3c96fa4f2b678f76e9a7242e80719e59a4f
convertGroupType
public Converter convertGroupType(final List<GroupType> path, final GroupType groupType, final List<Converter> children)
{    return new GroupConverter() {        private void validate(String message) {            ExpectationValidatingConverter.this.validate(path(path, groupType) + message);        }        @Override        public void start() {            validate("start()");        }        @Override        public void end() {            validate("end()");        }        @Override        public Converter getConverter(int fieldIndex) {            return children.get(fieldIndex);        }    };}
29730d87b140677f9369f49d653fed33c3b3499e0681a941429908549277d4f5
validate
private void validate(String message)
{    ExpectationValidatingConverter.this.validate(path(path, groupType) + message);}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    validate("start()");}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    validate("end()");}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    return children.get(fieldIndex);}
cb5d8e8107f10533f6fea38b3f33e4f3b7800855ede38a8874ed735eb19eb23d
convertMessageType
public Converter convertMessageType(MessageType messageType, final List<Converter> children)
{    return new GroupConverter() {        @Override        public Converter getConverter(int fieldIndex) {            return children.get(fieldIndex);        }        @Override        public void start() {            validate("startMessage()");        }        @Override        public void end() {            validate("endMessage()");        }    };}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    return children.get(fieldIndex);}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    validate("startMessage()");}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    validate("endMessage()");}
9c1c88dacbfb5ad079ccd67f2cc57640e3f74bc218deac01474e0aa0eb19b693
getCurrentRecord
public Void getCurrentRecord()
{    return null;}
7f00a0be7f0919855afc550cf9f9ee8587a72ff88e9e8941adacbc678f981aab
path
private String path(List<GroupType> path, Type type)
{    String pathString = "";    if (path.size() > 0) {        for (int i = 1; i < path.size(); i++) {            pathString += path.get(i).getName() + ".";        }    }    pathString += type.getName() + ".";    return pathString;}
92fd854c4aebb01be238d83e407159211ea5cf60b5efd6fc7db8904dba13699b
getRootConverter
public GroupConverter getRootConverter()
{    return root;}
cdbd929d63133c5d9abd81a854c9cc09cd26a018e33d3b41f0633756054bc92a
validate
private void validate(String got)
{        assertEquals("event #" + count, expectations.pop(), got);    ++count;}
e5e2c9b58121c7b8e63436a9e7031931166ce2bd9376140b1790d59ac20dcfbe
startMessage
public void startMessage()
{    validate("startMessage()");}
bfaaecdf8637c04369d0caed5ce7be12b1f042c05c383dc5f56a16cbd1691cc5
startGroup
public void startGroup()
{    validate("startGroup()");}
236c79d8ba13d45c1abe57e04adf551d76dcb00c9a850a52081487fd2a43a22f
startField
public void startField(String field, int index)
{    validate("startField(" + field + ", " + index + ")");}
c0050e156bf5e112b0554bf9524370c3e6283a1c5ae4b1604d4372dd52f52bf9
endMessage
public void endMessage()
{    validate("endMessage()");}
dfc16afb5d0316137d8951a7e04ed7d4672d9248b3dddee0a28c6939f9c45eaf
endGroup
public void endGroup()
{    validate("endGroup()");}
727a571f26f4770f35d9e03a67bbd8f2ba8b89efb3ee6a0616432db5d5f26dc0
endField
public void endField(String field, int index)
{    validate("endField(" + field + ", " + index + ")");}
eb80b1067a5ffb5802b37913bc5fed8ff814c76a74fa1b038fa559d98f1f8f4b
addInteger
public void addInteger(int value)
{    validate("addInt(" + value + ")");}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    validate("addLong(" + value + ")");}
23123f6657c241ab9b9f31f8efedc28a553ed91046d705121ce2667b065d6c17
addBoolean
public void addBoolean(boolean value)
{    validate("addBoolean(" + value + ")");}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    validate("addBinary(" + value.toStringUsingUTF8() + ")");}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    validate("addFloat(" + value + ")");}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    validate("addDouble(" + value + ")");}
ea956eca0ceec4b07db63def8a0f238be4f058fb174f02b053447578581df262
flush
public void flush()
{    validate("flush()");}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    MemPageStore memPageStore = new MemPageStore(0);    write(memPageStore);    read(memPageStore);}
efe5588a2aa9b37f8e12350fa58a14f694f5c3d8f99016a743d5dea2b162872f
read
private static void read(MemPageStore memPageStore)
{    read(memPageStore, schema, "read all");    read(memPageStore, schema, "read all");    read(memPageStore, schema2, "read projected");    read(memPageStore, schema3, "read projected no Strings");}
7ae62732917d1c0d790345362f58b493d6c717619979462ba3d389c812e9b9d7
read
private static void read(MemPageStore memPageStore, MessageType myschema, String message)
{    MessageColumnIO columnIO = newColumnFactory(myschema);    System.out.println(message);    RecordMaterializer<Object> recordConsumer = new DummyRecordConverter(myschema);    RecordReader<Object> recordReader = columnIO.getRecordReader(memPageStore, recordConsumer);    read(recordReader, 2, myschema);    read(recordReader, 10000, myschema);    read(recordReader, 10000, myschema);    read(recordReader, 10000, myschema);    read(recordReader, 10000, myschema);    read(recordReader, 10000, myschema);    read(recordReader, 100000, myschema);    read(recordReader, 1000000, myschema);    System.out.println();}
6cf835a4307acd2b870edd7d49b54269f67871d165a85c4c5d1be2bb13f9ac6a
write
private static void write(MemPageStore memPageStore)
{    ColumnWriteStoreV1 columns = new ColumnWriteStoreV1(memPageStore, ParquetProperties.builder().withPageSize(50 * 1024 * 1024).withDictionaryEncoding(false).build());    MessageColumnIO columnIO = newColumnFactory(schema);    GroupWriter groupWriter = new GroupWriter(columnIO.getRecordWriter(columns), schema);    groupWriter.write(r1);    groupWriter.write(r2);    write(memPageStore, groupWriter, 10000);    write(memPageStore, groupWriter, 10000);    write(memPageStore, groupWriter, 10000);    write(memPageStore, groupWriter, 10000);    write(memPageStore, groupWriter, 10000);    write(memPageStore, groupWriter, 100000);    write(memPageStore, groupWriter, 1000000);    columns.flush();    System.out.println();    System.out.println(columns.getBufferedSize() + " bytes used total");    System.out.println("max col size: " + columns.maxColMemSize() + " bytes");}
881edcef847dbd90836a542f7617d09e5152b00b8fedf17c4d4cdc5b98c18571
newColumnFactory
private static MessageColumnIO newColumnFactory(MessageType schema)
{    return new ColumnIOFactory().getColumnIO(schema);}
a58c2f8260b421a26706a8dbc2bcac8c2c6a89ea6ad956d3112c28d938451c2d
read
private static void read(RecordReader<Object> recordReader, int count, MessageType schema)
{    Object[] records = new Object[count];    System.gc();    System.out.print("no gc <");    long t0 = System.currentTimeMillis();    for (int i = 0; i < records.length; i++) {        records[i] = recordReader.read();    }    long t1 = System.currentTimeMillis();    System.out.print("> ");    long t = t1 - t0;        float err = (float) 100 * 2 / t;    System.out.printf("                                            read %,9d recs in %,5d ms at %,9d rec/s err: %3.2f%%\n", count, t, t == 0 ? 0 : count * 1000 / t, err);    if (!records[0].equals("end()")) {        throw new RuntimeException("" + records[0]);    }}
aff32cfc5a1089d071d9436e544fa4b7dd2a34e08d80f91bf927e7d2a684e023
write
private static void write(MemPageStore memPageStore, GroupWriter groupWriter, int count)
{    long t0 = System.currentTimeMillis();    for (int i = 0; i < count; i++) {        groupWriter.write(r1);    }    long t1 = System.currentTimeMillis();    long t = t1 - t0;    memPageStore.addRowCount(count);    System.out.printf("written %,9d recs in %,5d ms at %,9d rec/s\n", count, t, t == 0 ? 0 : count * 1000 / t);}
1420f3322811efcea56773615b3c9b3695ac75ae3f056851fcb7a27523138958
data
public static Collection<Object[]> data() throws IOException
{    Object[][] data = { { true }, { false } };    return Arrays.asList(data);}
1aca96105510472967528a9c2eca094f717f052dd61eba38822e75be822619b9
testSchema
public void testSchema()
{    assertEquals(schemaString, schema.toString());}
58953b60b78d9b37be525da69b38937ab65f2a175eb2a50a82db95d1142714bf
testReadUsingRequestedSchemaWithExtraFields
public void testReadUsingRequestedSchemaWithExtraFields()
{    MessageType orginalSchema = new MessageType("schema", new PrimitiveType(REQUIRED, INT32, "a"), new PrimitiveType(OPTIONAL, INT32, "b"));    MessageType schemaWithExtraField = new MessageType("schema", new PrimitiveType(OPTIONAL, INT32, "b"), new PrimitiveType(OPTIONAL, INT32, "a"), new PrimitiveType(OPTIONAL, INT32, "c"));    MemPageStore memPageStoreForOriginalSchema = new MemPageStore(1);    MemPageStore memPageStoreForSchemaWithExtraField = new MemPageStore(1);    SimpleGroupFactory groupFactory = new SimpleGroupFactory(orginalSchema);    writeGroups(orginalSchema, memPageStoreForOriginalSchema, groupFactory.newGroup().append("a", 1).append("b", 2));    SimpleGroupFactory groupFactory2 = new SimpleGroupFactory(schemaWithExtraField);    writeGroups(schemaWithExtraField, memPageStoreForSchemaWithExtraField, groupFactory2.newGroup().append("a", 1).append("b", 2).append("c", 3));    {        List<Group> groups = new ArrayList<Group>();        groups.addAll(readGroups(memPageStoreForOriginalSchema, orginalSchema, schemaWithExtraField, 1));        groups.addAll(readGroups(memPageStoreForSchemaWithExtraField, schemaWithExtraField, schemaWithExtraField, 1));                        Object[][] expected = { { 2, 1, null }, { 2, 1, 3 }         };        validateGroups(groups, expected);    }}
accde7f0c197571949a5398ddec79d159ed652ca365634c568415276b01cd295
testReadUsingRequestedSchemaWithIncompatibleField
public void testReadUsingRequestedSchemaWithIncompatibleField()
{    MessageType originalSchema = new MessageType("schema", new PrimitiveType(OPTIONAL, INT32, "e"));    MemPageStore store = new MemPageStore(1);    SimpleGroupFactory groupFactory = new SimpleGroupFactory(originalSchema);    writeGroups(originalSchema, store, groupFactory.newGroup().append("e", 4));    try {        MessageType schemaWithIncompatibleField = new MessageType("schema",         new PrimitiveType(OPTIONAL, BINARY, "e"));        readGroups(store, originalSchema, schemaWithIncompatibleField, 1);        fail("should have thrown an incompatible schema exception");    } catch (ParquetDecodingException e) {        assertEquals("The requested schema is not compatible with the file schema. incompatible types: optional binary e != optional int32 e", e.getMessage());    }}
74f66282f683eec2927a46b8f27c2cce2df1e41d3549125ba5ebcc3c4fe6c4da
testReadUsingSchemaWithRequiredFieldThatWasOptional
public void testReadUsingSchemaWithRequiredFieldThatWasOptional()
{    MessageType originalSchema = new MessageType("schema", new PrimitiveType(OPTIONAL, INT32, "e"));    MemPageStore store = new MemPageStore(1);    SimpleGroupFactory groupFactory = new SimpleGroupFactory(originalSchema);    writeGroups(originalSchema, store, groupFactory.newGroup().append("e", 4));    try {        MessageType schemaWithRequiredFieldThatWasOptional = new MessageType("schema",         new PrimitiveType(REQUIRED, INT32, "e"));        readGroups(store, originalSchema, schemaWithRequiredFieldThatWasOptional, 1);        fail("should have thrown an incompatible schema exception");    } catch (ParquetDecodingException e) {        assertEquals("The requested schema is not compatible with the file schema. incompatible types: required int32 e != optional int32 e", e.getMessage());    }}
1cbe38e97114b33a341fd48c66486d8955b7cecbe88818845eb380293850ac27
testReadUsingProjectedSchema
public void testReadUsingProjectedSchema()
{    MessageType orginalSchema = new MessageType("schema", new PrimitiveType(REQUIRED, INT32, "a"), new PrimitiveType(REQUIRED, INT32, "b"));    MessageType projectedSchema = new MessageType("schema", new PrimitiveType(OPTIONAL, INT32, "b"));    MemPageStore store = new MemPageStore(1);    SimpleGroupFactory groupFactory = new SimpleGroupFactory(orginalSchema);    writeGroups(orginalSchema, store, groupFactory.newGroup().append("a", 1).append("b", 2));    {        List<Group> groups = new ArrayList<Group>();        groups.addAll(readGroups(store, orginalSchema, projectedSchema, 1));        Object[][] expected = { { 2 } };        validateGroups(groups, expected);    }}
76b04fe14fe2b0754684257be543b2a6f37f6e4bb46dbd965e92e77113cbf023
validateGroups
private void validateGroups(List<Group> groups1, Object[][] e1)
{    Iterator<Group> i1 = groups1.iterator();    for (int i = 0; i < e1.length; i++) {        Object[] objects = e1[i];        Group next = i1.next();        for (int j = 0; j < objects.length; j++) {            Object object = objects[j];            if (object == null) {                assertEquals(0, next.getFieldRepetitionCount(j));            } else {                assertEquals("looking for r[" + i + "][" + j + "][0]=" + object, 1, next.getFieldRepetitionCount(j));                assertEquals(object, next.getInteger(j, 0));            }        }    }}
a57b118abed0ed4a910cfa680841a8c26d2056846cebb99a0b024a731d07f20d
readGroups
private List<Group> readGroups(MemPageStore memPageStore, MessageType fileSchema, MessageType requestedSchema, int n)
{    ColumnIOFactory columnIOFactory = new ColumnIOFactory(true);    MessageColumnIO columnIO = columnIOFactory.getColumnIO(requestedSchema, fileSchema);    RecordReaderImplementation<Group> recordReader = getRecordReader(columnIO, requestedSchema, memPageStore);    List<Group> groups = new ArrayList<Group>();    for (int i = 0; i < n; i++) {        groups.add(recordReader.read());    }    return groups;}
1b03ec5f6b73067023d450a8d21363ff4f2f56b5db205666e2f368ce917483fc
writeGroups
private void writeGroups(MessageType writtenSchema, MemPageStore memPageStore, Group... groups)
{    ColumnIOFactory columnIOFactory = new ColumnIOFactory(true);    ColumnWriteStoreV1 columns = newColumnWriteStore(memPageStore);    MessageColumnIO columnIO = columnIOFactory.getColumnIO(writtenSchema);    RecordConsumer recordWriter = columnIO.getRecordWriter(columns);    GroupWriter groupWriter = new GroupWriter(recordWriter, writtenSchema);    for (Group group : groups) {        groupWriter.write(group);    }    recordWriter.flush();    columns.flush();}
f039e8129b175aed0d127e311ca646a1a03ffb87889b523b4f1ff80540323b18
testColumnIO
public void testColumnIO()
{    log(schema);    log("r1");    log(r1);    log("r2");    log(r2);    MemPageStore memPageStore = new MemPageStore(2);    ColumnWriteStoreV1 columns = newColumnWriteStore(memPageStore);    ColumnIOFactory columnIOFactory = new ColumnIOFactory(true);    {        MessageColumnIO columnIO = columnIOFactory.getColumnIO(schema);        log(columnIO);        RecordConsumer recordWriter = columnIO.getRecordWriter(columns);        GroupWriter groupWriter = new GroupWriter(recordWriter, schema);        groupWriter.write(r1);        groupWriter.write(r2);        recordWriter.flush();        columns.flush();        log(columns);        log("=========");        RecordReaderImplementation<Group> recordReader = getRecordReader(columnIO, schema, memPageStore);        validateFSA(expectedFSA, columnIO, recordReader);        List<Group> records = new ArrayList<Group>();        records.add(recordReader.read());        records.add(recordReader.read());        int i = 0;        for (Group record : records) {            log("r" + (++i));            log(record);        }        assertEquals("deserialization does not display the same result", r1.toString(), records.get(0).toString());        assertEquals("deserialization does not display the same result", r2.toString(), records.get(1).toString());    }    {        MessageColumnIO columnIO2 = columnIOFactory.getColumnIO(schema2);        List<Group> records = new ArrayList<Group>();        RecordReaderImplementation<Group> recordReader = getRecordReader(columnIO2, schema2, memPageStore);        validateFSA(expectedFSA2, columnIO2, recordReader);        records.add(recordReader.read());        records.add(recordReader.read());        int i = 0;        for (Group record : records) {            log("r" + (++i));            log(record);        }        assertEquals("deserialization does not display the expected result", pr1.toString(), records.get(0).toString());        assertEquals("deserialization does not display the expected result", pr2.toString(), records.get(1).toString());    }}
b5291846b88f6a3647f35052f41eac7cd350a4d5fb69ce77875d01fdd1ba7664
testOneOfEach
public void testOneOfEach()
{    MessageType oneOfEachSchema = MessageTypeParser.parseMessageType(oneOfEach);    GroupFactory gf = new SimpleGroupFactory(oneOfEachSchema);    Group g1 = gf.newGroup().append("a", 1l).append("b", 2).append("c", 3.0f).append("d", 4.0d).append("e", true).append("f", Binary.fromString("6")).append("g", new NanoTime(1234, System.currentTimeMillis() * 1000)).append("h", Binary.fromString("abc"));    testSchema(oneOfEachSchema, Arrays.asList(g1));}
a1db96df7f7c0ccae1eeb1d1c3bbe5fb21d2d030e2cd98e2ba0323f840a159f6
testRequiredOfRequired
public void testRequiredOfRequired()
{    MessageType reqreqSchema = MessageTypeParser.parseMessageType("message Document {\n" + "  required group foo {\n" + "    required int64 bar;\n" + "  }\n" + "}\n");    GroupFactory gf = new SimpleGroupFactory(reqreqSchema);    Group g1 = gf.newGroup();    g1.addGroup("foo").append("bar", 2l);    testSchema(reqreqSchema, Arrays.asList(g1));}
c1a4d416512b2874902390ded230b38f7ef312fc24c4e2e84dddf287e0b71427
testOptionalRequiredInteraction
public void testOptionalRequiredInteraction()
{    for (int i = 0; i < 6; i++) {        Type current = new PrimitiveType(Repetition.REQUIRED, PrimitiveTypeName.BINARY, "primitive");        for (int j = 0; j < i; j++) {            current = new GroupType(Repetition.REQUIRED, "req" + j, current);        }        MessageType groupSchema = new MessageType("schema" + i, current);        GroupFactory gf = new SimpleGroupFactory(groupSchema);        List<Group> groups = new ArrayList<Group>();        Group root = gf.newGroup();        Group currentGroup = root;        for (int j = 0; j < i; j++) {            currentGroup = currentGroup.addGroup(0);        }        currentGroup.add(0, Binary.fromString("foo"));        groups.add(root);        testSchema(groupSchema, groups);    }    for (int i = 0; i < 6; i++) {        Type current = new PrimitiveType(Repetition.OPTIONAL, PrimitiveTypeName.BINARY, "primitive");        for (int j = 0; j < i; j++) {            current = new GroupType(Repetition.REQUIRED, "req" + j, current);        }        MessageType groupSchema = new MessageType("schema" + (i + 6), current);        GroupFactory gf = new SimpleGroupFactory(groupSchema);        List<Group> groups = new ArrayList<Group>();        Group rootDefined = gf.newGroup();        Group rootUndefined = gf.newGroup();        Group currentDefinedGroup = rootDefined;        Group currentUndefinedGroup = rootUndefined;        for (int j = 0; j < i; j++) {            currentDefinedGroup = currentDefinedGroup.addGroup(0);            currentUndefinedGroup = currentUndefinedGroup.addGroup(0);        }        currentDefinedGroup.add(0, Binary.fromString("foo"));        groups.add(rootDefined);        groups.add(rootUndefined);        testSchema(groupSchema, groups);    }    for (int i = 0; i < 6; i++) {        Type current = new PrimitiveType(Repetition.OPTIONAL, PrimitiveTypeName.BINARY, "primitive");        for (int j = 0; j < 6; j++) {            current = new GroupType(i == j ? Repetition.OPTIONAL : Repetition.REQUIRED, "req" + j, current);        }        MessageType groupSchema = new MessageType("schema" + (i + 12), current);        GroupFactory gf = new SimpleGroupFactory(groupSchema);        List<Group> groups = new ArrayList<Group>();        Group rootDefined = gf.newGroup();        Group rootUndefined = gf.newGroup();        Group currentDefinedGroup = rootDefined;        Group currentUndefinedGroup = rootUndefined;        for (int j = 0; j < 6; j++) {            currentDefinedGroup = currentDefinedGroup.addGroup(0);            if (i < j) {                currentUndefinedGroup = currentUndefinedGroup.addGroup(0);            }        }        currentDefinedGroup.add(0, Binary.fromString("foo"));        groups.add(rootDefined);        groups.add(rootUndefined);        testSchema(groupSchema, groups);    }}
cdfec64470d1a79f97fe72485480ef184c30a1e212a5092729295ac7d7a1225c
testSchema
private void testSchema(MessageType messageSchema, List<Group> groups)
{    MemPageStore memPageStore = new MemPageStore(groups.size());    ColumnWriteStoreV1 columns = newColumnWriteStore(memPageStore);    ColumnIOFactory columnIOFactory = new ColumnIOFactory(true);    MessageColumnIO columnIO = columnIOFactory.getColumnIO(messageSchema);    log(columnIO);        RecordConsumer recordWriter = columnIO.getRecordWriter(columns);    GroupWriter groupWriter = new GroupWriter(recordWriter, messageSchema);    for (Group group : groups) {        groupWriter.write(group);    }    recordWriter.flush();    columns.flush();        RecordReaderImplementation<Group> recordReader = getRecordReader(columnIO, messageSchema, memPageStore);    for (Group group : groups) {        final Group got = recordReader.read();        assertEquals("deserialization does not display the same result", group.toString(), got.toString());    }}
56e7ee5e761a3637658c7ededbd3a4a41b92a45b99bc591bf76a9efbdc3b99b6
getRecordReader
private RecordReaderImplementation<Group> getRecordReader(MessageColumnIO columnIO, MessageType schema, PageReadStore pageReadStore)
{    RecordMaterializer<Group> recordConverter = new GroupRecordConverter(schema);    return (RecordReaderImplementation<Group>) columnIO.getRecordReader(pageReadStore, recordConverter);}
79531c049672d687009b9e8ca769bb9ac88f4fe703903af221cad741ef569a09
log
private void log(Object o)
{    LOG.info("{}", o);}
62810153eeaced416f93aaf55cf4e82a91fc5d861495738a292e48fbed95073c
validateFSA
private void validateFSA(int[][] expectedFSA, MessageColumnIO columnIO, RecordReaderImplementation<?> recordReader)
{    log("FSA: ----");    List<PrimitiveColumnIO> leaves = columnIO.getLeaves();    for (int i = 0; i < leaves.size(); ++i) {        PrimitiveColumnIO primitiveColumnIO = leaves.get(i);        log(Arrays.toString(primitiveColumnIO.getFieldPath()));        for (int r = 0; r < expectedFSA[i].length; r++) {            int next = expectedFSA[i][r];            log(" " + r + " -> " + (next == leaves.size() ? "end" : Arrays.toString(leaves.get(next).getFieldPath())) + ": " + recordReader.getNextLevel(i, r));            assertEquals(Arrays.toString(primitiveColumnIO.getFieldPath()) + ": " + r + " -> ", next, recordReader.getNextReader(i, r));        }    }    log("----");}
d27c1dbe27d04870f7a050c983a01b81b647127bdbbffb8b036b654509465280
testPushParser
public void testPushParser()
{    MemPageStore memPageStore = new MemPageStore(1);    ColumnWriteStoreV1 columns = newColumnWriteStore(memPageStore);    MessageColumnIO columnIO = new ColumnIOFactory().getColumnIO(schema);    RecordConsumer recordWriter = columnIO.getRecordWriter(columns);    new GroupWriter(recordWriter, schema).write(r1);    recordWriter.flush();    columns.flush();    RecordReader<Void> recordReader = columnIO.getRecordReader(memPageStore, new ExpectationValidatingConverter(expectedEventsForR1, schema));    recordReader.read();}
1919ef412555995344a12a603d988aedf1a61000466d199afaf81fd47529cc10
newColumnWriteStore
private ColumnWriteStoreV1 newColumnWriteStore(MemPageStore memPageStore)
{    return new ColumnWriteStoreV1(memPageStore, ParquetProperties.builder().withPageSize(800).withDictionaryPageSize(800).withDictionaryEncoding(useDictionary).build());}
7cf16c350d45c806dcabcf0740e9f2cdcc1f57b35e67f44cda931beb73175789
testEmptyField
public void testEmptyField()
{    MemPageStore memPageStore = new MemPageStore(1);    ColumnWriteStoreV1 columns = newColumnWriteStore(memPageStore);    MessageColumnIO columnIO = new ColumnIOFactory(true).getColumnIO(schema);    final RecordConsumer recordWriter = columnIO.getRecordWriter(columns);    recordWriter.startMessage();    recordWriter.startField("DocId", 0);    recordWriter.addLong(0);    recordWriter.endField("DocId", 0);    recordWriter.startField("Links", 1);    try {        recordWriter.endField("Links", 1);        Assert.fail("expected exception because of empty field");    } catch (ParquetEncodingException e) {        Assert.assertEquals("empty fields are illegal, the field should be ommited completely instead", e.getMessage());    }}
a5132141d7b89237d523d075c1dd4614208d685bf42d4dc7839d0a67c8a27d95
testGroupWriter
public void testGroupWriter()
{    List<Group> result = new ArrayList<Group>();    final GroupRecordConverter groupRecordConverter = new GroupRecordConverter(schema);    RecordConsumer groupConsumer = new ConverterConsumer(groupRecordConverter.getRootConverter(), schema);    GroupWriter groupWriter = new GroupWriter(new RecordConsumerLoggingWrapper(groupConsumer), schema);    groupWriter.write(r1);    result.add(groupRecordConverter.getCurrentRecord());    groupWriter.write(r2);    result.add(groupRecordConverter.getCurrentRecord());    assertEquals("deserialization does not display the expected result", result.get(0).toString(), r1.toString());    assertEquals("deserialization does not display the expected result", result.get(1).toString(), r2.toString());}
4f72629de7d4a27e11764254013de532ad30c3b5c84796db9d7ffd18d3120cda
testWriteWithGroupWriter
public void testWriteWithGroupWriter()
{    final String[] expected = { "[DocId]: 10, r:0, d:0", "[Links, Forward]: 20, r:0, d:2", "[Links, Forward]: 40, r:1, d:2", "[Links, Forward]: 60, r:1, d:2", "[Links, Backward]: null, r:0, d:1", "[Name, Language, Code]: en-us, r:0, d:2", "[Name, Language, Country]: us, r:0, d:3", "[Name, Language, Code]: en, r:2, d:2", "[Name, Language, Country]: null, r:2, d:2", "[Name, Url]: http://A, r:0, d:2", "[Name, Url]: http://B, r:1, d:2", "[Name, Language, Code]: null, r:1, d:1", "[Name, Language, Country]: null, r:1, d:1", "[Name, Language, Code]: en-gb, r:1, d:2", "[Name, Language, Country]: gb, r:1, d:3", "[Name, Url]: null, r:1, d:1", "[DocId]: 20, r:0, d:0", "[Links, Backward]: 10, r:0, d:2", "[Links, Backward]: 30, r:1, d:2", "[Links, Forward]: 80, r:0, d:2", "[Name, Url]: http://C, r:0, d:2", "[Name, Language, Code]: null, r:0, d:1", "[Name, Language, Country]: null, r:0, d:1" };    ValidatingColumnWriteStore columns = new ValidatingColumnWriteStore(expected);    MessageColumnIO columnIO = new ColumnIOFactory().getColumnIO(schema);    RecordConsumer recordWriter = columnIO.getRecordWriter(columns);    GroupWriter groupWriter = new GroupWriter(recordWriter, schema);    groupWriter.write(r1);    groupWriter.write(r2);    recordWriter.flush();    columns.validate();    columns.flush();    columns.close();}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{}
38cc7f6e74b60bbc1670dc915422d0fc9ca0a1a5507547b06b4944ea92e07a70
getColumnWriter
public ColumnWriter getColumnWriter(final ColumnDescriptor path)
{    return new ColumnWriter() {        private void validate(Object value, int repetitionLevel, int definitionLevel) {            String actual = Arrays.toString(path.getPath()) + ": " + value + ", r:" + repetitionLevel + ", d:" + definitionLevel;            assertEquals("event #" + counter, expected[counter], actual);            ++counter;        }        @Override        public void writeNull(int repetitionLevel, int definitionLevel) {            validate(null, repetitionLevel, definitionLevel);        }        @Override        public void write(Binary value, int repetitionLevel, int definitionLevel) {            validate(value.toStringUsingUTF8(), repetitionLevel, definitionLevel);        }        @Override        public void write(float value, int repetitionLevel, int definitionLevel) {            validate(value, repetitionLevel, definitionLevel);        }        @Override        public void write(boolean value, int repetitionLevel, int definitionLevel) {            validate(value, repetitionLevel, definitionLevel);        }        @Override        public void write(int value, int repetitionLevel, int definitionLevel) {            validate(value, repetitionLevel, definitionLevel);        }        @Override        public void write(long value, int repetitionLevel, int definitionLevel) {            validate(value, repetitionLevel, definitionLevel);        }        @Override        public void close() {        }        @Override        public long getBufferedSizeInMemory() {            throw new UnsupportedOperationException();        }        @Override        public void write(double value, int repetitionLevel, int definitionLevel) {            validate(value, repetitionLevel, definitionLevel);        }    };}
a98374ea90a60ad9ff02350100ff54d53f9780826a64dd8ef2ae04f7eaea9478
validate
private void validate(Object value, int repetitionLevel, int definitionLevel)
{    String actual = Arrays.toString(path.getPath()) + ": " + value + ", r:" + repetitionLevel + ", d:" + definitionLevel;    assertEquals("event #" + counter, expected[counter], actual);    ++counter;}
cbd3b64601d64801ea2b6b5cbd4ced5dc1ab2411f49b891edb97cbc88b23fdbd
writeNull
public void writeNull(int repetitionLevel, int definitionLevel)
{    validate(null, repetitionLevel, definitionLevel);}
7b24db9f5d5c7ebb22495d8f1c7abbf4122ad81d8bba3cbc49050dea4fbbacab
write
public void write(Binary value, int repetitionLevel, int definitionLevel)
{    validate(value.toStringUsingUTF8(), repetitionLevel, definitionLevel);}
d39fb6324bd5b06b761cf916ec238d9704e8f6b7a4f733df9d220ea42695900d
write
public void write(float value, int repetitionLevel, int definitionLevel)
{    validate(value, repetitionLevel, definitionLevel);}
dbe0fcdf27e1ffaaf36a89f63674baebe3e1fd4a4e8ea319ce997e38a1fc4702
write
public void write(boolean value, int repetitionLevel, int definitionLevel)
{    validate(value, repetitionLevel, definitionLevel);}
53c3e69fd1408e8633b8a927e44162bb73dfae96cea1c615d82f559c276b8640
write
public void write(int value, int repetitionLevel, int definitionLevel)
{    validate(value, repetitionLevel, definitionLevel);}
b5ff81594e698e7e5429928ea010d7759f6083e62eb1a6c132a799a10fe088c7
write
public void write(long value, int repetitionLevel, int definitionLevel)
{    validate(value, repetitionLevel, definitionLevel);}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{}
7e6728033b48c8641ea3e1ea2de0cd9690f159308b12f4450c6166714177d6e3
getBufferedSizeInMemory
public long getBufferedSizeInMemory()
{    throw new UnsupportedOperationException();}
b4a558026ed47a9b43b29d94165e24d48fda9dabc838f587bb58f7bf2803af2e
write
public void write(double value, int repetitionLevel, int definitionLevel)
{    validate(value, repetitionLevel, definitionLevel);}
675257a90384295af5c28f92ff6b0f5f89faf18e57bcf5f69e929c19afc2b1cf
validate
public void validate()
{    assertEquals("read all events", expected.length, counter);}
902efc93e2b44aa9778c16b0540857076ef96fb4b47ce98941d77f435e6cdac8
endRecord
public void endRecord()
{}
ea956eca0ceec4b07db63def8a0f238be4f058fb174f02b053447578581df262
flush
public void flush()
{}
3276143416d44249f488f85b127246b083e1e6024d88125aae60e635a8ad8ba7
getAllocatedSize
public long getAllocatedSize()
{    return 0;}
0c921188cddfdbdd5e940a92767fca400663f7ba7c1b4fbfdb5a2e991b21cb93
getBufferedSize
public long getBufferedSize()
{    return 0;}
e4a1e31ebb8e326fa4817a42e9e67e3574f771bad021989e779433ddb97f34af
memUsageString
public String memUsageString()
{    return null;}
54d91c296842e60cb65d0a08a8f0ffba45b398f0c11dca923229ea68157e9a6d
functionToApply
public boolean functionToApply(long input)
{    return input > 15;}
bd081a2069711cb6909de2b422989eccbd9996dc31521234cea762e20e425341
functionToApply
public boolean functionToApply(String input)
{    return input.endsWith("A");}
3e6584b0fa481bb626ea952683f458222165e7b42a39e0f8311739b31fec3471
readAll
private List<Group> readAll(RecordReader<Group> reader)
{    List<Group> result = new ArrayList<Group>();    Group g;    while ((g = reader.read()) != null) {        result.add(g);    }    return result;}
c507ac51442e17e6cd632327c3635893a3a4739af520afc23ccb0f47ebaa29e9
readOne
private void readOne(RecordReader<Group> reader, String message, Group expected)
{    List<Group> result = readAll(reader);    assertEquals(message + ": " + result, 1, result.size());    assertEquals("filtering did not return the correct record", expected.toString(), result.get(0).toString());}
b6bfbf039db5bc3c157ac8c26265166029359d50e93edea5860bf74701535674
testFilterOnInteger
public void testFilterOnInteger()
{    MessageColumnIO columnIO = new ColumnIOFactory(true).getColumnIO(schema);    MemPageStore memPageStore = writeTestRecords(columnIO, 1);        RecordMaterializer<Group> recordConverter = new GroupRecordConverter(schema);    RecordReaderImplementation<Group> recordReader = (RecordReaderImplementation<Group>) columnIO.getRecordReader(memPageStore, recordConverter, FilterCompat.get(column("DocId", equalTo(10l))));    readOne(recordReader, "r2 filtered out", r1);        recordReader = (RecordReaderImplementation<Group>) columnIO.getRecordReader(memPageStore, recordConverter, FilterCompat.get(column("DocId", equalTo(20l))));    readOne(recordReader, "r1 filtered out", r2);}
ac4a96992ab7b4d8c5d90d260cd3b908b86a064449ac5a33a4dd09e4ed421331
testApplyFunctionFilterOnLong
public void testApplyFunctionFilterOnLong()
{    MessageColumnIO columnIO = new ColumnIOFactory(true).getColumnIO(schema);    MemPageStore memPageStore = writeTestRecords(columnIO, 1);        RecordMaterializer<Group> recordConverter = new GroupRecordConverter(schema);    RecordReaderImplementation<Group> recordReader = (RecordReaderImplementation<Group>) columnIO.getRecordReader(memPageStore, recordConverter, FilterCompat.get(column("DocId", equalTo(10l))));    readOne(recordReader, "r2 filtered out", r1);        recordReader = (RecordReaderImplementation<Group>) columnIO.getRecordReader(memPageStore, recordConverter, FilterCompat.get(column("DocId", applyFunctionToLong(new LongGreaterThan15Predicate()))));    readOne(recordReader, "r1 filtered out", r2);}
c47b5595be34246fe284c0b2f253504c67312d340a39768b873940c492ceefea
testFilterOnString
public void testFilterOnString()
{    MessageColumnIO columnIO = new ColumnIOFactory(true).getColumnIO(schema);    MemPageStore memPageStore = writeTestRecords(columnIO, 1);        RecordMaterializer<Group> recordConverter = new GroupRecordConverter(schema);    RecordReaderImplementation<Group> recordReader = (RecordReaderImplementation<Group>) columnIO.getRecordReader(memPageStore, recordConverter, FilterCompat.get(column("Name.Url", equalTo("http://A"))));    readOne(recordReader, "r2 filtered out", r1);            recordReader = (RecordReaderImplementation<Group>) columnIO.getRecordReader(memPageStore, recordConverter, FilterCompat.get(column("Name.Url", equalTo("http://B"))));    List<Group> all = readAll(recordReader);    assertEquals("There should be no matching records: " + all, 0, all.size());        recordReader = (RecordReaderImplementation<Group>) columnIO.getRecordReader(memPageStore, recordConverter, FilterCompat.get(column("Name.Url", equalTo("http://C"))));    readOne(recordReader, "r1 filtered out", r2);}
f4ef130c42373853d7d92b5259d8907e9204ce1ea25ea2c739851c041baeb7d4
testApplyFunctionFilterOnString
public void testApplyFunctionFilterOnString()
{    MessageColumnIO columnIO = new ColumnIOFactory(true).getColumnIO(schema);    MemPageStore memPageStore = writeTestRecords(columnIO, 1);        RecordMaterializer<Group> recordConverter = new GroupRecordConverter(schema);    RecordReaderImplementation<Group> recordReader = (RecordReaderImplementation<Group>) columnIO.getRecordReader(memPageStore, recordConverter, FilterCompat.get(column("Name.Url", applyFunctionToString(new StringEndsWithAPredicate()))));    readOne(recordReader, "r2 filtered out", r1);            recordReader = (RecordReaderImplementation<Group>) columnIO.getRecordReader(memPageStore, recordConverter, FilterCompat.get(column("Name.Url", equalTo("http://B"))));    List<Group> all = readAll(recordReader);    assertEquals("There should be no matching records: " + all, 0, all.size());        recordReader = (RecordReaderImplementation<Group>) columnIO.getRecordReader(memPageStore, recordConverter, FilterCompat.get(column("Name.Url", equalTo("http://C"))));    readOne(recordReader, "r1 filtered out", r2);}
7ab2fc748cc37af26c6c1c43089477525cb3d5a3ab945582fa44608a6379979b
testPaged
public void testPaged()
{    MessageColumnIO columnIO = new ColumnIOFactory(true).getColumnIO(schema);    MemPageStore memPageStore = writeTestRecords(columnIO, 6);    RecordMaterializer<Group> recordConverter = new GroupRecordConverter(schema);    RecordReaderImplementation<Group> recordReader = (RecordReaderImplementation<Group>) columnIO.getRecordReader(memPageStore, recordConverter, FilterCompat.get(page(4, 4)));    List<Group> all = readAll(recordReader);    assertEquals("expecting records " + all, 4, all.size());    for (int i = 0; i < all.size(); i++) {        assertEquals("expecting record", (i % 2 == 0 ? r2 : r1).toString(), all.get(i).toString());    }}
87ea4b50ed214419510dfdfb22456c008e46eeec40c42f686f66d90d828d08dd
testFilteredAndPaged
public void testFilteredAndPaged()
{    MessageColumnIO columnIO = new ColumnIOFactory(true).getColumnIO(schema);    MemPageStore memPageStore = writeTestRecords(columnIO, 8);    RecordMaterializer<Group> recordConverter = new GroupRecordConverter(schema);    RecordReaderImplementation<Group> recordReader = (RecordReaderImplementation<Group>) columnIO.getRecordReader(memPageStore, recordConverter, FilterCompat.get(and(column("DocId", equalTo(10l)), page(2, 4))));    List<Group> all = readAll(recordReader);    assertEquals("expecting 4 records " + all, 4, all.size());    for (int i = 0; i < all.size(); i++) {        assertEquals("expecting record1", r1.toString(), all.get(i).toString());    }}
7eb7363430e8e97231ca7ff671a6f9fe1210d04c7afdd24eefabc6f26459871c
testFilteredOrPaged
public void testFilteredOrPaged()
{    MessageColumnIO columnIO = new ColumnIOFactory(true).getColumnIO(schema);    MemPageStore memPageStore = writeTestRecords(columnIO, 8);    RecordMaterializer<Group> recordConverter = new GroupRecordConverter(schema);    RecordReaderImplementation<Group> recordReader = (RecordReaderImplementation<Group>) columnIO.getRecordReader(memPageStore, recordConverter, FilterCompat.get(or(column("DocId", equalTo(10l)), column("DocId", equalTo(20l)))));    List<Group> all = readAll(recordReader);    assertEquals("expecting 8 records " + all, 16, all.size());    for (int i = 0; i < all.size() / 2; i++) {        assertEquals("expecting record1", r1.toString(), all.get(2 * i).toString());        assertEquals("expecting record2", r2.toString(), all.get(2 * i + 1).toString());    }}
bf4e72b55b83760fce50219590c32f68a1d99b2bcf59f0aaa53bc630392743db
testFilteredNotPaged
public void testFilteredNotPaged()
{    MessageColumnIO columnIO = new ColumnIOFactory(true).getColumnIO(schema);    MemPageStore memPageStore = writeTestRecords(columnIO, 8);    RecordMaterializer<Group> recordConverter = new GroupRecordConverter(schema);    RecordReaderImplementation<Group> recordReader = (RecordReaderImplementation<Group>) columnIO.getRecordReader(memPageStore, recordConverter, FilterCompat.get(not(column("DocId", equalTo(10l)))));    List<Group> all = readAll(recordReader);    assertEquals("expecting 8 records " + all, 8, all.size());    for (int i = 0; i < all.size(); i++) {        assertEquals("expecting record2", r2.toString(), all.get(i).toString());    }}
163817caafcfde5800b3609e7a3c596f6c6fae9823bb2f29f92f80f3a787b14f
writeTestRecords
private MemPageStore writeTestRecords(MessageColumnIO columnIO, int number)
{    MemPageStore memPageStore = new MemPageStore(number * 2);    ColumnWriteStoreV1 columns = new ColumnWriteStoreV1(memPageStore, ParquetProperties.builder().withPageSize(800).withDictionaryEncoding(false).build());    RecordConsumer recordWriter = columnIO.getRecordWriter(columns);    GroupWriter groupWriter = new GroupWriter(recordWriter, schema);    for (int i = 0; i < number; i++) {        groupWriter.write(r1);        groupWriter.write(r2);    }    recordWriter.flush();    columns.flush();    return memPageStore;}
be99768950f8df78033704250559a587404e4e92dfce8f6d76d312d71da9e826
testPaperExample
public void testPaperExample()
{    String example = "message Document {\n" + "  required int64 DocId;\n" + "  optional group Links {\n" + "    repeated int64 Backward;\n" + "    repeated int64 Forward; }\n" + "  repeated group Name {\n" + "    repeated group Language {\n" + "      required binary Code;\n" + "      required binary Country; }\n" + "    optional binary Url; }}";    MessageType parsed = parseMessageType(example);    MessageType manuallyMade = new MessageType("Document", new PrimitiveType(REQUIRED, INT64, "DocId"), new GroupType(OPTIONAL, "Links", new PrimitiveType(REPEATED, INT64, "Backward"), new PrimitiveType(REPEATED, INT64, "Forward")), new GroupType(REPEATED, "Name", new GroupType(REPEATED, "Language", new PrimitiveType(REQUIRED, BINARY, "Code"), new PrimitiveType(REQUIRED, BINARY, "Country")), new PrimitiveType(OPTIONAL, BINARY, "Url")));    assertEquals(manuallyMade, parsed);    MessageType parsedThenReparsed = parseMessageType(parsed.toString());    assertEquals(manuallyMade, parsedThenReparsed);    parsed = parseMessageType("message m { required group a {required binary b;} required group c { required int64 d; }}");    manuallyMade = new MessageType("m", new GroupType(REQUIRED, "a", new PrimitiveType(REQUIRED, BINARY, "b")), new GroupType(REQUIRED, "c", new PrimitiveType(REQUIRED, INT64, "d")));    assertEquals(manuallyMade, parsed);    parsedThenReparsed = parseMessageType(parsed.toString());    assertEquals(manuallyMade, parsedThenReparsed);}
df71b22e8338a5eb3bd4be0c579cb97a01d5f79ac0982b717d873ea22754f81a
testEachPrimitiveType
public void testEachPrimitiveType()
{    MessageTypeBuilder builder = buildMessage();    StringBuilder schema = new StringBuilder();    schema.append("message EachType {\n");    for (PrimitiveTypeName type : PrimitiveTypeName.values()) {                if (type == FIXED_LEN_BYTE_ARRAY) {            schema.append("  required fixed_len_byte_array(3) fixed_;");            builder.required(FIXED_LEN_BYTE_ARRAY).length(3).named("fixed_");        } else {            schema.append("  required ").append(type).append(" ").append(type).append("_;\n");            builder.required(type).named(type.toString() + "_");        }    }    schema.append("}\n");    MessageType expected = builder.named("EachType");    MessageType parsed = parseMessageType(schema.toString());    assertEquals(expected, parsed);    MessageType reparsed = parseMessageType(parsed.toString());    assertEquals(expected, reparsed);}
aadd39fcd9c330942bd15afbff1c182a10bf69df75bb6b1dba3f00dcbb43bf99
testSTRINGAnnotation
public void testSTRINGAnnotation()
{    String message = "message StringMessage {\n" + "  required binary string (STRING);\n" + "}\n";    MessageType parsed = parseMessageType(message);    MessageType expected = buildMessage().required(BINARY).as(stringType()).named("string").named("StringMessage");    assertEquals(expected, parsed);    MessageType reparsed = parseMessageType(parsed.toString());    assertEquals(expected, reparsed);}
0c2f4dde4fd947dd8a68218b912553d284589f1d6c99e8bdee38127e9df42356
testUTF8Annotation
public void testUTF8Annotation()
{    String message = "message StringMessage {\n" + "  required binary string (UTF8);\n" + "}\n";    MessageType parsed = parseMessageType(message);    MessageType expected = buildMessage().required(BINARY).as(UTF8).named("string").named("StringMessage");    assertEquals(expected, parsed);    MessageType reparsed = parseMessageType(parsed.toString());    assertEquals(expected, reparsed);}
56ce2fc09e969ce00da3b4844f5944781c929505486e98ab77ed837d7bb7de26
testIDs
public void testIDs()
{    String message = "message Message {\n" + "  required binary string (UTF8) = 6;\n" + "  required int32 i=1;\n" + "  required binary s2= 3;\n" + "  required binary s3 =4;\n" + "}\n";    MessageType parsed = parseMessageType(message);    MessageType expected = buildMessage().required(BINARY).as(OriginalType.UTF8).id(6).named("string").required(INT32).id(1).named("i").required(BINARY).id(3).named("s2").required(BINARY).id(4).named("s3").named("Message");    assertEquals(expected, parsed);    MessageType reparsed = parseMessageType(parsed.toString());    assertEquals(expected, reparsed);}
32fef2b5dc832ae6ce510bdef85255759ec5259d04ecb00eff915a1967b941df
testMAPAnnotations
public void testMAPAnnotations()
{        String message = "message Message {\n" + "  optional group aMap (MAP) {\n" + "    repeated group map (MAP_KEY_VALUE) {\n" + "      required binary key (UTF8);\n" + "      required int32 value;\n" + "    }\n" + "  }\n" + "}\n";    MessageType parsed = parseMessageType(message);    MessageType expected = buildMessage().optionalGroup().as(MAP).repeatedGroup().as(MAP_KEY_VALUE).required(BINARY).as(UTF8).named("key").required(INT32).named("value").named("map").named("aMap").named("Message");    assertEquals(expected, parsed);    MessageType reparsed = parseMessageType(parsed.toString());    assertEquals(expected, reparsed);}
2c5b13b880f1a419afb1ce77ba13868058567dc6adec2d1aa3167db1c98280fd
testLISTAnnotation
public void testLISTAnnotation()
{        String message = "message Message {\n" + "  required group aList (LIST) {\n" + "    repeated binary string (UTF8);\n" + "  }\n" + "}\n";    MessageType parsed = parseMessageType(message);    MessageType expected = buildMessage().requiredGroup().as(LIST).repeated(BINARY).as(UTF8).named("string").named("aList").named("Message");    assertEquals(expected, parsed);    MessageType reparsed = parseMessageType(parsed.toString());    assertEquals(expected, reparsed);}
172d3dde9edc8c9dadef2a1ed46be9a19fa036f9bfc0507eea19de5d4ce38867
testDecimalFixedAnnotation
public void testDecimalFixedAnnotation()
{    String message = "message DecimalMessage {\n" + "  required FIXED_LEN_BYTE_ARRAY(4) aDecimal (DECIMAL(9,2));\n" + "}\n";    MessageType parsed = parseMessageType(message);    MessageType expected = buildMessage().required(FIXED_LEN_BYTE_ARRAY).length(4).as(DECIMAL).precision(9).scale(2).named("aDecimal").named("DecimalMessage");    assertEquals(expected, parsed);    MessageType reparsed = parseMessageType(parsed.toString());    assertEquals(expected, reparsed);}
0ff395198e89c3ed6b361e74ba056a8804e875ec50f9ecae69ff0f22919a9651
testDecimalBinaryAnnotation
public void testDecimalBinaryAnnotation()
{    String message = "message DecimalMessage {\n" + "  required binary aDecimal (DECIMAL(9,2));\n" + "}\n";    MessageType parsed = parseMessageType(message);    MessageType expected = buildMessage().required(BINARY).as(DECIMAL).precision(9).scale(2).named("aDecimal").named("DecimalMessage");    assertEquals(expected, parsed);    MessageType reparsed = parseMessageType(parsed.toString());    assertEquals(expected, reparsed);}
555a8e4b525222f2e481247360896b8efc1ca6ba2612d7f75a95985af8a36696
testTimeAnnotations
public void testTimeAnnotations()
{    String message = "message TimeMessage {" + "  required int32 date (DATE);" + "  required int32 time (TIME_MILLIS);" + "  required int64 timestamp (TIMESTAMP_MILLIS);" + "  required FIXED_LEN_BYTE_ARRAY(12) interval (INTERVAL);" + "  required int32 newTime (TIME(MILLIS,true));" + "  required int64 nanoTime (TIME(NANOS,true));" + "  required int64 newTimestamp (TIMESTAMP(MILLIS,false));" + "  required int64 nanoTimestamp (TIMESTAMP(NANOS,false));" + "}\n";    MessageType parsed = MessageTypeParser.parseMessageType(message);    MessageType expected = Types.buildMessage().required(INT32).as(DATE).named("date").required(INT32).as(TIME_MILLIS).named("time").required(INT64).as(TIMESTAMP_MILLIS).named("timestamp").required(FIXED_LEN_BYTE_ARRAY).length(12).as(INTERVAL).named("interval").required(INT32).as(timeType(true, MILLIS)).named("newTime").required(INT64).as(timeType(true, NANOS)).named("nanoTime").required(INT64).as(timestampType(false, MILLIS)).named("newTimestamp").required(INT64).as(timestampType(false, NANOS)).named("nanoTimestamp").named("TimeMessage");    assertEquals(expected, parsed);    MessageType reparsed = MessageTypeParser.parseMessageType(parsed.toString());    assertEquals(expected, reparsed);}
fd0dc9e08690cad0efd85fb9c2ba43efb320366220ad34a18faafbe621846693
testIntAnnotations
public void testIntAnnotations()
{    String message = "message IntMessage {" + "  required int32 i8 (INT_8);" + "  required int32 i16 (INT_16);" + "  required int32 i32 (INT_32);" + "  required int64 i64 (INT_64);" + "  required int32 u8 (UINT_8);" + "  required int32 u16 (UINT_16);" + "  required int32 u32 (UINT_32);" + "  required int64 u64 (UINT_64);" + "}\n";    MessageType parsed = MessageTypeParser.parseMessageType(message);    MessageType expected = Types.buildMessage().required(INT32).as(INT_8).named("i8").required(INT32).as(INT_16).named("i16").required(INT32).as(INT_32).named("i32").required(INT64).as(INT_64).named("i64").required(INT32).as(UINT_8).named("u8").required(INT32).as(UINT_16).named("u16").required(INT32).as(UINT_32).named("u32").required(INT64).as(UINT_64).named("u64").named("IntMessage");    assertEquals(expected, parsed);    MessageType reparsed = MessageTypeParser.parseMessageType(parsed.toString());    assertEquals(expected, reparsed);}
c39a2080af1a6711e82af65ef017db83d3f1b51b3571e9058a04f0c4a78b07d7
testIntegerAnnotations
public void testIntegerAnnotations()
{    String message = "message IntMessage {" + "  required int32 i8 (INTEGER(8,true));" + "  required int32 i16 (INTEGER(16,true));" + "  required int32 i32 (INTEGER(32,true));" + "  required int64 i64 (INTEGER(64,true));" + "  required int32 u8 (INTEGER(8,false));" + "  required int32 u16 (INTEGER(16,false));" + "  required int32 u32 (INTEGER(32,false));" + "  required int64 u64 (INTEGER(64,false));" + "}\n";    MessageType parsed = MessageTypeParser.parseMessageType(message);    MessageType expected = Types.buildMessage().required(INT32).as(intType(8, true)).named("i8").required(INT32).as(intType(16, true)).named("i16").required(INT32).as(intType(32, true)).named("i32").required(INT64).as(intType(64, true)).named("i64").required(INT32).as(intType(8, false)).named("u8").required(INT32).as(intType(16, false)).named("u16").required(INT32).as(intType(32, false)).named("u32").required(INT64).as(intType(64, false)).named("u64").named("IntMessage");    assertEquals(expected, parsed);    MessageType reparsed = MessageTypeParser.parseMessageType(parsed.toString());    assertEquals(expected, reparsed);}
3e369e4aadfc3eddbf351e0aa9715b5d43e21dfa4d3b1c0a8220371aedd767a9
testEmbeddedAnnotations
public void testEmbeddedAnnotations()
{    String message = "message EmbeddedMessage {" + "  required binary json (JSON);" + "  required binary bson (BSON);" + "}\n";    MessageType parsed = MessageTypeParser.parseMessageType(message);    MessageType expected = Types.buildMessage().required(BINARY).as(JSON).named("json").required(BINARY).as(BSON).named("bson").named("EmbeddedMessage");    assertEquals(expected, parsed);    MessageType reparsed = MessageTypeParser.parseMessageType(parsed.toString());    assertEquals(expected, reparsed);}
ced3637227837bc8935023b279f6d11e541ba2dd6bbaff26ba3afa81b2fd1240
test
public void test() throws Exception
{    MessageType schema = MessageTypeParser.parseMessageType(Paper.schema.toString());    assertEquals(Paper.schema, schema);    assertEquals(schema.toString(), Paper.schema.toString());}
b4b39747a238d7f91f5bb6a1e49b1d4db047387f54c0a9eedc66b0323bedc2b0
testNestedTypes
public void testNestedTypes()
{    MessageType schema = MessageTypeParser.parseMessageType(Paper.schema.toString());    Type type = schema.getType("Links", "Backward");    assertEquals(PrimitiveTypeName.INT64, type.asPrimitiveType().getPrimitiveTypeName());    assertEquals(0, schema.getMaxRepetitionLevel("DocId"));    assertEquals(1, schema.getMaxRepetitionLevel("Name"));    assertEquals(2, schema.getMaxRepetitionLevel("Name", "Language"));    assertEquals(0, schema.getMaxDefinitionLevel("DocId"));    assertEquals(1, schema.getMaxDefinitionLevel("Links"));    assertEquals(2, schema.getMaxDefinitionLevel("Links", "Backward"));}
3e36f21646cf9adaa24dbab8b708fbe0d216faa5843101bfa046faf46a2579af
testMergeSchema
public void testMergeSchema()
{    MessageType t1 = new MessageType("root1", new PrimitiveType(REPEATED, BINARY, "a"), new PrimitiveType(OPTIONAL, BINARY, "b"));    MessageType t2 = new MessageType("root2", new PrimitiveType(REQUIRED, BINARY, "c"));    assertEquals(t1.union(t2), new MessageType("root1", new PrimitiveType(REPEATED, BINARY, "a"), new PrimitiveType(OPTIONAL, BINARY, "b"), new PrimitiveType(REQUIRED, BINARY, "c")));    assertEquals(t2.union(t1), new MessageType("root2", new PrimitiveType(REQUIRED, BINARY, "c"), new PrimitiveType(REPEATED, BINARY, "a"), new PrimitiveType(OPTIONAL, BINARY, "b")));    MessageType t3 = new MessageType("root1", new PrimitiveType(OPTIONAL, BINARY, "a"));    MessageType t4 = new MessageType("root2", new PrimitiveType(REQUIRED, BINARY, "a"));    assertEquals(t3.union(t4), new MessageType("root1", new PrimitiveType(OPTIONAL, BINARY, "a")));    assertEquals(t4.union(t3), new MessageType("root2", new PrimitiveType(OPTIONAL, BINARY, "a")));    MessageType t5 = new MessageType("root1", new GroupType(REQUIRED, "g1", new PrimitiveType(OPTIONAL, BINARY, "a")), new GroupType(REQUIRED, "g2", new PrimitiveType(OPTIONAL, BINARY, "b")));    MessageType t6 = new MessageType("root1", new GroupType(REQUIRED, "g1", new PrimitiveType(OPTIONAL, BINARY, "a")), new GroupType(REQUIRED, "g2", new GroupType(REQUIRED, "g3", new PrimitiveType(OPTIONAL, BINARY, "c")), new PrimitiveType(OPTIONAL, BINARY, "b")));    assertEquals(t5.union(t6), new MessageType("root1", new GroupType(REQUIRED, "g1", new PrimitiveType(OPTIONAL, BINARY, "a")), new GroupType(REQUIRED, "g2", new PrimitiveType(OPTIONAL, BINARY, "b"), new GroupType(REQUIRED, "g3", new PrimitiveType(OPTIONAL, BINARY, "c")))));    MessageType t7 = new MessageType("root1", new PrimitiveType(OPTIONAL, BINARY, "a"));    MessageType t8 = new MessageType("root2", new PrimitiveType(OPTIONAL, INT32, "a"));    try {        t7.union(t8);        fail("moving from BINARY to INT32");    } catch (IncompatibleSchemaModificationException e) {        assertEquals("can not merge type optional int32 a into optional binary a", e.getMessage());    }    MessageType t9 = Types.buildMessage().addField(Types.optional(BINARY).as(OriginalType.UTF8).named("a")).named("root1");    MessageType t10 = Types.buildMessage().addField(Types.optional(BINARY).named("a")).named("root1");    assertEquals(t9.union(t9), t9);    try {        t9.union(t10);        fail("moving from BINARY (UTF8) to BINARY");    } catch (IncompatibleSchemaModificationException e) {        assertEquals("cannot merge logical type null into STRING", e.getMessage());    }    MessageType t11 = Types.buildMessage().addField(Types.optional(FIXED_LEN_BYTE_ARRAY).length(10).named("a")).named("root1");    MessageType t12 = Types.buildMessage().addField(Types.optional(FIXED_LEN_BYTE_ARRAY).length(20).named("a")).named("root2");    try {        t11.union(t12);        fail("moving from FIXED_LEN_BYTE_ARRAY(10) to FIXED_LEN_BYTE_ARRAY(20)");    } catch (IncompatibleSchemaModificationException e) {        assertEquals("can not merge type optional fixed_len_byte_array(20) a into optional fixed_len_byte_array(10) a", e.getMessage());    }}
becdf16dada8aa99c61e4fb43f11bc0cf23a59b2826a8db333588ba3b78e9ed0
testMergeSchemaWithOriginalType
public void testMergeSchemaWithOriginalType() throws Exception
{    MessageType t5 = new MessageType("root1", new GroupType(REQUIRED, "g1", LIST, new PrimitiveType(OPTIONAL, BINARY, "a")), new GroupType(REQUIRED, "g2", new PrimitiveType(OPTIONAL, BINARY, "b")));    MessageType t6 = new MessageType("root1", new GroupType(REQUIRED, "g1", LIST, new PrimitiveType(OPTIONAL, BINARY, "a")), new GroupType(REQUIRED, "g2", LIST, new GroupType(REQUIRED, "g3", new PrimitiveType(OPTIONAL, BINARY, "c")), new PrimitiveType(OPTIONAL, BINARY, "b")));    assertEquals(new MessageType("root1", new GroupType(REQUIRED, "g1", LIST, new PrimitiveType(OPTIONAL, BINARY, "a")), new GroupType(REQUIRED, "g2", LIST, new PrimitiveType(OPTIONAL, BINARY, "b"), new GroupType(REQUIRED, "g3", new PrimitiveType(OPTIONAL, BINARY, "c")))), t5.union(t6));}
c76dda489b53f0806a4c7004e7937b03029edf1e5ba1f29fc74d1ce463d08117
testMergeSchemaWithColumnOrder
public void testMergeSchemaWithColumnOrder()
{    MessageType m1 = Types.buildMessage().addFields(Types.requiredList().element(Types.optional(BINARY).columnOrder(ColumnOrder.undefined()).named("a")).named("g"), Types.optional(INT96).named("b")).named("root");    MessageType m2 = Types.buildMessage().addFields(Types.requiredList().element(Types.optional(BINARY).columnOrder(ColumnOrder.undefined()).named("a")).named("g"), Types.optional(BINARY).named("c")).named("root");    MessageType m3 = Types.buildMessage().addFields(Types.requiredList().element(Types.optional(BINARY).named("a")).named("g")).named("root");    assertEquals(Types.buildMessage().addFields(Types.requiredList().element(Types.optional(BINARY).named("a")).named("g"), Types.optional(INT96).named("b"), Types.optional(BINARY).named("c")).named("root"), m1.union(m2));    try {        m1.union(m3);        fail("An IncompatibleSchemaModificationException should have been thrown");    } catch (Exception e) {        assertTrue("The thrown exception should have been IncompatibleSchemaModificationException but was " + e.getClass(), e instanceof IncompatibleSchemaModificationException);        assertEquals("can not merge type optional binary a with column order TYPE_DEFINED_ORDER into optional binary a with column order UNDEFINED", e.getMessage());    }}
5590c2e6e1c99c2874f6475a50a4d48dc5845a1f749c5a37fc19f1e8bb5e523d
testIDs
public void testIDs() throws Exception
{    MessageType schema = new MessageType("test", new PrimitiveType(REQUIRED, BINARY, "foo").withId(4), new GroupType(REQUIRED, "bar", new PrimitiveType(REQUIRED, BINARY, "baz").withId(3)).withId(8));    MessageType schema2 = MessageTypeParser.parseMessageType(schema.toString());    assertEquals(schema, schema2);    assertEquals(schema.toString(), schema2.toString());}
a0f7bd4c27e5b81e36a12f28ca3eb3ba1d9e581acd479d3d46db5d7f0bfaf7ca
testBooleanComparator
public void testBooleanComparator()
{    Boolean[] valuesInAscendingOrder = { null, false, true };    for (int i = 0; i < valuesInAscendingOrder.length; ++i) {        for (int j = 0; j < valuesInAscendingOrder.length; ++j) {            Boolean vi = valuesInAscendingOrder[i];            Boolean vj = valuesInAscendingOrder[j];            int exp = i - j;            assertSignumEquals(vi, vj, exp, BOOLEAN_COMPARATOR.compare(vi, vj));            if (vi != null && vj != null) {                assertSignumEquals(vi, vj, exp, BOOLEAN_COMPARATOR.compare(vi.booleanValue(), vj.booleanValue()));            }        }    }    checkThrowingUnsupportedException(BOOLEAN_COMPARATOR, Boolean.TYPE);}
30d1b98a4cccf49bf25a4d3d6c326f00df3e49941af996a22af1a94c05cba983
testSignedInt32Comparator
public void testSignedInt32Comparator()
{    testInt32Comparator(SIGNED_INT32_COMPARATOR, null, Integer.MIN_VALUE, -12345, -1, 0, 1, 12345, Integer.MAX_VALUE);}
2741180814c4067358488a3b7e189fe81250fe031ec70fcfaf95561a6221a582
testUnsignedInt32Comparator
public void testUnsignedInt32Comparator()
{    testInt32Comparator(UNSIGNED_INT32_COMPARATOR, null,     0,     1,     12345,     Integer.MAX_VALUE,     Integer.MIN_VALUE,     -12345,     -1);}
5d99f294ad9888deab2c8caf9789d3c40f56fc62846ddb03d5a535e8c5cc859e
testInt32Comparator
private void testInt32Comparator(PrimitiveComparator<Integer> comparator, Integer... valuesInAscendingOrder)
{    for (int i = 0; i < valuesInAscendingOrder.length; ++i) {        for (int j = 0; j < valuesInAscendingOrder.length; ++j) {            Integer vi = valuesInAscendingOrder[i];            Integer vj = valuesInAscendingOrder[j];            int exp = i - j;            assertSignumEquals(vi, vj, exp, comparator.compare(vi, vj));            if (vi != null && vj != null) {                assertSignumEquals(vi, vj, exp, comparator.compare(vi.intValue(), vj.intValue()));            }        }    }    checkThrowingUnsupportedException(comparator, Integer.TYPE);}
140ef59860dcb7ddbb07c94d1691779d8a03fe4c82c2a8e794d3e1fa69385e2e
testSignedInt64Comparator
public void testSignedInt64Comparator()
{    testInt64Comparator(SIGNED_INT64_COMPARATOR, null, Long.MIN_VALUE, -12345678901L, -1L, 0L, 1L, 12345678901L, Long.MAX_VALUE);}
3e0585bd82270ed5ac1946c3a8002c2122c4e73e4dff869df7918a16b9cec238
testUnsignedInt64Comparator
public void testUnsignedInt64Comparator()
{    testInt64Comparator(UNSIGNED_INT64_COMPARATOR, null,     0L,     1L,     12345678901L,     Long.MAX_VALUE,     Long.MIN_VALUE,     -12345678901L,     -1L);}
ad812ee9d10889bc4672697d9914d4cd83784acc004437690e62121f7b00ec4a
testInt64Comparator
private void testInt64Comparator(PrimitiveComparator<Long> comparator, Long... valuesInAscendingOrder)
{    for (int i = 0; i < valuesInAscendingOrder.length; ++i) {        for (int j = 0; j < valuesInAscendingOrder.length; ++j) {            Long vi = valuesInAscendingOrder[i];            Long vj = valuesInAscendingOrder[j];            int exp = i - j;            assertSignumEquals(vi, vj, exp, comparator.compare(vi, vj));            if (vi != null && vj != null) {                assertSignumEquals(vi, vj, exp, comparator.compare(vi.longValue(), vj.longValue()));            }        }    }    checkThrowingUnsupportedException(comparator, Long.TYPE);}
2dd07d7d3bbdd2e98b4a7a279ed6f0e69b2a2ad4a1666bdf773b358269d79727
testFloatComparator
public void testFloatComparator()
{    Float[] valuesInAscendingOrder = { null, Float.NEGATIVE_INFINITY, -Float.MAX_VALUE, -1234.5678F, -Float.MIN_VALUE, 0.0F, Float.MIN_VALUE, 1234.5678F, Float.MAX_VALUE, Float.POSITIVE_INFINITY };    for (int i = 0; i < valuesInAscendingOrder.length; ++i) {        for (int j = 0; j < valuesInAscendingOrder.length; ++j) {            Float vi = valuesInAscendingOrder[i];            Float vj = valuesInAscendingOrder[j];            int exp = i - j;            assertSignumEquals(vi, vj, exp, FLOAT_COMPARATOR.compare(vi, vj));            if (vi != null && vj != null) {                assertSignumEquals(vi, vj, exp, FLOAT_COMPARATOR.compare(vi.floatValue(), vj.floatValue()));            }        }    }    checkThrowingUnsupportedException(FLOAT_COMPARATOR, Float.TYPE);}
ed21c90937afdb6c6868fad6aacb71324b666675452652845bc5c3a5d43dc05b
testDoubleComparator
public void testDoubleComparator()
{    Double[] valuesInAscendingOrder = { null, Double.NEGATIVE_INFINITY, -Double.MAX_VALUE, -123456.7890123456789, -Double.MIN_VALUE, 0.0, Double.MIN_VALUE, 123456.7890123456789, Double.MAX_VALUE, Double.POSITIVE_INFINITY };    for (int i = 0; i < valuesInAscendingOrder.length; ++i) {        for (int j = 0; j < valuesInAscendingOrder.length; ++j) {            Double vi = valuesInAscendingOrder[i];            Double vj = valuesInAscendingOrder[j];            int exp = i - j;            assertSignumEquals(vi, vj, exp, DOUBLE_COMPARATOR.compare(vi, vj));            if (vi != null && vj != null) {                assertSignumEquals(vi, vj, exp, DOUBLE_COMPARATOR.compare(vi.doubleValue(), vj.doubleValue()));            }        }    }    checkThrowingUnsupportedException(DOUBLE_COMPARATOR, Double.TYPE);}
0b47f97755f640f4ba2312b434b8e3d4f646474e58c3c0808a374721a8582379
testLexicographicalBinaryComparator
public void testLexicographicalBinaryComparator()
{    testObjectComparator(UNSIGNED_LEXICOGRAPHICAL_BINARY_COMPARATOR, null,     Binary.fromConstantByteArray(new byte[0]),     Binary.fromConstantByteArray(new byte[] { 127, 127, 0, 127 }, 2, 1),     Binary.fromCharSequence("aaa"),     Binary.fromString("aaaa"),     Binary.fromReusedByteArray("aaab".getBytes()),     Binary.fromReusedByteArray("azzza".getBytes(), 1, 3),     Binary.fromReusedByteBuffer(ByteBuffer.wrap("zzzzzz".getBytes())),     Binary.fromReusedByteBuffer(ByteBuffer.wrap("aazzzzzzaa".getBytes(), 2, 7)),     Binary.fromConstantByteBuffer(ByteBuffer.wrap(new byte[] { -128, -128, -128 })),     Binary.fromConstantByteBuffer(ByteBuffer.wrap(new byte[] { -128, -128, -1 }, 1, 2)));}
a38a58c76d23cbd15b3cc0b662463c17fe6b89b6cd1564785585d94f071a2d16
testBinaryAsSignedIntegerComparator
public void testBinaryAsSignedIntegerComparator()
{    testObjectComparator(BINARY_AS_SIGNED_INTEGER_COMPARATOR, null, Binary.fromConstantByteArray(new BigInteger("-9999999999999999999999999999999999999999").toByteArray()), Binary.fromReusedByteArray(new BigInteger("-9999999999999999999999999999999999999998").toByteArray()), Binary.fromConstantByteArray(BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.ONE).toByteArray()), Binary.fromConstantByteArray(BigInteger.valueOf(Long.MIN_VALUE).toByteArray()), Binary.fromConstantByteArray(BigInteger.valueOf(Long.MIN_VALUE).add(BigInteger.ONE).toByteArray()), Binary.fromReusedByteArray(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, -2 }, 1, 3), Binary.fromReusedByteArray(new BigInteger("-1").toByteArray()), Binary.fromConstantByteBuffer(ByteBuffer.wrap(new BigInteger("0").toByteArray())), Binary.fromReusedByteBuffer(ByteBuffer.wrap(new byte[] { 0, 0, 0, 1 })), Binary.fromConstantByteBuffer(ByteBuffer.wrap(new byte[] { 0, 0, 0, 2 }), 2, 2), Binary.fromConstantByteBuffer(ByteBuffer.wrap(BigInteger.valueOf(Long.MAX_VALUE).subtract(BigInteger.ONE).toByteArray())), Binary.fromConstantByteBuffer(ByteBuffer.wrap(BigInteger.valueOf(Long.MAX_VALUE).toByteArray())), Binary.fromConstantByteBuffer(ByteBuffer.wrap(BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE).toByteArray())), Binary.fromConstantByteBuffer(ByteBuffer.wrap(new BigInteger("999999999999999999999999999999999999999").toByteArray())), Binary.fromReusedByteBuffer(ByteBuffer.wrap(new BigInteger("9999999999999999999999999999999999999998").toByteArray())), Binary.fromConstantByteBuffer(ByteBuffer.wrap(new BigInteger("9999999999999999999999999999999999999999").toByteArray())));}
9f9eb0997b05f36be808cbca6be5dacf9eaffa4c6001283199a4c27749c42cef
testBinaryAsSignedIntegerComparatorWithEquals
public void testBinaryAsSignedIntegerComparatorWithEquals()
{    List<Binary> valuesToCompare = new ArrayList<>();    valuesToCompare.add(Binary.fromConstantByteBuffer(ByteBuffer.wrap(new byte[] { 0, 0, -108 })));    valuesToCompare.add(Binary.fromConstantByteBuffer(ByteBuffer.wrap(new byte[] { 0, 0, 0, 0, 0, -108 })));    valuesToCompare.add(Binary.fromConstantByteBuffer(ByteBuffer.wrap(new byte[] { 0, 0, 0, -108 })));    valuesToCompare.add(Binary.fromConstantByteBuffer(ByteBuffer.wrap(new byte[] { 0, 0, 0, 0, -108 })));    valuesToCompare.add(Binary.fromConstantByteBuffer(ByteBuffer.wrap(new byte[] { 0, -108 })));    for (Binary v1 : valuesToCompare) {        for (Binary v2 : valuesToCompare) {            assertEquals(String.format("Wrong result of comparison %s and %s", v1, v2), 0, BINARY_AS_SIGNED_INTEGER_COMPARATOR.compare(v1, v2));        }    }}
e12f7d65821e62be16ac2b4eae26661dc093f421dfb3823d204b43a6d24bab3e
testObjectComparator
private void testObjectComparator(PrimitiveComparator<T> comparator, T... valuesInAscendingOrder)
{    for (int i = 0; i < valuesInAscendingOrder.length; ++i) {        for (int j = 0; j < valuesInAscendingOrder.length; ++j) {            T vi = valuesInAscendingOrder[i];            T vj = valuesInAscendingOrder[j];            int exp = i - j;            assertSignumEquals(vi, vj, exp, comparator.compare(vi, vj));        }    }    checkThrowingUnsupportedException(comparator, null);}
a1c8c53fd88ea2e7a4b383ff90e8ac64e36ee6d97028172322645a02d8fba691
assertSignumEquals
private void assertSignumEquals(T v1, T v2, int expected, int actual)
{    String sign = expected < 0 ? " < " : expected > 0 ? " > " : " = ";    assertEquals("expected: " + v1 + sign + v2, signum(expected), signum(actual));}
9a3aef19dc14a9d56878808cb59f576c8a115f77b14e3b20159dd64479df1189
signum
private int signum(int i)
{    return i < 0 ? -1 : i > 0 ? 1 : 0;}
82bda765e6aed7c73d81e14bb5e1e03373c23a66d79f8c6ed693a2eda2991e20
checkThrowingUnsupportedException
private void checkThrowingUnsupportedException(PrimitiveComparator<?> comparator, Class<?> exclude)
{    if (Integer.TYPE != exclude) {        try {            comparator.compare(0, 0);            fail("An UnsupportedOperationException should have been thrown");        } catch (UnsupportedOperationException e) {        }    }    if (Long.TYPE != exclude) {        try {            comparator.compare(0L, 0L);            fail("An UnsupportedOperationException should have been thrown");        } catch (UnsupportedOperationException e) {        }    }    if (Float.TYPE != exclude) {        try {            comparator.compare(0.0F, 0.0F);            fail("An UnsupportedOperationException should have been thrown");        } catch (UnsupportedOperationException e) {        }    }    if (Double.TYPE != exclude) {        try {            comparator.compare(0.0, 0.0);            fail("An UnsupportedOperationException should have been thrown");        } catch (UnsupportedOperationException e) {        }    }    if (Boolean.TYPE != exclude) {        try {            comparator.compare(false, false);            fail("An UnsupportedOperationException should have been thrown");        } catch (UnsupportedOperationException e) {        }    }}
63bc9188ebfb5f82ca8573cf426df65c7ddd8f029173a737f08a8cb40662119f
testDefaultStringifier
public void testDefaultStringifier()
{    PrimitiveStringifier stringifier = DEFAULT_STRINGIFIER;    assertEquals("true", stringifier.stringify(true));    assertEquals("false", stringifier.stringify(false));    assertEquals("0.0", stringifier.stringify(0.0));    assertEquals("123456.7891234567", stringifier.stringify(123456.7891234567));    assertEquals("-98765.43219876543", stringifier.stringify(-98765.43219876543));    assertEquals("0.0", stringifier.stringify(0.0f));    assertEquals("987.6543", stringifier.stringify(987.6543f));    assertEquals("-123.4567", stringifier.stringify(-123.4567f));    assertEquals("0", stringifier.stringify(0));    assertEquals("1234567890", stringifier.stringify(1234567890));    assertEquals("-987654321", stringifier.stringify(-987654321));    assertEquals("0", stringifier.stringify(0l));    assertEquals("1234567890123456789", stringifier.stringify(1234567890123456789l));    assertEquals("-987654321987654321", stringifier.stringify(-987654321987654321l));    assertEquals("null", stringifier.stringify(null));    assertEquals("0x", stringifier.stringify(Binary.EMPTY));    assertEquals("0x0123456789ABCDEF", stringifier.stringify(Binary.fromConstantByteArray(new byte[] { 0x01, 0x23, 0x45, 0x67, (byte) 0x89, (byte) 0xAB, (byte) 0xCD, (byte) 0xEF })));}
4cc7efcfbb7381ff61e258cdd97205d8e3ec5052782ef676b4b2cd6ab9fa4325
testUnsignedStringifier
public void testUnsignedStringifier()
{    PrimitiveStringifier stringifier = UNSIGNED_STRINGIFIER;    assertEquals("0", stringifier.stringify(0));    assertEquals("2147483647", stringifier.stringify(2147483647));    assertEquals("4294967295", stringifier.stringify(0xFFFFFFFF));    assertEquals("0", stringifier.stringify(0l));    assertEquals("9223372036854775807", stringifier.stringify(9223372036854775807l));    assertEquals("18446744073709551615", stringifier.stringify(0xFFFFFFFFFFFFFFFFl));    checkThrowingUnsupportedException(stringifier, Integer.TYPE, Long.TYPE);}
17c80bea31d2869427fbc6cc2651b335d48fec5f728ea251e7d2d51c16e0a141
testUTF8Stringifier
public void testUTF8Stringifier()
{    PrimitiveStringifier stringifier = UTF8_STRINGIFIER;    assertEquals("null", stringifier.stringify(null));    assertEquals("", stringifier.stringify(Binary.EMPTY));    assertEquals("This is a UTF-8 test", stringifier.stringify(Binary.fromString("This is a UTF-8 test")));    assertEquals("UTF-8", stringifier.stringify(Binary.fromConstantByteArray("UTF-8".getBytes(UTF_8))));    checkThrowingUnsupportedException(stringifier, Binary.class);}
46eed9ffca544b7b1486f677fe72530bc22945b3dd56be45342fd30e2a11020b
testIntervalStringifier
public void testIntervalStringifier()
{    PrimitiveStringifier stringifier = INTERVAL_STRINGIFIER;    assertEquals("null", stringifier.stringify(null));    assertEquals("<INVALID>", stringifier.stringify(Binary.EMPTY));    assertEquals("<INVALID>", stringifier.stringify(Binary.fromConstantByteArray(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 })));    assertEquals("<INVALID>", stringifier.stringify(Binary.fromReusedByteArray(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 })));    ByteBuffer buffer = ByteBuffer.allocate(12);    assertEquals("interval(0 months, 0 days, 0 millis)", stringifier.stringify(Binary.fromConstantByteBuffer(buffer)));    buffer.putInt(0x03000000);    buffer.putInt(0x06000000);    buffer.putInt(0x09000000);    buffer.flip();    assertEquals("interval(3 months, 6 days, 9 millis)", stringifier.stringify(Binary.fromConstantByteBuffer(buffer)));    buffer.clear();    buffer.putInt(0xFFFFFFFF);    buffer.putInt(0xFEFFFFFF);    buffer.putInt(0xFDFFFFFF);    buffer.flip();    assertEquals("interval(4294967295 months, 4294967294 days, 4294967293 millis)", stringifier.stringify(Binary.fromReusedByteBuffer(buffer)));    checkThrowingUnsupportedException(stringifier, Binary.class);}
591ccb10267fc2fbe0343e6a7ecfd6856f6fb0df0422f20ebbadbb10b6e82da0
testDateStringifier
public void testDateStringifier()
{    PrimitiveStringifier stringifier = DATE_STRINGIFIER;    assertEquals("1970-01-01", stringifier.stringify(0));    Calendar cal = Calendar.getInstance(UTC);    cal.clear();    cal.set(2017, Calendar.DECEMBER, 14);    assertEquals("2017-12-14", stringifier.stringify((int) MILLISECONDS.toDays(cal.getTimeInMillis())));    cal.clear();    cal.set(1583, Calendar.AUGUST, 3);    assertEquals("1583-08-03", stringifier.stringify((int) MILLISECONDS.toDays(cal.getTimeInMillis())));    checkThrowingUnsupportedException(stringifier, Integer.TYPE);}
6d2e14ba743e154aee2ca19973fe6fd9ab0e163c55a54a0123667fbe6e19b5d0
testTimestampMillisStringifier
public void testTimestampMillisStringifier()
{    for (PrimitiveStringifier stringifier : asList(TIMESTAMP_MILLIS_STRINGIFIER, TIMESTAMP_MILLIS_UTC_STRINGIFIER)) {        String timezoneAmendment = (stringifier == TIMESTAMP_MILLIS_STRINGIFIER ? "" : "+0000");        assertEquals(withZoneString("1970-01-01T00:00:00.000", timezoneAmendment), stringifier.stringify(0l));        Calendar cal = Calendar.getInstance(UTC);        cal.clear();        cal.set(2017, Calendar.DECEMBER, 15, 10, 9, 54);        cal.set(Calendar.MILLISECOND, 120);        assertEquals(withZoneString("2017-12-15T10:09:54.120", timezoneAmendment), stringifier.stringify(cal.getTimeInMillis()));        cal.clear();        cal.set(1948, Calendar.NOVEMBER, 23, 20, 19, 1);        cal.set(Calendar.MILLISECOND, 9);        assertEquals(withZoneString("1948-11-23T20:19:01.009", timezoneAmendment), stringifier.stringify(cal.getTimeInMillis()));        checkThrowingUnsupportedException(stringifier, Long.TYPE);    }}
0d60e48b0d84ddaae514a3bcf3ce2ea634da4c73c5f66d7b8b5d0661225db8dc
testTimestampMicrosStringifier
public void testTimestampMicrosStringifier()
{    for (PrimitiveStringifier stringifier : asList(TIMESTAMP_MICROS_STRINGIFIER, TIMESTAMP_MICROS_UTC_STRINGIFIER)) {        String timezoneAmendment = (stringifier == TIMESTAMP_MICROS_STRINGIFIER ? "" : "+0000");        assertEquals(withZoneString("1970-01-01T00:00:00.000000", timezoneAmendment), stringifier.stringify(0l));        Calendar cal = Calendar.getInstance(UTC);        cal.clear();        cal.set(2053, Calendar.JULY, 10, 22, 13, 24);        cal.set(Calendar.MILLISECOND, 84);        long micros = cal.getTimeInMillis() * 1000 + 900;        assertEquals(withZoneString("2053-07-10T22:13:24.084900", timezoneAmendment), stringifier.stringify(micros));        cal.clear();        cal.set(1848, Calendar.MARCH, 15, 9, 23, 59);        cal.set(Calendar.MILLISECOND, 765);        micros = cal.getTimeInMillis() * 1000 - 1;        assertEquals(withZoneString("1848-03-15T09:23:59.764999", timezoneAmendment), stringifier.stringify(micros));        checkThrowingUnsupportedException(stringifier, Long.TYPE);    }}
f7f33d3fd202fb732eee7b4000e9b28a662294af30da691faa8bc56f5286faa6
testTimestampNanosStringifier
public void testTimestampNanosStringifier()
{    for (PrimitiveStringifier stringifier : asList(TIMESTAMP_NANOS_STRINGIFIER, TIMESTAMP_NANOS_UTC_STRINGIFIER)) {        String timezoneAmendment = (stringifier == TIMESTAMP_NANOS_STRINGIFIER ? "" : "+0000");        assertEquals(withZoneString("1970-01-01T00:00:00.000000000", timezoneAmendment), stringifier.stringify(0l));        Calendar cal = Calendar.getInstance(UTC);        cal.clear();        cal.set(2053, Calendar.JULY, 10, 22, 13, 24);        cal.set(Calendar.MILLISECOND, 84);        long nanos = cal.getTimeInMillis() * 1_000_000 + 536;        assertEquals(withZoneString("2053-07-10T22:13:24.084000536", timezoneAmendment), stringifier.stringify(nanos));        cal.clear();        cal.set(1848, Calendar.MARCH, 15, 9, 23, 59);        cal.set(Calendar.MILLISECOND, 765);        nanos = cal.getTimeInMillis() * 1_000_000 - 1;        assertEquals(withZoneString("1848-03-15T09:23:59.764999999", timezoneAmendment), stringifier.stringify(nanos));        checkThrowingUnsupportedException(stringifier, Long.TYPE);    }}
bd81e1d7887db98e788ca10b5f8a5f0f84f2517646db47ee04a1ba798f91cc00
testTimeStringifier
public void testTimeStringifier()
{    for (PrimitiveStringifier stringifier : asList(TIME_STRINGIFIER, TIME_UTC_STRINGIFIER)) {        String timezoneAmendment = (stringifier == TIME_STRINGIFIER ? "" : "+0000");        assertEquals(withZoneString("00:00:00.000", timezoneAmendment), stringifier.stringify(0));        assertEquals(withZoneString("00:00:00.000000", timezoneAmendment), stringifier.stringify(0l));        assertEquals(withZoneString("12:34:56.789", timezoneAmendment), stringifier.stringify((int) convert(MILLISECONDS, 12, 34, 56, 789)));        assertEquals(withZoneString("12:34:56.789012", timezoneAmendment), stringifier.stringify(convert(MICROSECONDS, 12, 34, 56, 789012)));        assertEquals(withZoneString("-12:34:56.789", timezoneAmendment), stringifier.stringify((int) convert(MILLISECONDS, -12, -34, -56, -789)));        assertEquals(withZoneString("-12:34:56.789012", timezoneAmendment), stringifier.stringify(convert(MICROSECONDS, -12, -34, -56, -789012)));        assertEquals(withZoneString("123:12:34.567", timezoneAmendment), stringifier.stringify((int) convert(MILLISECONDS, 123, 12, 34, 567)));        assertEquals(withZoneString("12345:12:34.056789", timezoneAmendment), stringifier.stringify(convert(MICROSECONDS, 12345, 12, 34, 56789)));        assertEquals(withZoneString("-123:12:34.567", timezoneAmendment), stringifier.stringify((int) convert(MILLISECONDS, -123, -12, -34, -567)));        assertEquals(withZoneString("-12345:12:34.056789", timezoneAmendment), stringifier.stringify(convert(MICROSECONDS, -12345, -12, -34, -56789)));        checkThrowingUnsupportedException(stringifier, Integer.TYPE, Long.TYPE);    }}
4e7ce86296fc1c488f476e35ebf32884a54f190c73019beb1b1e6382665592e9
testTimeNanoStringifier
public void testTimeNanoStringifier()
{    for (PrimitiveStringifier stringifier : asList(TIME_NANOS_STRINGIFIER, TIME_NANOS_UTC_STRINGIFIER)) {        String timezoneAmendment = (stringifier == TIME_NANOS_STRINGIFIER ? "" : "+0000");        assertEquals(withZoneString("00:00:00.000000000", timezoneAmendment), stringifier.stringify(0l));        assertEquals(withZoneString("12:34:56.789012987", timezoneAmendment), stringifier.stringify(convert(NANOSECONDS, 12, 34, 56, 789012987)));        assertEquals(withZoneString("-12:34:56.000789012", timezoneAmendment), stringifier.stringify(convert(NANOSECONDS, -12, -34, -56, -789012)));        assertEquals(withZoneString("12345:12:34.000056789", timezoneAmendment), stringifier.stringify(convert(NANOSECONDS, 12345, 12, 34, 56789)));        assertEquals(withZoneString("-12345:12:34.000056789", timezoneAmendment), stringifier.stringify(convert(NANOSECONDS, -12345, -12, -34, -56789)));        checkThrowingUnsupportedException(stringifier, Integer.TYPE, Long.TYPE);    }}
8ed38db019f618a90f717a9354bcf844cbbd1a99b49181ea837275ca0ed25ff3
withZoneString
private String withZoneString(String expected, String zoneString)
{    return expected + zoneString;}
9e298e5b05d63a356319747f11c36f824b6c752240994b18ab733fb15e56dceb
convert
private long convert(TimeUnit unit, long hours, long minutes, long seconds, long rest)
{    return unit.convert(hours, HOURS) + unit.convert(minutes, MINUTES) + unit.convert(seconds, SECONDS) + rest;}
6d86084e3873fa1f09bab20ed4ba87e11fcf77b55502bd410196303c84186846
testDecimalStringifier
public void testDecimalStringifier()
{    PrimitiveStringifier stringifier = PrimitiveStringifier.createDecimalStringifier(4);    assertEquals("0.0000", stringifier.stringify(0));    assertEquals("123456.7890", stringifier.stringify(1234567890));    assertEquals("-98765.4321", stringifier.stringify(-987654321));    assertEquals("0.0000", stringifier.stringify(0l));    assertEquals("123456789012345.6789", stringifier.stringify(1234567890123456789l));    assertEquals("-98765432109876.5432", stringifier.stringify(-987654321098765432l));    assertEquals("null", stringifier.stringify(null));    assertEquals("<INVALID>", stringifier.stringify(Binary.EMPTY));    assertEquals("0.0000", stringifier.stringify(Binary.fromReusedByteArray(new byte[] { 0 })));    assertEquals("9876543210987654321098765432109876543210987654.3210", stringifier.stringify(Binary.fromConstantByteArray(new BigInteger("98765432109876543210987654321098765432109876543210").toByteArray())));    assertEquals("-1234567890123456789012345678901234567890123456.7890", stringifier.stringify(Binary.fromConstantByteArray(new BigInteger("-12345678901234567890123456789012345678901234567890").toByteArray())));    checkThrowingUnsupportedException(stringifier, Integer.TYPE, Long.TYPE, Binary.class);}
8b531eaa26ac0a882b557369d4a71c740dfb94ea5c5dca2b50975c6f94be728c
checkThrowingUnsupportedException
private void checkThrowingUnsupportedException(PrimitiveStringifier stringifier, Class<?>... excludes)
{    Set<Class<?>> set = new HashSet<>(asList(excludes));    if (!set.contains(Integer.TYPE)) {        try {            stringifier.stringify(0);            fail("An UnsupportedOperationException should have been thrown");        } catch (UnsupportedOperationException e) {        }    }    if (!set.contains(Long.TYPE)) {        try {            stringifier.stringify(0l);            fail("An UnsupportedOperationException should have been thrown");        } catch (UnsupportedOperationException e) {        }    }    if (!set.contains(Float.TYPE)) {        try {            stringifier.stringify(0.0f);            fail("An UnsupportedOperationException should have been thrown");        } catch (UnsupportedOperationException e) {        }    }    if (!set.contains(Double.TYPE)) {        try {            stringifier.stringify(0.0);            fail("An UnsupportedOperationException should have been thrown");        } catch (UnsupportedOperationException e) {        }    }    if (!set.contains(Boolean.TYPE)) {        try {            stringifier.stringify(false);            fail("An UnsupportedOperationException should have been thrown");        } catch (UnsupportedOperationException e) {        }    }    if (!set.contains(Binary.class)) {        try {            stringifier.stringify(Binary.EMPTY);            fail("An UnsupportedOperationException should have been thrown");        } catch (UnsupportedOperationException e) {        }    }}
2a6b15b337b51547c3ed214389c53cb68e34c4eba4263e5dc830f1b852612ef3
testLeastRestrictiveRepetition
public void testLeastRestrictiveRepetition()
{    Type.Repetition REQUIRED = Type.Repetition.REQUIRED;    Type.Repetition OPTIONAL = Type.Repetition.OPTIONAL;    Type.Repetition REPEATED = Type.Repetition.REPEATED;    assertEquals(REPEATED, Type.Repetition.leastRestrictive(REQUIRED, OPTIONAL, REPEATED, REQUIRED, OPTIONAL, REPEATED));    assertEquals(OPTIONAL, Type.Repetition.leastRestrictive(REQUIRED, OPTIONAL, REQUIRED, OPTIONAL));    assertEquals(REQUIRED, Type.Repetition.leastRestrictive(REQUIRED, REQUIRED));}
be99768950f8df78033704250559a587404e4e92dfce8f6d76d312d71da9e826
testPaperExample
public void testPaperExample()
{    MessageType expected = new MessageType("Document", new PrimitiveType(REQUIRED, INT64, "DocId"), new GroupType(OPTIONAL, "Links", new PrimitiveType(REPEATED, INT64, "Backward"), new PrimitiveType(REPEATED, INT64, "Forward")), new GroupType(REPEATED, "Name", new GroupType(REPEATED, "Language", new PrimitiveType(REQUIRED, BINARY, "Code"), new PrimitiveType(REQUIRED, BINARY, "Country")), new PrimitiveType(OPTIONAL, BINARY, "Url")));    MessageType builderType = Types.buildMessage().required(INT64).named("DocId").optionalGroup().repeated(INT64).named("Backward").repeated(INT64).named("Forward").named("Links").repeatedGroup().repeatedGroup().required(BINARY).named("Code").required(BINARY).named("Country").named("Language").optional(BINARY).named("Url").named("Name").named("Document");    Assert.assertEquals(expected, builderType);}
1b4aceebe934a1682028da448ea859d5de424c803184df41ea8c3301f46d392f
testGroupTypeConstruction
public void testGroupTypeConstruction()
{    PrimitiveType f1 = Types.required(BINARY).as(UTF8).named("f1");    PrimitiveType f2 = Types.required(INT32).named("f2");    PrimitiveType f3 = Types.optional(INT32).named("f3");    String name = "group";    for (Type.Repetition repetition : Type.Repetition.values()) {        GroupType expected = new GroupType(repetition, name, f1, new GroupType(repetition, "g1", f2, f3));        GroupType built = Types.buildGroup(repetition).addField(f1).group(repetition).addFields(f2, f3).named("g1").named(name);        Assert.assertEquals(expected, built);        switch(repetition) {            case REQUIRED:                built = Types.requiredGroup().addField(f1).requiredGroup().addFields(f2, f3).named("g1").named(name);                break;            case OPTIONAL:                built = Types.optionalGroup().addField(f1).optionalGroup().addFields(f2, f3).named("g1").named(name);                break;            case REPEATED:                built = Types.repeatedGroup().addField(f1).repeatedGroup().addFields(f2, f3).named("g1").named(name);                break;        }        Assert.assertEquals(expected, built);    }}
9a23ad6cfc6b8c2133cdf7ff3e7148467242f97b894113289b435a55ddbea82e
testPrimitiveTypeConstruction
public void testPrimitiveTypeConstruction()
{    PrimitiveTypeName[] types = new PrimitiveTypeName[] { BOOLEAN, INT32, INT64, INT96, FLOAT, DOUBLE, BINARY };    for (PrimitiveTypeName type : types) {        String name = type.toString() + "_";        for (Type.Repetition repetition : Type.Repetition.values()) {            PrimitiveType expected = new PrimitiveType(repetition, type, name);            PrimitiveType built = Types.primitive(type, repetition).named(name);            Assert.assertEquals(expected, built);            switch(repetition) {                case REQUIRED:                    built = Types.required(type).named(name);                    break;                case OPTIONAL:                    built = Types.optional(type).named(name);                    break;                case REPEATED:                    built = Types.repeated(type).named(name);                    break;            }            Assert.assertEquals(expected, built);        }    }}
9de7bf86b2f51a6241888b564389b404b14247910bda607f57ff541bbcb922d1
testFixedTypeConstruction
public void testFixedTypeConstruction()
{    String name = "fixed_";    int len = 5;    for (Type.Repetition repetition : Type.Repetition.values()) {        PrimitiveType expected = new PrimitiveType(repetition, FIXED_LEN_BYTE_ARRAY, len, name);        PrimitiveType built = Types.primitive(FIXED_LEN_BYTE_ARRAY, repetition).length(len).named(name);        Assert.assertEquals(expected, built);        switch(repetition) {            case REQUIRED:                built = Types.required(FIXED_LEN_BYTE_ARRAY).length(len).named(name);                break;            case OPTIONAL:                built = Types.optional(FIXED_LEN_BYTE_ARRAY).length(len).named(name);                break;            case REPEATED:                built = Types.repeated(FIXED_LEN_BYTE_ARRAY).length(len).named(name);                break;        }        Assert.assertEquals(expected, built);    }}
1395d1725fa3fa9bade4a13e5079baf48a5422548ef939d3526835efb67a9330
testEmptyGroup
public void testEmptyGroup()
{        Assert.assertEquals("Should not complain about an empty required group", Types.requiredGroup().named("g"), new GroupType(REQUIRED, "g"));    Assert.assertEquals("Should not complain about an empty required group", Types.optionalGroup().named("g"), new GroupType(OPTIONAL, "g"));    Assert.assertEquals("Should not complain about an empty required group", Types.repeatedGroup().named("g"), new GroupType(REPEATED, "g"));}
cd55e87e83c5e4c27db397f10e711d2d0263b92f1641862b1e17b9a2038117fc
testEmptyMessage
public void testEmptyMessage()
{        Assert.assertEquals("Should not complain about an empty required group", Types.buildMessage().named("m"), new MessageType("m"));}
a0a855d153f47249cb501428d7527569d30c7dbfe5b06e05d6fc1131dabac752
testFixedWithoutLength
public void testFixedWithoutLength()
{    Types.required(FIXED_LEN_BYTE_ARRAY).named("fixed");}
80164b14eceddf825a415b0ad583cf0b36e516ffa71d19896eae2e495ef9d3a7
testFixedWithLength
public void testFixedWithLength()
{    PrimitiveType expected = new PrimitiveType(REQUIRED, FIXED_LEN_BYTE_ARRAY, 7, "fixed");    PrimitiveType fixed = Types.required(FIXED_LEN_BYTE_ARRAY).length(7).named("fixed");    Assert.assertEquals(expected, fixed);}
a89453474c7ad1bb8d31e480f888c8f90602fc089ab41ae02ede386a2022803f
testFixedLengthEquals
public void testFixedLengthEquals()
{    Type f4 = Types.required(FIXED_LEN_BYTE_ARRAY).length(4).named("f4");    Type f8 = Types.required(FIXED_LEN_BYTE_ARRAY).length(8).named("f8");    Assert.assertFalse("Types with different lengths should not be equal", f4.equals(f8));}
bb15256b7eaa9e8ea1f3ac36d6afd1d08bc029330291b75504aff27861a3ba20
testDecimalAnnotation
public void testDecimalAnnotation()
{        MessageType expected = new MessageType("DecimalMessage", new PrimitiveType(REQUIRED, INT32, 0, "aDecimal", DECIMAL, new DecimalMetadata(9, 2), null));    MessageType builderType = Types.buildMessage().required(INT32).as(DECIMAL).precision(9).scale(2).named("aDecimal").named("DecimalMessage");    Assert.assertEquals(expected, builderType);        expected = new MessageType("DecimalMessage", new PrimitiveType(REQUIRED, INT64, 0, "aDecimal", DECIMAL, new DecimalMetadata(18, 2), null));    builderType = Types.buildMessage().required(INT64).as(DECIMAL).precision(18).scale(2).named("aDecimal").named("DecimalMessage");    Assert.assertEquals(expected, builderType);        expected = new MessageType("DecimalMessage", new PrimitiveType(REQUIRED, BINARY, 0, "aDecimal", DECIMAL, new DecimalMetadata(9, 2), null));    builderType = Types.buildMessage().required(BINARY).as(DECIMAL).precision(9).scale(2).named("aDecimal").named("DecimalMessage");    Assert.assertEquals(expected, builderType);        expected = new MessageType("DecimalMessage", new PrimitiveType(REQUIRED, FIXED_LEN_BYTE_ARRAY, 4, "aDecimal", DECIMAL, new DecimalMetadata(9, 2), null));    builderType = Types.buildMessage().required(FIXED_LEN_BYTE_ARRAY).length(4).as(DECIMAL).precision(9).scale(2).named("aDecimal").named("DecimalMessage");    Assert.assertEquals(expected, builderType);}
a2a9a70dd3fa7739dd79ed0005d4ba554cc5008153df82c9e16158bfbd64b975
testDecimalAnnotationMissingScale
public void testDecimalAnnotationMissingScale()
{    MessageType expected = new MessageType("DecimalMessage", new PrimitiveType(REQUIRED, INT32, 0, "aDecimal", DECIMAL, new DecimalMetadata(9, 0), null));    MessageType builderType = Types.buildMessage().required(INT32).as(DECIMAL).precision(9).named("aDecimal").named("DecimalMessage");    Assert.assertEquals(expected, builderType);    expected = new MessageType("DecimalMessage", new PrimitiveType(REQUIRED, INT64, 0, "aDecimal", DECIMAL, new DecimalMetadata(9, 0), null));    builderType = Types.buildMessage().required(INT64).as(DECIMAL).precision(9).named("aDecimal").named("DecimalMessage");    Assert.assertEquals(expected, builderType);    expected = new MessageType("DecimalMessage", new PrimitiveType(REQUIRED, BINARY, 0, "aDecimal", DECIMAL, new DecimalMetadata(9, 0), null));    builderType = Types.buildMessage().required(BINARY).as(DECIMAL).precision(9).named("aDecimal").named("DecimalMessage");    Assert.assertEquals(expected, builderType);    expected = new MessageType("DecimalMessage", new PrimitiveType(REQUIRED, FIXED_LEN_BYTE_ARRAY, 7, "aDecimal", DECIMAL, new DecimalMetadata(9, 0), null));    builderType = Types.buildMessage().required(FIXED_LEN_BYTE_ARRAY).length(7).as(DECIMAL).precision(9).named("aDecimal").named("DecimalMessage");    Assert.assertEquals(expected, builderType);}
038bc1e8223c8d41d0e8c982503e51bc2deead374537cea0d93a1784b510434d
testDecimalAnnotationMissingPrecision
public void testDecimalAnnotationMissingPrecision()
{    assertThrows("Should reject decimal annotation without precision", IllegalArgumentException.class, (Callable<Type>) () -> Types.buildMessage().required(INT32).as(DECIMAL).scale(2).named("aDecimal").named("DecimalMessage"));    assertThrows("Should reject decimal annotation without precision", IllegalArgumentException.class, (Callable<Type>) () -> Types.buildMessage().required(INT64).as(DECIMAL).scale(2).named("aDecimal").named("DecimalMessage"));    assertThrows("Should reject decimal annotation without precision", IllegalArgumentException.class, (Callable<Type>) () -> Types.buildMessage().required(BINARY).as(DECIMAL).scale(2).named("aDecimal").named("DecimalMessage"));    assertThrows("Should reject decimal annotation without precision", IllegalArgumentException.class, (Callable<Type>) () -> Types.buildMessage().required(FIXED_LEN_BYTE_ARRAY).length(7).as(DECIMAL).scale(2).named("aDecimal").named("DecimalMessage"));}
8bb094e1bc7f8eefe5e144fcc8408ecbd584b2992b8e4415f9100c9ece323869
testDecimalAnnotationPrecisionScaleBound
public void testDecimalAnnotationPrecisionScaleBound()
{    assertThrows("Should reject scale greater than precision", IllegalArgumentException.class, (Callable<Type>) () -> Types.buildMessage().required(INT32).as(DECIMAL).precision(3).scale(4).named("aDecimal").named("DecimalMessage"));    assertThrows("Should reject scale greater than precision", IllegalArgumentException.class, (Callable<Type>) () -> Types.buildMessage().required(INT64).as(DECIMAL).precision(3).scale(4).named("aDecimal").named("DecimalMessage"));    assertThrows("Should reject scale greater than precision", IllegalArgumentException.class, (Callable<Type>) () -> Types.buildMessage().required(BINARY).as(DECIMAL).precision(3).scale(4).named("aDecimal").named("DecimalMessage"));    assertThrows("Should reject scale greater than precision", IllegalArgumentException.class, (Callable<Type>) () -> Types.buildMessage().required(FIXED_LEN_BYTE_ARRAY).length(7).as(DECIMAL).precision(3).scale(4).named("aDecimal").named("DecimalMessage"));}
c3f32a63ed3984b99a917400e73eeddc3eb7bc5b2ab008f276d6f716eb486312
testDecimalAnnotationLengthCheck
public void testDecimalAnnotationLengthCheck()
{        assertThrows("should reject precision 10 with length 4", IllegalStateException.class, (Callable<Type>) () -> Types.required(FIXED_LEN_BYTE_ARRAY).length(4).as(DECIMAL).precision(10).scale(2).named("aDecimal"));    assertThrows("should reject precision 10 with length 4", IllegalStateException.class, (Callable<Type>) () -> Types.required(INT32).as(DECIMAL).precision(10).scale(2).named("aDecimal"));        assertThrows("should reject precision 19 with length 8", IllegalStateException.class, (Callable<Type>) () -> Types.required(FIXED_LEN_BYTE_ARRAY).length(8).as(DECIMAL).precision(19).scale(4).named("aDecimal"));    assertThrows("should reject precision 19 with length 8", IllegalStateException.class, (Callable<Type>) () -> Types.required(INT64).length(8).as(DECIMAL).precision(19).scale(4).named("aDecimal"));}
707b14ce29d553cc89d7ee4997f4c026965ac79aad6ee97099251effb32ce3a5
testDECIMALAnnotationRejectsUnsupportedTypes
public void testDECIMALAnnotationRejectsUnsupportedTypes()
{    PrimitiveTypeName[] unsupported = new PrimitiveTypeName[] { BOOLEAN, INT96, DOUBLE, FLOAT };    for (final PrimitiveTypeName type : unsupported) {        assertThrows("Should reject non-binary type: " + type, IllegalStateException.class, (Callable<Type>) () -> Types.required(type).as(DECIMAL).precision(9).scale(2).named("d"));    }}
48af8d2d970d112261a017be711aebc75370cd46e1dc38d1f28ffcdc6c78cbb6
testBinaryAnnotations
public void testBinaryAnnotations()
{    OriginalType[] types = new OriginalType[] { UTF8, JSON, BSON };    for (final OriginalType logicalType : types) {        PrimitiveType expected = new PrimitiveType(REQUIRED, BINARY, "col", logicalType);        PrimitiveType string = Types.required(BINARY).as(logicalType).named("col");        Assert.assertEquals(expected, string);    }}
6cea87e1f862985436ebb30fe726885f263495036d669c8a4b29fe57aac6ff2b
testBinaryAnnotationsRejectsNonBinary
public void testBinaryAnnotationsRejectsNonBinary()
{    OriginalType[] types = new OriginalType[] { UTF8, JSON, BSON };    for (final OriginalType logicalType : types) {        PrimitiveTypeName[] nonBinary = new PrimitiveTypeName[] { BOOLEAN, INT32, INT64, INT96, DOUBLE, FLOAT };        for (final PrimitiveTypeName type : nonBinary) {            assertThrows("Should reject non-binary type: " + type, IllegalStateException.class, (Callable<Type>) () -> Types.required(type).as(logicalType).named("col"));        }        assertThrows("Should reject non-binary type: FIXED_LEN_BYTE_ARRAY", IllegalStateException.class, (Callable<Type>) () -> Types.required(FIXED_LEN_BYTE_ARRAY).length(1).as(logicalType).named("col"));    }}
6d5c1c9a308fd3b26012ca10da65da8b2a74f13f0eb8ca7420356e3a7c96e181
testInt32Annotations
public void testInt32Annotations()
{    OriginalType[] types = new OriginalType[] { DATE, TIME_MILLIS, UINT_8, UINT_16, UINT_32, INT_8, INT_16, INT_32 };    for (OriginalType logicalType : types) {        PrimitiveType expected = new PrimitiveType(REQUIRED, INT32, "col", logicalType);        PrimitiveType date = Types.required(INT32).as(logicalType).named("col");        Assert.assertEquals(expected, date);    }}
1a5c98d9ab5a9ff1be3cd2495cff79454572aae17f179e36cf40e8e6c8b9f41f
testInt32AnnotationsRejectNonInt32
public void testInt32AnnotationsRejectNonInt32()
{    OriginalType[] types = new OriginalType[] { DATE, TIME_MILLIS, UINT_8, UINT_16, UINT_32, INT_8, INT_16, INT_32 };    for (final OriginalType logicalType : types) {        PrimitiveTypeName[] nonInt32 = new PrimitiveTypeName[] { BOOLEAN, INT64, INT96, DOUBLE, FLOAT, BINARY };        for (final PrimitiveTypeName type : nonInt32) {            assertThrows("Should reject non-int32 type: " + type, IllegalStateException.class, (Callable<Type>) () -> Types.required(type).as(logicalType).named("col"));        }        assertThrows("Should reject non-int32 type: FIXED_LEN_BYTE_ARRAY", IllegalStateException.class, (Callable<Type>) () -> Types.required(FIXED_LEN_BYTE_ARRAY).length(1).as(logicalType).named("col"));    }}
5012f2447715f518a17392e19b87390af36e30b445142bdb4c6e4edc19ce94d9
testInt64Annotations
public void testInt64Annotations()
{    OriginalType[] types = new OriginalType[] { TIME_MICROS, TIMESTAMP_MILLIS, TIMESTAMP_MICROS, UINT_64, INT_64 };    for (OriginalType logicalType : types) {        PrimitiveType expected = new PrimitiveType(REQUIRED, INT64, "col", logicalType);        PrimitiveType date = Types.required(INT64).as(logicalType).named("col");        Assert.assertEquals(expected, date);    }}
f935bf289b5cc050d7afea6b41fb640ae7067c3a95a1f7a933cc9527923e91bc
testInt64AnnotationsRejectNonInt64
public void testInt64AnnotationsRejectNonInt64()
{    OriginalType[] types = new OriginalType[] { TIME_MICROS, TIMESTAMP_MILLIS, TIMESTAMP_MICROS, UINT_64, INT_64 };    for (final OriginalType logicalType : types) {        PrimitiveTypeName[] nonInt64 = new PrimitiveTypeName[] { BOOLEAN, INT32, INT96, DOUBLE, FLOAT, BINARY };        for (final PrimitiveTypeName type : nonInt64) {            assertThrows("Should reject non-int64 type: " + type, IllegalStateException.class, (Callable<Type>) () -> Types.required(type).as(logicalType).named("col"));        }        assertThrows("Should reject non-int64 type: FIXED_LEN_BYTE_ARRAY", IllegalStateException.class, (Callable<Type>) () -> Types.required(FIXED_LEN_BYTE_ARRAY).length(1).as(logicalType).named("col"));    }}
d9235ceadf4534223d3f68e1484fc937bd974d3272605a0b059efde816b036a2
testIntervalAnnotation
public void testIntervalAnnotation()
{    PrimitiveType expected = new PrimitiveType(REQUIRED, FIXED_LEN_BYTE_ARRAY, 12, "interval", INTERVAL);    PrimitiveType string = Types.required(FIXED_LEN_BYTE_ARRAY).length(12).as(INTERVAL).named("interval");    Assert.assertEquals(expected, string);}
d6d5de8177e68f5335fae3f08d2a7c0fb4ad5d45f0288ebc3b9dfad516d64b48
testIntervalAnnotationRejectsNonFixed
public void testIntervalAnnotationRejectsNonFixed()
{    PrimitiveTypeName[] nonFixed = new PrimitiveTypeName[] { BOOLEAN, INT32, INT64, INT96, DOUBLE, FLOAT, BINARY };    for (final PrimitiveTypeName type : nonFixed) {        assertThrows("Should reject non-fixed type: " + type, IllegalStateException.class, (Callable<Type>) () -> Types.required(type).as(INTERVAL).named("interval"));    }}
bc7118bb47f597a3c460c8c5481db7ef6c74f6cc999300097078d31444af5daf
testIntervalAnnotationRejectsNonFixed12
public void testIntervalAnnotationRejectsNonFixed12()
{    assertThrows("Should reject fixed with length != 12: " + 11, IllegalStateException.class, (Callable<Type>) () -> Types.required(FIXED_LEN_BYTE_ARRAY).length(11).as(INTERVAL).named("interval"));}
73af2883a12ad57b7181f5f4910c1171449f21a04b0e1a06a9a696e3f7765e0c
testRequiredMap
public void testRequiredMap()
{    List<Type> typeList = new ArrayList<Type>();    typeList.add(new PrimitiveType(REQUIRED, INT64, "key"));    typeList.add(new PrimitiveType(REQUIRED, INT64, "value"));    GroupType expected = new GroupType(REQUIRED, "myMap", OriginalType.MAP, new GroupType(REPEATED, "map", typeList));    GroupType actual = Types.requiredMap().key(INT64).requiredValue(INT64).named("myMap");    Assert.assertEquals(expected, actual);}
988cf35a8d2e07fe5d2e45c571a41a9634ac72364e7c2aa58068095e5c5448a6
testOptionalMap
public void testOptionalMap()
{    List<Type> typeList = new ArrayList<Type>();    typeList.add(new PrimitiveType(REQUIRED, INT64, "key"));    typeList.add(new PrimitiveType(REQUIRED, INT64, "value"));    GroupType expected = new GroupType(OPTIONAL, "myMap", OriginalType.MAP, new GroupType(REPEATED, "map", typeList));    GroupType actual = Types.optionalMap().key(INT64).requiredValue(INT64).named("myMap");    Assert.assertEquals(expected, actual);}
a1225e0adbd3d1f2fcade592d7774afc83eaeda08885d6154f4d2bc7d221139d
testMapWithRequiredValue
public void testMapWithRequiredValue()
{    List<Type> typeList = new ArrayList<Type>();    typeList.add(new PrimitiveType(REQUIRED, INT64, "key"));    typeList.add(new PrimitiveType(REQUIRED, INT64, "value"));    GroupType map = new GroupType(REQUIRED, "myMap", OriginalType.MAP, new GroupType(REPEATED, "map", typeList));    MessageType expected = new MessageType("mapParent", map);    GroupType actual = Types.buildMessage().requiredMap().key(INT64).requiredValue(INT64).named("myMap").named("mapParent");    Assert.assertEquals(expected, actual);}
69b1844da298763efa452e124b5996bfe0bd5cadf0ce608dbe1f2f23e687e9c1
testMapWithOptionalValue
public void testMapWithOptionalValue()
{    List<Type> typeList = new ArrayList<Type>();    typeList.add(new PrimitiveType(REQUIRED, INT64, "key"));    typeList.add(new PrimitiveType(OPTIONAL, INT64, "value"));    GroupType map = new GroupType(REQUIRED, "myMap", OriginalType.MAP, new GroupType(REPEATED, "map", typeList));    MessageType expected = new MessageType("mapParent", map);    GroupType actual = Types.buildMessage().requiredMap().key(INT64).optionalValue(INT64).named("myMap").named("mapParent");    Assert.assertEquals(expected, actual);}
298a268e09a29ac78c73f5ffe8c03205606906c271b16fc06fa35281f8e649d3
testMapWithGroupKeyAndOptionalGroupValue
public void testMapWithGroupKeyAndOptionalGroupValue()
{    List<Type> typeList = new ArrayList<Type>();    List<Type> keyFields = new ArrayList<Type>();    keyFields.add(new PrimitiveType(OPTIONAL, INT64, "first"));    keyFields.add(new PrimitiveType(OPTIONAL, DOUBLE, "second"));    typeList.add(new GroupType(REQUIRED, "key", keyFields));    List<Type> valueFields = new ArrayList<Type>();    valueFields.add(new PrimitiveType(OPTIONAL, DOUBLE, "one"));    valueFields.add(new PrimitiveType(OPTIONAL, INT32, "two"));    typeList.add(new GroupType(OPTIONAL, "value", valueFields));    GroupType map = new GroupType(OPTIONAL, "myMap", OriginalType.MAP, new GroupType(REPEATED, "map", typeList));    GroupType actual = Types.optionalMap().groupKey().optional(INT64).named("first").optional(DOUBLE).named("second").optionalGroupValue().optional(DOUBLE).named("one").optional(INT32).named("two").named("myMap");    Assert.assertEquals(map, actual);}
a4364e204b224925c04a397b4a1b94dab8ac1cc273deae4497db52203ff09958
testMapWithGroupKeyAndRequiredGroupValue
public void testMapWithGroupKeyAndRequiredGroupValue()
{    List<Type> typeList = new ArrayList<Type>();    List<Type> keyFields = new ArrayList<Type>();    keyFields.add(new PrimitiveType(OPTIONAL, INT64, "first"));    keyFields.add(new PrimitiveType(OPTIONAL, DOUBLE, "second"));    typeList.add(new GroupType(REQUIRED, "key", keyFields));    List<Type> valueFields = new ArrayList<Type>();    valueFields.add(new PrimitiveType(OPTIONAL, DOUBLE, "one"));    valueFields.add(new PrimitiveType(OPTIONAL, INT32, "two"));    typeList.add(new GroupType(REQUIRED, "value", valueFields));    GroupType map = new GroupType(OPTIONAL, "myMap", OriginalType.MAP, new GroupType(REPEATED, "map", typeList));    MessageType expected = new MessageType("mapParent", map);    GroupType actual = Types.buildMessage().optionalMap().groupKey().optional(INT64).named("first").optional(DOUBLE).named("second").requiredGroupValue().optional(DOUBLE).named("one").optional(INT32).named("two").named("myMap").named("mapParent");    Assert.assertEquals(expected, actual);}
0bb824cbe9476e4ccd7c2a540a9d41dde6b03b2ded94954d79f29fcef87133b0
testMapWithGroupKeyAndOptionalValue
public void testMapWithGroupKeyAndOptionalValue()
{    List<Type> typeList = new ArrayList<Type>();    List<Type> keyFields = new ArrayList<Type>();    keyFields.add(new PrimitiveType(OPTIONAL, INT64, "first"));    keyFields.add(new PrimitiveType(OPTIONAL, DOUBLE, "second"));    typeList.add(new GroupType(REQUIRED, "key", keyFields));    typeList.add(new PrimitiveType(OPTIONAL, DOUBLE, "value"));    GroupType map = new GroupType(OPTIONAL, "myMap", OriginalType.MAP, new GroupType(REPEATED, "map", typeList));    MessageType expected = new MessageType("mapParent", map);    GroupType actual = Types.buildMessage().optionalMap().groupKey().optional(INT64).named("first").optional(DOUBLE).named("second").optionalValue(DOUBLE).named("myMap").named("mapParent");    Assert.assertEquals(expected, actual);}
2047cca9831632e3fdb156143985e631d92d1d3aefac5f68483e3b8add067fd5
testMapWithGroupKeyAndRequiredValue
public void testMapWithGroupKeyAndRequiredValue()
{    List<Type> typeList = new ArrayList<Type>();    List<Type> keyFields = new ArrayList<Type>();    keyFields.add(new PrimitiveType(OPTIONAL, INT64, "first"));    keyFields.add(new PrimitiveType(OPTIONAL, DOUBLE, "second"));    typeList.add(new GroupType(REQUIRED, "key", keyFields));    typeList.add(new PrimitiveType(REQUIRED, DOUBLE, "value"));    GroupType map = new GroupType(OPTIONAL, "myMap", OriginalType.MAP, new GroupType(REPEATED, "map", typeList));    MessageType expected = new MessageType("mapParent", map);    GroupType actual = Types.buildMessage().optionalMap().groupKey().optional(INT64).named("first").optional(DOUBLE).named("second").requiredValue(DOUBLE).named("myMap").named("mapParent");    Assert.assertEquals(expected, actual);}
ce822403fbd8c271d36b38f41c5f3f6e1f7ab2bb0f419eb40caccc88cbcabd17
testMapWithOptionalGroupValue
public void testMapWithOptionalGroupValue()
{    List<Type> typeList = new ArrayList<Type>();    List<Type> keyFields = new ArrayList<Type>();    keyFields.add(new PrimitiveType(OPTIONAL, INT64, "first"));    keyFields.add(new PrimitiveType(OPTIONAL, DOUBLE, "second"));    typeList.add(new PrimitiveType(REQUIRED, INT64, "key"));    List<Type> valueFields = new ArrayList<Type>();    valueFields.add(new PrimitiveType(OPTIONAL, DOUBLE, "one"));    valueFields.add(new PrimitiveType(OPTIONAL, INT32, "two"));    typeList.add(new GroupType(OPTIONAL, "value", valueFields));    GroupType map = new GroupType(OPTIONAL, "myMap", OriginalType.MAP, new GroupType(REPEATED, "map", typeList));    MessageType expected = new MessageType("mapParent", map);    GroupType actual = Types.buildMessage().optionalMap().key(INT64).optionalGroupValue().optional(DOUBLE).named("one").optional(INT32).named("two").named("myMap").named("mapParent");    Assert.assertEquals(expected, actual);}
198bc8c3a5b4ae555e234b59b31971443107fec1150aeda0fc30c1d332c45412
testMapWithRequiredGroupValue
public void testMapWithRequiredGroupValue()
{    List<Type> typeList = new ArrayList<Type>();    typeList.add(new PrimitiveType(REQUIRED, INT64, "key"));    List<Type> valueFields = new ArrayList<Type>();    valueFields.add(new PrimitiveType(OPTIONAL, DOUBLE, "one"));    valueFields.add(new PrimitiveType(OPTIONAL, INT32, "two"));    typeList.add(new GroupType(REQUIRED, "value", valueFields));    GroupType map = new GroupType(OPTIONAL, "myMap", OriginalType.MAP, new GroupType(REPEATED, "map", typeList));    MessageType expected = new MessageType("mapParent", map);    GroupType actual = Types.buildMessage().optionalMap().key(INT64).requiredGroupValue().optional(DOUBLE).named("one").optional(INT32).named("two").named("myMap").named("mapParent");    Assert.assertEquals(expected, actual);}
ac673be62d82181fd0b2cd33e91e7ee48c20e33fc248b95053bf4f678caea98b
testMapWithNestedGroupKeyAndNestedGroupValue
public void testMapWithNestedGroupKeyAndNestedGroupValue()
{    List<Type> typeList = new ArrayList<Type>();    List<Type> innerFields = new ArrayList<Type>();    innerFields.add(new PrimitiveType(REQUIRED, FLOAT, "inner_key_1"));    innerFields.add(new PrimitiveType(OPTIONAL, INT32, "inner_key_2"));    List<Type> keyFields = new ArrayList<Type>();    keyFields.add(new PrimitiveType(OPTIONAL, INT64, "first"));    keyFields.add(new GroupType(REQUIRED, "second", innerFields));    typeList.add(new GroupType(REQUIRED, "key", keyFields));    List<Type> valueFields = new ArrayList<Type>();    valueFields.add(new GroupType(OPTIONAL, "one", innerFields));    valueFields.add(new PrimitiveType(OPTIONAL, INT32, "two"));    typeList.add(new GroupType(OPTIONAL, "value", valueFields));    GroupType map = new GroupType(REQUIRED, "myMap", OriginalType.MAP, new GroupType(REPEATED, "map", typeList));    MessageType expected = new MessageType("mapParent", map);    GroupType actual = Types.buildMessage().requiredMap().groupKey().optional(INT64).named("first").requiredGroup().required(FLOAT).named("inner_key_1").optional(INT32).named("inner_key_2").named("second").optionalGroupValue().optionalGroup().required(FLOAT).named("inner_key_1").optional(INT32).named("inner_key_2").named("one").optional(INT32).named("two").named("myMap").named("mapParent");    Assert.assertEquals(expected, actual);}
9af5e1c30d1c8de21cd5db5913c402c3f5e695fa495213a4cb4e2d6e9a86efff
testMapWithRequiredListValue
public void testMapWithRequiredListValue()
{    List<Type> typeList = new ArrayList<Type>();    typeList.add(new PrimitiveType(REQUIRED, INT64, "key"));    typeList.add(new GroupType(REQUIRED, "value", OriginalType.LIST, new GroupType(REPEATED, "list", new PrimitiveType(OPTIONAL, INT64, "element"))));    GroupType map = new GroupType(OPTIONAL, "myMap", OriginalType.MAP, new GroupType(REPEATED, "map", typeList));    MessageType expected = new MessageType("mapParent", map);    GroupType actual = Types.buildMessage().optionalMap().key(INT64).requiredListValue().optionalElement(INT64).named("myMap").named("mapParent");    Assert.assertEquals(expected, actual);}
bd65f23425bf93193d36e29a863e80e1c5da4c3b4fb9d93c76625ba2c47df5db
testMapWithOptionalListValue
public void testMapWithOptionalListValue()
{    List<Type> typeList = new ArrayList<Type>();    typeList.add(new PrimitiveType(REQUIRED, INT64, "key"));    typeList.add(new GroupType(OPTIONAL, "value", OriginalType.LIST, new GroupType(REPEATED, "list", new PrimitiveType(OPTIONAL, INT64, "element"))));    GroupType map = new GroupType(OPTIONAL, "myMap", OriginalType.MAP, new GroupType(REPEATED, "map", typeList));    MessageType expected = new MessageType("mapParent", map);    GroupType actual = Types.buildMessage().optionalMap().key(INT64).optionalListValue().optionalElement(INT64).named("myMap").named("mapParent");    Assert.assertEquals(expected, actual);}
72226da84eee0a93280a2b82a52ab15ef0ec78b75aaf116912aa076497b250b9
testMapWithRequiredMapValue
public void testMapWithRequiredMapValue()
{    List<Type> typeList = new ArrayList<Type>();    List<Type> innerMapTypeList = new ArrayList<Type>();    innerMapTypeList.add(new PrimitiveType(REQUIRED, INT64, "key"));    innerMapTypeList.add(new PrimitiveType(REQUIRED, INT64, "value"));    typeList.add(new PrimitiveType(REQUIRED, INT64, "key"));    typeList.add(new GroupType(REQUIRED, "value", OriginalType.MAP, new GroupType(REPEATED, "map", innerMapTypeList)));    GroupType map = new GroupType(OPTIONAL, "myMap", OriginalType.MAP, new GroupType(REPEATED, "map", typeList));    MessageType expected = new MessageType("mapParent", map);    GroupType actual = Types.buildMessage().optionalMap().key(INT64).requiredMapValue().key(INT64).requiredValue(INT64).named("myMap").named("mapParent");    Assert.assertEquals(expected, actual);}
dcd4fc14e5a4907a920c7190986b3316fb57714d957868dd3f17d6d1e894c5e5
testMapWithOptionalMapValue
public void testMapWithOptionalMapValue()
{    List<Type> typeList = new ArrayList<Type>();    List<Type> innerMapTypeList = new ArrayList<Type>();    innerMapTypeList.add(new PrimitiveType(REQUIRED, INT64, "key"));    innerMapTypeList.add(new PrimitiveType(REQUIRED, INT64, "value"));    typeList.add(new PrimitiveType(REQUIRED, INT64, "key"));    typeList.add(new GroupType(OPTIONAL, "value", OriginalType.MAP, new GroupType(REPEATED, "map", innerMapTypeList)));    GroupType map = new GroupType(OPTIONAL, "myMap", OriginalType.MAP, new GroupType(REPEATED, "map", typeList));    MessageType expected = new MessageType("mapParent", map);    GroupType actual = Types.buildMessage().optionalMap().key(INT64).optionalMapValue().key(INT64).requiredValue(INT64).named("myMap").named("mapParent");    Assert.assertEquals(expected, actual);}
a66719d76e7dc6e56da8b3a467e940c8efdfa87bc7ad84eb5b56b6abefdde99f
testMapWithGroupKeyAndRequiredListValue
public void testMapWithGroupKeyAndRequiredListValue()
{    List<Type> typeList = new ArrayList<Type>();    typeList.add(new GroupType(REQUIRED, "key", new PrimitiveType(REQUIRED, INT64, "first")));    typeList.add(new GroupType(REQUIRED, "value", OriginalType.LIST, new GroupType(REPEATED, "list", new PrimitiveType(OPTIONAL, INT64, "element"))));    GroupType map = new GroupType(OPTIONAL, "myMap", OriginalType.MAP, new GroupType(REPEATED, "map", typeList));    MessageType expected = new MessageType("mapParent", map);    GroupType actual = Types.buildMessage().optionalMap().groupKey().required(INT64).named("first").requiredListValue().optionalElement(INT64).named("myMap").named("mapParent");    Assert.assertEquals(expected, actual);}
e84593cf2ffaf84ed818724497068070485b8d56ea0ab75cd415dc409dc5fccc
testMapWithGroupKeyAndOptionalListValue
public void testMapWithGroupKeyAndOptionalListValue()
{    List<Type> typeList = new ArrayList<Type>();    typeList.add(new GroupType(REQUIRED, "key", new PrimitiveType(REQUIRED, INT64, "first")));    typeList.add(new GroupType(OPTIONAL, "value", OriginalType.LIST, new GroupType(REPEATED, "list", new PrimitiveType(OPTIONAL, INT64, "element"))));    GroupType map = new GroupType(OPTIONAL, "myMap", OriginalType.MAP, new GroupType(REPEATED, "map", typeList));    MessageType expected = new MessageType("mapParent", map);    GroupType actual = Types.buildMessage().optionalMap().groupKey().required(INT64).named("first").optionalListValue().optionalElement(INT64).named("myMap").named("mapParent");    Assert.assertEquals(expected, actual);}
1e328f5bb90da573cd6d90ec873420d9a50fe125eaab8aa705a9f2246e26f9dd
testMapWithGroupKeyAndRequiredMapValue
public void testMapWithGroupKeyAndRequiredMapValue()
{    List<Type> typeList = new ArrayList<Type>();    List<Type> innerMapTypeList = new ArrayList<Type>();    innerMapTypeList.add(new PrimitiveType(REQUIRED, INT64, "key"));    innerMapTypeList.add(new PrimitiveType(REQUIRED, INT64, "value"));    typeList.add(new GroupType(REQUIRED, "key", new PrimitiveType(REQUIRED, INT64, "first")));    typeList.add(new GroupType(REQUIRED, "value", OriginalType.MAP, new GroupType(REPEATED, "map", innerMapTypeList)));    GroupType map = new GroupType(OPTIONAL, "myMap", OriginalType.MAP, new GroupType(REPEATED, "map", typeList));    MessageType expected = new MessageType("mapParent", map);    GroupType actual = Types.buildMessage().optionalMap().groupKey().required(INT64).named("first").requiredMapValue().key(INT64).requiredValue(INT64).named("myMap").named("mapParent");    Assert.assertEquals(expected, actual);}
1de20b00e04c9536c9dc4ffc141e6d8ab4d5a2f489d4513fa27f6976ced63dda
testMapWithGroupKeyAndOptionalMapValue
public void testMapWithGroupKeyAndOptionalMapValue()
{    List<Type> typeList = new ArrayList<Type>();    List<Type> innerMapTypeList = new ArrayList<Type>();    innerMapTypeList.add(new PrimitiveType(REQUIRED, INT64, "key"));    innerMapTypeList.add(new PrimitiveType(REQUIRED, INT64, "value"));    typeList.add(new GroupType(REQUIRED, "key", new PrimitiveType(REQUIRED, INT64, "first")));    typeList.add(new GroupType(OPTIONAL, "value", OriginalType.MAP, new GroupType(REPEATED, "map", innerMapTypeList)));    GroupType map = new GroupType(OPTIONAL, "myMap", OriginalType.MAP, new GroupType(REPEATED, "map", typeList));    MessageType expected = new MessageType("mapParent", map);    GroupType actual = Types.buildMessage().optionalMap().groupKey().required(INT64).named("first").optionalMapValue().key(INT64).requiredValue(INT64).named("myMap").named("mapParent");    Assert.assertEquals(expected, actual);}
43051c974e891c2f46dc2210dd796fc8149201d7a9fee532552467e40e459698
testMapWithNullValue
public void testMapWithNullValue()
{    List<Type> typeList = new ArrayList<Type>();    typeList.add(new PrimitiveType(REQUIRED, INT64, "key"));    GroupType map = new GroupType(OPTIONAL, "myMap", OriginalType.MAP, new GroupType(REPEATED, "map", typeList));    MessageType expected = new MessageType("mapParent", map);    GroupType actual = Types.buildMessage().optionalMap().key(INT64).named("myMap").named("mapParent");    Assert.assertEquals(expected, actual);}
0a7f0134879240633d52678dfa0b72b7b847dacf7ba0e94abdd3babc1b9974b8
testMapWithDefaultKeyAndNullValue
public void testMapWithDefaultKeyAndNullValue()
{    List<Type> typeList = new ArrayList<Type>();    typeList.add(new PrimitiveType(REQUIRED, BINARY, "key", OriginalType.UTF8));    GroupType map = new GroupType(OPTIONAL, "myMap", OriginalType.MAP, new GroupType(REPEATED, "map", typeList));    MessageType expected = new MessageType("mapParent", map);    GroupType actual = Types.buildMessage().optionalMap().named("myMap").named("mapParent");    Assert.assertEquals(expected, actual);}
25fc0e3d3bdc4caa69123fd053db57f7a69b5cd24b9a67eec818a2221934295b
testMapWithPreBuiltKeyAndValueTypes
public void testMapWithPreBuiltKeyAndValueTypes()
{    Type keyType = Types.required(INT64).named("key");    Type valueType = Types.required(BOOLEAN).named("value");    GroupType map = new GroupType(REQUIRED, "myMap", OriginalType.MAP, new GroupType(REPEATED, "map", new Type[] { keyType, valueType }));    MessageType expected = new MessageType("mapParent", map);    GroupType actual = Types.buildMessage().requiredMap().key(keyType).value(valueType).named("myMap").named("mapParent");    Assert.assertEquals(expected, actual);}
9375740b4983635c28ba5fb3a45c410a5401747dbd1795984832fd41a0ee1212
testListWithRequiredPreBuiltElement
public void testListWithRequiredPreBuiltElement()
{    GroupType expected = new GroupType(REQUIRED, "myList", OriginalType.LIST, new GroupType(REPEATED, "list", new PrimitiveType(REQUIRED, INT64, "element")));    Type element = Types.primitive(INT64, REQUIRED).named("element");    Type actual = Types.requiredList().element(element).named("myList");    Assert.assertEquals(expected, actual);}
72086b7856fd44e1151db6c3a14e2bcad673311bf0c0743497f18ed0d81be2ac
testRequiredList
public void testRequiredList()
{    GroupType expected = new GroupType(REQUIRED, "myList", OriginalType.LIST, new GroupType(REPEATED, "list", new PrimitiveType(OPTIONAL, INT64, "element")));    Type actual = Types.requiredList().optionalElement(INT64).named("myList");    Assert.assertEquals(expected, actual);}
f084fd90c731982bc51c3e2f0d3a86117a9ad9c6947f73c2c09981f66dbbd062
testOptionalList
public void testOptionalList()
{    GroupType expected = new GroupType(OPTIONAL, "myList", OriginalType.LIST, new GroupType(REPEATED, "list", new PrimitiveType(OPTIONAL, INT64, "element")));    Type actual = Types.optionalList().optionalElement(INT64).named("myList");    Assert.assertEquals(expected, actual);}
25549b8008f996fe1234b2dbcd5da4f83feaf02bca9de99626ca607a2a81c2b4
testListOfReqGroup
public void testListOfReqGroup()
{    List<Type> fields = new ArrayList<Type>();    fields.add(new PrimitiveType(OPTIONAL, BOOLEAN, "field"));    GroupType expected = new GroupType(REQUIRED, "myList", OriginalType.LIST, new GroupType(REPEATED, "list", new GroupType(REQUIRED, "element", fields)));    Type actual = Types.requiredList().requiredGroupElement().optional(BOOLEAN).named("field").named("myList");    Assert.assertEquals(expected, actual);}
33d97b000747387472cfd75a1c03cf75e9dbb634a3a4a5225686c606a78b23e0
testListOfOptionalGroup
public void testListOfOptionalGroup()
{    List<Type> fields = new ArrayList<Type>();    fields.add(new PrimitiveType(OPTIONAL, BOOLEAN, "field"));    GroupType expected = new GroupType(REQUIRED, "myList", OriginalType.LIST, new GroupType(REPEATED, "list", new GroupType(OPTIONAL, "element", fields)));    Type actual = Types.requiredList().optionalGroupElement().optional(BOOLEAN).named("field").named("myList");    Assert.assertEquals(expected, actual);}
391d1015ce4e7b94342870321bfd7b4772c16e2cff00fae74a6b71f0cbb5ee98
testRequiredNestedList
public void testRequiredNestedList()
{    List<Type> fields = new ArrayList<Type>();    fields.add(new GroupType(REQUIRED, "element", OriginalType.LIST, new GroupType(REPEATED, "list", new PrimitiveType(OPTIONAL, DOUBLE, "element"))));    GroupType expected = new GroupType(OPTIONAL, "myList", OriginalType.LIST, new GroupType(REPEATED, "list", fields));    Type actual = Types.optionalList().requiredListElement().optionalElement(DOUBLE).named("myList");    Assert.assertEquals(expected, actual);}
f5818f1159609bc24d56e3af4abea2ce2f00154e8d3434a1042a747060f30f17
testOptionalNestedList
public void testOptionalNestedList()
{    List<Type> fields = new ArrayList<Type>();    fields.add(new GroupType(OPTIONAL, "element", OriginalType.LIST, new GroupType(REPEATED, "list", new PrimitiveType(OPTIONAL, DOUBLE, "element"))));    GroupType expected = new GroupType(OPTIONAL, "myList", OriginalType.LIST, new GroupType(REPEATED, "list", fields));    Type actual = Types.optionalList().optionalListElement().optionalElement(DOUBLE).named("myList");    Assert.assertEquals(expected, actual);}
6fe91767c1f7bcc2f6ed19873c8fd00b1947800ea3113ff2e935735946e6a2f6
testRequiredListWithinGroup
public void testRequiredListWithinGroup()
{    List<Type> fields = new ArrayList<Type>();    fields.add(new GroupType(REQUIRED, "element", OriginalType.LIST, new GroupType(REPEATED, "list", new PrimitiveType(OPTIONAL, INT64, "element"))));    GroupType expected = new GroupType(REQUIRED, "topGroup", fields);    Type actual = Types.requiredGroup().requiredList().optionalElement(INT64).named("element").named("topGroup");    Assert.assertEquals(expected, actual);}
99fbf349726cb8e51f82cd410e2ed3de458502274008fecf4777baf9bcf61f18
testOptionalListWithinGroup
public void testOptionalListWithinGroup()
{    List<Type> fields = new ArrayList<Type>();    fields.add(new GroupType(OPTIONAL, "element", OriginalType.LIST, new GroupType(REPEATED, "list", new PrimitiveType(OPTIONAL, INT64, "element"))));    GroupType expected = new GroupType(REQUIRED, "topGroup", fields);    Type actual = Types.requiredGroup().optionalList().optionalElement(INT64).named("element").named("topGroup");    Assert.assertEquals(expected, actual);}
c8de84c29ad8fefca384581537136e848d4ad2ec64b2e15c8cb79a69ee9e62c6
testOptionalListWithinGroupWithReqElement
public void testOptionalListWithinGroupWithReqElement()
{    List<Type> fields = new ArrayList<Type>();    fields.add(new GroupType(OPTIONAL, "element", OriginalType.LIST, new GroupType(REPEATED, "list", new PrimitiveType(REQUIRED, INT64, "element"))));    GroupType expected = new GroupType(REQUIRED, "topGroup", fields);    Type actual = Types.requiredGroup().optionalList().requiredElement(INT64).named("element").named("topGroup");    Assert.assertEquals(expected, actual);}
f95084577dc2d620e74b7975198112b3f15f6c85ba5cc96f282c2604366983f3
testRequiredMapWithinList
public void testRequiredMapWithinList()
{    List<Type> innerFields = new ArrayList<Type>();    innerFields.add(new PrimitiveType(REQUIRED, DOUBLE, "key"));    innerFields.add(new PrimitiveType(REQUIRED, INT32, "value"));    List<Type> fields = new ArrayList<Type>();    fields.add(new GroupType(REQUIRED, "element", OriginalType.MAP, new GroupType(REPEATED, "map", innerFields)));    GroupType expected = new GroupType(OPTIONAL, "myList", OriginalType.LIST, new GroupType(REPEATED, "list", fields));    Type actual = Types.optionalList().requiredMapElement().key(DOUBLE).requiredValue(INT32).named("myList");    Assert.assertEquals(expected, actual);}
28cde5d49d878bf6ae4ee4a0953d003e4bf01eed8b9aaedc702f10af0234daaa
testOptionalMapWithinList
public void testOptionalMapWithinList()
{    List<Type> innerFields = new ArrayList<Type>();    innerFields.add(new PrimitiveType(REQUIRED, DOUBLE, "key"));    innerFields.add(new PrimitiveType(REQUIRED, INT32, "value"));    List<Type> fields = new ArrayList<Type>();    fields.add(new GroupType(OPTIONAL, "element", OriginalType.MAP, new GroupType(REPEATED, "map", innerFields)));    GroupType expected = new GroupType(OPTIONAL, "myList", OriginalType.LIST, new GroupType(REPEATED, "list", fields));    Type actual = Types.optionalList().optionalMapElement().key(DOUBLE).requiredValue(INT32).named("myList");    Assert.assertEquals(expected, actual);}
ae736d47cd21c8b7c3b4ac982942e4bd47feedbc9fc09757f6c44e356e6c855b
testTypeConstructionWithUndefinedColumnOrder
public void testTypeConstructionWithUndefinedColumnOrder()
{    PrimitiveTypeName[] types = new PrimitiveTypeName[] { BOOLEAN, INT32, INT64, INT96, FLOAT, DOUBLE, BINARY, FIXED_LEN_BYTE_ARRAY };    for (PrimitiveTypeName type : types) {        String name = type.toString() + "_";        int len = type == FIXED_LEN_BYTE_ARRAY ? 42 : 0;        PrimitiveType expected = new PrimitiveType(Repetition.OPTIONAL, type, len, name, null, null, null, ColumnOrder.undefined());        PrimitiveType built = Types.optional(type).length(len).columnOrder(ColumnOrder.undefined()).named(name);        Assert.assertEquals(expected, built);    }}
0dff8af0fcf58bfaaa1f20242d74bd694a17a5fb91eca4f6eee5efc2d713ab32
testTypeConstructionWithTypeDefinedColumnOrder
public void testTypeConstructionWithTypeDefinedColumnOrder()
{    PrimitiveTypeName[] types = new PrimitiveTypeName[] { BOOLEAN, INT32, INT64, FLOAT, DOUBLE, BINARY, FIXED_LEN_BYTE_ARRAY };    for (PrimitiveTypeName type : types) {        String name = type.toString() + "_";        int len = type == FIXED_LEN_BYTE_ARRAY ? 42 : 0;        PrimitiveType expected = new PrimitiveType(Repetition.OPTIONAL, type, len, name, null, null, null, ColumnOrder.typeDefined());        PrimitiveType built = Types.optional(type).length(len).columnOrder(ColumnOrder.typeDefined()).named(name);        Assert.assertEquals(expected, built);    }}
49746addc2bbc70020a36c8d41c2eeecf21c648013a16af2c48b7f1924c76b10
testTypeConstructionWithUnsupportedColumnOrder
public void testTypeConstructionWithUnsupportedColumnOrder()
{    assertThrows(null, IllegalArgumentException.class, (Callable<PrimitiveType>) () -> Types.optional(INT96).columnOrder(ColumnOrder.typeDefined()).named("int96_unsupported"));    assertThrows(null, IllegalArgumentException.class, (Callable<PrimitiveType>) () -> Types.optional(FIXED_LEN_BYTE_ARRAY).length(12).as(INTERVAL).columnOrder(ColumnOrder.typeDefined()).named("interval_unsupported"));}
78cb8a25a1dd5da4b0b2e4ff6d6400a5df45c492dcf9ddb36869b55284f929a6
testDecimalLogicalType
public void testDecimalLogicalType()
{    PrimitiveType expected = new PrimitiveType(REQUIRED, BINARY, "aDecimal", LogicalTypeAnnotation.decimalType(3, 4));    PrimitiveType actual = Types.required(BINARY).as(LogicalTypeAnnotation.decimalType(3, 4)).named("aDecimal");    Assert.assertEquals(expected, actual);}
51d44e93e28042851339948b94e66554e2e4d81955a4bc2b154d6bb822313cf6
testDecimalLogicalTypeWithDeprecatedScale
public void testDecimalLogicalTypeWithDeprecatedScale()
{    PrimitiveType expected = new PrimitiveType(REQUIRED, BINARY, "aDecimal", LogicalTypeAnnotation.decimalType(3, 4));    PrimitiveType actual = Types.required(BINARY).as(LogicalTypeAnnotation.decimalType(3, 4)).scale(3).named("aDecimal");    Assert.assertEquals(expected, actual);}
ef98bff72d10f69acff817c263474ce21ff4b778775ba611068323c681a902da
testDecimalLogicalTypeWithDeprecatedPrecision
public void testDecimalLogicalTypeWithDeprecatedPrecision()
{    PrimitiveType expected = new PrimitiveType(REQUIRED, BINARY, "aDecimal", LogicalTypeAnnotation.decimalType(3, 4));    PrimitiveType actual = Types.required(BINARY).as(LogicalTypeAnnotation.decimalType(3, 4)).precision(4).named("aDecimal");    Assert.assertEquals(expected, actual);}
6ba925bc81588e8f85b573641961d55d0fdd5e20392110afb16bef8b2d2624fc
testTimestampLogicalTypeWithUTCParameter
public void testTimestampLogicalTypeWithUTCParameter()
{    PrimitiveType utcMillisExpected = new PrimitiveType(REQUIRED, INT64, "aTimestamp", timestampType(true, MILLIS));    PrimitiveType nonUtcMillisExpected = new PrimitiveType(REQUIRED, INT64, "aTimestamp", timestampType(false, MILLIS));    PrimitiveType utcMicrosExpected = new PrimitiveType(REQUIRED, INT64, "aTimestamp", timestampType(true, MICROS));    PrimitiveType nonUtcMicrosExpected = new PrimitiveType(REQUIRED, INT64, "aTimestamp", timestampType(false, MICROS));    PrimitiveType utcMillisActual = Types.required(INT64).as(timestampType(true, MILLIS)).named("aTimestamp");    PrimitiveType nonUtcMillisActual = Types.required(INT64).as(timestampType(false, MILLIS)).named("aTimestamp");    PrimitiveType utcMicrosActual = Types.required(INT64).as(timestampType(true, MICROS)).named("aTimestamp");    PrimitiveType nonUtcMicrosActual = Types.required(INT64).as(timestampType(false, MICROS)).named("aTimestamp");    Assert.assertEquals(utcMillisExpected, utcMillisActual);    Assert.assertEquals(nonUtcMillisExpected, nonUtcMillisActual);    Assert.assertEquals(utcMicrosExpected, utcMicrosActual);    Assert.assertEquals(nonUtcMicrosExpected, nonUtcMicrosActual);}
b652021af0c3793cc0ece4b590a76f78d25ad8c3eafeb245e8e2bfac814775e0
testDecimalLogicalTypeWithDeprecatedScaleMismatch
public void testDecimalLogicalTypeWithDeprecatedScaleMismatch()
{    Types.required(BINARY).as(LogicalTypeAnnotation.decimalType(3, 4)).scale(4).named("aDecimal");}
adf99fd9ef5ec440ae4ea42b08cd048abe83494be42963232b358d391c535b7d
testDecimalLogicalTypeWithDeprecatedPrecisionMismatch
public void testDecimalLogicalTypeWithDeprecatedPrecisionMismatch()
{    Types.required(BINARY).as(LogicalTypeAnnotation.decimalType(3, 4)).precision(5).named("aDecimal");}
d54ae37b15047137d77db38fa1b84620ac079ebc22c52523675be58707583c68
assertThrows
public static void assertThrows(String message, Class<? extends Exception> expected, Callable callable)
{    try {        callable.call();        Assert.fail("No exception was thrown (" + message + "), expected: " + expected.getName());    } catch (Exception actual) {        Assert.assertEquals(message, expected, actual.getClass());    }}
1b4aceebe934a1682028da448ea859d5de424c803184df41ea8c3301f46d392f
testGroupTypeConstruction
public void testGroupTypeConstruction()
{    PrimitiveType f1 = Types.required(BINARY).as(stringType()).named("f1");    PrimitiveType f2 = Types.required(INT32).named("f2");    PrimitiveType f3 = Types.optional(INT32).named("f3");    String name = "group";    for (Repetition repetition : Repetition.values()) {        GroupType expected = new GroupType(repetition, name, f1, new GroupType(repetition, "g1", f2, f3));        GroupType built = Types.buildGroup(repetition).addField(f1).group(repetition).addFields(f2, f3).named("g1").named(name);        Assert.assertEquals(expected, built);        switch(repetition) {            case REQUIRED:                built = Types.requiredGroup().addField(f1).requiredGroup().addFields(f2, f3).named("g1").named(name);                break;            case OPTIONAL:                built = Types.optionalGroup().addField(f1).optionalGroup().addFields(f2, f3).named("g1").named(name);                break;            case REPEATED:                built = Types.repeatedGroup().addField(f1).repeatedGroup().addFields(f2, f3).named("g1").named(name);                break;        }        Assert.assertEquals(expected, built);    }}
bb15256b7eaa9e8ea1f3ac36d6afd1d08bc029330291b75504aff27861a3ba20
testDecimalAnnotation
public void testDecimalAnnotation()
{        MessageType expected = new MessageType("DecimalMessage", new PrimitiveType(REQUIRED, INT32, 0, "aDecimal", decimalType(2, 9), null));    MessageType builderType = Types.buildMessage().required(INT32).as(decimalType(2, 9)).named("aDecimal").named("DecimalMessage");    Assert.assertEquals(expected, builderType);        expected = new MessageType("DecimalMessage", new PrimitiveType(REQUIRED, INT64, 0, "aDecimal", decimalType(2, 18), null));    builderType = Types.buildMessage().required(INT64).as(decimalType(2, 18)).precision(18).scale(2).named("aDecimal").named("DecimalMessage");    Assert.assertEquals(expected, builderType);        expected = new MessageType("DecimalMessage", new PrimitiveType(REQUIRED, BINARY, 0, "aDecimal", decimalType(2, 9), null));    builderType = Types.buildMessage().required(BINARY).as(decimalType(2, 9)).named("aDecimal").named("DecimalMessage");    Assert.assertEquals(expected, builderType);        expected = new MessageType("DecimalMessage", new PrimitiveType(REQUIRED, FIXED_LEN_BYTE_ARRAY, 4, "aDecimal", decimalType(2, 9), null));    builderType = Types.buildMessage().required(FIXED_LEN_BYTE_ARRAY).length(4).as(decimalType(2, 9)).named("aDecimal").named("DecimalMessage");    Assert.assertEquals(expected, builderType);}
8bb094e1bc7f8eefe5e144fcc8408ecbd584b2992b8e4415f9100c9ece323869
testDecimalAnnotationPrecisionScaleBound
public void testDecimalAnnotationPrecisionScaleBound()
{    assertThrows("Should reject scale greater than precision", IllegalArgumentException.class, () -> Types.buildMessage().required(INT32).as(decimalType(4, 3)).named("aDecimal").named("DecimalMessage"));    assertThrows("Should reject scale greater than precision", IllegalArgumentException.class, () -> Types.buildMessage().required(INT64).as(decimalType(4, 3)).named("aDecimal").named("DecimalMessage"));    assertThrows("Should reject scale greater than precision", IllegalArgumentException.class, () -> Types.buildMessage().required(BINARY).as(decimalType(4, 3)).named("aDecimal").named("DecimalMessage"));    assertThrows("Should reject scale greater than precision", IllegalArgumentException.class, () -> Types.buildMessage().required(FIXED_LEN_BYTE_ARRAY).length(7).as(decimalType(4, 3)).named("aDecimal").named("DecimalMessage"));}
c3f32a63ed3984b99a917400e73eeddc3eb7bc5b2ab008f276d6f716eb486312
testDecimalAnnotationLengthCheck
public void testDecimalAnnotationLengthCheck()
{        assertThrows("should reject precision 10 with length 4", IllegalStateException.class, () -> Types.required(FIXED_LEN_BYTE_ARRAY).length(4).as(decimalType(2, 10)).named("aDecimal"));    assertThrows("should reject precision 10 with length 4", IllegalStateException.class, () -> Types.required(INT32).as(decimalType(2, 10)).named("aDecimal"));        assertThrows("should reject precision 19 with length 8", IllegalStateException.class, () -> Types.required(FIXED_LEN_BYTE_ARRAY).length(8).as(decimalType(4, 19)).named("aDecimal"));    assertThrows("should reject precision 19 with length 8", IllegalStateException.class, () -> Types.required(INT64).length(8).as(decimalType(4, 19)).named("aDecimal"));}
707b14ce29d553cc89d7ee4997f4c026965ac79aad6ee97099251effb32ce3a5
testDECIMALAnnotationRejectsUnsupportedTypes
public void testDECIMALAnnotationRejectsUnsupportedTypes()
{    PrimitiveTypeName[] unsupported = new PrimitiveTypeName[] { BOOLEAN, INT96, DOUBLE, FLOAT };    for (final PrimitiveTypeName type : unsupported) {        assertThrows("Should reject non-binary type: " + type, IllegalStateException.class, () -> Types.required(type).as(decimalType(2, 9)).named("d"));    }}
48af8d2d970d112261a017be711aebc75370cd46e1dc38d1f28ffcdc6c78cbb6
testBinaryAnnotations
public void testBinaryAnnotations()
{    LogicalTypeAnnotation[] types = new LogicalTypeAnnotation[] { stringType(), jsonType(), bsonType() };    for (final LogicalTypeAnnotation logicalType : types) {        PrimitiveType expected = new PrimitiveType(REQUIRED, BINARY, "col", logicalType);        PrimitiveType string = Types.required(BINARY).as(logicalType).named("col");        Assert.assertEquals(expected, string);    }}
6cea87e1f862985436ebb30fe726885f263495036d669c8a4b29fe57aac6ff2b
testBinaryAnnotationsRejectsNonBinary
public void testBinaryAnnotationsRejectsNonBinary()
{    LogicalTypeAnnotation[] types = new LogicalTypeAnnotation[] { stringType(), jsonType(), bsonType() };    for (final LogicalTypeAnnotation logicalType : types) {        PrimitiveTypeName[] nonBinary = new PrimitiveTypeName[] { BOOLEAN, INT32, INT64, INT96, DOUBLE, FLOAT };        for (final PrimitiveTypeName type : nonBinary) {            assertThrows("Should reject non-binary type: " + type, IllegalStateException.class, () -> Types.required(type).as(logicalType).named("col"));        }        assertThrows("Should reject non-binary type: FIXED_LEN_BYTE_ARRAY", IllegalStateException.class, () -> Types.required(FIXED_LEN_BYTE_ARRAY).length(1).as(logicalType).named("col"));    }}
6d5c1c9a308fd3b26012ca10da65da8b2a74f13f0eb8ca7420356e3a7c96e181
testInt32Annotations
public void testInt32Annotations()
{    LogicalTypeAnnotation[] types = new LogicalTypeAnnotation[] { dateType(), timeType(true, MILLIS), timeType(false, MILLIS), intType(8, false), intType(16, false), intType(32, false), intType(8, true), intType(16, true), intType(32, true) };    for (LogicalTypeAnnotation logicalType : types) {        PrimitiveType expected = new PrimitiveType(REQUIRED, INT32, "col", logicalType);        PrimitiveType date = Types.required(INT32).as(logicalType).named("col");        Assert.assertEquals(expected, date);    }}
1a5c98d9ab5a9ff1be3cd2495cff79454572aae17f179e36cf40e8e6c8b9f41f
testInt32AnnotationsRejectNonInt32
public void testInt32AnnotationsRejectNonInt32()
{    LogicalTypeAnnotation[] types = new LogicalTypeAnnotation[] { dateType(), timeType(true, MILLIS), timeType(false, MILLIS), intType(8, false), intType(16, false), intType(32, false), intType(8, true), intType(16, true), intType(32, true) };    for (final LogicalTypeAnnotation logicalType : types) {        PrimitiveTypeName[] nonInt32 = new PrimitiveTypeName[] { BOOLEAN, INT64, INT96, DOUBLE, FLOAT, BINARY };        for (final PrimitiveTypeName type : nonInt32) {            assertThrows("Should reject non-int32 type: " + type, IllegalStateException.class, () -> Types.required(type).as(logicalType).named("col"));        }        assertThrows("Should reject non-int32 type: FIXED_LEN_BYTE_ARRAY", IllegalStateException.class, () -> Types.required(FIXED_LEN_BYTE_ARRAY).length(1).as(logicalType).named("col"));    }}
5012f2447715f518a17392e19b87390af36e30b445142bdb4c6e4edc19ce94d9
testInt64Annotations
public void testInt64Annotations()
{    LogicalTypeAnnotation[] types = new LogicalTypeAnnotation[] { timeType(true, MICROS), timeType(false, MICROS), timeType(true, NANOS), timeType(false, NANOS), timestampType(true, MILLIS), timestampType(false, MILLIS), timestampType(true, MICROS), timestampType(false, MICROS), timestampType(true, NANOS), timestampType(false, NANOS), intType(64, true), intType(64, false) };    for (LogicalTypeAnnotation logicalType : types) {        PrimitiveType expected = new PrimitiveType(REQUIRED, INT64, "col", logicalType);        PrimitiveType date = Types.required(INT64).as(logicalType).named("col");        Assert.assertEquals(expected, date);    }}
f935bf289b5cc050d7afea6b41fb640ae7067c3a95a1f7a933cc9527923e91bc
testInt64AnnotationsRejectNonInt64
public void testInt64AnnotationsRejectNonInt64()
{    LogicalTypeAnnotation[] types = new LogicalTypeAnnotation[] { timeType(true, MICROS), timeType(false, MICROS), timeType(true, NANOS), timeType(false, NANOS), timestampType(true, MILLIS), timestampType(false, MILLIS), timestampType(true, MICROS), timestampType(false, MICROS), timestampType(true, NANOS), timestampType(false, NANOS), intType(64, true), intType(64, false) };    for (final LogicalTypeAnnotation logicalType : types) {        PrimitiveTypeName[] nonInt64 = new PrimitiveTypeName[] { BOOLEAN, INT32, INT96, DOUBLE, FLOAT, BINARY };        for (final PrimitiveTypeName type : nonInt64) {            assertThrows("Should reject non-int64 type: " + type, IllegalStateException.class, (Callable<Type>) () -> Types.required(type).as(logicalType).named("col"));        }        assertThrows("Should reject non-int64 type: FIXED_LEN_BYTE_ARRAY", IllegalStateException.class, (Callable<Type>) () -> Types.required(FIXED_LEN_BYTE_ARRAY).length(1).as(logicalType).named("col"));    }}
d6d5de8177e68f5335fae3f08d2a7c0fb4ad5d45f0288ebc3b9dfad516d64b48
testIntervalAnnotationRejectsNonFixed
public void testIntervalAnnotationRejectsNonFixed()
{    PrimitiveTypeName[] nonFixed = new PrimitiveTypeName[] { BOOLEAN, INT32, INT64, INT96, DOUBLE, FLOAT, BINARY };    for (final PrimitiveTypeName type : nonFixed) {        assertThrows("Should reject non-fixed type: " + type, IllegalStateException.class, () -> Types.required(type).as(LogicalTypeAnnotation.IntervalLogicalTypeAnnotation.getInstance()).named("interval"));    }}
bc7118bb47f597a3c460c8c5481db7ef6c74f6cc999300097078d31444af5daf
testIntervalAnnotationRejectsNonFixed12
public void testIntervalAnnotationRejectsNonFixed12()
{    assertThrows("Should reject fixed with length != 12: " + 11, IllegalStateException.class, () -> Types.required(FIXED_LEN_BYTE_ARRAY).length(11).as(LogicalTypeAnnotation.IntervalLogicalTypeAnnotation.getInstance()).named("interval"));}
49746addc2bbc70020a36c8d41c2eeecf21c648013a16af2c48b7f1924c76b10
testTypeConstructionWithUnsupportedColumnOrder
public void testTypeConstructionWithUnsupportedColumnOrder()
{    assertThrows(null, IllegalArgumentException.class, () -> Types.optional(INT96).columnOrder(ColumnOrder.typeDefined()).named("int96_unsupported"));    assertThrows(null, IllegalArgumentException.class, () -> Types.optional(PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY).length(12).as(LogicalTypeAnnotation.IntervalLogicalTypeAnnotation.getInstance()).columnOrder(ColumnOrder.typeDefined()).named("interval_unsupported"));}
78cb8a25a1dd5da4b0b2e4ff6d6400a5df45c492dcf9ddb36869b55284f929a6
testDecimalLogicalType
public void testDecimalLogicalType()
{    PrimitiveType expected = new PrimitiveType(REQUIRED, BINARY, "aDecimal", LogicalTypeAnnotation.decimalType(3, 4));    PrimitiveType actual = Types.required(BINARY).as(LogicalTypeAnnotation.decimalType(3, 4)).named("aDecimal");    Assert.assertEquals(expected, actual);}
51d44e93e28042851339948b94e66554e2e4d81955a4bc2b154d6bb822313cf6
testDecimalLogicalTypeWithDeprecatedScale
public void testDecimalLogicalTypeWithDeprecatedScale()
{    PrimitiveType expected = new PrimitiveType(REQUIRED, BINARY, "aDecimal", LogicalTypeAnnotation.decimalType(3, 4));    PrimitiveType actual = Types.required(BINARY).as(LogicalTypeAnnotation.decimalType(3, 4)).scale(3).named("aDecimal");    Assert.assertEquals(expected, actual);}
ef98bff72d10f69acff817c263474ce21ff4b778775ba611068323c681a902da
testDecimalLogicalTypeWithDeprecatedPrecision
public void testDecimalLogicalTypeWithDeprecatedPrecision()
{    PrimitiveType expected = new PrimitiveType(REQUIRED, BINARY, "aDecimal", LogicalTypeAnnotation.decimalType(3, 4));    PrimitiveType actual = Types.required(BINARY).as(LogicalTypeAnnotation.decimalType(3, 4)).precision(4).named("aDecimal");    Assert.assertEquals(expected, actual);}
6ba925bc81588e8f85b573641961d55d0fdd5e20392110afb16bef8b2d2624fc
testTimestampLogicalTypeWithUTCParameter
public void testTimestampLogicalTypeWithUTCParameter()
{    PrimitiveType utcMillisExpected = new PrimitiveType(REQUIRED, INT64, "aTimestamp", timestampType(true, MILLIS));    PrimitiveType nonUtcMillisExpected = new PrimitiveType(REQUIRED, INT64, "aTimestamp", timestampType(false, MILLIS));    PrimitiveType utcMicrosExpected = new PrimitiveType(REQUIRED, INT64, "aTimestamp", timestampType(true, MICROS));    PrimitiveType nonUtcMicrosExpected = new PrimitiveType(REQUIRED, INT64, "aTimestamp", timestampType(false, MICROS));    PrimitiveType utcMillisActual = Types.required(INT64).as(timestampType(true, MILLIS)).named("aTimestamp");    PrimitiveType nonUtcMillisActual = Types.required(INT64).as(timestampType(false, MILLIS)).named("aTimestamp");    PrimitiveType utcMicrosActual = Types.required(INT64).as(timestampType(true, MICROS)).named("aTimestamp");    PrimitiveType nonUtcMicrosActual = Types.required(INT64).as(timestampType(false, MICROS)).named("aTimestamp");    Assert.assertEquals(utcMillisExpected, utcMillisActual);    Assert.assertEquals(nonUtcMillisExpected, nonUtcMillisActual);    Assert.assertEquals(utcMicrosExpected, utcMicrosActual);    Assert.assertEquals(nonUtcMicrosExpected, nonUtcMicrosActual);}
b652021af0c3793cc0ece4b590a76f78d25ad8c3eafeb245e8e2bfac814775e0
testDecimalLogicalTypeWithDeprecatedScaleMismatch
public void testDecimalLogicalTypeWithDeprecatedScaleMismatch()
{    Types.required(BINARY).as(LogicalTypeAnnotation.decimalType(3, 4)).scale(4).named("aDecimal");}
adf99fd9ef5ec440ae4ea42b08cd048abe83494be42963232b358d391c535b7d
testDecimalLogicalTypeWithDeprecatedPrecisionMismatch
public void testDecimalLogicalTypeWithDeprecatedPrecisionMismatch()
{    Types.required(BINARY).as(LogicalTypeAnnotation.decimalType(3, 4)).precision(5).named("aDecimal");}
d54ae37b15047137d77db38fa1b84620ac079ebc22c52523675be58707583c68
assertThrows
public static void assertThrows(String message, Class<? extends Exception> expected, Callable callable)
{    try {        callable.call();        Assert.fail("No exception was thrown (" + message + "), expected: " + expected.getName());    } catch (Exception actual) {        Assert.assertEquals(message, expected, actual.getClass());    }}
6f69086ddf7ca30625bfdcdde646b44ba9d2c9b9b829f66682fe93551adfbed4
testWriteCheckMessageType
public void testWriteCheckMessageType()
{    TypeUtil.checkValidWriteSchema(Types.buildMessage().required(INT32).named("a").optional(BINARY).as(UTF8).named("b").named("valid_schema"));    TestTypeBuilders.assertThrows("Should complain about empty MessageType", InvalidSchemaException.class, (Callable<Void>) () -> {        TypeUtil.checkValidWriteSchema(new MessageType("invalid_schema"));        return null;    });}
44b428d792b8237bb922afacf5f459780c1661327eb7a7e3d8e30e88e69e8af8
testWriteCheckGroupType
public void testWriteCheckGroupType()
{    TypeUtil.checkValidWriteSchema(Types.repeatedGroup().required(INT32).named("a").optional(BINARY).as(UTF8).named("b").named("valid_group"));    TestTypeBuilders.assertThrows("Should complain about empty GroupType", InvalidSchemaException.class, (Callable<Void>) () -> {        TypeUtil.checkValidWriteSchema(new GroupType(REPEATED, "invalid_group"));        return null;    });}
f02e0b66034e9d1ced7a98463e34029d2ace92d4fb7b67cf10036dd89d49e782
testWriteCheckNestedGroupType
public void testWriteCheckNestedGroupType()
{    TypeUtil.checkValidWriteSchema(Types.buildMessage().repeatedGroup().required(INT32).named("a").optional(BINARY).as(UTF8).named("b").named("valid_group").named("valid_message"));    TestTypeBuilders.assertThrows("Should complain about empty GroupType", InvalidSchemaException.class, (Callable<Void>) () -> {        TypeUtil.checkValidWriteSchema(Types.buildMessage().addField(new GroupType(REPEATED, "invalid_group")).named("invalid_message"));        return null;    });}
552f47c4eeb1300699930171d67c3ff4e9f37feef71441829efab1b8ff6db3e2
wrap
public static ByteBufferInputStream wrap(ByteBuffer... buffers)
{    if (buffers.length == 1) {        return new SingleBufferInputStream(buffers[0]);    } else {        return new MultiBufferInputStream(Arrays.asList(buffers));    }}
4954c3aa6315427f5dfbfc94f64a6e2ccbc486c33cd7b20174827ddc3ec6f901
wrap
public static ByteBufferInputStream wrap(List<ByteBuffer> buffers)
{    if (buffers.size() == 1) {        return new SingleBufferInputStream(buffers.get(0));    } else {        return new MultiBufferInputStream(buffers);    }}
ead687f9007d16fe8de2c376f5517d30f8d6937095c5cc7805e37f274364bba4
toByteBuffer
public ByteBuffer toByteBuffer()
{    try {        return slice(available());    } catch (EOFException e) {        throw new ShouldNeverHappenException(e);    }}
64a3ee0922b6f03ba972a38aa52a0e1866d9bbcb6c04662c3cec03bc5a001fe5
position
public long position()
{    return delegate.position();}
7d33380b7db52cb7ce1f09dbc0ac3dd7353103f2ae5b19d0c72d0e0893a45484
skipFully
public void skipFully(long n) throws IOException
{    long skipped = skip(n);    if (skipped < n) {        throw new EOFException("Not enough bytes to skip: " + skipped + " < " + n);    }}
42bd96fea83f8535b30f7a1d4be2135983b6e18fdf7e21a7d0e8e80d3f00fd2a
read
public int read(ByteBuffer out)
{    return delegate.read(out);}
5785a49ae8e405148b93815746be6f3c1a41c0b1c6c323bde1d83dfd2e3ff7c8
slice
public ByteBuffer slice(int length) throws EOFException
{    return delegate.slice(length);}
12b9ca0cadb57f2c0cdd23eb0b019260c635488af0b52b8c83d85d62226be35b
sliceBuffers
public List<ByteBuffer> sliceBuffers(long length) throws EOFException
{    return delegate.sliceBuffers(length);}
c46ae8673f3833b449ec6aaa1a5cffbbe2d0b83359bdf89399ac25a16d69eecd
sliceStream
public ByteBufferInputStream sliceStream(long length) throws EOFException
{    return ByteBufferInputStream.wrap(sliceBuffers(length));}
edc020f04ff1582ce013d9c123709d4cb3c2475b5656800f92a706bc95edb293
remainingBuffers
public List<ByteBuffer> remainingBuffers()
{    return delegate.remainingBuffers();}
eaa581f7f67b2dc688db11b7fb4de93c3754f6f126f05cf8e58ab33ec52d551f
remainingStream
public ByteBufferInputStream remainingStream()
{    return ByteBufferInputStream.wrap(remainingBuffers());}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    return delegate.read();}
56e08d87e6bd0be2a60f9b2de3195d58bc9d56a2637f6fed6210d21e832632ea
read
public int read(byte[] b, int off, int len) throws IOException
{    return delegate.read(b, off, len);}
7c19bd84924ea3cd1314ee9059df92a2c49b00d5d8e3580697d2f75a289ebca3
skip
public long skip(long n)
{    return delegate.skip(n);}
7abd61fd851f87b95935f20a9acee256b4b0722e248a8c94a1a5ed2f46622abd
available
public int available()
{    return delegate.available();}
7cc921b4ff6dbc30866ab49e9ef2a88f2538680c6450f60e1fcc7989cfa03402
mark
public void mark(int readlimit)
{    delegate.mark(readlimit);}
39fd2a669bd97a959085d10145da4dcd11d83878afcd67b2123354de7e8771d9
reset
public void reset() throws IOException
{    delegate.reset();}
23a63ca46da6513daeb255dee9f0a6e74737bbe34c04911d002213961e2f7cc9
markSupported
public boolean markSupported()
{    return delegate.markSupported();}
7f13382ec77d4864031b1b5022360fd7737241f0c621df0f09e58b8e54f029fb
concat
public static BytesInput concat(BytesInput... inputs)
{    return new SequenceBytesIn(Arrays.asList(inputs));}
b6ae37d508ff9dc06a914e3aae161f5774db15878b74eab827af77a0c62784f1
concat
public static BytesInput concat(List<BytesInput> inputs)
{    return new SequenceBytesIn(inputs);}
5446cdc73b375706fa899b59a4aa0c43a40108859e9ebdcf218fbc9a696838f7
from
public static BytesInput from(InputStream in, int bytes)
{    return new StreamBytesInput(in, bytes);}
228d957aa66d842f5c4358bb14b5f38b9a67a725891bbc9fc82e88b9b9793493
from
public static BytesInput from(ByteBuffer buffer, int offset, int length)
{    ByteBuffer tmp = buffer.duplicate();    tmp.position(offset);    ByteBuffer slice = tmp.slice();    slice.limit(length);    return new ByteBufferBytesInput(slice);}
ac75892963ec37b338c179af46f56f16d6ac3810ac03f34f3a6e0791c2777283
from
public static BytesInput from(ByteBuffer... buffers)
{    if (buffers.length == 1) {        return new ByteBufferBytesInput(buffers[0]);    }    return new BufferListBytesInput(Arrays.asList(buffers));}
0c13b49a5e6723316cf601376229b584aae343c4fbe6fb2774d966174a15ae02
from
public static BytesInput from(List<ByteBuffer> buffers)
{    if (buffers.size() == 1) {        return new ByteBufferBytesInput(buffers.get(0));    }    return new BufferListBytesInput(buffers);}
0a34cb24be2a58206b649e084c99b1ab945dc048f6aa5597940ff8abc860d19e
from
public static BytesInput from(byte[] in)
{    LOG.debug("BytesInput from array of {} bytes", in.length);    return new ByteArrayBytesInput(in, 0, in.length);}
9c7c9a343e6ecc7c1de0ea4db81b6eaccffe40257cdfe2025e90d5a7420b2d85
from
public static BytesInput from(byte[] in, int offset, int length)
{    LOG.debug("BytesInput from array of {} bytes", length);    return new ByteArrayBytesInput(in, offset, length);}
cee203719f063b17664a3c5acd4140ddc25acc359f451888b1a96f42f9a9d126
fromInt
public static BytesInput fromInt(int intValue)
{    return new IntBytesInput(intValue);}
ad6ac46b53f6518bdeb9db1fed5f6d5e6b17a8a597965ef781a5ba3a6ea26efb
fromUnsignedVarInt
public static BytesInput fromUnsignedVarInt(int intValue)
{    return new UnsignedVarIntBytesInput(intValue);}
3f5f7f5976acbede45adc1cf45fbe75cf9f09f8c7b5d4584856b9c17a0f5cff0
fromZigZagVarInt
public static BytesInput fromZigZagVarInt(int intValue)
{    int zigZag = (intValue << 1) ^ (intValue >> 31);    return new UnsignedVarIntBytesInput(zigZag);}
5cf8e1ae3213a0ea4a7cef0c55a5a42c4eb86dafbd0878be3efa4e7a5a4c0de2
fromUnsignedVarLong
public static BytesInput fromUnsignedVarLong(long longValue)
{    return new UnsignedVarLongBytesInput(longValue);}
ca028b9dad8fce1d327d2f0f8b3d58af15094408a29222d8cf8c16c3d8663690
fromZigZagVarLong
public static BytesInput fromZigZagVarLong(long longValue)
{    long zigZag = (longValue << 1) ^ (longValue >> 63);    return new UnsignedVarLongBytesInput(zigZag);}
3d1a89b425e9e3e790023079bcc83f698ae54148c852621ad895e3751cc8f9b9
from
public static BytesInput from(CapacityByteArrayOutputStream arrayOut)
{    return new CapacityBAOSBytesInput(arrayOut);}
a36679da12a02e7e49e7aab9692faddc90335ca63abdebcd6083877eed0059cf
from
public static BytesInput from(ByteArrayOutputStream baos)
{    return new BAOSBytesInput(baos);}
fce0fa990886035534d5271049a6541f75ee722960027aceb800a70ce49e9c98
empty
public static BytesInput empty()
{    return EMPTY_BYTES_INPUT;}
72190e9cfb7a380e2178af061db131ab3e5f267b470959899ff1cc687c6a4a08
copy
public static BytesInput copy(BytesInput bytesInput) throws IOException
{    return from(bytesInput.toByteArray());}
8ab41e80c5d7223badec15de7c1ac29dffe5bb2a0892ab399cb244b98a4b3fcd
toByteArray
public byte[] toByteArray() throws IOException
{    BAOS baos = new BAOS((int) size());    this.writeAllTo(baos);    LOG.debug("converted {} to byteArray of {} bytes", size(), baos.size());    return baos.getBuf();}
1873cae200088b1796bcc9ddb74631095175c8a14c3e77fceb16ba07ca23a130
toByteBuffer
public ByteBuffer toByteBuffer() throws IOException
{    return ByteBuffer.wrap(toByteArray());}
0994772d1d7556ae52e051bf97c5f3d8ca88cf66a16276216b02d939d776c414
toInputStream
public ByteBufferInputStream toInputStream() throws IOException
{    return ByteBufferInputStream.wrap(toByteBuffer());}
2a1ae5da33cf18200974c12c02ccd63851b11dfc6a63d19fed8f8194ddc8bc90
getBuf
public byte[] getBuf()
{    return this.buf;}
b31ecdd27ff00947523b9706e1e03cfb020f32ce038e16f8e9a8d2c9fc142aaf
writeAllTo
public void writeAllTo(OutputStream out) throws IOException
{    LOG.debug("write All {} bytes", byteCount);        out.write(this.toByteArray());}
8ab41e80c5d7223badec15de7c1ac29dffe5bb2a0892ab399cb244b98a4b3fcd
toByteArray
public byte[] toByteArray() throws IOException
{    LOG.debug("read all {} bytes", byteCount);    byte[] buf = new byte[byteCount];    new DataInputStream(in).readFully(buf);    return buf;}
cfb41f73e412eba54585b19c4db25a324ab3cdbbceb33179d6832934541179a0
size
public long size()
{    return byteCount;}
b31ecdd27ff00947523b9706e1e03cfb020f32ce038e16f8e9a8d2c9fc142aaf
writeAllTo
public void writeAllTo(OutputStream out) throws IOException
{    for (BytesInput input : inputs) {        LOG.debug("write {} bytes to out", input.size());        if (input instanceof SequenceBytesIn)            LOG.debug("{");        input.writeAllTo(out);        if (input instanceof SequenceBytesIn)            LOG.debug("}");    }}
cfb41f73e412eba54585b19c4db25a324ab3cdbbceb33179d6832934541179a0
size
public long size()
{    return size;}
b31ecdd27ff00947523b9706e1e03cfb020f32ce038e16f8e9a8d2c9fc142aaf
writeAllTo
public void writeAllTo(OutputStream out) throws IOException
{    BytesUtils.writeIntLittleEndian(out, intValue);}
1873cae200088b1796bcc9ddb74631095175c8a14c3e77fceb16ba07ca23a130
toByteBuffer
public ByteBuffer toByteBuffer() throws IOException
{    return ByteBuffer.allocate(4).putInt(0, intValue);}
cfb41f73e412eba54585b19c4db25a324ab3cdbbceb33179d6832934541179a0
size
public long size()
{    return 4;}
b31ecdd27ff00947523b9706e1e03cfb020f32ce038e16f8e9a8d2c9fc142aaf
writeAllTo
public void writeAllTo(OutputStream out) throws IOException
{    BytesUtils.writeUnsignedVarInt(intValue, out);}
1873cae200088b1796bcc9ddb74631095175c8a14c3e77fceb16ba07ca23a130
toByteBuffer
public ByteBuffer toByteBuffer() throws IOException
{    ByteBuffer ret = ByteBuffer.allocate((int) size());    BytesUtils.writeUnsignedVarInt(intValue, ret);    return ret;}
cfb41f73e412eba54585b19c4db25a324ab3cdbbceb33179d6832934541179a0
size
public long size()
{    int s = (38 - Integer.numberOfLeadingZeros(intValue)) / 7;    return s == 0 ? 1 : s;}
b31ecdd27ff00947523b9706e1e03cfb020f32ce038e16f8e9a8d2c9fc142aaf
writeAllTo
public void writeAllTo(OutputStream out) throws IOException
{    BytesUtils.writeUnsignedVarLong(longValue, out);}
cfb41f73e412eba54585b19c4db25a324ab3cdbbceb33179d6832934541179a0
size
public long size()
{    int s = (70 - Long.numberOfLeadingZeros(longValue)) / 7;    return s == 0 ? 1 : s;}
b31ecdd27ff00947523b9706e1e03cfb020f32ce038e16f8e9a8d2c9fc142aaf
writeAllTo
public void writeAllTo(OutputStream out) throws IOException
{}
cfb41f73e412eba54585b19c4db25a324ab3cdbbceb33179d6832934541179a0
size
public long size()
{    return 0;}
1873cae200088b1796bcc9ddb74631095175c8a14c3e77fceb16ba07ca23a130
toByteBuffer
public ByteBuffer toByteBuffer() throws IOException
{    return ByteBuffer.allocate(0);}
b31ecdd27ff00947523b9706e1e03cfb020f32ce038e16f8e9a8d2c9fc142aaf
writeAllTo
public void writeAllTo(OutputStream out) throws IOException
{    arrayOut.writeTo(out);}
cfb41f73e412eba54585b19c4db25a324ab3cdbbceb33179d6832934541179a0
size
public long size()
{    return arrayOut.size();}
b31ecdd27ff00947523b9706e1e03cfb020f32ce038e16f8e9a8d2c9fc142aaf
writeAllTo
public void writeAllTo(OutputStream out) throws IOException
{    arrayOut.writeTo(out);}
cfb41f73e412eba54585b19c4db25a324ab3cdbbceb33179d6832934541179a0
size
public long size()
{    return arrayOut.size();}
b31ecdd27ff00947523b9706e1e03cfb020f32ce038e16f8e9a8d2c9fc142aaf
writeAllTo
public void writeAllTo(OutputStream out) throws IOException
{    out.write(in, offset, length);}
1873cae200088b1796bcc9ddb74631095175c8a14c3e77fceb16ba07ca23a130
toByteBuffer
public ByteBuffer toByteBuffer() throws IOException
{    return java.nio.ByteBuffer.wrap(in, offset, length);}
cfb41f73e412eba54585b19c4db25a324ab3cdbbceb33179d6832934541179a0
size
public long size()
{    return length;}
b31ecdd27ff00947523b9706e1e03cfb020f32ce038e16f8e9a8d2c9fc142aaf
writeAllTo
public void writeAllTo(OutputStream out) throws IOException
{    WritableByteChannel channel = Channels.newChannel(out);    for (ByteBuffer buffer : buffers) {        channel.write(buffer.duplicate());    }}
ad20d0b23a0243f8187ddfca704b59c6ff2bb30a1dd4b7b4f2ad646cb81f3a52
toInputStream
public ByteBufferInputStream toInputStream()
{    return ByteBufferInputStream.wrap(buffers);}
cfb41f73e412eba54585b19c4db25a324ab3cdbbceb33179d6832934541179a0
size
public long size()
{    return length;}
b31ecdd27ff00947523b9706e1e03cfb020f32ce038e16f8e9a8d2c9fc142aaf
writeAllTo
public void writeAllTo(OutputStream out) throws IOException
{    Channels.newChannel(out).write(buffer.duplicate());}
ad20d0b23a0243f8187ddfca704b59c6ff2bb30a1dd4b7b4f2ad646cb81f3a52
toInputStream
public ByteBufferInputStream toInputStream()
{    return ByteBufferInputStream.wrap(buffer);}
cfb41f73e412eba54585b19c4db25a324ab3cdbbceb33179d6832934541179a0
size
public long size()
{    return buffer.remaining();}
88b94c9675fa033b604b9618235417df08cc65e96672c8807ac19f9b3d73020e
getWidthFromMaxInt
public static int getWidthFromMaxInt(int bound)
{    return 32 - Integer.numberOfLeadingZeros(bound);}
167b8c8dd98f396f57c14c458df4a7f1886af82da0e279aa391fc887dffd6045
readIntLittleEndian
public static int readIntLittleEndian(ByteBuffer in, int offset) throws IOException
{    int ch4 = in.get(offset) & 0xff;    int ch3 = in.get(offset + 1) & 0xff;    int ch2 = in.get(offset + 2) & 0xff;    int ch1 = in.get(offset + 3) & 0xff;    return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));}
4fab2fd738f59d03182bbf988323a7114f969b86d58eae5506b0a8f1e5f8349c
readIntLittleEndian
public static int readIntLittleEndian(byte[] in, int offset) throws IOException
{    int ch4 = in[offset] & 0xff;    int ch3 = in[offset + 1] & 0xff;    int ch2 = in[offset + 2] & 0xff;    int ch1 = in[offset + 3] & 0xff;    return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));}
220c12a4e2fb7b427a4e23bc3a59c347ae7eb964d519fa4ddfa7c4dad13df3a2
readIntLittleEndian
public static int readIntLittleEndian(InputStream in) throws IOException
{        int ch1 = in.read();    int ch2 = in.read();    int ch3 = in.read();    int ch4 = in.read();    if ((ch1 | ch2 | ch3 | ch4) < 0) {        throw new EOFException();    }    return ((ch4 << 24) + (ch3 << 16) + (ch2 << 8) + (ch1 << 0));}
6725aba1f932317030e8d451ee34b3c0eededfcf8455d70782385fc332989125
readIntLittleEndianOnOneByte
public static int readIntLittleEndianOnOneByte(InputStream in) throws IOException
{    int ch1 = in.read();    if (ch1 < 0) {        throw new EOFException();    }    return ch1;}
9a1c695b1941b735542ddeef95288c348c8418217e3d655a535355e87b4a45a5
readIntLittleEndianOnTwoBytes
public static int readIntLittleEndianOnTwoBytes(InputStream in) throws IOException
{    int ch1 = in.read();    int ch2 = in.read();    if ((ch1 | ch2) < 0) {        throw new EOFException();    }    return ((ch2 << 8) + (ch1 << 0));}
eb51959e9c48815a76497478816a1b4ff13c4b2ad43ac9681ce5ff435d994ef6
readIntLittleEndianOnThreeBytes
public static int readIntLittleEndianOnThreeBytes(InputStream in) throws IOException
{    int ch1 = in.read();    int ch2 = in.read();    int ch3 = in.read();    if ((ch1 | ch2 | ch3) < 0) {        throw new EOFException();    }    return ((ch3 << 16) + (ch2 << 8) + (ch1 << 0));}
884cbc334d2432d111626375628b1ece2b1c36e6d9a262c224bb1ffac65da383
readIntLittleEndianPaddedOnBitWidth
public static int readIntLittleEndianPaddedOnBitWidth(InputStream in, int bitWidth) throws IOException
{    int bytesWidth = paddedByteCountFromBits(bitWidth);    switch(bytesWidth) {        case 0:            return 0;        case 1:            return BytesUtils.readIntLittleEndianOnOneByte(in);        case 2:            return BytesUtils.readIntLittleEndianOnTwoBytes(in);        case 3:            return BytesUtils.readIntLittleEndianOnThreeBytes(in);        case 4:            return BytesUtils.readIntLittleEndian(in);        default:            throw new IOException(String.format("Encountered bitWidth (%d) that requires more than 4 bytes", bitWidth));    }}
64d3073c884c8dec700b337e02f1efa0b576ee5d1b800cf3e5142c275f4e2d04
writeIntLittleEndianOnOneByte
public static void writeIntLittleEndianOnOneByte(OutputStream out, int v) throws IOException
{    out.write((v >>> 0) & 0xFF);}
c0ea37cec683308805d69caec03e6c0682e22dfca6047953e307534ff4f14543
writeIntLittleEndianOnTwoBytes
public static void writeIntLittleEndianOnTwoBytes(OutputStream out, int v) throws IOException
{    out.write((v >>> 0) & 0xFF);    out.write((v >>> 8) & 0xFF);}
4ba1906a36944bd1bdba7e8a0569d5bb8801e48bd19e3e87677258e1a3a26403
writeIntLittleEndianOnThreeBytes
public static void writeIntLittleEndianOnThreeBytes(OutputStream out, int v) throws IOException
{    out.write((v >>> 0) & 0xFF);    out.write((v >>> 8) & 0xFF);    out.write((v >>> 16) & 0xFF);}
b3e08bcf03fcdb99d044a4b8aa5120d152105e934dcf7960b53d9ea94685f0f4
writeIntLittleEndian
public static void writeIntLittleEndian(OutputStream out, int v) throws IOException
{        out.write((v >>> 0) & 0xFF);    out.write((v >>> 8) & 0xFF);    out.write((v >>> 16) & 0xFF);    out.write((v >>> 24) & 0xFF);    if (LOG.isDebugEnabled())        LOG.debug("write le int: " + v + " => " + ((v >>> 0) & 0xFF) + " " + ((v >>> 8) & 0xFF) + " " + ((v >>> 16) & 0xFF) + " " + ((v >>> 24) & 0xFF));}
bfab0e71cc98b82f4ca30b209c2a3feef017cd8ae0791c4efc9545bbfb0eb111
writeIntLittleEndianPaddedOnBitWidth
public static void writeIntLittleEndianPaddedOnBitWidth(OutputStream out, int v, int bitWidth) throws IOException
{    int bytesWidth = paddedByteCountFromBits(bitWidth);    switch(bytesWidth) {        case 0:            break;        case 1:            writeIntLittleEndianOnOneByte(out, v);            break;        case 2:            writeIntLittleEndianOnTwoBytes(out, v);            break;        case 3:            writeIntLittleEndianOnThreeBytes(out, v);            break;        case 4:            writeIntLittleEndian(out, v);            break;        default:            throw new IOException(String.format("Encountered value (%d) that requires more than 4 bytes", v));    }}
dced95c985da18f5360a01d6e06ac896fc3c0338a66ee40033a9e3f44cc6108e
readUnsignedVarInt
public static int readUnsignedVarInt(InputStream in) throws IOException
{    int value = 0;    int i = 0;    int b;    while (((b = in.read()) & 0x80) != 0) {        value |= (b & 0x7F) << i;        i += 7;    }    return value | (b << i);}
48d0784d103dbc02f7cf5c8e69c3949f8fe3ed57c8019eb1078112d88853bc66
readZigZagVarInt
public static int readZigZagVarInt(InputStream in) throws IOException
{    int raw = readUnsignedVarInt(in);    int temp = (((raw << 31) >> 31) ^ raw) >> 1;    return temp ^ (raw & (1 << 31));}
682e19a3cb75cae099b3660bb9a3593ca8cac90a2ed8e063218f350ad58090f7
writeUnsignedVarInt
public static void writeUnsignedVarInt(int value, OutputStream out) throws IOException
{    while ((value & 0xFFFFFF80) != 0L) {        out.write((value & 0x7F) | 0x80);        value >>>= 7;    }    out.write(value & 0x7F);}
1c68b77d0a88d1da1d2262b4ebc58bdfe34632c9ad57511895afc9747a6439db
writeUnsignedVarInt
public static void writeUnsignedVarInt(int value, ByteBuffer dest) throws IOException
{    while ((value & 0xFFFFFF80) != 0L) {        dest.putInt((value & 0x7F) | 0x80);        value >>>= 7;    }    dest.putInt(value & 0x7F);}
11301e3c6a6a4b0315cfba6339b1cc613a39747211e9309ee8ff2dd1014cfcd8
writeZigZagVarInt
public static void writeZigZagVarInt(int intValue, OutputStream out) throws IOException
{    writeUnsignedVarInt((intValue << 1) ^ (intValue >> 31), out);}
2d0081849a23846cc1a7912539a11335b254775b51f48fc105535a58a8aa6671
readZigZagVarLong
public static long readZigZagVarLong(InputStream in) throws IOException
{    long raw = readUnsignedVarLong(in);    long temp = (((raw << 63) >> 63) ^ raw) >> 1;    return temp ^ (raw & (1L << 63));}
33cb56c2c762217ac7b36b6826a3589a676eae5bdca988a04851e4074b73a9a4
readUnsignedVarLong
public static long readUnsignedVarLong(InputStream in) throws IOException
{    long value = 0;    int i = 0;    long b;    while (((b = in.read()) & 0x80) != 0) {        value |= (b & 0x7F) << i;        i += 7;    }    return value | (b << i);}
d9885020760589dc201c6657b69b45ad7777e8b1d785e775ce84effbd2889962
writeUnsignedVarLong
public static void writeUnsignedVarLong(long value, OutputStream out) throws IOException
{    while ((value & 0xFFFFFFFFFFFFFF80L) != 0L) {        out.write((int) ((value & 0x7F) | 0x80));        value >>>= 7;    }    out.write((int) (value & 0x7F));}
0bbbd65d047cb43f688014b60e5a1f77c0f1f26a55adffbf47bfb2ec74778a5e
writeZigZagVarLong
public static void writeZigZagVarLong(long longValue, OutputStream out) throws IOException
{    writeUnsignedVarLong((longValue << 1) ^ (longValue >> 63), out);}
9078755ca070f4a5c2b3ce6e6ad336f8f29233ce9a26009ed5ec9fe89747ffd0
paddedByteCountFromBits
public static int paddedByteCountFromBits(int bitLength)
{    return (bitLength + 7) / 8;}
eec7f427bdcc74133523a99cd0e6b6344cd370d189647126ad10107473fbd4ef
intToBytes
public static byte[] intToBytes(int value)
{    byte[] outBuffer = new byte[4];    outBuffer[3] = (byte) (value >>> 24);    outBuffer[2] = (byte) (value >>> 16);    outBuffer[1] = (byte) (value >>> 8);    outBuffer[0] = (byte) (value >>> 0);    return outBuffer;}
dcf3477c00f20b830870b314b50b93cfa5219a1f8812bf09806e404233516562
bytesToInt
public static int bytesToInt(byte[] bytes)
{    return ((int) (bytes[3] & 255) << 24) + ((int) (bytes[2] & 255) << 16) + ((int) (bytes[1] & 255) << 8) + ((int) (bytes[0] & 255) << 0);}
e02b780190590517a4a57827de05ac2bc0a9000f00ead159b0ac6b345e5e30c1
longToBytes
public static byte[] longToBytes(long value)
{    byte[] outBuffer = new byte[8];    outBuffer[7] = (byte) (value >>> 56);    outBuffer[6] = (byte) (value >>> 48);    outBuffer[5] = (byte) (value >>> 40);    outBuffer[4] = (byte) (value >>> 32);    outBuffer[3] = (byte) (value >>> 24);    outBuffer[2] = (byte) (value >>> 16);    outBuffer[1] = (byte) (value >>> 8);    outBuffer[0] = (byte) (value >>> 0);    return outBuffer;}
c26521ab5e233a547e1432e881d280a40f9eba32c251b1e729cc14ae91ff4665
bytesToLong
public static long bytesToLong(byte[] bytes)
{    return (((long) bytes[7] << 56) + ((long) (bytes[6] & 255) << 48) + ((long) (bytes[5] & 255) << 40) + ((long) (bytes[4] & 255) << 32) + ((long) (bytes[3] & 255) << 24) + ((long) (bytes[2] & 255) << 16) + ((long) (bytes[1] & 255) << 8) + ((long) (bytes[0] & 255) << 0));}
78c5afa9a2403f1f05e68b8db3733c0afaddb56eab7aa3a74caf301c03dcd8f2
booleanToBytes
public static byte[] booleanToBytes(boolean value)
{    byte[] outBuffer = new byte[1];    outBuffer[0] = (byte) (value ? 1 : 0);    return outBuffer;}
76658603465494545038b6a7cbe9342c499e81dfd36fc960616a5079eec80328
bytesToBool
public static boolean bytesToBool(byte[] bytes)
{    return ((int) (bytes[0] & 255) != 0);}
e99ebb5ebb7fdf55531dfac44c802975cbedb1afb27538a9c06aeab77ad261d5
initialSlabSizeHeuristic
public static int initialSlabSizeHeuristic(int minSlabSize, int targetCapacity, int targetNumSlabs)
{        return max(minSlabSize, ((int) (targetCapacity / pow(2, targetNumSlabs))));}
cea4b524b99a5b6b1dc277aaf28b856cd8a5980ee71fd38ebb53278620667187
withTargetNumSlabs
public static CapacityByteArrayOutputStream withTargetNumSlabs(int minSlabSize, int maxCapacityHint, int targetNumSlabs)
{    return withTargetNumSlabs(minSlabSize, maxCapacityHint, targetNumSlabs, new HeapByteBufferAllocator());}
9650995ce79704c08c057464cd711a1932945fa8a0a4fc52c318c6b7b37f9f56
withTargetNumSlabs
public static CapacityByteArrayOutputStream withTargetNumSlabs(int minSlabSize, int maxCapacityHint, int targetNumSlabs, ByteBufferAllocator allocator)
{    return new CapacityByteArrayOutputStream(initialSlabSizeHeuristic(minSlabSize, maxCapacityHint, targetNumSlabs), maxCapacityHint, allocator);}
ad4191f17911784948d0ffea45eb84e9ea839e4fdfb663dca490a7257d9d468a
addSlab
private void addSlab(int minimumSize)
{    int nextSlabSize;    if (bytesUsed == 0) {        nextSlabSize = initialSlabSize;    } else if (bytesUsed > maxCapacityHint / 5) {                nextSlabSize = maxCapacityHint / 5;    } else {                nextSlabSize = bytesUsed;    }    if (nextSlabSize < minimumSize) {        LOG.debug("slab size {} too small for value of size {}. Bumping up slab size", nextSlabSize, minimumSize);        nextSlabSize = minimumSize;    }    LOG.debug("used {} slabs, adding new slab of size {}", slabs.size(), nextSlabSize);    this.currentSlab = allocator.allocate(nextSlabSize);    this.slabs.add(currentSlab);    this.bytesAllocated += nextSlabSize;    this.currentSlabIndex = 0;}
25b35cf2ca566b5b4b14451f4ded1a3f4e745f0a14883c16b91d1495a5574ab6
write
public void write(int b)
{    if (!currentSlab.hasRemaining()) {        addSlab(1);    }    currentSlab.put(currentSlabIndex, (byte) b);    currentSlabIndex += 1;    currentSlab.position(currentSlabIndex);    bytesUsed += 1;}
ff0b219f0fb5d98769feafdb43b42bceec5beac4330d68da85f0f922f1b42b7f
write
public void write(byte[] b, int off, int len)
{    if ((off < 0) || (off > b.length) || (len < 0) || ((off + len) - b.length > 0)) {        throw new IndexOutOfBoundsException(String.format("Given byte array of size %d, with requested length(%d) and offset(%d)", b.length, len, off));    }    if (len >= currentSlab.remaining()) {        final int length1 = currentSlab.remaining();        currentSlab.put(b, off, length1);        bytesUsed += length1;        currentSlabIndex += length1;        final int length2 = len - length1;        addSlab(length2);        currentSlab.put(b, off + length1, length2);        currentSlabIndex = length2;        bytesUsed += length2;    } else {        currentSlab.put(b, off, len);        currentSlabIndex += len;        bytesUsed += len;    }}
a36a2eb5b67bf2c0214f6a8c24252818950d7594c4ec31cdbd58b3915fb0694d
writeToOutput
private void writeToOutput(OutputStream out, ByteBuffer buf, int len) throws IOException
{    if (buf.hasArray()) {        out.write(buf.array(), buf.arrayOffset(), len);    } else {                        byte[] copy = new byte[len];        buf.flip();        buf.get(copy);        out.write(copy);    }}
7dc6be4554c74a17fd17d70feb1dc3c6f61c5fa8dae9c84dbc82b8c7a8ae9a29
writeTo
public void writeTo(OutputStream out) throws IOException
{    for (int i = 0; i < slabs.size() - 1; i++) {        writeToOutput(out, slabs.get(i), slabs.get(i).position());    }    writeToOutput(out, currentSlab, currentSlabIndex);}
cfb41f73e412eba54585b19c4db25a324ab3cdbbceb33179d6832934541179a0
size
public long size()
{    return bytesUsed;}
b5a88633b1030fb86fd7f643804f6ea7ac9e8b092ca1aac528aa0781750bc032
getCapacity
public int getCapacity()
{    return bytesAllocated;}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{            this.initialSlabSize = max(bytesUsed / 7, initialSlabSize);    LOG.debug("initial slab of size {}", initialSlabSize);    for (ByteBuffer slab : slabs) {        allocator.release(slab);    }    this.slabs.clear();    this.bytesAllocated = 0;    this.bytesUsed = 0;    this.currentSlab = EMPTY_SLAB;    this.currentSlabIndex = 0;}
0f090db1caa97f3fac28f6dd7a14b6f4ee9a51fe095e6a79d9861b7146668291
getCurrentIndex
public long getCurrentIndex()
{    checkArgument(bytesUsed > 0, "This is an empty stream");    return bytesUsed - 1;}
22db93bd56909fdbdecf815b1a224ed44b0a17bcf14133fa9ec9c747b4906ebd
setByte
public void setByte(long index, byte value)
{    checkArgument(index < bytesUsed, "Index: " + index + " is >= the current size of: " + bytesUsed);    long seen = 0;    for (int i = 0; i < slabs.size(); i++) {        ByteBuffer slab = slabs.get(i);        if (index < seen + slab.limit()) {                        slab.put((int) (index - seen), value);            break;        }        seen += slab.limit();    }}
729f860abc36decbc60be91f7b83b54762252f09cb85d7c4e9f7517c5dace502
memUsageString
public String memUsageString(String prefix)
{    return format("%s %s %d slabs, %,d bytes", prefix, getClass().getSimpleName(), slabs.size(), getCapacity());}
c5e79ff5e7fefd050dbbc0882f2e2920dc1477552fa47d50f78410bbf9e3c9e8
getSlabCount
 int getSlabCount()
{    return slabs.size();}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    for (ByteBuffer slab : slabs) {        allocator.release(slab);    }    try {        super.close();    } catch (IOException e) {        throw new OutputStreamCloseException(e);    }}
d92aa3cfabe937bb0a7f6557d5e4e233c43341f038dc5502f6ae433ad4db47e1
collect
public void collect(BytesInput bytesInput) throws IOException
{    byte[] bytes = bytesInput.toByteArray();    slabs.add(bytes);    size += bytes.length;}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    size = 0;    slabs.clear();}
b31ecdd27ff00947523b9706e1e03cfb020f32ce038e16f8e9a8d2c9fc142aaf
writeAllTo
public void writeAllTo(OutputStream out) throws IOException
{    for (byte[] slab : slabs) {        out.write(slab);    }}
cfb41f73e412eba54585b19c4db25a324ab3cdbbceb33179d6832934541179a0
size
public long size()
{    return size;}
729f860abc36decbc60be91f7b83b54762252f09cb85d7c4e9f7517c5dace502
memUsageString
public String memUsageString(String prefix)
{    return format("%s %s %d slabs, %,d bytes", prefix, getClass().getSimpleName(), slabs.size(), size);}
cee4484c2f851595681bfb4a155a3c5269e2bc1aa747a3ce327a77ab13bf34a8
getInstance
public static final DirectByteBufferAllocator getInstance()
{    return new DirectByteBufferAllocator();}
62ff543a9141e2cb1030e39bdc126a1f58c3c61b46ba788273ee167ea8ef5738
allocate
public ByteBuffer allocate(final int size)
{    return ByteBuffer.allocateDirect(size);}
f12d217377442d5267dbe48ae3e28160724d4996fd82625b2886075c3740daaa
release
public void release(ByteBuffer b)
{        return;}
c8e0b9c5b5d5c23ed7f08abaed872fddaa698846429d682947ae64a9ff3b9c1e
isDirect
public boolean isDirect()
{    return true;}
07c12d85cc4e1dda2a765d25c0a1e3ce7bf8dc557510a701f51cd98ecd6b10c6
getInstance
public static final HeapByteBufferAllocator getInstance()
{    return new HeapByteBufferAllocator();}
62ff543a9141e2cb1030e39bdc126a1f58c3c61b46ba788273ee167ea8ef5738
allocate
public ByteBuffer allocate(final int size)
{    return ByteBuffer.allocate(size);}
f12d217377442d5267dbe48ae3e28160724d4996fd82625b2886075c3740daaa
release
public void release(ByteBuffer b)
{    return;}
c8e0b9c5b5d5c23ed7f08abaed872fddaa698846429d682947ae64a9ff3b9c1e
isDirect
public boolean isDirect()
{    return false;}
e985c5acb67e6364c525aa0b0d0f691756eede5afe3aca4b334467619ac6132d
readFully
public final void readFully(byte[] b) throws IOException
{    readFully(b, 0, b.length);}
940a684bd11f30a0355fbc59fd17c858172f674a4cc2332a25368430a17f8f51
readFully
public final void readFully(byte[] b, int off, int len) throws IOException
{    if (len < 0)        throw new IndexOutOfBoundsException();    int n = 0;    while (n < len) {        int count = in.read(b, off + n, len - n);        if (count < 0)            throw new EOFException();        n += count;    }}
952eb7d917ddb12ce87ce348474a8c3cfc17aefdbc3d78429a90daab7f8e5ed5
skipBytes
public final int skipBytes(int n) throws IOException
{    int total = 0;    int cur = 0;    while ((total < n) && ((cur = (int) in.skip(n - total)) > 0)) {        total += cur;    }    return total;}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    return in.read();}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return in.hashCode();}
f1bd356e482fbc023feab89d2655df447ac6f2bcd456f7c68cc5c21e4167b36b
read
public int read(byte[] b) throws IOException
{    return in.read(b);}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    return in.equals(obj);}
56e08d87e6bd0be2a60f9b2de3195d58bc9d56a2637f6fed6210d21e832632ea
read
public int read(byte[] b, int off, int len) throws IOException
{    return in.read(b, off, len);}
ce76f6aac8f77c67074f3b19112ca15bf61b65a883c96fe1c58af7e5620e8d94
skip
public long skip(long n) throws IOException
{    return in.skip(n);}
02422e619fc950e443408bbd36203c4155e09261ea21c537537f17f6e4a56d8f
available
public int available() throws IOException
{    return in.available();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    in.close();}
7cc921b4ff6dbc30866ab49e9ef2a88f2538680c6450f60e1fcc7989cfa03402
mark
public void mark(int readlimit)
{    in.mark(readlimit);}
39fd2a669bd97a959085d10145da4dcd11d83878afcd67b2123354de7e8771d9
reset
public void reset() throws IOException
{    in.reset();}
23a63ca46da6513daeb255dee9f0a6e74737bbe34c04911d002213961e2f7cc9
markSupported
public boolean markSupported()
{    return in.markSupported();}
80521e5be9119e754e19cbfaa0ecc7c631ff675c72611c125bbc5a8777ef91b8
readBoolean
public final boolean readBoolean() throws IOException
{    int ch = in.read();    if (ch < 0)        throw new EOFException();    return (ch != 0);}
e68cc6ffb988eb0a23d3524c0606d398ef488971771ee910b11cace647989c98
readByte
public final byte readByte() throws IOException
{    int ch = in.read();    if (ch < 0)        throw new EOFException();    return (byte) (ch);}
ea1375035e879488294da15d338fe5d41d0f5f4f992bd8ee3f38ea533b27b68e
readUnsignedByte
public final int readUnsignedByte() throws IOException
{    int ch = in.read();    if (ch < 0)        throw new EOFException();    return ch;}
be8cb2da4078e0500f93b548a6a13c309f11dfebd0a9cdafa7b71e0ef831f940
readShort
public final short readShort() throws IOException
{    int ch2 = in.read();    int ch1 = in.read();    if ((ch1 | ch2) < 0)        throw new EOFException();    return (short) ((ch1 << 8) + (ch2 << 0));}
40afe167a04fe536950d83e75d16a067f6e2bb363d609940a2c46162c6c1c96f
readUnsignedShort
public final int readUnsignedShort() throws IOException
{    int ch2 = in.read();    int ch1 = in.read();    if ((ch1 | ch2) < 0)        throw new EOFException();    return (ch1 << 8) + (ch2 << 0);}
601fecbc1956170734f3dab2b197b58e14b1944a5ccaa09490d205a7c5f89388
readInt
public final int readInt() throws IOException
{                        int ch4 = in.read();    int ch3 = in.read();    int ch2 = in.read();    int ch1 = in.read();    if ((ch1 | ch2 | ch3 | ch4) < 0)        throw new EOFException();    return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));}
b16a05eb605479f89c8731fa6b02a15dda2f96398465c05635a01e1cb49b5735
readLong
public final long readLong() throws IOException
{        readFully(readBuffer, 0, 8);    return (((long) readBuffer[7] << 56) + ((long) (readBuffer[6] & 255) << 48) + ((long) (readBuffer[5] & 255) << 40) + ((long) (readBuffer[4] & 255) << 32) + ((long) (readBuffer[3] & 255) << 24) + ((readBuffer[2] & 255) << 16) + ((readBuffer[1] & 255) << 8) + ((readBuffer[0] & 255) << 0));}
9c58448d99cd9e5444b228174e151508a76e3532c57224c023dbc2b12a680f4e
readFloat
public final float readFloat() throws IOException
{    return Float.intBitsToFloat(readInt());}
fba50739e892c296db5721de204fe3fd8339a6a1d7d23140b4ff773a073c3494
readDouble
public final double readDouble() throws IOException
{    return Double.longBitsToDouble(readLong());}
28b71ced43af8c83f8eb799b762b9363eea3393c08bf12a29b90de2304757b0c
write
public void write(int b) throws IOException
{    out.write(b);}
6426ce3b66c4d2446558d8b5b93fe8a019e350f1ed5c2b61732f1efce14f0e67
write
public void write(byte[] b, int off, int len) throws IOException
{    out.write(b, off, len);}
c3e67ec76f1b008887f1caba645a2614900cde6e477acca1bc3ecc36bf357fcf
flush
public void flush() throws IOException
{    out.flush();}
c1138fd9e1f7fa8f86e7ed7569ad6f3c5069619ee863c7ec2463d66ba2886b62
writeBoolean
public final void writeBoolean(boolean v) throws IOException
{    out.write(v ? 1 : 0);}
b5664ccc93aa30e740359e77d2830f6c8d236e99ac2387407dff7f5db70baf87
writeByte
public final void writeByte(int v) throws IOException
{    out.write(v);}
f3830b361aa6617012336e526b9af32753a0b8d68cbd4b899850c9227f345658
writeShort
public final void writeShort(int v) throws IOException
{    out.write((v >>> 0) & 0xFF);    out.write((v >>> 8) & 0xFF);}
837cfb0559829adc3672bc2018c5741a7e4c1d6c3e28dcb7976c1f5fa8e194cd
writeInt
public final void writeInt(int v) throws IOException
{                out.write((v >>> 0) & 0xFF);    out.write((v >>> 8) & 0xFF);    out.write((v >>> 16) & 0xFF);    out.write((v >>> 24) & 0xFF);}
e729ae10a24b25a8ea8eee3e16c07a42d2c146d826aa89e24eb346a2878e91c8
writeLong
public final void writeLong(long v) throws IOException
{    writeBuffer[7] = (byte) (v >>> 56);    writeBuffer[6] = (byte) (v >>> 48);    writeBuffer[5] = (byte) (v >>> 40);    writeBuffer[4] = (byte) (v >>> 32);    writeBuffer[3] = (byte) (v >>> 24);    writeBuffer[2] = (byte) (v >>> 16);    writeBuffer[1] = (byte) (v >>> 8);    writeBuffer[0] = (byte) (v >>> 0);    out.write(writeBuffer, 0, 8);}
bdcc1459f07ce22be404ce8a326efc5eef80d686aa6a77cb8ea91d5fb9a55eeb
writeFloat
public final void writeFloat(float v) throws IOException
{    writeInt(Float.floatToIntBits(v));}
a06ca8f10cd3ef67f979aefde8a43ca83fe0d961ee1109085a6ee6b4cb1240b4
writeDouble
public final void writeDouble(double v) throws IOException
{    writeLong(Double.doubleToLongBits(v));}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    IOExceptionUtils.closeQuietly(out);}
64a3ee0922b6f03ba972a38aa52a0e1866d9bbcb6c04662c3cec03bc5a001fe5
position
public long position()
{    return position;}
7c19bd84924ea3cd1314ee9059df92a2c49b00d5d8e3580697d2f75a289ebca3
skip
public long skip(long n)
{    if (n <= 0) {        return 0;    }    if (current == null) {        return -1;    }    long bytesSkipped = 0;    while (bytesSkipped < n) {        if (current.remaining() > 0) {            long bytesToSkip = Math.min(n - bytesSkipped, current.remaining());            current.position(current.position() + (int) bytesToSkip);            bytesSkipped += bytesToSkip;            this.position += bytesToSkip;        } else if (!nextBuffer()) {                        return bytesSkipped > 0 ? bytesSkipped : -1;        }    }    return bytesSkipped;}
42bd96fea83f8535b30f7a1d4be2135983b6e18fdf7e21a7d0e8e80d3f00fd2a
read
public int read(ByteBuffer out)
{    int len = out.remaining();    if (len <= 0) {        return 0;    }    if (current == null) {        return -1;    }    int bytesCopied = 0;    while (bytesCopied < len) {        if (current.remaining() > 0) {            int bytesToCopy;            ByteBuffer copyBuffer;            if (current.remaining() <= out.remaining()) {                                bytesToCopy = current.remaining();                copyBuffer = current;            } else {                                bytesToCopy = out.remaining();                copyBuffer = current.duplicate();                copyBuffer.limit(copyBuffer.position() + bytesToCopy);                current.position(copyBuffer.position() + bytesToCopy);            }            out.put(copyBuffer);            bytesCopied += bytesToCopy;            this.position += bytesToCopy;        } else if (!nextBuffer()) {                        return bytesCopied > 0 ? bytesCopied : -1;        }    }    return bytesCopied;}
5785a49ae8e405148b93815746be6f3c1a41c0b1c6c323bde1d83dfd2e3ff7c8
slice
public ByteBuffer slice(int length) throws EOFException
{    if (length <= 0) {        return EMPTY;    }    if (current == null) {        throw new EOFException();    }    ByteBuffer slice;    if (length > current.remaining()) {                        slice = ByteBuffer.allocate(length);        int bytesCopied = read(slice);        slice.flip();        if (bytesCopied < length) {            throw new EOFException();        }    } else {        slice = current.duplicate();        slice.limit(slice.position() + length);        current.position(slice.position() + length);        this.position += length;    }    return slice;}
c5aeaf8c7ea8d83b86ec9d930d6082f3343f51f7328e3595998fd22442487ada
sliceBuffers
public List<ByteBuffer> sliceBuffers(long len) throws EOFException
{    if (len <= 0) {        return Collections.emptyList();    }    if (current == null) {        throw new EOFException();    }    List<ByteBuffer> buffers = new ArrayList<>();    long bytesAccumulated = 0;    while (bytesAccumulated < len) {        if (current.remaining() > 0) {                                    int bufLen = (int) Math.min(len - bytesAccumulated, current.remaining());            ByteBuffer slice = current.duplicate();            slice.limit(slice.position() + bufLen);            buffers.add(slice);            bytesAccumulated += bufLen;                        current.position(current.position() + bufLen);            this.position += bufLen;        } else if (!nextBuffer()) {                        throw new EOFException();        }    }    return buffers;}
edc020f04ff1582ce013d9c123709d4cb3c2475b5656800f92a706bc95edb293
remainingBuffers
public List<ByteBuffer> remainingBuffers()
{    if (position >= length) {        return Collections.emptyList();    }    try {        return sliceBuffers(length - position);    } catch (EOFException e) {        throw new RuntimeException("[Parquet bug] Stream is bad: incorrect bytes remaining " + (length - position));    }}
b360165133c9cd56a2839cbab119daf0ffd385e57c8310aebad2148577a8e824
read
public int read(byte[] bytes, int off, int len)
{    if (len <= 0) {        if (len < 0) {            throw new IndexOutOfBoundsException("Read length must be greater than 0: " + len);        }        return 0;    }    if (current == null) {        return -1;    }    int bytesRead = 0;    while (bytesRead < len) {        if (current.remaining() > 0) {            int bytesToRead = Math.min(len - bytesRead, current.remaining());            current.get(bytes, off + bytesRead, bytesToRead);            bytesRead += bytesToRead;            this.position += bytesToRead;        } else if (!nextBuffer()) {                        return bytesRead > 0 ? bytesRead : -1;        }    }    return bytesRead;}
7354a6a8671b72ac9638644710cd0071d6a6f76e807f1655af7c06376ab855b9
read
public int read(byte[] bytes)
{    return read(bytes, 0, bytes.length);}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    if (current == null) {        throw new EOFException();    }    while (true) {        if (current.remaining() > 0) {            this.position += 1;                        return current.get() & 0xFF;        } else if (!nextBuffer()) {                        throw new EOFException();        }    }}
7abd61fd851f87b95935f20a9acee256b4b0722e248a8c94a1a5ed2f46622abd
available
public int available()
{    long remaining = length - position;    if (remaining > Integer.MAX_VALUE) {        return Integer.MAX_VALUE;    } else {        return (int) remaining;    }}
7cc921b4ff6dbc30866ab49e9ef2a88f2538680c6450f60e1fcc7989cfa03402
mark
public void mark(int readlimit)
{    if (mark >= 0) {        discardMark();    }    this.mark = position;    this.markLimit = mark + readlimit + 1;    if (current != null) {        markBuffers.add(current.duplicate());    }}
39fd2a669bd97a959085d10145da4dcd11d83878afcd67b2123354de7e8771d9
reset
public void reset() throws IOException
{    if (mark >= 0 && position < markLimit) {        this.position = mark;                        this.iterator = concat(markBuffers.iterator(), iterator);        discardMark();                nextBuffer();    } else {        throw new IOException("No mark defined or has read past the previous mark limit");    }}
244f70ead9c894c90c4fca5f2085acb27810b034366af93ce7bb05a3e6d4afb7
discardMark
private void discardMark()
{    this.mark = -1;    this.markLimit = 0;    markBuffers = new ArrayList<>();}
23a63ca46da6513daeb255dee9f0a6e74737bbe34c04911d002213961e2f7cc9
markSupported
public boolean markSupported()
{    return true;}
fd801b037f4ad68134f1cc6800e049fe0a05df1d699c5a55469eaef805f98010
nextBuffer
private boolean nextBuffer()
{    if (!iterator.hasNext()) {        this.current = null;        return false;    }    this.current = iterator.next().duplicate();    if (mark >= 0) {        if (position < markLimit) {                        markBuffers.add(current.duplicate());        } else {                        discardMark();        }    }    return true;}
7c9846ae860dd1caac9432f204ee376c526a440e100f760014e753af89822abf
concat
private static Iterator<E> concat(Iterator<E> first, Iterator<E> second)
{    return new ConcatIterator<>(first, second);}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    if (useFirst) {        if (first.hasNext()) {            return true;        } else {            useFirst = false;            return second.hasNext();        }    }    return second.hasNext();}
c8bdca1c159be1f114d59823385a107cb1e1393427235435e4cb9dd743d2eaa5
next
public E next()
{    if (useFirst && !first.hasNext()) {        useFirst = false;    }    if (!useFirst && !second.hasNext()) {        throw new NoSuchElementException();    }    if (useFirst) {        return first.next();    }    return second.next();}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    if (useFirst) {        first.remove();    }    second.remove();}
64a3ee0922b6f03ba972a38aa52a0e1866d9bbcb6c04662c3cec03bc5a001fe5
position
public long position()
{        return buffer.position() - startPosition;}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    if (!buffer.hasRemaining()) {        throw new EOFException();    }        return buffer.get() & 0xFF;}
8d5b28c9b6acd15e04adfa5131f580e30a612fd3ea9872605e3ccc9d0b0bf58c
read
public int read(byte[] bytes, int offset, int length) throws IOException
{    if (length == 0) {        return 0;    }    int remaining = buffer.remaining();    if (remaining <= 0) {        return -1;    }    int bytesToRead = Math.min(buffer.remaining(), length);    buffer.get(bytes, offset, bytesToRead);    return bytesToRead;}
7c19bd84924ea3cd1314ee9059df92a2c49b00d5d8e3580697d2f75a289ebca3
skip
public long skip(long n)
{    if (n == 0) {        return 0;    }    if (buffer.remaining() <= 0) {        return -1;    }        int bytesToSkip = (int) Math.min(buffer.remaining(), n);    buffer.position(buffer.position() + bytesToSkip);    return bytesToSkip;}
42bd96fea83f8535b30f7a1d4be2135983b6e18fdf7e21a7d0e8e80d3f00fd2a
read
public int read(ByteBuffer out)
{    int bytesToCopy;    ByteBuffer copyBuffer;    if (buffer.remaining() <= out.remaining()) {                bytesToCopy = buffer.remaining();        copyBuffer = buffer;    } else {                bytesToCopy = out.remaining();        copyBuffer = buffer.duplicate();        copyBuffer.limit(buffer.position() + bytesToCopy);        buffer.position(buffer.position() + bytesToCopy);    }    out.put(copyBuffer);    out.flip();    return bytesToCopy;}
5785a49ae8e405148b93815746be6f3c1a41c0b1c6c323bde1d83dfd2e3ff7c8
slice
public ByteBuffer slice(int length) throws EOFException
{    if (buffer.remaining() < length) {        throw new EOFException();    }        ByteBuffer copy = buffer.duplicate();    copy.limit(copy.position() + length);    buffer.position(buffer.position() + length);    return copy;}
12b9ca0cadb57f2c0cdd23eb0b019260c635488af0b52b8c83d85d62226be35b
sliceBuffers
public List<ByteBuffer> sliceBuffers(long length) throws EOFException
{    if (length == 0) {        return Collections.emptyList();    }    if (length > buffer.remaining()) {        throw new EOFException();    }        return Collections.singletonList(slice((int) length));}
edc020f04ff1582ce013d9c123709d4cb3c2475b5656800f92a706bc95edb293
remainingBuffers
public List<ByteBuffer> remainingBuffers()
{    if (buffer.remaining() <= 0) {        return Collections.emptyList();    }    ByteBuffer remaining = buffer.duplicate();    buffer.position(buffer.limit());    return Collections.singletonList(remaining);}
7cc921b4ff6dbc30866ab49e9ef2a88f2538680c6450f60e1fcc7989cfa03402
mark
public void mark(int readlimit)
{    this.mark = buffer.position();}
39fd2a669bd97a959085d10145da4dcd11d83878afcd67b2123354de7e8771d9
reset
public void reset() throws IOException
{    if (mark >= 0) {        buffer.position(mark);        this.mark = -1;    } else {        throw new IOException("No mark defined");    }}
23a63ca46da6513daeb255dee9f0a6e74737bbe34c04911d002213961e2f7cc9
markSupported
public boolean markSupported()
{    return true;}
7abd61fd851f87b95935f20a9acee256b4b0722e248a8c94a1a5ed2f46622abd
available
public int available()
{    return buffer.remaining();}
5121b590396dec0a21c8c368f1cb68feea5a404bcf80aee8083a9d4daa7a35d3
close
public static void close(Closeable c) throws IOException
{    if (c == null) {        return;    }    c.close();}
dcc11a53befc2c59cd43ea7a4f628f21188a32e5c51179cff5c0691e9ff55311
closeAndSwallowIOExceptions
public static void closeAndSwallowIOExceptions(Closeable c)
{    if (c == null) {        return;    }    try {        c.close();    } catch (IOException e) {        LOG.warn("Encountered exception closing closeable", e);    }}
5ec39537b8e3ac8cbcd9418d0d27f7887f9982abfbef67aa56f1e396fab1dfbf
throwIfInstance
public static void throwIfInstance(Throwable t, Class<E> excClass) throws E
{    if (excClass.isAssignableFrom(t.getClass())) {                throw excClass.cast(t);    }}
5aeb83ea832db6a2512a03fcd2ecd4ff9bf64f2627dab44acffe5045041a97ed
readAllLines
public static List<String> readAllLines(File file, Charset charset) throws IOException
{    BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), charset));    try {        List<String> result = new ArrayList<String>();        for (; ; ) {            String line = reader.readLine();            if (line == null)                break;            result.add(line);        }        return result;    } finally {        reader.close();    }}
2c7f52301142e3fb00b2391e4371bc9ba61be6db5e9948fa8259846839ca3e46
expand
public static List<String> expand(String globPattern)
{    return GlobExpanderImpl.expand(GlobParser.parse(globPattern));}
d3d7864e3abeaab69610b67d1516d0a0aac789a80f3f3893de054d9ca2b84c29
expand
public static List<String> expand(GlobNode node)
{    return node.accept(INSTANCE);}
038e654cd2bb641f25c852d022d23c01adfad9d73a4f9251a906a02601434ac3
visit
public List<String> visit(Atom atom)
{        return Arrays.asList(atom.get());}
2ae686f1e1a3d09d550f6139fcfaadd2c913f664992169ca967d6a96d33a88a7
visit
public List<String> visit(OneOf oneOf)
{                List<String> results = new ArrayList<String>();    for (GlobNode n : oneOf.getChildren()) {        results.addAll(n.accept(this));    }    return results;}
575d845bac02fa33bcf4d095117a10aab4993641b3774dc7621853d2a73fc1ab
visit
public List<String> visit(GlobNodeSequence seq)
{                    List<String> results = new ArrayList<String>();    for (GlobNode n : seq.getChildren()) {        results = crossOrTakeNonEmpty(results, n.accept(this));    }    return results;}
170a2c6eb9b378f8984bb0b2af9341d5d9a25bccc05bd709680464a6217362db
crossOrTakeNonEmpty
public static List<String> crossOrTakeNonEmpty(List<String> list1, List<String> list2)
{    if (list1.isEmpty()) {        ArrayList<String> result = new ArrayList<String>(list2.size());        result.addAll(list2);        return result;    }    if (list2.isEmpty()) {        ArrayList<String> result = new ArrayList<String>(list1.size());        result.addAll(list1);        return result;    }    List<String> result = new ArrayList<String>(list1.size() * list2.size());    for (String s1 : list1) {        for (String s2 : list2) {            result.add(s1 + s2);        }    }    return result;}
3bdfb82158e514af8fa8e4bf41a4e69a6b9317d48597b72409f899318865ae1b
get
public String get()
{    return s;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    return o != null && getClass() == o.getClass() && s.equals(((Atom) o).s);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return s.hashCode();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "Atom(" + s + ")";}
abab9921ffe7366a52406f9bbae13e33613f8fd08c0606a4a323a8912f6bcd5d
accept
public R accept(Visitor<R> visitor)
{    return visitor.visit(this);}
ef25ef56f4a0aa9fc2085596d7d01ced04e724b9b52e7b7c163cb9662304574c
getChildren
public List<GlobNode> getChildren()
{    return children;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    return o != null && getClass() == o.getClass() && children.equals(((OneOf) o).children);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return children.hashCode();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "OneOf" + children;}
abab9921ffe7366a52406f9bbae13e33613f8fd08c0606a4a323a8912f6bcd5d
accept
public R accept(Visitor<R> visitor)
{    return visitor.visit(this);}
ef25ef56f4a0aa9fc2085596d7d01ced04e724b9b52e7b7c163cb9662304574c
getChildren
public List<GlobNode> getChildren()
{    return children;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    return o != null && getClass() == o.getClass() && children.equals(((OneOf) o).children);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return children.hashCode();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "GlobNodeSequence" + children;}
abab9921ffe7366a52406f9bbae13e33613f8fd08c0606a4a323a8912f6bcd5d
accept
public R accept(Visitor<R> visitor)
{    return visitor.visit(this);}
b868a1062c831c98cecb0959d93c4c25e5cf7228a1f1e6e43d5e8de072e0fd4b
parse
public static GlobNodeSequence parse(String pattern)
{    if (pattern.isEmpty() || pattern.equals("{}")) {        return new GlobNodeSequence(Arrays.<GlobNode>asList(new Atom("")));    }            List<GlobNode> children = new ArrayList<GlobNode>();        int unmatchedBraces = 0;        int firstBrace = 0;        int anchor = 0;    for (int i = 0; i < pattern.length(); i++) {        char c = pattern.charAt(i);        switch(c) {            case ',':                if (unmatchedBraces == 0) {                                        throw new GlobParseException("Unexpected comma outside of a {} group:\n" + annotateMessage(pattern, i));                }                break;            case '{':                if (unmatchedBraces == 0) {                                        firstBrace = i;                }                unmatchedBraces++;                break;            case '}':                unmatchedBraces--;                if (unmatchedBraces < 0) {                    throw new GlobParseException("Unexpected closing }:\n" + annotateMessage(pattern, i));                }                if (unmatchedBraces == 0) {                                        if (anchor != firstBrace) {                                                                        children.add(new Atom(pattern.substring(anchor, firstBrace)));                    }                                                            children.add(parseOneOf(pattern.substring(firstBrace + 1, i)));                                        anchor = i + 1;                }                break;        }    }    if (unmatchedBraces > 0) {        throw new GlobParseException("Not enough close braces in: " + pattern);    }    if (anchor != pattern.length()) {                                children.add(new Atom(pattern.substring(anchor, pattern.length())));    }    return new GlobNodeSequence(children);}
0ccd0fcde7606f2d9c1a0a2f6b9864bc40757ac3a176bc9faf7c945fdb594e5f
parseOneOf
private static OneOf parseOneOf(String pattern)
{    /*     * This method is only called when parsing the inside of a {} expression.     * So in the example above, of calling parse("apache{one,pre{x,y}post,two}parquet{a,b}")     * this method will get called on first "one,pre{x,y}post,two", then on "x,y" and then on "a,b"     *     * The inside of a {} expression essentially means "one of these comma separated expressions".     * So this gets parsed slightly differently than the top level string passed to parse().     *     * The algorithm works as follows:     * 1) Split the string on ',' -- but only commas that are not inside of {} expressions     * 2) Each of the splits can be parsed via the parse() method above     * 3) Add all parsed splits to a single parent OneOf.     */            List<GlobNode> children = new ArrayList<GlobNode>();        int unmatchedBraces = 0;        int anchor = 0;    for (int i = 0; i < pattern.length(); i++) {        char c = pattern.charAt(i);        switch(c) {            case ',':                                if (unmatchedBraces == 0) {                                                                                children.add(parse(pattern.substring(anchor, i)));                                        anchor = i + 1;                }                break;            case '{':                unmatchedBraces++;                break;            case '}':                unmatchedBraces--;                if (unmatchedBraces < 0) {                    throw new GlobParseException("Unexpected closing }:\n" + annotateMessage(pattern, i));                }                break;        }    }    if (unmatchedBraces > 0) {        throw new GlobParseException("Not enough close braces in: " + pattern);    }    if (anchor != pattern.length()) {                                children.add(parse(pattern.substring(anchor, pattern.length())));    }    if (pattern.length() > 0 && pattern.charAt(pattern.length() - 1) == ',') {                children.add(parse(""));    }    return new OneOf(children);}
9148396bd6eb3443fdb46629f5821d0d9b997d38d41efc8279599271a5da0422
annotateMessage
private static String annotateMessage(String message, int pos)
{    StringBuilder sb = new StringBuilder(message);    sb.append('\n');    for (int i = 0; i < pos; i++) {        sb.append('-');    }    sb.append('^');    return sb.toString();}
5b2ac7593f280e9e4af82ad46a5a7b550a8bae7c8ffa8aa634a57d50a6bc134e
buildRegex
public static String buildRegex(String wildcardPath, char delim)
{    if (wildcardPath.isEmpty()) {        return wildcardPath;    }    String delimStr = Pattern.quote(Character.toString(delim));        String[] splits = wildcardPath.split("\\*", -1);    StringBuilder regex = new StringBuilder();    for (int i = 0; i < splits.length; i++) {        if ((i == 0 || i == splits.length - 1) && splits[i].isEmpty()) {                        regex.append(STAR_REGEX);            continue;        }        if (splits[i].isEmpty()) {                        continue;        }                        regex.append(Pattern.quote(splits[i]));        if (i < splits.length - 1) {                        regex.append(STAR_REGEX);        }    }        regex.append(String.format(MORE_NESTED_FIELDS_TEMPLATE, delimStr));    return regex.toString();}
fdad0512b698c9e294276c51d323c6081de5de4b13621ff2366da55dc4d6d59e
matches
public boolean matches(String path)
{    return pattern.matcher(path).matches();}
093e1c6a847fc43d820b00f893c3d439c2cf94e8eee59843c32e1d1a5cceb199
getParentGlobPath
public String getParentGlobPath()
{    return parentGlobPath;}
8cb0c6e1eeff9fb39d419cd1778c66b38a2ea6d003f645d8a72b10fa3393eb19
getOriginalPattern
public String getOriginalPattern()
{    return originalPattern;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.format("WildcardPath(parentGlobPath: '%s', pattern: '%s')", parentGlobPath, originalPattern);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    WildcardPath wildcardPath = (WildcardPath) o;    return originalPattern.equals(wildcardPath.originalPattern);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return originalPattern.hashCode();}
da2ab016b8677dcb170c0190d0079ef7972232c98131dc58fbb9de80bca35030
getCodecClass
public Class getCodecClass()
{    return codecClass;}
76a9002a7b69219822415489e768d15b9036a7984c439489b7f727b9752f8981
canonicalize
public final T canonicalize(T value)
{    T canonical = canonicals.get(value);    if (canonical == null) {        value = toCanonical(value);        T existing = canonicals.putIfAbsent(value, value);                if (existing == null) {            canonical = value;        } else {            canonical = existing;        }    }    return canonical;}
a054d4d40dbca64141580a6229cc2d2ba8b9c3886b467daf93d9435860e7ba79
toCanonical
protected T toCanonical(T value)
{    return value;}
cdc76f983f17017b1986d8a9a049be31cbe154ed9fe4b1cb585d5e6d9df2b091
toCanonical
protected ColumnPath toCanonical(ColumnPath value)
{    String[] path = new String[value.p.length];    for (int i = 0; i < value.p.length; i++) {        path[i] = value.p[i].intern();    }    return new ColumnPath(path);}
7d689f099855a1c7c91737f2499b62f7b4a61f565b6521396264dd99bb7179b7
fromDotString
public static ColumnPath fromDotString(String path)
{    checkNotNull(path, "path");    return get(path.split("\\."));}
ac7d48ccb4a6f8d3dc5b963e5817b91fb831660febf2f88c5a4d6cad169be4a9
get
public static ColumnPath get(String... path)
{    return paths.canonicalize(new ColumnPath(path));}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (obj instanceof ColumnPath) {        return Arrays.equals(p, ((ColumnPath) obj).p);    }    return false;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return Arrays.hashCode(p);}
f0e211863e0e19e5a2b24007f6febf66444217a0044c5b6475c502a0650c3074
toDotString
public String toDotString()
{    return Strings.join(p, ".");}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return Arrays.toString(p);}
37c103bb84952e055d3c90aa17374e9c534adb331cfa33135047f91399a5d006
iterator
public Iterator<String> iterator()
{    return Arrays.asList(p).iterator();}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return p.length;}
0245bc5897b5e77bcce088d4392a8f7c8cd0df0fc21d44fb0e8d973c1a93cad0
toArray
public String[] toArray()
{    return p;}
989e28bb0e1bcaac6df19bf802a54e4fe716140e0f50d77acb24031050f3565d
fromConf
public static CompressionCodecName fromConf(String name)
{    if (name == null) {        return UNCOMPRESSED;    }    return valueOf(name.toUpperCase(Locale.ENGLISH));}
83ed1c30a692e0c22ebd8bbdadf4cd3f8320a05f9b7f8c6bc73fd683301a78f0
fromCompressionCodec
public static CompressionCodecName fromCompressionCodec(Class<?> clazz)
{    if (clazz == null) {        return UNCOMPRESSED;    }    String name = clazz.getName();    for (CompressionCodecName codec : CompressionCodecName.values()) {        if (name.equals(codec.getHadoopCompressionCodecClassName())) {            return codec;        }    }    throw new CompressionCodecNotSupportedException(clazz);}
eb424e681094dd6e8da028c6e113692a11a269f64fbd30c077d0a91f64b3185d
fromParquet
public static CompressionCodecName fromParquet(CompressionCodec codec)
{    for (CompressionCodecName codecName : CompressionCodecName.values()) {        if (codec.equals(codecName.parquetCompressionCodec)) {            return codecName;        }    }    throw new IllegalArgumentException("Unknown compression codec " + codec);}
28beba3c0a8050e1f34ab4871bf8b3e3cf8630b95d0a0b17a309229f492816af
getHadoopCompressionCodecClassName
public String getHadoopCompressionCodecClassName()
{    return hadoopCompressionCodecClass;}
c4352662f312d75459962b0d1d3e64953cd7e616426d979757a4c9fbf7cb7004
getHadoopCompressionCodecClass
public Class getHadoopCompressionCodecClass()
{    String codecClassName = getHadoopCompressionCodecClassName();    if (codecClassName == null) {        return null;    }    try {        return Class.forName(codecClassName);    } catch (ClassNotFoundException e) {        return null;    }}
bc878a252f3612d53b34e1618934d3bc79ea5487efe47311cbde99a00465402a
getParquetCompressionCodec
public CompressionCodec getParquetCompressionCodec()
{    return parquetCompressionCodec;}
dd386f4d75b694f73345347a9b2e46289fee679d7748d4d3eee41cd501d6e88c
getExtension
public String getExtension()
{    return extension;}
88c74df585c7f109fc41bd87b5d4e6626a1da5cc0f1f1601d859a51debec9db3
checkedCast
public static int checkedCast(long value)
{    int valueI = (int) value;    if (valueI != value) {        throw new IllegalArgumentException(String.format("Overflow casting %d to an int", value));    }    return valueI;}
bb60c6dfe298c6469b3f6c4bcd7d7b7a0c9d40b0bae41f2dc02b19f8011ef5f3
getStream
public OutputStream getStream()
{    return stream;}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    stream.close();}
c3e67ec76f1b008887f1caba645a2614900cde6e477acca1bc3ecc36bf357fcf
flush
public void flush() throws IOException
{    stream.flush();}
28b71ced43af8c83f8eb799b762b9363eea3393c08bf12a29b90de2304757b0c
write
public void write(int b) throws IOException
{    stream.write(b);}
9dc05e09d787e6afa8b5d2cf4cacaf1f65f348fcc597daca5502cd46ac6e898a
write
public void write(byte[] b) throws IOException
{    stream.write(b);}
6426ce3b66c4d2446558d8b5b93fe8a019e350f1ed5c2b61732f1efce14f0e67
write
public void write(byte[] b, int off, int len) throws IOException
{    stream.write(b, off, len);}
ee5bf5def3b430bc7760531d3b1dde08b2cf2b051565502b18838df56f00e27a
getStream
public InputStream getStream()
{    return stream;}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    stream.close();}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    return stream.read();}
56e08d87e6bd0be2a60f9b2de3195d58bc9d56a2637f6fed6210d21e832632ea
read
public int read(byte[] b, int off, int len) throws IOException
{    return stream.read(b, off, len);}
6393462ea979ef8532c28bb0edd9b6422e4a0d9ddd3547cc24589fe4a0d75955
readFully
public void readFully(byte[] bytes) throws IOException
{    readFully(stream, bytes, 0, bytes.length);}
715c9d664f161880709dd932f02fb9e3cc1877d4eb29878dabf25a019b03537c
readFully
public void readFully(byte[] bytes, int start, int len) throws IOException
{    readFully(stream, bytes, start, len);}
f6cf5cebd4378bf21b6f722e4d539ff0fb218c112d1691f1f0bbd0eda4e34078
read
public int read(ByteBuffer buf) throws IOException
{    if (buf.hasArray()) {        return readHeapBuffer(stream, buf);    } else {        return readDirectBuffer(stream, buf, temp);    }}
830af4e995db0d11aa62bd34816b2f9fc08bdeadd196b209feb6be1c304ce330
readFully
public void readFully(ByteBuffer buf) throws IOException
{    if (buf.hasArray()) {        readFullyHeapBuffer(stream, buf);    } else {        readFullyDirectBuffer(stream, buf, temp);    }}
a4ff5e8068e6376bdc04b494322b9de4ea8fcf8ae2f77aed5ec64f8aff82608a
readFully
 static void readFully(InputStream f, byte[] bytes, int start, int len) throws IOException
{    int offset = start;    int remaining = len;    while (remaining > 0) {        int bytesRead = f.read(bytes, offset, remaining);        if (bytesRead < 0) {            throw new EOFException("Reached the end of stream with " + remaining + " bytes left to read");        }        remaining -= bytesRead;        offset += bytesRead;    }}
c0f2389fd3607189eff6b0742f4af7a7697759acabc1fac73ca9465daf065544
readHeapBuffer
 static int readHeapBuffer(InputStream f, ByteBuffer buf) throws IOException
{    int bytesRead = f.read(buf.array(), buf.arrayOffset() + buf.position(), buf.remaining());    if (bytesRead < 0) {                return bytesRead;    } else {        buf.position(buf.position() + bytesRead);        return bytesRead;    }}
38678a56cf5076589b21d78dc0225c5ca6fdecb1e4329b0f7be9b416950b4283
readFullyHeapBuffer
 static void readFullyHeapBuffer(InputStream f, ByteBuffer buf) throws IOException
{    readFully(f, buf.array(), buf.arrayOffset() + buf.position(), buf.remaining());    buf.position(buf.limit());}
a9f8984b44afcd7eab181c0827c83057ac13bbfaccb25e1ccf1bdea72fcdf57f
readDirectBuffer
 static int readDirectBuffer(InputStream f, ByteBuffer buf, byte[] temp) throws IOException
{            int nextReadLength = Math.min(buf.remaining(), temp.length);    int totalBytesRead = 0;    int bytesRead;    while ((bytesRead = f.read(temp, 0, nextReadLength)) == temp.length) {        buf.put(temp);        totalBytesRead += bytesRead;        nextReadLength = Math.min(buf.remaining(), temp.length);    }    if (bytesRead < 0) {                return totalBytesRead == 0 ? -1 : totalBytesRead;    } else {                buf.put(temp, 0, bytesRead);        totalBytesRead += bytesRead;        return totalBytesRead;    }}
6a75d168142c5d600a6940d937b776b9af89bc11d7891c4d260dfc5f5884f6ed
readFullyDirectBuffer
 static void readFullyDirectBuffer(InputStream f, ByteBuffer buf, byte[] temp) throws IOException
{    int nextReadLength = Math.min(buf.remaining(), temp.length);    int bytesRead = 0;    while (nextReadLength > 0 && (bytesRead = f.read(temp, 0, nextReadLength)) >= 0) {        buf.put(temp, 0, bytesRead);        nextReadLength = Math.min(buf.remaining(), temp.length);    }    if (bytesRead < 0 && buf.remaining() > 0) {        throw new EOFException("Reached the end of stream with " + buf.remaining() + " bytes left to read");    }}
c767cef8f12b33702ff58c7cf18fe4614aeec45597423b84df173216a2b53502
closeQuietly
public static void closeQuietly(Closeable closeable)
{    try {        closeable.close();    } catch (IOException e) {        throw new ParquetRuntimeException("Error closing I/O related resources.", e) {        };    }}
4876ebb6d4aaf0ca8fbc0912d70c9c1cd81a82b20b4f693fc9f2c996eed77c4e
getLog
public static Log getLog(Class<?> c)
{    return new Log(c);}
a21e883322dd621567737ef759ec4b695ad4ef438863565b76931f28ca2d8800
debug
public void debug(Object m)
{    if (m instanceof Throwable) {        logger.debug("", (Throwable) m);    } else {        logger.debug(String.valueOf(m));    }}
6afa756f21a4e9681b13e22ce4d1eb7ca4a443ea7d066549b5fc0395c3f0b8ae
debug
public void debug(Object m, Throwable t)
{    logger.debug(String.valueOf(m), t);}
cc435ddf9909bb79d5161cdf2eef99b698f5c82eeb34b63cfe8dee9b39c1eec7
info
public void info(Object m)
{    if (m instanceof Throwable) {        logger.info("", (Throwable) m);    } else {        logger.info(String.valueOf(m));    }}
899ee753a16dfcaaf1ea2d49367a87255bf2bdb46ed160bf4b4aa8785d8cc136
info
public void info(Object m, Throwable t)
{    logger.info(String.valueOf(m), t);}
8a88b77374e8ea0fa284cf44fbd396970e9daa1b2e2c82ca3e744317036f32c1
warn
public void warn(Object m)
{    if (m instanceof Throwable) {        logger.warn("", (Throwable) m);    } else {        logger.warn(String.valueOf(m));    }}
1a962ecb69cfb53e23fd0802498269f2ad7840b68d1b1a92a5efad95daaca40b
warn
public void warn(Object m, Throwable t)
{    logger.warn(String.valueOf(m), t);}
ce5c90637217371cd2bb4a6eea2077788dad790cea53fcf39f1101507c81b498
error
public void error(Object m)
{    if (m instanceof Throwable) {        logger.error("", (Throwable) m);    } else {        logger.error(String.valueOf(m));    }}
054c8acc0808b0114344e0f0ea8402b10b11f21eda02fc245eeda76b537d8282
error
public void error(Object m, Throwable t)
{    logger.error(String.valueOf(m), t);}
89e593538c5fcdc83903dff40773d27cb6533e12f9aaedb3b716167bd42fb1da
checkNotNull
public static T checkNotNull(T o, String name) throws NullPointerException
{    if (o == null) {        throw new NullPointerException(name + " should not be null");    }    return o;}
219edad63403869d6b34f85e28c453036b77619afe9b6651f000ae7659630db8
checkArgument
public static void checkArgument(boolean isValid, String message) throws IllegalArgumentException
{    if (!isValid) {        throw new IllegalArgumentException(message);    }}
ce511120ac497de60039d5a11aedadbde25502e0d8513c4fb0214c3397da9cce
checkArgument
public static void checkArgument(boolean isValid, String message, Object... args) throws IllegalArgumentException
{    if (!isValid) {        throw new IllegalArgumentException(String.format(String.valueOf(message), strings(args)));    }}
d682a35d8854a77c55e71f39cbb0e7e31de01a953aecff2684796eff65883d04
checkState
public static void checkState(boolean isValid, String message) throws IllegalStateException
{    if (!isValid) {        throw new IllegalStateException(message);    }}
793718ea48a2abe52c2a62d903bb735b43b6e35e688125532c43cf67030f6b8b
checkState
public static void checkState(boolean isValid, String message, Object... args) throws IllegalStateException
{    if (!isValid) {        throw new IllegalStateException(String.format(String.valueOf(message), strings(args)));    }}
c6758b09690288dc749e4ab5c312195d0053f2582846a044250fd9d79f85ab37
strings
private static String[] strings(Object[] objects)
{    String[] strings = new String[objects.length];    for (int i = 0; i < objects.length; i += 1) {        strings[i] = String.valueOf(objects[i]);    }    return strings;}
f9f0eb50e32239d9ad66e9ad3e036043832bb8a698bf1c8bab44b987a647311c
parse
public static SemanticVersion parse(String version) throws SemanticVersionParseException
{    Matcher matcher = PATTERN.matcher(version);    if (!matcher.matches()) {        throw new SemanticVersionParseException("" + version + " does not match format " + FORMAT);    }    final int major;    final int minor;    final int patch;    try {        major = Integer.valueOf(matcher.group(1));        minor = Integer.valueOf(matcher.group(2));        patch = Integer.valueOf(matcher.group(3));    } catch (NumberFormatException e) {        throw new SemanticVersionParseException(e);    }    final String unknown = matcher.group(4);    final String prerelease = matcher.group(5);    final String buildInfo = matcher.group(6);    if (major < 0 || minor < 0 || patch < 0) {        throw new SemanticVersionParseException(String.format("major(%d), minor(%d), and patch(%d) must all be >= 0", major, minor, patch));    }    return new SemanticVersion(major, minor, patch, unknown, prerelease, buildInfo);}
ee8df63518298951bdac84f7fd5c025e14b982ad97c0522cf0462cd947c095f3
compareTo
public int compareTo(SemanticVersion o)
{    int cmp;    cmp = compareIntegers(major, o.major);    if (cmp != 0) {        return cmp;    }    cmp = compareIntegers(minor, o.minor);    if (cmp != 0) {        return cmp;    }    cmp = compareIntegers(patch, o.patch);    if (cmp != 0) {        return cmp;    }    cmp = compareBooleans(o.prerelease, prerelease);    if (cmp != 0) {        return cmp;    }    if (pre != null) {        if (o.pre != null) {            return pre.compareTo(o.pre);        } else {            return -1;        }    } else if (o.pre != null) {        return 1;    }    return 0;}
6b7d5c1d287b82edf5ed40cfc09d064c2b73cf9280323acc0ee0802e08b819b0
compareIntegers
private static int compareIntegers(int x, int y)
{    return (x < y) ? -1 : ((x == y) ? 0 : 1);}
5c6744096e8bde91626431e08ac03578c6d52a5766aee7002c394e9bf64d3b52
compareBooleans
private static int compareBooleans(boolean x, boolean y)
{    return (x == y) ? 0 : (x ? 1 : -1);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    SemanticVersion that = (SemanticVersion) o;    return compareTo(that) == 0;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = major;    result = 31 * result + minor;    result = 31 * result + patch;    return result;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder();    sb.append(major).append(".").append(minor).append(".").append(patch);    if (prerelease) {        sb.append(unknown);    }    if (pre != null) {        sb.append(pre.original);    }    if (buildInfo != null) {        sb.append(buildInfo);    }    return sb.toString();}
463eafc6cbb6831d29290c3e4f9603741e3ba40bf7188d8a341810950cd80682
compareTo
public int compareTo(NumberOrString that)
{        int cmp = compareBooleans(that.isNumeric, this.isNumeric);    if (cmp != 0) {        return cmp;    }    if (isNumeric) {                return compareIntegers(this.number, that.number);    }        return this.original.compareTo(that.original);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return original;}
83de3f512de209658daadab50e2d68608f046cd13c3009d4967db1d209d49635
compareTo
public int compareTo(Prerelease that)
{            int size = Math.min(this.identifiers.size(), that.identifiers.size());    for (int i = 0; i < size; i += 1) {        int cmp = identifiers.get(i).compareTo(that.identifiers.get(i));        if (cmp != 0) {            return cmp;        }    }    return compareIntegers(this.identifiers.size(), that.identifiers.size());}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return original;}
5634a81352184bdc267a62b0aa21b226e6f15118d12634f98c2722b59eb54eb2
join
public static String join(Iterable<String> s, String on)
{    return join(s.iterator(), on);}
8880228c9601c43705f43360921c27d6e67627c6456b6a1c079793ba4cfc181b
join
public static String join(Iterator<String> iter, String on)
{    StringBuilder sb = new StringBuilder();    while (iter.hasNext()) {        sb.append(iter.next());        if (iter.hasNext()) {            sb.append(on);        }    }    return sb.toString();}
a435484761ae2cfeeba563c1504b7c3abe6e0c79993fd3b3cae004e698168b96
join
public static String join(String[] s, String on)
{    return join(Arrays.asList(s), on);}
6d465ffa357f00370b23d8a20e45521cdcf1081146fcb286e47fc8f10a014157
isNullOrEmpty
public static boolean isNullOrEmpty(String s)
{    return s == null || s.isEmpty();}
7208f1d4226d08075e56d544543e342d96f81551c20a1b041a6980ad2ef0428f
expandGlob
public static List<String> expandGlob(String globPattern)
{    return GlobExpander.expand(globPattern);}
370d5f7600ba284f57ff4caa8e2558eb7e93ce3faaabb159eb6274bad648828f
expandGlobToWildCardPaths
public static List<WildcardPath> expandGlobToWildCardPaths(String globPattern, char delim)
{    List<WildcardPath> ret = new ArrayList<WildcardPath>();    for (String expandedGlob : Strings.expandGlob(globPattern)) {        ret.add(new WildcardPath(globPattern, expandedGlob, delim));    }    return ret;}
fc2e1147e17bff9fb76e5024f97a214f4331b7056d88cf70ce98821e169fd5d0
getConstructedClass
public Class<? extends C> getConstructedClass()
{    return constructed;}
9aa9b6b8af103c3ad14bbed96086495943c10653293b7b031181a5dc64aaf91e
newInstanceChecked
public C newInstanceChecked(Object... args) throws Exception
{    try {        return ctor.newInstance(args);    } catch (InstantiationException e) {        throw e;    } catch (IllegalAccessException e) {        throw e;    } catch (InvocationTargetException e) {        throwIfInstance(e.getCause(), Exception.class);        throwIfInstance(e.getCause(), RuntimeException.class);        throw new RuntimeException(e.getCause());    }}
02b7d8a67eb0cdf1a9bd5f8865adeb119cbce761f8dfdf628323eb26bd14d4e8
newInstance
public C newInstance(Object... args)
{    try {        return newInstanceChecked(args);    } catch (Exception e) {        throwIfInstance(e, RuntimeException.class);        throw new RuntimeException(e);    }}
3da74e3f0ace7637d8c2fc5ee8f3671c234682521998492c004e8395a505b0b2
invoke
public R invoke(Object target, Object... args)
{    Preconditions.checkArgument(target == null, "Invalid call to constructor: target must be null");    return (R) newInstance(args);}
baec652c63702ae4a690e75e27cddbd9c9bffb6c440e385e2e954143f2a5f03b
invokeChecked
public R invokeChecked(Object target, Object... args) throws Exception
{    Preconditions.checkArgument(target == null, "Invalid call to constructor: target must be null");    return (R) newInstanceChecked(args);}
1eb0d8d3e25efc8fbdfc89c0735eee0bebb4a798e01bf9f6adeace92d040d5bc
bind
public DynMethods.BoundMethod bind(Object receiver)
{    throw new IllegalStateException("Cannot bind constructors");}
d7bd172131e63c8aab950cfe8184e7f0a4665220ee471355d1ad0ecd78725249
isStatic
public boolean isStatic()
{    return true;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return getClass().getSimpleName() + "(constructor=" + ctor + ", class=" + constructed + ")";}
a48cc30e2eb15e31f6a4c413e8b123ac13a122b598c400fb930e6c101ec6e104
loader
public Builder loader(ClassLoader loader)
{    this.loader = loader;    return this;}
20aee5a0f9e39d0c229566a1749580cd41f0dc66659bf2471a53d7c44dab9e5d
impl
public Builder impl(String className, Class<?>... types)
{        if (ctor != null) {        return this;    }    try {        Class<?> targetClass = Class.forName(className, true, loader);        impl(targetClass, types);    } catch (NoClassDefFoundError e) {                problems.put(className, e);    } catch (ClassNotFoundException e) {                problems.put(className, e);    }    return this;}
78a1085123e13f694c83435d2a55956223b170617a137a1dffb6d2cc013c4307
impl
public Builder impl(Class<T> targetClass, Class<?>... types)
{        if (ctor != null) {        return this;    }    try {        ctor = new Ctor<T>(targetClass.getConstructor(types), targetClass);    } catch (NoSuchMethodException e) {                problems.put(methodName(targetClass, types), e);    }    return this;}
c6a0c9ebd5826a8b111e1e9483f9dd23d8e540119f8bfe5029a44b9d64439306
hiddenImpl
public Builder hiddenImpl(Class<?>... types)
{    hiddenImpl(baseClass, types);    return this;}
cfbcfbffeb880a5bf8140bbec429ecd63afd11aeebc9a7a64fd72ba1f3902bf9
hiddenImpl
public Builder hiddenImpl(String className, Class<?>... types)
{        if (ctor != null) {        return this;    }    try {        Class targetClass = Class.forName(className, true, loader);        hiddenImpl(targetClass, types);    } catch (NoClassDefFoundError e) {                problems.put(className, e);    } catch (ClassNotFoundException e) {                problems.put(className, e);    }    return this;}
b762da3c4de23e623e1a6b7ef85136b38932c0b7b58cd9799acb3d93524d5d40
hiddenImpl
public Builder hiddenImpl(Class<T> targetClass, Class<?>... types)
{        if (ctor != null) {        return this;    }    try {        Constructor<T> hidden = targetClass.getDeclaredConstructor(types);        AccessController.doPrivileged(new MakeAccessible(hidden));        ctor = new Ctor<T>(hidden, targetClass);    } catch (SecurityException e) {                problems.put(methodName(targetClass, types), e);    } catch (NoSuchMethodException e) {                problems.put(methodName(targetClass, types), e);    }    return this;}
cd0acb9bd0f290001beb2c333c0530b35ddee8f35ea0305ef80ba56bbb43f04f
buildChecked
public Ctor<C> buildChecked() throws NoSuchMethodException
{    if (ctor != null) {        return ctor;    }    throw new NoSuchMethodException("Cannot find constructor for " + baseClass + "\n" + formatProblems(problems));}
dbed49ea30e73a7c1022e52d02b3f93b6c623aac1102310287a41cf800875e3f
build
public Ctor<C> build()
{    if (ctor != null) {        return ctor;    }    throw new RuntimeException("Cannot find constructor for " + baseClass + "\n" + formatProblems(problems));}
a77e2f85757b4876c5c34d20cca9aba6bd4475b939d3cc84faec8c4e779f882f
run
public Void run()
{    hidden.setAccessible(true);    return null;}
c46358a3418abc7a39796b79a2112bdcc28ccb359781da7fe794b046a863e359
formatProblems
private static String formatProblems(Map<String, Throwable> problems)
{    StringBuilder sb = new StringBuilder();    boolean first = true;    for (Map.Entry<String, Throwable> problem : problems.entrySet()) {        if (first) {            first = false;        } else {            sb.append("\n");        }        sb.append("\tMissing ").append(problem.getKey()).append(" [").append(problem.getValue().getClass().getName()).append(": ").append(problem.getValue().getMessage()).append("]");    }    return sb.toString();}
c057e7f47cbfce762e1999ef33a2e0fc80a94ab4166db34d34f1bbf6d7c166fc
methodName
private static String methodName(Class<?> targetClass, Class<?>... types)
{    StringBuilder sb = new StringBuilder();    sb.append(targetClass.getName()).append("(");    boolean first = true;    for (Class<?> type : types) {        if (first) {            first = false;        } else {            sb.append(",");        }        sb.append(type.getName());    }    sb.append(")");    return sb.toString();}
baec652c63702ae4a690e75e27cddbd9c9bffb6c440e385e2e954143f2a5f03b
invokeChecked
public R invokeChecked(Object target, Object... args) throws Exception
{    try {        if (argLength < 0) {            return (R) method.invoke(target, args);        } else {            return (R) method.invoke(target, Arrays.copyOfRange(args, 0, argLength));        }    } catch (InvocationTargetException e) {        throwIfInstance(e.getCause(), Exception.class);        throwIfInstance(e.getCause(), RuntimeException.class);        throw new RuntimeException(e.getCause());    }}
3da74e3f0ace7637d8c2fc5ee8f3671c234682521998492c004e8395a505b0b2
invoke
public R invoke(Object target, Object... args)
{    try {        return this.<R>invokeChecked(target, args);    } catch (Exception e) {        throwIfInstance(e, RuntimeException.class);        throw new RuntimeException(e);    }}
cb1bf35cbec9196466513d0618855c609aa2dbcd1363da269a2e15df61945a2a
bind
public BoundMethod bind(Object receiver)
{    Preconditions.checkState(!isStatic(), "Cannot bind static method " + method.toGenericString());    Preconditions.checkArgument(method.getDeclaringClass().isAssignableFrom(receiver.getClass()), "Cannot bind " + method.toGenericString() + " to instance of " + receiver.getClass());    return new BoundMethod(this, receiver);}
d7bd172131e63c8aab950cfe8184e7f0a4665220ee471355d1ad0ecd78725249
isStatic
public boolean isStatic()
{    return Modifier.isStatic(method.getModifiers());}
b3729a765933481a8b7e069f10510f56b0c7b57f5291db046e595c12a8a1ac86
isNoop
public boolean isNoop()
{    return this == NOOP;}
1e619d8fc1350141f7269819ea3de4925253bfb8c8827e50b7b56cb3be56dead
asStatic
public StaticMethod asStatic()
{    Preconditions.checkState(isStatic(), "Method is not static");    return new StaticMethod(this);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "DynMethods.UnboundMethod(name=" + name + " method=" + method.toGenericString() + ")";}
baec652c63702ae4a690e75e27cddbd9c9bffb6c440e385e2e954143f2a5f03b
invokeChecked
public R invokeChecked(Object target, Object... args) throws Exception
{    return null;}
cb1bf35cbec9196466513d0618855c609aa2dbcd1363da269a2e15df61945a2a
bind
public BoundMethod bind(Object receiver)
{    return new BoundMethod(this, receiver);}
1e619d8fc1350141f7269819ea3de4925253bfb8c8827e50b7b56cb3be56dead
asStatic
public StaticMethod asStatic()
{    return new StaticMethod(this);}
d7bd172131e63c8aab950cfe8184e7f0a4665220ee471355d1ad0ecd78725249
isStatic
public boolean isStatic()
{    return true;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "DynMethods.UnboundMethod(NOOP)";}
99d0772e6da0fc16200613410c7a4346c24619c634c6b5142bdaaab3c1fe88bd
invokeChecked
public R invokeChecked(Object... args) throws Exception
{    return method.invokeChecked(receiver, args);}
22f87df0955c94559332411396829798bc913796907dd49d5e31a5b830381f77
invoke
public R invoke(Object... args)
{    return method.invoke(receiver, args);}
99d0772e6da0fc16200613410c7a4346c24619c634c6b5142bdaaab3c1fe88bd
invokeChecked
public R invokeChecked(Object... args) throws Exception
{    return method.invokeChecked(null, args);}
22f87df0955c94559332411396829798bc913796907dd49d5e31a5b830381f77
invoke
public R invoke(Object... args)
{    return method.invoke(null, args);}
a48cc30e2eb15e31f6a4c413e8b123ac13a122b598c400fb930e6c101ec6e104
loader
public Builder loader(ClassLoader loader)
{    this.loader = loader;    return this;}
fff5d8e3aac4285f9f05bfa8db58e7440c9c997650c2de081d78becd86d0d1b3
orNoop
public Builder orNoop()
{    if (method == null) {        this.method = UnboundMethod.NOOP;    }    return this;}
593e8c57e5b177d34549cffd2323fe5c3d298e3284b64f78e5708a0de753ecf9
impl
public Builder impl(String className, String methodName, Class<?>... argClasses)
{        if (method != null) {        return this;    }    try {        Class<?> targetClass = Class.forName(className, true, loader);        impl(targetClass, methodName, argClasses);    } catch (ClassNotFoundException e) {        }    return this;}
8bd6c28512998400026abc80f69d056d1a99df2f7f512f95bbcb1389cc1e46c3
impl
public Builder impl(String className, Class<?>... argClasses)
{    impl(className, name, argClasses);    return this;}
633e13492a34ff8428b160f3fd661bdf08791749c61a5221d76edcffa2c96dd5
impl
public Builder impl(Class<?> targetClass, String methodName, Class<?>... argClasses)
{        if (method != null) {        return this;    }    try {        this.method = new UnboundMethod(targetClass.getMethod(methodName, argClasses), name);    } catch (NoSuchMethodException e) {        }    return this;}
b4fa6318b36abdcab5b38372e3a9cd734059156bd1c0d2cb2654db967280d934
impl
public Builder impl(Class<?> targetClass, Class<?>... argClasses)
{    impl(targetClass, name, argClasses);    return this;}
cbb3149049093ceebbbe728e51d0b414cc009bbd11f3546629da4c7bc0499b2a
ctorImpl
public Builder ctorImpl(Class<?> targetClass, Class<?>... argClasses)
{        if (method != null) {        return this;    }    try {        this.method = new DynConstructors.Builder().impl(targetClass, argClasses).buildChecked();    } catch (NoSuchMethodException e) {        }    return this;}
3230e1418a22f72c9e7d1a594fb7109ab6b80d4a1572ccce88e3d9690566c7e9
ctorImpl
public Builder ctorImpl(String className, Class<?>... argClasses)
{        if (method != null) {        return this;    }    try {        this.method = new DynConstructors.Builder().impl(className, argClasses).buildChecked();    } catch (NoSuchMethodException e) {        }    return this;}
c71e62248232ca01d416988df7f0e2c303660bab3aecd8a694d7b2973457ef41
hiddenImpl
public Builder hiddenImpl(String className, String methodName, Class<?>... argClasses)
{        if (method != null) {        return this;    }    try {        Class<?> targetClass = Class.forName(className, true, loader);        hiddenImpl(targetClass, methodName, argClasses);    } catch (ClassNotFoundException e) {        }    return this;}
d59d84d633f0b50c7cbbe971394433747b43110f91f17ae4546719aca762f95b
hiddenImpl
public Builder hiddenImpl(String className, Class<?>... argClasses)
{    hiddenImpl(className, name, argClasses);    return this;}
977214eef00e8a7ee99208a47cb1a2f1f6f20fecb8c8108bd121c0d24c0e99ba
hiddenImpl
public Builder hiddenImpl(Class<?> targetClass, String methodName, Class<?>... argClasses)
{        if (method != null) {        return this;    }    try {        Method hidden = targetClass.getDeclaredMethod(methodName, argClasses);        AccessController.doPrivileged(new MakeAccessible(hidden));        this.method = new UnboundMethod(hidden, name);    } catch (SecurityException e) {        } catch (NoSuchMethodException e) {        }    return this;}
a68ca2da9f99cd782d7d7c2d23e845602a7301318ca62615ccbe92ee0445ec66
hiddenImpl
public Builder hiddenImpl(Class<?> targetClass, Class<?>... argClasses)
{    hiddenImpl(targetClass, name, argClasses);    return this;}
88068f942a9637b4ccec0a2cf0d10281078ba5f3a24806212acb5641958784dc
buildChecked
public UnboundMethod buildChecked() throws NoSuchMethodException
{    if (method != null) {        return method;    } else {        throw new NoSuchMethodException("Cannot find method: " + name);    }}
1eb9cab93b8597b32fe1ce58fd44e93df68c1f1894d72c1c50f15da6125fb806
build
public UnboundMethod build()
{    if (method != null) {        return method;    } else {        throw new RuntimeException("Cannot find method: " + name);    }}
4f8f29a3024ce27d95d64490bea2af2e9e9b176454d83cb82a184a6e02d473fb
buildChecked
public BoundMethod buildChecked(Object receiver) throws NoSuchMethodException
{    return buildChecked().bind(receiver);}
c7d48d1760e31f2513ed9607cf2d3c3171facc10f13c4bca8d7012e237016700
build
public BoundMethod build(Object receiver)
{    return build().bind(receiver);}
932e765fc17a9b26d8c56608a69ede73d8f67c4eecc2b3561c62d25a7fc94e6d
buildStaticChecked
public StaticMethod buildStaticChecked() throws NoSuchMethodException
{    return buildChecked().asStatic();}
af3bf87b08f4e2e8899e0ba544919147de5f61469173e56f0a14c56774abcf94
buildStatic
public StaticMethod buildStatic()
{    return build().asStatic();}
a77e2f85757b4876c5c34d20cca9aba6bd4475b939d3cc84faec8c4e779f882f
run
public Void run()
{    hidden.setAccessible(true);    return null;}
b4ed04b55bfc668f35fea7a16ffd5fc77da05e0fb305d3a51944a44af0bc0017
hasSemanticVersion
public boolean hasSemanticVersion()
{    return hasSemver;}
bda3e5f8210e67af774556f0244da4b8977a816b643b03d66ae3de07d59042be
getSemanticVersion
public SemanticVersion getSemanticVersion()
{    return semver;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    ParsedVersion version = (ParsedVersion) o;    if (appBuildHash != null ? !appBuildHash.equals(version.appBuildHash) : version.appBuildHash != null)        return false;    if (application != null ? !application.equals(version.application) : version.application != null)        return false;    if (this.version != null ? !this.version.equals(version.version) : version.version != null)        return false;    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = application != null ? application.hashCode() : 0;    result = 31 * result + (version != null ? version.hashCode() : 0);    result = 31 * result + (appBuildHash != null ? appBuildHash.hashCode() : 0);    return result;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "ParsedVersion(" + "application=" + application + ", semver=" + version + ", appBuildHash=" + appBuildHash + ')';}
b7ea3ff4fa7cdd71ac093676ea479c0ffedb862a580c4945ccfcba58398f071d
parse
public static ParsedVersion parse(String createdBy) throws VersionParseException
{    Matcher matcher = PATTERN.matcher(createdBy);    if (!matcher.matches()) {        throw new VersionParseException("Could not parse created_by: " + createdBy + " using format: " + FORMAT);    }    String application = matcher.group(1);    String semver = matcher.group(2);    String appBuildHash = matcher.group(3);    if (Strings.isNullOrEmpty(application)) {        throw new VersionParseException("application cannot be null or empty");    }    return new ParsedVersion(application, semver, appBuildHash);}
55cc4406bfcef1358f4b6cef2e37755d6fd854f14b8b444994d5764129f4c1c7
testRead0
public void testRead0() throws Exception
{    byte[] bytes = new byte[0];    ByteBufferInputStream stream = newStream();    Assert.assertEquals("Should read 0 bytes", 0, stream.read(bytes));    int bytesRead = stream.read(new byte[100]);    Assert.assertTrue("Should read to end of stream", bytesRead < 100);    Assert.assertEquals("Should read 0 bytes at end of stream", 0, stream.read(bytes));}
ffa54caf2a03012122c6ca12aeab972494b4d70dead598e81469a7569fac4642
testReadAll
public void testReadAll() throws Exception
{    byte[] bytes = new byte[35];    ByteBufferInputStream stream = newStream();    int bytesRead = stream.read(bytes);    Assert.assertEquals("Should read the entire buffer", bytes.length, bytesRead);    for (int i = 0; i < bytes.length; i += 1) {        Assert.assertEquals("Byte i should be i", i, bytes[i]);        Assert.assertEquals("Should advance position", 35, stream.position());    }    Assert.assertEquals("Should have no more remaining content", 0, stream.available());    Assert.assertEquals("Should return -1 at end of stream", -1, stream.read(bytes));    Assert.assertEquals("Should have no more remaining content", 0, stream.available());    checkOriginalData();}
4c0295ab3d061bce4463b414fa2c5089f8206595e08c86eb376ae3fc3a821f07
testSmallReads
public void testSmallReads() throws Exception
{    for (int size = 1; size < 36; size += 1) {        byte[] bytes = new byte[size];        ByteBufferInputStream stream = newStream();        long length = stream.available();        int lastBytesRead = bytes.length;        for (int offset = 0; offset < length; offset += bytes.length) {            Assert.assertEquals("Should read requested len", bytes.length, lastBytesRead);            lastBytesRead = stream.read(bytes, 0, bytes.length);            Assert.assertEquals("Should advance position", offset + lastBytesRead, stream.position());                        for (int i = 0; i < lastBytesRead; i += 1) {                Assert.assertEquals("Byte i should be i", offset + i, bytes[i]);            }        }        Assert.assertEquals("Should read fewer bytes at end of buffer", length % bytes.length, lastBytesRead % bytes.length);        Assert.assertEquals("Should have no more remaining content", 0, stream.available());        Assert.assertEquals("Should return -1 at end of stream", -1, stream.read(bytes));        Assert.assertEquals("Should have no more remaining content", 0, stream.available());    }    checkOriginalData();}
1c93bce2700d51e0d8f6307c0b685243c1d95378a43d224194ca7eaa66eaa81e
testPartialBufferReads
public void testPartialBufferReads() throws Exception
{    for (int size = 1; size < 35; size += 1) {        byte[] bytes = new byte[33];        ByteBufferInputStream stream = newStream();        int lastBytesRead = size;        for (int offset = 0; offset < bytes.length; offset += size) {            Assert.assertEquals("Should read requested len", size, lastBytesRead);            lastBytesRead = stream.read(bytes, offset, Math.min(size, bytes.length - offset));            Assert.assertEquals("Should advance position", lastBytesRead > 0 ? offset + lastBytesRead : offset, stream.position());        }        Assert.assertEquals("Should read fewer bytes at end of buffer", bytes.length % size, lastBytesRead % size);        for (int i = 0; i < bytes.length; i += 1) {            Assert.assertEquals("Byte i should be i", i, bytes[i]);        }        Assert.assertEquals("Should have no more remaining content", 2, stream.available());        Assert.assertEquals("Should return 2 more bytes", 2, stream.read(bytes));        Assert.assertEquals("Should have no more remaining content", 0, stream.available());        Assert.assertEquals("Should return -1 at end of stream", -1, stream.read(bytes));        Assert.assertEquals("Should have no more remaining content", 0, stream.available());    }    checkOriginalData();}
a2e4740555cd643b64923047f088718f417925997d38ed367f0e87d84b162943
testReadByte
public void testReadByte() throws Exception
{    final ByteBufferInputStream stream = newStream();    int length = stream.available();    for (int i = 0; i < length; i += 1) {        Assert.assertEquals("Position should increment", i, stream.position());        Assert.assertEquals(i, stream.read());    }    assertThrows("Should throw EOFException at end of stream", EOFException.class, (Callable<Integer>) stream::read);    checkOriginalData();}
e07f1ddbf3e5b24e0c815f6c2d045092795cd5b73af05a463a0fda641f445c60
testSlice
public void testSlice() throws Exception
{    ByteBufferInputStream stream = newStream();    int length = stream.available();    ByteBuffer empty = stream.slice(0);    Assert.assertNotNull("slice(0) should produce a non-null buffer", empty);    Assert.assertEquals("slice(0) should produce an empty buffer", 0, empty.remaining());    Assert.assertEquals("Position should be at start", 0, stream.position());    int i = 0;    while (stream.available() > 0) {        int bytesToSlice = Math.min(stream.available(), 10);        ByteBuffer buffer = stream.slice(bytesToSlice);        for (int j = 0; j < bytesToSlice; j += 1) {            Assert.assertEquals("Data should be correct", i + j, buffer.get());        }        i += bytesToSlice;    }    Assert.assertEquals("Position should be at end", length, stream.position());    checkOriginalData();}
91b7e3a9fc322cb48ddfa1170dcae1ac8e5792cffb2ffaa9de7122d0a9b66750
testSliceBuffers0
public void testSliceBuffers0() throws Exception
{    ByteBufferInputStream stream = newStream();    Assert.assertEquals("Should return an empty list", Collections.emptyList(), stream.sliceBuffers(0));}
2b92ea8bf45b40f18c1c873958fe06100011eaa87c48a48f5b427c32cb9cbfed
testWholeSliceBuffers
public void testWholeSliceBuffers() throws Exception
{    final ByteBufferInputStream stream = newStream();    final int length = stream.available();    List<ByteBuffer> buffers = stream.sliceBuffers(stream.available());    Assert.assertEquals("Should consume all buffers", length, stream.position());    assertThrows("Should throw EOFException when empty", EOFException.class, (Callable<List<ByteBuffer>>) () -> stream.sliceBuffers(length));    ByteBufferInputStream copy = ByteBufferInputStream.wrap(buffers);    for (int i = 0; i < length; i += 1) {        Assert.assertEquals("Slice should have identical data", i, copy.read());    }    checkOriginalData();}
9f45198b96412fc3f430422fff4c2e36331ef7c3a341da6255a2195bdbd93145
testSliceBuffersCoverage
public void testSliceBuffersCoverage() throws Exception
{    for (int size = 1; size < 36; size += 1) {        ByteBufferInputStream stream = newStream();        int length = stream.available();        List<ByteBuffer> buffers = new ArrayList<>();        while (stream.available() > 0) {            buffers.addAll(stream.sliceBuffers(Math.min(size, stream.available())));        }        Assert.assertEquals("Should consume all content", length, stream.position());        ByteBufferInputStream newStream = new MultiBufferInputStream(buffers);        for (int i = 0; i < length; i += 1) {            Assert.assertEquals("Data should be correct", i, newStream.read());        }    }    checkOriginalData();}
59aaf69e2d841212cc0c34de417d3236719eefc35a46eba9edd6d5b639b0decb
testSliceBuffersModification
public void testSliceBuffersModification() throws Exception
{    ByteBufferInputStream stream = newStream();    int length = stream.available();    int sliceLength = 5;    List<ByteBuffer> buffers = stream.sliceBuffers(sliceLength);    Assert.assertEquals("Should advance the original stream", length - sliceLength, stream.available());    Assert.assertEquals("Should advance the original stream position", sliceLength, stream.position());    Assert.assertEquals("Should return a slice of the first buffer", 1, buffers.size());    ByteBuffer buffer = buffers.get(0);    Assert.assertEquals("Should have requested bytes", sliceLength, buffer.remaining());            buffer.limit(sliceLength + 1);    for (int i = 0; i < sliceLength + 1; i += 1) {        Assert.assertEquals("Should have correct data", i, buffer.get());    }    Assert.assertEquals("Reading a slice shouldn't advance the original stream", sliceLength, stream.position());    Assert.assertEquals("Reading a slice shouldn't change the underlying data", sliceLength, stream.read());        buffer.limit(sliceLength + 2);    int originalValue = buffer.duplicate().get();    ByteBuffer undoBuffer = buffer.duplicate();    try {        buffer.put((byte) 255);        Assert.assertEquals("Writing to a slice shouldn't advance the original stream", sliceLength + 1, stream.position());        Assert.assertEquals("Writing to a slice should change the underlying data", 255, stream.read());    } finally {        undoBuffer.put((byte) originalValue);    }}
015b2b6b16b8c27ce77fd9133f4b8e8ee01136e1798169674fcdcb010616e4ec
testSkip
public void testSkip() throws Exception
{    ByteBufferInputStream stream = newStream();    while (stream.available() > 0) {        int bytesToSkip = Math.min(stream.available(), 10);        Assert.assertEquals("Should skip all, regardless of backing buffers", bytesToSkip, stream.skip(bytesToSkip));    }    stream = newStream();    Assert.assertEquals(0, stream.skip(0));    int length = stream.available();    Assert.assertEquals("Should stop at end when out of bytes", length, stream.skip(length + 10));    Assert.assertEquals("Should return -1 when at end", -1, stream.skip(10));}
499d334f3795f800b08fe956ecf69bdfac6d207407e307316056211cec7a445f
testSkipFully
public void testSkipFully() throws Exception
{    ByteBufferInputStream stream = newStream();    long lastPosition = 0;    while (stream.available() > 0) {        int bytesToSkip = Math.min(stream.available(), 10);        stream.skipFully(bytesToSkip);        Assert.assertEquals("Should skip all, regardless of backing buffers", bytesToSkip, stream.position() - lastPosition);        lastPosition = stream.position();    }    final ByteBufferInputStream stream2 = newStream();    stream2.skipFully(0);    Assert.assertEquals(0, stream2.position());    final int length = stream2.available();    assertThrows("Should throw when out of bytes", EOFException.class, () -> {        stream2.skipFully(length + 10);        return null;    });}
ba8b322048dea065207329508fcb51e6b0c5be70da0c4c785e5e5efe2cc288a7
testMark
public void testMark() throws Exception
{    ByteBufferInputStream stream = newStream();    stream.read(new byte[7]);    stream.mark(100);    long mark = stream.position();    byte[] expected = new byte[100];    int expectedBytesRead = stream.read(expected);    long end = stream.position();    stream.reset();    Assert.assertEquals("Position should return to the mark", mark, stream.position());    byte[] afterReset = new byte[100];    int bytesReadAfterReset = stream.read(afterReset);    Assert.assertEquals("Should read the same number of bytes", expectedBytesRead, bytesReadAfterReset);    Assert.assertEquals("Read should end at the same position", end, stream.position());    Assert.assertArrayEquals("Content should be equal", expected, afterReset);}
820ed1ebc14fc0079d488d047d9fc0b6d123147928ba517e52417f993cbefe62
testMarkTwice
public void testMarkTwice() throws Exception
{    ByteBufferInputStream stream = newStream();    stream.read(new byte[7]);    stream.mark(1);    stream.mark(100);    long mark = stream.position();    byte[] expected = new byte[100];    int expectedBytesRead = stream.read(expected);    long end = stream.position();    stream.reset();    Assert.assertEquals("Position should return to the mark", mark, stream.position());    byte[] afterReset = new byte[100];    int bytesReadAfterReset = stream.read(afterReset);    Assert.assertEquals("Should read the same number of bytes", expectedBytesRead, bytesReadAfterReset);    Assert.assertEquals("Read should end at the same position", end, stream.position());    Assert.assertArrayEquals("Content should be equal", expected, afterReset);}
127fc7236098144e2583ce79ae9ca51100507f735951e2edde89324528c6dbe0
testMarkAtStart
public void testMarkAtStart() throws Exception
{    ByteBufferInputStream stream = newStream();    stream.mark(100);    long mark = stream.position();    byte[] expected = new byte[10];    Assert.assertEquals("Should read 10 bytes", 10, stream.read(expected));    long end = stream.position();    stream.reset();    Assert.assertEquals("Position should return to the mark", mark, stream.position());    byte[] afterReset = new byte[10];    Assert.assertEquals("Should read 10 bytes", 10, stream.read(afterReset));    Assert.assertEquals("Read should end at the same position", end, stream.position());    Assert.assertArrayEquals("Content should be equal", expected, afterReset);}
8705230eb21a1655389566eaeed1df4fb9598485f994214fc4394a4b968b9057
testMarkAtEnd
public void testMarkAtEnd() throws Exception
{    ByteBufferInputStream stream = newStream();    int bytesRead = stream.read(new byte[100]);    Assert.assertTrue("Should read to end of stream", bytesRead < 100);    stream.mark(100);    long mark = stream.position();    byte[] expected = new byte[10];    Assert.assertEquals("Should read 0 bytes", -1, stream.read(expected));    long end = stream.position();    stream.reset();    Assert.assertEquals("Position should return to the mark", mark, stream.position());    byte[] afterReset = new byte[10];    Assert.assertEquals("Should read 0 bytes", -1, stream.read(afterReset));    Assert.assertEquals("Read should end at the same position", end, stream.position());    Assert.assertArrayEquals("Content should be equal", expected, afterReset);}
5565a9f39a7e6dd60eb7e19ffe448b74548f92612761675ff74de9869a20de04
testMarkUnset
public void testMarkUnset()
{    final ByteBufferInputStream stream = newStream();    assertThrows("Should throw an error for reset() without mark()", IOException.class, () -> {        stream.reset();        return null;    });}
d18a715a1fa0ad711fb2cc4fdb40e26d6933efb580888a66406d75719cca882d
testMarkAndResetTwiceOverSameRange
public void testMarkAndResetTwiceOverSameRange() throws Exception
{    final ByteBufferInputStream stream = newStream();    byte[] expected = new byte[6];    stream.mark(10);    Assert.assertEquals("Should read expected bytes", expected.length, stream.read(expected));    stream.reset();    stream.mark(10);    byte[] firstRead = new byte[6];    Assert.assertEquals("Should read firstRead bytes", firstRead.length, stream.read(firstRead));    stream.reset();    byte[] secondRead = new byte[6];    Assert.assertEquals("Should read secondRead bytes", secondRead.length, stream.read(secondRead));    Assert.assertArrayEquals("First read should be correct", expected, firstRead);    Assert.assertArrayEquals("Second read should be correct", expected, secondRead);}
7b6b12e1421cc435f9a08df630a324958e35a6e14a9ac8d466101eedeae85d31
testMarkLimit
public void testMarkLimit() throws Exception
{    final ByteBufferInputStream stream = newStream();    stream.mark(5);    Assert.assertEquals("Should read 5 bytes", 5, stream.read(new byte[5]));    stream.reset();    Assert.assertEquals("Should read 6 bytes", 6, stream.read(new byte[6]));    assertThrows("Should throw an error for reset() after limit", IOException.class, () -> {        stream.reset();        return null;    });}
44cae0a5c7a69a808e8d0dec6ba1168b3c0d30608b950659d9d410bf8e7a1152
testMarkDoubleReset
public void testMarkDoubleReset() throws Exception
{    final ByteBufferInputStream stream = newStream();    stream.mark(5);    Assert.assertEquals("Should read 5 bytes", 5, stream.read(new byte[5]));    stream.reset();    assertThrows("Should throw an error for double reset()", IOException.class, () -> {        stream.reset();        return null;    });}
54881071acb3559b34b864ac98b3ee7dc6cb84d8f4436ef22218ce718078f82a
testToByteBuffer
public void testToByteBuffer()
{    final ByteBufferInputStream stream = newStream();    ByteBuffer buffer = stream.toByteBuffer();    for (int i = 0; i < DATA_LENGTH; ++i) {        assertEquals(i, buffer.get());    }}
d54ae37b15047137d77db38fa1b84620ac079ebc22c52523675be58707583c68
assertThrows
public static void assertThrows(String message, Class<? extends Exception> expected, Callable callable)
{    try {        callable.call();        Assert.fail("No exception was thrown (" + message + "), expected: " + expected.getName());    } catch (Exception actual) {        try {            Assert.assertEquals(message, expected, actual.getClass());        } catch (AssertionError e) {            e.addSuppressed(actual);            throw e;        }    }}
b11992f9f446051260d0f1fec5f67d76c106aa797bdf35643be3c92f397f03d9
testWidth
public void testWidth()
{    assertEquals(0, getWidthFromMaxInt(0));    assertEquals(1, getWidthFromMaxInt(1));    assertEquals(2, getWidthFromMaxInt(2));    assertEquals(2, getWidthFromMaxInt(3));    assertEquals(3, getWidthFromMaxInt(4));    assertEquals(3, getWidthFromMaxInt(5));    assertEquals(3, getWidthFromMaxInt(6));    assertEquals(3, getWidthFromMaxInt(7));    assertEquals(4, getWidthFromMaxInt(8));    assertEquals(4, getWidthFromMaxInt(15));    assertEquals(5, getWidthFromMaxInt(16));    assertEquals(5, getWidthFromMaxInt(31));    assertEquals(6, getWidthFromMaxInt(32));    assertEquals(6, getWidthFromMaxInt(63));    assertEquals(7, getWidthFromMaxInt(64));    assertEquals(7, getWidthFromMaxInt(127));    assertEquals(8, getWidthFromMaxInt(128));    assertEquals(8, getWidthFromMaxInt(255));}
d53d26e51bea7d783c5afce7cd83ddd7c832c4eae8472715975f3ed27a053617
parameters
public static List<Object[]> parameters()
{    return Arrays.asList(new Object[] { TestSingleBufferInputStream.DATA, null }, new Object[] { TestSingleBufferInputStream.DATA, 0 }, new Object[] { ByteBuffer.wrap(new byte[] { -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34 }), 4 }, new Object[] { ByteBuffer.wrap(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, -1, -1, -1 }), 0 }, new Object[] { ByteBuffer.wrap(new byte[] { -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, -1, -1 }), 3 });}
b0ce38f579360082f1a90a8522028eea9f9358ed1589b3de4bd88b594b0f18b1
newStream
protected ByteBufferInputStream newStream()
{    if (offset == null) {        return new ByteBufferInputStream(data);    } else {        return new ByteBufferInputStream(data, offset, DATA_LENGTH);    }}
cde7078624dc48ad616d2e1e8953906ad6e2575df7337c5c8df55f9ba0481fc3
checkOriginalData
protected void checkOriginalData()
{    Assert.assertEquals("Position should not change", 0, data.position());    Assert.assertEquals("Limit should not change", data.array().length, data.limit());}
5791aad0a05ba972917b47211c4528d86d34bba48b1c51f5aced200db4881e56
testSliceData
public void testSliceData() throws Exception
{    ByteBufferInputStream stream = newStream();    int length = stream.available();    List<ByteBuffer> buffers = new ArrayList<>();        while (stream.available() > 0) {        int bytesToSlice = Math.min(stream.available(), 8);        buffers.add(stream.slice(bytesToSlice));    }    Assert.assertEquals("Position should be at end", length, stream.position());    Assert.assertEquals("Should produce 5 buffers", 5, buffers.size());    int i = 0;    ByteBuffer one = buffers.get(0);    Assert.assertSame("Should use the same backing array", one.array(), data.array());    Assert.assertEquals(8, one.remaining());    Assert.assertEquals(0, one.position());    Assert.assertEquals(8, one.limit());    for (; i < 8; i += 1) {        Assert.assertEquals("Should produce correct values", i, one.get());    }    ByteBuffer two = buffers.get(1);    Assert.assertSame("Should use the same backing array", two.array(), data.array());    Assert.assertEquals(8, two.remaining());    Assert.assertEquals(8, two.position());    Assert.assertEquals(16, two.limit());    for (; i < 16; i += 1) {        Assert.assertEquals("Should produce correct values", i, two.get());    }        ByteBuffer three = buffers.get(2);    Assert.assertSame("Should use the same backing array", three.array(), data.array());    Assert.assertEquals(8, three.remaining());    Assert.assertEquals(16, three.position());    Assert.assertEquals(24, three.limit());    for (; i < 24; i += 1) {        Assert.assertEquals("Should produce correct values", i, three.get());    }        ByteBuffer four = buffers.get(3);    Assert.assertSame("Should use the same backing array", four.array(), data.array());    Assert.assertEquals(8, four.remaining());    Assert.assertEquals(24, four.position());    Assert.assertEquals(32, four.limit());    for (; i < 32; i += 1) {        Assert.assertEquals("Should produce correct values", i, four.get());    }        ByteBuffer five = buffers.get(4);    Assert.assertSame("Should use the same backing array", five.array(), data.array());    Assert.assertEquals(3, five.remaining());    Assert.assertEquals(32, five.position());    Assert.assertEquals(35, five.limit());    for (; i < 35; i += 1) {        Assert.assertEquals("Should produce correct values", i, five.get());    }}
47b3f5e114adbce6f725dfc5f9296018aa96dd3481cbc7faccd4c81304d907a5
testWholeSliceBuffersData
public void testWholeSliceBuffersData() throws Exception
{    ByteBufferInputStream stream = newStream();    List<ByteBuffer> buffers = stream.sliceBuffers(stream.available());    Assert.assertEquals("Should return duplicates of all non-empty buffers", Collections.singletonList(TestSingleBufferInputStream.DATA), buffers);}
b0ce38f579360082f1a90a8522028eea9f9358ed1589b3de4bd88b594b0f18b1
newStream
protected ByteBufferInputStream newStream()
{    return new MultiBufferInputStream(DATA);}
cde7078624dc48ad616d2e1e8953906ad6e2575df7337c5c8df55f9ba0481fc3
checkOriginalData
protected void checkOriginalData()
{    for (ByteBuffer buffer : DATA) {        Assert.assertEquals("Position should not change", 0, buffer.position());        Assert.assertEquals("Limit should not change", buffer.array().length, buffer.limit());    }}
5791aad0a05ba972917b47211c4528d86d34bba48b1c51f5aced200db4881e56
testSliceData
public void testSliceData() throws Exception
{    ByteBufferInputStream stream = newStream();    int length = stream.available();    List<ByteBuffer> buffers = new ArrayList<>();        while (stream.available() > 0) {        int bytesToSlice = Math.min(stream.available(), 8);        buffers.add(stream.slice(bytesToSlice));    }    Assert.assertEquals("Position should be at end", length, stream.position());    Assert.assertEquals("Should produce 5 buffers", 5, buffers.size());    int i = 0;        ByteBuffer one = buffers.get(0);    Assert.assertSame("Should be a duplicate of the first array", one.array(), DATA.get(0).array());    Assert.assertEquals(8, one.remaining());    Assert.assertEquals(0, one.position());    Assert.assertEquals(8, one.limit());    Assert.assertEquals(9, one.capacity());    for (; i < 8; i += 1) {        Assert.assertEquals("Should produce correct values", i, one.get());    }        ByteBuffer two = buffers.get(1);    Assert.assertEquals(8, two.remaining());    Assert.assertEquals(0, two.position());    Assert.assertEquals(8, two.limit());    Assert.assertEquals(8, two.capacity());    for (; i < 16; i += 1) {        Assert.assertEquals("Should produce correct values", i, two.get());    }        ByteBuffer three = buffers.get(2);    Assert.assertSame("Should be a duplicate of the fourth array", three.array(), DATA.get(3).array());    Assert.assertEquals(8, three.remaining());    Assert.assertEquals(3, three.position());    Assert.assertEquals(11, three.limit());    Assert.assertEquals(12, three.capacity());    for (; i < 24; i += 1) {        Assert.assertEquals("Should produce correct values", i, three.get());    }        ByteBuffer four = buffers.get(3);    Assert.assertEquals(8, four.remaining());    Assert.assertEquals(0, four.position());    Assert.assertEquals(8, four.limit());    Assert.assertEquals(8, four.capacity());    for (; i < 32; i += 1) {        Assert.assertEquals("Should produce correct values", i, four.get());    }        ByteBuffer five = buffers.get(4);    Assert.assertEquals(3, five.remaining());    Assert.assertEquals(0, five.position());    Assert.assertEquals(3, five.limit());    Assert.assertEquals(3, five.capacity());    for (; i < 35; i += 1) {        Assert.assertEquals("Should produce correct values", i, five.get());    }}
bbc066351f82a416e1572186b5ae960e9310afeb266cfeac3429d2f5cccf593d
testSliceBuffersData
public void testSliceBuffersData() throws Exception
{    ByteBufferInputStream stream = newStream();    List<ByteBuffer> buffers = stream.sliceBuffers(stream.available());    List<ByteBuffer> nonEmptyBuffers = new ArrayList<>();    for (ByteBuffer buffer : DATA) {        if (buffer.remaining() > 0) {            nonEmptyBuffers.add(buffer);        }    }    Assert.assertEquals("Should return duplicates of all non-empty buffers", nonEmptyBuffers, buffers);}
b0ce38f579360082f1a90a8522028eea9f9358ed1589b3de4bd88b594b0f18b1
newStream
protected ByteBufferInputStream newStream()
{    return new SingleBufferInputStream(DATA);}
cde7078624dc48ad616d2e1e8953906ad6e2575df7337c5c8df55f9ba0481fc3
checkOriginalData
protected void checkOriginalData()
{    Assert.assertEquals("Position should not change", 0, DATA.position());    Assert.assertEquals("Limit should not change", DATA.array().length, DATA.limit());}
5791aad0a05ba972917b47211c4528d86d34bba48b1c51f5aced200db4881e56
testSliceData
public void testSliceData() throws Exception
{    ByteBufferInputStream stream = newStream();    int length = stream.available();    List<ByteBuffer> buffers = new ArrayList<>();        while (stream.available() > 0) {        int bytesToSlice = Math.min(stream.available(), 8);        buffers.add(stream.slice(bytesToSlice));    }    Assert.assertEquals("Position should be at end", length, stream.position());    Assert.assertEquals("Should produce 5 buffers", 5, buffers.size());    int i = 0;    ByteBuffer one = buffers.get(0);    Assert.assertSame("Should use the same backing array", one.array(), DATA.array());    Assert.assertEquals(8, one.remaining());    Assert.assertEquals(0, one.position());    Assert.assertEquals(8, one.limit());    Assert.assertEquals(35, one.capacity());    for (; i < 8; i += 1) {        Assert.assertEquals("Should produce correct values", i, one.get());    }    ByteBuffer two = buffers.get(1);    Assert.assertSame("Should use the same backing array", two.array(), DATA.array());    Assert.assertEquals(8, two.remaining());    Assert.assertEquals(8, two.position());    Assert.assertEquals(16, two.limit());    Assert.assertEquals(35, two.capacity());    for (; i < 16; i += 1) {        Assert.assertEquals("Should produce correct values", i, two.get());    }        ByteBuffer three = buffers.get(2);    Assert.assertSame("Should use the same backing array", three.array(), DATA.array());    Assert.assertEquals(8, three.remaining());    Assert.assertEquals(16, three.position());    Assert.assertEquals(24, three.limit());    Assert.assertEquals(35, three.capacity());    for (; i < 24; i += 1) {        Assert.assertEquals("Should produce correct values", i, three.get());    }        ByteBuffer four = buffers.get(3);    Assert.assertSame("Should use the same backing array", four.array(), DATA.array());    Assert.assertEquals(8, four.remaining());    Assert.assertEquals(24, four.position());    Assert.assertEquals(32, four.limit());    Assert.assertEquals(35, four.capacity());    for (; i < 32; i += 1) {        Assert.assertEquals("Should produce correct values", i, four.get());    }        ByteBuffer five = buffers.get(4);    Assert.assertSame("Should use the same backing array", five.array(), DATA.array());    Assert.assertEquals(3, five.remaining());    Assert.assertEquals(32, five.position());    Assert.assertEquals(35, five.limit());    Assert.assertEquals(35, five.capacity());    for (; i < 35; i += 1) {        Assert.assertEquals("Should produce correct values", i, five.get());    }}
47b3f5e114adbce6f725dfc5f9296018aa96dd3481cbc7faccd4c81304d907a5
testWholeSliceBuffersData
public void testWholeSliceBuffersData() throws Exception
{    ByteBufferInputStream stream = newStream();    List<ByteBuffer> buffers = stream.sliceBuffers(stream.available());    Assert.assertEquals("Should return duplicates of all non-empty buffers", Collections.singletonList(DATA), buffers);}
609ca5bcac3bc8d925915e0f12ffde6deafcacc55525358481ed7c994caede8f
testNoGlobs
public void testNoGlobs()
{    assertEquals(Arrays.asList("foo"), Strings.expandGlob("foo"));}
1395d1725fa3fa9bade4a13e5079baf48a5422548ef939d3526835efb67a9330
testEmptyGroup
public void testEmptyGroup()
{    assertEquals(Arrays.asList(""), Strings.expandGlob(""));    assertEquals(Arrays.asList(""), Strings.expandGlob("{}"));    assertEquals(Arrays.asList("a"), Strings.expandGlob("a{}"));    assertEquals(Arrays.asList("ab"), Strings.expandGlob("a{}b"));    assertEquals(Arrays.asList("a"), Strings.expandGlob("{}a"));    assertEquals(Arrays.asList("a"), Strings.expandGlob("a{}"));    assertEquals(Arrays.asList("", ""), Strings.expandGlob("{,}"));    assertEquals(Arrays.asList("ab", "a", "ac"), Strings.expandGlob("a{b,{},c}"));}
a7439108f83598e41d943170e96f5133dfdbbf637ffe3b4e18ffb206c864e0ed
testSingleLevel
public void testSingleLevel()
{    assertEquals(Arrays.asList("foobar", "foobaz"), Strings.expandGlob("foo{bar,baz}"));    assertEquals(Arrays.asList("startfooend", "startbarend"), Strings.expandGlob("start{foo,bar}end"));    assertEquals(Arrays.asList("fooend", "barend"), Strings.expandGlob("{foo,bar}end"));    assertEquals(Arrays.asList("startfooenda", "startfooendb", "startfooendc", "startfooendd", "startbarenda", "startbarendb", "startbarendc", "startbarendd"), Strings.expandGlob("start{foo,bar}end{a,b,c,d}"));    assertEquals(Arrays.asList("xa", "xb", "xc", "ya", "yb", "yc"), Strings.expandGlob("{x,y}{a,b,c}"));    assertEquals(Arrays.asList("x", "y", "z"), Strings.expandGlob("{x,y,z}"));}
daa7f2c4df81feb87f6cc6b6e0b41c21bf23b020ef3e76b88695a815f03f6e01
testNested
public void testNested()
{    assertEquals(Arrays.asList("startoneend", "startpretwopostend", "startprethreepostend", "startfourend", "startfiveend", "a", "b", "foox", "fooy"), Strings.expandGlob("{start{one,pre{two,three}post,{four,five}}end,a,b,foo{x,y}}"));}
52bd227ed13765e8b84f936cd55aa723257b7e456413413d9637f172c7d096b2
testExtraBraces
public void testExtraBraces()
{    assertEquals(Arrays.asList("x", "y", "z"), Strings.expandGlob("{{x,y,z}}"));    assertEquals(Arrays.asList("x", "y", "z"), Strings.expandGlob("{{{x,y,z}}}"));    assertEquals(Arrays.asList("startx", "starta", "startb", "starty"), Strings.expandGlob("start{x,{a,b},y}"));}
e152a7623816b806d2c2ba3910d8e285a71833981f15603c4a97c139c5ff9108
testCommaInTopLevel
public void testCommaInTopLevel()
{    try {        Strings.expandGlob("foo,bar");        fail("This should throw");    } catch (GlobParseException e) {        Assert.assertEquals("Unexpected comma outside of a {} group:\n" + "foo,bar\n" + "---^", e.getMessage());    }}
4de327a4f44333058b57b2daef879bcbf94acb2943eaca478e65df00aa0b26ca
testCommaCornerCases
public void testCommaCornerCases()
{        assertEquals(Arrays.asList("foobar", "foo", "foobaz"), Strings.expandGlob("foo{bar,,baz}"));    assertEquals(Arrays.asList("foo", "foobar", "foobaz"), Strings.expandGlob("foo{,bar,baz}"));    assertEquals(Arrays.asList("foobar", "foobaz", "foo"), Strings.expandGlob("foo{bar,baz,}"));        assertEquals(Arrays.asList("foobar", "foo", "foo", "foobaz"), Strings.expandGlob("foo{bar,,,baz}"));    assertEquals(Arrays.asList("foo", "foo", "foobar", "foobaz"), Strings.expandGlob("foo{,,bar,baz}"));    assertEquals(Arrays.asList("foobar", "foobaz", "foo", "foo"), Strings.expandGlob("foo{bar,baz,,}"));        assertEquals(Arrays.asList("x", "y", "", "a", "b"), Strings.expandGlob("{{x,y},,{a,b}}"));}
19dc257ce64de560a558a766e366f2b434f8f1f07a953153ae32e9513005894e
assertNotEnoughCloseBraces
private void assertNotEnoughCloseBraces(String s)
{    String expected = "Not enough close braces in: ";    try {        Strings.expandGlob(s);        fail("this should throw");    } catch (GlobParseException e) {        Assert.assertEquals(expected, e.getMessage().substring(0, expected.length()));    }}
ec6e0521a4f35d1c100af5f617bd08957d66923600c45088d0d0b9c7ef7d3b8c
assertTooManyCloseBraces
private void assertTooManyCloseBraces(String s)
{    String expected = "Unexpected closing }:";    try {        Strings.expandGlob(s);        fail("this should throw");    } catch (GlobParseException e) {        Assert.assertEquals(expected, e.getMessage().substring(0, expected.length()));    }}
3e682c32cb1b3fd3106cc58a186f6199fbf8b3733e5f3a6ac69582fd8b7058e3
testMismatchedBraces
public void testMismatchedBraces()
{    assertNotEnoughCloseBraces("{");    assertNotEnoughCloseBraces("{}{}{}{{}{}{");    assertNotEnoughCloseBraces("foo{bar");    assertNotEnoughCloseBraces("foo{{bar}");    assertNotEnoughCloseBraces("foo{}{{bar}");    assertTooManyCloseBraces("{}}{");    assertTooManyCloseBraces("}");    assertTooManyCloseBraces("{}{}{}}{}{}{");    assertTooManyCloseBraces("foo}bar");    assertTooManyCloseBraces("foo}}bar}");    assertTooManyCloseBraces("foo{}{{bar}}}");}
c1c5688f2415476af13516eae8f391ad2656af30cd11efbb3c4c5871568eb3fb
assertMatches
private static void assertMatches(WildcardPath wp, String... strings)
{    for (String s : strings) {        if (!wp.matches(s)) {            fail(String.format("String '%s' was expected to match '%s'", s, wp));        }    }}
20aff0efa41924c38b7d55d13ef54f29582f204688e393f428ff77c8a940bcf5
assertDoesNotMatch
private static void assertDoesNotMatch(WildcardPath wp, String... strings)
{    for (String s : strings) {        if (wp.matches(s)) {            fail(String.format("String '%s' was not expected to match '%s'", s, wp));        }    }}
d1f630959b3847c1b688eeb7c7e61c537d44a8e1d91d50015a3b5f56b95d9561
testNoWildcards
public void testNoWildcards()
{    WildcardPath wp = new WildcardPath("", "foo", '.');    assertMatches(wp, "foo", "foo.x", "foo.x.y");    assertDoesNotMatch(wp, "xfoo", "xfoox", "fooa.x.y");}
651c4ed39c9d44ab7e504d96d91cc21f824376295f6e343d9fb510e732387f55
testStarMatchesEverything
public void testStarMatchesEverything()
{    WildcardPath wp = new WildcardPath("", "*", '.');    assertMatches(wp, "", ".", "hi", "foo.bar", "*", "foo.");}
8926b84750c6aabd8e0c6dfc065563e9baab67e8397f096cf873807707b804f7
testChildrenPathsMatch
public void testChildrenPathsMatch()
{    WildcardPath wp = new WildcardPath("", "x.y.z", '.');    assertMatches(wp, "x.y.z", "x.y.z.bar", "x.y.z.bar.baz.bop");    assertDoesNotMatch(wp, "x.y.zzzz", "x.y.b", "x.y.a.z", "x.y.zhi.z");}
357cc5526358801c58258e45865be1cd68814860f0d259b19873a1fb58b559ce
testEmptyString
public void testEmptyString()
{    WildcardPath wp = new WildcardPath("", "", '.');    assertMatches(wp, "");    assertDoesNotMatch(wp, "x");}
a8fb83d5370b8e3a11f58a2a846723999f5eff1115020a813a5508ed2445b04a
testDoubleStarsIgnored
public void testDoubleStarsIgnored()
{    WildcardPath wp = new WildcardPath("", "foo**bar", '.');    assertMatches(wp, "foobar", "fooxyzbar", "foo.x.y.z.bar");    assertDoesNotMatch(wp, "fobar", "hi", "foobazr");    wp = new WildcardPath("", "foo********bar", '.');    assertMatches(wp, "foobar", "fooxyzbar", "foo.x.y.z.bar");    assertDoesNotMatch(wp, "fobar", "hi", "foobazr");}
3ccff589ca1d69e527484bdf761bdfe88d45e9ee083c60a5b9355a99e2b8477c
testStarsAtBeginAndEnd
public void testStarsAtBeginAndEnd()
{    WildcardPath wp = new WildcardPath("", "*x.y.z", '.');    assertMatches(wp, "a.b.c.x.y.z", "x.y.z", "zoopx.y.z", "zoopx.y.z.child");    assertDoesNotMatch(wp, "a.b.c.x.y", "xy.z", "hi");    wp = new WildcardPath("", "*.x.y.z", '.');    assertMatches(wp, "a.b.c.x.y.z", "foo.x.y.z", "foo.x.y.z.child");    assertDoesNotMatch(wp, "x.y.z", "a.b.c.x.y", "xy.z", "hi", "zoopx.y.z", "zoopx.y.z.child");    wp = new WildcardPath("", "x.y.z*", '.');    assertMatches(wp, "x.y.z", "x.y.z.foo", "x.y.zoo", "x.y.zoo.bar");    assertDoesNotMatch(wp, "a.b.c.x.y.z", "foo.x.y.z", "hi");    wp = new WildcardPath("", "x.y.z.*", '.');    assertMatches(wp, "x.y.z.foo", "x.y.z.bar.baz");    assertDoesNotMatch(wp, "x.y.z", "a.b.c.x.y.z", "x.y.zoo", "foo.x.y.z", "hi", "x.y.zoo.bar");}
e38a3b46001aaf1ce6782fff33ac1aa769470d6e918883dbb79c30db295b54df
testComplex
public void testComplex()
{    WildcardPath wp = new WildcardPath("", "*.street", '.');    assertMatches(wp, "home.address.street", "home.address.street.number", "work.address.street", "work.address.street.foo", "street.street", "street.street.street.street", "thing.street.thing");    assertDoesNotMatch(wp, "home.address.street_2", "home.address.street_2.number", "work.addressstreet", "work.addressstreet.foo", "", "x.y.z.street2", "x.y.z.street2.z");    wp = new WildcardPath("", "x.y.*_stat.average", '.');    assertMatches(wp, "x.y.z_stat.average", "x.y.foo_stat.average", "x.y.z.a.b_stat.average", "x.y.z.a.b_stat.average.child", "x.y.z._stat.average");    assertDoesNotMatch(wp, "x.y.z_stats.average", "x.y.z_stat.averages", "x.y_stat.average", "x.yyy.foo_stat.average");    wp = new WildcardPath("", "x.y.pre*.bar", '.');    assertMatches(wp, "x.y.pre.bar", "x.y.preabc.bar", "x.y.prebar.bar");    assertDoesNotMatch(wp, "x.y.pre.baraaaa", "x.y.preabc.baraaaa");}
aaeda8254d4079cb4f6456af28df58b3588d281ec86cadc8f3767ae9ef4d79e2
read
public synchronized int read(byte[] b, int off, int len)
{    if (current < lengths.length) {        if (len <= lengths[current]) {                        int bytesRead = super.read(b, off, len);            lengths[current] -= bytesRead;            return bytesRead;        } else {            int bytesRead = super.read(b, off, lengths[current]);            current += 1;            return bytesRead;        }    } else {        return super.read(b, off, len);    }}
85c9e8103213800a008e1513fd902875fca6ec188d881a20c3f992c4f66c2d87
getPos
public long getPos()
{    return this.pos;}
2fcab08b83b659b767bfd6345ab5a6078e33f62deff5881aa271a634bb012744
testReadFully
public void testReadFully() throws Exception
{    byte[] buffer = new byte[5];    MockInputStream stream = new MockInputStream();    DelegatingSeekableInputStream.readFully(stream, buffer, 0, buffer.length);    Assert.assertArrayEquals("Byte array contents should match", Arrays.copyOfRange(TEST_ARRAY, 0, 5), buffer);    Assert.assertEquals("Stream position should reflect bytes read", 5, stream.getPos());}
153692ca7cfef2f25d0317e0b4105f45b611c232ba2fd820dee542555d884334
testReadFullySmallReads
public void testReadFullySmallReads() throws Exception
{    byte[] buffer = new byte[5];    MockInputStream stream = new MockInputStream(2, 3, 3);    DelegatingSeekableInputStream.readFully(stream, buffer, 0, buffer.length);    Assert.assertArrayEquals("Byte array contents should match", Arrays.copyOfRange(TEST_ARRAY, 0, 5), buffer);    Assert.assertEquals("Stream position should reflect bytes read", 5, stream.getPos());}
5bc2d730ccd0728c8d507c04d7ee2e0a940049e9af77150615d96081a8a278e7
testReadFullyJustRight
public void testReadFullyJustRight() throws Exception
{    final byte[] buffer = new byte[10];    final MockInputStream stream = new MockInputStream(2, 3, 3);    DelegatingSeekableInputStream.readFully(stream, buffer, 0, buffer.length);    Assert.assertArrayEquals("Byte array contents should match", TEST_ARRAY, buffer);    Assert.assertEquals("Stream position should reflect bytes read", 10, stream.getPos());    TestUtils.assertThrows("Should throw EOFException if no more bytes left", EOFException.class, (Callable<Void>) () -> {        DelegatingSeekableInputStream.readFully(stream, buffer, 0, 1);        return null;    });}
3190ba01e2055c2fcd49129baaefeae0abdbc3fbc2aa655208a6bc1c8dd02748
testReadFullyUnderflow
public void testReadFullyUnderflow() throws Exception
{    final byte[] buffer = new byte[11];    final MockInputStream stream = new MockInputStream(2, 3, 3);    TestUtils.assertThrows("Should throw EOFException if no more bytes left", EOFException.class, (Callable<Void>) () -> {        DelegatingSeekableInputStream.readFully(stream, buffer, 0, buffer.length);        return null;    });    Assert.assertArrayEquals("Should have consumed bytes", TEST_ARRAY, Arrays.copyOfRange(buffer, 0, 10));    Assert.assertEquals("Stream position should reflect bytes read", 10, stream.getPos());}
e8a4bbc4629370d5b94dacbe828ba63b630e2985279de13f8716128e56698412
testReadFullyStartAndLength
public void testReadFullyStartAndLength() throws IOException
{    byte[] buffer = new byte[10];    MockInputStream stream = new MockInputStream();    DelegatingSeekableInputStream.readFully(stream, buffer, 2, 5);    Assert.assertArrayEquals("Byte array contents should match", Arrays.copyOfRange(TEST_ARRAY, 0, 5), Arrays.copyOfRange(buffer, 2, 7));    Assert.assertEquals("Stream position should reflect bytes read", 5, stream.getPos());}
03f72a6f71fa4f4bdd56ea17ae70d5ff016aea4b5067b52a519e4a31e820ac6e
testReadFullyZeroByteRead
public void testReadFullyZeroByteRead() throws IOException
{    byte[] buffer = new byte[0];    MockInputStream stream = new MockInputStream();    DelegatingSeekableInputStream.readFully(stream, buffer, 0, buffer.length);    Assert.assertEquals("Stream position should reflect bytes read", 0, stream.getPos());}
cef108f64e1d86ea9f0206ec0294b4cf9ae05d56b8d3db0c3d59686c8eca095d
testReadFullySmallReadsWithStartAndLength
public void testReadFullySmallReadsWithStartAndLength() throws IOException
{    byte[] buffer = new byte[10];    MockInputStream stream = new MockInputStream(2, 2, 3);    DelegatingSeekableInputStream.readFully(stream, buffer, 2, 5);    Assert.assertArrayEquals("Byte array contents should match", Arrays.copyOfRange(TEST_ARRAY, 0, 5), Arrays.copyOfRange(buffer, 2, 7));    Assert.assertEquals("Stream position should reflect bytes read", 5, stream.getPos());}
afc8e68c155c025dec6ccae29d3d4f701a33519589fc48cd8f68713ffdcb7c12
testHeapRead
public void testHeapRead() throws Exception
{    ByteBuffer readBuffer = ByteBuffer.allocate(20);    MockInputStream stream = new MockInputStream();    int len = DelegatingSeekableInputStream.readHeapBuffer(stream, readBuffer);    Assert.assertEquals(10, len);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(20, readBuffer.limit());    len = DelegatingSeekableInputStream.readHeapBuffer(stream, readBuffer);    Assert.assertEquals(-1, len);    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY), readBuffer);}
4948ec114e0127e8c87f20ca7603c166f9dc4bd68e21306088ddc5c15c041734
testHeapSmallBuffer
public void testHeapSmallBuffer() throws Exception
{    ByteBuffer readBuffer = ByteBuffer.allocate(5);    MockInputStream stream = new MockInputStream();    int len = DelegatingSeekableInputStream.readHeapBuffer(stream, readBuffer);    Assert.assertEquals(5, len);    Assert.assertEquals(5, readBuffer.position());    Assert.assertEquals(5, readBuffer.limit());    len = DelegatingSeekableInputStream.readHeapBuffer(stream, readBuffer);    Assert.assertEquals(0, len);    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 5), readBuffer);}
a21331f8a468e78859d60b8b1720d1d90ef7ec41e39b810be4d1d55563e32504
testHeapSmallReads
public void testHeapSmallReads() throws Exception
{    ByteBuffer readBuffer = ByteBuffer.allocate(10);    MockInputStream stream = new MockInputStream(2, 3, 3);    int len = DelegatingSeekableInputStream.readHeapBuffer(stream, readBuffer);    Assert.assertEquals(2, len);    Assert.assertEquals(2, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    len = DelegatingSeekableInputStream.readHeapBuffer(stream, readBuffer);    Assert.assertEquals(3, len);    Assert.assertEquals(5, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    len = DelegatingSeekableInputStream.readHeapBuffer(stream, readBuffer);    Assert.assertEquals(3, len);    Assert.assertEquals(8, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    len = DelegatingSeekableInputStream.readHeapBuffer(stream, readBuffer);    Assert.assertEquals(2, len);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY), readBuffer);}
9f8ab84394538498b4622844e72973cb9d2355dda099c14ae709a07fe0b0c620
testHeapPosition
public void testHeapPosition() throws Exception
{    ByteBuffer readBuffer = ByteBuffer.allocate(20);    readBuffer.position(10);    readBuffer.mark();    MockInputStream stream = new MockInputStream(8);    int len = DelegatingSeekableInputStream.readHeapBuffer(stream, readBuffer);    Assert.assertEquals(8, len);    Assert.assertEquals(18, readBuffer.position());    Assert.assertEquals(20, readBuffer.limit());    len = DelegatingSeekableInputStream.readHeapBuffer(stream, readBuffer);    Assert.assertEquals(2, len);    Assert.assertEquals(20, readBuffer.position());    Assert.assertEquals(20, readBuffer.limit());    len = DelegatingSeekableInputStream.readHeapBuffer(stream, readBuffer);    Assert.assertEquals(-1, len);    readBuffer.reset();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY), readBuffer);}
6fddcf821a0a1ff2a8c2f020365cf5ad3b6dbaf82c89b26838af8dcaab3a5bbb
testHeapLimit
public void testHeapLimit() throws Exception
{    ByteBuffer readBuffer = ByteBuffer.allocate(20);    readBuffer.limit(8);    MockInputStream stream = new MockInputStream(7);    int len = DelegatingSeekableInputStream.readHeapBuffer(stream, readBuffer);    Assert.assertEquals(7, len);    Assert.assertEquals(7, readBuffer.position());    Assert.assertEquals(8, readBuffer.limit());    len = DelegatingSeekableInputStream.readHeapBuffer(stream, readBuffer);    Assert.assertEquals(1, len);    Assert.assertEquals(8, readBuffer.position());    Assert.assertEquals(8, readBuffer.limit());    len = DelegatingSeekableInputStream.readHeapBuffer(stream, readBuffer);    Assert.assertEquals(0, len);    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 8), readBuffer);}
8435fd2073d749b0442e06a669532245eaa07dad2de05c4ecf0c82003a7818b8
testHeapPositionAndLimit
public void testHeapPositionAndLimit() throws Exception
{    ByteBuffer readBuffer = ByteBuffer.allocate(20);    readBuffer.position(5);    readBuffer.limit(13);    readBuffer.mark();    MockInputStream stream = new MockInputStream(7);    int len = DelegatingSeekableInputStream.readHeapBuffer(stream, readBuffer);    Assert.assertEquals(7, len);    Assert.assertEquals(12, readBuffer.position());    Assert.assertEquals(13, readBuffer.limit());    len = DelegatingSeekableInputStream.readHeapBuffer(stream, readBuffer);    Assert.assertEquals(1, len);    Assert.assertEquals(13, readBuffer.position());    Assert.assertEquals(13, readBuffer.limit());    len = DelegatingSeekableInputStream.readHeapBuffer(stream, readBuffer);    Assert.assertEquals(0, len);    readBuffer.reset();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 8), readBuffer);}
3b84505b5dd92230be124c12cc6a9661909a1b732434ec33d31114c70962c77a
testDirectRead
public void testDirectRead() throws Exception
{    ByteBuffer readBuffer = ByteBuffer.allocateDirect(20);    MockInputStream stream = new MockInputStream();    int len = DelegatingSeekableInputStream.readDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(10, len);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(20, readBuffer.limit());    len = DelegatingSeekableInputStream.readDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(-1, len);    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY), readBuffer);}
80195f1f5c0bd88481b3b4042bc7b6667c582a7e9f4566a8b35b56d3f8a0ce7b
testDirectSmallBuffer
public void testDirectSmallBuffer() throws Exception
{    ByteBuffer readBuffer = ByteBuffer.allocateDirect(5);    MockInputStream stream = new MockInputStream();    int len = DelegatingSeekableInputStream.readDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(5, len);    Assert.assertEquals(5, readBuffer.position());    Assert.assertEquals(5, readBuffer.limit());    len = DelegatingSeekableInputStream.readDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(0, len);    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 5), readBuffer);}
b3d542612a5a38e6cb440e54026075ca11b62295b95b0ebfbd6aaa4775d07f6b
testDirectSmallReads
public void testDirectSmallReads() throws Exception
{    ByteBuffer readBuffer = ByteBuffer.allocateDirect(10);    MockInputStream stream = new MockInputStream(2, 3, 3);    int len = DelegatingSeekableInputStream.readDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(2, len);    Assert.assertEquals(2, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    len = DelegatingSeekableInputStream.readDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(3, len);    Assert.assertEquals(5, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    len = DelegatingSeekableInputStream.readDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(3, len);    Assert.assertEquals(8, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    len = DelegatingSeekableInputStream.readDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(2, len);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY), readBuffer);}
044e8d10070f65747e37c7f6b795b8a50db9f5ef6c2436bf78961329a2628415
testDirectPosition
public void testDirectPosition() throws Exception
{    ByteBuffer readBuffer = ByteBuffer.allocateDirect(20);    readBuffer.position(10);    readBuffer.mark();    MockInputStream stream = new MockInputStream(8);    int len = DelegatingSeekableInputStream.readDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(8, len);    Assert.assertEquals(18, readBuffer.position());    Assert.assertEquals(20, readBuffer.limit());    len = DelegatingSeekableInputStream.readDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(2, len);    Assert.assertEquals(20, readBuffer.position());    Assert.assertEquals(20, readBuffer.limit());    len = DelegatingSeekableInputStream.readDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(-1, len);    readBuffer.reset();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY), readBuffer);}
33564c03eeae71b57ff6262ddbfc280ff5787610cc06c88f423820040b4e57cb
testDirectLimit
public void testDirectLimit() throws Exception
{    ByteBuffer readBuffer = ByteBuffer.allocate(20);    readBuffer.limit(8);    MockInputStream stream = new MockInputStream(7);    int len = DelegatingSeekableInputStream.readDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(7, len);    Assert.assertEquals(7, readBuffer.position());    Assert.assertEquals(8, readBuffer.limit());    len = DelegatingSeekableInputStream.readDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(1, len);    Assert.assertEquals(8, readBuffer.position());    Assert.assertEquals(8, readBuffer.limit());    len = DelegatingSeekableInputStream.readDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(0, len);    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 8), readBuffer);}
bf2099ca84ad00ab398c65ccf66d6122f9dd88b88b69187222fb1fa678640752
testDirectPositionAndLimit
public void testDirectPositionAndLimit() throws Exception
{    ByteBuffer readBuffer = ByteBuffer.allocateDirect(20);    readBuffer.position(5);    readBuffer.limit(13);    readBuffer.mark();    MockInputStream stream = new MockInputStream(7);    int len = DelegatingSeekableInputStream.readDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(7, len);    Assert.assertEquals(12, readBuffer.position());    Assert.assertEquals(13, readBuffer.limit());    len = DelegatingSeekableInputStream.readDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(1, len);    Assert.assertEquals(13, readBuffer.position());    Assert.assertEquals(13, readBuffer.limit());    len = DelegatingSeekableInputStream.readDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(0, len);    readBuffer.reset();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 8), readBuffer);}
f1b79f9abac932996c6626ad517f5a1e4182ddaa49535cd9a59e8a0eb6297b7d
testDirectSmallTempBufferSmallReads
public void testDirectSmallTempBufferSmallReads() throws Exception
{        byte[] temp = new byte[2];    ByteBuffer readBuffer = ByteBuffer.allocateDirect(10);    MockInputStream stream = new MockInputStream(2, 3, 3);    int len = DelegatingSeekableInputStream.readDirectBuffer(stream, readBuffer, temp);    Assert.assertEquals(2, len);    Assert.assertEquals(2, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    len = DelegatingSeekableInputStream.readDirectBuffer(stream, readBuffer, temp);    Assert.assertEquals(3, len);    Assert.assertEquals(5, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    len = DelegatingSeekableInputStream.readDirectBuffer(stream, readBuffer, temp);    Assert.assertEquals(3, len);    Assert.assertEquals(8, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    len = DelegatingSeekableInputStream.readDirectBuffer(stream, readBuffer, temp);    Assert.assertEquals(2, len);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    len = DelegatingSeekableInputStream.readDirectBuffer(stream, readBuffer, temp);    Assert.assertEquals(-1, len);    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY), readBuffer);}
3817d2a12216ec70550f824c9404180c6f23ea0f68cf03b9d82a8ab2d5d911e8
testDirectSmallTempBufferWithPositionAndLimit
public void testDirectSmallTempBufferWithPositionAndLimit() throws Exception
{        byte[] temp = new byte[2];    ByteBuffer readBuffer = ByteBuffer.allocateDirect(20);    readBuffer.position(5);    readBuffer.limit(13);    readBuffer.mark();    MockInputStream stream = new MockInputStream(7);    int len = DelegatingSeekableInputStream.readDirectBuffer(stream, readBuffer, temp);    Assert.assertEquals(7, len);    Assert.assertEquals(12, readBuffer.position());    Assert.assertEquals(13, readBuffer.limit());    len = DelegatingSeekableInputStream.readDirectBuffer(stream, readBuffer, temp);    Assert.assertEquals(1, len);    Assert.assertEquals(13, readBuffer.position());    Assert.assertEquals(13, readBuffer.limit());    len = DelegatingSeekableInputStream.readDirectBuffer(stream, readBuffer, temp);    Assert.assertEquals(0, len);    readBuffer.reset();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 8), readBuffer);}
c65eccd80d60913b9af4737a02b5437e8ffcde595df160fb593b71c64952e062
testHeapReadFullySmallBuffer
public void testHeapReadFullySmallBuffer() throws Exception
{    ByteBuffer readBuffer = ByteBuffer.allocate(8);    MockInputStream stream = new MockInputStream();    DelegatingSeekableInputStream.readFullyHeapBuffer(stream, readBuffer);    Assert.assertEquals(8, readBuffer.position());    Assert.assertEquals(8, readBuffer.limit());    DelegatingSeekableInputStream.readFullyHeapBuffer(stream, readBuffer);    Assert.assertEquals(8, readBuffer.position());    Assert.assertEquals(8, readBuffer.limit());    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 8), readBuffer);}
41e6ca3cc249b1bb3c352db00909d1427616b98aca0236c9df7aeb6d8e015123
testHeapReadFullyLargeBuffer
public void testHeapReadFullyLargeBuffer() throws Exception
{    final ByteBuffer readBuffer = ByteBuffer.allocate(20);    final MockInputStream stream = new MockInputStream();    TestUtils.assertThrows("Should throw EOFException", EOFException.class, () -> {        DelegatingSeekableInputStream.readFullyHeapBuffer(stream, readBuffer);        return null;    });    Assert.assertEquals(0, readBuffer.position());    Assert.assertEquals(20, readBuffer.limit());}
4d52a409b2ad34c8d70807a09389353dfa47199d1e48522f1e3e1053bf0818f7
testHeapReadFullyJustRight
public void testHeapReadFullyJustRight() throws Exception
{    final ByteBuffer readBuffer = ByteBuffer.allocate(10);    MockInputStream stream = new MockInputStream();        DelegatingSeekableInputStream.readFullyHeapBuffer(stream, readBuffer);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());        DelegatingSeekableInputStream.readFullyHeapBuffer(stream, readBuffer);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY), readBuffer);}
a711af09e3f6f90a0be9f717314cb0dc917256392dca7f8d2eab45b13a433491
testHeapReadFullySmallReads
public void testHeapReadFullySmallReads() throws Exception
{    final ByteBuffer readBuffer = ByteBuffer.allocate(10);    MockInputStream stream = new MockInputStream(2, 3, 3);    DelegatingSeekableInputStream.readFullyHeapBuffer(stream, readBuffer);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    DelegatingSeekableInputStream.readFullyHeapBuffer(stream, readBuffer);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY), readBuffer);}
cefcc109f2cab89d41cd1cf6b5a2d7a74c0f68cf3e698840f49c8f2f2e32be39
testHeapReadFullyPosition
public void testHeapReadFullyPosition() throws Exception
{    final ByteBuffer readBuffer = ByteBuffer.allocate(10);    readBuffer.position(3);    readBuffer.mark();    MockInputStream stream = new MockInputStream(2, 3, 3);    DelegatingSeekableInputStream.readFullyHeapBuffer(stream, readBuffer);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    DelegatingSeekableInputStream.readFullyHeapBuffer(stream, readBuffer);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    readBuffer.reset();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 7), readBuffer);}
cbdaf0738b7e8de9ad79bcd557e5ff56c6017a95971a4a7c81125fd9b9fe0843
testHeapReadFullyLimit
public void testHeapReadFullyLimit() throws Exception
{    final ByteBuffer readBuffer = ByteBuffer.allocate(10);    readBuffer.limit(7);    MockInputStream stream = new MockInputStream(2, 3, 3);    DelegatingSeekableInputStream.readFullyHeapBuffer(stream, readBuffer);    Assert.assertEquals(7, readBuffer.position());    Assert.assertEquals(7, readBuffer.limit());    DelegatingSeekableInputStream.readFullyHeapBuffer(stream, readBuffer);    Assert.assertEquals(7, readBuffer.position());    Assert.assertEquals(7, readBuffer.limit());    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 7), readBuffer);    readBuffer.position(7);    readBuffer.limit(10);    DelegatingSeekableInputStream.readFullyHeapBuffer(stream, readBuffer);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY), readBuffer);}
d362858c0b3671c8fa9e97f4d862e5edbb8ece3147a246b375170ce9ecccb878
testHeapReadFullyPositionAndLimit
public void testHeapReadFullyPositionAndLimit() throws Exception
{    final ByteBuffer readBuffer = ByteBuffer.allocate(10);    readBuffer.position(3);    readBuffer.limit(7);    readBuffer.mark();    MockInputStream stream = new MockInputStream(2, 3, 3);    DelegatingSeekableInputStream.readFullyHeapBuffer(stream, readBuffer);    Assert.assertEquals(7, readBuffer.position());    Assert.assertEquals(7, readBuffer.limit());    DelegatingSeekableInputStream.readFullyHeapBuffer(stream, readBuffer);    Assert.assertEquals(7, readBuffer.position());    Assert.assertEquals(7, readBuffer.limit());    readBuffer.reset();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 4), readBuffer);    readBuffer.position(7);    readBuffer.limit(10);    DelegatingSeekableInputStream.readFullyHeapBuffer(stream, readBuffer);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    readBuffer.reset();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 7), readBuffer);}
946661e20d2edba41d5e99530609c0cd62745897c0494259c73f1ffa271facae
testDirectReadFullySmallBuffer
public void testDirectReadFullySmallBuffer() throws Exception
{    ByteBuffer readBuffer = ByteBuffer.allocateDirect(8);    MockInputStream stream = new MockInputStream();    DelegatingSeekableInputStream.readFullyDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(8, readBuffer.position());    Assert.assertEquals(8, readBuffer.limit());    DelegatingSeekableInputStream.readFullyDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(8, readBuffer.position());    Assert.assertEquals(8, readBuffer.limit());    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 8), readBuffer);}
0705692717e56afd360c96351c9d6febf700150017b47841ec536db3b69464f6
testDirectReadFullyLargeBuffer
public void testDirectReadFullyLargeBuffer() throws Exception
{    final ByteBuffer readBuffer = ByteBuffer.allocateDirect(20);    final MockInputStream stream = new MockInputStream();    TestUtils.assertThrows("Should throw EOFException", EOFException.class, () -> {        DelegatingSeekableInputStream.readFullyDirectBuffer(stream, readBuffer, TEMP.get());        return null;    });                            Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(20, readBuffer.limit());}
3a66deefdc4b8825e9024b494a5e5b5acb7a8dd8b811072603c83f17b4eb3315
testDirectReadFullyJustRight
public void testDirectReadFullyJustRight() throws Exception
{    final ByteBuffer readBuffer = ByteBuffer.allocateDirect(10);    MockInputStream stream = new MockInputStream();        DelegatingSeekableInputStream.readFullyDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());        DelegatingSeekableInputStream.readFullyDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY), readBuffer);}
f685f203175da0ea904aae08714ff1bf7677d70feea517fedce702d454d7ceac
testDirectReadFullySmallReads
public void testDirectReadFullySmallReads() throws Exception
{    final ByteBuffer readBuffer = ByteBuffer.allocateDirect(10);    MockInputStream stream = new MockInputStream(2, 3, 3);    DelegatingSeekableInputStream.readFullyDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    DelegatingSeekableInputStream.readFullyDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY), readBuffer);}
6b9c889cf46ef04a31faf6eb8d40d2f578b25029eb1606673a951352b21b939d
testDirectReadFullyPosition
public void testDirectReadFullyPosition() throws Exception
{    final ByteBuffer readBuffer = ByteBuffer.allocateDirect(10);    readBuffer.position(3);    readBuffer.mark();    MockInputStream stream = new MockInputStream(2, 3, 3);    DelegatingSeekableInputStream.readFullyDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    DelegatingSeekableInputStream.readFullyDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    readBuffer.reset();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 7), readBuffer);}
3c11953b863e4130c7030ea77003afdd3a6d333d60073719eac5966fa1d7ece8
testDirectReadFullyLimit
public void testDirectReadFullyLimit() throws Exception
{    final ByteBuffer readBuffer = ByteBuffer.allocateDirect(10);    readBuffer.limit(7);    MockInputStream stream = new MockInputStream(2, 3, 3);    DelegatingSeekableInputStream.readFullyDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(7, readBuffer.position());    Assert.assertEquals(7, readBuffer.limit());    DelegatingSeekableInputStream.readFullyDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(7, readBuffer.position());    Assert.assertEquals(7, readBuffer.limit());    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 7), readBuffer);    readBuffer.position(7);    readBuffer.limit(10);    DelegatingSeekableInputStream.readFullyDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY), readBuffer);}
e8968bbb7a8089c3d31be7e588a0553f66881583723847fec68b31b630760106
testDirectReadFullyPositionAndLimit
public void testDirectReadFullyPositionAndLimit() throws Exception
{    final ByteBuffer readBuffer = ByteBuffer.allocateDirect(10);    readBuffer.position(3);    readBuffer.limit(7);    readBuffer.mark();    MockInputStream stream = new MockInputStream(2, 3, 3);    DelegatingSeekableInputStream.readFullyDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(7, readBuffer.position());    Assert.assertEquals(7, readBuffer.limit());    DelegatingSeekableInputStream.readFullyDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(7, readBuffer.position());    Assert.assertEquals(7, readBuffer.limit());    readBuffer.reset();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 4), readBuffer);    readBuffer.position(7);    readBuffer.limit(10);    DelegatingSeekableInputStream.readFullyDirectBuffer(stream, readBuffer, TEMP.get());    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    readBuffer.reset();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 7), readBuffer);}
86458ca0416183cbc151bd9ce413fcb4827d6540a39b5606ddec106d9e2d0aff
testDirectReadFullySmallTempBufferWithPositionAndLimit
public void testDirectReadFullySmallTempBufferWithPositionAndLimit() throws Exception
{        byte[] temp = new byte[2];    final ByteBuffer readBuffer = ByteBuffer.allocateDirect(10);    readBuffer.position(3);    readBuffer.limit(7);    readBuffer.mark();    MockInputStream stream = new MockInputStream(2, 3, 3);    DelegatingSeekableInputStream.readFullyDirectBuffer(stream, readBuffer, temp);    Assert.assertEquals(7, readBuffer.position());    Assert.assertEquals(7, readBuffer.limit());    DelegatingSeekableInputStream.readFullyDirectBuffer(stream, readBuffer, temp);    Assert.assertEquals(7, readBuffer.position());    Assert.assertEquals(7, readBuffer.limit());    readBuffer.reset();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 4), readBuffer);    readBuffer.position(7);    readBuffer.limit(10);    DelegatingSeekableInputStream.readFullyDirectBuffer(stream, readBuffer, temp);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    readBuffer.reset();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 7), readBuffer);}
41dd1440e007f2271227d7c71b61d3195aee2817e4050f0a3daaa94d827cbb23
testCompare
public void testCompare()
{    assertTrue(new SemanticVersion(1, 8, 1).compareTo(new SemanticVersion(1, 8, 1)) == 0);    assertTrue(new SemanticVersion(1, 8, 0).compareTo(new SemanticVersion(1, 8, 1)) < 0);    assertTrue(new SemanticVersion(1, 8, 2).compareTo(new SemanticVersion(1, 8, 1)) > 0);    assertTrue(new SemanticVersion(1, 8, 1).compareTo(new SemanticVersion(1, 8, 1)) == 0);    assertTrue(new SemanticVersion(1, 8, 0).compareTo(new SemanticVersion(1, 8, 1)) < 0);    assertTrue(new SemanticVersion(1, 8, 2).compareTo(new SemanticVersion(1, 8, 1)) > 0);    assertTrue(new SemanticVersion(1, 7, 0).compareTo(new SemanticVersion(1, 8, 0)) < 0);    assertTrue(new SemanticVersion(1, 9, 0).compareTo(new SemanticVersion(1, 8, 0)) > 0);    assertTrue(new SemanticVersion(0, 0, 0).compareTo(new SemanticVersion(1, 0, 0)) < 0);    assertTrue(new SemanticVersion(2, 0, 0).compareTo(new SemanticVersion(1, 0, 0)) > 0);    assertTrue(new SemanticVersion(1, 8, 100).compareTo(new SemanticVersion(1, 9, 0)) < 0);    assertTrue(new SemanticVersion(1, 8, 0).compareTo(new SemanticVersion(1, 8, 0, true)) > 0);    assertTrue(new SemanticVersion(1, 8, 0, true).compareTo(new SemanticVersion(1, 8, 0, true)) == 0);    assertTrue(new SemanticVersion(1, 8, 0, true).compareTo(new SemanticVersion(1, 8, 0)) < 0);}
e002456623447f7597e15ebd7c78ae99243e2e828f2df47ae7ae89739122b352
testSemverPrereleaseExamples
public void testSemverPrereleaseExamples() throws Exception
{    List<String> examples = Arrays.asList("1.0.0-alpha", "1.0.0-alpha.1", "1.0.0-alpha.beta", "1.0.0-beta", "1.0.0-beta.2", "1.0.0-beta.11", "1.0.0-rc.1", "1.0.0");    for (int i = 0; i < examples.size() - 1; i += 1) {        assertLessThan(examples.get(i), examples.get(i + 1));        assertEqualTo(examples.get(i), examples.get(i));    }        assertEqualTo(examples.get(examples.size() - 1), examples.get(examples.size() - 1));}
afc0923257e86e7344825dcae92c2a6984b665ac372276495d4bb553575002e5
testSemverBuildInfoExamples
public void testSemverBuildInfoExamples() throws Exception
{    assertEqualTo("1.0.0-alpha+001", "1.0.0-alpha+001");    assertEqualTo("1.0.0-alpha", "1.0.0-alpha+001");    assertEqualTo("1.0.0+20130313144700", "1.0.0+20130313144700");    assertEqualTo("1.0.0", "1.0.0+20130313144700");    assertEqualTo("1.0.0-beta+exp.sha.5114f85", "1.0.0-beta+exp.sha.5114f85");    assertEqualTo("1.0.0-beta", "1.0.0-beta+exp.sha.5114f85");}
0ee7404f1a9be4965015235b77a9c6bfa7dddcf3dd71d4dc718e2942785312ce
testUnknownComparisons
public void testUnknownComparisons() throws Exception
{        assertLessThan("1.0.0rc0-alpha+001", "1.0.0-alpha");}
4cfa5a97b18f6e1fd9d86c7522a9a7b9b0e033eb3cd3046230b46543a9adeaee
testDistributionVersions
public void testDistributionVersions() throws Exception
{    assertEqualTo("1.5.0-cdh5.5.0", "1.5.0-cdh5.5.0");    assertLessThan("1.5.0-cdh5.5.0", "1.5.0-cdh5.5.1");    assertLessThan("1.5.0-cdh5.5.0", "1.5.0-cdh5.5.1-SNAPSHOT");    assertLessThan("1.5.0-cdh5.5.0", "1.5.0-cdh5.6.0");    assertLessThan("1.5.0-cdh5.5.0", "1.5.0-cdh6.0.0");    assertLessThan("1.5.0-cdh5.5.0", "1.5.0");        assertLessThan("1.5.0-cdh5.5.0", "1.5.0-cdh5.5.0-SNAPSHOT");}
53f08741b60660eb06b43ab3287b253fa38bee40abec4fcb47016593e1dd2fa6
testParse
public void testParse() throws Exception
{    assertEquals(new SemanticVersion(1, 8, 0), SemanticVersion.parse("1.8.0"));    assertEquals(new SemanticVersion(1, 8, 0, true), SemanticVersion.parse("1.8.0rc3"));    assertEquals(new SemanticVersion(1, 8, 0, "rc3", "SNAPSHOT", null), SemanticVersion.parse("1.8.0rc3-SNAPSHOT"));    assertEquals(new SemanticVersion(1, 8, 0, null, "SNAPSHOT", null), SemanticVersion.parse("1.8.0-SNAPSHOT"));    assertEquals(new SemanticVersion(1, 5, 0, null, "cdh5.5.0", null), SemanticVersion.parse("1.5.0-cdh5.5.0"));}
2d88cc3970f7f78989bfebd1854462b4ef8169c66a4fe1f899ee6e23517158b6
assertLessThan
private static void assertLessThan(String a, String b) throws SemanticVersion.SemanticVersionParseException
{    assertTrue(a + " should be < " + b, SemanticVersion.parse(a).compareTo(SemanticVersion.parse(b)) < 0);    assertTrue(b + " should be > " + a, SemanticVersion.parse(b).compareTo(SemanticVersion.parse(a)) > 0);}
df5912c5cb074fdc2ffcfe87af580b801d3e320a9bedb330484e5a74664f6a36
assertEqualTo
private static void assertEqualTo(String a, String b) throws SemanticVersion.SemanticVersionParseException
{    assertTrue(a + " should equal " + b, SemanticVersion.parse(a).compareTo(SemanticVersion.parse(b)) == 0);}
0a7a0bea099d291b32bd380b860df15bbc5ff08941bb8bcb8eb4518a3ca1f3ef
testCheckArgument
public void testCheckArgument()
{    try {        Preconditions.checkArgument(true, "Test message: %s %s", 12, null);    } catch (IllegalArgumentException e) {        Assert.fail("Should not throw exception when isValid is true");    }    try {        Preconditions.checkArgument(false, "Test message: %s %s", 12, null);        Assert.fail("Should throw exception when isValid is false");    } catch (IllegalArgumentException e) {        Assert.assertEquals("Should format message", "Test message: 12 null", e.getMessage());    }}
f74844d1f08d19f35ed258294fbea0e3738e058f315b3f86640f58c5e368345c
testCheckState
public void testCheckState()
{    try {        Preconditions.checkState(true, "Test message: %s %s", 12, null);    } catch (IllegalStateException e) {        Assert.fail("Should not throw exception when isValid is true");    }    try {        Preconditions.checkState(false, "Test message: %s %s", 12, null);        Assert.fail("Should throw exception when isValid is false");    } catch (IllegalStateException e) {        Assert.assertEquals("Should format message", "Test message: 12 null", e.getMessage());    }}
d54ae37b15047137d77db38fa1b84620ac079ebc22c52523675be58707583c68
assertThrows
public static void assertThrows(String message, Class<? extends Exception> expected, Callable callable)
{    try {        callable.call();        Assert.fail("No exception was thrown (" + message + "), expected: " + expected.getName());    } catch (Exception actual) {        try {            Assert.assertEquals(message, expected, actual.getClass());        } catch (AssertionError e) {            e.addSuppressed(actual);            throw e;        }    }}
e23f7e21bd235330c29ffa1bc05eb380b6733a0b532ec6b7ca8d92bf684094b4
assertThrows
public static void assertThrows(String message, Class<? extends Exception> expected, Runnable runnable)
{    try {        runnable.run();        Assert.fail("No exception was thrown (" + message + "), expected: " + expected.getName());    } catch (Exception actual) {        try {            Assert.assertEquals(message, expected, actual.getClass());        } catch (AssertionError e) {            e.addSuppressed(actual);            throw e;        }    }}
c7cc8d78b7f8d07b9d615c24cdc303f173b48224fae9f429168305a38b0fb9a3
newConcatenator
public static Concatenator newConcatenator(String sep)
{    return new Concatenator(sep);}
bffcded15d6018f6a4893909e7cd3a70b882debe80d4609cb4557ae2a4d4b7ba
setSeparator
private void setSeparator(String sep)
{    this.sep = sep;}
80e8edb518833bac64f0b728f572d0451124e4d5d59c4fc26b214f40888be77a
concat
public String concat(String left, String right)
{    return left + sep + right;}
470b69fe07fd82214ac0b8f446c9a083672e7e5054b977b6852c797a6323541c
concat
public String concat(String left, String middle, String right)
{    return left + sep + middle + sep + right;}
8f2d8f3fa431333683898e9166be33657fc76ce3e773fe05cfb2e1b55a79b7b3
concat
public String concat(Exception e) throws Exception
{    throw e;}
c18fd16a4ea51692404f3b6fa0905c53fb75df4f30bee498a217808f0f986554
concat
public String concat(String... strings)
{    if (strings.length >= 1) {        StringBuilder sb = new StringBuilder();        sb.append(strings[0]);        for (int i = 1; i < strings.length; i += 1) {            sb.append(sep);            sb.append(strings[i]);        }        return sb.toString();    }    return null;}
719d783ca8763c83ba6e5266ae7bcd50f659ee392fa5a40fe157da8751d65ff0
cat
public static String cat(String... strings)
{    return new Concatenator().concat(strings);}
9fc12db014997868671c74b40c29f4094066d6bc8587e36f82c359c8469de4c9
testNoImplCall
public void testNoImplCall()
{    final DynConstructors.Builder builder = new DynConstructors.Builder();    TestUtils.assertThrows("Checked build should throw NoSuchMethodException", NoSuchMethodException.class, (Callable) builder::buildChecked);    TestUtils.assertThrows("Normal build should throw RuntimeException", RuntimeException.class, (Runnable) builder::build);}
d609a3223bd73e7e95bd8874a9c3b7f6eec06247f94886e07f0aca20d9ac22e7
testMissingClass
public void testMissingClass()
{    final DynConstructors.Builder builder = new DynConstructors.Builder().impl("not.a.RealClass");    TestUtils.assertThrows("Checked build should throw NoSuchMethodException", NoSuchMethodException.class, (Callable) builder::buildChecked);    TestUtils.assertThrows("Normal build should throw RuntimeException", RuntimeException.class, (Callable) builder::build);}
64c0bfa24a20e0efe71ff1e45207752d2477ec43237dc11ea9c3fdd4c27d7f24
testMissingConstructor
public void testMissingConstructor()
{    final DynConstructors.Builder builder = new DynConstructors.Builder().impl(Concatenator.class, String.class, String.class);    TestUtils.assertThrows("Checked build should throw NoSuchMethodException", NoSuchMethodException.class, (Callable) builder::buildChecked);    TestUtils.assertThrows("Normal build should throw RuntimeException", RuntimeException.class, (Callable) builder::build);}
e0df713bc807d1d40b7f0a67b7c49d6ed4dfd06568c96ce9fb6ef5fbcd05e4e5
testFirstImplReturned
public void testFirstImplReturned() throws Exception
{    final DynConstructors.Ctor<Concatenator> sepCtor = new DynConstructors.Builder().impl("not.a.RealClass", String.class).impl(Concatenator.class, String.class).impl(Concatenator.class).buildChecked();    Concatenator dashCat = sepCtor.newInstanceChecked("-");    Assert.assertEquals("Should construct with the 1-arg version", "a-b", dashCat.concat("a", "b"));    TestUtils.assertThrows("Should complain about extra arguments", IllegalArgumentException.class, () -> sepCtor.newInstanceChecked("/", "-"));    TestUtils.assertThrows("Should complain about extra arguments", IllegalArgumentException.class, () -> sepCtor.newInstance("/", "-"));    DynConstructors.Ctor<Concatenator> defaultCtor = new DynConstructors.Builder().impl("not.a.RealClass", String.class).impl(Concatenator.class).impl(Concatenator.class, String.class).buildChecked();    Concatenator cat = defaultCtor.newInstanceChecked();    Assert.assertEquals("Should construct with the no-arg version", "ab", cat.concat("a", "b"));}
b6f87a8c5ab6df75bb9c342482e14a5dc6cbf9e2b08cb4d5b71d8e2919787bb8
testExceptionThrown
public void testExceptionThrown() throws Exception
{    final SomeCheckedException exc = new SomeCheckedException();    final DynConstructors.Ctor<Concatenator> sepCtor = new DynConstructors.Builder().impl("not.a.RealClass", String.class).impl(Concatenator.class, Exception.class).buildChecked();    TestUtils.assertThrows("Should re-throw the exception", SomeCheckedException.class, () -> sepCtor.newInstanceChecked(exc));    TestUtils.assertThrows("Should wrap the exception in RuntimeException", RuntimeException.class, () -> sepCtor.newInstance(exc));}
b6ad778afb112760b9fc41b7036c04ecf32d85b54a28bed4e92da35ab10d6ae2
testStringClassname
public void testStringClassname() throws Exception
{    final DynConstructors.Ctor<Concatenator> sepCtor = new DynConstructors.Builder().impl(Concatenator.class.getName(), String.class).buildChecked();    Assert.assertNotNull("Should find 1-arg constructor", sepCtor.newInstance("-"));}
94ed25e5b63931a1f9393d29001cba79fd9dbe0481fbca59d9058f640889e454
testHiddenMethod
public void testHiddenMethod() throws Exception
{    TestUtils.assertThrows("Should fail to find hidden method", NoSuchMethodException.class, () -> new DynMethods.Builder("setSeparator").impl(Concatenator.class, char.class).buildChecked());    final DynConstructors.Ctor<Concatenator> sepCtor = new DynConstructors.Builder().hiddenImpl(Concatenator.class.getName(), char.class).buildChecked();    Assert.assertNotNull("Should find hidden ctor with hiddenImpl", sepCtor);    Concatenator slashCat = sepCtor.newInstanceChecked('/');    Assert.assertEquals("Should use separator /", "a/b", slashCat.concat("a", "b"));}
052807958ebed0377c8f4d7d0eaa089428f2fd0fc8e64b9995d577baed61f01c
testBind
public void testBind() throws Exception
{    final DynConstructors.Ctor<Concatenator> ctor = new DynConstructors.Builder().impl(Concatenator.class.getName()).buildChecked();    Assert.assertTrue("Should always be static", ctor.isStatic());    TestUtils.assertThrows("Should complain that method is static", IllegalStateException.class, () -> ctor.bind(null));}
463fae489fd1627f6bafababffc586acdb26357f5d6f2ded6d803800636e2f13
testInvoke
public void testInvoke() throws Exception
{    final DynMethods.UnboundMethod ctor = new DynConstructors.Builder().impl(Concatenator.class.getName()).buildChecked();    TestUtils.assertThrows("Should complain that target must be null", IllegalArgumentException.class, () -> ctor.invokeChecked("a"));    TestUtils.assertThrows("Should complain that target must be null", IllegalArgumentException.class, () -> ctor.invoke("a"));    Assert.assertNotNull("Should allow invokeChecked(null, ...)", ctor.invokeChecked(null));    Assert.assertNotNull("Should allow invoke(null, ...)", ctor.invoke(null));}
9fc12db014997868671c74b40c29f4094066d6bc8587e36f82c359c8469de4c9
testNoImplCall
public void testNoImplCall()
{    final DynMethods.Builder builder = new DynMethods.Builder("concat");    TestUtils.assertThrows("Checked build should throw NoSuchMethodException", NoSuchMethodException.class, (Callable) builder::buildChecked);    TestUtils.assertThrows("Normal build should throw RuntimeException", RuntimeException.class, (Callable) builder::build);}
d609a3223bd73e7e95bd8874a9c3b7f6eec06247f94886e07f0aca20d9ac22e7
testMissingClass
public void testMissingClass()
{    final DynMethods.Builder builder = new DynMethods.Builder("concat").impl("not.a.RealClass", String.class, String.class);    TestUtils.assertThrows("Checked build should throw NoSuchMethodException", NoSuchMethodException.class, (Callable) builder::buildChecked);    TestUtils.assertThrows("Normal build should throw RuntimeException", RuntimeException.class, (Runnable) builder::build);}
49a120cb2941fb79850a5841077d3cdf567d730a691c4057684520df9ac92992
testMissingMethod
public void testMissingMethod()
{    final DynMethods.Builder builder = new DynMethods.Builder("concat").impl(Concatenator.class, "cat2strings", String.class, String.class);    TestUtils.assertThrows("Checked build should throw NoSuchMethodException", NoSuchMethodException.class, (Callable) builder::buildChecked);    TestUtils.assertThrows("Normal build should throw RuntimeException", RuntimeException.class, (Runnable) builder::build);}
e0df713bc807d1d40b7f0a67b7c49d6ed4dfd06568c96ce9fb6ef5fbcd05e4e5
testFirstImplReturned
public void testFirstImplReturned() throws Exception
{    Concatenator obj = new Concatenator("-");    DynMethods.UnboundMethod cat2 = new DynMethods.Builder("concat").impl("not.a.RealClass", String.class, String.class).impl(Concatenator.class, String.class, String.class).impl(Concatenator.class, String.class, String.class, String.class).buildChecked();    Assert.assertEquals("Should call the 2-arg version successfully", "a-b", cat2.invoke(obj, "a", "b"));    Assert.assertEquals("Should ignore extra arguments", "a-b", cat2.invoke(obj, "a", "b", "c"));    DynMethods.UnboundMethod cat3 = new DynMethods.Builder("concat").impl("not.a.RealClass", String.class, String.class).impl(Concatenator.class, String.class, String.class, String.class).impl(Concatenator.class, String.class, String.class).build();    Assert.assertEquals("Should call the 3-arg version successfully", "a-b-c", cat3.invoke(obj, "a", "b", "c"));    Assert.assertEquals("Should call the 3-arg version null padding", "a-b-null", cat3.invoke(obj, "a", "b"));}
9fdf77c8234613d7678e867362e179b0ef7f8b03858ea4d9065e8a8bdfe996ba
testVarArgs
public void testVarArgs() throws Exception
{    DynMethods.UnboundMethod cat = new DynMethods.Builder("concat").impl(Concatenator.class, String[].class).buildChecked();    Assert.assertEquals("Should use the varargs version", "abcde", cat.invokeChecked(new Concatenator(), (Object) new String[] { "a", "b", "c", "d", "e" }));    Assert.assertEquals("Should use the varargs version", "abcde", cat.bind(new Concatenator()).invokeChecked((Object) new String[] { "a", "b", "c", "d", "e" }));}
f2fee3f13579551d0fdb7bbf808edae614fd2f9d4897be865a1582087c07e9a5
testIncorrectArguments
public void testIncorrectArguments() throws Exception
{    final Concatenator obj = new Concatenator("-");    final DynMethods.UnboundMethod cat = new DynMethods.Builder("concat").impl("not.a.RealClass", String.class, String.class).impl(Concatenator.class, String.class, String.class).buildChecked();    TestUtils.assertThrows("Should fail if non-string arguments are passed", IllegalArgumentException.class, () -> cat.invoke(obj, 3, 4));    TestUtils.assertThrows("Should fail if non-string arguments are passed", IllegalArgumentException.class, () -> cat.invokeChecked(obj, 3, 4));}
b6f87a8c5ab6df75bb9c342482e14a5dc6cbf9e2b08cb4d5b71d8e2919787bb8
testExceptionThrown
public void testExceptionThrown() throws Exception
{    final SomeCheckedException exc = new SomeCheckedException();    final Concatenator obj = new Concatenator("-");    final DynMethods.UnboundMethod cat = new DynMethods.Builder("concat").impl("not.a.RealClass", String.class, String.class).impl(Concatenator.class, Exception.class).buildChecked();    TestUtils.assertThrows("Should re-throw the exception", SomeCheckedException.class, () -> cat.invokeChecked(obj, exc));    TestUtils.assertThrows("Should wrap the exception in RuntimeException", RuntimeException.class, () -> cat.invoke(obj, exc));}
0d3ee31604ff1000031683b73b8f268dd6263085adb70e448b4c810833f666be
testNameChange
public void testNameChange() throws Exception
{    Concatenator obj = new Concatenator("-");    DynMethods.UnboundMethod cat = new DynMethods.Builder("cat").impl(Concatenator.class, "concat", String.class, String.class).buildChecked();    Assert.assertEquals("Should find 2-arg concat method", "a-b", cat.invoke(obj, "a", "b"));}
b6ad778afb112760b9fc41b7036c04ecf32d85b54a28bed4e92da35ab10d6ae2
testStringClassname
public void testStringClassname() throws Exception
{    Concatenator obj = new Concatenator("-");    DynMethods.UnboundMethod cat = new DynMethods.Builder("concat").impl(Concatenator.class.getName(), String.class, String.class).buildChecked();    Assert.assertEquals("Should find 2-arg concat method", "a-b", cat.invoke(obj, "a", "b"));}
94ed25e5b63931a1f9393d29001cba79fd9dbe0481fbca59d9058f640889e454
testHiddenMethod
public void testHiddenMethod() throws Exception
{    Concatenator obj = new Concatenator("-");    TestUtils.assertThrows("Should fail to find hidden method", NoSuchMethodException.class, () -> new DynMethods.Builder("setSeparator").impl(Concatenator.class, String.class).buildChecked());    DynMethods.UnboundMethod changeSep = new DynMethods.Builder("setSeparator").hiddenImpl(Concatenator.class, String.class).buildChecked();    Assert.assertNotNull("Should find hidden method with hiddenImpl", changeSep);    changeSep.invokeChecked(obj, "/");    Assert.assertEquals("Should use separator / instead of -", "a/b", obj.concat("a", "b"));}
8c08576dd5fbbb9b7fc114e8310ee3e73ae17f9c310c5ac11abe8a211c2eb2b6
testBoundMethod
public void testBoundMethod() throws Exception
{    DynMethods.UnboundMethod cat = new DynMethods.Builder("concat").impl(Concatenator.class, String.class, String.class).buildChecked();        DynMethods.BoundMethod dashCat = cat.bind(new Concatenator("-"));    DynMethods.BoundMethod underCat = cat.bind(new Concatenator("_"));    Assert.assertEquals("Should use '-' object without passing", "a-b", dashCat.invoke("a", "b"));    Assert.assertEquals("Should use '_' object without passing", "a_b", underCat.invoke("a", "b"));    DynMethods.BoundMethod slashCat = new DynMethods.Builder("concat").impl(Concatenator.class, String.class, String.class).buildChecked(new Concatenator("/"));    Assert.assertEquals("Should use bound object from builder without passing", "a/b", slashCat.invoke("a", "b"));}
6ab4b8affff0b1952f1046cf56ec9b9e43b0aa746f064bd79318aed2d417513e
testBindStaticMethod
public void testBindStaticMethod() throws Exception
{    final DynMethods.Builder builder = new DynMethods.Builder("cat").impl(Concatenator.class, String[].class);    TestUtils.assertThrows("Should complain that method is static", IllegalStateException.class, () -> builder.buildChecked(new Concatenator()));    TestUtils.assertThrows("Should complain that method is static", IllegalStateException.class, () -> builder.build(new Concatenator()));    final DynMethods.UnboundMethod staticCat = builder.buildChecked();    Assert.assertTrue("Should be static", staticCat.isStatic());    TestUtils.assertThrows("Should complain that method is static", IllegalStateException.class, () -> staticCat.bind(new Concatenator()));}
9596facf13ffe3c4ee03275c86f57eacafbf719099da39d8e98fff1aa02db607
testStaticMethod
public void testStaticMethod() throws Exception
{    DynMethods.StaticMethod staticCat = new DynMethods.Builder("cat").impl(Concatenator.class, String[].class).buildStaticChecked();    Assert.assertEquals("Should call varargs static method cat(String...)", "abcde", staticCat.invokeChecked((Object) new String[] { "a", "b", "c", "d", "e" }));}
020a96b10e251ec51d11c915f95a11cd2b9ba3dbe7e131ba77e6ca91cf7f7c35
testNonStaticMethod
public void testNonStaticMethod() throws Exception
{    final DynMethods.Builder builder = new DynMethods.Builder("concat").impl(Concatenator.class, String.class, String.class);    TestUtils.assertThrows("Should complain that method is not static", IllegalStateException.class, builder::buildStatic);    TestUtils.assertThrows("Should complain that method is not static", IllegalStateException.class, builder::buildStaticChecked);    final DynMethods.UnboundMethod cat2 = builder.buildChecked();    Assert.assertFalse("concat(String,String) should not be static", cat2.isStatic());    TestUtils.assertThrows("Should complain that method is not static", IllegalStateException.class, cat2::asStatic);}
be34c973f196d44921afa39b7568c11b30a4cd0a33c3cebe095475d5dc268147
testConstructorImpl
public void testConstructorImpl() throws Exception
{    final DynMethods.Builder builder = new DynMethods.Builder("newConcatenator").ctorImpl(Concatenator.class, String.class).impl(Concatenator.class, String.class);    DynMethods.UnboundMethod newConcatenator = builder.buildChecked();    Assert.assertTrue("Should find constructor implementation", newConcatenator instanceof DynConstructors.Ctor);    Assert.assertTrue("Constructor should be a static method", newConcatenator.isStatic());    Assert.assertFalse("Constructor should not be NOOP", newConcatenator.isNoop());        TestUtils.assertThrows("Should complain that ctor method is static", IllegalStateException.class, () -> builder.buildChecked(new Concatenator()));    TestUtils.assertThrows("Should complain that ctor method is static", IllegalStateException.class, () -> builder.build(new Concatenator()));    Concatenator concatenator = newConcatenator.asStatic().invoke("*");    Assert.assertEquals("Should function as a concatenator", "a*b", concatenator.concat("a", "b"));    concatenator = newConcatenator.asStatic().invokeChecked("@");    Assert.assertEquals("Should function as a concatenator", "a@b", concatenator.concat("a", "b"));}
c689be7b96e562dab76ac952e271b14ead8424f10ed86d3e75dd75a0c429e120
testConstructorImplAfterFactoryMethod
public void testConstructorImplAfterFactoryMethod() throws Exception
{    DynMethods.UnboundMethod newConcatenator = new DynMethods.Builder("newConcatenator").impl(Concatenator.class, String.class).ctorImpl(Concatenator.class, String.class).buildChecked();    Assert.assertFalse("Should find factory method before constructor method", newConcatenator instanceof DynConstructors.Ctor);}
975f0c7b22fce0e4954efd46c5a77704eb13970d64badbad083cb6e4c33a0863
testNoop
public void testNoop() throws Exception
{        DynMethods.UnboundMethod noop = new DynMethods.Builder("concat").impl("not.a.RealClass", String.class, String.class).orNoop().buildChecked();    Assert.assertTrue("No implementation found, should return NOOP", noop.isNoop());    Assert.assertNull("NOOP should always return null", noop.invoke(new Concatenator(), "a"));    Assert.assertNull("NOOP can be called with null", noop.invoke(null, "a"));    Assert.assertNull("NOOP can be bound", noop.bind(new Concatenator()).invoke("a"));    Assert.assertNull("NOOP can be bound to null", noop.bind(null).invoke("a"));    Assert.assertNull("NOOP can be static", noop.asStatic().invoke("a"));}
63fcdb6ca22d7cf5fa5683db1f5e2c2148d6ebce72359144f5532f9b35ec0655
assertVersionValid
private void assertVersionValid(String v)
{    try {        org.semver.Version.parse(v);    } catch (RuntimeException e) {        throw new RuntimeException(v + " is not a valid semver!", e);    }}
564aed8a7a036ef4f87ed96aa6aeaa8bbc61ae18dee0e89d64be6aa0414909ef
testVersion
public void testVersion()
{    assertVersionValid(Version.VERSION_NUMBER);}
8ef9cf767eee93f6924c1b18dda6404998bd86952ec1cf537d9df8f2fc2c7ef5
testFullVersion
public void testFullVersion() throws Exception
{    ParsedVersion version = VersionParser.parse(Version.FULL_VERSION);    assertVersionValid(version.version);    assertEquals(Version.VERSION_NUMBER, version.version);    assertEquals("parquet-mr", version.application);}
64227603c02c47e0787ed0d414b5a21dd9361cce1b48dfb023d8aef67e42764b
testVersionParser
public void testVersionParser() throws Exception
{    assertEquals(new ParsedVersion("parquet-mr", "1.6.0", "abcd"), VersionParser.parse("parquet-mr version 1.6.0 (build abcd)"));    assertEquals(new ParsedVersion("parquet-mr", "1.6.22rc99-SNAPSHOT", "abcd"), VersionParser.parse("parquet-mr version 1.6.22rc99-SNAPSHOT (build abcd)"));    try {        VersionParser.parse("unparseable string");        fail("this should throw");    } catch (VersionParseException e) {        }        assertEquals(new ParsedVersion("parquet-mr", null, "abcd"), VersionParser.parse("parquet-mr version (build abcd)"));    assertEquals(new ParsedVersion("parquet-mr", null, "abcd"), VersionParser.parse("parquet-mr version  (build abcd)"));        assertEquals(new ParsedVersion("parquet-mr", "1.6.0", null), VersionParser.parse("parquet-mr version 1.6.0 (build )"));    assertEquals(new ParsedVersion("parquet-mr", "1.6.0", null), VersionParser.parse("parquet-mr version 1.6.0 (build)"));    assertEquals(new ParsedVersion("parquet-mr", null, null), VersionParser.parse("parquet-mr version (build)"));    assertEquals(new ParsedVersion("parquet-mr", null, null), VersionParser.parse("parquet-mr version (build )"));        assertEquals(new ParsedVersion("parquet-mr", "1.6.0", null), VersionParser.parse("parquet-mr version 1.6.0"));    assertEquals(new ParsedVersion("parquet-mr", "1.8.0rc4", null), VersionParser.parse("parquet-mr version 1.8.0rc4"));    assertEquals(new ParsedVersion("parquet-mr", "1.8.0rc4-SNAPSHOT", null), VersionParser.parse("parquet-mr version 1.8.0rc4-SNAPSHOT"));    assertEquals(new ParsedVersion("parquet-mr", null, null), VersionParser.parse("parquet-mr version"));        assertEquals(new ParsedVersion("parquet-mr", "1.6.0", null), VersionParser.parse("parquet-mr     version    1.6.0"));    assertEquals(new ParsedVersion("parquet-mr", "1.8.0rc4", null), VersionParser.parse("parquet-mr     version    1.8.0rc4"));    assertEquals(new ParsedVersion("parquet-mr", "1.8.0rc4-SNAPSHOT", null), VersionParser.parse("parquet-mr      version    1.8.0rc4-SNAPSHOT  "));    assertEquals(new ParsedVersion("parquet-mr", null, null), VersionParser.parse("parquet-mr      version"));    assertEquals(new ParsedVersion("parquet-mr", "1.6.0", null), VersionParser.parse("parquet-mr version 1.6.0 (  build )"));    assertEquals(new ParsedVersion("parquet-mr", "1.6.0", null), VersionParser.parse("parquet-mr     version 1.6.0 (    build)"));    assertEquals(new ParsedVersion("parquet-mr", null, null), VersionParser.parse("parquet-mr     version (    build)"));    assertEquals(new ParsedVersion("parquet-mr", null, null), VersionParser.parse("parquet-mr    version    (build    )"));}
f3f4dc2a3a5acdf79f18947c379a35ac87ad0deffb4f6ec48fc7aa9d921dfc31
getBitPackingWriter
public static BitPackingWriter getBitPackingWriter(int bitLength, OutputStream out)
{    switch(bitLength) {        case 0:            return new ZeroBitPackingWriter();        case 1:            return new OneBitPackingWriter(out);        case 2:            return new TwoBitPackingWriter(out);        case 3:            return new ThreeBitPackingWriter(out);        case 4:            return new FourBitPackingWriter(out);        case 5:            return new FiveBitPackingWriter(out);        case 6:            return new SixBitPackingWriter(out);        case 7:            return new SevenBitPackingWriter(out);        case 8:            return new EightBitPackingWriter(out);        default:            throw new UnsupportedOperationException("only support up to 8 for now");    }}
2b9f061c255a10e1ad91456a9af05e88616dec6323384b457e52c5274126cad4
createBitPackingReader
public static BitPackingReader createBitPackingReader(int bitLength, InputStream in, long valueCount)
{    switch(bitLength) {        case 0:            return new ZeroBitPackingReader();        case 1:            return new OneBitPackingReader(in);        case 2:            return new TwoBitPackingReader(in);        case 3:            return new ThreeBitPackingReader(in, valueCount);        case 4:            return new FourBitPackingReader(in);        case 5:            return new FiveBitPackingReader(in, valueCount);        case 6:            return new SixBitPackingReader(in, valueCount);        case 7:            return new SevenBitPackingReader(in, valueCount);        case 8:            return new EightBitPackingReader(in);        default:            throw new UnsupportedOperationException("only support up to 8 for now");    }}
2a823a875ed7d2e2c556cf2ce9238948fc8208314bc7be70d7c7e7273254eae6
finish
 void finish(int numberOfBits, int buffer, OutputStream out) throws IOException
{    int padding = numberOfBits % 8 == 0 ? 0 : 8 - (numberOfBits % 8);    buffer = buffer << padding;    int numberOfBytes = (numberOfBits + padding) / 8;    for (int i = (numberOfBytes - 1) * 8; i >= 0; i -= 8) {        out.write((buffer >>> i) & 0xFF);    }}
a5a465cfaf4e81c5eebfb49414cb46fb4a97cb4aff05ccc4acdb0cf2d8ea9ba6
finish
 void finish(int numberOfBits, long buffer, OutputStream out) throws IOException
{    int padding = numberOfBits % 8 == 0 ? 0 : 8 - (numberOfBits % 8);    buffer = buffer << padding;    int numberOfBytes = (numberOfBits + padding) / 8;    for (int i = (numberOfBytes - 1) * 8; i >= 0; i -= 8) {        out.write((int) (buffer >>> i) & 0xFF);    }}
4c0cd44333ba1a725d4680d5967caba7c7a52a171d4f30731d9363d0e73c53ee
alignToBytes
 int alignToBytes(int bitsCount)
{    return BytesUtils.paddedByteCountFromBits(bitsCount);}
8336374318f968680be5b9b293b7b189f50c61d77428a81a148212a8c86d00e3
write
public void write(int val) throws IOException
{}
2f4f0c5911eb373c5a036e054e4a8f1ff0d397cd2a8f65fa91fd70a1558407cf
finish
public void finish()
{}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    return 0;}
8336374318f968680be5b9b293b7b189f50c61d77428a81a148212a8c86d00e3
write
public void write(int val) throws IOException
{    buffer = buffer << 1;    buffer |= val;    ++count;    if (count == 8) {        out.write(buffer);        buffer = 0;        count = 0;    }}
744f86b085b6d15c99aff81723cd20f3131d09bb239c3df9e2454bcc8a1a5a5f
finish
public void finish() throws IOException
{    while (count != 0) {        write(0);    }        out = null;}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    if (count == 0) {        buffer = in.read();        count = 8;    }    int result = (buffer >> (count - 1)) & 1;    --count;    return result;}
8336374318f968680be5b9b293b7b189f50c61d77428a81a148212a8c86d00e3
write
public void write(int val) throws IOException
{    buffer = buffer << 2;    buffer |= val;    ++count;    if (count == 4) {        out.write(buffer);        buffer = 0;        count = 0;    }}
744f86b085b6d15c99aff81723cd20f3131d09bb239c3df9e2454bcc8a1a5a5f
finish
public void finish() throws IOException
{    while (count != 0) {        write(0);    }        out = null;}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    if (count == 0) {        buffer = in.read();        count = 4;    }    int result = (buffer >> ((count - 1) * 2)) & 3;    --count;    return result;}
8336374318f968680be5b9b293b7b189f50c61d77428a81a148212a8c86d00e3
write
public void write(int val) throws IOException
{    buffer = buffer << 3;    buffer |= val;    ++count;    if (count == 8) {        out.write((buffer >>> 16) & 0xFF);        out.write((buffer >>> 8) & 0xFF);        out.write((buffer >>> 0) & 0xFF);        buffer = 0;        count = 0;    }}
744f86b085b6d15c99aff81723cd20f3131d09bb239c3df9e2454bcc8a1a5a5f
finish
public void finish() throws IOException
{    if (count != 0) {        int numberOfBits = count * 3;        finish(numberOfBits, buffer, out);        buffer = 0;        count = 0;    }        out = null;}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    if (count == 0) {        if (valueCount - totalRead < 8) {            buffer = 0;            int bitsToRead = 3 * (int) (valueCount - totalRead);            int bytesToRead = alignToBytes(bitsToRead);            for (int i = 3 - 1; i >= 3 - bytesToRead; i--) {                buffer |= in.read() << (i * 8);            }            count = 8;            totalRead = valueCount;        } else {            buffer = (in.read() << 16) + (in.read() << 8) + in.read();            count = 8;            totalRead += 8;        }    }    int result = (buffer >> ((count - 1) * 3)) & 7;    --count;    return result;}
8336374318f968680be5b9b293b7b189f50c61d77428a81a148212a8c86d00e3
write
public void write(int val) throws IOException
{    buffer = buffer << 4;    buffer |= val;    ++count;    if (count == 2) {        out.write(buffer);        buffer = 0;        count = 0;    }}
744f86b085b6d15c99aff81723cd20f3131d09bb239c3df9e2454bcc8a1a5a5f
finish
public void finish() throws IOException
{    while (count != 0) {                write(0);    }        out = null;}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    if (count == 0) {        buffer = in.read();        count = 2;    }    int result = (buffer >> ((count - 1) * 4)) & 15;    --count;    return result;}
8336374318f968680be5b9b293b7b189f50c61d77428a81a148212a8c86d00e3
write
public void write(int val) throws IOException
{    buffer = buffer << 5;    buffer |= val;    ++count;    if (count == 8) {        out.write((int) (buffer >>> 32) & 0xFF);        out.write((int) (buffer >>> 24) & 0xFF);        out.write((int) (buffer >>> 16) & 0xFF);        out.write((int) (buffer >>> 8) & 0xFF);        out.write((int) (buffer >>> 0) & 0xFF);        buffer = 0;        count = 0;    }}
744f86b085b6d15c99aff81723cd20f3131d09bb239c3df9e2454bcc8a1a5a5f
finish
public void finish() throws IOException
{    if (count != 0) {        int numberOfBits = count * 5;        finish(numberOfBits, buffer, out);        buffer = 0;        count = 0;    }        out = null;}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    if (count == 0) {        if (valueCount - totalRead < 8) {            buffer = 0;            int bitsToRead = 5 * (int) (valueCount - totalRead);            int bytesToRead = alignToBytes(bitsToRead);            for (int i = 5 - 1; i >= 5 - bytesToRead; i--) {                buffer |= (((long) in.read()) & 255) << (i * 8);            }            count = 8;            totalRead = valueCount;        } else {            buffer = ((((long) in.read()) & 255) << 32) + ((((long) in.read()) & 255) << 24) + (in.read() << 16) + (in.read() << 8) + in.read();            count = 8;            totalRead += 8;        }    }    int result = (((int) (buffer >> ((count - 1) * 5))) & 31);    --count;    return result;}
8336374318f968680be5b9b293b7b189f50c61d77428a81a148212a8c86d00e3
write
public void write(int val) throws IOException
{    buffer = buffer << 6;    buffer |= val;    ++count;    if (count == 4) {        out.write((buffer >>> 16) & 0xFF);        out.write((buffer >>> 8) & 0xFF);        out.write((buffer >>> 0) & 0xFF);        buffer = 0;        count = 0;    }}
744f86b085b6d15c99aff81723cd20f3131d09bb239c3df9e2454bcc8a1a5a5f
finish
public void finish() throws IOException
{    if (count != 0) {        int numberOfBits = count * 6;        finish(numberOfBits, buffer, out);        buffer = 0;        count = 0;    }        out = null;}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    if (count == 0) {        if (valueCount - totalRead < 4) {            buffer = 0;            int bitsToRead = 6 * (int) (valueCount - totalRead);            int bytesToRead = alignToBytes(bitsToRead);            for (int i = 3 - 1; i >= 3 - bytesToRead; i--) {                buffer |= in.read() << (i * 8);            }            count = 4;            totalRead = valueCount;        } else {            buffer = (in.read() << 16) + (in.read() << 8) + in.read();            count = 4;            totalRead += 4;        }    }    int result = (buffer >> ((count - 1) * 6)) & 63;    --count;    return result;}
8336374318f968680be5b9b293b7b189f50c61d77428a81a148212a8c86d00e3
write
public void write(int val) throws IOException
{    buffer = buffer << 7;    buffer |= val;    ++count;    if (count == 8) {        out.write((int) (buffer >>> 48) & 0xFF);        out.write((int) (buffer >>> 40) & 0xFF);        out.write((int) (buffer >>> 32) & 0xFF);        out.write((int) (buffer >>> 24) & 0xFF);        out.write((int) (buffer >>> 16) & 0xFF);        out.write((int) (buffer >>> 8) & 0xFF);        out.write((int) (buffer >>> 0) & 0xFF);        buffer = 0;        count = 0;    }}
744f86b085b6d15c99aff81723cd20f3131d09bb239c3df9e2454bcc8a1a5a5f
finish
public void finish() throws IOException
{    if (count != 0) {        int numberOfBits = count * 7;        finish(numberOfBits, buffer, out);        buffer = 0;        count = 0;    }        out = null;}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    if (count == 0) {        if (valueCount - totalRead < 8) {            buffer = 0;            int bitsToRead = 7 * (int) (valueCount - totalRead);            int bytesToRead = alignToBytes(bitsToRead);            for (int i = 7 - 1; i >= 7 - bytesToRead; i--) {                buffer |= (((long) in.read()) & 255) << (i * 8);            }            count = 8;            totalRead = valueCount;        } else {            buffer = ((((long) in.read()) & 255) << 48) + ((((long) in.read()) & 255) << 40) + ((((long) in.read()) & 255) << 32) + ((((long) in.read()) & 255) << 24) + (in.read() << 16) + (in.read() << 8) + in.read();            count = 8;            totalRead += 8;        }    }    int result = (((int) (buffer >> ((count - 1) * 7))) & 127);    --count;    return result;}
8336374318f968680be5b9b293b7b189f50c61d77428a81a148212a8c86d00e3
write
public void write(int val) throws IOException
{    out.write(val);}
744f86b085b6d15c99aff81723cd20f3131d09bb239c3df9e2454bcc8a1a5a5f
finish
public void finish() throws IOException
{        out = null;}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    return in.read();}
becc5c024a78e36f62372c94a18ad86d7a668c73c902541926c9abb38e6db3c3
writeInt
public void writeInt(int value) throws IOException
{    input[inputSize] = value;    ++inputSize;    if (inputSize == VALUES_WRITTEN_AT_A_TIME) {        pack();        if (packedPosition == slabSize) {            slabs.add(BytesInput.from(packed));            totalFullSlabSize += slabSize;            if (slabSize < bitWidth * MAX_SLAB_SIZE_MULT) {                slabSize *= 2;            }            initPackedSlab();        }    }}
fdfc044ee62f1a080d4497f54ababe553d0169ce0756bf34a8d57f437617051c
pack
private void pack()
{    packer.pack8Values(input, 0, packed, packedPosition);    packedPosition += bitWidth;    totalValues += inputSize;    inputSize = 0;}
9c9f4622e9da52261dae565a2b98fa2448d5eeac2d79d893168502c7f77b80f3
initPackedSlab
private void initPackedSlab()
{    packed = new byte[slabSize];    packedPosition = 0;}
d5a4162523f7bbffbea0fd20903b6ebeb901ae80867c3cab4cb908f402532c63
toBytes
public BytesInput toBytes() throws IOException
{    int packedByteLength = packedPosition + BytesUtils.paddedByteCountFromBits(inputSize * bitWidth);    LOG.debug("writing {} bytes", (totalFullSlabSize + packedByteLength));    if (inputSize > 0) {        for (int i = inputSize; i < input.length; i++) {            input[i] = 0;        }        pack();    }    return concat(concat(slabs), BytesInput.from(packed, 0, packedByteLength));}
b3416754c2718b74c03a182d787140f7b028359006abd365c411a03c8cb11c5d
getBufferSize
public long getBufferSize()
{    return BytesUtils.paddedByteCountFromBits((totalValues + inputSize) * bitWidth);}
3276143416d44249f488f85b127246b083e1e6024d88125aae60e635a8ad8ba7
getAllocatedSize
public long getAllocatedSize()
{    return totalFullSlabSize + packed.length + input.length * 4;}
729f860abc36decbc60be91f7b83b54762252f09cb85d7c4e9f7517c5dace502
memUsageString
public String memUsageString(String prefix)
{    return String.format("%s ByteBitPacking %d slabs, %d bytes", prefix, slabs.size(), getAllocatedSize());}
fdb212b53fd1ef044f3dc4a19828958dba81c9f35edc0549252766a5582a6138
getNumSlabs
 int getNumSlabs()
{    return slabs.size() + 1;}
0357cddc0e7cfd27a525f535747811913a9ef400c8a82780175177d7512f9065
getBitWidth
public final int getBitWidth()
{    return bitWidth;}
d8eefce839e8094954580689d9b17ef4ab2e17629d9ff02afcb7b3ba6441cd68
unpack8Values
public void unpack8Values(final byte[] input, final int inPos, final int[] output, final int outPos)
{    unpack8Values(ByteBuffer.wrap(input), inPos, output, outPos);}
044331f0a0b3f013ed2d86ae1e445be1533f5dfd8bb32ab71f6dc7d42e32d9f9
unpack32Values
public void unpack32Values(byte[] input, int inPos, int[] output, int outPos)
{    unpack32Values(ByteBuffer.wrap(input), inPos, output, outPos);}
0357cddc0e7cfd27a525f535747811913a9ef400c8a82780175177d7512f9065
getBitWidth
public final int getBitWidth()
{    return bitWidth;}
0357cddc0e7cfd27a525f535747811913a9ef400c8a82780175177d7512f9065
getBitWidth
public final int getBitWidth()
{    return bitWidth;}
a716080530c915fc445d59f7ad2d2ba170021a7ee5f0ed9a10641af9a8f49679
getIntPackerFactory
private static IntPackerFactory getIntPackerFactory(String name)
{    return (IntPackerFactory) getStaticField("org.apache.parquet.column.values.bitpacking." + name, "factory");}
858318d5fe96c8a73a92fd98e1f9f09e3ebd5f2819808c207afa458f148c3347
getBytePackerFactory
private static BytePackerFactory getBytePackerFactory(String name)
{    return (BytePackerFactory) getStaticField("org.apache.parquet.column.values.bitpacking." + name, "factory");}
b48244672bfd2a4b64478bba442a91efc9442ef9e5b01af160c3fc0ff256c1f6
getBytePackerForLongFactory
private static BytePackerForLongFactory getBytePackerForLongFactory(String name)
{    return (BytePackerForLongFactory) getStaticField("org.apache.parquet.column.values.bitpacking." + name, "factory");}
12ed00969f8756422fb13b9b21e0841266314b952dacea45081d0c0e7aaca535
getStaticField
private static Object getStaticField(String className, String fieldName)
{    try {        return Class.forName(className).getField(fieldName).get(null);    } catch (IllegalArgumentException e) {        throw new RuntimeException(e);    } catch (IllegalAccessException e) {        throw new RuntimeException(e);    } catch (NoSuchFieldException e) {        throw new RuntimeException(e);    } catch (SecurityException e) {        throw new RuntimeException(e);    } catch (ClassNotFoundException e) {        throw new RuntimeException(e);    }}
aab84c032f9dfb06e8c50f11820579423cb45706e1d836b89dd3391654b17e8e
newIntPacker
public IntPacker newIntPacker(int width)
{    return beIntPackerFactory.newIntPacker(width);}
32d24591165ce749e58e50a67cf4f139d5d5e961a3aeb96a3d36335935fddb05
newBytePacker
public BytePacker newBytePacker(int width)
{    return beBytePackerFactory.newBytePacker(width);}
1af1ac2c2a0d88e36d217d1a7c72f4267d1afef31100178790bf299763dc9ffa
newBytePackerForLong
public BytePackerForLong newBytePackerForLong(int width)
{    return beBytePackerForLongFactory.newBytePackerForLong(width);}
aab84c032f9dfb06e8c50f11820579423cb45706e1d836b89dd3391654b17e8e
newIntPacker
public IntPacker newIntPacker(int width)
{    return leIntPackerFactory.newIntPacker(width);}
32d24591165ce749e58e50a67cf4f139d5d5e961a3aeb96a3d36335935fddb05
newBytePacker
public BytePacker newBytePacker(int width)
{    return leBytePackerFactory.newBytePacker(width);}
1af1ac2c2a0d88e36d217d1a7c72f4267d1afef31100178790bf299763dc9ffa
newBytePackerForLong
public BytePackerForLong newBytePackerForLong(int width)
{    return leBytePackerForLongFactory.newBytePackerForLong(width);}
74e41adce870e811577f9748ceb332ddc80bc0454931734216ea550e52faa0b0
testWriteInt
public void testWriteInt() throws Throwable
{    int[] testVals = { Integer.MIN_VALUE, Integer.MAX_VALUE, 0, 100, 1000, 0xdaedbeef };    for (Integer testVal : testVals) {        BytesInput varInt = BytesInput.fromUnsignedVarInt(testVal);        byte[] rno = varInt.toByteArray();        int i = BytesUtils.readUnsignedVarInt(new ByteArrayInputStream(rno));        assertEquals((int) testVal, i);    }}
1fd72acda67abb3a5768328b96d7803a2173ee40d822c0054a2d29f36c7da9ba
testWrite
public void testWrite() throws Throwable
{    CapacityByteArrayOutputStream capacityByteArrayOutputStream = newCapacityBAOS(10);    final int expectedSize = 54;    for (int i = 0; i < expectedSize; i++) {        capacityByteArrayOutputStream.write(i);        assertEquals(i + 1, capacityByteArrayOutputStream.size());    }    validate(capacityByteArrayOutputStream, expectedSize);}
b7334cdf9df66dc6934faa77d38cd9467d66a869d475072398a23e2f91c95251
testWriteArray
public void testWriteArray() throws Throwable
{    CapacityByteArrayOutputStream capacityByteArrayOutputStream = newCapacityBAOS(10);    int v = 23;    writeArraysOf3(capacityByteArrayOutputStream, v);    validate(capacityByteArrayOutputStream, v * 3);}
70d7ffa3c8ea6b5d1929b84b31d0c2cddf7dd0b54a6026c0b1ed314b08a69d5b
testWriteArrayAndInt
public void testWriteArrayAndInt() throws Throwable
{    CapacityByteArrayOutputStream capacityByteArrayOutputStream = newCapacityBAOS(10);    for (int i = 0; i < 23; i++) {        byte[] toWrite = { (byte) (i * 3), (byte) (i * 3 + 1) };        capacityByteArrayOutputStream.write(toWrite);        capacityByteArrayOutputStream.write((byte) (i * 3 + 2));        assertEquals((i + 1) * 3, capacityByteArrayOutputStream.size());    }    validate(capacityByteArrayOutputStream, 23 * 3);}
7cb6e611a618924c46460ba213fc4d4c139b6d7aa1b0ac88553d0e4f2db62abe
newCapacityBAOS
protected CapacityByteArrayOutputStream newCapacityBAOS(int initialSize)
{    return new CapacityByteArrayOutputStream(initialSize, 1000000, new HeapByteBufferAllocator());}
81462e017c2f31090cd03440e8d4dbda73695a6c3f5a3ed38168fc52a365d63c
testReset
public void testReset() throws Throwable
{    CapacityByteArrayOutputStream capacityByteArrayOutputStream = newCapacityBAOS(10);    for (int i = 0; i < 54; i++) {        capacityByteArrayOutputStream.write(i);        assertEquals(i + 1, capacityByteArrayOutputStream.size());    }    capacityByteArrayOutputStream.reset();    for (int i = 0; i < 54; i++) {        capacityByteArrayOutputStream.write(54 + i);        assertEquals(i + 1, capacityByteArrayOutputStream.size());    }    final byte[] byteArray = BytesInput.from(capacityByteArrayOutputStream).toByteArray();    assertEquals(54, byteArray.length);    for (int i = 0; i < 54; i++) {        assertEquals(i + " in " + Arrays.toString(byteArray), 54 + i, byteArray[i]);    }}
02ad011b8728734921956e2671b933c172cf58b9a56736089d5f1faedc66f3af
testWriteArrayBiggerThanSlab
public void testWriteArrayBiggerThanSlab() throws Throwable
{    CapacityByteArrayOutputStream capacityByteArrayOutputStream = newCapacityBAOS(10);    int v = 23;    writeArraysOf3(capacityByteArrayOutputStream, v);    int n = v * 3;    byte[] toWrite = {     (byte) n, (byte) (n + 1), (byte) (n + 2), (byte) (n + 3), (byte) (n + 4), (byte) (n + 5), (byte) (n + 6), (byte) (n + 7), (byte) (n + 8), (byte) (n + 9), (byte) (n + 10), (byte) (n + 11), (byte) (n + 12), (byte) (n + 13), (byte) (n + 14), (byte) (n + 15), (byte) (n + 16), (byte) (n + 17), (byte) (n + 18), (byte) (n + 19), (byte) (n + 20) };    capacityByteArrayOutputStream.write(toWrite);    n = n + toWrite.length;    assertEquals(n, capacityByteArrayOutputStream.size());    validate(capacityByteArrayOutputStream, n);    capacityByteArrayOutputStream.reset();        capacityByteArrayOutputStream.write(toWrite);    assertEquals(toWrite.length, capacityByteArrayOutputStream.size());    byte[] byteArray = BytesInput.from(capacityByteArrayOutputStream).toByteArray();    assertEquals(toWrite.length, byteArray.length);    for (int i = 0; i < toWrite.length; i++) {        assertEquals(toWrite[i], byteArray[i]);    }}
a4beaa86a7cb4343260f23fedd023b375e5a2965a86c24fed493354b3f730feb
testWriteArrayManySlabs
public void testWriteArrayManySlabs() throws Throwable
{    CapacityByteArrayOutputStream capacityByteArrayOutputStream = newCapacityBAOS(10);    int it = 500;    int v = 23;    for (int j = 0; j < it; j++) {        for (int i = 0; i < v; i++) {            byte[] toWrite = { (byte) (i * 3), (byte) (i * 3 + 1), (byte) (i * 3 + 2) };            capacityByteArrayOutputStream.write(toWrite);            assertEquals((i + 1) * 3 + v * 3 * j, capacityByteArrayOutputStream.size());        }    }    byte[] byteArray = BytesInput.from(capacityByteArrayOutputStream).toByteArray();    assertEquals(v * 3 * it, byteArray.length);    for (int i = 0; i < v * 3 * it; i++) {        assertEquals(i % (v * 3), byteArray[i]);    }        assertTrue("slab count: " + capacityByteArrayOutputStream.getSlabCount(), capacityByteArrayOutputStream.getSlabCount() <= 20);    capacityByteArrayOutputStream.reset();    writeArraysOf3(capacityByteArrayOutputStream, v);    validate(capacityByteArrayOutputStream, v * 3);        assertTrue("slab count: " + capacityByteArrayOutputStream.getSlabCount(), capacityByteArrayOutputStream.getSlabCount() <= 2);}
cb0b0a5e57dde43cd74287f9c7d62f54a152510f68040c329d388cf9a2d71c45
testReplaceByte
public void testReplaceByte() throws Throwable
{        {        CapacityByteArrayOutputStream cbaos = newCapacityBAOS(5);        cbaos.write(10);        assertEquals(0, cbaos.getCurrentIndex());        cbaos.setByte(0, (byte) 7);        ByteArrayOutputStream baos = new ByteArrayOutputStream();        cbaos.writeTo(baos);        assertEquals(7, baos.toByteArray()[0]);    }        {        CapacityByteArrayOutputStream cbaos = newCapacityBAOS(5);        cbaos.write(10);        cbaos.write(13);        cbaos.write(15);        cbaos.write(17);        assertEquals(3, cbaos.getCurrentIndex());        cbaos.write(19);        cbaos.setByte(3, (byte) 7);        ByteArrayOutputStream baos = new ByteArrayOutputStream();        cbaos.writeTo(baos);        assertArrayEquals(new byte[] { 10, 13, 15, 7, 19 }, baos.toByteArray());    }        {        CapacityByteArrayOutputStream cbaos = newCapacityBAOS(5);                for (int i = 0; i < 12; i++) {            cbaos.write(100 + i);        }        assertEquals(11, cbaos.getCurrentIndex());        cbaos.setByte(6, (byte) 7);        ByteArrayOutputStream baos = new ByteArrayOutputStream();        cbaos.writeTo(baos);        assertArrayEquals(new byte[] { 100, 101, 102, 103, 104, 105, 7, 107, 108, 109, 110, 111 }, baos.toByteArray());    }        {        CapacityByteArrayOutputStream cbaos = newCapacityBAOS(5);                for (int i = 0; i < 12; i++) {            cbaos.write(100 + i);        }        assertEquals(11, cbaos.getCurrentIndex());        cbaos.setByte(9, (byte) 7);        ByteArrayOutputStream baos = new ByteArrayOutputStream();        cbaos.writeTo(baos);        assertArrayEquals(new byte[] { 100, 101, 102, 103, 104, 105, 106, 107, 108, 7, 110, 111 }, baos.toByteArray());    }        {        CapacityByteArrayOutputStream cbaos = newCapacityBAOS(5);                for (int i = 0; i < 12; i++) {            cbaos.write(100 + i);        }        assertEquals(11, cbaos.getCurrentIndex());        cbaos.setByte(11, (byte) 7);        ByteArrayOutputStream baos = new ByteArrayOutputStream();        cbaos.writeTo(baos);        assertArrayEquals(new byte[] { 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 7 }, baos.toByteArray());    }}
4837498fb90fd8ccffc2c17754429035d9f80bceed79b3dc297a663ffbccb167
writeArraysOf3
private void writeArraysOf3(CapacityByteArrayOutputStream capacityByteArrayOutputStream, int n) throws IOException
{    for (int i = 0; i < n; i++) {        byte[] toWrite = { (byte) (i * 3), (byte) (i * 3 + 1), (byte) (i * 3 + 2) };        capacityByteArrayOutputStream.write(toWrite);        assertEquals((i + 1) * 3, capacityByteArrayOutputStream.size());    }}
55da4aef96461492a7bdd24ead3b6eae251d92793bf50b70ea4c00b97e73b2f9
validate
private void validate(CapacityByteArrayOutputStream capacityByteArrayOutputStream, final int expectedSize) throws IOException
{    final byte[] byteArray = BytesInput.from(capacityByteArrayOutputStream).toByteArray();    assertEquals(expectedSize, byteArray.length);    for (int i = 0; i < expectedSize; i++) {        assertEquals(i, byteArray[i]);    }}
5630f560aa182ff99a0dde428f64803fb0c325c25e9cad41ea2da67399b094ca
testZero
public void testZero() throws IOException
{    int bitLength = 0;    int[] vals = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };    String expected = "";    validateEncodeDecode(bitLength, vals, expected);}
1394e88db5506af6ddeb2f5491662107a6d13332c1ae291b5a73d367d2bbddda
testOne_0
public void testOne_0() throws IOException
{    int[] vals = { 0 };    String expected = "00000000";    validateEncodeDecode(1, vals, expected);}
c15b58b737217fa89703024cb421cfa028b2b28d6e61a11804c5c9e255994842
testOne_1
public void testOne_1() throws IOException
{    int[] vals = { 1 };    String expected = "10000000";    validateEncodeDecode(1, vals, expected);}
a2ee7c84c62d7a85298d00bac2e8762a8d0d83cfe395ce1757b28d8cc8a3c23a
testOne_0_0
public void testOne_0_0() throws IOException
{    int[] vals = { 0, 0 };    String expected = "00000000";    validateEncodeDecode(1, vals, expected);}
42857fffdaa7724e34dff4097c170af0de5ce90c00f37c8368bcf79a16c3a450
testOne_1_1
public void testOne_1_1() throws IOException
{    int[] vals = { 1, 1 };    String expected = "11000000";    validateEncodeDecode(1, vals, expected);}
74ef617f73f5eb132e8a374e4026f15b88fe383842b338282457fb916f621e28
testOne_9_1s
public void testOne_9_1s() throws IOException
{    int[] vals = { 1, 1, 1, 1, 1, 1, 1, 1, 1 };    String expected = "11111111 10000000";    validateEncodeDecode(1, vals, expected);}
8f5aa40d6bcc56c886231c63162f885c8dae19e04abb704637facf36b599d6fd
testOne_9_0s
public void testOne_9_0s() throws IOException
{    int[] vals = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };    String expected = "00000000 00000000";    validateEncodeDecode(1, vals, expected);}
f6a4525ef820cfd8a1e7ab487c1cb14c4f268f3725d750d3a29a7ca8ceb6edbe
testOne_7_0s_1_1
public void testOne_7_0s_1_1() throws IOException
{    int[] vals = { 0, 0, 0, 0, 0, 0, 0, 1 };    String expected = "00000001";    validateEncodeDecode(1, vals, expected);}
027b49680baddba2e863d6eb1ed8093050dfc932fdf218a1e844899bb32af7a1
testOne_9_0s_1_1
public void testOne_9_0s_1_1() throws IOException
{    int[] vals = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 };    String expected = "00000000 01000000";    validateEncodeDecode(1, vals, expected);}
eab8d4d3e2375d6f62c3e9786473d36cd0cff0ed6904410fe8a489a57c65d6a2
testOne
public void testOne() throws IOException
{    int[] vals = { 0, 1, 0, 0, 1, 1, 1, 0, 0, 1 };    String expected = "01001110 01000000";    validateEncodeDecode(1, vals, expected);}
3d4e618f65eff917e616a3b799bc55ec1cb5ed45ed7e80d2e56d03b81e16a9c7
testTwo
public void testTwo() throws IOException
{    int[] vals = { 0, 1, 2, 3, 3, 3, 2, 1, 1, 0, 0, 0, 1 };    String expected = "00011011 11111001 01000000 01000000";    validateEncodeDecode(2, vals, expected);}
a6311870f518a302ef942c253b77dbe9ecd4bb7a3ff7b743e9bae63b59ed1bb8
testThree
public void testThree() throws IOException
{    int[] vals = { 0, 1, 2, 3, 4, 5, 6, 7, 1 };    String expected = "00000101 00111001 01110111 " + "00100000";    validateEncodeDecode(3, vals, expected);}
098b6fe03a658953a4fc82785d520ea2fc6eae7e2918a762ac2252c35ace593b
testFour
public void testFour() throws IOException
{    int[] vals = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1 };    String expected = "00000001 00100011 01000101 01100111 10001001 10101011 11001101 11101111 00010000";    validateEncodeDecode(4, vals, expected);}
61b7cc4a0b46d978d99184561c59a23f0415748a413a25cd682702cd16f33430
testFive
public void testFive() throws IOException
{    int[] vals = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 1 };    String expected = "00000000 01000100 00110010 00010100 11000111 " + "01000010 01010100 10110110 00110101 11001111 " + "10000100 01100101 00111010 01010110 11010111 " + "11000110 01110101 10111110 01110111 11011111 " + "00001000";    validateEncodeDecode(5, vals, expected);}
2e8e5de9853a51714f775cdf535f190799d4157c5d00b51f7ec06bf373a96672
testSix
public void testSix() throws IOException
{    int[] vals = { 0, 28, 34, 35, 63, 1 };        String expected = "00000001 11001000 10100011 " + "11111100 00010000";    validateEncodeDecode(6, vals, expected);}
6b4634c8635be36cfd07b28bdbde77a35899030d94a28aa2ee6a0e43df58254e
testSeven
public void testSeven() throws IOException
{    int[] vals = { 0, 28, 34, 35, 63, 1, 125, 1, 1 };        String expected = "00000000 01110001 00010010 00110111 11100000 01111110 10000001 " + "00000010";    validateEncodeDecode(7, vals, expected);}
9f7b708d559e516ef201460d896f024a543b1ca2085fe385569e8e68426c0f24
validateEncodeDecode
private void validateEncodeDecode(int bitLength, int[] vals, String expected) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BitPackingWriter w = BitPacking.getBitPackingWriter(bitLength, baos);    for (int i : vals) {        w.write(i);    }    w.finish();    byte[] bytes = baos.toByteArray();    LOG.debug("vals (" + bitLength + "): " + toString(vals));    LOG.debug("bytes: {}", toString(bytes));    Assert.assertEquals(expected, toString(bytes));    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);    BitPackingReader r = BitPacking.createBitPackingReader(bitLength, bais, vals.length);    int[] result = new int[vals.length];    for (int i = 0; i < result.length; i++) {        result[i] = r.read();    }    LOG.debug("result: {}", toString(result));    assertArrayEquals(vals, result);}
32f2bb13871485ccb818ab69d59877c3e4c7f63a7a8b0dc0a783265bd0434f5a
toString
public static String toString(int[] vals)
{    StringBuilder sb = new StringBuilder();    boolean first = true;    for (int i : vals) {        if (first) {            first = false;        } else {            sb.append(" ");        }        sb.append(i);    }    return sb.toString();}
02ea56010823a6fbe8d7d54de27ec908e87860f31703a8c659fcca35085fb162
toString
public static String toString(long[] vals)
{    StringBuilder sb = new StringBuilder();    boolean first = true;    for (long i : vals) {        if (first) {            first = false;        } else {            sb.append(" ");        }        sb.append(i);    }    return sb.toString();}
3674a11004995ef53613a451f45a1b7adb0f24bda0f6656c0e9e19cd1d1c03f1
toString
public static String toString(byte[] bytes)
{    StringBuilder sb = new StringBuilder();    boolean first = true;    for (byte b : bytes) {        if (first) {            first = false;        } else {            sb.append(" ");        }        int i = b < 0 ? 256 + b : b;        String binaryString = Integer.toBinaryString(i);        for (int j = binaryString.length(); j < 8; ++j) {            sb.append("0");        }        sb.append(binaryString);    }    return sb.toString();}
fcfdf7d6b84dece9f51e32a4b9347f6af4a9077e190d5016adc36fbc126f7984
testSlabBoundary
public void testSlabBoundary()
{    for (int i = 0; i <= 32; i++) {        final ByteBasedBitPackingEncoder encoder = new ByteBasedBitPackingEncoder(i, Packer.BIG_ENDIAN);                final int totalValues = 191 * 1024 * 8 + 10;        for (int j = 0; j < totalValues; j++) {            try {                encoder.writeInt(j);            } catch (Exception e) {                throw new RuntimeException(i + ": error writing " + j, e);            }        }        assertEquals(BytesUtils.paddedByteCountFromBits(totalValues * i), encoder.getBufferSize());        assertEquals(i == 0 ? 1 : 9, encoder.getNumSlabs());    }}
369a6a91bc1c8b78d0922cb7318438963fbba782361e6dcd9494b8fa4fc20c23
testPackUnPack
public void testPackUnPack()
{    LOG.debug("");    LOG.debug("testPackUnPack");    for (int i = 1; i < 32; i++) {        LOG.debug("Width: {}", i);        int[] unpacked = new int[32];        int[] values = generateValues(i);        packUnpack(Packer.BIG_ENDIAN.newBytePacker(i), values, unpacked);        LOG.debug("Output: {}", TestBitPacking.toString(unpacked));        Assert.assertArrayEquals("width " + i, values, unpacked);    }}
0b4c26e7686b90cb91475746448ce62563bb918346816b997bc6f969564a2c8f
testPackUnPackLong
public void testPackUnPackLong()
{    LOG.debug("");    LOG.debug("testPackUnPackLong");    for (int i = 1; i < 64; i++) {        LOG.debug("Width: {}", i);        long[] unpacked32 = new long[32];        long[] unpacked8 = new long[32];        long[] values = generateValuesLong(i);        packUnpack32(Packer.BIG_ENDIAN.newBytePackerForLong(i), values, unpacked32);        LOG.debug("Output 32: {}", TestBitPacking.toString(unpacked32));        Assert.assertArrayEquals("width " + i, values, unpacked32);        packUnpack8(Packer.BIG_ENDIAN.newBytePackerForLong(i), values, unpacked8);        LOG.debug("Output 8: {}", TestBitPacking.toString(unpacked8));        Assert.assertArrayEquals("width " + i, values, unpacked8);    }}
3d982812b2f96958b54c55f0f862cccc8696ce3cd896a6d1de814a3439938f32
packUnpack
private void packUnpack(BytePacker packer, int[] values, int[] unpacked)
{    byte[] packed = new byte[packer.getBitWidth() * 4];    packer.pack32Values(values, 0, packed, 0);    LOG.debug("packed: {}", TestBitPacking.toString(packed));    packer.unpack32Values(ByteBuffer.wrap(packed), 0, unpacked, 0);}
1804d17b1becbe059058f61c6ba71129992a3f533311b4233f885e5be5a769af
packUnpack32
private void packUnpack32(BytePackerForLong packer, long[] values, long[] unpacked)
{    byte[] packed = new byte[packer.getBitWidth() * 4];    packer.pack32Values(values, 0, packed, 0);    LOG.debug("packed: {}", TestBitPacking.toString(packed));    packer.unpack32Values(packed, 0, unpacked, 0);}
d85ee9dfd1276809095abd4ac514111781e10ccf34bdc19a9ee953b90fa93c67
packUnpack8
private void packUnpack8(BytePackerForLong packer, long[] values, long[] unpacked)
{    byte[] packed = new byte[packer.getBitWidth() * 4];    for (int i = 0; i < 4; i++) {        packer.pack8Values(values, 8 * i, packed, packer.getBitWidth() * i);    }    LOG.debug("packed: {}", TestBitPacking.toString(packed));    for (int i = 0; i < 4; i++) {        packer.unpack8Values(packed, packer.getBitWidth() * i, unpacked, 8 * i);    }}
69339aec588f0551df1561f35904e1723e27ddf73e0ed2f30630670cea01a4b5
generateValues
private int[] generateValues(int bitWidth)
{    int[] values = new int[32];    for (int j = 0; j < values.length; j++) {        values[j] = (int) (Math.random() * 100000) % (int) Math.pow(2, bitWidth);    }    LOG.debug("Input:  {}", TestBitPacking.toString(values));    return values;}
0069abd065adfb2336a1a8e22f7533a2b803006377599cf9c1b8b3a15dd4c8c0
generateValuesLong
private long[] generateValuesLong(int bitWidth)
{    long[] values = new long[32];    Random random = new Random(0);    for (int j = 0; j < values.length; j++) {        values[j] = random.nextLong() & ((1l << bitWidth) - 1l);    }    LOG.debug("Input:  {}", TestBitPacking.toString(values));    return values;}
faace70c36621f51d22670cd4a84062b4af4eed078409c63f71b7207c35d7223
testPackUnPackAgainstHandWritten
public void testPackUnPackAgainstHandWritten() throws IOException
{    LOG.debug("");    LOG.debug("testPackUnPackAgainstHandWritten");    for (int i = 1; i < 8; i++) {        LOG.debug("Width: {}", i);        byte[] packed = new byte[i * 4];        int[] unpacked = new int[32];        int[] values = generateValues(i);                final BytePacker packer = Packer.BIG_ENDIAN.newBytePacker(i);        packer.pack32Values(values, 0, packed, 0);        LOG.debug("Generated: {}", TestBitPacking.toString(packed));                final ByteArrayOutputStream manualOut = new ByteArrayOutputStream();        final BitPackingWriter writer = BitPacking.getBitPackingWriter(i, manualOut);        for (int j = 0; j < values.length; j++) {            writer.write(values[j]);        }        final byte[] packedManualAsBytes = manualOut.toByteArray();        LOG.debug("Manual: {}", TestBitPacking.toString(packedManualAsBytes));                final BitPackingReader reader = BitPacking.createBitPackingReader(i, new ByteArrayInputStream(packed), 32);        for (int j = 0; j < unpacked.length; j++) {            unpacked[j] = reader.read();        }        LOG.debug("Output: {}", TestBitPacking.toString(unpacked));        Assert.assertArrayEquals("width " + i, values, unpacked);    }}
58f27c308e87b5a06b3d8ca5aa4a1203e4545c76a116f614fb749720b448e43f
testPackUnPackAgainstLemire
public void testPackUnPackAgainstLemire() throws IOException
{    for (Packer pack : Packer.values()) {        LOG.debug("");        LOG.debug("testPackUnPackAgainstLemire {}", pack.name());        for (int i = 1; i < 32; i++) {            LOG.debug("Width: {}", i);            int[] packed = new int[i];            int[] unpacked = new int[32];            int[] values = generateValues(i);                        final IntPacker packer = pack.newIntPacker(i);            packer.pack32Values(values, 0, packed, 0);                        final ByteArrayOutputStream lemireOut = new ByteArrayOutputStream();            for (int v : packed) {                switch(pack) {                    case LITTLE_ENDIAN:                        lemireOut.write((v >>> 0) & 0xFF);                        lemireOut.write((v >>> 8) & 0xFF);                        lemireOut.write((v >>> 16) & 0xFF);                        lemireOut.write((v >>> 24) & 0xFF);                        break;                    case BIG_ENDIAN:                        lemireOut.write((v >>> 24) & 0xFF);                        lemireOut.write((v >>> 16) & 0xFF);                        lemireOut.write((v >>> 8) & 0xFF);                        lemireOut.write((v >>> 0) & 0xFF);                        break;                }            }            final byte[] packedByLemireAsBytes = lemireOut.toByteArray();            LOG.debug("Lemire out: {}", TestBitPacking.toString(packedByLemireAsBytes));                        final BytePacker bytePacker = pack.newBytePacker(i);            byte[] packedGenerated = new byte[i * 4];            bytePacker.pack32Values(values, 0, packedGenerated, 0);            LOG.debug("Gener. out: {}", TestBitPacking.toString(packedGenerated));            Assert.assertEquals(pack.name() + " width " + i, TestBitPacking.toString(packedByLemireAsBytes), TestBitPacking.toString(packedGenerated));            bytePacker.unpack32Values(ByteBuffer.wrap(packedByLemireAsBytes), 0, unpacked, 0);            LOG.debug("Output: {}", TestBitPacking.toString(unpacked));            Assert.assertArrayEquals("width " + i, values, unpacked);        }    }}
369a6a91bc1c8b78d0922cb7318438963fbba782361e6dcd9494b8fa4fc20c23
testPackUnPack
public void testPackUnPack()
{    for (Packer packer : Packer.values()) {        LOG.debug("");        LOG.debug("testPackUnPack");        for (int i = 1; i < 32; i++) {            LOG.debug("Width: {}", i);            int[] values = generateValues(i);            int[] unpacked = new int[32];            {                packUnpack(packer.newIntPacker(i), values, unpacked);                LOG.debug("int based Output " + packer.name() + ": " + TestBitPacking.toString(unpacked));                Assert.assertArrayEquals(packer.name() + " width " + i, values, unpacked);            }            {                packUnpack(packer.newBytePacker(i), values, unpacked);                LOG.debug("byte based Output " + packer.name() + ": " + TestBitPacking.toString(unpacked));                Assert.assertArrayEquals(packer.name() + " width " + i, values, unpacked);            }        }    }}
83d5b5a5d08513927a030d4dc7c124324feaed403da9c7bb75ce96b304444da6
packUnpack
private void packUnpack(IntPacker packer, int[] values, int[] unpacked)
{    int[] packed = new int[packer.getBitWidth()];    packer.pack32Values(values, 0, packed, 0);    packer.unpack32Values(packed, 0, unpacked, 0);}
3d982812b2f96958b54c55f0f862cccc8696ce3cd896a6d1de814a3439938f32
packUnpack
private void packUnpack(BytePacker packer, int[] values, int[] unpacked)
{    byte[] packed = new byte[packer.getBitWidth() * 4];    packer.pack32Values(values, 0, packed, 0);    packer.unpack32Values(ByteBuffer.wrap(packed), 0, unpacked, 0);}
69339aec588f0551df1561f35904e1723e27ddf73e0ed2f30630670cea01a4b5
generateValues
private int[] generateValues(int bitWidth)
{    int[] values = new int[32];    for (int j = 0; j < values.length; j++) {        values[j] = (int) (Math.random() * 100000) % (int) Math.pow(2, bitWidth);    }    LOG.debug("Input:  {}", TestBitPacking.toString(values));    return values;}
faace70c36621f51d22670cd4a84062b4af4eed078409c63f71b7207c35d7223
testPackUnPackAgainstHandWritten
public void testPackUnPackAgainstHandWritten() throws IOException
{    LOG.debug("");    LOG.debug("testPackUnPackAgainstHandWritten");    for (int i = 1; i < 8; i++) {        LOG.debug("Width: {}", i);        int[] packed = new int[i];        int[] unpacked = new int[32];        int[] values = generateValues(i);                final IntPacker packer = Packer.BIG_ENDIAN.newIntPacker(i);        packer.pack32Values(values, 0, packed, 0);                final ByteArrayOutputStream lemireOut = new ByteArrayOutputStream();        for (int v : packed) {            lemireOut.write((v >>> 24) & 0xFF);            lemireOut.write((v >>> 16) & 0xFF);            lemireOut.write((v >>> 8) & 0xFF);            lemireOut.write((v >>> 0) & 0xFF);        }        final byte[] packedByLemireAsBytes = lemireOut.toByteArray();        LOG.debug("Lemire: {}", TestBitPacking.toString(packedByLemireAsBytes));                final ByteArrayOutputStream manualOut = new ByteArrayOutputStream();        final BitPackingWriter writer = BitPacking.getBitPackingWriter(i, manualOut);        for (int j = 0; j < values.length; j++) {            writer.write(values[j]);        }        final byte[] packedManualAsBytes = manualOut.toByteArray();        LOG.debug("Manual: {}", TestBitPacking.toString(packedManualAsBytes));                final BitPackingReader reader = BitPacking.createBitPackingReader(i, new ByteArrayInputStream(packedByLemireAsBytes), 32);        for (int j = 0; j < unpacked.length; j++) {            unpacked[j] = reader.read();        }        LOG.debug("Output: {}", TestBitPacking.toString(unpacked));        Assert.assertArrayEquals("width " + i, values, unpacked);    }}
102488811f0f2447c2de6185f8429c4ce43c8ccc7528a469b4455cc787467c33
onField
public DelegatingFieldConsumer onField(TFieldIdEnum e, TypedConsumer typedConsumer)
{    Map<Short, TypedConsumer> newContexts = new HashMap<Short, TypedConsumer>(contexts);    newContexts.put(e.getThriftFieldId(), typedConsumer);    return new DelegatingFieldConsumer(defaultFieldEventConsumer, newContexts);}
3793e26c26d1204bba19c7b779992ad9fbc1494a9792df1ab7b4339e4c23dbff
consumeField
public void consumeField(TProtocol protocol, EventBasedThriftReader reader, short id, byte type) throws TException
{    TypedConsumer delegate = contexts.get(id);    if (delegate != null) {        delegate.read(protocol, reader, type);    } else {        defaultFieldEventConsumer.consumeField(protocol, reader, id, type);    }}
7ff0898593c0143c4d95b1946b65b45a7a75e1337d7b9517d3d001f176417f71
fieldConsumer
public static DelegatingFieldConsumer fieldConsumer()
{    return new DelegatingFieldConsumer();}
dbefa4b6d0e735546fb65fd7cdcc757f4b0fce5e516ecc7097462c74b8fbad5b
listOf
public static ListConsumer listOf(Class<T> c, final Consumer<List<T>> consumer)
{    class ListConsumer implements Consumer<T> {        List<T> list;        @Override        public void consume(T t) {            list.add(t);        }    }    final ListConsumer co = new ListConsumer();    return new DelegatingListElementsConsumer(struct(c, co)) {        @Override        public void consumeList(TProtocol protocol, EventBasedThriftReader reader, TList tList) throws TException {            co.list = new ArrayList<T>();            super.consumeList(protocol, reader, tList);            consumer.consume(co.list);        }    };}
953384c3384d6c808a107db02623b567897eb98541609666a019cba1964a4b06
consume
public void consume(T t)
{    list.add(t);}
b08ccb1c9dd00d8283f5f0e788488d61108869cc6228cc8d1a2345673bf165aa
consumeList
public void consumeList(TProtocol protocol, EventBasedThriftReader reader, TList tList) throws TException
{    co.list = new ArrayList<T>();    super.consumeList(protocol, reader, tList);    consumer.consume(co.list);}
0a72f4a92aa3422e9dbdafa1d2090547dfe3a23b0c9232e9ae4c90ede13c2d6d
listElementsOf
public static ListConsumer listElementsOf(TypedConsumer consumer)
{    return new DelegatingListElementsConsumer(consumer);}
769503c744f73cf544dd43d106880fe0f29b7d66a1c3afb3b66004c22a29272b
struct
public static StructConsumer struct(final Class<T> c, final Consumer<T> consumer)
{    return new TBaseStructConsumer<T>(c, consumer);}
3793e26c26d1204bba19c7b779992ad9fbc1494a9792df1ab7b4339e4c23dbff
consumeField
public void consumeField(TProtocol protocol, EventBasedThriftReader reader, short id, byte type) throws TException
{    TProtocolUtil.skip(protocol, type);}
af82183a34869bec74fae59ccfa7644430185d3f65fae53cd7f2eeec07d1a5b8
consumeElement
public void consumeElement(TProtocol protocol, EventBasedThriftReader reader, byte elemType) throws TException
{    elementConsumer.read(protocol, reader, elemType);}
27fdb31a2eadb9e186515dd1fb5fd67d6c76acdff0a90c4305128ff72bc55ca5
consumeStruct
public void consumeStruct(TProtocol protocol, EventBasedThriftReader reader) throws TException
{    T o = newObject();    o.read(protocol);    consumer.consume(o);}
edbda0e56436be56005b189af4bc1aa50a935ef5f02e40dc56870a0a59e5c3f6
newObject
protected T newObject()
{    try {        return c.newInstance();    } catch (InstantiationException e) {        throw new RuntimeException(c.getName(), e);    } catch (IllegalAccessException e) {        throw new RuntimeException(c.getName(), e);    }}
f8cdb0aed9ebd050d7994984a6ca9a63294a67882f9d495ce9d49a2fdf58e361
readStruct
public void readStruct(FieldConsumer c) throws TException
{    protocol.readStructBegin();    readStructContent(c);    protocol.readStructEnd();}
5bfea98ad0c97dcc9f824fc9652243c2afb206910b34a7dee25b9cd466ca866e
readStructContent
public void readStructContent(FieldConsumer c) throws TException
{    TField field;    while (true) {        field = protocol.readFieldBegin();        if (field.type == TType.STOP) {            break;        }        c.consumeField(protocol, this, field.id, field.type);    }}
b5722c1a4310901184260875c714ae4639f798724f5e685a7267aa7ebbc1f5bc
readSetContent
public void readSetContent(SetConsumer eventConsumer, TSet tSet) throws TException
{    for (int i = 0; i < tSet.size; i++) {        eventConsumer.consumeElement(protocol, this, tSet.elemType);    }}
7b599b045716c457dacd0d2cd14e6d6f3edc6aa5b6b4d2b05ff9da38ed6d3ddb
readMapContent
public void readMapContent(MapConsumer eventConsumer, TMap tMap) throws TException
{    for (int i = 0; i < tMap.size; i++) {        eventConsumer.consumeEntry(protocol, this, tMap.keyType, tMap.valueType);    }}
f193ab62b9ac0df57562887bf74b84cafde0352cad1487f3f338413b385f0319
readMapEntry
public void readMapEntry(byte keyType, TypedConsumer keyConsumer, byte valueType, TypedConsumer valueConsumer) throws TException
{    keyConsumer.read(protocol, this, keyType);    valueConsumer.read(protocol, this, valueType);}
a7182c5d2fe2ee76b346fb2c0abb1999e803479570a6b58cece18da15457b969
readListContent
public void readListContent(ListConsumer eventConsumer, TList tList) throws TException
{    for (int i = 0; i < tList.size; i++) {        eventConsumer.consumeElement(protocol, this, tList.elemType);    }}
915baf7c883b611c6125c3b2c8bff5367a9418c18f4aff649e11e1664eb44717
read
 final void read(TProtocol protocol, EventBasedThriftReader reader) throws TException
{    this.consume(protocol.readDouble());}
915baf7c883b611c6125c3b2c8bff5367a9418c18f4aff649e11e1664eb44717
read
 final void read(TProtocol protocol, EventBasedThriftReader reader) throws TException
{    this.consume(protocol.readByte());}
915baf7c883b611c6125c3b2c8bff5367a9418c18f4aff649e11e1664eb44717
read
 final void read(TProtocol protocol, EventBasedThriftReader reader) throws TException
{    this.consume(protocol.readBool());}
915baf7c883b611c6125c3b2c8bff5367a9418c18f4aff649e11e1664eb44717
read
 final void read(TProtocol protocol, EventBasedThriftReader reader) throws TException
{    this.consume(protocol.readI32());}
915baf7c883b611c6125c3b2c8bff5367a9418c18f4aff649e11e1664eb44717
read
 final void read(TProtocol protocol, EventBasedThriftReader reader) throws TException
{    this.consume(protocol.readI64());}
915baf7c883b611c6125c3b2c8bff5367a9418c18f4aff649e11e1664eb44717
read
 final void read(TProtocol protocol, EventBasedThriftReader reader) throws TException
{    this.consume(protocol.readI16());}
915baf7c883b611c6125c3b2c8bff5367a9418c18f4aff649e11e1664eb44717
read
 final void read(TProtocol protocol, EventBasedThriftReader reader) throws TException
{    this.consume(protocol.readString());}
915baf7c883b611c6125c3b2c8bff5367a9418c18f4aff649e11e1664eb44717
read
 final void read(TProtocol protocol, EventBasedThriftReader reader) throws TException
{    this.consumeStruct(protocol, reader);}
915baf7c883b611c6125c3b2c8bff5367a9418c18f4aff649e11e1664eb44717
read
 final void read(TProtocol protocol, EventBasedThriftReader reader) throws TException
{    this.consumeList(protocol, reader, protocol.readListBegin());    protocol.readListEnd();}
b08ccb1c9dd00d8283f5f0e788488d61108869cc6228cc8d1a2345673bf165aa
consumeList
public void consumeList(TProtocol protocol, EventBasedThriftReader reader, TList tList) throws TException
{    reader.readListContent(this, tList);}
915baf7c883b611c6125c3b2c8bff5367a9418c18f4aff649e11e1664eb44717
read
 final void read(TProtocol protocol, EventBasedThriftReader reader) throws TException
{    this.consumeSet(protocol, reader, protocol.readSetBegin());    protocol.readSetEnd();}
83bd131fc4b4a78de2a66bcda7c932d23715c69c8f2e37ea9ecb03a05ee580e3
consumeSet
public void consumeSet(TProtocol protocol, EventBasedThriftReader reader, TSet tSet) throws TException
{    reader.readSetContent(this, tSet);}
915baf7c883b611c6125c3b2c8bff5367a9418c18f4aff649e11e1664eb44717
read
 final void read(TProtocol protocol, EventBasedThriftReader reader) throws TException
{    this.consumeMap(protocol, reader, protocol.readMapBegin());    protocol.readMapEnd();}
bfe7b2655de7df22e5b2b70d8a6582ada1f0431f7e9059f1c1a18bd15c5c5438
consumeMap
public void consumeMap(TProtocol protocol, EventBasedThriftReader reader, TMap tMap) throws TException
{    reader.readMapContent(this, tMap);}
c3f13fd23d19b79bbee99e83d9bad4a7d0449d19c009578af3bc6b3a80d37469
read
public final void read(TProtocol protocol, EventBasedThriftReader reader, byte type) throws TException
{    if (this.type != type) {        throw new TException("Incorrect type in stream. " + "Expected " + this.type + " but got " + type);    }    this.read(protocol, reader);}
05b696c09696aa9c7cafcb6383831578f1834bac430a9874af506eb4f4a990b1
getTransport
public TTransport getTransport()
{    return delegate.getTransport();}
6e40e5cf513a809dc50dcdd328059e0c91563b4e305762fe100219b231c6dc54
writeMessageBegin
public void writeMessageBegin(TMessage message) throws TException
{    delegate.writeMessageBegin(message);}
ade94bcb84429ca34b3ac1ffccc0acc87510cd06267edc8ad0ed40cef78b39be
writeMessageEnd
public void writeMessageEnd() throws TException
{    delegate.writeMessageEnd();}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return delegate.hashCode();}
20dc992c59eb5c65b7b90e25660bfc1481e15b20d117fe08ace652816e9c445b
writeStructBegin
public void writeStructBegin(TStruct struct) throws TException
{    delegate.writeStructBegin(struct);}
5010522f36971f2f24e6875669da519eedd379b8640ddb4a0af7cde61d7658f1
writeStructEnd
public void writeStructEnd() throws TException
{    delegate.writeStructEnd();}
64d9ca4acffc3a8699f25fc5f94ade23da81b62bc424b46c1653856d57271ac9
writeFieldBegin
public void writeFieldBegin(TField field) throws TException
{    delegate.writeFieldBegin(field);}
b0a830717a657c899097e3e736493aef0faf6dfb430e313b020bb0bc8b19e69d
writeFieldEnd
public void writeFieldEnd() throws TException
{    delegate.writeFieldEnd();}
63fb9d3a4e5cbe6779cc99e3ffabfbdd3e3e28004f4746a682d3adbc8c35c688
writeFieldStop
public void writeFieldStop() throws TException
{    delegate.writeFieldStop();}
dcde37228f607b0b7e2604909079cdb3ac5768c8a4652c8047c51f97e2b72923
writeMapBegin
public void writeMapBegin(TMap map) throws TException
{    delegate.writeMapBegin(map);}
67f363c30f9232259c0c23dfa790d0a3f2e19a688b3722f5022b7740792babc3
writeMapEnd
public void writeMapEnd() throws TException
{    delegate.writeMapEnd();}
d9a67025b8f7c6c7661007c24445a49d4c582691acc753ead1143988200f3564
writeListBegin
public void writeListBegin(TList list) throws TException
{    delegate.writeListBegin(list);}
da56dbd294fd9e9d40f80049f21ed2188c3c2af2f491f4891f69bcbe9db1a4f5
writeListEnd
public void writeListEnd() throws TException
{    delegate.writeListEnd();}
0e77a5eb1b9addd6787ba2d53261ea79f7759d3e93c3802ae83789d183e0069d
writeSetBegin
public void writeSetBegin(TSet set) throws TException
{    delegate.writeSetBegin(set);}
28c6e88e95a0808e952fbe67452962d4a597da72aa56238d97a567ddd1869239
writeSetEnd
public void writeSetEnd() throws TException
{    delegate.writeSetEnd();}
8d51211e99f12413f17007de4e371cf8d247ef1e73702baa074d51179537a9af
writeBool
public void writeBool(boolean b) throws TException
{    delegate.writeBool(b);}
be49bceacc378be83521557b99caf10bf06185e2eef7a78a1152a3694a4d6b2c
writeByte
public void writeByte(byte b) throws TException
{    delegate.writeByte(b);}
6011ebac32f1841cc3594f03ba466ef0a3224ba6b2dca594fe9e54e69b12dcd1
writeI16
public void writeI16(short i16) throws TException
{    delegate.writeI16(i16);}
09c4dd32fada8b5897257a4f8bc3ac37dddaa946b64adc9e0d81fa15184ecf91
writeI32
public void writeI32(int i32) throws TException
{    delegate.writeI32(i32);}
9debc22382676ead907181f78b9352e9216b0614ca4d72b5651b9c5dace5974c
writeI64
public void writeI64(long i64) throws TException
{    delegate.writeI64(i64);}
625514537dfb535a0c170483331a32cc17a9536725dc2c4a8435b99c8c74e37a
writeDouble
public void writeDouble(double dub) throws TException
{    delegate.writeDouble(dub);}
577a22fa000fa7c1262c7a2e6b6c5d943d78e9c16e7e2f302e1379873c98897c
writeString
public void writeString(String str) throws TException
{    delegate.writeString(str);}
9353686a74c9a338b24da7a843112e9ea342b14072ee2373f57ca35d7a8fb3fb
writeBinary
public void writeBinary(ByteBuffer buf) throws TException
{    delegate.writeBinary(buf);}
c6ab4f5d84fcab78958bee81390e6ada7da59b5847e76b5d129f058f70e05975
readMessageBegin
public TMessage readMessageBegin() throws TException
{    return delegate.readMessageBegin();}
49dda8daa7cd38d4ed0a88e9d4e712e102114876e873a30f58897265526217e0
readMessageEnd
public void readMessageEnd() throws TException
{    delegate.readMessageEnd();}
4581ce92c1c14390774b3334899b0792f18429a4fa86e1eab50f00a0c8e87c3b
readStructBegin
public TStruct readStructBegin() throws TException
{    return delegate.readStructBegin();}
313291383bc799a61a64fd536cdb66162569f48a255366c7cc2e937412433b56
readStructEnd
public void readStructEnd() throws TException
{    delegate.readStructEnd();}
6771498943d82d6987ae6cbbe2274166a2ff9ce14f84ac60f6a13d9df78f9b26
readFieldBegin
public TField readFieldBegin() throws TException
{    return delegate.readFieldBegin();}
0ba8e2da944ada1e2b2f96d56fd37a118dc4e3ae0abe06e5d3269bb901ff0383
readFieldEnd
public void readFieldEnd() throws TException
{    delegate.readFieldEnd();}
ccef29d31156242180b2595fbe4f2e8f11ecb097f7eb5013f5cfbcbadb7d3f2b
readMapBegin
public TMap readMapBegin() throws TException
{    return delegate.readMapBegin();}
2a5867240c482ae3a61d58bbbb1c1b7e42b363a1f64c6cd3524c0470d749c9a0
readMapEnd
public void readMapEnd() throws TException
{    delegate.readMapEnd();}
f11327b40a2aa7489a812533ff4e918785c8373aaf59343add9f4bbcdcfd11f0
readListBegin
public TList readListBegin() throws TException
{    return delegate.readListBegin();}
751f723cedbf7b8de4f12a4df7d3afebe4ff7079c529f2086892ae666fc1bf34
readListEnd
public void readListEnd() throws TException
{    delegate.readListEnd();}
5b0265bf5be1a6ae8196064eb3a9728c746c5a31b8da6f6e24655b5b965b45dc
readSetBegin
public TSet readSetBegin() throws TException
{    return delegate.readSetBegin();}
6d0d71f10658b2a33eefe039338687f1c171606506f807722885f53093eb40ca
readSetEnd
public void readSetEnd() throws TException
{    delegate.readSetEnd();}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    return delegate.equals(obj);}
e3ae4a5d2127da24daf3630c1e497e9da2943770af69da55e3286e71d1fc6e10
readBool
public boolean readBool() throws TException
{    return delegate.readBool();}
d0afc620362c8c05d0f9d6409f34df154f23b95cbd7164d4d31708bf01bfc254
readByte
public byte readByte() throws TException
{    return delegate.readByte();}
ba19a1b6b27a9d1241b1532c49518058e1c6aae1b2fce864cac33b0323b4e9ed
readI16
public short readI16() throws TException
{    return delegate.readI16();}
9cdce61957c527c2da4806031bffb0b62837efdf684b720ac095ddc794ad3be4
readI32
public int readI32() throws TException
{    return delegate.readI32();}
effebad19b862ab3187f7a56079de27779133ee1979be7276c1ea72d6bec8a0b
readI64
public long readI64() throws TException
{    return delegate.readI64();}
13e5eb98c42fdbefd38e11fed60126ad859699a84615bbae60805a0c45f03126
readDouble
public double readDouble() throws TException
{    return delegate.readDouble();}
00b5d4f7589ed91042175c05b813cc60c9649f639b471d6be729691cd5b52bd7
readString
public String readString() throws TException
{        return delegate.readString().intern();}
a4bf98b9a9e380c02f650aea16d41e5140ec75fdfa57c19ba07e0787d5cb43b9
readBinary
public ByteBuffer readBinary() throws TException
{    return delegate.readBinary();}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    delegate.reset();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return delegate.toString();}
a2ac7f6bea276d89c75818648a7375e5a76dff3fdc08a335162819c55b552664
DECIMAL
public static LogicalType DECIMAL(int scale, int precision)
{    return LogicalType.DECIMAL(new DecimalType(scale, precision));}
ab83e851166345415e91137eb1455fee3299d916401d13dccb88a84cad008577
writeColumnIndex
public static void writeColumnIndex(ColumnIndex columnIndex, OutputStream to) throws IOException
{    write(columnIndex, to);}
c1dc44fe7ff0d74a43e481a2c28ed9960ad7f5e45a66a5f39e0aad25cac07e50
readColumnIndex
public static ColumnIndex readColumnIndex(InputStream from) throws IOException
{    return read(from, new ColumnIndex());}
01f7d3b6e1aaa91bf74ec4b449d37de0898eb948ecf06250e4e283393318941b
writeOffsetIndex
public static void writeOffsetIndex(OffsetIndex offsetIndex, OutputStream to) throws IOException
{    write(offsetIndex, to);}
fe69355702eba405d89a18ff4241042c7411277303ceda9f36cd12515022f956
readOffsetIndex
public static OffsetIndex readOffsetIndex(InputStream from) throws IOException
{    return read(from, new OffsetIndex());}
c20f9e322b86166e41d472291013f786290b0d4e2eb02238f0c0fdaad7749e0a
writePageHeader
public static void writePageHeader(PageHeader pageHeader, OutputStream to) throws IOException
{    write(pageHeader, to);}
dc8b3df5d412f39b104cff13a6e43df30506f254f6e92dceabd39312a8a5fec4
readPageHeader
public static PageHeader readPageHeader(InputStream from) throws IOException
{    return read(from, new PageHeader());}
656454db3f62833da4897d036d1eaf671318d0d9d0ba36a99104ce697d35d1b9
writeFileMetaData
public static void writeFileMetaData(org.apache.parquet.format.FileMetaData fileMetadata, OutputStream to) throws IOException
{    write(fileMetadata, to);}
0e626fb388d0fe320738c63fd479292f628a46c051e8040cb502b22313e8dbab
readFileMetaData
public static FileMetaData readFileMetaData(InputStream from) throws IOException
{    return read(from, new FileMetaData());}
a2ded95569c8b08d681a8a18d1ab9912a7c4ea652bb018b6060856c50b5c0d65
readFileMetaData
public static FileMetaData readFileMetaData(InputStream from, boolean skipRowGroups) throws IOException
{    FileMetaData md = new FileMetaData();    if (skipRowGroups) {        readFileMetaData(from, new DefaultFileMetaDataConsumer(md), skipRowGroups);    } else {        read(from, md);    }    return md;}
24c1e0bb2fb8e08d8dbd6c1e1cc4e481fdcd5538e19be533ec851e4aedbf0628
setVersion
public void setVersion(int version)
{    md.setVersion(version);}
eb17c1bfb5092586ba240bdd919afeefeb636ff536199f8aa8c944a02e82618f
setSchema
public void setSchema(List<SchemaElement> schema)
{    md.setSchema(schema);}
ccd65ffc0f3508a642e8c4c6f96e97a34090b04d790e233b0dfabd87d2cc3449
setNumRows
public void setNumRows(long numRows)
{    md.setNum_rows(numRows);}
c2baae578584ee533cd2a36b349830922b6ac97c38f18501e2acee30ec1d462f
setCreatedBy
public void setCreatedBy(String createdBy)
{    md.setCreated_by(createdBy);}
f9d1127e9a57f83416678be352f97c30a340d068649e799d4cb01fde4dde8fd0
addRowGroup
public void addRowGroup(RowGroup rowGroup)
{    md.addToRow_groups(rowGroup);}
3187fe397d2db7359a3aeb96b55710ef6e95cc39b5e6bbc93a70cd475be77406
addKeyValueMetaData
public void addKeyValueMetaData(KeyValue kv)
{    md.addToKey_value_metadata(kv);}
db972367b12e1419d812c86f12534eeb0474a87ff1aeaecf73764331fc4a2cdf
readFileMetaData
public static void readFileMetaData(InputStream from, FileMetaDataConsumer consumer) throws IOException
{    readFileMetaData(from, consumer, false);}
9c13c8e6e3fdb7c5ec5bc66a937b60923c5b94421010e1f3570068ee2cf68c96
readFileMetaData
public static void readFileMetaData(InputStream from, final FileMetaDataConsumer consumer, boolean skipRowGroups) throws IOException
{    try {        DelegatingFieldConsumer eventConsumer = fieldConsumer().onField(VERSION, new I32Consumer() {            @Override            public void consume(int value) {                consumer.setVersion(value);            }        }).onField(SCHEMA, listOf(SchemaElement.class, new Consumer<List<SchemaElement>>() {            @Override            public void consume(List<SchemaElement> schema) {                consumer.setSchema(schema);            }        })).onField(NUM_ROWS, new I64Consumer() {            @Override            public void consume(long value) {                consumer.setNumRows(value);            }        }).onField(KEY_VALUE_METADATA, listElementsOf(struct(KeyValue.class, new Consumer<KeyValue>() {            @Override            public void consume(KeyValue kv) {                consumer.addKeyValueMetaData(kv);            }        }))).onField(CREATED_BY, new StringConsumer() {            @Override            public void consume(String value) {                consumer.setCreatedBy(value);            }        });        if (!skipRowGroups) {            eventConsumer = eventConsumer.onField(ROW_GROUPS, listElementsOf(struct(RowGroup.class, new Consumer<RowGroup>() {                @Override                public void consume(RowGroup rowGroup) {                    consumer.addRowGroup(rowGroup);                }            })));        }        new EventBasedThriftReader(protocol(from)).readStruct(eventConsumer);    } catch (TException e) {        throw new IOException("can not read FileMetaData: " + e.getMessage(), e);    }}
1161daec69cfc596dca0fd3979c80217a4bde97513f9f8a208a9c1fdfcd0afbf
consume
public void consume(int value)
{    consumer.setVersion(value);}
d1b8cbbd79d275b37490f92a55a9098eaf03e2d2ea48bbbd6cc697a32f47d9f3
consume
public void consume(List<SchemaElement> schema)
{    consumer.setSchema(schema);}
485f15672b869758acd52148d113e6d0205c8b9ae46e28b58aefdc88c7c184f5
consume
public void consume(long value)
{    consumer.setNumRows(value);}
ae12e379afacc7adc0b8652ab680655cc0f3719324cf2bb6276f03aa868d0bb5
consume
public void consume(KeyValue kv)
{    consumer.addKeyValueMetaData(kv);}
b118a13f26af3c25915fc19003391d6555d04d4ebfae501e9d47ae4154bc6d2c
consume
public void consume(String value)
{    consumer.setCreatedBy(value);}
8ff0c6474bf9b771859d07adf22e067e3e96ce747d0df0d424d5748eacd91918
consume
public void consume(RowGroup rowGroup)
{    consumer.addRowGroup(rowGroup);}
71347657e970e75407b13271cb278feb7ba712c2f2dc55e958b667ad4e805647
protocol
private static TProtocol protocol(OutputStream to)
{    return protocol(new TIOStreamTransport(to));}
2fda4e9e984f34cd37d3d845b50c500d515c0c6f647a40c8d896bb4aad4b242a
protocol
private static TProtocol protocol(InputStream from)
{    return protocol(new TIOStreamTransport(from));}
6f89ad326557298bcef2e8e58c04ede6daa47ef61ac6f7e10eaeea7971712a52
protocol
private static InterningProtocol protocol(TIOStreamTransport t)
{    return new InterningProtocol(new TCompactProtocol(t));}
17802fbc074e6050506a73e3e26243b3fc1a4a4188b9419816cc570bf93179b3
read
private static T read(InputStream from, T tbase) throws IOException
{    try {        tbase.read(protocol(from));        return tbase;    } catch (TException e) {        throw new IOException("can not read " + tbase.getClass() + ": " + e.getMessage(), e);    }}
d90d8d3c265af920c5228bcdbf0c7580839ee37da3b3ca9339e5b6a2ba6f5e79
write
private static void write(TBase<?, ?> tbase, OutputStream to) throws IOException
{    try {        tbase.write(protocol(to));    } catch (TException e) {        throw new IOException("can not write " + tbase, e);    }}
bceec69b9f12b670eb341c03e9ca6f96ab175f2031db36689f00a0f8226f94b3
testReadFileMetadata
public void testReadFileMetadata() throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    FileMetaData md = new FileMetaData(1, asList(new SchemaElement("foo")), 10, asList(new RowGroup(asList(new ColumnChunk(0), new ColumnChunk(1)), 10, 5), new RowGroup(asList(new ColumnChunk(2), new ColumnChunk(3)), 11, 5)));    writeFileMetaData(md, baos);    FileMetaData md2 = readFileMetaData(in(baos));    FileMetaData md3 = new FileMetaData();    readFileMetaData(in(baos), new DefaultFileMetaDataConsumer(md3));    FileMetaData md4 = new FileMetaData();    readFileMetaData(in(baos), new DefaultFileMetaDataConsumer(md4), true);    FileMetaData md5 = readFileMetaData(in(baos), true);    FileMetaData md6 = readFileMetaData(in(baos), false);    assertEquals(md, md2);    assertEquals(md, md3);    assertNull(md4.getRow_groups());    assertNull(md5.getRow_groups());    assertEquals(md4, md5);    md4.setRow_groups(md.getRow_groups());    md5.setRow_groups(md.getRow_groups());    assertEquals(md, md4);    assertEquals(md, md5);    assertEquals(md4, md5);    assertEquals(md, md6);}
753508f8c987323f6ac5f7af33b322440fe7f2205775a951a861fa13a51650ab
in
private ByteArrayInputStream in(ByteArrayOutputStream baos)
{    return new ByteArrayInputStream(baos.toByteArray());}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    String basePath = args[0];        generateScheme(false, true, basePath);        generateScheme(false, false, basePath);        generateScheme(true, true, basePath);        generateScheme(true, false, basePath);}
db9a844eee642bb395f87e14e8fd353bb18731cdd6342975b0101455f5f395a1
generateScheme
private static void generateScheme(boolean isLong, boolean msbFirst, String basePath) throws IOException
{    String baseClassName = isLong ? CLASS_NAME_PREFIX_FOR_LONG : CLASS_NAME_PREFIX_FOR_INT;    String className = msbFirst ? (baseClassName + "BE") : (baseClassName + "LE");    int maxBits = isLong ? MAX_BITS_FOR_LONG : MAX_BITS_FOR_INT;    String nameSuffix = isLong ? "ForLong" : "";    final File file = new File(basePath + "/org/apache/parquet/column/values/bitpacking/" + className + ".java").getAbsoluteFile();    if (!file.getParentFile().exists()) {        file.getParentFile().mkdirs();    }    try (FileWriter fw = new FileWriter(file)) {        fw.append("package org.apache.parquet.column.values.bitpacking;\n");        fw.append("import java.nio.ByteBuffer;\n");        fw.append("\n");        fw.append("/**\n");        if (msbFirst) {            fw.append(" * Packs from the Most Significant Bit first\n");        } else {            fw.append(" * Packs from the Least Significant Bit first\n");        }        fw.append(" * \n");        fw.append(" * See ByteBasedBitPackingGenerator to make changes to this file\n");        fw.append(" * Automatically generated\n");        fw.append(" *\n");        fw.append(" */\n");        fw.append("public abstract class " + className + " {\n");        fw.append("\n");        fw.append("  private static final BytePacker" + nameSuffix + "[] packers = new BytePacker" + nameSuffix + "[" + (maxBits + 1) + "];\n");        fw.append("  static {\n");        for (int i = 0; i <= maxBits; i++) {            fw.append("    packers[" + i + "] = new Packer" + i + "();\n");        }        fw.append("  }\n");        fw.append("\n");        fw.append("  public static final BytePacker" + nameSuffix + "Factory factory = new BytePacker" + nameSuffix + "Factory() {\n");        fw.append("    public BytePacker" + nameSuffix + " newBytePacker" + nameSuffix + "(int bitWidth) {\n");        fw.append("      return packers[bitWidth];\n");        fw.append("    }\n");        fw.append("  };\n");        fw.append("\n");        for (int i = 0; i <= maxBits; i++) {            generateClass(fw, i, isLong, msbFirst);            fw.append("\n");        }        fw.append("}\n");    }}
40a9aab6e6d5b00264a6fb2deef3e2d77233720585992022c7e75730dce1feb0
generateClass
private static void generateClass(FileWriter fw, int bitWidth, boolean isLong, boolean msbFirst) throws IOException
{    String nameSuffix = isLong ? "ForLong" : "";    fw.append("  private static final class Packer" + bitWidth + " extends BytePacker" + nameSuffix + " {\n");    fw.append("\n");    fw.append("    private Packer" + bitWidth + "() {\n");    fw.append("      super(" + bitWidth + ");\n");    fw.append("    }\n");    fw.append("\n");        generatePack(fw, bitWidth, 1, isLong, msbFirst);    generatePack(fw, bitWidth, 4, isLong, msbFirst);        generateUnpack(fw, bitWidth, 1, isLong, msbFirst, true);    generateUnpack(fw, bitWidth, 1, isLong, msbFirst, false);    generateUnpack(fw, bitWidth, 4, isLong, msbFirst, true);    generateUnpack(fw, bitWidth, 4, isLong, msbFirst, false);    fw.append("  }\n");}
a3605563d870ec1bc786ce5666a80ee5eb63366971fa8ecbcc6c0ffc02f34e54
getShift
private static ShiftMask getShift(FileWriter fw, int bitWidth, boolean isLong, boolean msbFirst, int byteIndex, int valueIndex) throws IOException
{        int valueStartBitIndex = (valueIndex * bitWidth) - (8 * (byteIndex));    int valueEndBitIndex = ((valueIndex + 1) * bitWidth) - (8 * (byteIndex + 1));        int valueStartBitWanted;    int valueEndBitWanted;        int byteStartBitWanted;    int byteEndBitWanted;    int shift;    int widthWanted;    if (msbFirst) {        valueStartBitWanted = valueStartBitIndex < 0 ? bitWidth - 1 + valueStartBitIndex : bitWidth - 1;        valueEndBitWanted = valueEndBitIndex > 0 ? valueEndBitIndex : 0;        byteStartBitWanted = valueStartBitIndex < 0 ? 8 : 7 - valueStartBitIndex;        byteEndBitWanted = valueEndBitIndex > 0 ? 0 : -valueEndBitIndex;        shift = valueEndBitWanted - byteEndBitWanted;        widthWanted = Math.min(7, byteStartBitWanted) - Math.min(7, byteEndBitWanted) + 1;    } else {        valueStartBitWanted = bitWidth - 1 - (valueEndBitIndex > 0 ? valueEndBitIndex : 0);        valueEndBitWanted = bitWidth - 1 - (valueStartBitIndex < 0 ? bitWidth - 1 + valueStartBitIndex : bitWidth - 1);        byteStartBitWanted = 7 - (valueEndBitIndex > 0 ? 0 : -valueEndBitIndex);        byteEndBitWanted = 7 - (valueStartBitIndex < 0 ? 8 : 7 - valueStartBitIndex);        shift = valueStartBitWanted - byteStartBitWanted;        widthWanted = Math.max(0, byteStartBitWanted) - Math.max(0, byteEndBitWanted) + 1;    }    int maskWidth = widthWanted + Math.max(0, shift);    visualizeAlignment(fw, bitWidth, valueEndBitIndex, valueStartBitWanted, valueEndBitWanted, byteStartBitWanted, byteEndBitWanted, shift);    return new ShiftMask(shift, genMask(maskWidth, isLong));}
a8a3c3e54c5a7ec033a334ce7b4ff547c22722fd80868a81857b366e8d0a6007
visualizeAlignment
private static void visualizeAlignment(FileWriter fw, int bitWidth, int valueEndBitIndex, int valueStartBitWanted, int valueEndBitWanted, int byteStartBitWanted, int byteEndBitWanted, int shift) throws IOException
{        fw.append("//");    int buf = 2 + Math.max(0, bitWidth + 8);    for (int i = 0; i < buf; i++) {        fw.append(" ");    }    fw.append("[");    for (int i = 7; i >= 0; i--) {        if (i <= byteStartBitWanted && i >= byteEndBitWanted) {            fw.append(String.valueOf(i));        } else {            fw.append("_");        }    }    fw.append("]\n          //");    for (int i = 0; i < buf + (8 - bitWidth + shift); i++) {        fw.append(" ");    }    fw.append("[");    for (int i = bitWidth - 1; i >= 0; i--) {        if (i <= valueStartBitWanted && i >= valueEndBitWanted) {            fw.append(String.valueOf(i % 10));        } else {            fw.append("_");        }    }    fw.append("]\n");    fw.append("           ");}
b769d4cdcfd1feed0f3147557559bd7e3d19a87c5768464a2a976299255a661f
generatePack
private static void generatePack(FileWriter fw, int bitWidth, int batch, boolean isLong, boolean msbFirst) throws IOException
{    long mask = genMask(bitWidth, isLong);    String maskSuffix = isLong ? "L" : "";    String variableType = isLong ? VARIABLE_TYPE_FOR_LONG : VARIABLE_TYPE_FOR_INT;    fw.append("    public final void pack" + (batch * 8) + "Values(final " + variableType + "[] in, final int inPos, final byte[] out, final int outPos) {\n");    for (int byteIndex = 0; byteIndex < bitWidth * batch; ++byteIndex) {        fw.append("      out[" + align(byteIndex, 2) + " + outPos] = (byte)((\n");        int startIndex = (byteIndex * 8) / bitWidth;        int endIndex = ((byteIndex + 1) * 8 + bitWidth - 1) / bitWidth;        for (int valueIndex = startIndex; valueIndex < endIndex; valueIndex++) {            if (valueIndex == startIndex) {                fw.append("          ");            } else {                fw.append("\n        | ");            }            ShiftMask shiftMask = getShift(fw, bitWidth, isLong, msbFirst, byteIndex, valueIndex);                        String shiftString = "";            if (shiftMask.shift > 0) {                shiftString = " >>> " + shiftMask.shift;            } else if (shiftMask.shift < 0) {                shiftString = " <<  " + (-shiftMask.shift);            }            fw.append("((in[" + align(valueIndex, 2) + " + inPos] & " + mask + maskSuffix + ")" + shiftString + ")");        }        fw.append(") & 255);\n");    }    fw.append("    }\n");}
e04ebb6e609512710302f15d1a84b9f29050667068a2f03bff96c138dcd664c3
generateUnpack
private static void generateUnpack(FileWriter fw, int bitWidth, int batch, boolean isLong, boolean msbFirst, boolean useByteArray) throws IOException
{    final String variableType = isLong ? VARIABLE_TYPE_FOR_LONG : VARIABLE_TYPE_FOR_INT;    final String bufferDataType = useByteArray ? "byte[]" : "ByteBuffer";    fw.append("    public final void unpack" + (batch * 8) + "Values(final " + bufferDataType + " in, " + "final int inPos, final " + variableType + "[] out, final int outPos) {\n");    if (bitWidth > 0) {        String maskSuffix = isLong ? "L" : "";        for (int valueIndex = 0; valueIndex < (batch * 8); ++valueIndex) {            fw.append("      out[" + align(valueIndex, 2) + " + outPos] =\n");            int startIndex = valueIndex * bitWidth / 8;            int endIndex = paddedByteCountFromBits((valueIndex + 1) * bitWidth);            for (int byteIndex = startIndex; byteIndex < endIndex; byteIndex++) {                if (byteIndex == startIndex) {                    fw.append("          ");                } else {                    fw.append("\n        | ");                }                ShiftMask shiftMask = getShift(fw, bitWidth, isLong, msbFirst, byteIndex, valueIndex);                                String shiftString = "";                if (shiftMask.shift < 0) {                    shiftString = ">>  " + (-shiftMask.shift);                } else if (shiftMask.shift > 0) {                    shiftString = "<<  " + shiftMask.shift;                }                final String byteAccess;                if (useByteArray) {                    byteAccess = "in[" + align(byteIndex, 2) + " + inPos]";                } else {                                        byteAccess = "in.get(" + align(byteIndex, 2) + " + inPos)";                }                                fw.append(" ((((" + variableType + ")" + byteAccess + ") " + shiftString + ") & " + shiftMask.mask + maskSuffix + ")");            }            fw.append(";\n");        }    }    fw.append("    }\n");}
1f3e4e79092f7b2c532a18c63d11375eb8fb274605aa544752eccf0015744e6d
genMask
private static long genMask(int bitWidth, boolean isLong)
{    int maxBitWidth = isLong ? MAX_BITS_FOR_LONG : MAX_BITS_FOR_INT;    if (bitWidth >= maxBitWidth) {                return -1;    }    long mask = 0;    for (int i = 0; i < bitWidth; i++) {        mask <<= 1;        mask |= 1;    }    return mask;}
d2a6bc2a1e930590947920fde61ea20e148b1ccfd016985109e7b0bdcac8d962
align
private static String align(int value, int digits)
{    final String valueString = String.valueOf(value);    StringBuilder result = new StringBuilder();    for (int i = valueString.length(); i < digits; i++) {        result.append(" ");    }    result.append(valueString);    return result.toString();}
cb70bc5e38a25f5a235252de102f0e406131794a117147f68bdc9b371ce115d3
paddedByteCountFromBits
private static int paddedByteCountFromBits(int bitLength)
{    return (bitLength + 7) / 8;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    String basePath = args[0];    generateScheme(CLASS_NAME_PREFIX + "BE", true, basePath);    generateScheme(CLASS_NAME_PREFIX + "LE", false, basePath);}
2a36f479d1703ad6f7a15b62f91209899f6817edbf2236f7b3895d76dd001b0b
generateScheme
private static void generateScheme(String className, boolean msbFirst, String basePath) throws IOException
{    final File file = new File(basePath + "/org/apache/parquet/column/values/bitpacking/" + className + ".java").getAbsoluteFile();    if (!file.getParentFile().exists()) {        file.getParentFile().mkdirs();    }    try (FileWriter fw = new FileWriter(file)) {        fw.append("package org.apache.parquet.column.values.bitpacking;\n");        fw.append("\n");        fw.append("/**\n");        fw.append(" * Based on the original implementation at at https://github.com/lemire/JavaFastPFOR/blob/master/src/integercompression/BitPacking.java\n");        fw.append(" * Which is released under the\n");        fw.append(" * Apache License Version 2.0 http://www.apache.org/licenses/.\n");        fw.append(" * By Daniel Lemire, http://lemire.me/en/\n");        fw.append(" * \n");        fw.append(" * Scheme designed by D. Lemire\n");        if (msbFirst) {            fw.append(" * Adapted to pack from the Most Significant Bit first\n");        }        fw.append(" * \n");        fw.append(" * Automatically generated\n");        fw.append(" * @see IntBasedBitPackingGenerator\n");        fw.append(" *\n");        fw.append(" */\n");        fw.append("abstract class " + className + " {\n");        fw.append("\n");        fw.append("  private static final IntPacker[] packers = new IntPacker[32];\n");        fw.append("  static {\n");        for (int i = 0; i < 32; i++) {            fw.append("    packers[" + i + "] = new Packer" + i + "();\n");        }        fw.append("  }\n");        fw.append("\n");        fw.append("  public static final IntPackerFactory factory = new IntPackerFactory() {\n");        fw.append("    public IntPacker newIntPacker(int bitWidth) {\n");        fw.append("      return packers[bitWidth];\n");        fw.append("    }\n");        fw.append("  };\n");        fw.append("\n");        for (int i = 0; i < 32; i++) {            generateClass(fw, i, msbFirst);            fw.append("\n");        }        fw.append("}\n");    }}
da63dde1de2a65ffd389c478a5d61a23c321e6083d384cb3574912760f84f5c7
generateClass
private static void generateClass(FileWriter fw, int bitWidth, boolean msbFirst) throws IOException
{    int mask = 0;    for (int i = 0; i < bitWidth; i++) {        mask <<= 1;        mask |= 1;    }    fw.append("  private static final class Packer" + bitWidth + " extends IntPacker {\n");    fw.append("\n");    fw.append("    private Packer" + bitWidth + "() {\n");    fw.append("      super(" + bitWidth + ");\n");    fw.append("    }\n");    fw.append("\n");        fw.append("    public final void pack32Values(final int[] in, final int inPos, final int[] out, final int outPos) {\n");    for (int i = 0; i < bitWidth; ++i) {        fw.append("      out[" + align(i, 2) + " + outPos] =\n");        int startIndex = (i * 32) / bitWidth;        int endIndex = ((i + 1) * 32 + bitWidth - 1) / bitWidth;        for (int j = startIndex; j < endIndex; j++) {            if (j == startIndex) {                fw.append("          ");            } else {                fw.append("\n        | ");            }            String shiftString = getPackShiftString(bitWidth, i, startIndex, j, msbFirst);            fw.append("((in[" + align(j, 2) + " + inPos] & " + mask + ")" + shiftString + ")");        }        fw.append(";\n");    }    fw.append("    }\n");        fw.append("    public final void unpack32Values(final int[] in, final int inPos, final int[] out, final int outPos) {\n");    if (bitWidth > 0) {        for (int i = 0; i < 32; ++i) {            fw.append("      out[" + align(i, 2) + " + outPos] =");            int byteIndex = i * bitWidth / 32;            String shiftString = getUnpackShiftString(bitWidth, i, msbFirst);            fw.append(" ((in[" + align(byteIndex, 2) + " + inPos] " + shiftString + ") & " + mask + ")");            if (((i + 1) * bitWidth - 1) / 32 != byteIndex) {                                int bitsRead = ((i + 1) * bitWidth - 1) % 32 + 1;                fw.append(" | ((in[" + align(byteIndex + 1, 2) + " + inPos]");                if (msbFirst) {                    fw.append(") >>> " + align(32 - bitsRead, 2) + ")");                } else {                    int lowerMask = 0;                    for (int j = 0; j < bitsRead; j++) {                        lowerMask <<= 1;                        lowerMask |= 1;                    }                    fw.append(" & " + lowerMask + ") << " + align(bitWidth - bitsRead, 2) + ")");                }            }            fw.append(";\n");        }    }    fw.append("    }\n");    fw.append("  }\n");}
04184dbad0fb75d94651c067ca9585f209f4dddfaaa066d824052e03c1833b70
getUnpackShiftString
private static String getUnpackShiftString(int bitWidth, int i, boolean msbFirst)
{    final int regularShift = i * bitWidth % 32;    String shiftString;    if (msbFirst) {        int shift = 32 - (regularShift + bitWidth);        if (shift < 0) {            shiftString = "<<  " + align(-shift, 2);        } else {            shiftString = ">>> " + align(shift, 2);        }    } else {        shiftString = ">>> " + align(regularShift, 2);    }    return shiftString;}
b39485d24cab2bd9084e3311899619efe3fc5d9b4a3df4a83927c075ef74acf2
getPackShiftString
private static String getPackShiftString(int bitWidth, int integerIndex, int startIndex, int valueIndex, boolean msbFirst)
{    String shiftString;    int regularShift = (valueIndex * bitWidth) % 32;    if (msbFirst) {                int shift = 32 - (regularShift + bitWidth);        if (valueIndex == startIndex && (integerIndex * 32) % bitWidth != 0) {                        shiftString = " <<  " + align(32 - (((valueIndex + 1) * bitWidth) % 32), 2);        } else if (shift < 0) {                        shiftString = " >>> " + align(-shift, 2);        } else {            shiftString = " <<  " + align(shift, 2);        }    } else {                if (valueIndex == startIndex && (integerIndex * 32) % bitWidth != 0) {                        shiftString = " >>> " + align(32 - regularShift, 2);        } else {            shiftString = " <<  " + align(regularShift, 2);        }    }    return shiftString;}
d2a6bc2a1e930590947920fde61ea20e148b1ccfd016985109e7b0bdcac8d962
align
private static String align(int value, int digits)
{    final String valueString = String.valueOf(value);    StringBuilder result = new StringBuilder();    for (int i = valueString.length(); i < digits; i++) {        result.append(" ");    }    result.append(valueString);    return result.toString();}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    IntBasedBitPackingGenerator.main(args);    ByteBasedBitPackingGenerator.main(args);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    IncrementallyUpdatedFilterPredicateGenerator.main(args);}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    File srcFile = new File(args[0] + "/org/apache/parquet/filter2/recordlevel/IncrementallyUpdatedFilterPredicateBuilder.java");    srcFile = srcFile.getAbsoluteFile();    File parent = srcFile.getParentFile();    if (!parent.exists()) {        if (!parent.mkdirs()) {            throw new IOException("Couldn't mkdirs for " + parent);        }    }    new IncrementallyUpdatedFilterPredicateGenerator(srcFile).run();}
b5070baa161b082d18a140d391b48c0200529b621d1cbd19db35eebf7725cc85
run
public void run() throws IOException
{    add("package org.apache.parquet.filter2.recordlevel;\n" + "\n" + "import java.util.List;\n" + "\n" + "import org.apache.parquet.hadoop.metadata.ColumnPath;\n" + "import org.apache.parquet.filter2.predicate.Operators.Eq;\n" + "import org.apache.parquet.filter2.predicate.Operators.Gt;\n" + "import org.apache.parquet.filter2.predicate.Operators.GtEq;\n" + "import org.apache.parquet.filter2.predicate.Operators.LogicalNotUserDefined;\n" + "import org.apache.parquet.filter2.predicate.Operators.Lt;\n" + "import org.apache.parquet.filter2.predicate.Operators.LtEq;\n" + "import org.apache.parquet.filter2.predicate.Operators.NotEq;\n" + "import org.apache.parquet.filter2.predicate.Operators.UserDefined;\n" + "import org.apache.parquet.filter2.predicate.UserDefinedPredicate;\n" + "import org.apache.parquet.filter2.recordlevel.IncrementallyUpdatedFilterPredicate.ValueInspector;\n" + "import org.apache.parquet.io.api.Binary;\n" + "import org.apache.parquet.io.PrimitiveColumnIO;\n" + "import org.apache.parquet.schema.PrimitiveComparator;\n\n" + "/**\n" + " * This class is auto-generated by org.apache.parquet.filter2.IncrementallyUpdatedFilterPredicateGenerator\n" + " * Do not manually edit!\n" + " * See {@link IncrementallyUpdatedFilterPredicateBuilderBase}\n" + " */\n");    add("public class IncrementallyUpdatedFilterPredicateBuilder extends IncrementallyUpdatedFilterPredicateBuilderBase {\n\n");    add("  public IncrementallyUpdatedFilterPredicateBuilder(List<PrimitiveColumnIO> leaves) {\n" + "    super(leaves);\n" + "  }\n\n");    addVisitBegin("Eq");    for (TypeInfo info : TYPES) {        addEqNotEqCase(info, true);    }    addVisitEnd();    addVisitBegin("NotEq");    for (TypeInfo info : TYPES) {        addEqNotEqCase(info, false);    }    addVisitEnd();    addVisitBegin("Lt");    for (TypeInfo info : TYPES) {        addInequalityCase(info, "<");    }    addVisitEnd();    addVisitBegin("LtEq");    for (TypeInfo info : TYPES) {        addInequalityCase(info, "<=");    }    addVisitEnd();    addVisitBegin("Gt");    for (TypeInfo info : TYPES) {        addInequalityCase(info, ">");    }    addVisitEnd();    addVisitBegin("GtEq");    for (TypeInfo info : TYPES) {        addInequalityCase(info, ">=");    }    addVisitEnd();    add("  @Override\n" + "  public <T extends Comparable<T>, U extends UserDefinedPredicate<T>> IncrementallyUpdatedFilterPredicate visit(UserDefined<T, U> pred) {\n");    addUdpBegin();    for (TypeInfo info : TYPES) {        addUdpCase(info, false);    }    addVisitEnd();    add("  @Override\n" + "  public <T extends Comparable<T>, U extends UserDefinedPredicate<T>> IncrementallyUpdatedFilterPredicate visit(LogicalNotUserDefined<T, U> notPred) {\n" + "    UserDefined<T, U> pred = notPred.getUserDefined();\n");    addUdpBegin();    for (TypeInfo info : TYPES) {        addUdpCase(info, true);    }    addVisitEnd();    add("}\n");    writer.close();}
bbe3841710df428ab1746ff56dc01338c28b67cee33b01de6d657cf884911108
addVisitBegin
private void addVisitBegin(String inVar) throws IOException
{    add("  @Override\n" + "  public <T extends Comparable<T>> IncrementallyUpdatedFilterPredicate visit(" + inVar + "<T> pred) {\n" + "    ColumnPath columnPath = pred.getColumn().getColumnPath();\n" + "    Class<T> clazz = pred.getColumn().getColumnType();\n" + "\n" + "    ValueInspector valueInspector = null;\n\n");}
aa9f009c3a03fae2a389b50631e7b333618837ffd410a773006908821ac43052
addVisitEnd
private void addVisitEnd() throws IOException
{    add("    if (valueInspector == null) {\n" + "      throw new IllegalArgumentException(\"Encountered unknown type \" + clazz);\n" + "    }\n" + "\n" + "    addValueInspector(columnPath, valueInspector);\n" + "    return valueInspector;\n" + "  }\n\n");}
54f48e58e09b1fc38577971926e46106ccbd4f231de98a2f965916e292d6d5fe
addEqNotEqCase
private void addEqNotEqCase(TypeInfo info, boolean isEq) throws IOException
{    add("    if (clazz.equals(" + info.className + ".class)) {\n" + "      if (pred.getValue() == null) {\n" + "        valueInspector = new ValueInspector() {\n" + "          @Override\n" + "          public void updateNull() {\n" + "            setResult(" + isEq + ");\n" + "          }\n" + "\n" + "          @Override\n" + "          public void update(" + info.primitiveName + " value) {\n" + "            setResult(" + !isEq + ");\n" + "          }\n" + "        };\n" + "      } else {\n" + "        final " + info.primitiveName + " target = (" + info.className + ") (Object) pred.getValue();\n" + "        final PrimitiveComparator<" + info.className + "> comparator = getComparator(columnPath);\n" + "\n" + "        valueInspector = new ValueInspector() {\n" + "          @Override\n" + "          public void updateNull() {\n" + "            setResult(" + !isEq + ");\n" + "          }\n" + "\n" + "          @Override\n" + "          public void update(" + info.primitiveName + " value) {\n");    add("            setResult(" + compareEquality("value", "target", isEq) + ");\n");    add("          }\n" + "        };\n" + "      }\n" + "    }\n\n");}
d38a0de29a889ea63c0688b5339e5ccb98b429c01ee22fae64f1b1ef05819f08
addInequalityCase
private void addInequalityCase(TypeInfo info, String op) throws IOException
{    if (!info.supportsInequality) {        add("    if (clazz.equals(" + info.className + ".class)) {\n");        add("      throw new IllegalArgumentException(\"Operator " + op + " not supported for " + info.className + "\");\n");        add("    }\n\n");        return;    }    add("    if (clazz.equals(" + info.className + ".class)) {\n" + "      final " + info.primitiveName + " target = (" + info.className + ") (Object) pred.getValue();\n" + "      final PrimitiveComparator<" + info.className + "> comparator = getComparator(columnPath);\n" + "\n" + "      valueInspector = new ValueInspector() {\n" + "        @Override\n" + "        public void updateNull() {\n" + "          setResult(false);\n" + "        }\n" + "\n" + "        @Override\n" + "        public void update(" + info.primitiveName + " value) {\n");    add("          setResult(comparator.compare(value, target) " + op + " 0);\n");    add("        }\n" + "      };\n" + "    }\n\n");}
abc90c220a76bb1fbc2c4d3b038732afe0b97d53de64eb832e9595f4b4238322
addUdpBegin
private void addUdpBegin() throws IOException
{    add("    ColumnPath columnPath = pred.getColumn().getColumnPath();\n" + "    Class<T> clazz = pred.getColumn().getColumnType();\n" + "\n" + "    ValueInspector valueInspector = null;\n" + "\n" + "    final U udp = pred.getUserDefinedPredicate();\n" + "\n");}
af88e45450a1a50efb71cef3cef5fa2c5e5301668af852c1c746cc1c0625e748
addUdpCase
private void addUdpCase(TypeInfo info, boolean invert) throws IOException
{    add("    if (clazz.equals(" + info.className + ".class)) {\n" + "      valueInspector = new ValueInspector() {\n" + "        @Override\n" + "        public void updateNull() {\n" + "          setResult(" + (invert ? "!" : "") + "udp.acceptsNullValue());\n" + "        }\n" + "\n" + "        @SuppressWarnings(\"unchecked\")\n" + "        @Override\n" + "        public void update(" + info.primitiveName + " value) {\n" + "          setResult(" + (invert ? "!" : "") + "udp.keep((T) (Object) value));\n" + "        }\n" + "      };\n" + "    }\n\n");}
7c637a920850df71e62d585149017a813b139972726e13cf61ef392b6bdd371d
compareEquality
private String compareEquality(String var, String target, boolean eq)
{    return "comparator.compare(" + var + ", " + target + ")" + (eq ? " == 0 " : " != 0");}
49184fb2072f8e45b9504158141fc639663454d7f211a93d59dc91b42452e1f5
add
private void add(String s) throws IOException
{    writer.write(s);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    VersionGenerator.main(args);}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    File srcFile = new File(args[0] + "/org/apache/parquet/Version.java");    srcFile = srcFile.getAbsoluteFile();    File parent = srcFile.getParentFile();    if (!parent.exists()) {        if (!parent.mkdirs()) {            throw new IOException("Couldn't mkdirs for " + parent);        }    }    new VersionGenerator(srcFile).run();}
b5070baa161b082d18a140d391b48c0200529b621d1cbd19db35eebf7725cc85
run
public void run() throws IOException
{    InputStream in = VersionGenerator.class.getResourceAsStream("/parquet-version.properties");    if (in == null) {        throw new IOException("/parquet-version.properties not found");    }    Properties props = new Properties();    try {        props.load(in);    } finally {        in.close();    }    add("package org.apache.parquet;\n" + "\n" + "/**\n" + " * This class is auto-generated by org.apache.parquet.version.VersionGenerator\n" + " * Do not manually edit!\n" + " */\n");    add("public class Version {\n");    add("  public static final String VERSION_NUMBER = \"");    add(props.getProperty("versionNumber"));    add("\";\n");    add("  public static final String FULL_VERSION = \"");    add(props.getProperty("fullVersion"));    add("\";\n\n");    add("  public static void main(String[] args) {\n");    add("    System.out.println(FULL_VERSION);\n");    add("  }\n");    add("}\n");    writer.close();}
49184fb2072f8e45b9504158141fc639663454d7f211a93d59dc91b42452e1f5
add
private void add(String s) throws IOException
{    writer.write(s);}
fff618e8a72df9885c7715022bcbaa47db4decd1c0b62fd688ed7675bb1e1a46
filterRowGroups
public static List<BlockMetaData> filterRowGroups(Filter filter, List<BlockMetaData> blocks, MessageType schema)
{    checkNotNull(filter, "filter");    return filter.accept(new RowGroupFilter(blocks, schema));}
c789cf6fb38b489ec1496584079dc6de39727cbb1e17dbfb8d3dd2f8312ee98b
filterRowGroups
public static List<BlockMetaData> filterRowGroups(List<FilterLevel> levels, Filter filter, List<BlockMetaData> blocks, ParquetFileReader reader)
{    checkNotNull(filter, "filter");    return filter.accept(new RowGroupFilter(levels, blocks, reader));}
5c276d58191e5cae0b32c51edba1e0c1daace0683eb86aac83c4cff423966c6a
visit
public List<BlockMetaData> visit(FilterCompat.FilterPredicateCompat filterPredicateCompat)
{    FilterPredicate filterPredicate = filterPredicateCompat.getFilterPredicate();        SchemaCompatibilityValidator.validate(filterPredicate, schema);    List<BlockMetaData> filteredBlocks = new ArrayList<BlockMetaData>();    for (BlockMetaData block : blocks) {        boolean drop = false;        if (levels.contains(FilterLevel.STATISTICS)) {            drop = StatisticsFilter.canDrop(filterPredicate, block.getColumns());        }        if (!drop && levels.contains(FilterLevel.DICTIONARY)) {            drop = DictionaryFilter.canDrop(filterPredicate, block.getColumns(), reader.getDictionaryReader(block));        }        if (!drop) {            filteredBlocks.add(block);        }    }    return filteredBlocks;}
5563c2df00e3e4e1428c5b530d5acf4abe33841de9bdf2edf8421035dbbedf22
visit
public List<BlockMetaData> visit(FilterCompat.UnboundRecordFilterCompat unboundRecordFilterCompat)
{    return blocks;}
666d3797fe749579edb93e7c1fea9cda08524712edb9e527dcad2950a4b71cb0
visit
public List<BlockMetaData> visit(NoOpFilter noOpFilter)
{    return blocks;}
7bbdcc028537252e65247246fed746314c625c229ecff3cc793d1b30047f90fd
canDrop
public static boolean canDrop(FilterPredicate pred, List<ColumnChunkMetaData> columns, DictionaryPageReadStore dictionaries)
{    checkNotNull(pred, "pred");    checkNotNull(columns, "columns");    return pred.accept(new DictionaryFilter(columns, dictionaries));}
fc8bac3747ee8e46be574808a4c56c9426b2b370ee0461f4df2ba7c1b87ef12f
getColumnChunk
private ColumnChunkMetaData getColumnChunk(ColumnPath columnPath)
{    return columns.get(columnPath);}
09da894b1b2c70916c02d05514709c4e7e2ed7d528fc6b15fc380b204c5461d6
expandDictionary
private Set<T> expandDictionary(ColumnChunkMetaData meta) throws IOException
{    ColumnDescriptor col = new ColumnDescriptor(meta.getPath().toArray(), meta.getPrimitiveType(), -1, -1);    DictionaryPage page = dictionaries.readDictionaryPage(col);        if (page == null) {        return null;    }    Dictionary dict = page.getEncoding().initDictionary(col, page);    IntFunction<Object> dictValueProvider;    PrimitiveTypeName type = meta.getPrimitiveType().getPrimitiveTypeName();    switch(type) {                case FIXED_LEN_BYTE_ARRAY:        case BINARY:            dictValueProvider = dict::decodeToBinary;            break;        case INT32:            dictValueProvider = dict::decodeToInt;            break;        case INT64:            dictValueProvider = dict::decodeToLong;            break;        case FLOAT:            dictValueProvider = dict::decodeToFloat;            break;        case DOUBLE:            dictValueProvider = dict::decodeToDouble;            break;        default:            LOG.warn("Unsupported dictionary type: {}", type);            return null;    }    Set<T> dictSet = new HashSet<>();    for (int i = 0; i <= dict.getMaxId(); i++) {        dictSet.add((T) dictValueProvider.apply(i));    }    return dictSet;}
b044335dea3ce852471db14ef002fe32fc0a846c3010f640adf957dc3d8b4317
visit
public Boolean visit(Eq<T> eq)
{    T value = eq.getValue();    if (value == null) {                return BLOCK_MIGHT_MATCH;    }    Column<T> filterColumn = eq.getColumn();    ColumnChunkMetaData meta = getColumnChunk(filterColumn.getColumnPath());    if (meta == null) {                return BLOCK_CANNOT_MATCH;    }        if (hasNonDictionaryPages(meta)) {        return BLOCK_MIGHT_MATCH;    }    try {        Set<T> dictSet = expandDictionary(meta);        if (dictSet != null && !dictSet.contains(value)) {            return BLOCK_CANNOT_MATCH;        }    } catch (IOException e) {        LOG.warn("Failed to process dictionary for filter evaluation.", e);    }        return BLOCK_MIGHT_MATCH;}
cb49ee85edccd78bebad7140f414e9b8adb7bce5d9eabd723ddb2b287aaa377b
visit
public Boolean visit(NotEq<T> notEq)
{    Column<T> filterColumn = notEq.getColumn();    ColumnChunkMetaData meta = getColumnChunk(filterColumn.getColumnPath());    T value = notEq.getValue();    if (value == null && meta == null) {                return BLOCK_CANNOT_MATCH;    }    if (value == null) {                return BLOCK_MIGHT_MATCH;    }    if (meta == null) {                return BLOCK_MIGHT_MATCH;    }        if (hasNonDictionaryPages(meta)) {        return BLOCK_MIGHT_MATCH;    }    try {        Set<T> dictSet = expandDictionary(meta);        boolean mayContainNull = (meta.getStatistics() == null || !meta.getStatistics().isNumNullsSet() || meta.getStatistics().getNumNulls() > 0);        if (dictSet != null && dictSet.size() == 1 && dictSet.contains(value) && !mayContainNull) {            return BLOCK_CANNOT_MATCH;        }    } catch (IOException e) {        LOG.warn("Failed to process dictionary for filter evaluation.", e);    }    return BLOCK_MIGHT_MATCH;}
983f062f002e8a13b792419916a605a41a4f09d0ce087c271eff9cd3b47685bf
visit
public Boolean visit(Lt<T> lt)
{    Column<T> filterColumn = lt.getColumn();    ColumnChunkMetaData meta = getColumnChunk(filterColumn.getColumnPath());    if (meta == null) {                return BLOCK_CANNOT_MATCH;    }        if (hasNonDictionaryPages(meta)) {        return BLOCK_MIGHT_MATCH;    }    T value = lt.getValue();    try {        Set<T> dictSet = expandDictionary(meta);        if (dictSet == null) {            return BLOCK_MIGHT_MATCH;        }        Comparator<T> comparator = meta.getPrimitiveType().comparator();        for (T entry : dictSet) {            if (comparator.compare(value, entry) > 0) {                return BLOCK_MIGHT_MATCH;            }        }        return BLOCK_CANNOT_MATCH;    } catch (IOException e) {        LOG.warn("Failed to process dictionary for filter evaluation.", e);    }    return BLOCK_MIGHT_MATCH;}
4a8465f907a5f39c236ad4fcd4b267c2d378c0c523cbc7d5c5d68fe72ef025f6
visit
public Boolean visit(LtEq<T> ltEq)
{    Column<T> filterColumn = ltEq.getColumn();    ColumnChunkMetaData meta = getColumnChunk(filterColumn.getColumnPath());    if (meta == null) {                return BLOCK_CANNOT_MATCH;    }        if (hasNonDictionaryPages(meta)) {        return BLOCK_MIGHT_MATCH;    }    T value = ltEq.getValue();    filterColumn.getColumnPath();    try {        Set<T> dictSet = expandDictionary(meta);        if (dictSet == null) {            return BLOCK_MIGHT_MATCH;        }        Comparator<T> comparator = meta.getPrimitiveType().comparator();        for (T entry : dictSet) {            if (comparator.compare(value, entry) >= 0) {                return BLOCK_MIGHT_MATCH;            }        }        return BLOCK_CANNOT_MATCH;    } catch (IOException e) {        LOG.warn("Failed to process dictionary for filter evaluation.", e);    }    return BLOCK_MIGHT_MATCH;}
5635ea15c51bf33fa5efbaf56e7304d9dc472151e7087b4dd1a059a3ad19b652
visit
public Boolean visit(Gt<T> gt)
{    Column<T> filterColumn = gt.getColumn();    ColumnChunkMetaData meta = getColumnChunk(filterColumn.getColumnPath());    if (meta == null) {                return BLOCK_CANNOT_MATCH;    }        if (hasNonDictionaryPages(meta)) {        return BLOCK_MIGHT_MATCH;    }    T value = gt.getValue();    try {        Set<T> dictSet = expandDictionary(meta);        if (dictSet == null) {            return BLOCK_MIGHT_MATCH;        }        Comparator<T> comparator = meta.getPrimitiveType().comparator();        for (T entry : dictSet) {            if (comparator.compare(value, entry) < 0) {                return BLOCK_MIGHT_MATCH;            }        }        return BLOCK_CANNOT_MATCH;    } catch (IOException e) {        LOG.warn("Failed to process dictionary for filter evaluation.", e);    }    return BLOCK_MIGHT_MATCH;}
2c70e11cf7f8f1131aed5e60621f027076badb9bfe6d62941d9b4ce749e14116
visit
public Boolean visit(GtEq<T> gtEq)
{    Column<T> filterColumn = gtEq.getColumn();    ColumnChunkMetaData meta = getColumnChunk(filterColumn.getColumnPath());    if (meta == null) {                return BLOCK_CANNOT_MATCH;    }        if (hasNonDictionaryPages(meta)) {        return BLOCK_MIGHT_MATCH;    }    T value = gtEq.getValue();    filterColumn.getColumnPath();    try {        Set<T> dictSet = expandDictionary(meta);        if (dictSet == null) {            return BLOCK_MIGHT_MATCH;        }        Comparator<T> comparator = meta.getPrimitiveType().comparator();        for (T entry : dictSet) {            if (comparator.compare(value, entry) <= 0) {                return BLOCK_MIGHT_MATCH;            }        }        return BLOCK_CANNOT_MATCH;    } catch (IOException e) {        LOG.warn("Failed to process dictionary for filter evaluation.", e);    }    return BLOCK_MIGHT_MATCH;}
2df247dfad08f60d2d926d924482315cf89f1bc9af0abcf65a7d87325e95f174
visit
public Boolean visit(And and)
{    return and.getLeft().accept(this) || and.getRight().accept(this);}
98176954836739fd2aa9aafaa60510cbbe292219f2b4af81697b882b3d87a5e6
visit
public Boolean visit(Or or)
{    return or.getLeft().accept(this) && or.getRight().accept(this);}
8566c3dd8b5e64698ad36a0da78a35bf17ef8a3783ac6c483c5a31292b4117ef
visit
public Boolean visit(Not not)
{    throw new IllegalArgumentException("This predicate contains a not! Did you forget to run this predicate through LogicalInverseRewriter? " + not);}
acd64b91d735819b22f10886f9a663bce6538364fbf424c53a14534ff3896f99
visit
private Boolean visit(UserDefined<T, U> ud, boolean inverted)
{    Column<T> filterColumn = ud.getColumn();    ColumnChunkMetaData meta = getColumnChunk(filterColumn.getColumnPath());    U udp = ud.getUserDefinedPredicate();        if (meta == null) {        if (inverted) {            return udp.acceptsNullValue();        } else {            return !udp.acceptsNullValue();        }    }    if (hasNonDictionaryPages(meta)) {        return BLOCK_MIGHT_MATCH;    }    try {        Set<T> dictSet = expandDictionary(meta);        if (dictSet == null) {            return BLOCK_MIGHT_MATCH;        }        for (T entry : dictSet) {            boolean keep = udp.keep(entry);            if ((keep && !inverted) || (!keep && inverted))                return BLOCK_MIGHT_MATCH;        }        return BLOCK_CANNOT_MATCH;    } catch (IOException e) {        LOG.warn("Failed to process dictionary for filter evaluation.", e);    }    return BLOCK_MIGHT_MATCH;}
e96eabcb00d8f3de4a1bf3829bfaae59ca2d9cf78d737531883fc677adbb244c
visit
public Boolean visit(UserDefined<T, U> udp)
{    return visit(udp, false);}
15e75820b5e8766f8af98d74edb1278a8449518634e4a35d16b45d1edc0e8fdc
visit
public Boolean visit(LogicalNotUserDefined<T, U> udp)
{    return visit(udp.getUserDefined(), true);}
952c284d8181afbd8603ad5f00a042066764459d2ff5489386a6dcaa825ea843
hasNonDictionaryPages
private static boolean hasNonDictionaryPages(ColumnChunkMetaData meta)
{    EncodingStats stats = meta.getEncodingStats();    if (stats != null) {        return stats.hasNonDictionaryEncodedPages();    }        Set<Encoding> encodings = new HashSet<Encoding>(meta.getEncodings());    if (encodings.remove(Encoding.PLAIN_DICTIONARY)) {                                encodings.remove(Encoding.RLE);        encodings.remove(Encoding.BIT_PACKED);        if (encodings.isEmpty()) {                        return false;        }        return true;    } else {                return true;    }}
ee15f0489bc5c6610df0fcd5897cfede3210d2855197e10413d346ddb55e17bd
canDrop
public static boolean canDrop(FilterPredicate pred, List<ColumnChunkMetaData> columns)
{    checkNotNull(pred, "pred");    checkNotNull(columns, "columns");    return pred.accept(new StatisticsFilter(columns));}
fc8bac3747ee8e46be574808a4c56c9426b2b370ee0461f4df2ba7c1b87ef12f
getColumnChunk
private ColumnChunkMetaData getColumnChunk(ColumnPath columnPath)
{    return columns.get(columnPath);}
fa84f6aefa73e5cac14d0b6ae904ceba94d6dc733993fc8130f9429ecf0d98d7
isAllNulls
private boolean isAllNulls(ColumnChunkMetaData column)
{    return column.getStatistics().getNumNulls() == column.getValueCount();}
8c587d7a9d592a433dd7733fc4f86ee8ff583bcb3daf61b58565086f5d3b462f
hasNulls
private boolean hasNulls(ColumnChunkMetaData column)
{    return column.getStatistics().getNumNulls() > 0;}
b044335dea3ce852471db14ef002fe32fc0a846c3010f640adf957dc3d8b4317
visit
public Boolean visit(Eq<T> eq)
{    Column<T> filterColumn = eq.getColumn();    ColumnChunkMetaData meta = getColumnChunk(filterColumn.getColumnPath());    T value = eq.getValue();    if (meta == null) {                if (value != null) {                        return BLOCK_CANNOT_MATCH;        }        return BLOCK_MIGHT_MATCH;    }    Statistics<T> stats = meta.getStatistics();    if (stats.isEmpty()) {                return BLOCK_MIGHT_MATCH;    }    if (value == null) {                if (!stats.isNumNullsSet()) {            return BLOCK_MIGHT_MATCH;        }                return !hasNulls(meta);    }    if (isAllNulls(meta)) {                return BLOCK_CANNOT_MATCH;    }    if (!stats.hasNonNullValue()) {                return BLOCK_MIGHT_MATCH;    }        return stats.compareMinToValue(value) > 0 || stats.compareMaxToValue(value) < 0;}
cb49ee85edccd78bebad7140f414e9b8adb7bce5d9eabd723ddb2b287aaa377b
visit
public Boolean visit(NotEq<T> notEq)
{    Column<T> filterColumn = notEq.getColumn();    ColumnChunkMetaData meta = getColumnChunk(filterColumn.getColumnPath());    T value = notEq.getValue();    if (meta == null) {        if (value == null) {                        return BLOCK_CANNOT_MATCH;        }        return BLOCK_MIGHT_MATCH;    }    Statistics<T> stats = meta.getStatistics();    if (stats.isEmpty()) {                return BLOCK_MIGHT_MATCH;    }    if (value == null) {                return isAllNulls(meta);    }    if (stats.isNumNullsSet() && hasNulls(meta)) {                return BLOCK_MIGHT_MATCH;    }    if (!stats.hasNonNullValue()) {                return BLOCK_MIGHT_MATCH;    }        return stats.compareMinToValue(value) == 0 && stats.compareMaxToValue(value) == 0;}
983f062f002e8a13b792419916a605a41a4f09d0ce087c271eff9cd3b47685bf
visit
public Boolean visit(Lt<T> lt)
{    Column<T> filterColumn = lt.getColumn();    ColumnChunkMetaData meta = getColumnChunk(filterColumn.getColumnPath());    if (meta == null) {                return BLOCK_CANNOT_MATCH;    }    Statistics<T> stats = meta.getStatistics();    if (stats.isEmpty()) {                return BLOCK_MIGHT_MATCH;    }    if (isAllNulls(meta)) {                return BLOCK_CANNOT_MATCH;    }    if (!stats.hasNonNullValue()) {                return BLOCK_MIGHT_MATCH;    }    T value = lt.getValue();        return stats.compareMinToValue(value) >= 0;}
4a8465f907a5f39c236ad4fcd4b267c2d378c0c523cbc7d5c5d68fe72ef025f6
visit
public Boolean visit(LtEq<T> ltEq)
{    Column<T> filterColumn = ltEq.getColumn();    ColumnChunkMetaData meta = getColumnChunk(filterColumn.getColumnPath());    if (meta == null) {                return BLOCK_CANNOT_MATCH;    }    Statistics<T> stats = meta.getStatistics();    if (stats.isEmpty()) {                return BLOCK_MIGHT_MATCH;    }    if (isAllNulls(meta)) {                return BLOCK_CANNOT_MATCH;    }    if (!stats.hasNonNullValue()) {                return BLOCK_MIGHT_MATCH;    }    T value = ltEq.getValue();        return stats.compareMinToValue(value) > 0;}
5635ea15c51bf33fa5efbaf56e7304d9dc472151e7087b4dd1a059a3ad19b652
visit
public Boolean visit(Gt<T> gt)
{    Column<T> filterColumn = gt.getColumn();    ColumnChunkMetaData meta = getColumnChunk(filterColumn.getColumnPath());    if (meta == null) {                return BLOCK_CANNOT_MATCH;    }    Statistics<T> stats = meta.getStatistics();    if (stats.isEmpty()) {                return BLOCK_MIGHT_MATCH;    }    if (isAllNulls(meta)) {                return BLOCK_CANNOT_MATCH;    }    if (!stats.hasNonNullValue()) {                return BLOCK_MIGHT_MATCH;    }    T value = gt.getValue();        return stats.compareMaxToValue(value) <= 0;}
2c70e11cf7f8f1131aed5e60621f027076badb9bfe6d62941d9b4ce749e14116
visit
public Boolean visit(GtEq<T> gtEq)
{    Column<T> filterColumn = gtEq.getColumn();    ColumnChunkMetaData meta = getColumnChunk(filterColumn.getColumnPath());    if (meta == null) {                return BLOCK_CANNOT_MATCH;    }    Statistics<T> stats = meta.getStatistics();    if (stats.isEmpty()) {                return BLOCK_MIGHT_MATCH;    }    if (isAllNulls(meta)) {                return BLOCK_CANNOT_MATCH;    }    if (!stats.hasNonNullValue()) {                return BLOCK_MIGHT_MATCH;    }    T value = gtEq.getValue();        return stats.compareMaxToValue(value) < 0;}
2df247dfad08f60d2d926d924482315cf89f1bc9af0abcf65a7d87325e95f174
visit
public Boolean visit(And and)
{        return and.getLeft().accept(this) || and.getRight().accept(this);}
98176954836739fd2aa9aafaa60510cbbe292219f2b4af81697b882b3d87a5e6
visit
public Boolean visit(Or or)
{        return or.getLeft().accept(this) && or.getRight().accept(this);}
8566c3dd8b5e64698ad36a0da78a35bf17ef8a3783ac6c483c5a31292b4117ef
visit
public Boolean visit(Not not)
{    throw new IllegalArgumentException("This predicate contains a not! Did you forget to run this predicate through LogicalInverseRewriter? " + not);}
acd64b91d735819b22f10886f9a663bce6538364fbf424c53a14534ff3896f99
visit
private Boolean visit(UserDefined<T, U> ud, boolean inverted)
{    Column<T> filterColumn = ud.getColumn();    ColumnChunkMetaData columnChunk = getColumnChunk(filterColumn.getColumnPath());    U udp = ud.getUserDefinedPredicate();    if (columnChunk == null) {                if (inverted) {            return udp.acceptsNullValue();        } else {            return !udp.acceptsNullValue();        }    }    Statistics<T> stats = columnChunk.getStatistics();    if (stats.isEmpty()) {                return BLOCK_MIGHT_MATCH;    }    if (isAllNulls(columnChunk)) {                if (inverted) {            return udp.acceptsNullValue();        } else {            return !udp.acceptsNullValue();        }    }    if (!stats.hasNonNullValue()) {                return BLOCK_MIGHT_MATCH;    }    org.apache.parquet.filter2.predicate.Statistics<T> udpStats = new org.apache.parquet.filter2.predicate.Statistics<T>(stats.genericGetMin(), stats.genericGetMax(), stats.comparator());    if (inverted) {        return udp.inverseCanDrop(udpStats);    } else {        return udp.canDrop(udpStats);    }}
726fc37c4940b554dab425bfb38a0067c31d362310e9a89ceab6d40b9772d4a1
visit
public Boolean visit(UserDefined<T, U> ud)
{    return visit(ud, false);}
685bdd7c7e13baa2990cbb86f9f044d62475471940195d6c09e8d97980bb8e1f
visit
public Boolean visit(LogicalNotUserDefined<T, U> lnud)
{    return visit(lnud.getUserDefined(), true);}
ee92ff6e4acbf80e6bdafb7d4d636b74bbf5e7a7e444beff6890836145cebbef
toParquetMetadata
public FileMetaData toParquetMetadata(int currentVersion, ParquetMetadata parquetMetadata)
{    List<BlockMetaData> blocks = parquetMetadata.getBlocks();    List<RowGroup> rowGroups = new ArrayList<RowGroup>();    long numRows = 0;    for (BlockMetaData block : blocks) {        numRows += block.getRowCount();        addRowGroup(parquetMetadata, rowGroups, block);    }    FileMetaData fileMetaData = new FileMetaData(currentVersion, toParquetSchema(parquetMetadata.getFileMetaData().getSchema()), numRows, rowGroups);    Set<Entry<String, String>> keyValues = parquetMetadata.getFileMetaData().getKeyValueMetaData().entrySet();    for (Entry<String, String> keyValue : keyValues) {        addKeyValue(fileMetaData, keyValue.getKey(), keyValue.getValue());    }    fileMetaData.setCreated_by(parquetMetadata.getFileMetaData().getCreatedBy());    fileMetaData.setColumn_orders(getColumnOrders(parquetMetadata.getFileMetaData().getSchema()));    return fileMetaData;}
6279d64621b910c469574095a2cb0af7d744c3c62717707caabe6d4524175f3c
getColumnOrders
private List<ColumnOrder> getColumnOrders(MessageType schema)
{    List<ColumnOrder> columnOrders = new ArrayList<>();        for (int i = 0, n = schema.getPaths().size(); i < n; ++i) {        ColumnOrder columnOrder = new ColumnOrder();        columnOrder.setTYPE_ORDER(TYPE_DEFINED_ORDER);        columnOrders.add(columnOrder);    }    return columnOrders;}
0733389b9a22fe0c9566786b0df5bbeafef7b02e6350bab91c58630f2025729e
toParquetSchema
 List<SchemaElement> toParquetSchema(MessageType schema)
{    List<SchemaElement> result = new ArrayList<SchemaElement>();    addToList(result, schema);    return result;}
6c56274bbfbe467ef6377542369bb191fa590434ba315c86428cf40fa86979ac
addToList
private void addToList(final List<SchemaElement> result, org.apache.parquet.schema.Type field)
{    field.accept(new TypeVisitor() {        @Override        public void visit(PrimitiveType primitiveType) {            SchemaElement element = new SchemaElement(primitiveType.getName());            element.setRepetition_type(toParquetRepetition(primitiveType.getRepetition()));            element.setType(getType(primitiveType.getPrimitiveTypeName()));            if (primitiveType.getLogicalTypeAnnotation() != null) {                element.setConverted_type(convertToConvertedType(primitiveType.getLogicalTypeAnnotation()));                element.setLogicalType(convertToLogicalType(primitiveType.getLogicalTypeAnnotation()));            }            if (primitiveType.getDecimalMetadata() != null) {                element.setPrecision(primitiveType.getDecimalMetadata().getPrecision());                element.setScale(primitiveType.getDecimalMetadata().getScale());            }            if (primitiveType.getTypeLength() > 0) {                element.setType_length(primitiveType.getTypeLength());            }            if (primitiveType.getId() != null) {                element.setField_id(primitiveType.getId().intValue());            }            result.add(element);        }        @Override        public void visit(MessageType messageType) {            SchemaElement element = new SchemaElement(messageType.getName());            if (messageType.getId() != null) {                element.setField_id(messageType.getId().intValue());            }            visitChildren(result, messageType.asGroupType(), element);        }        @Override        public void visit(GroupType groupType) {            SchemaElement element = new SchemaElement(groupType.getName());            element.setRepetition_type(toParquetRepetition(groupType.getRepetition()));            if (groupType.getLogicalTypeAnnotation() != null) {                element.setConverted_type(convertToConvertedType(groupType.getLogicalTypeAnnotation()));                element.setLogicalType(convertToLogicalType(groupType.getLogicalTypeAnnotation()));            }            if (groupType.getId() != null) {                element.setField_id(groupType.getId().intValue());            }            visitChildren(result, groupType, element);        }        private void visitChildren(final List<SchemaElement> result, GroupType groupType, SchemaElement element) {            element.setNum_children(groupType.getFieldCount());            result.add(element);            for (org.apache.parquet.schema.Type field : groupType.getFields()) {                addToList(result, field);            }        }    });}
d786d00215ab65b41fff4db7542dd376f5c3b9f2b7c11065b6f1a5b3a4feb8b0
visit
public void visit(PrimitiveType primitiveType)
{    SchemaElement element = new SchemaElement(primitiveType.getName());    element.setRepetition_type(toParquetRepetition(primitiveType.getRepetition()));    element.setType(getType(primitiveType.getPrimitiveTypeName()));    if (primitiveType.getLogicalTypeAnnotation() != null) {        element.setConverted_type(convertToConvertedType(primitiveType.getLogicalTypeAnnotation()));        element.setLogicalType(convertToLogicalType(primitiveType.getLogicalTypeAnnotation()));    }    if (primitiveType.getDecimalMetadata() != null) {        element.setPrecision(primitiveType.getDecimalMetadata().getPrecision());        element.setScale(primitiveType.getDecimalMetadata().getScale());    }    if (primitiveType.getTypeLength() > 0) {        element.setType_length(primitiveType.getTypeLength());    }    if (primitiveType.getId() != null) {        element.setField_id(primitiveType.getId().intValue());    }    result.add(element);}
e183e50c625f3005b23a9727bd6a0d4ad3baa292e6b90993c782af03766328a8
visit
public void visit(MessageType messageType)
{    SchemaElement element = new SchemaElement(messageType.getName());    if (messageType.getId() != null) {        element.setField_id(messageType.getId().intValue());    }    visitChildren(result, messageType.asGroupType(), element);}
6ae94c927875668c171f00a4537468b9128fa1e640c0eb0d44c672494f97ea30
visit
public void visit(GroupType groupType)
{    SchemaElement element = new SchemaElement(groupType.getName());    element.setRepetition_type(toParquetRepetition(groupType.getRepetition()));    if (groupType.getLogicalTypeAnnotation() != null) {        element.setConverted_type(convertToConvertedType(groupType.getLogicalTypeAnnotation()));        element.setLogicalType(convertToLogicalType(groupType.getLogicalTypeAnnotation()));    }    if (groupType.getId() != null) {        element.setField_id(groupType.getId().intValue());    }    visitChildren(result, groupType, element);}
72750739c86b0b1a73116ede26959d22e07718f547ef15e191d4a514dc63dd52
visitChildren
private void visitChildren(final List<SchemaElement> result, GroupType groupType, SchemaElement element)
{    element.setNum_children(groupType.getFieldCount());    result.add(element);    for (org.apache.parquet.schema.Type field : groupType.getFields()) {        addToList(result, field);    }}
d340668edf635b064dec09cead25720f579f2e8179201c4d2b9b06eb38cd36ca
convertToLogicalType
 LogicalType convertToLogicalType(LogicalTypeAnnotation logicalTypeAnnotation)
{    return logicalTypeAnnotation.accept(LOGICAL_TYPE_ANNOTATION_VISITOR).get();}
e38651af68699d97ae6ce0418aa4140fb3b431c5b5a4c4d471a50783995042e0
convertToConvertedType
 ConvertedType convertToConvertedType(LogicalTypeAnnotation logicalTypeAnnotation)
{    return logicalTypeAnnotation.accept(CONVERTED_TYPE_CONVERTER_VISITOR).orElse(null);}
78e44f180fbe13546bd1ee37216bb439e49e90278c21ff5add862bbf8dc5c3b1
convertUnit
 static org.apache.parquet.format.TimeUnit convertUnit(LogicalTypeAnnotation.TimeUnit unit)
{    switch(unit) {        case MICROS:            return org.apache.parquet.format.TimeUnit.MICROS(new MicroSeconds());        case MILLIS:            return org.apache.parquet.format.TimeUnit.MILLIS(new MilliSeconds());        case NANOS:            return TimeUnit.NANOS(new NanoSeconds());        default:            throw new RuntimeException("Unknown time unit " + unit);    }}
b3538c18778ec336b5667f069c5b7a1b601d2857f99d3ebcb598761eb8055778
visit
public Optional<ConvertedType> visit(LogicalTypeAnnotation.StringLogicalTypeAnnotation stringLogicalType)
{    return of(ConvertedType.UTF8);}
11a30c8f96055e52c088109e244e7ef27aca898f57a5f6e54ce18c17759c562e
visit
public Optional<ConvertedType> visit(LogicalTypeAnnotation.MapLogicalTypeAnnotation mapLogicalType)
{    return of(ConvertedType.MAP);}
a32ee7499bdc7c66b0b225e7222d182263f851c7a6a4dd68b81879df2606c0b8
visit
public Optional<ConvertedType> visit(LogicalTypeAnnotation.ListLogicalTypeAnnotation listLogicalType)
{    return of(ConvertedType.LIST);}
98f74fae3f10de4cea4bebfe4db8968328cbf6325b41e3584e607738ad183113
visit
public Optional<ConvertedType> visit(LogicalTypeAnnotation.EnumLogicalTypeAnnotation enumLogicalType)
{    return of(ConvertedType.ENUM);}
2c7f55e19dd0ec3e676368cf2c0767802245754d2e26962d81348cde2f33e977
visit
public Optional<ConvertedType> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType)
{    return of(ConvertedType.DECIMAL);}
b3bb78fdcb61258839abfd4962310ad0e86a10e37c26f1afb45f4a9d60a80e51
visit
public Optional<ConvertedType> visit(LogicalTypeAnnotation.DateLogicalTypeAnnotation dateLogicalType)
{    return of(ConvertedType.DATE);}
18df412c989fad63e8258c9d5b39bfd7c28cd6e5e72e73eb178b8d4764354d6b
visit
public Optional<ConvertedType> visit(LogicalTypeAnnotation.TimeLogicalTypeAnnotation timeLogicalType)
{    if (!timeLogicalType.isAdjustedToUTC()) {        return empty();    }    switch(timeLogicalType.getUnit()) {        case MILLIS:            return of(ConvertedType.TIME_MILLIS);        case MICROS:            return of(ConvertedType.TIME_MICROS);        case NANOS:            return empty();        default:            throw new RuntimeException("Unknown converted type for " + timeLogicalType.toOriginalType());    }}
c6d19ff4faa89236cca55f2b517021760773006f8e9514587ffc10d87eec8544
visit
public Optional<ConvertedType> visit(LogicalTypeAnnotation.TimestampLogicalTypeAnnotation timestampLogicalType)
{    if (!timestampLogicalType.isAdjustedToUTC()) {        return empty();    }    switch(timestampLogicalType.getUnit()) {        case MICROS:            return of(ConvertedType.TIMESTAMP_MICROS);        case MILLIS:            return of(ConvertedType.TIMESTAMP_MILLIS);        case NANOS:            return empty();        default:            throw new RuntimeException("Unknown converted type for " + timestampLogicalType.toOriginalType());    }}
2ca446e2579633ea1e0082f6d418a23e25805377be40240f93e26aa5167eb350
visit
public Optional<ConvertedType> visit(LogicalTypeAnnotation.IntLogicalTypeAnnotation intLogicalType)
{    boolean signed = intLogicalType.isSigned();    switch(intLogicalType.getBitWidth()) {        case 8:            return of(signed ? ConvertedType.INT_8 : ConvertedType.UINT_8);        case 16:            return of(signed ? ConvertedType.INT_16 : ConvertedType.UINT_16);        case 32:            return of(signed ? ConvertedType.INT_32 : ConvertedType.UINT_32);        case 64:            return of(signed ? ConvertedType.INT_64 : ConvertedType.UINT_64);        default:            throw new RuntimeException("Unknown original type " + intLogicalType.toOriginalType());    }}
eae8d7425b121bf10413aa843a232e4daf00bc5944cdaccc434a7ccf0eae6c48
visit
public Optional<ConvertedType> visit(LogicalTypeAnnotation.JsonLogicalTypeAnnotation jsonLogicalType)
{    return of(ConvertedType.JSON);}
5ba3b84b7c4e41c634d804cec5587dc9c38792537796b94673ec9646ef629d52
visit
public Optional<ConvertedType> visit(LogicalTypeAnnotation.BsonLogicalTypeAnnotation bsonLogicalType)
{    return of(ConvertedType.BSON);}
fd7beb99549dc707909eb141720bae052985fb0bc0becef1ce062147325bbfc5
visit
public Optional<ConvertedType> visit(LogicalTypeAnnotation.IntervalLogicalTypeAnnotation intervalLogicalType)
{    return of(ConvertedType.INTERVAL);}
d8269e7fad10c5b4e520fcab9671c5434629b144577905689e428992f5b74e31
visit
public Optional<ConvertedType> visit(LogicalTypeAnnotation.MapKeyValueTypeAnnotation mapKeyValueLogicalType)
{    return of(ConvertedType.MAP_KEY_VALUE);}
bd76f506eec71a5dc3d02097471d98076b30653e657e3b84c2bbb4f0355b1159
visit
public Optional<LogicalType> visit(LogicalTypeAnnotation.StringLogicalTypeAnnotation stringLogicalType)
{    return of(LogicalType.STRING(new StringType()));}
71c441f9180603c3a6fd5017a569b45155961a45ab34d4534878de232c889c13
visit
public Optional<LogicalType> visit(LogicalTypeAnnotation.MapLogicalTypeAnnotation mapLogicalType)
{    return of(LogicalType.MAP(new MapType()));}
5ea04b3cb1f670889c23c352ac5a8257919dee48fd6e52b6f15e599e66287acc
visit
public Optional<LogicalType> visit(LogicalTypeAnnotation.ListLogicalTypeAnnotation listLogicalType)
{    return of(LogicalType.LIST(new ListType()));}
61f53d7dc52de210d79c03c4f23cdfc79532029677a388b508af814b97095f15
visit
public Optional<LogicalType> visit(LogicalTypeAnnotation.EnumLogicalTypeAnnotation enumLogicalType)
{    return of(LogicalType.ENUM(new EnumType()));}
4e3940c686e8391cc577ede4ca9baa684399c88b0b422caf0021ee1e6e49acfe
visit
public Optional<LogicalType> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType)
{    return of(LogicalType.DECIMAL(new DecimalType(decimalLogicalType.getScale(), decimalLogicalType.getPrecision())));}
68d8812694b9c21b619a29391ea8fe53fcf02037012f68c82c337e370df0dd35
visit
public Optional<LogicalType> visit(LogicalTypeAnnotation.DateLogicalTypeAnnotation dateLogicalType)
{    return of(LogicalType.DATE(new DateType()));}
ef25f619b4117fcaaee5de1050bedea0698ed975dac1bd6e2185a81f15716fae
visit
public Optional<LogicalType> visit(LogicalTypeAnnotation.TimeLogicalTypeAnnotation timeLogicalType)
{    return of(LogicalType.TIME(new TimeType(timeLogicalType.isAdjustedToUTC(), convertUnit(timeLogicalType.getUnit()))));}
8dd441a7209df906fdac4e302254eabe3e4b356b046152db0f22a95e720a3dbb
visit
public Optional<LogicalType> visit(LogicalTypeAnnotation.TimestampLogicalTypeAnnotation timestampLogicalType)
{    return of(LogicalType.TIMESTAMP(new TimestampType(timestampLogicalType.isAdjustedToUTC(), convertUnit(timestampLogicalType.getUnit()))));}
2b0d67a8990374fd4b4169ec324f853aa2652a01219c7aa33c1a655f1e0e159b
visit
public Optional<LogicalType> visit(LogicalTypeAnnotation.IntLogicalTypeAnnotation intLogicalType)
{    return of(LogicalType.INTEGER(new IntType((byte) intLogicalType.getBitWidth(), intLogicalType.isSigned())));}
bef2887ac439d149b40faefb15c4544ad9701ad04990bc7312e04d5fe7066c56
visit
public Optional<LogicalType> visit(LogicalTypeAnnotation.JsonLogicalTypeAnnotation jsonLogicalType)
{    return of(LogicalType.JSON(new JsonType()));}
e483f5bbfe98fc5022ff9ddc18110b3f9106738ae8237325f9f3ee5b855471a0
visit
public Optional<LogicalType> visit(LogicalTypeAnnotation.BsonLogicalTypeAnnotation bsonLogicalType)
{    return of(LogicalType.BSON(new BsonType()));}
4f102a6ee1332f46794e1807e37f67957e08ed7bce1a39d05262d4627016841a
visit
public Optional<LogicalType> visit(LogicalTypeAnnotation.IntervalLogicalTypeAnnotation intervalLogicalType)
{    return of(LogicalType.UNKNOWN(new NullType()));}
0932ab5ca0c196f62c0501602c25899d6d0b3984fc288229c963279c6b8edde5
visit
public Optional<LogicalType> visit(LogicalTypeAnnotation.MapKeyValueTypeAnnotation mapKeyValueLogicalType)
{    return of(LogicalType.UNKNOWN(new NullType()));}
2cbb8fd21b81711fccdfd167c8f57e48e8d91a32aac36eeae522a0345885654a
addRowGroup
private void addRowGroup(ParquetMetadata parquetMetadata, List<RowGroup> rowGroups, BlockMetaData block)
{        List<ColumnChunkMetaData> columns = block.getColumns();    List<ColumnChunk> parquetColumns = new ArrayList<ColumnChunk>();    for (ColumnChunkMetaData columnMetaData : columns) {                ColumnChunk columnChunk = new ColumnChunk(columnMetaData.getFirstDataPageOffset());                columnChunk.file_path = block.getPath();        columnChunk.meta_data = new ColumnMetaData(getType(columnMetaData.getType()), toFormatEncodings(columnMetaData.getEncodings()), Arrays.asList(columnMetaData.getPath().toArray()), toFormatCodec(columnMetaData.getCodec()), columnMetaData.getValueCount(), columnMetaData.getTotalUncompressedSize(), columnMetaData.getTotalSize(), columnMetaData.getFirstDataPageOffset());        columnChunk.meta_data.dictionary_page_offset = columnMetaData.getDictionaryPageOffset();        if (!columnMetaData.getStatistics().isEmpty()) {            columnChunk.meta_data.setStatistics(toParquetStatistics(columnMetaData.getStatistics()));        }        if (columnMetaData.getEncodingStats() != null) {            columnChunk.meta_data.setEncoding_stats(convertEncodingStats(columnMetaData.getEncodingStats()));        }                        IndexReference columnIndexRef = columnMetaData.getColumnIndexReference();        if (columnIndexRef != null) {            columnChunk.setColumn_index_offset(columnIndexRef.getOffset());            columnChunk.setColumn_index_length(columnIndexRef.getLength());        }        IndexReference offsetIndexRef = columnMetaData.getOffsetIndexReference();        if (offsetIndexRef != null) {            columnChunk.setOffset_index_offset(offsetIndexRef.getOffset());            columnChunk.setOffset_index_length(offsetIndexRef.getLength());        }        parquetColumns.add(columnChunk);    }    RowGroup rowGroup = new RowGroup(parquetColumns, block.getTotalByteSize(), block.getRowCount());    rowGroups.add(rowGroup);}
b21d82c48523ac3696bb718ae620deb01da5726ebdb83d24bbbcc0193a669635
toFormatEncodings
private List<Encoding> toFormatEncodings(Set<org.apache.parquet.column.Encoding> encodings)
{    List<Encoding> converted = new ArrayList<Encoding>(encodings.size());    for (org.apache.parquet.column.Encoding encoding : encodings) {        converted.add(getEncoding(encoding));    }    return converted;}
afd965ec231a94fed449474644e56ca20aecaf2ac7b39a6d8f2a17c7b2fa136f
fromFormatEncodings
 Set<org.apache.parquet.column.Encoding> fromFormatEncodings(List<Encoding> encodings)
{    Set<org.apache.parquet.column.Encoding> converted = new HashSet<org.apache.parquet.column.Encoding>();    for (Encoding encoding : encodings) {        converted.add(getEncoding(encoding));    }        converted = Collections.unmodifiableSet(converted);        Set<org.apache.parquet.column.Encoding> cached = cachedEncodingSets.putIfAbsent(converted, converted);    if (cached == null) {                                cached = converted;    }    return cached;}
a448e98ad5d178eb372d690e3a28e8464350d358d7636945e1a57f0ffd7eb835
fromFormatCodec
private CompressionCodecName fromFormatCodec(CompressionCodec codec)
{    return CompressionCodecName.valueOf(codec.toString());}
475ce844aec81f85fa750b09d1b28bb238530ce908dc8501d4642f0c62ecb54e
toFormatCodec
private CompressionCodec toFormatCodec(CompressionCodecName codec)
{    return CompressionCodec.valueOf(codec.toString());}
9e72b0721d974d5b3b13e46b0729f1de9c732e47775e8eb2d080d54577d5bcae
getEncoding
public org.apache.parquet.column.Encoding getEncoding(Encoding encoding)
{    return org.apache.parquet.column.Encoding.valueOf(encoding.name());}
434e7f623efacd78cb03187bc24bdb8bce286fc98bfa4fa00cffe785a99591da
getEncoding
public Encoding getEncoding(org.apache.parquet.column.Encoding encoding)
{    return Encoding.valueOf(encoding.name());}
4588cc226e3e4812652d6f7443eff95e0f9170d146bb933d83c2bae5b582b622
convertEncodingStats
public EncodingStats convertEncodingStats(List<PageEncodingStats> stats)
{    if (stats == null) {        return null;    }    EncodingStats.Builder builder = new EncodingStats.Builder();    for (PageEncodingStats stat : stats) {        switch(stat.getPage_type()) {            case DATA_PAGE_V2:                builder.withV2Pages();                        case DATA_PAGE:                builder.addDataEncoding(getEncoding(stat.getEncoding()), stat.getCount());                break;            case DICTIONARY_PAGE:                builder.addDictEncoding(getEncoding(stat.getEncoding()), stat.getCount());                break;        }    }    return builder.build();}
231454548a03c3e9208b92c7630db8b5a15cc9d751184c6cbc7399a6c7bf070f
convertEncodingStats
public List<PageEncodingStats> convertEncodingStats(EncodingStats stats)
{    if (stats == null) {        return null;    }    List<PageEncodingStats> formatStats = new ArrayList<PageEncodingStats>();    for (org.apache.parquet.column.Encoding encoding : stats.getDictionaryEncodings()) {        formatStats.add(new PageEncodingStats(PageType.DICTIONARY_PAGE, getEncoding(encoding), stats.getNumDictionaryPagesEncodedAs(encoding)));    }    PageType dataPageType = (stats.usesV2Pages() ? PageType.DATA_PAGE_V2 : PageType.DATA_PAGE);    for (org.apache.parquet.column.Encoding encoding : stats.getDataEncodings()) {        formatStats.add(new PageEncodingStats(dataPageType, getEncoding(encoding), stats.getNumDataPagesEncodedAs(encoding)));    }    return formatStats;}
8ce6a90fd4c25ff5d000c56fdd41f8050609c840763deb5e93c452cfe5571fed
toParquetStatistics
public static Statistics toParquetStatistics(org.apache.parquet.column.statistics.Statistics stats)
{    Statistics formatStats = new Statistics();        if (!stats.isEmpty() && stats.isSmallerThan(MAX_STATS_SIZE)) {        formatStats.setNull_count(stats.getNumNulls());        if (stats.hasNonNullValue()) {            byte[] min = stats.getMinBytes();            byte[] max = stats.getMaxBytes();                        if (sortOrder(stats.type()) == SortOrder.SIGNED || Arrays.equals(min, max)) {                formatStats.setMin(min);                formatStats.setMax(max);            }            if (isMinMaxStatsSupported(stats.type()) || Arrays.equals(min, max)) {                formatStats.setMin_value(min);                formatStats.setMax_value(max);            }        }    }    return formatStats;}
761ca45a5ced61617433dd599f3e00f8bb4514b83d7b80990d1958de05856f6b
isMinMaxStatsSupported
private static boolean isMinMaxStatsSupported(PrimitiveType type)
{    return type.columnOrder().getColumnOrderName() == ColumnOrderName.TYPE_DEFINED_ORDER;}
4a75c50318788d6d889ccbd49d4970d18f86f1132992c531b87c5e4c36b5935b
fromParquetStatistics
public static org.apache.parquet.column.statistics.Statistics fromParquetStatistics(Statistics statistics, PrimitiveTypeName type)
{    return fromParquetStatistics(null, statistics, type);}
b9e6428ab575b72626e996232eba1249d324d66be4a9120f6614cc2f5f91536c
fromParquetStatistics
public static org.apache.parquet.column.statistics.Statistics fromParquetStatistics(String createdBy, Statistics statistics, PrimitiveTypeName type)
{    return fromParquetStatisticsInternal(createdBy, statistics, new PrimitiveType(Repetition.OPTIONAL, type, "fake_type"), defaultSortOrder(type));}
78b68b2ffc88b01c6eb12b61ae75b5693e15d74cc0bb5a671e9582f2a9dbf274
fromParquetStatisticsInternal
 static org.apache.parquet.column.statistics.Statistics fromParquetStatisticsInternal(String createdBy, Statistics formatStats, PrimitiveType type, SortOrder typeSortOrder)
{        org.apache.parquet.column.statistics.Statistics.Builder statsBuilder = org.apache.parquet.column.statistics.Statistics.getBuilderForReading(type);    if (formatStats != null) {                if (formatStats.isSetMin_value() && formatStats.isSetMax_value()) {            byte[] min = formatStats.min_value.array();            byte[] max = formatStats.max_value.array();            if (isMinMaxStatsSupported(type) || Arrays.equals(min, max)) {                statsBuilder.withMin(min);                statsBuilder.withMax(max);            }        } else {            boolean isSet = formatStats.isSetMax() && formatStats.isSetMin();            boolean maxEqualsMin = isSet ? Arrays.equals(formatStats.getMin(), formatStats.getMax()) : false;            boolean sortOrdersMatch = SortOrder.SIGNED == typeSortOrder;                        if (!CorruptStatistics.shouldIgnoreStatistics(createdBy, type.getPrimitiveTypeName()) && (sortOrdersMatch || maxEqualsMin)) {                if (isSet) {                    statsBuilder.withMin(formatStats.min.array());                    statsBuilder.withMax(formatStats.max.array());                }            }        }        if (formatStats.isSetNull_count()) {            statsBuilder.withNumNulls(formatStats.null_count);        }    }    return statsBuilder.build();}
5d43b314d3285140844946df938eaa0d2ffc9f4e3de34ffa562fe54f7deea124
fromParquetStatistics
public org.apache.parquet.column.statistics.Statistics fromParquetStatistics(String createdBy, Statistics statistics, PrimitiveType type)
{    SortOrder expectedOrder = overrideSortOrderToSigned(type) ? SortOrder.SIGNED : sortOrder(type);    return fromParquetStatisticsInternal(createdBy, statistics, type, expectedOrder);}
0432cc8ae6de3c482a7bfc7e367505341a2a8ed74c4e10bd764013441b91f7c7
overrideSortOrderToSigned
private boolean overrideSortOrderToSigned(PrimitiveType type)
{                LogicalTypeAnnotation annotation = type.getLogicalTypeAnnotation();    return useSignedStringMinMax && PrimitiveTypeName.BINARY == type.getPrimitiveTypeName() && (annotation == null || STRING_TYPES.contains(annotation.getClass()));}
cb17ea9a19a809d7e2a81bbe3213f3e534b727a530bc5ded3c2a50f8edd65922
defaultSortOrder
private static SortOrder defaultSortOrder(PrimitiveTypeName primitive)
{    switch(primitive) {        case BOOLEAN:        case INT32:        case INT64:        case FLOAT:        case DOUBLE:            return SortOrder.SIGNED;        case BINARY:        case FIXED_LEN_BYTE_ARRAY:            return SortOrder.UNSIGNED;    }    return SortOrder.UNKNOWN;}
ae4d5dc2af12494b7870326a77399bafbd9bb50d003c0509ea68ac7ac735274e
sortOrder
private static SortOrder sortOrder(PrimitiveType primitive)
{    LogicalTypeAnnotation annotation = primitive.getLogicalTypeAnnotation();    if (annotation != null) {        return annotation.accept(new LogicalTypeAnnotation.LogicalTypeAnnotationVisitor<SortOrder>() {            @Override            public Optional<SortOrder> visit(LogicalTypeAnnotation.IntLogicalTypeAnnotation intLogicalType) {                return intLogicalType.isSigned() ? of(SortOrder.SIGNED) : of(SortOrder.UNSIGNED);            }            @Override            public Optional<SortOrder> visit(LogicalTypeAnnotation.IntervalLogicalTypeAnnotation intervalLogicalType) {                return of(SortOrder.UNKNOWN);            }            @Override            public Optional<SortOrder> visit(LogicalTypeAnnotation.DateLogicalTypeAnnotation dateLogicalType) {                return of(SortOrder.SIGNED);            }            @Override            public Optional<SortOrder> visit(LogicalTypeAnnotation.EnumLogicalTypeAnnotation enumLogicalType) {                return of(SortOrder.UNSIGNED);            }            @Override            public Optional<SortOrder> visit(LogicalTypeAnnotation.BsonLogicalTypeAnnotation bsonLogicalType) {                return of(SortOrder.UNSIGNED);            }            @Override            public Optional<SortOrder> visit(LogicalTypeAnnotation.JsonLogicalTypeAnnotation jsonLogicalType) {                return of(SortOrder.UNSIGNED);            }            @Override            public Optional<SortOrder> visit(LogicalTypeAnnotation.StringLogicalTypeAnnotation stringLogicalType) {                return of(SortOrder.UNSIGNED);            }            @Override            public Optional<SortOrder> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType) {                return of(SortOrder.UNKNOWN);            }            @Override            public Optional<SortOrder> visit(LogicalTypeAnnotation.MapKeyValueTypeAnnotation mapKeyValueLogicalType) {                return of(SortOrder.UNKNOWN);            }            @Override            public Optional<SortOrder> visit(LogicalTypeAnnotation.MapLogicalTypeAnnotation mapLogicalType) {                return of(SortOrder.UNKNOWN);            }            @Override            public Optional<SortOrder> visit(LogicalTypeAnnotation.ListLogicalTypeAnnotation listLogicalType) {                return of(SortOrder.UNKNOWN);            }            @Override            public Optional<SortOrder> visit(LogicalTypeAnnotation.TimeLogicalTypeAnnotation timeLogicalType) {                return of(SortOrder.SIGNED);            }            @Override            public Optional<SortOrder> visit(LogicalTypeAnnotation.TimestampLogicalTypeAnnotation timestampLogicalType) {                return of(SortOrder.SIGNED);            }        }).orElse(defaultSortOrder(primitive.getPrimitiveTypeName()));    }    return defaultSortOrder(primitive.getPrimitiveTypeName());}
888c2eba5b4a53bdaa9403e5e1c527464b2474305c2b2962307fb2a53cd687e1
visit
public Optional<SortOrder> visit(LogicalTypeAnnotation.IntLogicalTypeAnnotation intLogicalType)
{    return intLogicalType.isSigned() ? of(SortOrder.SIGNED) : of(SortOrder.UNSIGNED);}
29d2488c3adca7bfc063c25e67889d796aadb963d605cdd59345dbf05b176b76
visit
public Optional<SortOrder> visit(LogicalTypeAnnotation.IntervalLogicalTypeAnnotation intervalLogicalType)
{    return of(SortOrder.UNKNOWN);}
989e87da012ec5b45bb11849a0d2130a3646c39ebaced5bada7e491bbf201ccd
visit
public Optional<SortOrder> visit(LogicalTypeAnnotation.DateLogicalTypeAnnotation dateLogicalType)
{    return of(SortOrder.SIGNED);}
bbe60ca95dacf5af99cce76bf4d4a3cbb6b99138e3f077b5748102ca5241943a
visit
public Optional<SortOrder> visit(LogicalTypeAnnotation.EnumLogicalTypeAnnotation enumLogicalType)
{    return of(SortOrder.UNSIGNED);}
843e90bbaafcbabc6ecb3b09f2c7ef98212650d8dbcf977dac481f1a3f959f0c
visit
public Optional<SortOrder> visit(LogicalTypeAnnotation.BsonLogicalTypeAnnotation bsonLogicalType)
{    return of(SortOrder.UNSIGNED);}
0aff45e822b5026e33381e290820beeebc8f3c0f6d851173d9fab21065fdb04f
visit
public Optional<SortOrder> visit(LogicalTypeAnnotation.JsonLogicalTypeAnnotation jsonLogicalType)
{    return of(SortOrder.UNSIGNED);}
8b50ff1d099b359bf93ee88265c776921a15c73838db9e83177ba0393ec9c495
visit
public Optional<SortOrder> visit(LogicalTypeAnnotation.StringLogicalTypeAnnotation stringLogicalType)
{    return of(SortOrder.UNSIGNED);}
4191bac2e8db189e48216babc37f673d68cccfd3a976e378dc1755b2719c16b9
visit
public Optional<SortOrder> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType)
{    return of(SortOrder.UNKNOWN);}
496e2dd91dd4c5669758b6a8f6f91514ce5acffc374a682e3f904c7376096efc
visit
public Optional<SortOrder> visit(LogicalTypeAnnotation.MapKeyValueTypeAnnotation mapKeyValueLogicalType)
{    return of(SortOrder.UNKNOWN);}
7da1a098a40020f005ec57d2406196a57fc87a62456e1a727a614a706791acb3
visit
public Optional<SortOrder> visit(LogicalTypeAnnotation.MapLogicalTypeAnnotation mapLogicalType)
{    return of(SortOrder.UNKNOWN);}
737f0af265c8bbf6ab7effc7a17ff64fd77db868d56defa0a2b4bb0261a6189c
visit
public Optional<SortOrder> visit(LogicalTypeAnnotation.ListLogicalTypeAnnotation listLogicalType)
{    return of(SortOrder.UNKNOWN);}
4e51eb9cb5ff2341c51751eb5711f67e65cc9e0dbb5cad29f139d1be48fa27cd
visit
public Optional<SortOrder> visit(LogicalTypeAnnotation.TimeLogicalTypeAnnotation timeLogicalType)
{    return of(SortOrder.SIGNED);}
76b8a2da7c9960be22e7af362f53818c92a782b7209cbc316463b4c82f0d8c14
visit
public Optional<SortOrder> visit(LogicalTypeAnnotation.TimestampLogicalTypeAnnotation timestampLogicalType)
{    return of(SortOrder.SIGNED);}
2945175e619800f8a0a93707015248a87f3bdb5474d032bd215cc158ba3ac124
getPrimitive
public PrimitiveTypeName getPrimitive(Type type)
{    switch(type) {        case         BYTE_ARRAY:            return PrimitiveTypeName.BINARY;        case INT64:            return PrimitiveTypeName.INT64;        case INT32:            return PrimitiveTypeName.INT32;        case BOOLEAN:            return PrimitiveTypeName.BOOLEAN;        case FLOAT:            return PrimitiveTypeName.FLOAT;        case DOUBLE:            return PrimitiveTypeName.DOUBLE;        case INT96:            return PrimitiveTypeName.INT96;        case FIXED_LEN_BYTE_ARRAY:            return PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY;        default:            throw new RuntimeException("Unknown type " + type);    }}
b607986e114a926b2d1b4b73d23dfc8cf0e129e45396e6d199098dbd81e7e52d
getType
 Type getType(PrimitiveTypeName type)
{    switch(type) {        case INT64:            return Type.INT64;        case INT32:            return Type.INT32;        case BOOLEAN:            return Type.BOOLEAN;        case BINARY:            return Type.BYTE_ARRAY;        case FLOAT:            return Type.FLOAT;        case DOUBLE:            return Type.DOUBLE;        case INT96:            return Type.INT96;        case FIXED_LEN_BYTE_ARRAY:            return Type.FIXED_LEN_BYTE_ARRAY;        default:            throw new RuntimeException("Unknown primitive type " + type);    }}
cbbc5f8ed2fc2ab416c078e1aafa3672fcf1d5e5dd6037df73b20a3a8768d59f
getLogicalTypeAnnotation
 LogicalTypeAnnotation getLogicalTypeAnnotation(ConvertedType type, SchemaElement schemaElement)
{    switch(type) {        case UTF8:            return LogicalTypeAnnotation.stringType();        case MAP:            return LogicalTypeAnnotation.mapType();        case MAP_KEY_VALUE:            return LogicalTypeAnnotation.MapKeyValueTypeAnnotation.getInstance();        case LIST:            return LogicalTypeAnnotation.listType();        case ENUM:            return LogicalTypeAnnotation.enumType();        case DECIMAL:            int scale = (schemaElement == null ? 0 : schemaElement.scale);            int precision = (schemaElement == null ? 0 : schemaElement.precision);            return LogicalTypeAnnotation.decimalType(scale, precision);        case DATE:            return LogicalTypeAnnotation.dateType();        case TIME_MILLIS:            return LogicalTypeAnnotation.timeType(true, LogicalTypeAnnotation.TimeUnit.MILLIS);        case TIME_MICROS:            return LogicalTypeAnnotation.timeType(true, LogicalTypeAnnotation.TimeUnit.MICROS);        case TIMESTAMP_MILLIS:            return LogicalTypeAnnotation.timestampType(true, LogicalTypeAnnotation.TimeUnit.MILLIS);        case TIMESTAMP_MICROS:            return LogicalTypeAnnotation.timestampType(true, LogicalTypeAnnotation.TimeUnit.MICROS);        case INTERVAL:            return LogicalTypeAnnotation.IntervalLogicalTypeAnnotation.getInstance();        case INT_8:            return LogicalTypeAnnotation.intType(8, true);        case INT_16:            return LogicalTypeAnnotation.intType(16, true);        case INT_32:            return LogicalTypeAnnotation.intType(32, true);        case INT_64:            return LogicalTypeAnnotation.intType(64, true);        case UINT_8:            return LogicalTypeAnnotation.intType(8, false);        case UINT_16:            return LogicalTypeAnnotation.intType(16, false);        case UINT_32:            return LogicalTypeAnnotation.intType(32, false);        case UINT_64:            return LogicalTypeAnnotation.intType(64, false);        case JSON:            return LogicalTypeAnnotation.jsonType();        case BSON:            return LogicalTypeAnnotation.bsonType();        default:            throw new RuntimeException("Can't convert converted type to logical type, unknown converted type " + type);    }}
8d9dfb7a7c34e1990642e0a255d00315e756085f098ebbae6b554515c9f8f2eb
getLogicalTypeAnnotation
 LogicalTypeAnnotation getLogicalTypeAnnotation(LogicalType type)
{    switch(type.getSetField()) {        case MAP:            return LogicalTypeAnnotation.mapType();        case BSON:            return LogicalTypeAnnotation.bsonType();        case DATE:            return LogicalTypeAnnotation.dateType();        case ENUM:            return LogicalTypeAnnotation.enumType();        case JSON:            return LogicalTypeAnnotation.jsonType();        case LIST:            return LogicalTypeAnnotation.listType();        case TIME:            TimeType time = type.getTIME();            return LogicalTypeAnnotation.timeType(time.isAdjustedToUTC, convertTimeUnit(time.unit));        case STRING:            return LogicalTypeAnnotation.stringType();        case DECIMAL:            DecimalType decimal = type.getDECIMAL();            return LogicalTypeAnnotation.decimalType(decimal.scale, decimal.precision);        case INTEGER:            IntType integer = type.getINTEGER();            return LogicalTypeAnnotation.intType(integer.bitWidth, integer.isSigned);        case UNKNOWN:            return null;        case TIMESTAMP:            TimestampType timestamp = type.getTIMESTAMP();            return LogicalTypeAnnotation.timestampType(timestamp.isAdjustedToUTC, convertTimeUnit(timestamp.unit));        default:            throw new RuntimeException("Unknown logical type " + type);    }}
23578ae83abf643d6808e7e8a8b231d08d215bf62eaa38a09b1d9ce543c578dc
convertTimeUnit
private LogicalTypeAnnotation.TimeUnit convertTimeUnit(TimeUnit unit)
{    switch(unit.getSetField()) {        case MICROS:            return LogicalTypeAnnotation.TimeUnit.MICROS;        case MILLIS:            return LogicalTypeAnnotation.TimeUnit.MILLIS;        case NANOS:            return LogicalTypeAnnotation.TimeUnit.NANOS;        default:            throw new RuntimeException("Unknown time unit " + unit);    }}
f589f410cf9bb9dba270e57cca075542e21bfd47ecc4ceed2f93dde39fa5eee3
addKeyValue
private static void addKeyValue(FileMetaData fileMetaData, String key, String value)
{    KeyValue keyValue = new KeyValue(key);    keyValue.value = value;    fileMetaData.addToKey_value_metadata(keyValue);}
aa8d13e3137bae8727b21187bfa0fb5409736e686cc6420a75b7cc4dbaa123f1
range
public static MetadataFilter range(long startOffset, long endOffset)
{    return new RangeMetadataFilter(startOffset, endOffset);}
6cc1270786ca0c5ab85d09422c6c1929220f723faddfa8e536af717251b99425
offsets
public static MetadataFilter offsets(long... offsets)
{    Set<Long> set = new HashSet<Long>();    for (long offset : offsets) {        set.add(offset);    }    return new OffsetMetadataFilter(set);}
496a9caa86d65bb599f7d6b54f716ef4111f15e3d3bc2cb71ed49e63b383a26e
accept
 T accept(MetadataFilterVisitor<T, E> visitor) throws E
{    return visitor.visit(this);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "NO_FILTER";}
496a9caa86d65bb599f7d6b54f716ef4111f15e3d3bc2cb71ed49e63b383a26e
accept
 T accept(MetadataFilterVisitor<T, E> visitor) throws E
{    return visitor.visit(this);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "SKIP_ROW_GROUPS";}
496a9caa86d65bb599f7d6b54f716ef4111f15e3d3bc2cb71ed49e63b383a26e
accept
 T accept(MetadataFilterVisitor<T, E> visitor) throws E
{    return visitor.visit(this);}
2b9e8118bea07c36e16cf998db3875690bfa9ce5f0ad03b7dd1d4e0a169b06cd
contains
public boolean contains(long offset)
{    return offset >= this.startOffset && offset < this.endOffset;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "range(s:" + startOffset + ", e:" + endOffset + ")";}
2b9e8118bea07c36e16cf998db3875690bfa9ce5f0ad03b7dd1d4e0a169b06cd
contains
public boolean contains(long offset)
{    return offsets.contains(offset);}
496a9caa86d65bb599f7d6b54f716ef4111f15e3d3bc2cb71ed49e63b383a26e
accept
 T accept(MetadataFilterVisitor<T, E> visitor) throws E
{    return visitor.visit(this);}
4c000873d25e70e05d5a3e189eec8ce0b638ae71e42910819d9524cd8cebee2a
readParquetMetadata
public ParquetMetadata readParquetMetadata(InputStream from) throws IOException
{    return readParquetMetadata(from, NO_FILTER);}
87cf03117a47dfb2f2a49e2dbc3627ac8712b432a08cd5095461fd9150c726f3
filterFileMetaDataByMidpoint
 static FileMetaData filterFileMetaDataByMidpoint(FileMetaData metaData, RangeMetadataFilter filter)
{    List<RowGroup> rowGroups = metaData.getRow_groups();    List<RowGroup> newRowGroups = new ArrayList<RowGroup>();    for (RowGroup rowGroup : rowGroups) {        long totalSize = 0;        long startIndex = getOffset(rowGroup.getColumns().get(0));        for (ColumnChunk col : rowGroup.getColumns()) {            totalSize += col.getMeta_data().getTotal_compressed_size();        }        long midPoint = startIndex + totalSize / 2;        if (filter.contains(midPoint)) {            newRowGroups.add(rowGroup);        }    }    metaData.setRow_groups(newRowGroups);    return metaData;}
7b7f8c4b0b33964825bbbe05441e2a51e92aa9c3dea0f6110164ef191b8995fb
filterFileMetaDataByStart
 static FileMetaData filterFileMetaDataByStart(FileMetaData metaData, OffsetMetadataFilter filter)
{    List<RowGroup> rowGroups = metaData.getRow_groups();    List<RowGroup> newRowGroups = new ArrayList<RowGroup>();    for (RowGroup rowGroup : rowGroups) {        long startIndex = getOffset(rowGroup.getColumns().get(0));        if (filter.contains(startIndex)) {            newRowGroups.add(rowGroup);        }    }    metaData.setRow_groups(newRowGroups);    return metaData;}
f37cf671160af547c1fc1f26892ddf15c96c7b602538bb2ded7ade428d0dfe23
getOffset
 static long getOffset(RowGroup rowGroup)
{    return getOffset(rowGroup.getColumns().get(0));}
01851759c55cda5363ffc54c91761aaf824d0ec524b7a7c6aadda6469fa0a903
getOffset
 static long getOffset(ColumnChunk columnChunk)
{    ColumnMetaData md = columnChunk.getMeta_data();    long offset = md.getData_page_offset();    if (md.isSetDictionary_page_offset() && offset > md.getDictionary_page_offset()) {        offset = md.getDictionary_page_offset();    }    return offset;}
53e4509c33380059d6f4e5c80fa931f8765cc5b97ce9eb391ba23bf2b4252b9a
readParquetMetadata
public ParquetMetadata readParquetMetadata(final InputStream from, MetadataFilter filter) throws IOException
{    FileMetaData fileMetaData = filter.accept(new MetadataFilterVisitor<FileMetaData, IOException>() {        @Override        public FileMetaData visit(NoFilter filter) throws IOException {            return readFileMetaData(from);        }        @Override        public FileMetaData visit(SkipMetadataFilter filter) throws IOException {            return readFileMetaData(from, true);        }        @Override        public FileMetaData visit(OffsetMetadataFilter filter) throws IOException {            return filterFileMetaDataByStart(readFileMetaData(from), filter);        }        @Override        public FileMetaData visit(RangeMetadataFilter filter) throws IOException {            return filterFileMetaDataByMidpoint(readFileMetaData(from), filter);        }    });    LOG.debug("{}", fileMetaData);    ParquetMetadata parquetMetadata = fromParquetMetadata(fileMetaData);    if (LOG.isDebugEnabled())        LOG.debug(ParquetMetadata.toPrettyJSON(parquetMetadata));    return parquetMetadata;}
488db965fba1f15e503e05e602098ad8f3b35f2235e934b21dd73627683ed962
visit
public FileMetaData visit(NoFilter filter) throws IOException
{    return readFileMetaData(from);}
51254d77593052580f9b690b8523c99b8a28556ce282595adaf177f39be4fb36
visit
public FileMetaData visit(SkipMetadataFilter filter) throws IOException
{    return readFileMetaData(from, true);}
faf85ebf0c225cb471c4b4c3d14a63c2ed1da5e99d729ab7c65179902fa55c91
visit
public FileMetaData visit(OffsetMetadataFilter filter) throws IOException
{    return filterFileMetaDataByStart(readFileMetaData(from), filter);}
66b901a797b2e102c0efcf2b3001aa48b826b5df5092098d1c9ef28597dbfa95
visit
public FileMetaData visit(RangeMetadataFilter filter) throws IOException
{    return filterFileMetaDataByMidpoint(readFileMetaData(from), filter);}
3204ec3b0187f90421c97e7931e9e594f268466a6caba08d67806b8d9346f3ce
fromParquetMetadata
public ParquetMetadata fromParquetMetadata(FileMetaData parquetMetadata) throws IOException
{    MessageType messageType = fromParquetSchema(parquetMetadata.getSchema(), parquetMetadata.getColumn_orders());    List<BlockMetaData> blocks = new ArrayList<BlockMetaData>();    List<RowGroup> row_groups = parquetMetadata.getRow_groups();    if (row_groups != null) {        for (RowGroup rowGroup : row_groups) {            BlockMetaData blockMetaData = new BlockMetaData();            blockMetaData.setRowCount(rowGroup.getNum_rows());            blockMetaData.setTotalByteSize(rowGroup.getTotal_byte_size());            List<ColumnChunk> columns = rowGroup.getColumns();            String filePath = columns.get(0).getFile_path();            for (ColumnChunk columnChunk : columns) {                if ((filePath == null && columnChunk.getFile_path() != null) || (filePath != null && !filePath.equals(columnChunk.getFile_path()))) {                    throw new ParquetDecodingException("all column chunks of the same row group must be in the same file for now");                }                ColumnMetaData metaData = columnChunk.meta_data;                ColumnPath path = getPath(metaData);                ColumnChunkMetaData column = ColumnChunkMetaData.get(path, messageType.getType(path.toArray()).asPrimitiveType(), fromFormatCodec(metaData.codec), convertEncodingStats(metaData.getEncoding_stats()), fromFormatEncodings(metaData.encodings), fromParquetStatistics(parquetMetadata.getCreated_by(), metaData.statistics, messageType.getType(path.toArray()).asPrimitiveType()), metaData.data_page_offset, metaData.dictionary_page_offset, metaData.num_values, metaData.total_compressed_size, metaData.total_uncompressed_size);                column.setColumnIndexReference(toColumnIndexReference(columnChunk));                column.setOffsetIndexReference(toOffsetIndexReference(columnChunk));                                                                blockMetaData.addColumn(column);            }            blockMetaData.setPath(filePath);            blocks.add(blockMetaData);        }    }    Map<String, String> keyValueMetaData = new HashMap<String, String>();    List<KeyValue> key_value_metadata = parquetMetadata.getKey_value_metadata();    if (key_value_metadata != null) {        for (KeyValue keyValue : key_value_metadata) {            keyValueMetaData.put(keyValue.key, keyValue.value);        }    }    return new ParquetMetadata(new org.apache.parquet.hadoop.metadata.FileMetaData(messageType, keyValueMetaData, parquetMetadata.getCreated_by()), blocks);}
c662ef5388be971fbb0e7f69124d921381d2746820a5554fc7496489a1968985
toColumnIndexReference
private static IndexReference toColumnIndexReference(ColumnChunk columnChunk)
{    if (columnChunk.isSetColumn_index_offset() && columnChunk.isSetColumn_index_length()) {        return new IndexReference(columnChunk.getColumn_index_offset(), columnChunk.getColumn_index_length());    }    return null;}
1ff8253df522b6f424fa125f81a8897ab2f237b157e505f8ced9562b5904a4ea
toOffsetIndexReference
private static IndexReference toOffsetIndexReference(ColumnChunk columnChunk)
{    if (columnChunk.isSetOffset_index_offset() && columnChunk.isSetOffset_index_length()) {        return new IndexReference(columnChunk.getOffset_index_offset(), columnChunk.getOffset_index_length());    }    return null;}
688fe570fb1f95fa35b86f63fd941d9562c6341a7ed5f9868f08215ccaa12af0
getPath
private static ColumnPath getPath(ColumnMetaData metaData)
{    String[] path = metaData.path_in_schema.toArray(new String[metaData.path_in_schema.size()]);    return ColumnPath.get(path);}
13525e8e5d77034b2e29ca0e8694f82fee0e8371d22090ad5990264029b2c486
fromParquetSchema
 MessageType fromParquetSchema(List<SchemaElement> schema, List<ColumnOrder> columnOrders)
{    Iterator<SchemaElement> iterator = schema.iterator();    SchemaElement root = iterator.next();    Types.MessageTypeBuilder builder = Types.buildMessage();    if (root.isSetField_id()) {        builder.id(root.field_id);    }    buildChildren(builder, iterator, root.getNum_children(), columnOrders, 0);    return builder.named(root.name);}
8d6bba77b901495a8735b96a659c7acfacda0afe3a2aabd9046e903a2375bc8a
buildChildren
private void buildChildren(Types.GroupBuilder builder, Iterator<SchemaElement> schema, int childrenCount, List<ColumnOrder> columnOrders, int columnCount)
{    for (int i = 0; i < childrenCount; i++) {        SchemaElement schemaElement = schema.next();                Types.Builder childBuilder;        if (schemaElement.type != null) {            Types.PrimitiveBuilder primitiveBuilder = builder.primitive(getPrimitive(schemaElement.type), fromParquetRepetition(schemaElement.repetition_type));            if (schemaElement.isSetType_length()) {                primitiveBuilder.length(schemaElement.type_length);            }            if (schemaElement.isSetPrecision()) {                primitiveBuilder.precision(schemaElement.precision);            }            if (schemaElement.isSetScale()) {                primitiveBuilder.scale(schemaElement.scale);            }            if (columnOrders != null) {                org.apache.parquet.schema.ColumnOrder columnOrder = fromParquetColumnOrder(columnOrders.get(columnCount));                                if (columnOrder.getColumnOrderName() == ColumnOrderName.TYPE_DEFINED_ORDER && (schemaElement.type == Type.INT96 || schemaElement.converted_type == ConvertedType.INTERVAL)) {                    columnOrder = org.apache.parquet.schema.ColumnOrder.undefined();                }                primitiveBuilder.columnOrder(columnOrder);            }            childBuilder = primitiveBuilder;        } else {            childBuilder = builder.group(fromParquetRepetition(schemaElement.repetition_type));            buildChildren((Types.GroupBuilder) childBuilder, schema, schemaElement.num_children, columnOrders, columnCount);        }        if (schemaElement.isSetLogicalType()) {            childBuilder.as(getLogicalTypeAnnotation(schemaElement.logicalType));        }        if (schemaElement.isSetConverted_type()) {            OriginalType originalType = getLogicalTypeAnnotation(schemaElement.converted_type, schemaElement).toOriginalType();            OriginalType newOriginalType = (schemaElement.isSetLogicalType() && getLogicalTypeAnnotation(schemaElement.logicalType) != null) ? getLogicalTypeAnnotation(schemaElement.logicalType).toOriginalType() : null;            if (!originalType.equals(newOriginalType)) {                if (newOriginalType != null) {                    LOG.warn("Converted type and logical type metadata mismatch (convertedType: {}, logical type: {}). Using value in converted type.", schemaElement.converted_type, schemaElement.logicalType);                }                childBuilder.as(originalType);            }        }        if (schemaElement.isSetField_id()) {            childBuilder.id(schemaElement.field_id);        }        childBuilder.named(schemaElement.name);        ++columnCount;    }}
2420be7d78affc71e8a12d4613f030bed9a37cb5c91a75ff8695df59dd4179bd
toParquetRepetition
 FieldRepetitionType toParquetRepetition(Repetition repetition)
{    return FieldRepetitionType.valueOf(repetition.name());}
e889e7576e5a5212f2d61d1ca6ae1c0096b25fd594f684c55d3dea1056084eb5
fromParquetRepetition
 Repetition fromParquetRepetition(FieldRepetitionType repetition)
{    return Repetition.valueOf(repetition.name());}
13782de5258d5d7716af206a9b1ff8740adb9b5b89ea4b9fd5a5a150690d3dd0
fromParquetColumnOrder
private static org.apache.parquet.schema.ColumnOrder fromParquetColumnOrder(ColumnOrder columnOrder)
{    if (columnOrder.isSetTYPE_ORDER()) {        return org.apache.parquet.schema.ColumnOrder.typeDefined();    }        return org.apache.parquet.schema.ColumnOrder.undefined();}
8e8c3c58ba2f325fd5d571f589b1d01c77056d31b8b689333b98c759500f2d26
writeDataPageHeader
public void writeDataPageHeader(int uncompressedSize, int compressedSize, int valueCount, org.apache.parquet.column.Encoding rlEncoding, org.apache.parquet.column.Encoding dlEncoding, org.apache.parquet.column.Encoding valuesEncoding, OutputStream to) throws IOException
{    writePageHeader(newDataPageHeader(uncompressedSize, compressedSize, valueCount, rlEncoding, dlEncoding, valuesEncoding), to);}
9c04464af3437e52e74113a97afbfb046c3395f19ccd20b914069f6636e4110e
writeDataPageHeader
public void writeDataPageHeader(int uncompressedSize, int compressedSize, int valueCount, org.apache.parquet.column.statistics.Statistics statistics, org.apache.parquet.column.Encoding rlEncoding, org.apache.parquet.column.Encoding dlEncoding, org.apache.parquet.column.Encoding valuesEncoding, OutputStream to) throws IOException
{    writePageHeader(newDataPageHeader(uncompressedSize, compressedSize, valueCount, rlEncoding, dlEncoding, valuesEncoding), to);}
4620354544d122ade11d749caecaed4b39d0411cf0f84cd1187c4494ea4df5f5
newDataPageHeader
private PageHeader newDataPageHeader(int uncompressedSize, int compressedSize, int valueCount, org.apache.parquet.column.Encoding rlEncoding, org.apache.parquet.column.Encoding dlEncoding, org.apache.parquet.column.Encoding valuesEncoding)
{    PageHeader pageHeader = new PageHeader(PageType.DATA_PAGE, uncompressedSize, compressedSize);    pageHeader.setData_page_header(new DataPageHeader(valueCount, getEncoding(valuesEncoding), getEncoding(dlEncoding), getEncoding(rlEncoding)));    return pageHeader;}
56ea03923760933368e55614cc51b567e1124f0bd9a11cb894385659d1aae9bf
newDataPageHeader
private PageHeader newDataPageHeader(int uncompressedSize, int compressedSize, int valueCount, org.apache.parquet.column.Encoding rlEncoding, org.apache.parquet.column.Encoding dlEncoding, org.apache.parquet.column.Encoding valuesEncoding, int crc)
{    PageHeader pageHeader = new PageHeader(PageType.DATA_PAGE, uncompressedSize, compressedSize);    pageHeader.setCrc(crc);    pageHeader.setData_page_header(new DataPageHeader(valueCount, getEncoding(valuesEncoding), getEncoding(dlEncoding), getEncoding(rlEncoding)));    return pageHeader;}
7ec79b5988a16a5705129a6b0f1d6bfe73de914d367f5d2ae4e4e32e6f4bf2e3
writeDataPageV2Header
public void writeDataPageV2Header(int uncompressedSize, int compressedSize, int valueCount, int nullCount, int rowCount, org.apache.parquet.column.statistics.Statistics statistics, org.apache.parquet.column.Encoding dataEncoding, int rlByteLength, int dlByteLength, OutputStream to) throws IOException
{    writePageHeader(newDataPageV2Header(uncompressedSize, compressedSize, valueCount, nullCount, rowCount, dataEncoding, rlByteLength, dlByteLength), to);}
2645840a4f3cf58c1c824791727c0854defe3abec7a4fe0b527fbd11da68c9b9
writeDataPageV1Header
public void writeDataPageV1Header(int uncompressedSize, int compressedSize, int valueCount, org.apache.parquet.column.Encoding rlEncoding, org.apache.parquet.column.Encoding dlEncoding, org.apache.parquet.column.Encoding valuesEncoding, OutputStream to) throws IOException
{    writePageHeader(newDataPageHeader(uncompressedSize, compressedSize, valueCount, rlEncoding, dlEncoding, valuesEncoding), to);}
5b54de75bb9140162f9e2b2195482eba49ff816fe1b089fa8ef25a2639656e45
writeDataPageV1Header
public void writeDataPageV1Header(int uncompressedSize, int compressedSize, int valueCount, org.apache.parquet.column.Encoding rlEncoding, org.apache.parquet.column.Encoding dlEncoding, org.apache.parquet.column.Encoding valuesEncoding, int crc, OutputStream to) throws IOException
{    writePageHeader(newDataPageHeader(uncompressedSize, compressedSize, valueCount, rlEncoding, dlEncoding, valuesEncoding, crc), to);}
bcf5b0da19ed8a0ac8ac62aed8e8c6356d7d6b36d629120910ed8376d0ef4163
writeDataPageV2Header
public void writeDataPageV2Header(int uncompressedSize, int compressedSize, int valueCount, int nullCount, int rowCount, org.apache.parquet.column.Encoding dataEncoding, int rlByteLength, int dlByteLength, OutputStream to) throws IOException
{    writePageHeader(newDataPageV2Header(uncompressedSize, compressedSize, valueCount, nullCount, rowCount, dataEncoding, rlByteLength, dlByteLength), to);}
b6479fbe6727be44d9a61ac6a3101c5a9b321595a4878247dd7d35fc47032e4f
newDataPageV2Header
private PageHeader newDataPageV2Header(int uncompressedSize, int compressedSize, int valueCount, int nullCount, int rowCount, org.apache.parquet.column.Encoding dataEncoding, int rlByteLength, int dlByteLength)
{        DataPageHeaderV2 dataPageHeaderV2 = new DataPageHeaderV2(valueCount, nullCount, rowCount, getEncoding(dataEncoding), dlByteLength, rlByteLength);    PageHeader pageHeader = new PageHeader(PageType.DATA_PAGE_V2, uncompressedSize, compressedSize);    pageHeader.setData_page_header_v2(dataPageHeaderV2);    return pageHeader;}
6807c8206080f26cb11c3bf4ac5f3c7a5dc866b9c1466eb3316b0c72ff0917cc
writeDictionaryPageHeader
public void writeDictionaryPageHeader(int uncompressedSize, int compressedSize, int valueCount, org.apache.parquet.column.Encoding valuesEncoding, OutputStream to) throws IOException
{    PageHeader pageHeader = new PageHeader(PageType.DICTIONARY_PAGE, uncompressedSize, compressedSize);    pageHeader.setDictionary_page_header(new DictionaryPageHeader(valueCount, getEncoding(valuesEncoding)));    writePageHeader(pageHeader, to);}
eed9fd3453f24d71142b1137535901ffbcdddea23fd9ac7dd5ba03246043ced3
writeDictionaryPageHeader
public void writeDictionaryPageHeader(int uncompressedSize, int compressedSize, int valueCount, org.apache.parquet.column.Encoding valuesEncoding, int crc, OutputStream to) throws IOException
{    PageHeader pageHeader = new PageHeader(PageType.DICTIONARY_PAGE, uncompressedSize, compressedSize);    pageHeader.setCrc(crc);    pageHeader.setDictionary_page_header(new DictionaryPageHeader(valueCount, getEncoding(valuesEncoding)));    writePageHeader(pageHeader, to);}
a706fbafaee83ae94aa1306db1dcfdcce348e46037e7344252d55663d6966a30
toParquetBoundaryOrder
private static BoundaryOrder toParquetBoundaryOrder(org.apache.parquet.internal.column.columnindex.BoundaryOrder boundaryOrder)
{    switch(boundaryOrder) {        case ASCENDING:            return BoundaryOrder.ASCENDING;        case DESCENDING:            return BoundaryOrder.DESCENDING;        case UNORDERED:            return BoundaryOrder.UNORDERED;        default:            throw new IllegalArgumentException("Unsupported boundary order: " + boundaryOrder);    }}
0e7f4035f75eb69d25b4bfd26989bf7ba26f581a667ab416512585ac36082f4c
fromParquetBoundaryOrder
private static org.apache.parquet.internal.column.columnindex.BoundaryOrder fromParquetBoundaryOrder(BoundaryOrder boundaryOrder)
{    switch(boundaryOrder) {        case ASCENDING:            return org.apache.parquet.internal.column.columnindex.BoundaryOrder.ASCENDING;        case DESCENDING:            return org.apache.parquet.internal.column.columnindex.BoundaryOrder.DESCENDING;        case UNORDERED:            return org.apache.parquet.internal.column.columnindex.BoundaryOrder.UNORDERED;        default:            throw new IllegalArgumentException("Unsupported boundary order: " + boundaryOrder);    }}
ddc657f430c0ba14fad3a12f04c3544386bb52a65ccdc508a959c5037db4ab32
toParquetColumnIndex
public static ColumnIndex toParquetColumnIndex(PrimitiveType type, org.apache.parquet.internal.column.columnindex.ColumnIndex columnIndex)
{    if (!isMinMaxStatsSupported(type) || columnIndex == null) {        return null;    }    ColumnIndex parquetColumnIndex = new ColumnIndex(columnIndex.getNullPages(), columnIndex.getMinValues(), columnIndex.getMaxValues(), toParquetBoundaryOrder(columnIndex.getBoundaryOrder()));    parquetColumnIndex.setNull_counts(columnIndex.getNullCounts());    return parquetColumnIndex;}
9c31a1d6c53d285b802e668c621745265283871d9297200d2f63315d1f4dcec2
fromParquetColumnIndex
public static org.apache.parquet.internal.column.columnindex.ColumnIndex fromParquetColumnIndex(PrimitiveType type, ColumnIndex parquetColumnIndex)
{    if (!isMinMaxStatsSupported(type)) {        return null;    }    return ColumnIndexBuilder.build(type, fromParquetBoundaryOrder(parquetColumnIndex.getBoundary_order()), parquetColumnIndex.getNull_pages(), parquetColumnIndex.getNull_counts(), parquetColumnIndex.getMin_values(), parquetColumnIndex.getMax_values());}
4880d9722b6fd9656b38c3779131e2652f1f957bf9024eb1a74a697dfb636811
toParquetOffsetIndex
public static OffsetIndex toParquetOffsetIndex(org.apache.parquet.internal.column.columnindex.OffsetIndex offsetIndex)
{    List<PageLocation> pageLocations = new ArrayList<>(offsetIndex.getPageCount());    for (int i = 0, n = offsetIndex.getPageCount(); i < n; ++i) {        pageLocations.add(new PageLocation(offsetIndex.getOffset(i), offsetIndex.getCompressedPageSize(i), offsetIndex.getFirstRowIndex(i)));    }    return new OffsetIndex(pageLocations);}
9612aa8cf8834a65499782de557006a8584f079ab4a7fbeaa98d00d46521d6a5
fromParquetOffsetIndex
public static org.apache.parquet.internal.column.columnindex.OffsetIndex fromParquetOffsetIndex(OffsetIndex parquetOffsetIndex)
{    OffsetIndexBuilder builder = OffsetIndexBuilder.getBuilder();    for (PageLocation pageLocation : parquetOffsetIndex.getPage_locations()) {        builder.add(pageLocation.getOffset(), pageLocation.getCompressed_page_size(), pageLocation.getFirst_row_index());    }    return builder.build();}
2c488e3323e3800f38581935a7dec8a885588cde7bd730f8163641c1634350ba
init
public ReadSupport.ReadContext init(InitContext context)
{    return delegate.init(context);}
b1a222a8623a5da4638ce0058f1753f12243cd40ef5f472368654aa626f5ac88
prepareForRead
public RecordMaterializer<T> prepareForRead(Configuration configuration, Map<String, String> keyValueMetaData, MessageType fileSchema, ReadSupport.ReadContext readContext)
{    return delegate.prepareForRead(configuration, keyValueMetaData, fileSchema, readContext);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return this.getClass().getName() + "(" + delegate.toString() + ")";}
a6de8e509f219d3b0c7705a375d0163fc3e084498433cd919f13566eca42285b
init
public WriteSupport.WriteContext init(Configuration configuration)
{    return delegate.init(configuration);}
da9aef78cf181856102b820ffa7d5248e8581747b3f0670a7b049c4649b962ef
prepareForWrite
public void prepareForWrite(RecordConsumer recordConsumer)
{    delegate.prepareForWrite(recordConsumer);}
e1dbc5a450a06f22ce2d7d2253403253153e3053cbf43f22851c97af786390af
write
public void write(T record)
{    delegate.write(record);}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return delegate.getName();}
5a44de2b3c98ea3634dcb102f87f6cc1a757f3fdaccf37f9363a12fb58f69c90
finalizeWrite
public WriteSupport.FinalizedWriteContext finalizeWrite()
{    return delegate.finalizeWrite();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return getClass().getName() + "(" + delegate.toString() + ")";}
6f5bc302a277e2738c73ee820e443d5c6392ed76afe6ae371e2f10f9f70910b8
getMergedKeyValueMetaData
public Map<String, String> getMergedKeyValueMetaData()
{    if (mergedKeyValueMetadata == null) {        Map<String, String> mergedKeyValues = new HashMap<String, String>();        for (Entry<String, Set<String>> entry : keyValueMetadata.entrySet()) {            if (entry.getValue().size() > 1) {                throw new RuntimeException("could not merge metadata: key " + entry.getKey() + " has conflicting values: " + entry.getValue());            }            mergedKeyValues.put(entry.getKey(), entry.getValue().iterator().next());        }        mergedKeyValueMetadata = mergedKeyValues;    }    return mergedKeyValueMetadata;}
4ab32fd1c0fc8b7e0975a577f547cc7a82d509b4844a391bcce9e94e9bd47854
getConfiguration
public Configuration getConfiguration()
{    return configuration;}
00c8ef2a300380babea0ef8ea093265a86fd5d3ca61a850c0ebe03aa6bf872f8
getFileSchema
public MessageType getFileSchema()
{    return fileSchema;}
fcf3ec3596fbb40e6977f0f2925adca477b251bbcd38bfebb0ea91003cf2135b
getKeyValueMetadata
public Map<String, Set<String>> getKeyValueMetadata()
{    return keyValueMetadata;}
f061ab943e59b071454a6d39c183b0b1f48b49f353eaa355ef0bd32ec22bafc6
getSchemaForRead
public static MessageType getSchemaForRead(MessageType fileMessageType, String partialReadSchemaString)
{    if (partialReadSchemaString == null)        return fileMessageType;    MessageType requestedMessageType = MessageTypeParser.parseMessageType(partialReadSchemaString);    return getSchemaForRead(fileMessageType, requestedMessageType);}
c5e6f198a5eaa12af9d5e6992d5a3cb1d70aa589e9509e566b741f6cddcfdaf1
getSchemaForRead
public static MessageType getSchemaForRead(MessageType fileMessageType, MessageType projectedMessageType)
{    fileMessageType.checkContains(projectedMessageType);    return projectedMessageType;}
9f05e23006c5ef7acb499b683c83254f7d016dadfbda9d65c3f1212d59959596
init
public ReadContext init(Configuration configuration, Map<String, String> keyValueMetaData, MessageType fileSchema)
{    throw new UnsupportedOperationException("Override init(InitContext)");}
179fb3d7a903b204c2b4bf2b8050f64585c9b7e332f5069356f97fbb27f885e3
init
public ReadContext init(InitContext context)
{    return init(context.getConfiguration(), context.getMergedKeyValueMetaData(), context.getFileSchema());}
e1e0c3cb304597743a3ef9c8ae953b1d73e1762c1f5d450bc08f482310d354c6
getRequestedSchema
public MessageType getRequestedSchema()
{    return requestedSchema;}
0c68962600768aba33521cb8c66e62c5f54e8498c3696d5c30433be58a17cc7f
getReadSupportMetadata
public Map<String, String> getReadSupportMetadata()
{    return readSupportMetadata;}
8f20f33637bcf9d39a2a75cabdc1285e8da4037865fa2ea3eb9e9ca74be7a311
getSchema
public MessageType getSchema()
{    return schema;}
5e4368ce4ad1dba604fd6c8f284f16742f8fb26e636099a0fc2e3ae2ecdab35b
getExtraMetaData
public Map<String, String> getExtraMetaData()
{    return extraMetaData;}
5e4368ce4ad1dba604fd6c8f284f16742f8fb26e636099a0fc2e3ae2ecdab35b
getExtraMetaData
public Map<String, String> getExtraMetaData()
{    return extraMetaData;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return null;}
d36408c1f7cebff81836d8b1de9f1c478fcf62b3cbd961963b51a997a6d0bc27
finalizeWrite
public FinalizedWriteContext finalizeWrite()
{    return new FinalizedWriteContext(new HashMap<String, String>());}
11360bb487dfe81e5dee46195505a2df4f7942dfcffdbce93225471e730f2341
cleanDirectBuffer
public static void cleanDirectBuffer(ByteBuffer buf)
{    if (cleanMethod != null) {        try {            cleanMethod.invoke(cleanerMethod.invoke(buf));        } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException | SecurityException e) {            logger.warn("Error while cleaning up the DirectBuffer", e);        }    } else if (invokeCleanerMethod != null) {        try {            invokeCleanerMethod.invoke(unsafe, buf);        } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException | SecurityException e) {            logger.warn("Error while cleaning up the DirectBuffer", e);        }    }}
e67e304b7b61b7a72d60d08e83fef3b0dd2f1e1aa95a5789ec3344239577cfa9
from
public static CodecConfig from(JobConf jobConf)
{    return new MapredCodecConfig(jobConf);}
d8a9dff22a84ff5fbbaa9f018bfa2e80b086cca01e722ef02603056618459a06
from
public static CodecConfig from(TaskAttemptContext context)
{    return new MapreduceCodecConfig(context);}
458e8f7336f9837d31242e97de35a594fe7c00096894fd1e122bdb447bdd6a19
isParquetCompressionSet
public static boolean isParquetCompressionSet(Configuration conf)
{    return conf.get(ParquetOutputFormat.COMPRESSION) != null;}
13bf7416c0b2397dc4b4ff4871bb34fe03576c0ff3d6b04004db2c4fb05c27cf
getParquetCompressionCodec
public static CompressionCodecName getParquetCompressionCodec(Configuration configuration)
{    return CompressionCodecName.fromConf(configuration.get(ParquetOutputFormat.COMPRESSION, UNCOMPRESSED.name()));}
97315572e15d9bef04873ede716a96cee64f8c288ea74350948b3adaa0166ea6
getCodec
public CompressionCodecName getCodec()
{    CompressionCodecName codec;    Configuration configuration = getConfiguration();    if (isParquetCompressionSet(configuration)) {                codec = getParquetCompressionCodec(configuration);    } else if (isHadoopCompressionSet()) {                codec = getHadoopCompressionCodec();    } else {        LOG.info("Compression set to false");        codec = CompressionCodecName.UNCOMPRESSED;    }    LOG.info("Compression: {}", codec.name());    return codec;}
d275dff1367165141d413531f71b8b7d6a8c04f1312183a83ac819e25347028a
getHadoopCompressionCodec
private CompressionCodecName getHadoopCompressionCodec()
{    CompressionCodecName codec;    try {                Class<?> codecClass = getHadoopOutputCompressorClass(CompressionCodecName.UNCOMPRESSED.getHadoopCompressionCodecClass());        LOG.info("Compression set through hadoop codec: {}", codecClass.getName());        codec = CompressionCodecName.fromCompressionCodec(codecClass);    } catch (CompressionCodecNotSupportedException e) {        LOG.warn("codec defined in hadoop config is not supported by parquet [{}] and will use UNCOMPRESSED", e.getCodecClass().getName(), e);        codec = CompressionCodecName.UNCOMPRESSED;    } catch (IllegalArgumentException e) {        LOG.warn("codec class not found: {}", e.getMessage(), e);        codec = CompressionCodecName.UNCOMPRESSED;    }    return codec;}
3c99a8df314875a90430d01012fd1742018208935dfb0bc222973aa8e6a2a4e4
isHadoopCompressionSet
public boolean isHadoopCompressionSet()
{    return FileOutputFormat.getCompressOutput(context);}
b3fce64f5d286d5a2a19d48382e3f188d77217b0e777983caa824bfdf0c06445
getHadoopOutputCompressorClass
public Class getHadoopOutputCompressorClass(Class defaultCodec)
{    return FileOutputFormat.getOutputCompressorClass(context, defaultCodec);}
4ab32fd1c0fc8b7e0975a577f547cc7a82d509b4844a391bcce9e94e9bd47854
getConfiguration
public Configuration getConfiguration()
{    return ContextUtil.getConfiguration(context);}
3c99a8df314875a90430d01012fd1742018208935dfb0bc222973aa8e6a2a4e4
isHadoopCompressionSet
public boolean isHadoopCompressionSet()
{    return org.apache.hadoop.mapred.FileOutputFormat.getCompressOutput(conf);}
b3fce64f5d286d5a2a19d48382e3f188d77217b0e777983caa824bfdf0c06445
getHadoopOutputCompressorClass
public Class getHadoopOutputCompressorClass(Class defaultCodec)
{    return org.apache.hadoop.mapred.FileOutputFormat.getOutputCompressorClass(conf, defaultCodec);}
4ab32fd1c0fc8b7e0975a577f547cc7a82d509b4844a391bcce9e94e9bd47854
getConfiguration
public Configuration getConfiguration()
{    return conf;}
6426ce3b66c4d2446558d8b5b93fe8a019e350f1ed5c2b61732f1efce14f0e67
write
public void write(byte[] b, int off, int len) throws IOException
{        if (compressor.finished()) {        throw new IOException("write beyond end of stream");    }    if ((off | len | (off + len) | (b.length - (off + len))) < 0) {        throw new IndexOutOfBoundsException();    } else if (len == 0) {        return;    }    compressor.setInput(b, off, len);}
56e08d87e6bd0be2a60f9b2de3195d58bc9d56a2637f6fed6210d21e832632ea
read
public int read(byte[] b, int off, int len) throws IOException
{    if (!inputHandled) {                while (true) {            int compressedBytes = getCompressedData();            if (compressedBytes == -1)                break;            decompressor.setInput(buffer, 0, compressedBytes);        }        inputHandled = true;    }    int decompressedBytes = decompressor.decompress(b, off, len);    if (decompressor.finished()) {        decompressor.reset();    }    return decompressedBytes;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
30e5ef1846f5e2e3edc77fc2c01d8f4ca378686c3ed4589a4c9382a24d10ec94
createCompressor
public Compressor createCompressor()
{    return new SnappyCompressor();}
6da6f78f6c8fa4d0383c90ddd1d722fd6f7d7a65994d59bf873dfe62b15ab6c3
createDecompressor
public Decompressor createDecompressor()
{    return new SnappyDecompressor();}
9b907fbbecc41603a72dc5a0ee99920d6f4bf761771caa5c1be94eb9e8ee0d69
createInputStream
public CompressionInputStream createInputStream(InputStream stream) throws IOException
{    return createInputStream(stream, createDecompressor());}
eb2b51bb63f5fe0de8f3a60409b3b2ea10e8ced68bd532de43d94076e3c7f505
createInputStream
public CompressionInputStream createInputStream(InputStream stream, Decompressor decompressor) throws IOException
{    return new NonBlockedDecompressorStream(stream, decompressor, conf.getInt(BUFFER_SIZE_CONFIG, 4 * 1024));}
2717f3dbf716fbe454ae698b0e67feb39de17cf3245ae92237f203085d0fbae9
createOutputStream
public CompressionOutputStream createOutputStream(OutputStream stream) throws IOException
{    return createOutputStream(stream, createCompressor());}
0ce4bc9d801dc13882cd655b319a7d44ac0cfb735db5beb3b13cc563c594e2fb
createOutputStream
public CompressionOutputStream createOutputStream(OutputStream stream, Compressor compressor) throws IOException
{    return new NonBlockedCompressorStream(stream, compressor, conf.getInt(BUFFER_SIZE_CONFIG, 4 * 1024));}
7225d387854e4f973607c556317b6b83696921511e892cddd558932d674835c2
getCompressorType
public Class<? extends Compressor> getCompressorType()
{    return SnappyCompressor.class;}
ca6cf38451fa8ed0b3a749162136ad10bf9e12f30846bf571e3585bd6015e361
getDecompressorType
public Class<? extends Decompressor> getDecompressorType()
{    return SnappyDecompressor.class;}
928e4143ec2863620b8f12c83991e348a5831056522e2f088d518db2d96cc780
getDefaultExtension
public String getDefaultExtension()
{    return ".snappy";}
a1ecc0807df62970a679fc0ef77222691cc23323410938029136bce7990c5fd7
compress
public synchronized int compress(byte[] buffer, int off, int len) throws IOException
{    SnappyUtil.validateBuffer(buffer, off, len);    if (needsInput()) {                return 0;    }    if (!outputBuffer.hasRemaining()) {                int maxOutputSize = Snappy.maxCompressedLength(inputBuffer.position());        if (maxOutputSize > outputBuffer.capacity()) {            ByteBuffer oldBuffer = outputBuffer;            outputBuffer = ByteBuffer.allocateDirect(maxOutputSize);            CleanUtil.cleanDirectBuffer(oldBuffer);        }                outputBuffer.clear();        inputBuffer.limit(inputBuffer.position());        inputBuffer.position(0);        int size = Snappy.compress(inputBuffer, outputBuffer);        outputBuffer.limit(size);        inputBuffer.limit(0);        inputBuffer.rewind();    }        int numBytes = Math.min(len, outputBuffer.remaining());    outputBuffer.get(buffer, off, numBytes);    bytesWritten += numBytes;    return numBytes;}
736b28b5596c3ea1c0dedcec46cacabe85eedde5bb2b9f9f6f5249dca17a4846
setInput
public synchronized void setInput(byte[] buffer, int off, int len)
{    SnappyUtil.validateBuffer(buffer, off, len);    Preconditions.checkArgument(!outputBuffer.hasRemaining(), "Output buffer should be empty. Caller must call compress()");    if (inputBuffer.capacity() - inputBuffer.position() < len) {        ByteBuffer tmp = ByteBuffer.allocateDirect(inputBuffer.position() + len);        inputBuffer.rewind();        tmp.put(inputBuffer);        ByteBuffer oldBuffer = inputBuffer;        inputBuffer = tmp;        CleanUtil.cleanDirectBuffer(oldBuffer);    } else {        inputBuffer.limit(inputBuffer.position() + len);    }        inputBuffer.put(buffer, off, len);    bytesRead += len;}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    CleanUtil.cleanDirectBuffer(inputBuffer);    CleanUtil.cleanDirectBuffer(outputBuffer);}
90565eaa118bba86c796178b1f912ef49c4a45ec3f9ffb8606f215f108e67605
finish
public synchronized void finish()
{    finishCalled = true;}
b4c2f02ef25119dfb7a207b88e173fe79ed5d86fc07e583d97236f6f2aeb484c
finished
public synchronized boolean finished()
{    return finishCalled && inputBuffer.position() == 0 && !outputBuffer.hasRemaining();}
4093b85f3fcdd818588d4894695e9460d16537cb40cc04574306e779925cd8d7
getBytesRead
public long getBytesRead()
{    return bytesRead;}
35646fb62d020261093cd4775ecec97a769a67c0bc69a5423891f5f3b1a9b89a
getBytesWritten
public long getBytesWritten()
{    return bytesWritten;}
76ff49c4094efd7ab0c3bcebcce960c3ecb5a5b528db1ddd1b9e0422d2db922c
needsInput
public synchronized boolean needsInput()
{    return !finishCalled;}
3fe24c9479a16b58e908101d5b938fc79d2975d46d7bf9d632d7640902c75537
reinit
public void reinit(Configuration c)
{    reset();}
82d93c01a4aa8b564ec62dfb621083598a6a6b25ac4a6655d6e3db9476e48cd1
reset
public synchronized void reset()
{    finishCalled = false;    bytesRead = bytesWritten = 0;    inputBuffer.rewind();    outputBuffer.rewind();    inputBuffer.limit(0);    outputBuffer.limit(0);}
1c99aca461d4b6ce8c64102f419ea4f2617adde07e103b3ebe7e20e06b8f8102
setDictionary
public void setDictionary(byte[] dictionary, int off, int len)
{}
0751ec93685cb58da58be09244a4c6ecc3e033b44a930f45eb20b163a60d4c67
decompress
public synchronized int decompress(byte[] buffer, int off, int len) throws IOException
{    SnappyUtil.validateBuffer(buffer, off, len);    if (inputBuffer.position() == 0 && !outputBuffer.hasRemaining()) {        return 0;    }    if (!outputBuffer.hasRemaining()) {        inputBuffer.rewind();        Preconditions.checkArgument(inputBuffer.position() == 0, "Invalid position of 0.");        Preconditions.checkArgument(outputBuffer.position() == 0, "Invalid position of 0.");                int decompressedSize = Snappy.uncompressedLength(inputBuffer);        if (decompressedSize > outputBuffer.capacity()) {            ByteBuffer oldBuffer = outputBuffer;            outputBuffer = ByteBuffer.allocateDirect(decompressedSize);            CleanUtil.cleanDirectBuffer(oldBuffer);        }                outputBuffer.clear();        int size = Snappy.uncompress(inputBuffer, outputBuffer);        outputBuffer.limit(size);                inputBuffer.clear();        inputBuffer.limit(0);        finished = true;    }        int numBytes = Math.min(len, outputBuffer.remaining());    outputBuffer.get(buffer, off, numBytes);    return numBytes;}
736b28b5596c3ea1c0dedcec46cacabe85eedde5bb2b9f9f6f5249dca17a4846
setInput
public synchronized void setInput(byte[] buffer, int off, int len)
{    SnappyUtil.validateBuffer(buffer, off, len);    if (inputBuffer.capacity() - inputBuffer.position() < len) {        final ByteBuffer newBuffer = ByteBuffer.allocateDirect(inputBuffer.position() + len);        inputBuffer.rewind();        newBuffer.put(inputBuffer);        final ByteBuffer oldBuffer = inputBuffer;        inputBuffer = newBuffer;        CleanUtil.cleanDirectBuffer(oldBuffer);    } else {        inputBuffer.limit(inputBuffer.position() + len);    }    inputBuffer.put(buffer, off, len);}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    CleanUtil.cleanDirectBuffer(inputBuffer);    CleanUtil.cleanDirectBuffer(outputBuffer);}
b4c2f02ef25119dfb7a207b88e173fe79ed5d86fc07e583d97236f6f2aeb484c
finished
public synchronized boolean finished()
{    return finished && !outputBuffer.hasRemaining();}
038c06db664edb7b7b12f68d560eee78c5731a90ddd4e6e85c5d57e1fa42aa99
getRemaining
public int getRemaining()
{    return 0;}
76ff49c4094efd7ab0c3bcebcce960c3ecb5a5b528db1ddd1b9e0422d2db922c
needsInput
public synchronized boolean needsInput()
{    return !inputBuffer.hasRemaining() && !outputBuffer.hasRemaining();}
82d93c01a4aa8b564ec62dfb621083598a6a6b25ac4a6655d6e3db9476e48cd1
reset
public synchronized void reset()
{    finished = false;    inputBuffer.rewind();    outputBuffer.rewind();    inputBuffer.limit(0);    outputBuffer.limit(0);}
127e1b9eecc74084519e8569e36c3f27a8efcd61c475d34bf43fe7deb545dd80
needsDictionary
public boolean needsDictionary()
{    return false;}
0be1f7f594098f86ce336f3623b5e502c8e73d4ad7775572df839a85f92ddba3
setDictionary
public void setDictionary(byte[] b, int off, int len)
{}
359f1762bc72e92aa24cedbd198216c0af3c6c2b47c19bd9c8c07ea65705b8c3
validateBuffer
public static void validateBuffer(byte[] buffer, int off, int len)
{    Preconditions.checkNotNull(buffer, "buffer");    Preconditions.checkArgument(off >= 0 && len >= 0 && off <= buffer.length - len, "Invalid buffer offset or length: buffer.length=%s off=%s len=%s", buffer.length, off, len);}
d94b48cca6ef35c1c5516efcea74a8281d65409de935c18bf55e22055bd8710e
createDirectCodecFactory
public static CodecFactory createDirectCodecFactory(Configuration config, ByteBufferAllocator allocator, int pageSize)
{    return new DirectCodecFactory(config, allocator, pageSize);}
180217056b3829e9d3663d5333fdb6dc882164bcd64331030939ccfdd10fed32
decompress
public BytesInput decompress(BytesInput bytes, int uncompressedSize) throws IOException
{    final BytesInput decompressed;    if (codec != null) {        decompressor.reset();        InputStream is = codec.createInputStream(bytes.toInputStream(), decompressor);        decompressed = BytesInput.from(is, uncompressedSize);    } else {        decompressed = bytes;    }    return decompressed;}
5e23b7777d32f170fcffe2d8f3a7165aa3acc56dfb826cfc2f76bc65084982ae
decompress
public void decompress(ByteBuffer input, int compressedSize, ByteBuffer output, int uncompressedSize) throws IOException
{    ByteBuffer decompressed = decompress(BytesInput.from(input), uncompressedSize).toByteBuffer();    output.put(decompressed);}
841fe860486f1f0b6486b341715377c24ec761b4df1c0e8649a9679daecc27a4
release
public void release()
{    if (decompressor != null) {        CodecPool.returnDecompressor(decompressor);    }}
bceca01b13bfdb132ee51e7c433cd1e0ce5aa3d202027517734912a8c09aae16
compress
public BytesInput compress(BytesInput bytes) throws IOException
{    final BytesInput compressedBytes;    if (codec == null) {        compressedBytes = bytes;    } else {        compressedOutBuffer.reset();        if (compressor != null) {                        compressor.reset();        }        CompressionOutputStream cos = codec.createOutputStream(compressedOutBuffer, compressor);        bytes.writeAllTo(cos);        cos.finish();        cos.close();        compressedBytes = BytesInput.from(compressedOutBuffer);    }    return compressedBytes;}
841fe860486f1f0b6486b341715377c24ec761b4df1c0e8649a9679daecc27a4
release
public void release()
{    if (compressor != null) {        CodecPool.returnCompressor(compressor);    }}
bf484a5178ea60af7c97607f7c207960c498408f9df4220c87235c1fccc7e7fc
getCodecName
public CompressionCodecName getCodecName()
{    return codecName;}
05d3c40e5c2a4aa8f94aa119804621c6226741bd44912f08071a7cc5e6570e09
getCompressor
public BytesCompressor getCompressor(CompressionCodecName codecName)
{    BytesCompressor comp = compressors.get(codecName);    if (comp == null) {        comp = createCompressor(codecName);        compressors.put(codecName, comp);    }    return comp;}
a285d3355efaaceacba07abb256dc420c33d09895ffcb782b2c3622a48caf626
getDecompressor
public BytesDecompressor getDecompressor(CompressionCodecName codecName)
{    BytesDecompressor decomp = decompressors.get(codecName);    if (decomp == null) {        decomp = createDecompressor(codecName);        decompressors.put(codecName, decomp);    }    return decomp;}
aab787b0a4ce31188af317f0ffb1f9645e3157457cd0126336722e4fb413d0d6
createCompressor
protected BytesCompressor createCompressor(CompressionCodecName codecName)
{    return new HeapBytesCompressor(codecName);}
10335690f0a8cdc8886ecde1b6814141f02ea2a46446948006ba80f0e329adf0
createDecompressor
protected BytesDecompressor createDecompressor(CompressionCodecName codecName)
{    return new HeapBytesDecompressor(codecName);}
046ede1713f6a5891c284b1a24b9b5d5e4eee583a9430a7c91ca34b8f9359322
getCodec
protected CompressionCodec getCodec(CompressionCodecName codecName)
{    String codecClassName = codecName.getHadoopCompressionCodecClassName();    if (codecClassName == null) {        return null;    }    CompressionCodec codec = CODEC_BY_NAME.get(codecClassName);    if (codec != null) {        return codec;    }    try {        Class<?> codecClass = Class.forName(codecClassName);        codec = (CompressionCodec) ReflectionUtils.newInstance(codecClass, configuration);        CODEC_BY_NAME.put(codecClassName, codec);        return codec;    } catch (ClassNotFoundException e) {        throw new BadConfigurationException("Class " + codecClassName + " was not found", e);    }}
841fe860486f1f0b6486b341715377c24ec761b4df1c0e8649a9679daecc27a4
release
public void release()
{    for (BytesCompressor compressor : compressors.values()) {        compressor.release();    }    compressors.clear();    for (BytesDecompressor decompressor : decompressors.values()) {        decompressor.release();    }    decompressors.clear();}
a44ab89ac1bd1c96a51dfa0d50dcc13fd7563de2e02c8e8f8722aff5468302dd
getTotalValueCount
public long getTotalValueCount()
{    return valueCount;}
9cb4eeb0904f10d1d5e6bace639960ffa54293753cf81bf158838b756b0b9925
readPage
public DataPage readPage()
{    if (compressedPages.isEmpty()) {        return null;    }    DataPage compressedPage = compressedPages.remove(0);    final int currentPageIndex = pageIndex++;    return compressedPage.accept(new DataPage.Visitor<DataPage>() {        @Override        public DataPage visit(DataPageV1 dataPageV1) {            try {                BytesInput decompressed = decompressor.decompress(dataPageV1.getBytes(), dataPageV1.getUncompressedSize());                final DataPageV1 decompressedPage;                if (offsetIndex == null) {                    decompressedPage = new DataPageV1(decompressed, dataPageV1.getValueCount(), dataPageV1.getUncompressedSize(), dataPageV1.getStatistics(), dataPageV1.getRlEncoding(), dataPageV1.getDlEncoding(), dataPageV1.getValueEncoding());                } else {                    long firstRowIndex = offsetIndex.getFirstRowIndex(currentPageIndex);                    decompressedPage = new DataPageV1(decompressed, dataPageV1.getValueCount(), dataPageV1.getUncompressedSize(), firstRowIndex, Math.toIntExact(offsetIndex.getLastRowIndex(currentPageIndex, rowCount) - firstRowIndex + 1), dataPageV1.getStatistics(), dataPageV1.getRlEncoding(), dataPageV1.getDlEncoding(), dataPageV1.getValueEncoding());                }                if (dataPageV1.getCrc().isPresent()) {                    decompressedPage.setCrc(dataPageV1.getCrc().getAsInt());                }                return decompressedPage;            } catch (IOException e) {                throw new ParquetDecodingException("could not decompress page", e);            }        }        @Override        public DataPage visit(DataPageV2 dataPageV2) {            if (!dataPageV2.isCompressed()) {                if (offsetIndex == null) {                    return dataPageV2;                } else {                    return DataPageV2.uncompressed(dataPageV2.getRowCount(), dataPageV2.getNullCount(), dataPageV2.getValueCount(), offsetIndex.getFirstRowIndex(currentPageIndex), dataPageV2.getRepetitionLevels(), dataPageV2.getDefinitionLevels(), dataPageV2.getDataEncoding(), dataPageV2.getData(), dataPageV2.getStatistics());                }            }            try {                int uncompressedSize = Math.toIntExact(dataPageV2.getUncompressedSize() - dataPageV2.getDefinitionLevels().size() - dataPageV2.getRepetitionLevels().size());                BytesInput decompressed = decompressor.decompress(dataPageV2.getData(), uncompressedSize);                if (offsetIndex == null) {                    return DataPageV2.uncompressed(dataPageV2.getRowCount(), dataPageV2.getNullCount(), dataPageV2.getValueCount(), dataPageV2.getRepetitionLevels(), dataPageV2.getDefinitionLevels(), dataPageV2.getDataEncoding(), decompressed, dataPageV2.getStatistics());                } else {                    return DataPageV2.uncompressed(dataPageV2.getRowCount(), dataPageV2.getNullCount(), dataPageV2.getValueCount(), offsetIndex.getFirstRowIndex(currentPageIndex), dataPageV2.getRepetitionLevels(), dataPageV2.getDefinitionLevels(), dataPageV2.getDataEncoding(), decompressed, dataPageV2.getStatistics());                }            } catch (IOException e) {                throw new ParquetDecodingException("could not decompress page", e);            }        }    });}
140ea9f047008d524ff546d32bffde4e136753c36798d4509050c44a8633531f
visit
public DataPage visit(DataPageV1 dataPageV1)
{    try {        BytesInput decompressed = decompressor.decompress(dataPageV1.getBytes(), dataPageV1.getUncompressedSize());        final DataPageV1 decompressedPage;        if (offsetIndex == null) {            decompressedPage = new DataPageV1(decompressed, dataPageV1.getValueCount(), dataPageV1.getUncompressedSize(), dataPageV1.getStatistics(), dataPageV1.getRlEncoding(), dataPageV1.getDlEncoding(), dataPageV1.getValueEncoding());        } else {            long firstRowIndex = offsetIndex.getFirstRowIndex(currentPageIndex);            decompressedPage = new DataPageV1(decompressed, dataPageV1.getValueCount(), dataPageV1.getUncompressedSize(), firstRowIndex, Math.toIntExact(offsetIndex.getLastRowIndex(currentPageIndex, rowCount) - firstRowIndex + 1), dataPageV1.getStatistics(), dataPageV1.getRlEncoding(), dataPageV1.getDlEncoding(), dataPageV1.getValueEncoding());        }        if (dataPageV1.getCrc().isPresent()) {            decompressedPage.setCrc(dataPageV1.getCrc().getAsInt());        }        return decompressedPage;    } catch (IOException e) {        throw new ParquetDecodingException("could not decompress page", e);    }}
55c381abb07efa544477c26248285ad454e0e6572166e91d764830084ee568fc
visit
public DataPage visit(DataPageV2 dataPageV2)
{    if (!dataPageV2.isCompressed()) {        if (offsetIndex == null) {            return dataPageV2;        } else {            return DataPageV2.uncompressed(dataPageV2.getRowCount(), dataPageV2.getNullCount(), dataPageV2.getValueCount(), offsetIndex.getFirstRowIndex(currentPageIndex), dataPageV2.getRepetitionLevels(), dataPageV2.getDefinitionLevels(), dataPageV2.getDataEncoding(), dataPageV2.getData(), dataPageV2.getStatistics());        }    }    try {        int uncompressedSize = Math.toIntExact(dataPageV2.getUncompressedSize() - dataPageV2.getDefinitionLevels().size() - dataPageV2.getRepetitionLevels().size());        BytesInput decompressed = decompressor.decompress(dataPageV2.getData(), uncompressedSize);        if (offsetIndex == null) {            return DataPageV2.uncompressed(dataPageV2.getRowCount(), dataPageV2.getNullCount(), dataPageV2.getValueCount(), dataPageV2.getRepetitionLevels(), dataPageV2.getDefinitionLevels(), dataPageV2.getDataEncoding(), decompressed, dataPageV2.getStatistics());        } else {            return DataPageV2.uncompressed(dataPageV2.getRowCount(), dataPageV2.getNullCount(), dataPageV2.getValueCount(), offsetIndex.getFirstRowIndex(currentPageIndex), dataPageV2.getRepetitionLevels(), dataPageV2.getDefinitionLevels(), dataPageV2.getDataEncoding(), decompressed, dataPageV2.getStatistics());        }    } catch (IOException e) {        throw new ParquetDecodingException("could not decompress page", e);    }}
c912f40c38afde0ef75b8d08ab2c675551c383cef1763b349d2cf096213fb12d
readDictionaryPage
public DictionaryPage readDictionaryPage()
{    if (compressedDictionaryPage == null) {        return null;    }    try {        DictionaryPage decompressedPage = new DictionaryPage(decompressor.decompress(compressedDictionaryPage.getBytes(), compressedDictionaryPage.getUncompressedSize()), compressedDictionaryPage.getDictionarySize(), compressedDictionaryPage.getEncoding());        if (compressedDictionaryPage.getCrc().isPresent()) {            decompressedPage.setCrc(compressedDictionaryPage.getCrc().getAsInt());        }        return decompressedPage;    } catch (IOException e) {        throw new ParquetDecodingException("Could not decompress dictionary page", e);    }}
a3384eda6088ab785128d7d88a9af55e07543a5e59774f8c7f30961ef025e4f5
getRowCount
public long getRowCount()
{    return rowCount;}
14442cce04c1c5e007e705a98026fde89bda91472d4d7923cc084105edd28b04
getPageReader
public PageReader getPageReader(ColumnDescriptor path)
{    if (!readers.containsKey(path)) {        throw new IllegalArgumentException(path + " is not in the store: " + readers.keySet() + " " + rowCount);    }    return readers.get(path);}
bb902dcbcb3360c7fd371da6ab8821a08f18f898b07b1a65594d2060072e16e5
readDictionaryPage
public DictionaryPage readDictionaryPage(ColumnDescriptor descriptor)
{    return readers.get(descriptor).readDictionaryPage();}
199391e9abf820ddec232c64ab55fc1e5372feb139b51d733144319cd3f0d37e
getRowIndexes
public Optional<PrimitiveIterator.OfLong> getRowIndexes()
{    return rowRanges == null ? Optional.empty() : Optional.of(rowRanges.iterator());}
fbad4391485910f1acb92e6432ef26d41611a72c62917d31f4bf763dd673740e
addColumn
 void addColumn(ColumnDescriptor path, ColumnChunkPageReader reader)
{    if (readers.put(path, reader) != null) {        throw new RuntimeException(path + " was added twice");    }}
7b3484065d7223c96cd07cbc81db04c045e8ee7949f4c3030ba90a3e7461fc3c
writePage
public void writePage(BytesInput bytesInput, int valueCount, Statistics<?> statistics, Encoding rlEncoding, Encoding dlEncoding, Encoding valuesEncoding) throws IOException
{        columnIndexBuilder = ColumnIndexBuilder.getNoOpBuilder();    offsetIndexBuilder = OffsetIndexBuilder.getNoOpBuilder();    writePage(bytesInput, valueCount, -1, statistics, rlEncoding, dlEncoding, valuesEncoding);}
b67d65112cae8acce899051c5e8bfcb456b30f547282e4152eaa7847c83c843d
writePage
public void writePage(BytesInput bytes, int valueCount, int rowCount, Statistics statistics, Encoding rlEncoding, Encoding dlEncoding, Encoding valuesEncoding) throws IOException
{    long uncompressedSize = bytes.size();    if (uncompressedSize > Integer.MAX_VALUE) {        throw new ParquetEncodingException("Cannot write page larger than Integer.MAX_VALUE bytes: " + uncompressedSize);    }    BytesInput compressedBytes = compressor.compress(bytes);    long compressedSize = compressedBytes.size();    if (compressedSize > Integer.MAX_VALUE) {        throw new ParquetEncodingException("Cannot write compressed page larger than Integer.MAX_VALUE bytes: " + compressedSize);    }    tempOutputStream.reset();    if (pageWriteChecksumEnabled) {        crc.reset();        crc.update(compressedBytes.toByteArray());        parquetMetadataConverter.writeDataPageV1Header((int) uncompressedSize, (int) compressedSize, valueCount, rlEncoding, dlEncoding, valuesEncoding, (int) crc.getValue(), tempOutputStream);    } else {        parquetMetadataConverter.writeDataPageV1Header((int) uncompressedSize, (int) compressedSize, valueCount, rlEncoding, dlEncoding, valuesEncoding, tempOutputStream);    }    this.uncompressedLength += uncompressedSize;    this.compressedLength += compressedSize;    this.totalValueCount += valueCount;    this.pageCount += 1;        if (totalStatistics == null) {        totalStatistics = statistics.copy();    } else {        totalStatistics.mergeStatistics(statistics);    }    columnIndexBuilder.add(statistics);    offsetIndexBuilder.add(toIntWithCheck(tempOutputStream.size() + compressedSize), rowCount);            buf.collect(BytesInput.concat(BytesInput.from(tempOutputStream), compressedBytes));    rlEncodings.add(rlEncoding);    dlEncodings.add(dlEncoding);    dataEncodings.add(valuesEncoding);}
826a0908c0c09aa6f50aff7b6b7d4e389c1b9aa775b04cb02885f45a0e83ad2d
writePageV2
public void writePageV2(int rowCount, int nullCount, int valueCount, BytesInput repetitionLevels, BytesInput definitionLevels, Encoding dataEncoding, BytesInput data, Statistics<?> statistics) throws IOException
{    int rlByteLength = toIntWithCheck(repetitionLevels.size());    int dlByteLength = toIntWithCheck(definitionLevels.size());    int uncompressedSize = toIntWithCheck(data.size() + repetitionLevels.size() + definitionLevels.size());        BytesInput compressedData = compressor.compress(data);    int compressedSize = toIntWithCheck(compressedData.size() + repetitionLevels.size() + definitionLevels.size());    tempOutputStream.reset();    parquetMetadataConverter.writeDataPageV2Header(uncompressedSize, compressedSize, valueCount, nullCount, rowCount, dataEncoding, rlByteLength, dlByteLength, tempOutputStream);    this.uncompressedLength += uncompressedSize;    this.compressedLength += compressedSize;    this.totalValueCount += valueCount;    this.pageCount += 1;        if (totalStatistics == null) {        totalStatistics = statistics.copy();    } else {        totalStatistics.mergeStatistics(statistics);    }    columnIndexBuilder.add(statistics);    offsetIndexBuilder.add(toIntWithCheck((long) tempOutputStream.size() + compressedSize), rowCount);            buf.collect(BytesInput.concat(BytesInput.from(tempOutputStream), repetitionLevels, definitionLevels, compressedData));    dataEncodings.add(dataEncoding);}
8e3fb201eb68bd6d57097b4b87ea651064bb9571409c01f1032d1008bfe5968f
toIntWithCheck
private int toIntWithCheck(long size)
{    if (size > Integer.MAX_VALUE) {        throw new ParquetEncodingException("Cannot write page larger than " + Integer.MAX_VALUE + " bytes: " + size);    }    return (int) size;}
6a6d96a7d5cb6e49f470f1cd037acc9fc797a8452a905cfabb5dd9fec40874d4
getMemSize
public long getMemSize()
{    return buf.size();}
7f4655c784878e4c73c4027d68e66a98b5b4d15d32db014931440cdce2b5fc98
writeToFileWriter
public void writeToFileWriter(ParquetFileWriter writer) throws IOException
{    writer.writeColumnChunk(path, totalValueCount, compressor.getCodecName(), dictionaryPage, buf, uncompressedLength, compressedLength, totalStatistics, columnIndexBuilder, offsetIndexBuilder, rlEncodings, dlEncodings, dataEncodings);    if (LOG.isDebugEnabled()) {        LOG.debug(String.format("written %,dB for %s: %,d values, %,dB raw, %,dB comp, %d pages, encodings: %s", buf.size(), path, totalValueCount, uncompressedLength, compressedLength, pageCount, new HashSet<Encoding>(dataEncodings)) + (dictionaryPage != null ? String.format(", dic { %,d entries, %,dB raw, %,dB comp}", dictionaryPage.getDictionarySize(), dictionaryPage.getUncompressedSize(), dictionaryPage.getDictionarySize()) : ""));    }    rlEncodings.clear();    dlEncodings.clear();    dataEncodings.clear();    pageCount = 0;}
878d1060df6bc5af3d1f5d5388cfa4f6715bcc9c71ff30801f3696b5b8cc3ba2
allocatedSize
public long allocatedSize()
{    return buf.size();}
979a9e010c509f63ed8210f83e5e4d7838052d7f5e3bbb4e9c3797d5de3ea217
writeDictionaryPage
public void writeDictionaryPage(DictionaryPage dictionaryPage) throws IOException
{    if (this.dictionaryPage != null) {        throw new ParquetEncodingException("Only one dictionary page is allowed");    }    BytesInput dictionaryBytes = dictionaryPage.getBytes();    int uncompressedSize = (int) dictionaryBytes.size();    BytesInput compressedBytes = compressor.compress(dictionaryBytes);    this.dictionaryPage = new DictionaryPage(BytesInput.copy(compressedBytes), uncompressedSize, dictionaryPage.getDictionarySize(), dictionaryPage.getEncoding());}
729f860abc36decbc60be91f7b83b54762252f09cb85d7c4e9f7517c5dace502
memUsageString
public String memUsageString(String prefix)
{    return buf.memUsageString(prefix + " ColumnChunkPageWriter");}
49c948b863e8c6ae55cc16f5e5ada03850af9ce16ffe3f2f06d54af573345c22
getPageWriter
public PageWriter getPageWriter(ColumnDescriptor path)
{    return writers.get(path);}
1d439ddcbf2fe6724aa87fbb05cc0acc3d2a5333a2dd077a43ac6d54eae384b4
flushToFileWriter
public void flushToFileWriter(ParquetFileWriter writer) throws IOException
{    for (ColumnDescriptor path : schema.getColumns()) {        ColumnChunkPageWriter pageWriter = writers.get(path);        pageWriter.writeToFileWriter(writer);    }}
27dfcc4ac0e1867ef58eef8284f9f5d0ae75dece9d43d59761c952ee896338d6
getOffset
 long getOffset()
{    return offset;}
31b3077ce136a2cecc578a665d5ed79782e9569163f290b6d937063d4c25a1ad
getLength
 long getLength()
{    return length;}
f708d5f9a56a12312d3f8923a4a4a3d08297410af5aff4f71f43c26be9fc3840
extend
private boolean extend(long offset, int length)
{    if (this.offset + this.length == offset) {        this.length += length;        return true;    } else {        return false;    }}
6e0494c1557afad1c50045b01e6e6e5185f541d78e0c3325387bf572d4b6c90c
getPageCount
public int getPageCount()
{    return indexMap.length;}
91b7d33d27aa553842f84b87c8bb8d2a2db45dfe426c7b0e968cf71617c750da
getOffset
public long getOffset(int pageIndex)
{    return offsetIndex.getOffset(indexMap[pageIndex]);}
c23a85cdce0a6a62b73c30026554f81704999c625bd65684ad67c5414d4b17a9
getCompressedPageSize
public int getCompressedPageSize(int pageIndex)
{    return offsetIndex.getCompressedPageSize(indexMap[pageIndex]);}
2be9fde157325d17c973f350ff7e74ca384485421f5a7fff047acf1a30b5ed9a
getFirstRowIndex
public long getFirstRowIndex(int pageIndex)
{    return offsetIndex.getFirstRowIndex(indexMap[pageIndex]);}
bdc4e090e522f226400bf13c7ad4c97b7e3ca8e6bc5a507d2f6afd8c29a613bd
getLastRowIndex
public long getLastRowIndex(int pageIndex, long totalRowCount)
{    int nextIndex = indexMap[pageIndex] + 1;    return (nextIndex >= offsetIndex.getPageCount() ? totalRowCount : offsetIndex.getFirstRowIndex(nextIndex)) - 1;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    try (Formatter formatter = new Formatter()) {        formatter.format("%-12s  %20s  %16s  %20s\n", "", "offset", "compressed size", "first row index");        for (int i = 0, n = offsetIndex.getPageCount(); i < n; ++i) {            int index = Arrays.binarySearch(indexMap, i);            boolean isHidden = index < 0;            formatter.format("%spage-%-5d  %20d  %16d  %20d\n", isHidden ? "- " : "  ", isHidden ? i : index, offsetIndex.getOffset(i), offsetIndex.getCompressedPageSize(i), offsetIndex.getFirstRowIndex(i));        }        return formatter.toString();    }}
c098fccdb892522b5ba1701cdfd5b58f511377df1844ad33ab044b3f86ab02b2
filterOffsetIndex
 static OffsetIndex filterOffsetIndex(OffsetIndex offsetIndex, RowRanges rowRanges, long totalRowCount)
{    IntList indexMap = new IntArrayList();    for (int i = 0, n = offsetIndex.getPageCount(); i < n; ++i) {        long from = offsetIndex.getFirstRowIndex(i);        if (rowRanges.isOverlapping(from, offsetIndex.getLastRowIndex(i, totalRowCount))) {            indexMap.add(i);        }    }    return new FilteredOffsetIndex(offsetIndex, indexMap.toIntArray());}
a79c0a2999d658fd47639660704fa49b7d3e556d2ea8419f990b45de0c277037
calculateOffsetRanges
 static List<OffsetRange> calculateOffsetRanges(OffsetIndex offsetIndex, ColumnChunkMetaData cm, long firstPageOffset)
{    List<OffsetRange> ranges = new ArrayList<>();    int n = offsetIndex.getPageCount();    if (n > 0) {        OffsetRange currentRange = null;                long rowGroupOffset = cm.getStartingPos();        if (rowGroupOffset < firstPageOffset) {            currentRange = new OffsetRange(rowGroupOffset, (int) (firstPageOffset - rowGroupOffset));            ranges.add(currentRange);        }        for (int i = 0; i < n; ++i) {            long offset = offsetIndex.getOffset(i);            int length = offsetIndex.getCompressedPageSize(i);            if (currentRange == null || !currentRange.extend(offset, length)) {                currentRange = new OffsetRange(offset, length);                ranges.add(currentRange);            }        }    }    return ranges;}
0a08c079436163321eec15cc1a7e04ff093744c55235a49016b28d597cb6bca0
getColumnIndex
public ColumnIndex getColumnIndex()
{    if (!columnIndexRead) {        try {            columnIndex = reader.readColumnIndex(meta);        } catch (IOException e) {                                    LOGGER.warn("Unable to read column index for column {}", meta.getPath(), e);        }        columnIndexRead = true;    }    return columnIndex;}
97cf2d048d4a002e9f3103d0578b61485bc5a32f96af1ffa06685219ffa614be
getOffsetIndex
public OffsetIndex getOffsetIndex()
{    return offsetIndex;}
0a08c079436163321eec15cc1a7e04ff093744c55235a49016b28d597cb6bca0
getColumnIndex
public ColumnIndex getColumnIndex()
{    return null;}
97cf2d048d4a002e9f3103d0578b61485bc5a32f96af1ffa06685219ffa614be
getOffsetIndex
public OffsetIndex getOffsetIndex()
{    return null;}
cf6b81b70343f368ba7363b210bae70f5a21c9c1300b0cf68a80ae4a743cccd1
getColumnIndex
public ColumnIndex getColumnIndex(ColumnPath column)
{    return null;}
2698d03083af88b3c827e603e1f97530dacfdc449ddf9af80c09e43c70676a8e
getOffsetIndex
public OffsetIndex getOffsetIndex(ColumnPath column)
{    throw new MissingOffsetIndexException(column);}
ec53729ca815e90c02a97456507f95f479565128730be515251f9908e6ff4198
create
 static ColumnIndexStore create(ParquetFileReader reader, BlockMetaData block, Set<ColumnPath> paths)
{    try {        return new ColumnIndexStoreImpl(reader, block, paths);    } catch (MissingOffsetIndexException e) {        return EMPTY;    }}
cf6b81b70343f368ba7363b210bae70f5a21c9c1300b0cf68a80ae4a743cccd1
getColumnIndex
public ColumnIndex getColumnIndex(ColumnPath column)
{    return store.getOrDefault(column, MISSING_INDEX_STORE).getColumnIndex();}
2698d03083af88b3c827e603e1f97530dacfdc449ddf9af80c09e43c70676a8e
getOffsetIndex
public OffsetIndex getOffsetIndex(ColumnPath column)
{    return store.getOrDefault(column, MISSING_INDEX_STORE).getOffsetIndex();}
9ea65dad52e6b20c3e92e9a0f8b8b6b2d2b586982c10a5a556301b663f045619
setRowGroup
 void setRowGroup(ColumnChunkPageReadStore rowGroup)
{    this.rowGroup = rowGroup;}
bb902dcbcb3360c7fd371da6ab8821a08f18f898b07b1a65594d2060072e16e5
readDictionaryPage
public DictionaryPage readDictionaryPage(ColumnDescriptor descriptor)
{    if (rowGroup != null) {                return rowGroup.readDictionaryPage(descriptor);    }    String dotPath = Strings.join(descriptor.getPath(), ".");    ColumnChunkMetaData column = columns.get(dotPath);    if (column == null) {        throw new ParquetDecodingException("Cannot load dictionary, unknown column: " + dotPath);    }    if (cache.containsKey(dotPath)) {        return cache.get(dotPath);    }    try {        synchronized (cache) {                        if (!cache.containsKey(dotPath)) {                DictionaryPage dict = hasDictionaryPage(column) ? reader.readDictionary(column) : null;                                                                cache.put(dotPath, reusableCopy(dict));            }        }        return cache.get(dotPath);    } catch (IOException e) {        throw new ParquetDecodingException("Failed to read dictionary", e);    }}
071a9e3369a4a68607b66d572b558617f564a7565a1cf2d24970fc67c5d373ce
reusableCopy
private static DictionaryPage reusableCopy(DictionaryPage dict)
{    if (dict == null) {        return null;    }    try {        return new DictionaryPage(BytesInput.from(dict.getBytes().toByteArray()), dict.getDictionarySize(), dict.getEncoding());    } catch (IOException e) {        throw new ParquetDecodingException("Cannot read dictionary", e);    }}
1caa66fc8ed69e6fa2274b70c74358bd4ef8ded672cf0571e6ed38507d2ddc71
hasDictionaryPage
private boolean hasDictionaryPage(ColumnChunkMetaData column)
{    EncodingStats stats = column.getEncodingStats();    if (stats != null) {                return stats.hasDictionaryPages() && stats.hasDictionaryEncodedPages();    }    Set<Encoding> encodings = column.getEncodings();    return (encodings.contains(PLAIN_DICTIONARY) || encodings.contains(RLE_DICTIONARY));}
8eee7a1fdf46c2add607bc7bbe9bf27045206791db661c80d46908e5831ac16c
ensure
private ByteBuffer ensure(ByteBuffer buffer, int size)
{    if (buffer == null) {        buffer = allocator.allocate(size);    } else if (buffer.capacity() >= size) {        buffer.clear();    } else {        release(buffer);        buffer = allocator.allocate(size);    }    return buffer;}
2982b2d5f2e4b044879c5c8916bc721781ce1e68fc1466c94c7f256684b8c799
release
 ByteBuffer release(ByteBuffer buffer)
{    if (buffer != null) {        allocator.release(buffer);    }    return null;}
fb48cd8a6d2b7510a14a11651511354ffd293304c0179c3790cd6eb0b6d10de4
createCompressor
protected BytesCompressor createCompressor(final CompressionCodecName codecName)
{    CompressionCodec codec = getCodec(codecName);    if (codec == null) {        return new NoopCompressor();    } else if (codecName == CompressionCodecName.SNAPPY) {                return new SnappyCompressor();    } else {                return new HeapBytesCompressor(codecName);    }}
7031ffec443ec33c21c9b82d795f17c0e8522d48b39054f94d6cc16c81911ade
createDecompressor
protected BytesDecompressor createDecompressor(final CompressionCodecName codecName)
{    CompressionCodec codec = getCodec(codecName);    if (codec == null) {        return new NoopDecompressor();    } else if (codecName == CompressionCodecName.SNAPPY) {        return new SnappyDecompressor();    } else if (DirectCodecPool.INSTANCE.codec(codec).supportsDirectDecompression()) {        return new FullDirectDecompressor(codecName);    } else {        return new IndirectDecompressor(codec);    }}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    release();}
180217056b3829e9d3663d5333fdb6dc882164bcd64331030939ccfdd10fed32
decompress
public BytesInput decompress(BytesInput bytes, int uncompressedSize) throws IOException
{    decompressor.reset();    byte[] inputBytes = bytes.toByteArray();    decompressor.setInput(inputBytes, 0, inputBytes.length);    byte[] output = new byte[uncompressedSize];    decompressor.decompress(output, 0, uncompressedSize);    return BytesInput.from(output);}
5e23b7777d32f170fcffe2d8f3a7165aa3acc56dfb826cfc2f76bc65084982ae
decompress
public void decompress(ByteBuffer input, int compressedSize, ByteBuffer output, int uncompressedSize) throws IOException
{    decompressor.reset();    byte[] inputBytes = new byte[compressedSize];    input.position(0);    input.get(inputBytes);    decompressor.setInput(inputBytes, 0, inputBytes.length);    byte[] outputBytes = new byte[uncompressedSize];    decompressor.decompress(outputBytes, 0, uncompressedSize);    output.clear();    output.put(outputBytes);}
841fe860486f1f0b6486b341715377c24ec761b4df1c0e8649a9679daecc27a4
release
public void release()
{    DirectCodecPool.INSTANCE.returnDecompressor(decompressor);}
44fc366b8d88824671459f214aca9480bf5b3a7dac38368514839be076f8fb66
decompress
public BytesInput decompress(BytesInput compressedBytes, int uncompressedSize) throws IOException
{    return extraDecompressor.decompress(compressedBytes, uncompressedSize);}
5e23b7777d32f170fcffe2d8f3a7165aa3acc56dfb826cfc2f76bc65084982ae
decompress
public void decompress(ByteBuffer input, int compressedSize, ByteBuffer output, int uncompressedSize) throws IOException
{    output.clear();    try {        DECOMPRESS_METHOD.invoke(decompressor, (ByteBuffer) input.limit(compressedSize), (ByteBuffer) output.limit(uncompressedSize));    } catch (IllegalAccessException e) {        throw new DirectCodecPool.ParquetCompressionCodecException(e);    } catch (InvocationTargetException e) {        throw new DirectCodecPool.ParquetCompressionCodecException(e);    }    output.position(uncompressedSize);}
841fe860486f1f0b6486b341715377c24ec761b4df1c0e8649a9679daecc27a4
release
public void release()
{    DirectCodecPool.INSTANCE.returnDirectDecompressor(decompressor);    extraDecompressor.release();}
5e23b7777d32f170fcffe2d8f3a7165aa3acc56dfb826cfc2f76bc65084982ae
decompress
public void decompress(ByteBuffer input, int compressedSize, ByteBuffer output, int uncompressedSize) throws IOException
{    Preconditions.checkArgument(compressedSize == uncompressedSize, "Non-compressed data did not have matching compressed and uncompressed sizes.");    output.clear();    output.put((ByteBuffer) input.duplicate().position(0).limit(compressedSize));}
180217056b3829e9d3663d5333fdb6dc882164bcd64331030939ccfdd10fed32
decompress
public BytesInput decompress(BytesInput bytes, int uncompressedSize) throws IOException
{    return bytes;}
841fe860486f1f0b6486b341715377c24ec761b4df1c0e8649a9679daecc27a4
release
public void release()
{}
180217056b3829e9d3663d5333fdb6dc882164bcd64331030939ccfdd10fed32
decompress
public BytesInput decompress(BytesInput bytes, int uncompressedSize) throws IOException
{    return extraDecompressor.decompress(bytes, uncompressedSize);}
75c595922d394106dce82133b24e6d2242e774aaa550eac7a830362fe10ef788
decompress
public void decompress(ByteBuffer src, int compressedSize, ByteBuffer dst, int uncompressedSize) throws IOException
{    dst.clear();    int size = Snappy.uncompress(src, dst);    dst.limit(size);}
841fe860486f1f0b6486b341715377c24ec761b4df1c0e8649a9679daecc27a4
release
public void release()
{}
bceca01b13bfdb132ee51e7c433cd1e0ce5aa3d202027517734912a8c09aae16
compress
public BytesInput compress(BytesInput bytes) throws IOException
{    int maxOutputSize = Snappy.maxCompressedLength((int) bytes.size());    ByteBuffer bufferIn = bytes.toByteBuffer();    outgoing = ensure(outgoing, maxOutputSize);    final int size;    if (bufferIn.isDirect()) {        size = Snappy.compress(bufferIn, outgoing);    } else {                this.incoming = ensure(this.incoming, (int) bytes.size());        this.incoming.put(bufferIn);        this.incoming.flip();        size = Snappy.compress(this.incoming, outgoing);    }    outgoing.limit(size);    return BytesInput.from(outgoing);}
bf484a5178ea60af7c97607f7c207960c498408f9df4220c87235c1fccc7e7fc
getCodecName
public CompressionCodecName getCodecName()
{    return CompressionCodecName.SNAPPY;}
841fe860486f1f0b6486b341715377c24ec761b4df1c0e8649a9679daecc27a4
release
public void release()
{    outgoing = DirectCodecFactory.this.release(outgoing);    incoming = DirectCodecFactory.this.release(incoming);}
bceca01b13bfdb132ee51e7c433cd1e0ce5aa3d202027517734912a8c09aae16
compress
public BytesInput compress(BytesInput bytes) throws IOException
{    return bytes;}
bf484a5178ea60af7c97607f7c207960c498408f9df4220c87235c1fccc7e7fc
getCodecName
public CompressionCodecName getCodecName()
{    return CompressionCodecName.UNCOMPRESSED;}
841fe860486f1f0b6486b341715377c24ec761b4df1c0e8649a9679daecc27a4
release
public void release()
{}
34ca61c6c834daaab0eee4f8621114df043c2568972d843581a993cb82225245
makeObject
public Object makeObject() throws Exception
{    return codec.createCompressor();}
34ca61c6c834daaab0eee4f8621114df043c2568972d843581a993cb82225245
makeObject
public Object makeObject() throws Exception
{    return codec.createDecompressor();}
34ca61c6c834daaab0eee4f8621114df043c2568972d843581a993cb82225245
makeObject
public Object makeObject() throws Exception
{    return CREATE_DIRECT_DECOMPRESSOR_METHOD.invoke(DIRECT_DECOMPRESSION_CODEC_CLASS);}
f6c43ac3c90228664131b0f899c983764b497436348dc3eeec5d32d2d0c2adf1
borrowDirectDecompressor
public Object borrowDirectDecompressor()
{    Preconditions.checkArgument(supportDirectDecompressor, "Tried to get a direct Decompressor from a non-direct codec.");    try {        return directDecompressorPool.borrowObject();    } catch (Exception e) {        throw new ParquetCompressionCodecException(e);    }}
6535f09936e2bbb7cc43e459c5788079657a042eb539b60f73f6df766060b4fb
supportsDirectDecompression
public boolean supportsDirectDecompression()
{    return supportDirectDecompressor;}
71bab595bf8e5bc7ded3e972753d92e7274def9b1a0bdbf9c0fcd9c0dca7bb1b
borrowDecompressor
public Decompressor borrowDecompressor()
{    return borrow(decompressorPool);}
c15d48cb75ec0fdc22a59557e115adcf90e6d9ebdc5f19550adba6035bcaf1c1
borrowCompressor
public Compressor borrowCompressor()
{    return borrow(compressorPool);}
bdddd0a595779253110599dbea02c9bb8ab8e82278f22a92a7c5b3f9afcc1070
codec
public CodecPool codec(CompressionCodec codec)
{    CodecPool pools = codecs.get(codec);    if (pools == null) {        synchronized (this) {            pools = codecs.get(codec);            if (pools == null) {                pools = new CodecPool(codec);                codecs.put(codec, pools);            }        }    }    return pools;}
84f6b7c4605ffe273e509f89f7dcb34d9554b4b8136e8287c992c46e45e10357
returnToPool
private void returnToPool(Object obj, Map<Class<?>, GenericObjectPool> pools)
{    try {        GenericObjectPool pool = pools.get(obj.getClass());        if (pool == null) {            throw new IllegalStateException("Received unexpected compressor or decompressor, " + "cannot be returned to any available pool: " + obj.getClass().getSimpleName());        }        pool.returnObject(obj);    } catch (Exception e) {        throw new ParquetCompressionCodecException(e);    }}
e478ec79dd7c4b058a181729c4d40c3a688c0ae8e0bbb4e967c025354fe4c3c0
borrow
public T borrow(GenericObjectPool pool)
{    try {        return (T) pool.borrowObject();    } catch (Exception e) {        throw new ParquetCompressionCodecException(e);    }}
df52b42c99bb98d5251d653be8ae03348fc950112ad96eb62a7a3f8581ca341a
returnCompressor
public void returnCompressor(Compressor compressor)
{    returnToPool(compressor, cPools);}
17be6a7141b965471395551a2e579159a0f34ef2e2048a1656145f1798e46c6f
returnDecompressor
public void returnDecompressor(Decompressor decompressor)
{    returnToPool(decompressor, dePools);}
b3f1912c1fc782e688b94fbf20500a370ecbf47ff866a0e3955b60f830a05861
returnDirectDecompressor
public void returnDirectDecompressor(Object decompressor)
{    returnToPool(decompressor, directDePools);}
4055a8c4f5eaddac19cc6ead37335ac04e4097be95ab0b502cba7e7388e6a54a
setSchema
public static void setSchema(Job job, MessageType schema)
{    GroupWriteSupport.setSchema(schema, ContextUtil.getConfiguration(job));}
e3732018f1be72088de95516c567598d5a9b1a864fc9e65f309d0e3f39e253b5
getSchema
public static MessageType getSchema(Job job)
{    return GroupWriteSupport.getSchema(ContextUtil.getConfiguration(job));}
e56a8e168897880b65db0ea3cec7d6a2f9e0b63c60c61a07c85b9afa57453d43
builder
public static Builder builder(Path file)
{    return new Builder(file);}
385361abc3a731d165773b1fb053ef3a548fda25d0f34df6dc683b201a9a934e
builder
public static Builder builder(OutputFile file)
{    return new Builder(file);}
2bd901ea7f79c05304cf8df06e419ef0b79d199d8b2323dc5f4433d5bfd51763
withType
public Builder withType(MessageType type)
{    this.type = type;    return this;}
ad3ec4c27e82681b05faf36870728f956f2118bc1b606466f40c2ac0c4562cc1
withExtraMetaData
public Builder withExtraMetaData(Map<String, String> extraMetaData)
{    this.extraMetaData = extraMetaData;    return this;}
a993f28f6e04821d774f83bd8818357de573d43fb528d089f5f5a68dc6ef5f52
self
protected Builder self()
{    return this;}
accb9a3656c0207bb1e5a12702b44294a2f94934ee0a0ed6ff645a9463b645fb
getWriteSupport
protected WriteSupport<Group> getWriteSupport(Configuration conf)
{    return new GroupWriteSupport(type, extraMetaData);}
144789ca93722011d59500eb2ca80bc5500abb487acd4912097771a909ba3e72
init
public org.apache.parquet.hadoop.api.ReadSupport.ReadContext init(Configuration configuration, Map<String, String> keyValueMetaData, MessageType fileSchema)
{    String partialSchemaString = configuration.get(ReadSupport.PARQUET_READ_SCHEMA);    MessageType requestedProjection = getSchemaForRead(fileSchema, partialSchemaString);    return new ReadContext(requestedProjection);}
dd446788e8618dc276c72a658cc858d0c84eb60953770e84aa3aea6ae920d4b9
prepareForRead
public RecordMaterializer<Group> prepareForRead(Configuration configuration, Map<String, String> keyValueMetaData, MessageType fileSchema, org.apache.parquet.hadoop.api.ReadSupport.ReadContext readContext)
{    return new GroupRecordConverter(readContext.getRequestedSchema());}
e62319177e67b6f55fb25f6bb20f5b73da5a507a172465b5c5e5f8de12bda800
setSchema
public static void setSchema(MessageType schema, Configuration configuration)
{    configuration.set(PARQUET_EXAMPLE_SCHEMA, schema.toString());}
5dbfa363311eee8edd2d4325b752ce03bf91fc44bc9757e21c34831ee5e622ea
getSchema
public static MessageType getSchema(Configuration configuration)
{    return parseMessageType(checkNotNull(configuration.get(PARQUET_EXAMPLE_SCHEMA), PARQUET_EXAMPLE_SCHEMA));}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "example";}
7f8458dfb1b72d60e1e9cd1c65cc115b0e7fc4f161566bb61c50a98451e6f739
init
public org.apache.parquet.hadoop.api.WriteSupport.WriteContext init(Configuration configuration)
{        if (schema == null) {        schema = getSchema(configuration);    }    return new WriteContext(schema, this.extraMetaData);}
da9aef78cf181856102b820ffa7d5248e8581747b3f0670a7b049c4649b962ef
prepareForWrite
public void prepareForWrite(RecordConsumer recordConsumer)
{    groupWriter = new GroupWriter(recordConsumer, schema);}
31152d423e0a60e22d40aa015c8820bfc90d8884efa80a948aad1400e6ecebab
write
public void write(Group record)
{    groupWriter.write(record);}
1cd7c03f7fafac1bb795168cb128e970c38b92874e5b65d252bdebca96651ecb
getFile
public Path getFile()
{    return file;}
3947544a190ddb17c36a4ccf0887ca71126563c5ee334959af81c31edd413164
getParquetMetadata
public ParquetMetadata getParquetMetadata()
{    return parquetMetadata;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "Footer{" + file + ", " + parquetMetadata + "}";}
1c46580975c8c25b1b2e74fd26cd59ba88e90cbf027b5560ab1aa248195b04c5
checkRead
private void checkRead() throws IOException
{    if (current == totalCountLoadedSoFar) {        if (current != 0) {            totalTimeSpentProcessingRecords += (System.currentTimeMillis() - startedAssemblingCurrentBlockAt);            if (LOG.isInfoEnabled()) {                LOG.info("Assembled and processed " + totalCountLoadedSoFar + " records from " + columnCount + " columns in " + totalTimeSpentProcessingRecords + " ms: " + ((float) totalCountLoadedSoFar / totalTimeSpentProcessingRecords) + " rec/ms, " + ((float) totalCountLoadedSoFar * columnCount / totalTimeSpentProcessingRecords) + " cell/ms");                final long totalTime = totalTimeSpentProcessingRecords + totalTimeSpentReadingBytes;                if (totalTime != 0) {                    final long percentReading = 100 * totalTimeSpentReadingBytes / totalTime;                    final long percentProcessing = 100 * totalTimeSpentProcessingRecords / totalTime;                    LOG.info("time spent so far " + percentReading + "% reading (" + totalTimeSpentReadingBytes + " ms) and " + percentProcessing + "% processing (" + totalTimeSpentProcessingRecords + " ms)");                }            }        }        LOG.info("at row " + current + ". reading next block");        long t0 = System.currentTimeMillis();        PageReadStore pages = reader.readNextFilteredRowGroup();        if (pages == null) {            throw new IOException("expecting more rows but reached last block. Read " + current + " out of " + total);        }        long timeSpentReading = System.currentTimeMillis() - t0;        totalTimeSpentReadingBytes += timeSpentReading;        BenchmarkCounter.incrementTime(timeSpentReading);        if (LOG.isInfoEnabled())            LOG.info("block read in memory in {} ms. row count = {}", timeSpentReading, pages.getRowCount());        LOG.debug("initializing Record assembly with requested schema {}", requestedSchema);        MessageColumnIO columnIO = columnIOFactory.getColumnIO(requestedSchema, fileSchema, strictTypeChecking);        recordReader = columnIO.getRecordReader(pages, recordConverter, filterRecords ? filter : FilterCompat.NOOP);        startedAssemblingCurrentBlockAt = System.currentTimeMillis();        totalCountLoadedSoFar += pages.getRowCount();        ++currentBlock;    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    if (reader != null) {        reader.close();    }}
7e0e144ea811abeab166edde4c792d45321073d3a332fd9987c63fcb5f717a6f
getCurrentKey
public Void getCurrentKey() throws IOException, InterruptedException
{    return null;}
fadc2e51326de80aa9d9674da1ab3da153254ccefc7017086c4713afadd816c7
getCurrentValue
public T getCurrentValue() throws IOException, InterruptedException
{    return currentValue;}
e6a44445685ea2b0efb4761e11c07379596d7cd89a49901e52b03fbe83285805
getProgress
public float getProgress() throws IOException, InterruptedException
{    return (float) current / total;}
800fb516a034f0f71d94e68b2f6dd1aaa44fb47184ec05cc5c3700e5dab53452
initialize
public void initialize(ParquetFileReader reader, ParquetReadOptions options)
{        Configuration conf = new Configuration();    if (options instanceof HadoopReadOptions) {        conf = ((HadoopReadOptions) options).getConf();    }    for (String property : options.getPropertyNames()) {        conf.set(property, options.getProperty(property));    }        this.reader = reader;    FileMetaData parquetFileMetadata = reader.getFooter().getFileMetaData();    this.fileSchema = parquetFileMetadata.getSchema();    Map<String, String> fileMetadata = parquetFileMetadata.getKeyValueMetaData();    ReadSupport.ReadContext readContext = readSupport.init(new InitContext(conf, toSetMultiMap(fileMetadata), fileSchema));    this.columnIOFactory = new ColumnIOFactory(parquetFileMetadata.getCreatedBy());    this.requestedSchema = readContext.getRequestedSchema();    this.columnCount = requestedSchema.getPaths().size();    this.recordConverter = readSupport.prepareForRead(conf, fileMetadata, fileSchema, readContext);    this.strictTypeChecking = options.isEnabled(STRICT_TYPE_CHECKING, true);    this.total = reader.getFilteredRecordCount();    this.unmaterializableRecordCounter = new UnmaterializableRecordCounter(options, total);    this.filterRecords = options.useRecordFilter();    reader.setRequestedSchema(requestedSchema);    LOG.info("RecordReader initialized will read a total of {} records.", total);}
58ff6594dc624e64497d3d82aa01e189fda9f43917c14e0c1ba6339c7f2a1d32
initialize
public void initialize(ParquetFileReader reader, Configuration configuration) throws IOException
{        this.reader = reader;    FileMetaData parquetFileMetadata = reader.getFooter().getFileMetaData();    this.fileSchema = parquetFileMetadata.getSchema();    Map<String, String> fileMetadata = parquetFileMetadata.getKeyValueMetaData();    ReadSupport.ReadContext readContext = readSupport.init(new InitContext(configuration, toSetMultiMap(fileMetadata), fileSchema));    this.columnIOFactory = new ColumnIOFactory(parquetFileMetadata.getCreatedBy());    this.requestedSchema = readContext.getRequestedSchema();    this.columnCount = requestedSchema.getPaths().size();    this.recordConverter = readSupport.prepareForRead(configuration, fileMetadata, fileSchema, readContext);    this.strictTypeChecking = configuration.getBoolean(STRICT_TYPE_CHECKING, true);    this.total = reader.getFilteredRecordCount();    this.unmaterializableRecordCounter = new UnmaterializableRecordCounter(configuration, total);    this.filterRecords = configuration.getBoolean(RECORD_FILTERING_ENABLED, true);    reader.setRequestedSchema(requestedSchema);    LOG.info("RecordReader initialized will read a total of {} records.", total);}
ea3a7eba5daf72a5cdc712e0c558af9956bcee4d2482e651bd64ac1a2c167657
nextKeyValue
public boolean nextKeyValue() throws IOException, InterruptedException
{    boolean recordFound = false;    while (!recordFound) {                if (current >= total) {            return false;        }        try {            checkRead();            current++;            try {                currentValue = recordReader.read();            } catch (RecordMaterializationException e) {                                unmaterializableRecordCounter.incErrors(e);                LOG.debug("skipping a corrupt record");                continue;            }            if (recordReader.shouldSkipCurrentRecord()) {                                LOG.debug("skipping record");                continue;            }            if (currentValue == null) {                                current = totalCountLoadedSoFar;                LOG.debug("filtered record reader reached end of block");                continue;            }            recordFound = true;            LOG.debug("read value: {}", currentValue);        } catch (RuntimeException e) {            throw new ParquetDecodingException(format("Can not read value at %d in block %d in file %s", current, currentBlock, reader.getPath()), e);        }    }    return true;}
1f6b49d79548cca7b17c7182c8ee3c98759ba038dbb387542c8ed6fc7dff0b20
toSetMultiMap
private static Map<K, Set<V>> toSetMultiMap(Map<K, V> map)
{    Map<K, Set<V>> setMultiMap = new HashMap<K, Set<V>>();    for (Map.Entry<K, V> entry : map.entrySet()) {        Set<V> set = new HashSet<V>();        set.add(entry.getValue());        setMultiMap.put(entry.getKey(), Collections.unmodifiableSet(set));    }    return Collections.unmodifiableMap(setMultiMap);}
4c5838da1bbb7f272d023072572656ee488689766654d779a053dc4e7986bc90
getFooter
public ParquetMetadata getFooter()
{    return parquetFileWriter.getFooter();}
2f3beb9243cba4a56fde65b5b0c987a8f988d42626bdaeb73f0c5101b75b1168
initStore
private void initStore()
{    pageStore = new ColumnChunkPageWriteStore(compressor, schema, props.getAllocator(), props.getColumnIndexTruncateLength(), props.getPageWriteChecksumEnabled());    columnStore = props.newColumnWriteStore(schema, pageStore);    MessageColumnIO columnIO = new ColumnIOFactory(validating).getColumnIO(schema);    this.recordConsumer = columnIO.getRecordWriter(columnStore);    writeSupport.prepareForWrite(recordConsumer);}
9e818b59b77b5db0779404d46b38169add768940d01946f18308e6833d14b082
close
public void close() throws IOException, InterruptedException
{    if (!closed) {        flushRowGroupToStore();        FinalizedWriteContext finalWriteContext = writeSupport.finalizeWrite();        Map<String, String> finalMetadata = new HashMap<String, String>(extraMetaData);        String modelName = writeSupport.getName();        if (modelName != null) {            finalMetadata.put(ParquetWriter.OBJECT_MODEL_NAME_PROP, modelName);        }        finalMetadata.putAll(finalWriteContext.getExtraMetaData());        parquetFileWriter.end(finalMetadata);        closed = true;    }}
960ed392f5f877778e34176ca85559e39e6e7b3702973496223be195ab3f649f
write
public void write(T value) throws IOException, InterruptedException
{    writeSupport.write(value);    ++recordCount;    checkBlockSizeReached();}
8b21c504b91af76d414f19385993fbd468bb14899ecb91a63f6f9d1f3eb58f84
getDataSize
public long getDataSize()
{    return lastRowGroupEndPos + columnStore.getBufferedSize();}
4807c3766afb028d74e29dc46d358e83414f52a804d24c68656cf0320bc65c0f
checkBlockSizeReached
private void checkBlockSizeReached() throws IOException
{    if (recordCount >= recordCountForNextMemCheck) {                long memSize = columnStore.getBufferedSize();        long recordSize = memSize / recordCount;                if (memSize > (nextRowGroupSize - 2 * recordSize)) {            LOG.debug("mem size {} > {}: flushing {} records to disk.", memSize, nextRowGroupSize, recordCount);            flushRowGroupToStore();            initStore();            recordCountForNextMemCheck = min(max(MINIMUM_RECORD_COUNT_FOR_CHECK, recordCount / 2), MAXIMUM_RECORD_COUNT_FOR_CHECK);            this.lastRowGroupEndPos = parquetFileWriter.getPos();        } else {            recordCountForNextMemCheck = min(            max(MINIMUM_RECORD_COUNT_FOR_CHECK, (recordCount + (long) (nextRowGroupSize / ((float) recordSize))) / 2),             recordCount + MAXIMUM_RECORD_COUNT_FOR_CHECK);            LOG.debug("Checked mem at {} will check again at: {}", recordCount, recordCountForNextMemCheck);        }    }}
3771bde12075efe127d97e51152723e5fcc073ff1a0d094b44aa27637d7ac432
flushRowGroupToStore
private void flushRowGroupToStore() throws IOException
{    recordConsumer.flush();    LOG.debug("Flushing mem columnStore to file. allocated memory: {}", columnStore.getAllocatedSize());    if (columnStore.getAllocatedSize() > (3 * rowGroupSizeThreshold)) {        LOG.warn("Too much memory used: {}", columnStore.memUsageString());    }    if (recordCount > 0) {        parquetFileWriter.startBlock(recordCount);        columnStore.flush();        pageStore.flushToFileWriter(parquetFileWriter);        recordCount = 0;        parquetFileWriter.endBlock();        this.nextRowGroupSize = Math.min(parquetFileWriter.getNextRowGroupSize(), rowGroupSizeThreshold);    }    columnStore = null;    pageStore = null;}
aa6d122987c2fd07c47f50318098654c88e7628da35cd5d3a393810a43b3524e
getRowGroupSizeThreshold
 long getRowGroupSizeThreshold()
{    return rowGroupSizeThreshold;}
b93011ca9f626b2d3f3dddae9039c2ed9d313ea8cfe5ca6edbf70c1388aa0ecb
setRowGroupSizeThreshold
 void setRowGroupSizeThreshold(long rowGroupSizeThreshold)
{    this.rowGroupSizeThreshold = rowGroupSizeThreshold;}
f66460cf433c789724e0f6e1a04e441db27b87e79af036e67f75fd22f8a4e136
getSchema
 MessageType getSchema()
{    return this.schema;}
d45bbb1a0bd889e8ad26bcf232562f2afddcbbb314e7b47be55050b5b378dfed
removeEldestEntry
public boolean removeEldestEntry(final Map.Entry<K, V> eldest)
{    boolean result = size() > maxSize;    if (result) {        if (LOG.isDebugEnabled()) {            LOG.debug("Removing eldest entry in cache: " + eldest.getKey());        }    }    return result;}
3e77e39766dadb28edbfa285d863bfb428a25cfd9404b798c125484e8782ffa6
remove
public V remove(final K key)
{    V oldValue = cacheMap.remove(key);    if (oldValue != null) {        LOG.debug("Removed cache entry for '{}'", key);    }    return oldValue;}
82d7d1863658e9f5a9ac10188744aa04e3036718df65d439ff65c4ce884600c5
put
public void put(final K key, final V newValue)
{    if (newValue == null || !newValue.isCurrent(key)) {        if (LOG.isWarnEnabled()) {            LOG.warn("Ignoring new cache entry for '{}' because it is {}", key, (newValue == null ? "null" : "not current"));        }        return;    }    V oldValue = cacheMap.get(key);    if (oldValue != null && oldValue.isNewerThan(newValue)) {        if (LOG.isWarnEnabled()) {            LOG.warn("Ignoring new cache entry for '{}' because " + "existing cache entry is newer", key);        }        return;    }        oldValue = cacheMap.put(key, newValue);    if (LOG.isDebugEnabled()) {        if (oldValue == null) {            LOG.debug("Added new cache entry for '{}'", key);        } else {            LOG.debug("Overwrote existing cache entry for '{}'", key);        }    }}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    cacheMap.clear();}
26f014f370473048636640c938600654a2a8d18e1a3b46694bebef4e708be634
getCurrentValue
public V getCurrentValue(final K key)
{    V value = cacheMap.get(key);    LOG.debug("Value for '{}' {} in cache", key, (value == null ? "not " : ""));    if (value != null && !value.isCurrent(key)) {                remove(key);        return null;    }    return value;}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return cacheMap.size();}
9bbe0c80ac650f520ff19fde5c12393f6d4f9d71770f14a0c405f96ddccce773
set
public void set(T object)
{    this.object = object;}
f92b71e18fa63d96cf2b628ad8520702b897423512edea5de9dd0e96f471f5ff
get
public T get()
{    return object;}
0b2d9d18dbcada0f4a9d867d537b243336ed755d324dd8c17adf344969a912c0
getRecordReader
public RecordReader<Void, Container<V>> getRecordReader(InputSplit split, JobConf job, Reporter reporter) throws IOException
{    return new RecordReaderWrapper<V>(split, job, reporter);}
35a8196735b6a7da1d97e4629186f6ea135c0eb69d3ed5f88193d2486a0dd34d
getSplits
public InputSplit[] getSplits(JobConf job, int numSplits) throws IOException
{    if (isTaskSideMetaData(job)) {        return super.getSplits(job, numSplits);    }    List<Footer> footers = getFooters(job);    List<ParquetInputSplit> splits = realInputFormat.getSplits(job, footers);    if (splits == null) {        return null;    }    InputSplit[] resultSplits = new InputSplit[splits.size()];    int i = 0;    for (ParquetInputSplit split : splits) {        resultSplits[i++] = new ParquetInputSplitWrapper(split);    }    return resultSplits;}
4556ce7068e619b1febce36a709831e72e3d8542fd141ffebe74c6d1d88cabbe
getFooters
public List<Footer> getFooters(JobConf job) throws IOException
{    return realInputFormat.getFooters(job, asList(super.listStatus(job)));}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    realReader.close();}
ab17e9bb26eedecd2ccbaf58c7b672205c1e41f638f1cfe6f44a1bbdc8c3b2fe
createKey
public Void createKey()
{    return null;}
69415e41f0b81accc3fe28c2b5c4a029beaa6a57db668ab9d632dcd792a1e2f1
createValue
public Container<V> createValue()
{    return valueContainer;}
5800a0f531c192e683ef74c0c5de6015daf6261d1f8e5c0ce6d8e043b01926c7
getPos
public long getPos() throws IOException
{    return (long) (splitLen * getProgress());}
46dc59cbf7e4d6aafe0869ef2726ed2c5c897b673d9e37f94ab9b0e962f65f7f
getProgress
public float getProgress() throws IOException
{    try {        return realReader.getProgress();    } catch (InterruptedException e) {        Thread.interrupted();        throw new IOException(e);    }}
bab88311d0b104b6371188065188da274d87a53bf0a37c86afbf4aa5449adf48
next
public boolean next(Void key, Container<V> value) throws IOException
{    if (eof) {        return false;    }    if (firstRecord) {                firstRecord = false;        return true;    }    try {        if (realReader.nextKeyValue()) {            if (value != null)                value.set(realReader.getCurrentValue());            return true;        }    } catch (InterruptedException e) {        throw new IOException(e);    }        eof = true;    return false;}
33ab83565a5ead06d0e8a715daa9c95a6bae4945f873fb40fb826ecea607b1c9
isTaskSideMetaData
public static boolean isTaskSideMetaData(JobConf job)
{    return job.getBoolean(ParquetInputFormat.TASK_SIDE_METADATA, TRUE);}
9cd3ad9bf4a05b331833c639755ae4f81500bf1da82c30049ab97309a4bb3d9f
getLength
public long getLength() throws IOException
{    return realSplit.getLength();}
09395a9599cab7bb2e1f34feff81cbbcfc81ea48b04f555c84abc6a47cf73117
getLocations
public String[] getLocations() throws IOException
{    return realSplit.getLocations();}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    realSplit = new ParquetInputSplit();    realSplit.readFields(in);}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    realSplit.write(out);}
45ea9512298520f9659699b61fd61e10fafb91673d1ebfbf8435f4775ba156f5
setWriteSupportClass
public static void setWriteSupportClass(Configuration configuration, Class<?> writeSupportClass)
{    configuration.set(ParquetOutputFormat.WRITE_SUPPORT_CLASS, writeSupportClass.getName());}
64aba4f4ae6f565f43c7de45cf2c48854c78b927cc412ac673c03f9a6407dddf
setBlockSize
public static void setBlockSize(Configuration configuration, int blockSize)
{    configuration.setInt(ParquetOutputFormat.BLOCK_SIZE, blockSize);}
df9a23a7644d10da1397bd3e5cdc32a223ea55039325996d95d5bceb62d169d2
setPageSize
public static void setPageSize(Configuration configuration, int pageSize)
{    configuration.setInt(ParquetOutputFormat.PAGE_SIZE, pageSize);}
11b8e2e5521753435942bf2a6145b2ab4505602e99aeff077a2fe7d856ed2808
setCompression
public static void setCompression(Configuration configuration, CompressionCodecName compression)
{    configuration.set(ParquetOutputFormat.COMPRESSION, compression.name());}
7b4e280c4232f00234ef6b2a3f7998f2a8b22d80c7f67eb6d7b2790370c43745
setEnableDictionary
public static void setEnableDictionary(Configuration configuration, boolean enableDictionary)
{    configuration.setBoolean(ParquetOutputFormat.ENABLE_DICTIONARY, enableDictionary);}
a21b3a193eedc6d3ded5c480a0e314dc7c7f88f8dd0561dc23f8a65201b19aeb
setAsOutputFormat
public static void setAsOutputFormat(JobConf jobConf)
{    jobConf.setOutputFormat(DeprecatedParquetOutputFormat.class);    jobConf.setOutputCommitter(MapredParquetOutputCommitter.class);}
8b3bd8d4aa4ccc20680aee78ca0562193506811df9c0d08ff6cec7abd54c8736
getCodec
private CompressionCodecName getCodec(final JobConf conf)
{    return CodecConfig.from(conf).getCodec();}
190de0f5c3ff1f6634e5c8fe5c8896c82a348a07a533b32f5cefe5850e1bdc82
getDefaultWorkFile
private static Path getDefaultWorkFile(JobConf conf, String name, String extension)
{    String file = getUniqueName(conf, name) + extension;    return new Path(getWorkOutputPath(conf), file);}
b45ab37e6c6eb1173aced376d1bb678c802bb340631dec35c4c0902acb48c779
getRecordWriter
public RecordWriter<Void, V> getRecordWriter(FileSystem fs, JobConf conf, String name, Progressable progress) throws IOException
{    return new RecordWriterWrapper(realOutputFormat, fs, conf, name, progress);}
d217b17bf131ccc7d63327b9a21715cc03224e14acdccb70a58b2ad62544d0f8
close
public void close(Reporter reporter) throws IOException
{    try {        realWriter.close(null);    } catch (InterruptedException e) {        Thread.interrupted();        throw new IOException(e);    }}
2d42893b1eae35c8897732c156c0e798577d6bef6a746dd26dcf421e0b8eeddf
write
public void write(Void key, V value) throws IOException
{    try {        realWriter.write(key, value);    } catch (InterruptedException e) {        Thread.interrupted();        throw new IOException(e);    }}
b198207eaa6c446cd4bba318df29406cd9f4af119151e41cda1f0fd4c2965905
commitJob
public void commitJob(JobContext jobContext) throws IOException
{    super.commitJob(jobContext);    Configuration conf = ContextUtil.getConfiguration(jobContext);    Path outputPath = FileOutputFormat.getOutputPath(new JobConf(conf));    ParquetOutputCommitter.writeMetaDataFile(conf, outputPath);}
398c9e9796fbddb4bdbc907f3863d356f35e40df396abfa314180a6fb7dc55eb
checkRatio
private void checkRatio(float ratio)
{    if (ratio <= 0 || ratio > 1) {        throw new IllegalArgumentException("The configured memory pool ratio " + ratio + " is " + "not between 0 and 1.");    }}
6fade83158b63265a7b8bb10ef89158e02dc23028d1a854b9badf3423daa630c
addWriter
 synchronized void addWriter(InternalParquetRecordWriter writer, Long allocation)
{    Long oldValue = writerList.get(writer);    if (oldValue == null) {        writerList.put(writer, allocation);    } else {        throw new IllegalArgumentException("[BUG] The Parquet Memory Manager should not add an " + "instance of InternalParquetRecordWriter more than once. The Manager already contains " + "the writer: " + writer);    }    updateAllocation();}
71937e2fe8e9ecf3bbe62b1f38051833ca954edc4d550a65368cf5a4919d2c2e
removeWriter
 synchronized void removeWriter(InternalParquetRecordWriter writer)
{    if (writerList.containsKey(writer)) {        writerList.remove(writer);    }    if (!writerList.isEmpty()) {        updateAllocation();    }}
5493b3ee33e00805be1f13804b6dd2c18da7e744e4895d966c8d8c9171a6ad7d
updateAllocation
private void updateAllocation()
{    long totalAllocations = 0;    for (Long allocation : writerList.values()) {        totalAllocations += allocation;    }    if (totalAllocations <= totalMemoryPool) {        scale = 1.0;    } else {        scale = (double) totalMemoryPool / totalAllocations;        LOG.warn(String.format("Total allocation exceeds %.2f%% (%,d bytes) of heap memory\n" + "Scaling row group sizes to %.2f%% for %d writers", 100 * memoryPoolRatio, totalMemoryPool, 100 * scale, writerList.size()));        for (Runnable callBack : callBacks.values()) {                        callBack.run();        }    }    int maxColCount = 0;    for (InternalParquetRecordWriter w : writerList.keySet()) {        maxColCount = Math.max(w.getSchema().getColumns().size(), maxColCount);    }    for (Map.Entry<InternalParquetRecordWriter, Long> entry : writerList.entrySet()) {        long newSize = (long) Math.floor(entry.getValue() * scale);        if (scale < 1.0 && minMemoryAllocation > 0 && newSize < minMemoryAllocation) {            throw new ParquetRuntimeException(String.format("New Memory allocation %d bytes" + " is smaller than the minimum allocation size of %d bytes.", newSize, minMemoryAllocation)) {            };        }        entry.getKey().setRowGroupSizeThreshold(newSize);        LOG.debug(String.format("Adjust block size from %,d to %,d for writer: %s", entry.getValue(), newSize, entry.getKey()));    }}
85a4f658f342548308b0339f2a87e23e85b955de351aa3e7af75ae71bb20543d
getTotalMemoryPool
 long getTotalMemoryPool()
{    return totalMemoryPool;}
aa0b24741f90a9745a537cdc2a73f1ab8fbce2ee0135e1207f09ee005b4b8256
getWriterList
 Map<InternalParquetRecordWriter, Long> getWriterList()
{    return writerList;}
5b078d2ffc0fcc597c7f65a8c40834156f33bc5b64d435ba939c362ccf52c871
getMemoryPoolRatio
 float getMemoryPoolRatio()
{    return memoryPoolRatio;}
f032963605c78a19ae2280edb259b9df977f63fd8495f996ee649bb596b2bd87
registerScaleCallBack
public void registerScaleCallBack(String callBackName, Runnable callBack)
{    Preconditions.checkNotNull(callBackName, "callBackName");    Preconditions.checkNotNull(callBack, "callBack");    if (callBacks.containsKey(callBackName)) {        throw new IllegalArgumentException("The callBackName " + callBackName + " is duplicated and has been registered already.");    } else {        callBacks.put(callBackName, callBack);    }}
9ddde78c58820299c25cccbf12c3df02b278c6decdebb9ac98c801fcd74b7862
getScaleCallBacks
 Map<String, Runnable> getScaleCallBacks()
{    return Collections.unmodifiableMap(callBacks);}
396c980cfbe558c3c9189cf5622a5db43f6f20d8838d1f23beef851c70d8edec
getScale
 double getScale()
{    return scale;}
de663c4293dc7b4649bc9588c013d3f165ef1bdb800ee63172ba8730f7b71d91
setPath
public void setPath(String path)
{    this.path = path;}
58e7b527ecd5014eaf5f30fc9c50ba33e1f005f8ce9d24246253d62377788662
getPath
public String getPath()
{    return path;}
a3384eda6088ab785128d7d88a9af55e07543a5e59774f8c7f30961ef025e4f5
getRowCount
public long getRowCount()
{    return rowCount;}
308581bdc5e3721fc3181dca557dd2516682513c6f1cf17dd48cb0d547412619
setRowCount
public void setRowCount(long rowCount)
{    this.rowCount = rowCount;}
c39679b45a43f68f95c33acdc41371eea0447ac469a8de909960742e12ae3e56
getTotalByteSize
public long getTotalByteSize()
{    return totalByteSize;}
244339c7f45792051792435197fa929d7c230f9d7674d6067794a7300806e384
setTotalByteSize
public void setTotalByteSize(long totalByteSize)
{    this.totalByteSize = totalByteSize;}
42411bf1f08a83b4fff1ddc0881dba0f599e01461794f76a4558b5a2a7758066
addColumn
public void addColumn(ColumnChunkMetaData column)
{    columns.add(column);}
3cc05d816db8f7f4b655899f0efb8f532a9c9b9de30234bb427929b50a8ccf29
getColumns
public List<ColumnChunkMetaData> getColumns()
{    return Collections.unmodifiableList(columns);}
a42e42c2204c176cc870d8a1ba25dde301bee50854461dd56af5a4076b8401f9
getStartingPos
public long getStartingPos()
{    return getColumns().get(0).getStartingPos();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "BlockMetaData{" + rowCount + ", " + totalByteSize + " " + columns + "}";}
3c25ac3ffcacf98e71ad7a0191c82c6ba04e5b1205e41e7d29ac22e45fc4823d
getCompressedSize
public long getCompressedSize()
{    long totalSize = 0;    for (ColumnChunkMetaData col : getColumns()) {        totalSize += col.getTotalSize();    }    return totalSize;}
494e4dd174bef862fe00b599fab49641a3056a39e0ef91e1f2e7cfaa2fbe294b
get
public static ColumnChunkMetaData get(ColumnPath path, PrimitiveTypeName type, CompressionCodecName codec, Set<Encoding> encodings, long firstDataPage, long dictionaryPageOffset, long valueCount, long totalSize, long totalUncompressedSize)
{    return get(path, type, codec, null, encodings, new BooleanStatistics(), firstDataPage, dictionaryPageOffset, valueCount, totalSize, totalUncompressedSize);}
6ac7085e5646bced7f8e6507432e9ea2b8a51d2658d9ffaf9b3b4f76394538c9
get
public static ColumnChunkMetaData get(ColumnPath path, PrimitiveTypeName type, CompressionCodecName codec, Set<Encoding> encodings, Statistics statistics, long firstDataPage, long dictionaryPageOffset, long valueCount, long totalSize, long totalUncompressedSize)
{    return get(path, type, codec, null, encodings, statistics, firstDataPage, dictionaryPageOffset, valueCount, totalSize, totalUncompressedSize);}
239c05a57e5f31138064ce640e8401f30b116cd0f72a6835728ea3bb25b45c1b
get
public static ColumnChunkMetaData get(ColumnPath path, PrimitiveTypeName type, CompressionCodecName codec, EncodingStats encodingStats, Set<Encoding> encodings, Statistics statistics, long firstDataPage, long dictionaryPageOffset, long valueCount, long totalSize, long totalUncompressedSize)
{    return get(path, Types.optional(type).named("fake_type"), codec, encodingStats, encodings, statistics, firstDataPage, dictionaryPageOffset, valueCount, totalSize, totalUncompressedSize);}
61d8a9423495b6dd76336ebd30ed6b359a034fc0c295c39714463f9780a3d200
get
public static ColumnChunkMetaData get(ColumnPath path, PrimitiveType type, CompressionCodecName codec, EncodingStats encodingStats, Set<Encoding> encodings, Statistics statistics, long firstDataPage, long dictionaryPageOffset, long valueCount, long totalSize, long totalUncompressedSize)
{        if (positiveLongFitsInAnInt(firstDataPage) && positiveLongFitsInAnInt(dictionaryPageOffset) && positiveLongFitsInAnInt(valueCount) && positiveLongFitsInAnInt(totalSize) && positiveLongFitsInAnInt(totalUncompressedSize)) {        return new IntColumnChunkMetaData(path, type, codec, encodingStats, encodings, statistics, firstDataPage, dictionaryPageOffset, valueCount, totalSize, totalUncompressedSize);    } else {        return new LongColumnChunkMetaData(path, type, codec, encodingStats, encodings, statistics, firstDataPage, dictionaryPageOffset, valueCount, totalSize, totalUncompressedSize);    }}
a42e42c2204c176cc870d8a1ba25dde301bee50854461dd56af5a4076b8401f9
getStartingPos
public long getStartingPos()
{    long dictionaryPageOffset = getDictionaryPageOffset();    long firstDataPageOffset = getFirstDataPageOffset();    if (dictionaryPageOffset > 0 && dictionaryPageOffset < firstDataPageOffset) {                return dictionaryPageOffset;    }    return firstDataPageOffset;}
2a3e438c562097d362f597e6c87853f625ee3664a9dc8bb9dea3e48511ac9d93
positiveLongFitsInAnInt
protected static boolean positiveLongFitsInAnInt(long value)
{    return (value >= 0) && (value + Integer.MIN_VALUE <= Integer.MAX_VALUE);}
97315572e15d9bef04873ede716a96cee64f8c288ea74350948b3adaa0166ea6
getCodec
public CompressionCodecName getCodec()
{    return properties.getCodec();}
70456e9352ad9b15d8a761269863fb8426ea62a91dc397eae6744d14eb1f8655
getPath
public ColumnPath getPath()
{    return properties.getPath();}
33863a388ceaa73f61f42ed255644025c13814df9196ccfe0d910ea0eaa4c759
getType
public PrimitiveTypeName getType()
{    return properties.getType();}
dd7ba3358cd4c70fde4174e96da32193c06dbf7a02da2ad4e78d38a9f53e7065
getPrimitiveType
public PrimitiveType getPrimitiveType()
{    return properties.getPrimitiveType();}
27ed432dbc47685213751ee3f03dfde310205aee7350c3e183bf927bdbb9cd96
getColumnIndexReference
public IndexReference getColumnIndexReference()
{    return columnIndexReference;}
ce278ba7930f9dab4acd79d369f90aecfcf24bfa201a9212627a179ba90c6022
setColumnIndexReference
public void setColumnIndexReference(IndexReference indexReference)
{    this.columnIndexReference = indexReference;}
e872a3f95d301fbbd5899c1ea3a668e4e5d9d56f90b7abf6d05011fc76ce136e
getOffsetIndexReference
public IndexReference getOffsetIndexReference()
{    return offsetIndexReference;}
a38c4fe34d3e9ab5e8a3ba8e40c707c641e5ea44d858f9907d6851462b0ade11
setOffsetIndexReference
public void setOffsetIndexReference(IndexReference offsetIndexReference)
{    this.offsetIndexReference = offsetIndexReference;}
35f49115bd7a10012a14d57678d10e9fcb28e57320a41d9bafd4d458e92e25e4
getEncodings
public Set<Encoding> getEncodings()
{    return properties.getEncodings();}
75ac267782eb5754d0c22621abaccffe35f04d53ea55526c6fd3a55d39ba6318
getEncodingStats
public EncodingStats getEncodingStats()
{    return encodingStats;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "ColumnMetaData{" + properties.toString() + ", " + getFirstDataPageOffset() + "}";}
d8d1a2c7033e600dcc02cfec2a8c9f98a19d40511edaa9bea184d7fa59ca38cd
positiveLongToInt
private int positiveLongToInt(long value)
{    if (!ColumnChunkMetaData.positiveLongFitsInAnInt(value)) {        throw new IllegalArgumentException("value should be positive and fit in an int: " + value);    }    return (int) (value + Integer.MIN_VALUE);}
e22b2d41d0f7a56c73e33be4ff21ac8541a96969de3c00725bb7ad3164196a69
intToPositiveLong
private long intToPositiveLong(int value)
{    return (long) value - Integer.MIN_VALUE;}
cafac9e99e4579b5de2375c2943fa898ece23226ccb00083c0bd0ad78b53ac82
getFirstDataPageOffset
public long getFirstDataPageOffset()
{    return intToPositiveLong(firstDataPage);}
a86520826b5a4a1e794db10f64ee2657806f44f57d451fc02bc27654acaeaa1a
getDictionaryPageOffset
public long getDictionaryPageOffset()
{    return intToPositiveLong(dictionaryPageOffset);}
5a6b403cd13e9e34deceabc4def2696e9fbc043afc129a50c2e284fba243f8a4
getValueCount
public long getValueCount()
{    return intToPositiveLong(valueCount);}
d04d4efd9e78418e1844e7525f4b9c614ec58e4c9c98197b0a50e831b83f470d
getTotalUncompressedSize
public long getTotalUncompressedSize()
{    return intToPositiveLong(totalUncompressedSize);}
982a574ee7d5b22204504e267aa459747a7a897bed95e71e0e1e570248ef716a
getTotalSize
public long getTotalSize()
{    return intToPositiveLong(totalSize);}
5a4d75a976af2c02b3f67819990cb04d33e5b4209422e144ab64d16b815fb5ea
getStatistics
public Statistics getStatistics()
{    return statistics;}
cafac9e99e4579b5de2375c2943fa898ece23226ccb00083c0bd0ad78b53ac82
getFirstDataPageOffset
public long getFirstDataPageOffset()
{    return firstDataPageOffset;}
a86520826b5a4a1e794db10f64ee2657806f44f57d451fc02bc27654acaeaa1a
getDictionaryPageOffset
public long getDictionaryPageOffset()
{    return dictionaryPageOffset;}
5a6b403cd13e9e34deceabc4def2696e9fbc043afc129a50c2e284fba243f8a4
getValueCount
public long getValueCount()
{    return valueCount;}
d04d4efd9e78418e1844e7525f4b9c614ec58e4c9c98197b0a50e831b83f470d
getTotalUncompressedSize
public long getTotalUncompressedSize()
{    return totalUncompressedSize;}
982a574ee7d5b22204504e267aa459747a7a897bed95e71e0e1e570248ef716a
getTotalSize
public long getTotalSize()
{    return totalSize;}
5a4d75a976af2c02b3f67819990cb04d33e5b4209422e144ab64d16b815fb5ea
getStatistics
public Statistics getStatistics()
{    return statistics;}
b5040d888a2aeb652755f6d547d66bc019c6093f698726edb38532bc8b6fbca0
get
public static ColumnChunkProperties get(ColumnPath path, PrimitiveTypeName type, CompressionCodecName codec, Set<Encoding> encodings)
{    return get(path, new PrimitiveType(Type.Repetition.OPTIONAL, type, ""), codec, encodings);}
7b09e5a39dce4a5cb653a5a6bd673143a1b444396d90daabeb3f830301bfef3e
get
public static ColumnChunkProperties get(ColumnPath path, PrimitiveType type, CompressionCodecName codec, Set<Encoding> encodings)
{    return properties.canonicalize(new ColumnChunkProperties(codec, path, type, encodings));}
97315572e15d9bef04873ede716a96cee64f8c288ea74350948b3adaa0166ea6
getCodec
public CompressionCodecName getCodec()
{    return codec;}
70456e9352ad9b15d8a761269863fb8426ea62a91dc397eae6744d14eb1f8655
getPath
public ColumnPath getPath()
{    return path;}
33863a388ceaa73f61f42ed255644025c13814df9196ccfe0d910ea0eaa4c759
getType
public PrimitiveTypeName getType()
{    return type.getPrimitiveTypeName();}
dd7ba3358cd4c70fde4174e96da32193c06dbf7a02da2ad4e78d38a9f53e7065
getPrimitiveType
public PrimitiveType getPrimitiveType()
{    return type;}
35f49115bd7a10012a14d57678d10e9fcb28e57320a41d9bafd4d458e92e25e4
getEncodings
public Set<Encoding> getEncodings()
{    return encodings;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (obj instanceof ColumnChunkProperties) {        ColumnChunkProperties other = (ColumnChunkProperties) obj;        return other.codec == codec && other.path.equals(path) && other.type.equals(type) && equals(other.encodings, encodings);    }    return false;}
b94d3a2bc90f1e40f113c65ff18ba760fa8ee99816afa3fb81017f4600a3d1cc
equals
private boolean equals(Set<Encoding> a, Set<Encoding> b)
{    return a.size() == b.size() && a.containsAll(b);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return codec.hashCode() ^ path.hashCode() ^ type.hashCode() ^ Arrays.hashCode(encodings.toArray());}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return codec + " " + path + " " + type + "  " + encodings;}
4a2d02d2475bc947cac384a3dc36535c6053905241ec87d845780b7de8db9d67
getEncodingList
public static EncodingList getEncodingList(List<Encoding> encodings)
{    return encodingLists.canonicalize(new EncodingList(encodings));}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (obj instanceof EncodingList) {        List<org.apache.parquet.column.Encoding> other = ((EncodingList) obj).encodings;        final int size = other.size();        if (size != encodings.size()) {            return false;        }        for (int i = 0; i < size; i++) {            if (!other.get(i).equals(encodings.get(i))) {                return false;            }        }        return true;    }    return false;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = 1;    for (org.apache.parquet.column.Encoding element : encodings) result = 31 * result + (element == null ? 0 : element.hashCode());    return result;}
67547050d0a9243df5c516ac56ad700585e8023ea7a11547e3caa5ffe3412141
toList
public List<Encoding> toList()
{    return encodings;}
894e29c6877506a5cb3da677a1e1d5ff212c15bc747531980c77584a26d5a6d5
iterator
public Iterator<Encoding> iterator()
{    return encodings.iterator();}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return encodings.size();}
8f20f33637bcf9d39a2a75cabdc1285e8da4037865fa2ea3eb9e9ca74be7a311
getSchema
public MessageType getSchema()
{    return schema;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "FileMetaData{schema: " + schema + ", metadata: " + keyValueMetaData + "}";}
6d636b406713ec5d2ecf3d139d30035be4775b16164b07b523b29f76e35ee3e8
getKeyValueMetaData
public Map<String, String> getKeyValueMetaData()
{    return keyValueMetaData;}
7afbd63304efd4f498b55ba4dbbae1919b9588564426efa3f5968a141bfa291f
getCreatedBy
public String getCreatedBy()
{    return createdBy;}
8f20f33637bcf9d39a2a75cabdc1285e8da4037865fa2ea3eb9e9ca74be7a311
getSchema
public MessageType getSchema()
{    return schema;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "GlobalMetaData{schema: " + schema + ", metadata: " + keyValueMetaData + "}";}
e7add2133a0af5d91bcc2e517a07785e98e8008a9579fa685e669c76ba5e4950
getKeyValueMetaData
public Map<String, Set<String>> getKeyValueMetaData()
{    return keyValueMetaData;}
2a7213bf4c5c0216083e2a9942c9f5162116f2a445e1290df3cc03ce8229bf7e
getCreatedBy
public Set<String> getCreatedBy()
{    return createdBy;}
5816a5fe9bb6677443c38e8269b7adfce83da3f41cf5aa4ba8fface80204f10d
merge
public FileMetaData merge()
{    String createdByString = createdBy.size() == 1 ? createdBy.iterator().next() : createdBy.toString();    Map<String, String> mergedKeyValues = new HashMap<String, String>();    for (Entry<String, Set<String>> entry : keyValueMetaData.entrySet()) {        if (entry.getValue().size() > 1) {            throw new RuntimeException("could not merge metadata: key " + entry.getKey() + " has conflicting values: " + entry.getValue());        }        mergedKeyValues.put(entry.getKey(), entry.getValue().iterator().next());    }    return new FileMetaData(schema, mergedKeyValues, createdByString);}
e80d38d2b74a96b3194451a2c956a566d791d282f3790e9e14a2d41475e89aef
toJSON
public static String toJSON(ParquetMetadata parquetMetaData)
{    return toJSON(parquetMetaData, false);}
79afd631cf595288bc5372bd9f622b2a6f0a0b3ccc062ac2c935f906f8c3ff12
toPrettyJSON
public static String toPrettyJSON(ParquetMetadata parquetMetaData)
{    return toJSON(parquetMetaData, true);}
7e7aec13e3c023b9861b5b9e7f8a9088c02e0bef5c82b4d293717d736837eee0
toJSON
private static String toJSON(ParquetMetadata parquetMetaData, boolean isPrettyPrint)
{    StringWriter stringWriter = new StringWriter();    try {        if (isPrettyPrint) {            objectMapper.writerWithDefaultPrettyPrinter().writeValue(stringWriter, parquetMetaData);        } else {            objectMapper.writeValue(stringWriter, parquetMetaData);        }    } catch (JsonGenerationException e) {        throw new RuntimeException(e);    } catch (JsonMappingException e) {        throw new RuntimeException(e);    } catch (IOException e) {        throw new RuntimeException(e);    }    return stringWriter.toString();}
f7513904843848d8881b1fa58e0553b6d0d4cd491ab245527c57e8146e53734f
fromJSON
public static ParquetMetadata fromJSON(String json)
{    try {        return objectMapper.readValue(new StringReader(json), ParquetMetadata.class);    } catch (JsonParseException e) {        throw new RuntimeException(e);    } catch (JsonMappingException e) {        throw new RuntimeException(e);    } catch (IOException e) {        throw new RuntimeException(e);    }}
332c9204c807e91c856e0b541640b1a316868dfe73d3bca672055592d33786d5
getBlocks
public List<BlockMetaData> getBlocks()
{    return blocks;}
215eb7d7af83a0b24d361205c025846409eada7d08221bbd36d3a4c1bf447c5d
getFileMetaData
public FileMetaData getFileMetaData()
{    return fileMetaData;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "ParquetMetaData{" + fileMetaData + ", blocks: " + blocks + "}";}
be09e4db5c9edece9c1771c4ee6558ee214a12040bb187da9f4eb96783b9d984
readAllFootersInParallelUsingSummaryFiles
public static List<Footer> readAllFootersInParallelUsingSummaryFiles(Configuration configuration, List<FileStatus> partFiles) throws IOException
{    return readAllFootersInParallelUsingSummaryFiles(configuration, partFiles, false);}
22bad07e322cead3e692e1d943630cc811c3c01e665aec41963936b66bc1e8a7
filter
private static MetadataFilter filter(boolean skipRowGroups)
{    return skipRowGroups ? SKIP_ROW_GROUPS : NO_FILTER;}
a16f0852743010658306b83701f7a6e3576c7726aced3cc3baf92ff0caf459eb
readAllFootersInParallelUsingSummaryFiles
public static List<Footer> readAllFootersInParallelUsingSummaryFiles(final Configuration configuration, final Collection<FileStatus> partFiles, final boolean skipRowGroups) throws IOException
{        Set<Path> parents = new HashSet<Path>();    for (FileStatus part : partFiles) {        parents.add(part.getPath().getParent());    }        List<Callable<Map<Path, Footer>>> summaries = new ArrayList<Callable<Map<Path, Footer>>>();    for (final Path path : parents) {        summaries.add(() -> {            ParquetMetadata mergedMetadata = readSummaryMetadata(configuration, path, skipRowGroups);            if (mergedMetadata != null) {                final List<Footer> footers;                if (skipRowGroups) {                    footers = new ArrayList<Footer>();                    for (FileStatus f : partFiles) {                        footers.add(new Footer(f.getPath(), mergedMetadata));                    }                } else {                    footers = footersFromSummaryFile(path, mergedMetadata);                }                Map<Path, Footer> map = new HashMap<Path, Footer>();                for (Footer footer : footers) {                                        footer = new Footer(new Path(path, footer.getFile().getName()), footer.getParquetMetadata());                    map.put(footer.getFile(), footer);                }                return map;            } else {                return Collections.emptyMap();            }        });    }    Map<Path, Footer> cache = new HashMap<Path, Footer>();    try {        List<Map<Path, Footer>> footersFromSummaries = runAllInParallel(configuration.getInt(PARQUET_READ_PARALLELISM, 5), summaries);        for (Map<Path, Footer> footers : footersFromSummaries) {            cache.putAll(footers);        }    } catch (ExecutionException e) {        throw new IOException("Error reading summaries", e);    }        List<Footer> result = new ArrayList<Footer>(partFiles.size());    List<FileStatus> toRead = new ArrayList<FileStatus>();    for (FileStatus part : partFiles) {        Footer f = cache.get(part.getPath());        if (f != null) {            result.add(f);        } else {            toRead.add(part);        }    }    if (toRead.size() > 0) {                LOG.info("reading another {} footers", toRead.size());        result.addAll(readAllFootersInParallel(configuration, toRead, skipRowGroups));    }    return result;}
f945781b7df0eda6d5f8fdc2541b63f9f7fe2a76e46ce31ee10c4cae6ceebfad
runAllInParallel
private static List<T> runAllInParallel(int parallelism, List<Callable<T>> toRun) throws ExecutionException
{    LOG.info("Initiating action with parallelism: {}", parallelism);    ExecutorService threadPool = Executors.newFixedThreadPool(parallelism);    try {        List<Future<T>> futures = new ArrayList<Future<T>>();        for (Callable<T> callable : toRun) {            futures.add(threadPool.submit(callable));        }        List<T> result = new ArrayList<T>(toRun.size());        for (Future<T> future : futures) {            try {                result.add(future.get());            } catch (InterruptedException e) {                throw new RuntimeException("The thread was interrupted", e);            }        }        return result;    } finally {        threadPool.shutdownNow();    }}
31663d8493dde6e9ddb28e7f5592f6fca5283551cf4cd570b3ed220261efee27
readAllFootersInParallel
public static List<Footer> readAllFootersInParallel(final Configuration configuration, List<FileStatus> partFiles) throws IOException
{    return readAllFootersInParallel(configuration, partFiles, false);}
f8b610c7ae6629154f0bf9b5d41983fba4bbb302974ab6d1ea00bafbe8073969
readAllFootersInParallel
public static List<Footer> readAllFootersInParallel(final Configuration configuration, List<FileStatus> partFiles, final boolean skipRowGroups) throws IOException
{    List<Callable<Footer>> footers = new ArrayList<Callable<Footer>>();    for (final FileStatus currentFile : partFiles) {        footers.add(() -> {            try {                return new Footer(currentFile.getPath(), readFooter(configuration, currentFile, filter(skipRowGroups)));            } catch (IOException e) {                throw new IOException("Could not read footer for file " + currentFile, e);            }        });    }    try {        return runAllInParallel(configuration.getInt(PARQUET_READ_PARALLELISM, 5), footers);    } catch (ExecutionException e) {        throw new IOException("Could not read footer: " + e.getMessage(), e.getCause());    }}
4b4a63521f9eca0ac8141bda3e4986fa9e661e786583b5c7fe05679c0e3dc912
readAllFootersInParallel
public static List<Footer> readAllFootersInParallel(Configuration configuration, FileStatus fileStatus, boolean skipRowGroups) throws IOException
{    List<FileStatus> statuses = listFiles(configuration, fileStatus);    return readAllFootersInParallel(configuration, statuses, skipRowGroups);}
e65106f64a869984c40673e0ef3163a601d321f48c41930e0816400860578230
readAllFootersInParallel
public static List<Footer> readAllFootersInParallel(Configuration configuration, FileStatus fileStatus) throws IOException
{    return readAllFootersInParallel(configuration, fileStatus, false);}
892c1f82f21f3828caf4d1fe53a092b8bb900acb6c4a802265c57ccc8defc12a
readFooters
public static List<Footer> readFooters(Configuration configuration, Path path) throws IOException
{    return readFooters(configuration, status(configuration, path));}
9fabb0a5bcc6dbf153ca36eba15e0bfcfe18e8d764ea73c0b9c92f74454a4809
status
private static FileStatus status(Configuration configuration, Path path) throws IOException
{    return path.getFileSystem(configuration).getFileStatus(path);}
bca44672c537017ed19e8224f78f59a6395a9bc77d4001a9807a99768fb21491
readFooters
public static List<Footer> readFooters(Configuration configuration, FileStatus pathStatus) throws IOException
{    return readFooters(configuration, pathStatus, false);}
73ef5a806ab44bc89c4d33922d27d6d2bc943049a9e2bd1fdddba1219a03410f
readFooters
public static List<Footer> readFooters(Configuration configuration, FileStatus pathStatus, boolean skipRowGroups) throws IOException
{    List<FileStatus> files = listFiles(configuration, pathStatus);    return readAllFootersInParallelUsingSummaryFiles(configuration, files, skipRowGroups);}
d0daad7456b3688a34383d4f0d7b9f5588efe97902b4801f0cc6360eccc984c9
listFiles
private static List<FileStatus> listFiles(Configuration conf, FileStatus fileStatus) throws IOException
{    if (fileStatus.isDir()) {        FileSystem fs = fileStatus.getPath().getFileSystem(conf);        FileStatus[] list = fs.listStatus(fileStatus.getPath(), HiddenFileFilter.INSTANCE);        List<FileStatus> result = new ArrayList<FileStatus>();        for (FileStatus sub : list) {            result.addAll(listFiles(conf, sub));        }        return result;    } else {        return Arrays.asList(fileStatus);    }}
4067597bf8ba4e57a75c2704cc1fe74a670140e8dc91c7f4e838a387c0c12add
readSummaryFile
public static List<Footer> readSummaryFile(Configuration configuration, FileStatus summaryStatus) throws IOException
{    final Path parent = summaryStatus.getPath().getParent();    ParquetMetadata mergedFooters = readFooter(configuration, summaryStatus, filter(false));    return footersFromSummaryFile(parent, mergedFooters);}
13d13057968971550e6a9c400e1c6028b43bbc304b68adea293b449033298953
readSummaryMetadata
 static ParquetMetadata readSummaryMetadata(Configuration configuration, Path basePath, boolean skipRowGroups) throws IOException
{    Path metadataFile = new Path(basePath, PARQUET_METADATA_FILE);    Path commonMetaDataFile = new Path(basePath, PARQUET_COMMON_METADATA_FILE);    FileSystem fileSystem = basePath.getFileSystem(configuration);    if (skipRowGroups && fileSystem.exists(commonMetaDataFile)) {                LOG.info("reading summary file: {}", commonMetaDataFile);        return readFooter(configuration, commonMetaDataFile, filter(skipRowGroups));    } else if (fileSystem.exists(metadataFile)) {        LOG.info("reading summary file: {}", metadataFile);        return readFooter(configuration, metadataFile, filter(skipRowGroups));    } else {        return null;    }}
ec05dc3c4feaea2879e593d24b828163f4aafea574a92abcc59c2a642b854b33
footersFromSummaryFile
 static List<Footer> footersFromSummaryFile(final Path parent, ParquetMetadata mergedFooters)
{    Map<Path, ParquetMetadata> footers = new HashMap<Path, ParquetMetadata>();    List<BlockMetaData> blocks = mergedFooters.getBlocks();    for (BlockMetaData block : blocks) {        String path = block.getPath();        Path fullPath = new Path(parent, path);        ParquetMetadata current = footers.get(fullPath);        if (current == null) {            current = new ParquetMetadata(mergedFooters.getFileMetaData(), new ArrayList<BlockMetaData>());            footers.put(fullPath, current);        }        current.getBlocks().add(block);    }    List<Footer> result = new ArrayList<Footer>();    for (Entry<Path, ParquetMetadata> entry : footers.entrySet()) {        result.add(new Footer(entry.getKey(), entry.getValue()));    }    return result;}
5cee59cf6280036e072ccc4caf641e35b47c55e92cd0b1b737bdf2d8906b5a85
readFooter
public static final ParquetMetadata readFooter(Configuration configuration, Path file) throws IOException
{    return readFooter(configuration, file, NO_FILTER);}
158547d6026976aa585cbee605fc36263e5ccb0c1dcf316a7ee95644897f0d08
readFooter
public static ParquetMetadata readFooter(Configuration configuration, Path file, MetadataFilter filter) throws IOException
{    return readFooter(HadoopInputFile.fromPath(file, configuration), filter);}
d22f15b9201a7f1de10197fc20ab3e0f3bd9a456b75d3e437f8d9ade34033313
readFooter
public static final ParquetMetadata readFooter(Configuration configuration, FileStatus file) throws IOException
{    return readFooter(configuration, file, NO_FILTER);}
00d145baee7b9bb3f986ce94b7e54e4fa3670db33303c69166e7af9e093e55fb
readFooter
public static final ParquetMetadata readFooter(Configuration configuration, FileStatus file, MetadataFilter filter) throws IOException
{    return readFooter(HadoopInputFile.fromStatus(file, configuration), filter);}
410772c8c5c4954fa9d167bd8ce663a95ca0eeac352709fbe25141c015ef6e2a
readFooter
public static final ParquetMetadata readFooter(InputFile file, MetadataFilter filter) throws IOException
{    ParquetReadOptions options;    if (file instanceof HadoopInputFile) {        options = HadoopReadOptions.builder(((HadoopInputFile) file).getConfiguration()).withMetadataFilter(filter).build();    } else {        options = ParquetReadOptions.builder().withMetadataFilter(filter).build();    }    try (SeekableInputStream in = file.newStream()) {        return readFooter(file, options, in);    }}
ea9de7e44231d0571c1fa2bac8fc1c43e469e04b8b6311a9ae80353f1fc41f59
readFooter
private static final ParquetMetadata readFooter(InputFile file, ParquetReadOptions options, SeekableInputStream f) throws IOException
{    ParquetMetadataConverter converter = new ParquetMetadataConverter(options);    return readFooter(file, options, f, converter);}
f5f2df13e57154ab57ce511ba3782bc82bd4045aba1be80e92e931077db0e544
readFooter
private static final ParquetMetadata readFooter(InputFile file, ParquetReadOptions options, SeekableInputStream f, ParquetMetadataConverter converter) throws IOException
{    long fileLen = file.getLength();    String filePath = file.toString();    LOG.debug("File length {}", fileLen);    int FOOTER_LENGTH_SIZE = 4;    if (fileLen < MAGIC.length + FOOTER_LENGTH_SIZE + MAGIC.length) {                throw new RuntimeException(filePath + " is not a Parquet file (too small length: " + fileLen + ")");    }    long footerLengthIndex = fileLen - FOOTER_LENGTH_SIZE - MAGIC.length;    LOG.debug("reading footer index at {}", footerLengthIndex);    f.seek(footerLengthIndex);    int footerLength = readIntLittleEndian(f);    byte[] magic = new byte[MAGIC.length];    f.readFully(magic);    if (!Arrays.equals(MAGIC, magic)) {        throw new RuntimeException(filePath + " is not a Parquet file. expected magic number at tail " + Arrays.toString(MAGIC) + " but found " + Arrays.toString(magic));    }    long footerIndex = footerLengthIndex - footerLength;    LOG.debug("read footer length: {}, footer index: {}", footerLength, footerIndex);    if (footerIndex < MAGIC.length || footerIndex >= footerLengthIndex) {        throw new RuntimeException("corrupted file: the footer index is not within the file: " + footerIndex);    }    f.seek(footerIndex);            ByteBuffer footerBytesBuffer = ByteBuffer.allocate(footerLength);    f.readFully(footerBytesBuffer);    LOG.debug("Finished to read all footer bytes.");    footerBytesBuffer.flip();    InputStream footerBytesStream = ByteBufferInputStream.wrap(footerBytesBuffer);    return converter.readParquetMetadata(footerBytesStream, options.getMetadataFilter());}
3be67f14db720453acc3849945e37a60fde3eaaa06bece160187f44e4eaac8f7
open
public static ParquetFileReader open(Configuration conf, Path file) throws IOException
{    return new ParquetFileReader(HadoopInputFile.fromPath(file, conf), HadoopReadOptions.builder(conf).build());}
8c2067faf80cd24b1ad064c5b8f72f372998e3ea16d0081e65bc75a0ee205ef6
open
public static ParquetFileReader open(Configuration conf, Path file, MetadataFilter filter) throws IOException
{    return open(HadoopInputFile.fromPath(file, conf), HadoopReadOptions.builder(conf).withMetadataFilter(filter).build());}
398a01f8c690287784b422871f4be4d0cf19b3dcd59a28a05fedb7616cb8656e
open
public static ParquetFileReader open(Configuration conf, Path file, ParquetMetadata footer) throws IOException
{    return new ParquetFileReader(conf, file, footer);}
616d2183840dbbb78b6965d480dda92d9164db0b974433c33ead605c881f6a7b
open
public static ParquetFileReader open(InputFile file) throws IOException
{    return new ParquetFileReader(file, ParquetReadOptions.builder().build());}
dbf0f09a2ba9fdaff237cb4c6b20b0a9949b8f4ad0644726a37962c2eec2de00
open
public static ParquetFileReader open(InputFile file, ParquetReadOptions options) throws IOException
{    return new ParquetFileReader(file, options);}
a8d0634f5e78e5eedb714e775ce9484c9b62a9660674f7e3a03bedb05c730f72
listWithNulls
private static List<T> listWithNulls(int size)
{    return Stream.generate(() -> (T) null).limit(size).collect(Collectors.toCollection(ArrayList<T>::new));}
4c5838da1bbb7f272d023072572656ee488689766654d779a053dc4e7986bc90
getFooter
public ParquetMetadata getFooter()
{    if (footer == null) {        try {                        this.footer = readFooter(file, options, f, converter);        } catch (IOException e) {            throw new ParquetDecodingException("Unable to read file footer", e);        }    }    return footer;}
215eb7d7af83a0b24d361205c025846409eada7d08221bbd36d3a4c1bf447c5d
getFileMetaData
public FileMetaData getFileMetaData()
{    if (fileMetaData != null) {        return fileMetaData;    }    return getFooter().getFileMetaData();}
d38161c55824dafb889fadbffce0d88779c15d28a770d3ff0ea995f178d5d229
getRecordCount
public long getRecordCount()
{    long total = 0;    for (BlockMetaData block : blocks) {        total += block.getRowCount();    }    return total;}
80c05fc79ca05d457b078083c51ba93277dff906f647e08ee272e6e6341e5bfb
getFilteredRecordCount
 long getFilteredRecordCount()
{    if (!options.useColumnIndexFilter()) {        return getRecordCount();    }    long total = 0;    for (int i = 0, n = blocks.size(); i < n; ++i) {        total += getRowRanges(i).rowCount();    }    return total;}
8db7848085b680ef314213a1bef8feee4e1decb8072466d9168d74d75362d8fb
getPath
public Path getPath()
{    return new Path(file.toString());}
92a6ab87664e4a7e0434e20cf1b027d326dfeb4fa2c812de70c20d919017967a
getFile
public String getFile()
{    return file.toString();}
8a1e3addf96dbe637bf2deee992be4a4eb02f3693b993751d012b831cad6916e
filterRowGroups
private List<BlockMetaData> filterRowGroups(List<BlockMetaData> blocks) throws IOException
{        List<RowGroupFilter.FilterLevel> levels = new ArrayList<>();    if (options.useStatsFilter()) {        levels.add(STATISTICS);    }    if (options.useDictionaryFilter()) {        levels.add(DICTIONARY);    }    FilterCompat.Filter recordFilter = options.getRecordFilter();    if (recordFilter != null) {        return RowGroupFilter.filterRowGroups(levels, recordFilter, blocks, this);    }    return blocks;}
5f76a38992abc58acf276b34a3cf66dcce0cdab2d6cf845420ad7870f0a576a3
getRowGroups
public List<BlockMetaData> getRowGroups()
{    return blocks;}
c0ea8d127fdec7f7693fbe51ea89b96c8db9ba2da991e562b67223aed77995bf
setRequestedSchema
public void setRequestedSchema(MessageType projection)
{    paths.clear();    for (ColumnDescriptor col : projection.getColumns()) {        paths.put(ColumnPath.get(col.getPath()), col);    }}
37af7c6ef846225c2f1837f3f2e3cf083af4e06a8ae552ea32efae9bc72c3d14
appendTo
public void appendTo(ParquetFileWriter writer) throws IOException
{    writer.appendRowGroups(f, blocks, true);}
0771934158e4d8565566284c23d8be391ff01f199e9fba664bac49c201612bd1
readNextRowGroup
public PageReadStore readNextRowGroup() throws IOException
{    if (currentBlock == blocks.size()) {        return null;    }    BlockMetaData block = blocks.get(currentBlock);    if (block.getRowCount() == 0) {        throw new RuntimeException("Illegal row group of 0 rows");    }    this.currentRowGroup = new ColumnChunkPageReadStore(block.getRowCount());        List<ConsecutivePartList> allParts = new ArrayList<ConsecutivePartList>();    ConsecutivePartList currentParts = null;    for (ColumnChunkMetaData mc : block.getColumns()) {        ColumnPath pathKey = mc.getPath();        BenchmarkCounter.incrementTotalBytes(mc.getTotalSize());        ColumnDescriptor columnDescriptor = paths.get(pathKey);        if (columnDescriptor != null) {            long startingPos = mc.getStartingPos();                        if (currentParts == null || currentParts.endPos() != startingPos) {                currentParts = new ConsecutivePartList(startingPos);                allParts.add(currentParts);            }            currentParts.addChunk(new ChunkDescriptor(columnDescriptor, mc, startingPos, (int) mc.getTotalSize()));        }    }        ChunkListBuilder builder = new ChunkListBuilder();    for (ConsecutivePartList consecutiveChunks : allParts) {        consecutiveChunks.readAll(f, builder);    }    for (Chunk chunk : builder.build()) {        currentRowGroup.addColumn(chunk.descriptor.col, chunk.readAllPages());    }        if (nextDictionaryReader != null) {        nextDictionaryReader.setRowGroup(currentRowGroup);    }    advanceToNextBlock();    return currentRowGroup;}
99ffacdfd9169ccc9d6b3ff781f4d8f39a01deaf25f7c3117c77f3245c1b4218
readNextFilteredRowGroup
public PageReadStore readNextFilteredRowGroup() throws IOException
{    if (currentBlock == blocks.size()) {        return null;    }    if (!options.useColumnIndexFilter()) {        return readNextRowGroup();    }    BlockMetaData block = blocks.get(currentBlock);    if (block.getRowCount() == 0) {        throw new RuntimeException("Illegal row group of 0 rows");    }    ColumnIndexStore ciStore = getColumnIndexStore(currentBlock);    RowRanges rowRanges = getRowRanges(currentBlock);    long rowCount = rowRanges.rowCount();    if (rowCount == 0) {                advanceToNextBlock();        return readNextFilteredRowGroup();    }    if (rowCount == block.getRowCount()) {                return readNextRowGroup();    }    this.currentRowGroup = new ColumnChunkPageReadStore(rowRanges);        ChunkListBuilder builder = new ChunkListBuilder();    List<ConsecutivePartList> allParts = new ArrayList<ConsecutivePartList>();    ConsecutivePartList currentParts = null;    for (ColumnChunkMetaData mc : block.getColumns()) {        ColumnPath pathKey = mc.getPath();        ColumnDescriptor columnDescriptor = paths.get(pathKey);        if (columnDescriptor != null) {            OffsetIndex offsetIndex = ciStore.getOffsetIndex(mc.getPath());            OffsetIndex filteredOffsetIndex = filterOffsetIndex(offsetIndex, rowRanges, block.getRowCount());            for (OffsetRange range : calculateOffsetRanges(filteredOffsetIndex, mc, offsetIndex.getOffset(0))) {                BenchmarkCounter.incrementTotalBytes(range.getLength());                long startingPos = range.getOffset();                                if (currentParts == null || currentParts.endPos() != startingPos) {                    currentParts = new ConsecutivePartList(startingPos);                    allParts.add(currentParts);                }                ChunkDescriptor chunkDescriptor = new ChunkDescriptor(columnDescriptor, mc, startingPos, (int) range.getLength());                currentParts.addChunk(chunkDescriptor);                builder.setOffsetIndex(chunkDescriptor, filteredOffsetIndex);            }        }    }        for (ConsecutivePartList consecutiveChunks : allParts) {        consecutiveChunks.readAll(f, builder);    }    for (Chunk chunk : builder.build()) {        currentRowGroup.addColumn(chunk.descriptor.col, chunk.readAllPages());    }        if (nextDictionaryReader != null) {        nextDictionaryReader.setRowGroup(currentRowGroup);    }    advanceToNextBlock();    return currentRowGroup;}
17953c3177eab48c493f9fad7365a1723c62894719d74612de5e02b0d36042f8
getColumnIndexStore
private ColumnIndexStore getColumnIndexStore(int blockIndex)
{    ColumnIndexStore ciStore = blockIndexStores.get(blockIndex);    if (ciStore == null) {        ciStore = ColumnIndexStoreImpl.create(this, blocks.get(blockIndex), paths.keySet());        blockIndexStores.set(blockIndex, ciStore);    }    return ciStore;}
1b6d8077414b31559650a2aafab78426a05f1b967b13c1c596c2d425980b078d
getRowRanges
private RowRanges getRowRanges(int blockIndex)
{    RowRanges rowRanges = blockRowRanges.get(blockIndex);    if (rowRanges == null) {        rowRanges = ColumnIndexFilter.calculateRowRanges(options.getRecordFilter(), getColumnIndexStore(blockIndex), paths.keySet(), blocks.get(blockIndex).getRowCount());        blockRowRanges.set(blockIndex, rowRanges);    }    return rowRanges;}
207a73d547156b1b690fcc64aef993d7d14cd503b127860b1649636a6fb54f67
skipNextRowGroup
public boolean skipNextRowGroup()
{    return advanceToNextBlock();}
594691d01557b9c04d18a01ae2af5f112a87db13189fe71f5edf304ae0cc7ec3
advanceToNextBlock
private boolean advanceToNextBlock()
{    if (currentBlock == blocks.size()) {        return false;    }        ++currentBlock;    this.nextDictionaryReader = null;    return true;}
2fd8705bf4f3f6dd2f7a4f0e85623246985280068cd86d89f6b8b5bc11eacb2e
getNextDictionaryReader
public DictionaryPageReadStore getNextDictionaryReader()
{    if (nextDictionaryReader == null && currentBlock < blocks.size()) {        this.nextDictionaryReader = getDictionaryReader(blocks.get(currentBlock));    }    return nextDictionaryReader;}
58225b5b338b5a1ca13ff92cb0a01aa9ffc6be75c9f27bcce9d446f5d2fb0db7
getDictionaryReader
public DictionaryPageReader getDictionaryReader(BlockMetaData block)
{    return new DictionaryPageReader(this, block);}
236c63064e94605e44f0275f84589231886de47f934e3b579538084b23154935
readDictionary
 DictionaryPage readDictionary(ColumnChunkMetaData meta) throws IOException
{    if (!meta.getEncodings().contains(Encoding.PLAIN_DICTIONARY) && !meta.getEncodings().contains(Encoding.RLE_DICTIONARY)) {        return null;    }        if (f.getPos() != meta.getStartingPos()) {        f.seek(meta.getStartingPos());    }    PageHeader pageHeader = Util.readPageHeader(f);    if (!pageHeader.isSetDictionary_page_header()) {                return null;    }    DictionaryPage compressedPage = readCompressedDictionary(pageHeader, f);    BytesInputDecompressor decompressor = options.getCodecFactory().getDecompressor(meta.getCodec());    return new DictionaryPage(decompressor.decompress(compressedPage.getBytes(), compressedPage.getUncompressedSize()), compressedPage.getDictionarySize(), compressedPage.getEncoding());}
7b9da881ba3b2c060169fdd4e1dce759e25f6b0c2c114fbb8140faf1915e8a7b
readCompressedDictionary
private DictionaryPage readCompressedDictionary(PageHeader pageHeader, SeekableInputStream fin) throws IOException
{    DictionaryPageHeader dictHeader = pageHeader.getDictionary_page_header();    int uncompressedPageSize = pageHeader.getUncompressed_page_size();    int compressedPageSize = pageHeader.getCompressed_page_size();    byte[] dictPageBytes = new byte[compressedPageSize];    fin.readFully(dictPageBytes);    BytesInput bin = BytesInput.from(dictPageBytes);    return new DictionaryPage(bin, uncompressedPageSize, dictHeader.getNum_values(), converter.getEncoding(dictHeader.getEncoding()));}
5a1412f400b34c851615826011c83ae76c9d7836e31e1c945bb82b52779dca8f
readColumnIndex
public ColumnIndex readColumnIndex(ColumnChunkMetaData column) throws IOException
{    IndexReference ref = column.getColumnIndexReference();    if (ref == null) {        return null;    }    f.seek(ref.getOffset());    return ParquetMetadataConverter.fromParquetColumnIndex(column.getPrimitiveType(), Util.readColumnIndex(f));}
e39e3138fcac8f4af723238ead04f1a5e7512700c4a2a6a7d2ee13cbc0c00dbc
readOffsetIndex
public OffsetIndex readOffsetIndex(ColumnChunkMetaData column) throws IOException
{    IndexReference ref = column.getOffsetIndexReference();    if (ref == null) {        return null;    }    f.seek(ref.getOffset());    return ParquetMetadataConverter.fromParquetOffsetIndex(Util.readOffsetIndex(f));}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    try {        if (f != null) {            f.close();        }    } finally {        options.getCodecFactory().release();    }}
b4496876c9ddea7290556c83ac23645d11e0ee005120580d968a490ef01f946b
add
 void add(ChunkDescriptor descriptor, List<ByteBuffer> buffers, SeekableInputStream f)
{    ChunkData data = map.get(descriptor);    if (data == null) {        data = new ChunkData();        map.put(descriptor, data);    }    data.buffers.addAll(buffers);    lastDescriptor = descriptor;    this.f = f;}
2491ead6b5c55516b7513347127b6c5ecb1348b6cf2b3b3a27702f8d86e57e5a
setOffsetIndex
 void setOffsetIndex(ChunkDescriptor descriptor, OffsetIndex offsetIndex)
{    ChunkData data = map.get(descriptor);    if (data == null) {        data = new ChunkData();        map.put(descriptor, data);    }    data.offsetIndex = offsetIndex;}
365f1f2b3e347ef6768cc30cd3ac5a3e3e31f02c86ae67539e543c37f958aa12
build
 List<Chunk> build()
{    List<Chunk> chunks = new ArrayList<>();    for (Entry<ChunkDescriptor, ChunkData> entry : map.entrySet()) {        ChunkDescriptor descriptor = entry.getKey();        ChunkData data = entry.getValue();        if (descriptor.equals(lastDescriptor)) {                        chunks.add(new WorkaroundChunk(lastDescriptor, data.buffers, f, data.offsetIndex));        } else {            chunks.add(new Chunk(descriptor, data.buffers, data.offsetIndex));        }    }    return chunks;}
10f946522bbab1449671d4fd26182d2f69d512c480a880d4dec35a4026afb54d
readPageHeader
protected PageHeader readPageHeader() throws IOException
{    return Util.readPageHeader(stream);}
fc229feacac0b8f111c511ab06352c5587126b28586b657ef6730d3eb637d46d
verifyCrc
private void verifyCrc(int referenceCrc, byte[] bytes, String exceptionMsg)
{    crc.reset();    crc.update(bytes);    if (crc.getValue() != ((long) referenceCrc & 0xffffffffL)) {        throw new ParquetDecodingException(exceptionMsg);    }}
a85fcc3ec1db89df9a9c143a0d9d909f48a5b8108ddf4dae9a28507de872782e
readAllPages
public ColumnChunkPageReader readAllPages() throws IOException
{    List<DataPage> pagesInChunk = new ArrayList<DataPage>();    DictionaryPage dictionaryPage = null;    PrimitiveType type = getFileMetaData().getSchema().getType(descriptor.col.getPath()).asPrimitiveType();    long valuesCountReadSoFar = 0;    int dataPageCountReadSoFar = 0;    while (hasMorePages(valuesCountReadSoFar, dataPageCountReadSoFar)) {        PageHeader pageHeader = readPageHeader();        int uncompressedPageSize = pageHeader.getUncompressed_page_size();        int compressedPageSize = pageHeader.getCompressed_page_size();        final BytesInput pageBytes;        switch(pageHeader.type) {            case DICTIONARY_PAGE:                                if (dictionaryPage != null) {                    throw new ParquetDecodingException("more than one dictionary page in column " + descriptor.col);                }                pageBytes = this.readAsBytesInput(compressedPageSize);                if (options.usePageChecksumVerification() && pageHeader.isSetCrc()) {                    verifyCrc(pageHeader.getCrc(), pageBytes.toByteArray(), "could not verify dictionary page integrity, CRC checksum verification failed");                }                DictionaryPageHeader dicHeader = pageHeader.getDictionary_page_header();                dictionaryPage = new DictionaryPage(pageBytes, uncompressedPageSize, dicHeader.getNum_values(), converter.getEncoding(dicHeader.getEncoding()));                                if (pageHeader.isSetCrc()) {                    dictionaryPage.setCrc(pageHeader.getCrc());                }                break;            case DATA_PAGE:                DataPageHeader dataHeaderV1 = pageHeader.getData_page_header();                pageBytes = this.readAsBytesInput(compressedPageSize);                if (options.usePageChecksumVerification() && pageHeader.isSetCrc()) {                    verifyCrc(pageHeader.getCrc(), pageBytes.toByteArray(), "could not verify page integrity, CRC checksum verification failed");                }                DataPageV1 dataPageV1 = new DataPageV1(pageBytes, dataHeaderV1.getNum_values(), uncompressedPageSize, converter.fromParquetStatistics(getFileMetaData().getCreatedBy(), dataHeaderV1.getStatistics(), type), converter.getEncoding(dataHeaderV1.getRepetition_level_encoding()), converter.getEncoding(dataHeaderV1.getDefinition_level_encoding()), converter.getEncoding(dataHeaderV1.getEncoding()));                                if (pageHeader.isSetCrc()) {                    dataPageV1.setCrc(pageHeader.getCrc());                }                pagesInChunk.add(dataPageV1);                valuesCountReadSoFar += dataHeaderV1.getNum_values();                ++dataPageCountReadSoFar;                break;            case DATA_PAGE_V2:                DataPageHeaderV2 dataHeaderV2 = pageHeader.getData_page_header_v2();                int dataSize = compressedPageSize - dataHeaderV2.getRepetition_levels_byte_length() - dataHeaderV2.getDefinition_levels_byte_length();                pagesInChunk.add(new DataPageV2(dataHeaderV2.getNum_rows(), dataHeaderV2.getNum_nulls(), dataHeaderV2.getNum_values(), this.readAsBytesInput(dataHeaderV2.getRepetition_levels_byte_length()), this.readAsBytesInput(dataHeaderV2.getDefinition_levels_byte_length()), converter.getEncoding(dataHeaderV2.getEncoding()), this.readAsBytesInput(dataSize), uncompressedPageSize, converter.fromParquetStatistics(getFileMetaData().getCreatedBy(), dataHeaderV2.getStatistics(), type), dataHeaderV2.isIs_compressed()));                valuesCountReadSoFar += dataHeaderV2.getNum_values();                ++dataPageCountReadSoFar;                break;            default:                LOG.debug("skipping page of type {} of size {}", pageHeader.getType(), compressedPageSize);                stream.skipFully(compressedPageSize);                break;        }    }    if (offsetIndex == null && valuesCountReadSoFar != descriptor.metadata.getValueCount()) {                throw new IOException("Expected " + descriptor.metadata.getValueCount() + " values in column chunk at " + getPath() + " offset " + descriptor.metadata.getFirstDataPageOffset() + " but got " + valuesCountReadSoFar + " values instead over " + pagesInChunk.size() + " pages ending at file offset " + (descriptor.fileOffset + stream.position()));    }    BytesInputDecompressor decompressor = options.getCodecFactory().getDecompressor(descriptor.metadata.getCodec());    return new ColumnChunkPageReader(decompressor, pagesInChunk, dictionaryPage, offsetIndex, blocks.get(currentBlock).getRowCount());}
86389940b6846d28cd39398304bd8422fc8c459537a9a6fac34bf49ce166d0dd
hasMorePages
private boolean hasMorePages(long valuesCountReadSoFar, int dataPageCountReadSoFar)
{    return offsetIndex == null ? valuesCountReadSoFar < descriptor.metadata.getValueCount() : dataPageCountReadSoFar < offsetIndex.getPageCount();}
e136363b4c04bbdae44fc0a1605d90dd587ee0eed1e2a669cdd5a5d31699dd4e
readAsBytesInput
public BytesInput readAsBytesInput(int size) throws IOException
{    return BytesInput.from(stream.sliceBuffers(size));}
10f946522bbab1449671d4fd26182d2f69d512c480a880d4dec35a4026afb54d
readPageHeader
protected PageHeader readPageHeader() throws IOException
{    PageHeader pageHeader;        stream.mark(8192);    try {        pageHeader = Util.readPageHeader(stream);    } catch (IOException e) {                                                        stream.reset();        LOG.info("completing the column chunk to read the page header");                pageHeader = Util.readPageHeader(new SequenceInputStream(stream, f));    }    return pageHeader;}
e136363b4c04bbdae44fc0a1605d90dd587ee0eed1e2a669cdd5a5d31699dd4e
readAsBytesInput
public BytesInput readAsBytesInput(int size) throws IOException
{    int available = stream.available();    if (size > available) {                                        int missingBytes = size - available;        LOG.info("completed the column chunk with {} bytes", missingBytes);        List<ByteBuffer> buffers = new ArrayList<>();        buffers.addAll(stream.sliceBuffers(available));        ByteBuffer lastBuffer = ByteBuffer.allocate(missingBytes);        f.readFully(lastBuffer);        buffers.add(lastBuffer);        return BytesInput.from(buffers);    }    return super.readAsBytesInput(size);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return col.hashCode();}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj) {        return true;    } else if (obj instanceof ChunkDescriptor) {        return col.equals(((ChunkDescriptor) obj).col);    } else {        return false;    }}
819de51b867123d71b2fe0fc0225c50674e27938402180053a32870652578eb8
addChunk
public void addChunk(ChunkDescriptor descriptor)
{    chunks.add(descriptor);    length += descriptor.size;}
3a1d5ec6b4668fe9e4394ce5e58fad1c8fc60bf7aec377fe798d47bba4999e4e
readAll
public void readAll(SeekableInputStream f, ChunkListBuilder builder) throws IOException
{    List<Chunk> result = new ArrayList<Chunk>(chunks.size());    f.seek(offset);    int fullAllocations = length / options.getMaxAllocationSize();    int lastAllocationSize = length % options.getMaxAllocationSize();    int numAllocations = fullAllocations + (lastAllocationSize > 0 ? 1 : 0);    List<ByteBuffer> buffers = new ArrayList<>(numAllocations);    for (int i = 0; i < fullAllocations; i += 1) {        buffers.add(options.getAllocator().allocate(options.getMaxAllocationSize()));    }    if (lastAllocationSize > 0) {        buffers.add(options.getAllocator().allocate(lastAllocationSize));    }    for (ByteBuffer buffer : buffers) {        f.readFully(buffer);        buffer.flip();    }        BenchmarkCounter.incrementBytesRead(length);    ByteBufferInputStream stream = ByteBufferInputStream.wrap(buffers);    for (int i = 0; i < chunks.size(); i++) {        ChunkDescriptor descriptor = chunks.get(i);        builder.add(descriptor, stream.sliceBuffers(descriptor.size), f);    }}
1b7f990eee250760a834fdbb1265ee883b115fae2bd347d5125fe1b34831b95a
endPos
public long endPos()
{    return offset + length;}
66bb31831e76c06f00240ad97af64e1ecbab667cc187ed4535b7aab3b7604104
start
 STATE start() throws IOException
{    return error();}
6d9cf7dc0cca0b50e4ee04099b06876a05ee5f0b0c82da3d00991a7bff878219
startBlock
 STATE startBlock() throws IOException
{    return error();}
0588550820eb0609b6242ed5a8c6b99d9d6ebe8c86a4b78ba3b79045da558806
startColumn
 STATE startColumn() throws IOException
{    return error();}
4c0d7667628d485b872c2d75b5bc8d01b35c5cfac90fca0e23f88a017c606e3d
write
 STATE write() throws IOException
{    return error();}
1e1dd7a73e3a805b9bd706b412d34b0465a96e0e9df4cd2ec5e6e308beeaab29
endColumn
 STATE endColumn() throws IOException
{    return error();}
1bcaaa9a749e3fe4f44c42f250d019967b5bf695116d947726d2aba986e4ee5f
endBlock
 STATE endBlock() throws IOException
{    return error();}
34f225e4e6a8e71238bb5bca8667ff2f9ca1211340c6151e9c118ee9dd405702
end
 STATE end() throws IOException
{    return error();}
368bea2d1c3b6abbc6a2cfa8ea8d009535bbc8b7b32d7912beb7d7f75d3f8375
error
private final STATE error() throws IOException
{    throw new IOException("The file being written is in an invalid state. Probably caused by an error thrown previously. Current state: " + this.name());}
d0d75dad584c0ce2415d09545928922e8ab9481452ec18482cfb01150fcef263
start
 STATE start()
{    return STARTED;}
06a9b776ad436278a5ee51b5286228d27189ebbcc7a903f729e4cc5d9b3c6c14
startBlock
 STATE startBlock()
{    return BLOCK;}
67e19a42105c06bbab7fde0938244c8f0a15bbb876ebf0f9cfd681b19b0d6b76
end
 STATE end()
{    return ENDED;}
fb70709b11906635772861675c20dc3db2127062e124f60245dc2ecf3ffe6d4e
startColumn
 STATE startColumn()
{    return COLUMN;}
917c18073c0b805f6e94dfa8a8bc93ea5e10569ab2bcdf184e10b9c8304a4ee9
endBlock
 STATE endBlock()
{    return STARTED;}
171175327d51ce71d233320083f74ca2ccfe5dd47cc08b91fbd3e2794d036549
endColumn
 STATE endColumn()
{    return BLOCK;}
675f54e02cb780e731c61cd5e53a658a8dc80abae7a5c71e5a56d5156b882285
write
 STATE write()
{    return this;}
e5a14fc0f40f83e0c8774c3bcbdfa6c6fbf236404951b40500e2bd5e42f00077
start
public void start() throws IOException
{    state = state.start();    LOG.debug("{}: start", out.getPos());    out.write(MAGIC);}
63656b9948434bcdc70aca9258b64270c67d98e1cd9f34b9d69a1f1bb206ee47
startBlock
public void startBlock(long recordCount) throws IOException
{    state = state.startBlock();    LOG.debug("{}: start block", out.getPos());        alignment.alignForRowGroup(out);    currentBlock = new BlockMetaData();    currentRecordCount = recordCount;    currentColumnIndexes = new ArrayList<>();    currentOffsetIndexes = new ArrayList<>();}
7021740ef8a07e181e4c7ac4afc2e3b492ab0c0d048e99a7511eda5f896d8a59
startColumn
public void startColumn(ColumnDescriptor descriptor, long valueCount, CompressionCodecName compressionCodecName) throws IOException
{    state = state.startColumn();    encodingStatsBuilder.clear();    currentEncodings = new HashSet<Encoding>();    currentChunkPath = ColumnPath.get(descriptor.getPath());    currentChunkType = descriptor.getPrimitiveType();    currentChunkCodec = compressionCodecName;    currentChunkValueCount = valueCount;    currentChunkFirstDataPage = out.getPos();    compressedLength = 0;    uncompressedLength = 0;        currentStatistics = null;    columnIndexBuilder = ColumnIndexBuilder.getBuilder(currentChunkType, columnIndexTruncateLength);    offsetIndexBuilder = OffsetIndexBuilder.getBuilder();    firstPageOffset = -1;}
979a9e010c509f63ed8210f83e5e4d7838052d7f5e3bbb4e9c3797d5de3ea217
writeDictionaryPage
public void writeDictionaryPage(DictionaryPage dictionaryPage) throws IOException
{    state = state.write();    LOG.debug("{}: write dictionary page: {} values", out.getPos(), dictionaryPage.getDictionarySize());    currentChunkDictionaryPageOffset = out.getPos();    int uncompressedSize = dictionaryPage.getUncompressedSize();        int compressedPageSize = (int) dictionaryPage.getBytes().size();    if (pageWriteChecksumEnabled) {        crc.reset();        crc.update(dictionaryPage.getBytes().toByteArray());        metadataConverter.writeDictionaryPageHeader(uncompressedSize, compressedPageSize, dictionaryPage.getDictionarySize(), dictionaryPage.getEncoding(), (int) crc.getValue(), out);    } else {        metadataConverter.writeDictionaryPageHeader(uncompressedSize, compressedPageSize, dictionaryPage.getDictionarySize(), dictionaryPage.getEncoding(), out);    }    long headerSize = out.getPos() - currentChunkDictionaryPageOffset;    this.uncompressedLength += uncompressedSize + headerSize;    this.compressedLength += compressedPageSize + headerSize;    LOG.debug("{}: write dictionary page content {}", out.getPos(), compressedPageSize);    dictionaryPage.getBytes().writeAllTo(out);    encodingStatsBuilder.addDictEncoding(dictionaryPage.getEncoding());    currentEncodings.add(dictionaryPage.getEncoding());}
3a591e5707dd337430cdc76183c08f27349d8d99c6180fb68225985f5c79d6b5
writeDataPage
public void writeDataPage(int valueCount, int uncompressedPageSize, BytesInput bytes, Encoding rlEncoding, Encoding dlEncoding, Encoding valuesEncoding) throws IOException
{    state = state.write();        offsetIndexBuilder = OffsetIndexBuilder.getNoOpBuilder();    columnIndexBuilder = ColumnIndexBuilder.getNoOpBuilder();    long beforeHeader = out.getPos();    LOG.debug("{}: write data page: {} values", beforeHeader, valueCount);    int compressedPageSize = (int) bytes.size();    metadataConverter.writeDataPageV1Header(uncompressedPageSize, compressedPageSize, valueCount, rlEncoding, dlEncoding, valuesEncoding, out);    long headerSize = out.getPos() - beforeHeader;    this.uncompressedLength += uncompressedPageSize + headerSize;    this.compressedLength += compressedPageSize + headerSize;    LOG.debug("{}: write data page content {}", out.getPos(), compressedPageSize);    bytes.writeAllTo(out);    encodingStatsBuilder.addDataEncoding(valuesEncoding);    currentEncodings.add(rlEncoding);    currentEncodings.add(dlEncoding);    currentEncodings.add(valuesEncoding);}
6db11b4a871596907d740ef21768a6166e51a70dd4f8fde6999acab2a0cc8c8b
writeDataPage
public void writeDataPage(int valueCount, int uncompressedPageSize, BytesInput bytes, Statistics statistics, Encoding rlEncoding, Encoding dlEncoding, Encoding valuesEncoding) throws IOException
{        offsetIndexBuilder = OffsetIndexBuilder.getNoOpBuilder();    columnIndexBuilder = ColumnIndexBuilder.getNoOpBuilder();    innerWriteDataPage(valueCount, uncompressedPageSize, bytes, statistics, rlEncoding, dlEncoding, valuesEncoding);}
55e0519fc59264dcf796ab714575fa8892eb18c60a20a429b19be9daa6776c49
writeDataPage
public void writeDataPage(int valueCount, int uncompressedPageSize, BytesInput bytes, Statistics statistics, long rowCount, Encoding rlEncoding, Encoding dlEncoding, Encoding valuesEncoding) throws IOException
{    long beforeHeader = out.getPos();    innerWriteDataPage(valueCount, uncompressedPageSize, bytes, statistics, rlEncoding, dlEncoding, valuesEncoding);    offsetIndexBuilder.add((int) (out.getPos() - beforeHeader), rowCount);}
3f3256c9962ce4e4d41ce33dab6d6e9dd47a511f425ce8021ac6b209733d7ee8
innerWriteDataPage
private void innerWriteDataPage(int valueCount, int uncompressedPageSize, BytesInput bytes, Statistics statistics, Encoding rlEncoding, Encoding dlEncoding, Encoding valuesEncoding) throws IOException
{    state = state.write();    long beforeHeader = out.getPos();    if (firstPageOffset == -1) {        firstPageOffset = beforeHeader;    }    LOG.debug("{}: write data page: {} values", beforeHeader, valueCount);    int compressedPageSize = (int) bytes.size();    if (pageWriteChecksumEnabled) {        crc.reset();        crc.update(bytes.toByteArray());        metadataConverter.writeDataPageV1Header(uncompressedPageSize, compressedPageSize, valueCount, rlEncoding, dlEncoding, valuesEncoding, (int) crc.getValue(), out);    } else {        metadataConverter.writeDataPageV1Header(uncompressedPageSize, compressedPageSize, valueCount, rlEncoding, dlEncoding, valuesEncoding, out);    }    long headerSize = out.getPos() - beforeHeader;    this.uncompressedLength += uncompressedPageSize + headerSize;    this.compressedLength += compressedPageSize + headerSize;    LOG.debug("{}: write data page content {}", out.getPos(), compressedPageSize);    bytes.writeAllTo(out);        if (currentStatistics == null) {        currentStatistics = statistics.copy();    } else {        currentStatistics.mergeStatistics(statistics);    }    columnIndexBuilder.add(statistics);    encodingStatsBuilder.addDataEncoding(valuesEncoding);    currentEncodings.add(rlEncoding);    currentEncodings.add(dlEncoding);    currentEncodings.add(valuesEncoding);}
3a90cbffc6c8c23d828d33bb7bc65db935986c845b04a5b5e8a49518d79ea874
writeColumnChunk
 void writeColumnChunk(ColumnDescriptor descriptor, long valueCount, CompressionCodecName compressionCodecName, DictionaryPage dictionaryPage, BytesInput bytes, long uncompressedTotalPageSize, long compressedTotalPageSize, Statistics<?> totalStats, ColumnIndexBuilder columnIndexBuilder, OffsetIndexBuilder offsetIndexBuilder, Set<Encoding> rlEncodings, Set<Encoding> dlEncodings, List<Encoding> dataEncodings) throws IOException
{    startColumn(descriptor, valueCount, compressionCodecName);    state = state.write();    if (dictionaryPage != null) {        writeDictionaryPage(dictionaryPage);    }    LOG.debug("{}: write data pages", out.getPos());    long headersSize = bytes.size() - compressedTotalPageSize;    this.uncompressedLength += uncompressedTotalPageSize + headersSize;    this.compressedLength += compressedTotalPageSize + headersSize;    LOG.debug("{}: write data pages content", out.getPos());    firstPageOffset = out.getPos();    bytes.writeAllTo(out);    encodingStatsBuilder.addDataEncodings(dataEncodings);    if (rlEncodings.isEmpty()) {        encodingStatsBuilder.withV2Pages();    }    currentEncodings.addAll(rlEncodings);    currentEncodings.addAll(dlEncodings);    currentEncodings.addAll(dataEncodings);    currentStatistics = totalStats;    this.columnIndexBuilder = columnIndexBuilder;    this.offsetIndexBuilder = offsetIndexBuilder;    endColumn();}
5c6d0ad39a9cde18ecd49b27c2675cbc9f0e51954b7ebcbfb3fcebfc15ad67fb
endColumn
public void endColumn() throws IOException
{    state = state.endColumn();    LOG.debug("{}: end column", out.getPos());    if (columnIndexBuilder.getMinMaxSize() > columnIndexBuilder.getPageCount() * MAX_STATS_SIZE) {        currentColumnIndexes.add(null);    } else {        currentColumnIndexes.add(columnIndexBuilder.build());    }    currentOffsetIndexes.add(offsetIndexBuilder.build(firstPageOffset));    currentBlock.addColumn(ColumnChunkMetaData.get(currentChunkPath, currentChunkType, currentChunkCodec, encodingStatsBuilder.build(), currentEncodings, currentStatistics, currentChunkFirstDataPage, currentChunkDictionaryPageOffset, currentChunkValueCount, compressedLength, uncompressedLength));    this.currentBlock.setTotalByteSize(currentBlock.getTotalByteSize() + uncompressedLength);    this.uncompressedLength = 0;    this.compressedLength = 0;    columnIndexBuilder = null;    offsetIndexBuilder = null;}
bc33b29e5e8d3f11392c632a1370a08412987e0cafcf988aa70242b02bb5da3e
endBlock
public void endBlock() throws IOException
{    state = state.endBlock();    LOG.debug("{}: end block", out.getPos());    currentBlock.setRowCount(currentRecordCount);    blocks.add(currentBlock);    columnIndexes.add(currentColumnIndexes);    offsetIndexes.add(currentOffsetIndexes);    currentColumnIndexes = null;    currentOffsetIndexes = null;    currentBlock = null;}
02a10f60178d25a8969cd3bef421b345d38e277db1a6343363218a4f6906681f
appendFile
public void appendFile(Configuration conf, Path file) throws IOException
{    ParquetFileReader.open(conf, file).appendTo(this);}
8d14608b1dfc740cc38fff23d677e38ac990b0ab30d981155f205040d707cb02
appendFile
public void appendFile(InputFile file) throws IOException
{    try (ParquetFileReader reader = ParquetFileReader.open(file)) {        reader.appendTo(this);    }}
4c0e1ab454e1b19eb13584222c751aa863f2055714d0e0c9230497d5159f27a9
appendRowGroups
public void appendRowGroups(FSDataInputStream file, List<BlockMetaData> rowGroups, boolean dropColumns) throws IOException
{    appendRowGroups(HadoopStreams.wrap(file), rowGroups, dropColumns);}
44f47893b0d447cb41a3a6abae2953bcc8ec0b5e17cec96bc4d81bf2fc95fafb
appendRowGroups
public void appendRowGroups(SeekableInputStream file, List<BlockMetaData> rowGroups, boolean dropColumns) throws IOException
{    for (BlockMetaData block : rowGroups) {        appendRowGroup(file, block, dropColumns);    }}
6eee3789b100a00a476faf544d83ad132c95bba314f569517ab499f7e10334f3
appendRowGroup
public void appendRowGroup(FSDataInputStream from, BlockMetaData rowGroup, boolean dropColumns) throws IOException
{    appendRowGroup(HadoopStreams.wrap(from), rowGroup, dropColumns);}
2854117de9227c762c14ca072da2e91b52a16bd3138f9c79808662f8054026b2
appendRowGroup
public void appendRowGroup(SeekableInputStream from, BlockMetaData rowGroup, boolean dropColumns) throws IOException
{    startBlock(rowGroup.getRowCount());    Map<String, ColumnChunkMetaData> columnsToCopy = new HashMap<String, ColumnChunkMetaData>();    for (ColumnChunkMetaData chunk : rowGroup.getColumns()) {        columnsToCopy.put(chunk.getPath().toDotString(), chunk);    }    List<ColumnChunkMetaData> columnsInOrder = new ArrayList<ColumnChunkMetaData>();    for (ColumnDescriptor descriptor : schema.getColumns()) {        String path = ColumnPath.get(descriptor.getPath()).toDotString();        ColumnChunkMetaData chunk = columnsToCopy.remove(path);        if (chunk != null) {            columnsInOrder.add(chunk);        } else {            throw new IllegalArgumentException(String.format("Missing column '%s', cannot copy row group: %s", path, rowGroup));        }    }        if (!dropColumns && !columnsToCopy.isEmpty()) {        throw new IllegalArgumentException(String.format("Columns cannot be copied (missing from target schema): %s", Strings.join(columnsToCopy.keySet(), ", ")));    }        long start = -1;    long length = 0;    long blockUncompressedSize = 0L;    for (int i = 0; i < columnsInOrder.size(); i += 1) {        ColumnChunkMetaData chunk = columnsInOrder.get(i);                long newChunkStart = out.getPos() + length;                if (start < 0) {                        start = chunk.getStartingPos();        }        length += chunk.getTotalSize();        if ((i + 1) == columnsInOrder.size() || columnsInOrder.get(i + 1).getStartingPos() != (start + length)) {                        copy(from, out, start, length);                        start = -1;            length = 0;        }                        currentColumnIndexes.add(null);        currentOffsetIndexes.add(null);        currentBlock.addColumn(ColumnChunkMetaData.get(chunk.getPath(), chunk.getPrimitiveType(), chunk.getCodec(), chunk.getEncodingStats(), chunk.getEncodings(), chunk.getStatistics(), newChunkStart, newChunkStart, chunk.getValueCount(), chunk.getTotalSize(), chunk.getTotalUncompressedSize()));        blockUncompressedSize += chunk.getTotalUncompressedSize();    }    currentBlock.setTotalByteSize(blockUncompressedSize);    endBlock();}
8cf2aa4d7e1e04c3ac544fbf36cf4458434f56e903dbc50ec5583830a578e1d9
copy
private static void copy(SeekableInputStream from, PositionOutputStream to, long start, long length) throws IOException
{    LOG.debug("Copying {} bytes at {} to {}", length, start, to.getPos());    from.seek(start);    long bytesCopied = 0;    byte[] buffer = COPY_BUFFER.get();    while (bytesCopied < length) {        long bytesLeft = length - bytesCopied;        int bytesRead = from.read(buffer, 0, (buffer.length < bytesLeft ? buffer.length : (int) bytesLeft));        if (bytesRead < 0) {            throw new IllegalArgumentException("Unexpected end of input file at " + start + bytesCopied);        }        to.write(buffer, 0, bytesRead);        bytesCopied += bytesRead;    }}
9ed6feba9c9f5d765d8b6dd73ea0436388ed3c8c7bd53b2331154eae62d92ab8
end
public void end(Map<String, String> extraMetaData) throws IOException
{    state = state.end();    serializeColumnIndexes(columnIndexes, blocks, out);    serializeOffsetIndexes(offsetIndexes, blocks, out);    LOG.debug("{}: end", out.getPos());    this.footer = new ParquetMetadata(new FileMetaData(schema, extraMetaData, Version.FULL_VERSION), blocks);    serializeFooter(footer, out);    out.close();}
528ceaacfb9fd840464588be8feb4832f395bebb9b7ea6ea3b23457814200bf8
serializeColumnIndexes
private static void serializeColumnIndexes(List<List<ColumnIndex>> columnIndexes, List<BlockMetaData> blocks, PositionOutputStream out) throws IOException
{    LOG.debug("{}: column indexes", out.getPos());    for (int bIndex = 0, bSize = blocks.size(); bIndex < bSize; ++bIndex) {        List<ColumnChunkMetaData> columns = blocks.get(bIndex).getColumns();        List<ColumnIndex> blockColumnIndexes = columnIndexes.get(bIndex);        for (int cIndex = 0, cSize = columns.size(); cIndex < cSize; ++cIndex) {            ColumnChunkMetaData column = columns.get(cIndex);            org.apache.parquet.format.ColumnIndex columnIndex = ParquetMetadataConverter.toParquetColumnIndex(column.getPrimitiveType(), blockColumnIndexes.get(cIndex));            if (columnIndex == null) {                continue;            }            long offset = out.getPos();            Util.writeColumnIndex(columnIndex, out);            column.setColumnIndexReference(new IndexReference(offset, (int) (out.getPos() - offset)));        }    }}
becb39520ed749f4d1979d2fc2bfa514f64a345647577d9b0d17c4fa8bb78d23
serializeOffsetIndexes
private static void serializeOffsetIndexes(List<List<OffsetIndex>> offsetIndexes, List<BlockMetaData> blocks, PositionOutputStream out) throws IOException
{    LOG.debug("{}: offset indexes", out.getPos());    for (int bIndex = 0, bSize = blocks.size(); bIndex < bSize; ++bIndex) {        List<ColumnChunkMetaData> columns = blocks.get(bIndex).getColumns();        List<OffsetIndex> blockOffsetIndexes = offsetIndexes.get(bIndex);        for (int cIndex = 0, cSize = columns.size(); cIndex < cSize; ++cIndex) {            OffsetIndex offsetIndex = blockOffsetIndexes.get(cIndex);            if (offsetIndex == null) {                continue;            }            ColumnChunkMetaData column = columns.get(cIndex);            long offset = out.getPos();            Util.writeOffsetIndex(ParquetMetadataConverter.toParquetOffsetIndex(offsetIndex), out);            column.setOffsetIndexReference(new IndexReference(offset, (int) (out.getPos() - offset)));        }    }}
c3a4f0202f05a374a3f8a9f45a94669c35e7631c84a83c2a4a7eb4040131d406
serializeFooter
private static void serializeFooter(ParquetMetadata footer, PositionOutputStream out) throws IOException
{    long footerIndex = out.getPos();    org.apache.parquet.format.FileMetaData parquetMetadata = metadataConverter.toParquetMetadata(CURRENT_VERSION, footer);    writeFileMetaData(parquetMetadata, out);    LOG.debug("{}: footer length = {}", out.getPos(), (out.getPos() - footerIndex));    BytesUtils.writeIntLittleEndian(out, (int) (out.getPos() - footerIndex));    out.write(MAGIC);}
4c5838da1bbb7f272d023072572656ee488689766654d779a053dc4e7986bc90
getFooter
public ParquetMetadata getFooter()
{    Preconditions.checkState(state == STATE.ENDED, "Cannot return unfinished footer.");    return footer;}
6ec3e17967a4634ec6593105ac21782e6a9bcff965e28bc693f6f42e67e86e20
mergeMetadataFiles
public static ParquetMetadata mergeMetadataFiles(List<Path> files, Configuration conf) throws IOException
{    Preconditions.checkArgument(!files.isEmpty(), "Cannot merge an empty list of metadata");    GlobalMetaData globalMetaData = null;    List<BlockMetaData> blocks = new ArrayList<BlockMetaData>();    for (Path p : files) {        ParquetMetadata pmd = ParquetFileReader.readFooter(conf, p, ParquetMetadataConverter.NO_FILTER);        FileMetaData fmd = pmd.getFileMetaData();        globalMetaData = mergeInto(fmd, globalMetaData, true);        blocks.addAll(pmd.getBlocks());    }        return new ParquetMetadata(globalMetaData.merge(), blocks);}
35de0e8613620c5e108e85932028492b1b5b63eaa890cbe2f276ffc6fc5ce4ab
writeMergedMetadataFile
public static void writeMergedMetadataFile(List<Path> files, Path outputPath, Configuration conf) throws IOException
{    ParquetMetadata merged = mergeMetadataFiles(files, conf);    writeMetadataFile(outputPath, merged, outputPath.getFileSystem(conf));}
b257dde3ccb70f97aef0ee788ec2b653e81ded46f32a210315908026acd97cda
writeMetadataFile
public static void writeMetadataFile(Configuration configuration, Path outputPath, List<Footer> footers) throws IOException
{    writeMetadataFile(configuration, outputPath, footers, JobSummaryLevel.ALL);}
9bfd9d619fc4d6df59a8194a8558c624d6c317058356a6516e5ba857e92356d9
writeMetadataFile
public static void writeMetadataFile(Configuration configuration, Path outputPath, List<Footer> footers, JobSummaryLevel level) throws IOException
{    Preconditions.checkArgument(level == JobSummaryLevel.ALL || level == JobSummaryLevel.COMMON_ONLY, "Unsupported level: " + level);    FileSystem fs = outputPath.getFileSystem(configuration);    outputPath = outputPath.makeQualified(fs);    ParquetMetadata metadataFooter = mergeFooters(outputPath, footers);    if (level == JobSummaryLevel.ALL) {        writeMetadataFile(outputPath, metadataFooter, fs, PARQUET_METADATA_FILE);    }    metadataFooter.getBlocks().clear();    writeMetadataFile(outputPath, metadataFooter, fs, PARQUET_COMMON_METADATA_FILE);}
9f1f7a1764e9d120ad5e9b785ad51a96c5365d77468625c95a2e67dc350b100c
writeMetadataFile
private static void writeMetadataFile(Path outputPathRoot, ParquetMetadata metadataFooter, FileSystem fs, String parquetMetadataFile) throws IOException
{    Path metaDataPath = new Path(outputPathRoot, parquetMetadataFile);    writeMetadataFile(metaDataPath, metadataFooter, fs);}
9d0a9e036b3acf7e09fcef52fbf1b384923d492101a98dd8f65eba0ff15873f5
writeMetadataFile
private static void writeMetadataFile(Path outputPath, ParquetMetadata metadataFooter, FileSystem fs) throws IOException
{    PositionOutputStream metadata = HadoopStreams.wrap(fs.create(outputPath));    metadata.write(MAGIC);    serializeFooter(metadataFooter, metadata);    metadata.close();}
ac46a4deb929af00e7674b5cfd4204cec845816a95a1ddfa2867ecb221f7e7c4
mergeFooters
 static ParquetMetadata mergeFooters(Path root, List<Footer> footers)
{    String rootPath = root.toUri().getPath();    GlobalMetaData fileMetaData = null;    List<BlockMetaData> blocks = new ArrayList<BlockMetaData>();    for (Footer footer : footers) {        String footerPath = footer.getFile().toUri().getPath();        if (!footerPath.startsWith(rootPath)) {            throw new ParquetEncodingException(footerPath + " invalid: all the files must be contained in the root " + root);        }        footerPath = footerPath.substring(rootPath.length());        while (footerPath.startsWith("/")) {            footerPath = footerPath.substring(1);        }        fileMetaData = mergeInto(footer.getParquetMetadata().getFileMetaData(), fileMetaData);        for (BlockMetaData block : footer.getParquetMetadata().getBlocks()) {            block.setPath(footerPath);            blocks.add(block);        }    }    return new ParquetMetadata(fileMetaData.merge(), blocks);}
5800a0f531c192e683ef74c0c5de6015daf6261d1f8e5c0ce6d8e043b01926c7
getPos
public long getPos() throws IOException
{    return out.getPos();}
98633fc1d30241bce3ad9ee2c045392b691f8ba418c91f77b906dbbc88657635
getNextRowGroupSize
public long getNextRowGroupSize() throws IOException
{    return alignment.nextRowGroupSize(out);}
3df0524d3bfa3ec329a3c7c6b2ec82eaf1b769038f6b4b2b386869eb3588d42e
getGlobalMetaData
 static GlobalMetaData getGlobalMetaData(List<Footer> footers)
{    return getGlobalMetaData(footers, true);}
32bcfe6470db8d4a2161e315edf608c9bae23f8dacf1685464de0c6784d7e48d
getGlobalMetaData
 static GlobalMetaData getGlobalMetaData(List<Footer> footers, boolean strict)
{    GlobalMetaData fileMetaData = null;    for (Footer footer : footers) {        ParquetMetadata currentMetadata = footer.getParquetMetadata();        fileMetaData = mergeInto(currentMetadata.getFileMetaData(), fileMetaData, strict);    }    return fileMetaData;}
90f414c26be1c07e4543fa55f461715ef5300c6516457e37780e399c691bd5aa
mergeInto
 static GlobalMetaData mergeInto(FileMetaData toMerge, GlobalMetaData mergedMetadata)
{    return mergeInto(toMerge, mergedMetadata, true);}
eb4fca252eb3b1e4aaff28af6cf05348b596112121ddeb425e5d426a4a3747dd
mergeInto
 static GlobalMetaData mergeInto(FileMetaData toMerge, GlobalMetaData mergedMetadata, boolean strict)
{    MessageType schema = null;    Map<String, Set<String>> newKeyValues = new HashMap<String, Set<String>>();    Set<String> createdBy = new HashSet<String>();    if (mergedMetadata != null) {        schema = mergedMetadata.getSchema();        newKeyValues.putAll(mergedMetadata.getKeyValueMetaData());        createdBy.addAll(mergedMetadata.getCreatedBy());    }    if ((schema == null && toMerge.getSchema() != null) || (schema != null && !schema.equals(toMerge.getSchema()))) {        schema = mergeInto(toMerge.getSchema(), schema, strict);    }    for (Entry<String, String> entry : toMerge.getKeyValueMetaData().entrySet()) {        Set<String> values = newKeyValues.get(entry.getKey());        if (values == null) {            values = new LinkedHashSet<String>();            newKeyValues.put(entry.getKey(), values);        }        values.add(entry.getValue());    }    createdBy.add(toMerge.getCreatedBy());    return new GlobalMetaData(schema, newKeyValues, createdBy);}
f8de2f8def65778218e0c7121f64665303ea9ee2d388a128fd691651c2761cb6
mergeInto
 static MessageType mergeInto(MessageType toMerge, MessageType mergedSchema)
{    return mergeInto(toMerge, mergedSchema, true);}
6048edfc5b50e5c06dd3f163f01af0f76bb919470d4fe050e9e5facdd01e1db0
mergeInto
 static MessageType mergeInto(MessageType toMerge, MessageType mergedSchema, boolean strict)
{    if (mergedSchema == null) {        return toMerge;    }    return mergedSchema.union(toMerge, strict);}
02a6c728ddd6270bc25b75bfe0e7a300210a265c99566e0893f6407abbe88f08
get
public static NoAlignment get(long rowGroupSize)
{    return new NoAlignment(rowGroupSize);}
f6767c1ea1f52fb5c58c8e4095f20e464fb7b4d514aefe008acd50af05b08869
alignForRowGroup
public void alignForRowGroup(PositionOutputStream out)
{}
897a7efaa9e756e3d8b8d40213213bbcf429db8ab6ecc029d5b4de72ccab4214
nextRowGroupSize
public long nextRowGroupSize(PositionOutputStream out)
{    return rowGroupSize;}
f3c74a2cbcfd5e820e5820fb7d356ae760df7df1f7ef043f11e2aa8c159c8dec
get
public static PaddingAlignment get(long dfsBlockSize, long rowGroupSize, int maxPaddingSize)
{    return new PaddingAlignment(dfsBlockSize, rowGroupSize, maxPaddingSize);}
196bd48ac5fe8fc11896f32b4ce94f83ee2114f0ac0e042a962b1a70c8f7b6ab
alignForRowGroup
public void alignForRowGroup(PositionOutputStream out) throws IOException
{    long remaining = dfsBlockSize - (out.getPos() % dfsBlockSize);    if (isPaddingNeeded(remaining)) {        LOG.debug("Adding {} bytes of padding (row group size={}B, block size={}B)", remaining, rowGroupSize, dfsBlockSize);        for (; remaining > 0; remaining -= zeros.length) {            out.write(zeros, 0, (int) Math.min((long) zeros.length, remaining));        }    }}
81854b2bdc57616a3159cb41fe722081e2f1471a5fc9b7f38c9f6341b5db08ff
nextRowGroupSize
public long nextRowGroupSize(PositionOutputStream out) throws IOException
{    if (maxPaddingSize <= 0) {        return rowGroupSize;    }    long remaining = dfsBlockSize - (out.getPos() % dfsBlockSize);    if (isPaddingNeeded(remaining)) {        return rowGroupSize;    }    return Math.min(remaining, rowGroupSize);}
d39ce2adb4ed622c557e5942c3a42c0e61f89867ac6452957ec5e78c5d5565ef
isPaddingNeeded
protected boolean isPaddingNeeded(long remaining)
{    return (remaining <= maxPaddingSize);}
afec5bc824ab06ec30249a6e540dbcf819f8e00d82189dde31c3e20b7212adef
setTaskSideMetaData
public static void setTaskSideMetaData(Job job, boolean taskSideMetadata)
{    ContextUtil.getConfiguration(job).setBoolean(TASK_SIDE_METADATA, taskSideMetadata);}
1292c8c47c42c2c0a5bcbb0c3363123cda5c40efb962c1aa0ac4d0ae8e310acf
isTaskSideMetaData
public static boolean isTaskSideMetaData(Configuration configuration)
{    return configuration.getBoolean(TASK_SIDE_METADATA, TRUE);}
85014323a0bd389dda59827dcedd2ad104c9fd679e33ff3ce5ce328be2b78828
setReadSupportClass
public static void setReadSupportClass(Job job, Class<?> readSupportClass)
{    ContextUtil.getConfiguration(job).set(READ_SUPPORT_CLASS, readSupportClass.getName());}
57c5c9ebd3a6a9b615254a7be4bd3c2007ef9d1ba7800185cbe8c2d32c93e04c
setUnboundRecordFilter
public static void setUnboundRecordFilter(Job job, Class<? extends UnboundRecordFilter> filterClass)
{    Configuration conf = ContextUtil.getConfiguration(job);    checkArgument(getFilterPredicate(conf) == null, "You cannot provide an UnboundRecordFilter after providing a FilterPredicate");    conf.set(UNBOUND_RECORD_FILTER, filterClass.getName());}
06242e952b8ad606128d2fd7fad8249264b515e9bc58c6ba6c7c5b7a1e4d5f1d
getUnboundRecordFilter
public static Class<?> getUnboundRecordFilter(Configuration configuration)
{    return ConfigurationUtil.getClassFromConfig(configuration, UNBOUND_RECORD_FILTER, UnboundRecordFilter.class);}
c5b560a292132766d3f28c6686f8d4a55f436e798bfed56426a6d320cce67faa
getUnboundRecordFilterInstance
private static UnboundRecordFilter getUnboundRecordFilterInstance(Configuration configuration)
{    Class<?> clazz = ConfigurationUtil.getClassFromConfig(configuration, UNBOUND_RECORD_FILTER, UnboundRecordFilter.class);    if (clazz == null) {        return null;    }    try {        UnboundRecordFilter unboundRecordFilter = (UnboundRecordFilter) clazz.newInstance();        if (unboundRecordFilter instanceof Configurable) {            ((Configurable) unboundRecordFilter).setConf(configuration);        }        return unboundRecordFilter;    } catch (InstantiationException e) {        throw new BadConfigurationException("could not instantiate unbound record filter class", e);    } catch (IllegalAccessException e) {        throw new BadConfigurationException("could not instantiate unbound record filter class", e);    }}
56de865eb1e9959c6a59ceb54fc417e1fd860807c90ed852f56f7c98a0d871e6
setReadSupportClass
public static void setReadSupportClass(JobConf conf, Class<?> readSupportClass)
{    conf.set(READ_SUPPORT_CLASS, readSupportClass.getName());}
fe239c57549612eaa329e7fe7989457bdeac88bfce9d0b47062b1d0aed83ee03
getReadSupportClass
public static Class<?> getReadSupportClass(Configuration configuration)
{    return ConfigurationUtil.getClassFromConfig(configuration, READ_SUPPORT_CLASS, ReadSupport.class);}
20741d6267919bac3561b05b2bdd1df941582045cbf39adc82591b272abc4c52
setFilterPredicate
public static void setFilterPredicate(Configuration configuration, FilterPredicate filterPredicate)
{    checkArgument(getUnboundRecordFilter(configuration) == null, "You cannot provide a FilterPredicate after providing an UnboundRecordFilter");    configuration.set(FILTER_PREDICATE + ".human.readable", filterPredicate.toString());    try {        SerializationUtil.writeObjectToConfAsBase64(FILTER_PREDICATE, filterPredicate, configuration);    } catch (IOException e) {        throw new RuntimeException(e);    }}
b19b7ccf074907f4d9deb2473542e965a1f584fbb245f662c85f0d33c4d0b958
getFilterPredicate
private static FilterPredicate getFilterPredicate(Configuration configuration)
{    try {        return SerializationUtil.readObjectFromConfAsBase64(FILTER_PREDICATE, configuration);    } catch (IOException e) {        throw new RuntimeException(e);    }}
95de07e94417679e663d5aca88853360f1d2c6240a2193ec50d94966ea532bdd
getFilter
public static Filter getFilter(Configuration conf)
{    return FilterCompat.get(getFilterPredicate(conf), getUnboundRecordFilterInstance(conf));}
29924f4488c72d8f23cadb1e6241311725c6cb7bf99473757adb8f22440e7071
createRecordReader
public RecordReader<Void, T> createRecordReader(InputSplit inputSplit, TaskAttemptContext taskAttemptContext) throws IOException, InterruptedException
{    Configuration conf = ContextUtil.getConfiguration(taskAttemptContext);    ReadSupport<T> readSupport = getReadSupport(conf);    return new ParquetRecordReader<T>(readSupport, getFilter(conf));}
d208141bb1e402ba752838aa75119f4b0545d2c09c2cd2e6fe21dc923d263059
getReadSupport
 ReadSupport<T> getReadSupport(Configuration configuration)
{    return getReadSupportInstance(readSupportClass == null ? (Class<? extends ReadSupport<T>>) getReadSupportClass(configuration) : readSupportClass);}
59bc5bd93d435a99727b2881cffb1d281056a461f0d6556b20f6fc7729adccb8
getReadSupportInstance
public static ReadSupport<T> getReadSupportInstance(Configuration configuration)
{    return getReadSupportInstance((Class<? extends ReadSupport<T>>) getReadSupportClass(configuration));}
932b6e834bb400c77247e9b204b94b61740d9da8ba830874236634defd00db48
getReadSupportInstance
 static ReadSupport<T> getReadSupportInstance(Class<? extends ReadSupport<T>> readSupportClass)
{    try {        return readSupportClass.newInstance();    } catch (InstantiationException e) {        throw new BadConfigurationException("could not instantiate read support class", e);    } catch (IllegalAccessException e) {        throw new BadConfigurationException("could not instantiate read support class", e);    }}
37d29e851ed2078ac990b63cf4a0099a8630e39fcc6a1d470b5df49da324219e
isSplitable
protected boolean isSplitable(JobContext context, Path filename)
{    return ContextUtil.getConfiguration(context).getBoolean(SPLIT_FILES, true);}
b7b88c1a4ad437a124d5f0a17b194ccdb1e37bcd23f70f140c6fd725a6d37b8d
getSplits
public List<InputSplit> getSplits(JobContext jobContext) throws IOException
{    Configuration configuration = ContextUtil.getConfiguration(jobContext);    List<InputSplit> splits = new ArrayList<InputSplit>();    if (isTaskSideMetaData(configuration)) {                for (InputSplit split : super.getSplits(jobContext)) {            Preconditions.checkArgument(split instanceof FileSplit, "Cannot wrap non-FileSplit: " + split);            splits.add(ParquetInputSplit.from((FileSplit) split));        }        return splits;    } else {        splits.addAll(getSplits(configuration, getFooters(jobContext)));    }    return splits;}
fc405086cc71c5cc1ef4aec987d0e4dd3cb5facbb299b9912f8b3fc79df8eaca
getSplits
public List<ParquetInputSplit> getSplits(Configuration configuration, List<Footer> footers) throws IOException
{    boolean strictTypeChecking = configuration.getBoolean(STRICT_TYPE_CHECKING, true);    final long maxSplitSize = configuration.getLong("mapred.max.split.size", Long.MAX_VALUE);    final long minSplitSize = Math.max(getFormatMinSplitSize(), configuration.getLong("mapred.min.split.size", 0L));    if (maxSplitSize < 0 || minSplitSize < 0) {        throw new ParquetDecodingException("maxSplitSize or minSplitSize should not be negative: maxSplitSize = " + maxSplitSize + "; minSplitSize = " + minSplitSize);    }    GlobalMetaData globalMetaData = ParquetFileWriter.getGlobalMetaData(footers, strictTypeChecking);    ReadContext readContext = getReadSupport(configuration).init(new InitContext(configuration, globalMetaData.getKeyValueMetaData(), globalMetaData.getSchema()));    return new ClientSideMetadataSplitStrategy().getSplits(configuration, footers, maxSplitSize, minSplitSize, readContext);}
ce0d056ebd79c1f0b962fdca8fff6ffa308febb289340dbea0f81861a29ec38d
listStatus
protected List<FileStatus> listStatus(JobContext jobContext) throws IOException
{    return getAllFileRecursively(super.listStatus(jobContext), ContextUtil.getConfiguration(jobContext));}
e959ab015507307ebd04a4ff963f9f300db5fc952fcbecb10a50ef98e0f3a921
getAllFileRecursively
private static List<FileStatus> getAllFileRecursively(List<FileStatus> files, Configuration conf) throws IOException
{    List<FileStatus> result = new ArrayList<FileStatus>();    for (FileStatus file : files) {        if (file.isDir()) {            Path p = file.getPath();            FileSystem fs = p.getFileSystem(conf);            staticAddInputPathRecursively(result, fs, p, HiddenFileFilter.INSTANCE);        } else {            result.add(file);        }    }    LOG.info("Total input paths to process : {}", result.size());    return result;}
4e8fda1d768ee876b1b57b854ec38f9e399b3071f920ac55ba341515842eeb4e
staticAddInputPathRecursively
private static void staticAddInputPathRecursively(List<FileStatus> result, FileSystem fs, Path path, PathFilter inputFilter) throws IOException
{    for (FileStatus stat : fs.listStatus(path, inputFilter)) {        if (stat.isDir()) {            staticAddInputPathRecursively(result, fs, stat.getPath(), inputFilter);        } else {            result.add(stat);        }    }}
46303b3d5cc61dfd7419db7d84da26b92d11293607b5f030d9ac83fc6af39157
getFooters
public List<Footer> getFooters(JobContext jobContext) throws IOException
{    List<FileStatus> statuses = listStatus(jobContext);    if (statuses.isEmpty()) {        return Collections.emptyList();    }    Configuration config = ContextUtil.getConfiguration(jobContext);            Map<FileStatusWrapper, Footer> footersMap = new LinkedHashMap<FileStatusWrapper, Footer>();    Set<FileStatus> missingStatuses = new HashSet<FileStatus>();    Map<Path, FileStatusWrapper> missingStatusesMap = new HashMap<Path, FileStatusWrapper>(missingStatuses.size());    if (footersCache == null) {        footersCache = new LruCache<FileStatusWrapper, FootersCacheValue>(Math.max(statuses.size(), MIN_FOOTER_CACHE_SIZE));    }    for (FileStatus status : statuses) {        FileStatusWrapper statusWrapper = new FileStatusWrapper(status);        FootersCacheValue cacheEntry = footersCache.getCurrentValue(statusWrapper);        if (LOG.isDebugEnabled()) {            LOG.debug("Cache entry " + (cacheEntry == null ? "not " : "") + " found for '" + status.getPath() + "'");        }        if (cacheEntry != null) {            footersMap.put(statusWrapper, cacheEntry.getFooter());        } else {            footersMap.put(statusWrapper, null);            missingStatuses.add(status);            missingStatusesMap.put(status.getPath(), statusWrapper);        }    }    LOG.debug("found {} footers in cache and adding up to {} missing footers to the cache", footersMap.size(), missingStatuses.size());    if (!missingStatuses.isEmpty()) {        List<Footer> newFooters = getFooters(config, missingStatuses);        for (Footer newFooter : newFooters) {                                                            FileStatusWrapper fileStatus = missingStatusesMap.get(newFooter.getFile());            footersCache.put(fileStatus, new FootersCacheValue(fileStatus, newFooter));        }    }    List<Footer> footers = new ArrayList<Footer>(statuses.size());    for (Entry<FileStatusWrapper, Footer> footerEntry : footersMap.entrySet()) {        Footer footer = footerEntry.getValue();        if (footer == null) {                        footers.add(footersCache.getCurrentValue(footerEntry.getKey()).getFooter());        } else {            footers.add(footer);        }    }    return footers;}
f92ac6167f3d75d3f1701bb3d3d8cb1b0e83302284c587b38cf8f20b11deb7b4
getFooters
public List<Footer> getFooters(Configuration configuration, List<FileStatus> statuses) throws IOException
{    return getFooters(configuration, (Collection<FileStatus>) statuses);}
3e780314c198dbaf7e7868d36d544f5b525f59003b7294cc38981d8873e5a713
getFooters
public List<Footer> getFooters(Configuration configuration, Collection<FileStatus> statuses) throws IOException
{    LOG.debug("reading {} files", statuses.size());    boolean taskSideMetaData = isTaskSideMetaData(configuration);    return ParquetFileReader.readAllFootersInParallelUsingSummaryFiles(configuration, statuses, taskSideMetaData);}
fd92de884bf4892935234fc676c9bc63459c7f11ad4be627eec6e9db2c23fa55
getGlobalMetaData
public GlobalMetaData getGlobalMetaData(JobContext jobContext) throws IOException
{    return ParquetFileWriter.getGlobalMetaData(getFooters(jobContext));}
b57d91f8f02da40d93ff69fc0aeafe8da4beb1a1ab1d5e9a6dbfaab59a3e31a7
isCurrent
public boolean isCurrent(FileStatusWrapper key)
{    long currentModTime = key.getModificationTime();    boolean isCurrent = modificationTime >= currentModTime;    if (LOG.isDebugEnabled() && !isCurrent) {        LOG.debug("The cache value for '{}' is not current: cached modification time={}, current modification time: {}", key, modificationTime, currentModTime);    }    return isCurrent;}
2bd8d7b232a8b88c7f039386cad2dab23790d0930d5219bf52c2483b68a8417c
getFooter
public Footer getFooter()
{    return footer;}
09d5afb58333a1431aef4e07171ac689e592a11223617d88524b07c6d4a2ea5a
isNewerThan
public boolean isNewerThan(FootersCacheValue otherValue)
{    return otherValue == null || modificationTime > otherValue.modificationTime;}
8db7848085b680ef314213a1bef8feee4e1decb8072466d9168d74d75362d8fb
getPath
public Path getPath()
{    return footer.getFile();}
461ccb3fefa60e5a10d299c8924a0d848b6aaf387d5844d17485b021ed6c89a0
getModificationTime
public long getModificationTime()
{    return status.getModificationTime();}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return status.hashCode();}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    return other instanceof FileStatusWrapper && status.equals(((FileStatusWrapper) other).status);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return status.getPath().toString();}
bc4744f20a607fe4808985df1a1baaa0a361a0367e8e4220dde6e6bbcfb2ae28
compare
public int compare(BlockLocation b1, BlockLocation b2)
{    return Long.signum(b1.getOffset() - b2.getOffset());}
af066515bbd4018ba1092a29cfd37e21c00c89e485443cdc0f0c77280694f79d
getHDFSBlockEndingPosition
private long getHDFSBlockEndingPosition(int hdfsBlockIndex)
{    BlockLocation hdfsBlock = hdfsBlocks[hdfsBlockIndex];    return hdfsBlock.getOffset() + hdfsBlock.getLength() - 1;}
9b81ed16560b2edfef91c683d4b920a5c91ed0b67d6f6ca57e88bd05f87de278
checkBelongingToANewHDFSBlock
private boolean checkBelongingToANewHDFSBlock(BlockMetaData rowGroupMetadata)
{    boolean isNewHdfsBlock = false;    long rowGroupMidPoint = rowGroupMetadata.getStartingPos() + (rowGroupMetadata.getCompressedSize() / 2);        while (rowGroupMidPoint > getHDFSBlockEndingPosition(currentMidPointHDFSBlockIndex)) {        isNewHdfsBlock = true;        currentMidPointHDFSBlockIndex++;        if (currentMidPointHDFSBlockIndex >= hdfsBlocks.length)            throw new ParquetDecodingException("the row group is not in hdfs blocks in the file: midpoint of row groups is " + rowGroupMidPoint + ", the end of the hdfs block is " + getHDFSBlockEndingPosition(currentMidPointHDFSBlockIndex - 1));    }    while (rowGroupMetadata.getStartingPos() > getHDFSBlockEndingPosition(currentStartHdfsBlockIndex)) {        currentStartHdfsBlockIndex++;        if (currentStartHdfsBlockIndex >= hdfsBlocks.length)            throw new ParquetDecodingException("The row group does not start in this file: row group offset is " + rowGroupMetadata.getStartingPos() + " but the end of hdfs blocks of file is " + getHDFSBlockEndingPosition(currentStartHdfsBlockIndex));    }    return isNewHdfsBlock;}
8689e21979b74aa6ec00d5cb2e85ada89ada46515f5ee28baf22cb750249e6ed
getCurrentBlock
public BlockLocation getCurrentBlock()
{    return hdfsBlocks[currentStartHdfsBlockIndex];}
80865273e8e79e8ef1ea33c00b925471ea71a65009ba29ed92baf9be79cb0f76
addRowGroup
private void addRowGroup(BlockMetaData rowGroup)
{    this.rowGroups.add(rowGroup);    this.compressedByteSize += rowGroup.getCompressedSize();}
0f1e51a118b369d3b874a45c510210b21ec63f1235a08299f66dc92b6f03adab
getCompressedByteSize
public long getCompressedByteSize()
{    return compressedByteSize;}
5f76a38992abc58acf276b34a3cf66dcce0cdab2d6cf845420ad7870f0a576a3
getRowGroups
public List<BlockMetaData> getRowGroups()
{    return rowGroups;}
c62f566267855a6cae5ea87b01986413618e7ae1e7b5f9229c1961feb6414bbd
getRowGroupCount
 int getRowGroupCount()
{    return rowGroups.size();}
7c87d16ed441bd64c9b62d1bc45cbdca72227c1bb2b12e318ad4f951df2f5015
getParquetInputSplit
public ParquetInputSplit getParquetInputSplit(FileStatus fileStatus, String requestedSchema, Map<String, String> readSupportMetadata) throws IOException
{    MessageType requested = MessageTypeParser.parseMessageType(requestedSchema);    long length = 0;    for (BlockMetaData block : this.getRowGroups()) {        List<ColumnChunkMetaData> columns = block.getColumns();        for (ColumnChunkMetaData column : columns) {            if (requested.containsPath(column.getPath().toArray())) {                length += column.getTotalSize();            }        }    }    BlockMetaData lastRowGroup = this.getRowGroups().get(this.getRowGroupCount() - 1);    long end = lastRowGroup.getStartingPos() + lastRowGroup.getTotalByteSize();    long[] rowGroupOffsets = new long[this.getRowGroupCount()];    for (int i = 0; i < rowGroupOffsets.length; i++) {        rowGroupOffsets[i] = this.getRowGroups().get(i).getStartingPos();    }    return new ParquetInputSplit(fileStatus.getPath(), hdfsBlock.getOffset(), end, length, hdfsBlock.getHosts(), rowGroupOffsets);}
5c08b0f06a6c5198f017133c0b04ff086f7cf161780bd0da8bb8dcdce8cb7ccf
getSplits
 List<ParquetInputSplit> getSplits(Configuration configuration, List<Footer> footers, long maxSplitSize, long minSplitSize, ReadContext readContext) throws IOException
{    List<ParquetInputSplit> splits = new ArrayList<ParquetInputSplit>();    Filter filter = ParquetInputFormat.getFilter(configuration);    long rowGroupsDropped = 0;    long totalRowGroups = 0;    for (Footer footer : footers) {        final Path file = footer.getFile();        LOG.debug("{}", file);        FileSystem fs = file.getFileSystem(configuration);        FileStatus fileStatus = fs.getFileStatus(file);        ParquetMetadata parquetMetaData = footer.getParquetMetadata();        List<BlockMetaData> blocks = parquetMetaData.getBlocks();        List<BlockMetaData> filteredBlocks;        totalRowGroups += blocks.size();        filteredBlocks = RowGroupFilter.filterRowGroups(filter, blocks, parquetMetaData.getFileMetaData().getSchema());        rowGroupsDropped += blocks.size() - filteredBlocks.size();        if (filteredBlocks.isEmpty()) {            continue;        }        BlockLocation[] fileBlockLocations = fs.getFileBlockLocations(fileStatus, 0, fileStatus.getLen());        splits.addAll(generateSplits(filteredBlocks, fileBlockLocations, fileStatus, readContext.getRequestedSchema().toString(), readContext.getReadSupportMetadata(), minSplitSize, maxSplitSize));    }    if (rowGroupsDropped > 0 && totalRowGroups > 0) {        int percentDropped = (int) ((((double) rowGroupsDropped) / totalRowGroups) * 100);        LOG.info("Dropping {} row groups that do not pass filter predicate! ({}%)", rowGroupsDropped, percentDropped);    } else {        LOG.info("There were no row groups that could be dropped due to filter predicates");    }    return splits;}
2c92cb4a543220d3b445fd6efb83e0945711ab51f52d33bfd65807ba65915cd8
generateSplits
 static List<ParquetInputSplit> generateSplits(List<BlockMetaData> rowGroupBlocks, BlockLocation[] hdfsBlocksArray, FileStatus fileStatus, String requestedSchema, Map<String, String> readSupportMetadata, long minSplitSize, long maxSplitSize) throws IOException
{    List<SplitInfo> splitRowGroups = generateSplitInfo(rowGroupBlocks, hdfsBlocksArray, minSplitSize, maxSplitSize);        List<ParquetInputSplit> resultSplits = new ArrayList<ParquetInputSplit>();    for (SplitInfo splitInfo : splitRowGroups) {        ParquetInputSplit split = splitInfo.getParquetInputSplit(fileStatus, requestedSchema, readSupportMetadata);        resultSplits.add(split);    }    return resultSplits;}
3359f4e715320727d0627c8b526c51d2f662b1f61c51fd2fc90cbade7bca3db0
generateSplitInfo
 static List<SplitInfo> generateSplitInfo(List<BlockMetaData> rowGroupBlocks, BlockLocation[] hdfsBlocksArray, long minSplitSize, long maxSplitSize)
{    List<SplitInfo> splitRowGroups;    if (maxSplitSize < minSplitSize || maxSplitSize < 0 || minSplitSize < 0) {        throw new ParquetDecodingException("maxSplitSize and minSplitSize should be positive and max should be greater or equal to the minSplitSize: maxSplitSize = " + maxSplitSize + "; minSplitSize is " + minSplitSize);    }    HDFSBlocks hdfsBlocks = new HDFSBlocks(hdfsBlocksArray);    hdfsBlocks.checkBelongingToANewHDFSBlock(rowGroupBlocks.get(0));    SplitInfo currentSplit = new SplitInfo(hdfsBlocks.getCurrentBlock());        splitRowGroups = new ArrayList<SplitInfo>();        checkSorted(rowGroupBlocks);    for (BlockMetaData rowGroupMetadata : rowGroupBlocks) {        if ((hdfsBlocks.checkBelongingToANewHDFSBlock(rowGroupMetadata) && currentSplit.getCompressedByteSize() >= minSplitSize && currentSplit.getCompressedByteSize() > 0) || currentSplit.getCompressedByteSize() >= maxSplitSize) {                                    splitRowGroups.add(currentSplit);            currentSplit = new SplitInfo(hdfsBlocks.getCurrentBlock());        }        currentSplit.addRowGroup(rowGroupMetadata);    }    if (currentSplit.getRowGroupCount() > 0) {        splitRowGroups.add(currentSplit);    }    return splitRowGroups;}
c8af09e5d6ed74ee6879dd9f30e0fe829eda8db5ad637753e31ba5c8be718714
checkSorted
private static void checkSorted(List<BlockMetaData> rowGroupBlocks)
{    long previousOffset = 0L;    for (BlockMetaData rowGroup : rowGroupBlocks) {        long currentOffset = rowGroup.getStartingPos();        if (currentOffset < previousOffset) {            throw new ParquetDecodingException("row groups are not sorted: previous row groups starts at " + previousOffset + ", current row group starts at " + currentOffset);        }    }}
ea28dc7d9bca61a7e319123c3cda1b699a32a166f6e4864f3b2e77cddc00edfe
end
private static long end(List<BlockMetaData> blocks, String requestedSchema)
{    MessageType requested = MessageTypeParser.parseMessageType(requestedSchema);    long length = 0;    for (BlockMetaData block : blocks) {        List<ColumnChunkMetaData> columns = block.getColumns();        for (ColumnChunkMetaData column : columns) {            if (requested.containsPath(column.getPath().toArray())) {                length += column.getTotalSize();            }        }    }    return length;}
8bc35b67ee4d77b75ffb70abda4601ff56e8d8b676c6b696a3fe40335e192fcb
offsets
private static long[] offsets(List<BlockMetaData> blocks)
{    long[] offsets = new long[blocks.size()];    for (int i = 0; i < offsets.length; i++) {        offsets[i] = blocks.get(i).getStartingPos();    }    return offsets;}
332c9204c807e91c856e0b541640b1a316868dfe73d3bca672055592d33786d5
getBlocks
public List<BlockMetaData> getBlocks()
{    throw new UnsupportedOperationException("Splits no longer have row group metadata, see PARQUET-234");}
3bc1e820d2292a3364b686d1b7ccee11f9dee845f907e1345e28f5fdae66148a
from
 static ParquetInputSplit from(FileSplit split) throws IOException
{    return new ParquetInputSplit(split.getPath(), split.getStart(), split.getStart() + split.getLength(), split.getLength(), split.getLocations(), null);}
d34bedecb8e17695df53e91e0f202b6ca15d6c78282755c99143d7d3454a7db5
from
 static ParquetInputSplit from(org.apache.hadoop.mapred.FileSplit split) throws IOException
{    return new ParquetInputSplit(split.getPath(), split.getStart(), split.getStart() + split.getLength(), split.getLength(), split.getLocations(), null);}
9247db7b5b8ea3e24844571385a5839376d4b1179f48eb831d1a5999ef9c6503
getRequestedSchema
 String getRequestedSchema()
{    throw new UnsupportedOperationException("Splits no longer have the requested schema, see PARQUET-234");}
3fff2cd7a6e5a0304dca06c41346db87cd3399d05c4039dcd9c496ecf4294159
getFileSchema
public String getFileSchema()
{    throw new UnsupportedOperationException("Splits no longer have the file schema, see PARQUET-234");}
76e5506138920aa532662ee3bc845ae312dac0cd3f072a6d3a9c04c07008c2e9
getEnd
public long getEnd()
{    return end;}
c89b8a8b6b1221a91073292fec8164026f4b810930eb946454021979d10f58e2
getExtraMetadata
public Map<String, String> getExtraMetadata()
{    throw new UnsupportedOperationException("Splits no longer have file metadata, see PARQUET-234");}
13fff94c0ec4088f5ec5cd229742c8845a1684c2c569d96a04a1f93d77bb8b58
getReadSupportMetadata
 Map<String, String> getReadSupportMetadata()
{    throw new UnsupportedOperationException("Splits no longer have read-support metadata, see PARQUET-234");}
da1cd24611cb795c60f9219a8290069d9df354e1576157aefd02c986f426ebdd
getRowGroupOffsets
public long[] getRowGroupOffsets()
{    return rowGroupOffsets;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    String hosts;    try {        hosts = Arrays.toString(getLocations());    } catch (Exception e) {                hosts = "(" + e + ")";    }    return this.getClass().getSimpleName() + "{" + "part: " + getPath() + " start: " + getStart() + " end: " + getEnd() + " length: " + getLength() + " hosts: " + hosts + (rowGroupOffsets == null ? "" : (" row groups: " + Arrays.toString(rowGroupOffsets))) + "}";}
40ca3400743bb8feec832157f191de52515f96f7a4b584c564ef5969a3036780
readFields
public void readFields(DataInput hin) throws IOException
{    byte[] bytes = readArray(hin);    DataInputStream in = new DataInputStream(new GZIPInputStream(new ByteArrayInputStream(bytes)));    super.readFields(in);    this.end = in.readLong();    if (in.readBoolean()) {        this.rowGroupOffsets = new long[in.readInt()];        for (int i = 0; i < rowGroupOffsets.length; i++) {            rowGroupOffsets[i] = in.readLong();        }    }    in.close();}
a04f57522db6a89f47013fb27011d889fad67ccd227a5c3c9f59fccbecc0b7cd
write
public void write(DataOutput hout) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutputStream out = new DataOutputStream(new GZIPOutputStream(baos));    super.write(out);    out.writeLong(end);    out.writeBoolean(rowGroupOffsets != null);    if (rowGroupOffsets != null) {        out.writeInt(rowGroupOffsets.length);        for (long o : rowGroupOffsets) {            out.writeLong(o);        }    }    out.close();    writeArray(hout, baos.toByteArray());}
a43535d16b6039461d4c18926212482127aa8a09d19d669601568119658ea95e
writeArray
private static void writeArray(DataOutput out, byte[] bytes) throws IOException
{    out.writeInt(bytes.length);    out.write(bytes, 0, bytes.length);}
1e7d39721c8a82bb9a016bbd21dca85714b0ca5e2d8dc4f9713d51d094bdf08e
readArray
private static byte[] readArray(DataInput in) throws IOException
{    int len = in.readInt();    byte[] bytes = new byte[len];    in.readFully(bytes);    return bytes;}
b198207eaa6c446cd4bba318df29406cd9f4af119151e41cda1f0fd4c2965905
commitJob
public void commitJob(JobContext jobContext) throws IOException
{    super.commitJob(jobContext);    Configuration configuration = ContextUtil.getConfiguration(jobContext);    writeMetaDataFile(configuration, outputPath);}
e7124abb0db547b6e10515ce96ef55fed4bfd7f7cb9c0f081367e16615087c46
writeMetaDataFile
public static void writeMetaDataFile(Configuration configuration, Path outputPath)
{    JobSummaryLevel level = ParquetOutputFormat.getJobSummaryLevel(configuration);    if (level == JobSummaryLevel.NONE) {        return;    }    try {        final FileSystem fileSystem = outputPath.getFileSystem(configuration);        FileStatus outputStatus = fileSystem.getFileStatus(outputPath);        List<Footer> footers;        switch(level) {            case ALL:                                footers = ParquetFileReader.readAllFootersInParallel(configuration, outputStatus, false);                break;            case COMMON_ONLY:                                footers = ParquetFileReader.readAllFootersInParallel(configuration, outputStatus, true);                break;            default:                throw new IllegalArgumentException("Unrecognized job summary level: " + level);        }                if (footers.isEmpty()) {            return;        }        try {            ParquetFileWriter.writeMetadataFile(configuration, outputPath, footers, level);        } catch (Exception e) {            LOG.warn("could not write summary file(s) for " + outputPath, e);            final Path metadataPath = new Path(outputPath, ParquetFileWriter.PARQUET_METADATA_FILE);            try {                if (fileSystem.exists(metadataPath)) {                    fileSystem.delete(metadataPath, true);                }            } catch (Exception e2) {                LOG.warn("could not delete metadata file" + outputPath, e2);            }            try {                final Path commonMetadataPath = new Path(outputPath, ParquetFileWriter.PARQUET_COMMON_METADATA_FILE);                if (fileSystem.exists(commonMetadataPath)) {                    fileSystem.delete(commonMetadataPath, true);                }            } catch (Exception e2) {                LOG.warn("could not delete metadata file" + outputPath, e2);            }        }    } catch (Exception e) {        LOG.warn("could not write summary file for " + outputPath, e);    }}
331d58ecfac42d2fa94a294aa20069b1ea7ae517987bde379c26677867f294ff
getJobSummaryLevel
public static JobSummaryLevel getJobSummaryLevel(Configuration conf)
{    String level = conf.get(JOB_SUMMARY_LEVEL);    String deprecatedFlag = conf.get(ENABLE_JOB_SUMMARY);    if (deprecatedFlag != null) {        LOG.warn("Setting " + ENABLE_JOB_SUMMARY + " is deprecated, please use " + JOB_SUMMARY_LEVEL);    }    if (level != null && deprecatedFlag != null) {        LOG.warn("Both " + JOB_SUMMARY_LEVEL + " and " + ENABLE_JOB_SUMMARY + " are set! " + ENABLE_JOB_SUMMARY + " will be ignored.");    }    if (level != null) {        return JobSummaryLevel.valueOf(level.toUpperCase());    }    if (deprecatedFlag != null) {        return Boolean.valueOf(deprecatedFlag) ? JobSummaryLevel.ALL : JobSummaryLevel.NONE;    }    return JobSummaryLevel.ALL;}
0416d50c7e27c36387e9b9b7e742c1200db00a3c9273aaf92c067b1934ac46ba
setWriteSupportClass
public static void setWriteSupportClass(Job job, Class<?> writeSupportClass)
{    getConfiguration(job).set(WRITE_SUPPORT_CLASS, writeSupportClass.getName());}
603adc79917c324d658b7f585ad990d731957ec5b8d4ba7627fd7721d4242d13
setWriteSupportClass
public static void setWriteSupportClass(JobConf job, Class<?> writeSupportClass)
{    job.set(WRITE_SUPPORT_CLASS, writeSupportClass.getName());}
ecc94d1578a784520653df0d25f97f7f82043c73fe23a2d1a11dc129bdf78749
getWriteSupportClass
public static Class<?> getWriteSupportClass(Configuration configuration)
{    final String className = configuration.get(WRITE_SUPPORT_CLASS);    if (className == null) {        return null;    }    final Class<?> writeSupportClass = ConfigurationUtil.getClassFromConfig(configuration, WRITE_SUPPORT_CLASS, WriteSupport.class);    return writeSupportClass;}
a992b425e296a05d927a1e933ca0d5532c23be5784246195c005ac7e93af977e
setBlockSize
public static void setBlockSize(Job job, int blockSize)
{    getConfiguration(job).setInt(BLOCK_SIZE, blockSize);}
3acf1e128ba0153bef87362ef03c5bc09d35b5e8eda8b981b6e64c5489a26b67
setPageSize
public static void setPageSize(Job job, int pageSize)
{    getConfiguration(job).setInt(PAGE_SIZE, pageSize);}
2bd37173a3cf77dadb3223f44e9759844fa6b4865aeef21fc29cc2afb9a7b787
setDictionaryPageSize
public static void setDictionaryPageSize(Job job, int pageSize)
{    getConfiguration(job).setInt(DICTIONARY_PAGE_SIZE, pageSize);}
07fc3f9f40e8e58d2ab76792b59c0743d996bb41ff39383655f998eeeaae0a94
setCompression
public static void setCompression(Job job, CompressionCodecName compression)
{    getConfiguration(job).set(COMPRESSION, compression.name());}
30044be3b48683963725a681af501db2e06700d0567ef39ceb095a176afb1682
setEnableDictionary
public static void setEnableDictionary(Job job, boolean enableDictionary)
{    getConfiguration(job).setBoolean(ENABLE_DICTIONARY, enableDictionary);}
e5fe3b2b6cb897a927d0bd5f5c6a83e75aa2e55e600295d98ed1eb13480d52e5
getEnableDictionary
public static boolean getEnableDictionary(JobContext jobContext)
{    return getEnableDictionary(getConfiguration(jobContext));}
f81ead1924434da9d7d7d4a40e876f8a34baf13a77690ccab8e53396aae10ad9
getBlockSize
public static int getBlockSize(JobContext jobContext)
{    return getBlockSize(getConfiguration(jobContext));}
ab74ba836c799d4653666bcca18fc43bd794e378f94ad19d6c968fbdf3853dda
getPageSize
public static int getPageSize(JobContext jobContext)
{    return getPageSize(getConfiguration(jobContext));}
15d326714a5bf0b2cbc3e7e0c8d2880ecaca1422b73d6d788a26532f455793ce
getDictionaryPageSize
public static int getDictionaryPageSize(JobContext jobContext)
{    return getDictionaryPageSize(getConfiguration(jobContext));}
31066de5a213e48374fbf5ca96f4a8d1b05241f8ec5ab3e576f01c7aaacac21e
getCompression
public static CompressionCodecName getCompression(JobContext jobContext)
{    return getCompression(getConfiguration(jobContext));}
0adb16bee3de4aa59f8a2eb4860fec347fa8d7aecd59547a35cc368575db2cfb
isCompressionSet
public static boolean isCompressionSet(JobContext jobContext)
{    return isCompressionSet(getConfiguration(jobContext));}
62aeb38eb8b93e3ea3f0ab7072690f4b5161afb02ef42abb18226c6e590c3f1a
setValidation
public static void setValidation(JobContext jobContext, boolean validating)
{    setValidation(getConfiguration(jobContext), validating);}
4cd3380d969f56abdaf5c111e5d4a42a971a817bf933d45e0d05e0b9a1e19f3e
getValidation
public static boolean getValidation(JobContext jobContext)
{    return getValidation(getConfiguration(jobContext));}
9250d0530fd20753cf3600a36dfb42d168549bfbb948485c07fa5dbc887f2fcf
getEnableDictionary
public static boolean getEnableDictionary(Configuration configuration)
{    return configuration.getBoolean(ENABLE_DICTIONARY, ParquetProperties.DEFAULT_IS_DICTIONARY_ENABLED);}
e537a1d29c744b38cc038813ee729579967d7da515270df25138397d3f2c5dc7
getMinRowCountForPageSizeCheck
public static int getMinRowCountForPageSizeCheck(Configuration configuration)
{    return configuration.getInt(MIN_ROW_COUNT_FOR_PAGE_SIZE_CHECK, ParquetProperties.DEFAULT_MINIMUM_RECORD_COUNT_FOR_CHECK);}
ed1d58220e068d66ebfab32f933ae1387d47f00176f616aa7bd2e5f308f5c950
getMaxRowCountForPageSizeCheck
public static int getMaxRowCountForPageSizeCheck(Configuration configuration)
{    return configuration.getInt(MAX_ROW_COUNT_FOR_PAGE_SIZE_CHECK, ParquetProperties.DEFAULT_MAXIMUM_RECORD_COUNT_FOR_CHECK);}
b9569b10987c8406174721cf801501baceeff845727ea4122012d8b0c2b1742f
getEstimatePageSizeCheck
public static boolean getEstimatePageSizeCheck(Configuration configuration)
{    return configuration.getBoolean(ESTIMATE_PAGE_SIZE_CHECK, ParquetProperties.DEFAULT_ESTIMATE_ROW_COUNT_FOR_PAGE_SIZE_CHECK);}
17b19986ccfd2455a03f94561e07f20281c315c579f0c8bec80a37f1356e1c6b
getBlockSize
public static int getBlockSize(Configuration configuration)
{    return configuration.getInt(BLOCK_SIZE, DEFAULT_BLOCK_SIZE);}
eb364cca8b816f878000b9cf7a8673446e54eb863a671be6a14a38e4999a8a24
getLongBlockSize
public static long getLongBlockSize(Configuration configuration)
{    return configuration.getLong(BLOCK_SIZE, DEFAULT_BLOCK_SIZE);}
6b8ac31ebd12760f5a1a86a0c33eabf9755b45adc613bb8c74020edb93e86d7a
getPageSize
public static int getPageSize(Configuration configuration)
{    return configuration.getInt(PAGE_SIZE, ParquetProperties.DEFAULT_PAGE_SIZE);}
1c62166283c969d04dfd6847af2ca10b7326a733d7a8ec7771ba2165769a5631
getDictionaryPageSize
public static int getDictionaryPageSize(Configuration configuration)
{    return configuration.getInt(DICTIONARY_PAGE_SIZE, ParquetProperties.DEFAULT_DICTIONARY_PAGE_SIZE);}
5184be5a3b9d0a7c7c8202f16ac83a1e684008ac6e14997b9036aac2ccf5fbf8
getWriterVersion
public static WriterVersion getWriterVersion(Configuration configuration)
{    String writerVersion = configuration.get(WRITER_VERSION, ParquetProperties.DEFAULT_WRITER_VERSION.toString());    return WriterVersion.fromString(writerVersion);}
ada156a7d1a2ba96d5b45370158b1006a524ebab4ea8f3376e32a6ea63a4c2f9
getCompression
public static CompressionCodecName getCompression(Configuration configuration)
{    return CodecConfig.getParquetCompressionCodec(configuration);}
9af03b6665adec5997f70431282709100b8f000bf7a0bf8ed611d78d12c4c049
isCompressionSet
public static boolean isCompressionSet(Configuration configuration)
{    return CodecConfig.isParquetCompressionSet(configuration);}
83050ec0c7000ba5efdd00f390d64afe6bc877650ba3d91911bf8d07041a350a
setValidation
public static void setValidation(Configuration configuration, boolean validating)
{    configuration.setBoolean(VALIDATION, validating);}
cb357aa04a899636c7c137beeb49310742350d2ba14fa71c6f10d472d6862f12
getValidation
public static boolean getValidation(Configuration configuration)
{    return configuration.getBoolean(VALIDATION, false);}
90f365eb5c8d908b1e875e1391a235abe2fdb0f141043f8d408774335ff5c000
getCodec
private CompressionCodecName getCodec(TaskAttemptContext taskAttemptContext)
{    return CodecConfig.from(taskAttemptContext).getCodec();}
5acc7ec4113f83d0b12a35681156cf2bd9d637cb1c728e96ffc03cc894136301
setMaxPaddingSize
public static void setMaxPaddingSize(JobContext jobContext, int maxPaddingSize)
{    setMaxPaddingSize(getConfiguration(jobContext), maxPaddingSize);}
410ebec1e9fc16243c7d22bf658b1e24201e1709370034d1f366bd7b2f67f8e6
setMaxPaddingSize
public static void setMaxPaddingSize(Configuration conf, int maxPaddingSize)
{    conf.setInt(MAX_PADDING_BYTES, maxPaddingSize);}
a29ade495304177f88d8492d5c2ff395428ad638af69e7bd890e15f0bc395582
getMaxPaddingSize
private static int getMaxPaddingSize(Configuration conf)
{    return conf.getInt(MAX_PADDING_BYTES, ParquetWriter.MAX_PADDING_SIZE_DEFAULT);}
0c22c94cfd86b33defc833f0881fc9490fdfd30336aec54188a07614a1620d42
setColumnIndexTruncateLength
public static void setColumnIndexTruncateLength(JobContext jobContext, int length)
{    setColumnIndexTruncateLength(getConfiguration(jobContext), length);}
d6dc05b582f0aaaf04b0aa8f7095572a5cd457b5fa2d20297311b647df71175d
setColumnIndexTruncateLength
public static void setColumnIndexTruncateLength(Configuration conf, int length)
{    conf.setInt(COLUMN_INDEX_TRUNCATE_LENGTH, length);}
2bd80207b7949acf91a1d3c5e0fd6aed732aa52f2ec0fcfa50ab489230e2393d
getColumnIndexTruncateLength
private static int getColumnIndexTruncateLength(Configuration conf)
{    return conf.getInt(COLUMN_INDEX_TRUNCATE_LENGTH, ParquetProperties.DEFAULT_COLUMN_INDEX_TRUNCATE_LENGTH);}
beedd5aa3cdd887a1370b927d6f6edbf427116d57f07ff1c62e9651783829c44
setPageRowCountLimit
public static void setPageRowCountLimit(JobContext jobContext, int rowCount)
{    setPageRowCountLimit(getConfiguration(jobContext), rowCount);}
236d8f2cb7a8ea38de98aeae4efd303309bb4afb961d53d92f938b39708206e9
setPageRowCountLimit
public static void setPageRowCountLimit(Configuration conf, int rowCount)
{    conf.setInt(PAGE_ROW_COUNT_LIMIT, rowCount);}
caf401c0abd36608287cdaffeb537d9c3d7ed8078d7ccfd1e7b1deafb37e8c20
getPageRowCountLimit
private static int getPageRowCountLimit(Configuration conf)
{    return conf.getInt(PAGE_ROW_COUNT_LIMIT, ParquetProperties.DEFAULT_PAGE_ROW_COUNT_LIMIT);}
e266c4f18387f51960d6e43ae2c95eadc821a4e451b20f3f99c4fd8b33250d3d
setPageWriteChecksumEnabled
public static void setPageWriteChecksumEnabled(JobContext jobContext, boolean val)
{    setPageWriteChecksumEnabled(getConfiguration(jobContext), val);}
8c5fd091b6d967d8718af9e1d99e2ba2849aac4cc4f3794f691bfe786e5060d4
setPageWriteChecksumEnabled
public static void setPageWriteChecksumEnabled(Configuration conf, boolean val)
{    conf.setBoolean(PAGE_WRITE_CHECKSUM_ENABLED, val);}
52da257a8f41da03c9d77ea89b5aac2d503183b82ade3d64256ec16e80980627
getPageWriteChecksumEnabled
public static boolean getPageWriteChecksumEnabled(Configuration conf)
{    return conf.getBoolean(PAGE_WRITE_CHECKSUM_ENABLED, ParquetProperties.DEFAULT_PAGE_WRITE_CHECKSUM_ENABLED);}
0db87499339e0ae09c4688f947bf755551068a4ee77f3f5dd3cd78abc12edaa4
getRecordWriter
public RecordWriter<Void, T> getRecordWriter(TaskAttemptContext taskAttemptContext) throws IOException, InterruptedException
{    return getRecordWriter(taskAttemptContext, Mode.CREATE);}
ec3b7b2fae62f71e548bb7ba90d2366faf03368c8eb0152d47464b6a5e9357f3
getRecordWriter
public RecordWriter<Void, T> getRecordWriter(TaskAttemptContext taskAttemptContext, Mode mode) throws IOException, InterruptedException
{    final Configuration conf = getConfiguration(taskAttemptContext);    CompressionCodecName codec = getCodec(taskAttemptContext);    String extension = codec.getExtension() + ".parquet";    Path file = getDefaultWorkFile(taskAttemptContext, extension);    return getRecordWriter(conf, file, codec, mode);}
3c7e07468f9bb8d83aaa19423df95a82eda09815398bc4c3c2b59b05430dba74
getRecordWriter
public RecordWriter<Void, T> getRecordWriter(TaskAttemptContext taskAttemptContext, Path file) throws IOException, InterruptedException
{    return getRecordWriter(taskAttemptContext, file, Mode.CREATE);}
8daa6bd22640391c390dc7627eed109c26c9ca43586b775011fd5b2d96f68c24
getRecordWriter
public RecordWriter<Void, T> getRecordWriter(TaskAttemptContext taskAttemptContext, Path file, Mode mode) throws IOException, InterruptedException
{    return getRecordWriter(getConfiguration(taskAttemptContext), file, getCodec(taskAttemptContext), mode);}
d83f9fa36dfee62bce14ae44ce016e7d9128443bfcff2d64b1636670dd32262f
getRecordWriter
public RecordWriter<Void, T> getRecordWriter(Configuration conf, Path file, CompressionCodecName codec) throws IOException, InterruptedException
{    return getRecordWriter(conf, file, codec, Mode.CREATE);}
0bdf2d9af3c085862acfcc1163089f075c3f2b5323bee8e42a707ebb756d798b
getRecordWriter
public RecordWriter<Void, T> getRecordWriter(Configuration conf, Path file, CompressionCodecName codec, Mode mode) throws IOException, InterruptedException
{    final WriteSupport<T> writeSupport = getWriteSupport(conf);    ParquetProperties props = ParquetProperties.builder().withPageSize(getPageSize(conf)).withDictionaryPageSize(getDictionaryPageSize(conf)).withDictionaryEncoding(getEnableDictionary(conf)).withWriterVersion(getWriterVersion(conf)).estimateRowCountForPageSizeCheck(getEstimatePageSizeCheck(conf)).withMinRowCountForPageSizeCheck(getMinRowCountForPageSizeCheck(conf)).withMaxRowCountForPageSizeCheck(getMaxRowCountForPageSizeCheck(conf)).withColumnIndexTruncateLength(getColumnIndexTruncateLength(conf)).withPageRowCountLimit(getPageRowCountLimit(conf)).withPageWriteChecksumEnabled(getPageWriteChecksumEnabled(conf)).build();    long blockSize = getLongBlockSize(conf);    int maxPaddingSize = getMaxPaddingSize(conf);    boolean validating = getValidation(conf);    if (LOG.isInfoEnabled()) {        LOG.info("Parquet block size to {}", blockSize);        LOG.info("Parquet page size to {}", props.getPageSizeThreshold());        LOG.info("Parquet dictionary page size to {}", props.getDictionaryPageSizeThreshold());        LOG.info("Dictionary is {}", (props.isEnableDictionary() ? "on" : "off"));        LOG.info("Validation is {}", (validating ? "on" : "off"));        LOG.info("Writer version is: {}", props.getWriterVersion());        LOG.info("Maximum row group padding size is {} bytes", maxPaddingSize);        LOG.info("Page size checking is: {}", (props.estimateNextSizeCheck() ? "estimated" : "constant"));        LOG.info("Min row count for page size check is: {}", props.getMinRowCountForPageSizeCheck());        LOG.info("Max row count for page size check is: {}", props.getMaxRowCountForPageSizeCheck());        LOG.info("Truncate length for column indexes is: {}", props.getColumnIndexTruncateLength());        LOG.info("Page row count limit to {}", props.getPageRowCountLimit());        LOG.info("Writing page checksums is: {}", props.getPageWriteChecksumEnabled() ? "on" : "off");    }    WriteContext init = writeSupport.init(conf);    ParquetFileWriter w = new ParquetFileWriter(HadoopOutputFile.fromPath(file, conf), init.getSchema(), mode, blockSize, maxPaddingSize, props.getColumnIndexTruncateLength(), props.getPageWriteChecksumEnabled());    w.start();    float maxLoad = conf.getFloat(ParquetOutputFormat.MEMORY_POOL_RATIO, MemoryManager.DEFAULT_MEMORY_POOL_RATIO);    long minAllocation = conf.getLong(ParquetOutputFormat.MIN_MEMORY_ALLOCATION, MemoryManager.DEFAULT_MIN_MEMORY_ALLOCATION);    synchronized (ParquetOutputFormat.class) {        if (memoryManager == null) {            memoryManager = new MemoryManager(maxLoad, minAllocation);        }    }    if (memoryManager.getMemoryPoolRatio() != maxLoad) {        LOG.warn("The configuration " + MEMORY_POOL_RATIO + " has been set. It should not " + "be reset by the new value: " + maxLoad);    }    return new ParquetRecordWriter<T>(w, writeSupport, init.getSchema(), init.getExtraMetaData(), blockSize, codec, validating, props, memoryManager, conf);}
46ce5bf80bf8cbf7a784181579e7ed2640f52333e487f530f4f16e13d1895b79
getWriteSupport
public WriteSupport<T> getWriteSupport(Configuration configuration)
{    if (writeSupport != null)        return writeSupport;    Class<?> writeSupportClass = getWriteSupportClass(configuration);    try {        return (WriteSupport<T>) checkNotNull(writeSupportClass, "writeSupportClass").newInstance();    } catch (InstantiationException e) {        throw new BadConfigurationException("could not instantiate write support class: " + writeSupportClass, e);    } catch (IllegalAccessException e) {        throw new BadConfigurationException("could not instantiate write support class: " + writeSupportClass, e);    }}
77ab841ad031e596b23c11a2272c70097646883015abd28e78559b1da3dde4a6
getOutputCommitter
public OutputCommitter getOutputCommitter(TaskAttemptContext context) throws IOException
{    if (committer == null) {        Path output = getOutputPath(context);        committer = new ParquetOutputCommitter(output, context);    }    return committer;}
2916701188b2d3eda3607119e765ba56ef89fd33e895ce200ac90b42d56862b0
getMemoryManager
public static synchronized MemoryManager getMemoryManager()
{    return memoryManager;}
a7610ab926221b04648ab24d0255cf7328947aeda4ec1ed9672b257692866aaf
read
public T read() throws IOException
{    try {        if (reader != null && reader.nextKeyValue()) {            return reader.getCurrentValue();        } else {            initReader();            return reader == null ? null : read();        }    } catch (InterruptedException e) {        throw new IOException(e);    }}
81ba9df88b2fae8d350af70cf825bcb3c97f5dda9de28ccd33808f5da2efe22b
initReader
private void initReader() throws IOException
{    if (reader != null) {        reader.close();        reader = null;    }    if (filesIterator.hasNext()) {        InputFile file = filesIterator.next();        ParquetFileReader fileReader = ParquetFileReader.open(file, options);        reader = new InternalParquetRecordReader<>(readSupport, options.getRecordFilter());        reader.initialize(fileReader, options);    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    if (reader != null) {        reader.close();    }}
1bb754e065c75e0d8347535d31d53c0f1e3a08b1311dd667d9f43d3373a78844
read
public static Builder<T> read(InputFile file) throws IOException
{    return new Builder<>(file);}
7feb5d25a528f6c635a9811c81ab32096999b451c19dc67f96550b6b6d37fb1c
builder
public static Builder<T> builder(ReadSupport<T> readSupport, Path path)
{    return new Builder<>(readSupport, path);}
8c27984731e7aafa29fa0e94d76f30f54135fb6339635cd387e0b4bf22471921
withConf
public Builder<T> withConf(Configuration conf)
{    this.conf = checkNotNull(conf, "conf");            this.optionsBuilder = HadoopReadOptions.builder(conf);    if (filter != null) {        optionsBuilder.withRecordFilter(filter);    }    return this;}
212146f38d84bb5aabda5af0be103d25fd491483cabd6574497b6268bbeae4bb
withFilter
public Builder<T> withFilter(Filter filter)
{    this.filter = filter;    optionsBuilder.withRecordFilter(filter);    return this;}
7d98513e7780956418e7d7f02d30060728ac250804b8e6e84ab02e27c2ce24f9
useSignedStringMinMax
public Builder<T> useSignedStringMinMax(boolean useSignedStringMinMax)
{    optionsBuilder.useSignedStringMinMax(useSignedStringMinMax);    return this;}
c356d1426e384862e1c1c7e3c861261c6dd2994a96fb88c4ab8bf17ef87dc148
useSignedStringMinMax
public Builder<T> useSignedStringMinMax()
{    optionsBuilder.useSignedStringMinMax();    return this;}
ad908db9fcbedce04912208218b3cd609aa4e60ec8d8d01e815c8b3da7a82a07
useStatsFilter
public Builder<T> useStatsFilter(boolean useStatsFilter)
{    optionsBuilder.useStatsFilter(useStatsFilter);    return this;}
06d494972083d196eac28f39aa2b727eb6d95a674a94d5e34f6df29f259bf7f1
useStatsFilter
public Builder<T> useStatsFilter()
{    optionsBuilder.useStatsFilter();    return this;}
0b8049eabeecd1b6991ee7d5db65160e730239e0df5ecf305d6aff3416456c4e
useDictionaryFilter
public Builder<T> useDictionaryFilter(boolean useDictionaryFilter)
{    optionsBuilder.useDictionaryFilter(useDictionaryFilter);    return this;}
e724fd79ae63f89dc9b815c4e72eb965c36df74798853e0627452d0f34a4f60b
useDictionaryFilter
public Builder<T> useDictionaryFilter()
{    optionsBuilder.useDictionaryFilter();    return this;}
bd1f85a4d5180fbdb5cc836c62fd6a697e471bccc768673d9ac8b156cc22952d
useRecordFilter
public Builder<T> useRecordFilter(boolean useRecordFilter)
{    optionsBuilder.useRecordFilter(useRecordFilter);    return this;}
9fab8a8b459cf0bd46fd8bb110f949cb9457dd789571f7eb3dfff18bd8fb188e
useRecordFilter
public Builder<T> useRecordFilter()
{    optionsBuilder.useRecordFilter();    return this;}
614fd8ef28bae82b102b01afac964f9d78435b1816ec6d73ee5519dc4136482a
useColumnIndexFilter
public Builder<T> useColumnIndexFilter(boolean useColumnIndexFilter)
{    optionsBuilder.useColumnIndexFilter(useColumnIndexFilter);    return this;}
92be04a911a03145899f5deed2553049a16117da58c7c36ad901f4f607fa4301
useColumnIndexFilter
public Builder<T> useColumnIndexFilter()
{    optionsBuilder.useColumnIndexFilter();    return this;}
4b4145e83c9183a93b9430a79001193872a281fd73df4325b34b1f230becacd3
usePageChecksumVerification
public Builder<T> usePageChecksumVerification(boolean usePageChecksumVerification)
{    optionsBuilder.usePageChecksumVerification(usePageChecksumVerification);    return this;}
2ff1f69715424814a0eebb9d47a6d333f9a1feeaf3918624362ebf45ce4505d1
usePageChecksumVerification
public Builder<T> usePageChecksumVerification()
{    optionsBuilder.usePageChecksumVerification();    return this;}
7b3a542ae116a7fc28b0b4b4d436a9612af185062817b8a1bf99b8227629e5af
withFileRange
public Builder<T> withFileRange(long start, long end)
{    optionsBuilder.withRange(start, end);    return this;}
d2fa39ae970c424afd46e5e10be99055161308f74c00ef3102a7fd03f6bc240f
withCodecFactory
public Builder<T> withCodecFactory(CompressionCodecFactory codecFactory)
{    optionsBuilder.withCodecFactory(codecFactory);    return this;}
0d270b39e9b73f321a7d47755c311c9bcd2b09d2ed1c40ac26b16ce9c7411ab6
set
public Builder<T> set(String key, String value)
{    optionsBuilder.set(key, value);    return this;}
9cbda847a70608bb3a280b55cf8a9d897c12e8e6de61562b2ac51ca7e62d94ed
getReadSupport
protected ReadSupport<T> getReadSupport()
{        Preconditions.checkArgument(readSupport != null, "[BUG] Classes that extend Builder should override getReadSupport()");    return readSupport;}
5ba3fa8b872885bd028793dbf81abbd4aa4e9d621155577b0d40696579de46ba
build
public ParquetReader<T> build() throws IOException
{    ParquetReadOptions options = optionsBuilder.build();    if (path != null) {        FileSystem fs = path.getFileSystem(conf);        FileStatus stat = fs.getFileStatus(path);        if (stat.isFile()) {            return new ParquetReader<>(Collections.singletonList((InputFile) HadoopInputFile.fromStatus(stat, conf)), options, getReadSupport());        } else {            List<InputFile> files = new ArrayList<>();            for (FileStatus fileStatus : fs.listStatus(path, HiddenFileFilter.INSTANCE)) {                files.add(HadoopInputFile.fromStatus(fileStatus, conf));            }            return new ParquetReader<T>(files, options, getReadSupport());        }    } else {        return new ParquetReader<>(Collections.singletonList(file), options, getReadSupport());    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    internalReader.close();}
7e0e144ea811abeab166edde4c792d45321073d3a332fd9987c63fcb5f717a6f
getCurrentKey
public Void getCurrentKey() throws IOException, InterruptedException
{    return null;}
fadc2e51326de80aa9d9674da1ab3da153254ccefc7017086c4713afadd816c7
getCurrentValue
public T getCurrentValue() throws IOException, InterruptedException
{    return internalReader.getCurrentValue();}
e6a44445685ea2b0efb4761e11c07379596d7cd89a49901e52b03fbe83285805
getProgress
public float getProgress() throws IOException, InterruptedException
{    return internalReader.getProgress();}
31d67f0ebcfeca7fe0122ca3a067df23149a597f7062117725ccce7015a54168
initialize
public void initialize(InputSplit inputSplit, TaskAttemptContext context) throws IOException, InterruptedException
{    if (ContextUtil.hasCounterMethod(context)) {        BenchmarkCounter.initCounterFromContext(context);    } else {        LOG.error(String.format("Can not initialize counter because the class '%s' does not have a '.getCounterMethod'", context.getClass().getCanonicalName()));    }    initializeInternalReader(toParquetSplit(inputSplit), ContextUtil.getConfiguration(context));}
291def6b1ff8c3efafe045012ba4ea0a1c4d890b1afe98e76b5c87662c64925d
initialize
public void initialize(InputSplit inputSplit, Configuration configuration, Reporter reporter) throws IOException, InterruptedException
{    BenchmarkCounter.initCounterFromReporter(reporter, configuration);    initializeInternalReader(toParquetSplit(inputSplit), configuration);}
26a54b1790a36b3035ae76564f47e850ba3ab8e29eb5c92b65006a3dda6987ab
initializeInternalReader
private void initializeInternalReader(ParquetInputSplit split, Configuration configuration) throws IOException
{    Path path = split.getPath();    long[] rowGroupOffsets = split.getRowGroupOffsets();        ParquetReadOptions.Builder optionsBuilder = HadoopReadOptions.builder(configuration);    if (rowGroupOffsets != null) {        optionsBuilder.withOffsets(rowGroupOffsets);    } else {        optionsBuilder.withRange(split.getStart(), split.getEnd());    }        ParquetFileReader reader = ParquetFileReader.open(HadoopInputFile.fromPath(path, configuration), optionsBuilder.build());    if (rowGroupOffsets != null) {                List<BlockMetaData> blocks = reader.getFooter().getBlocks();        if (blocks.size() != rowGroupOffsets.length) {            throw new IllegalStateException("All of the offsets in the split should be found in the file." + " expected: " + Arrays.toString(rowGroupOffsets) + " found: " + blocks);        }    }    if (!reader.getRowGroups().isEmpty()) {        checkDeltaByteArrayProblem(reader.getFooter().getFileMetaData(), configuration, reader.getRowGroups().get(0));    }    internalReader.initialize(reader, configuration);}
74c8c798d8f40bbfe1ffb923fbcd6c7a9bc31466d6bafdd56ebda6326fb738cb
checkDeltaByteArrayProblem
private void checkDeltaByteArrayProblem(FileMetaData meta, Configuration conf, BlockMetaData block)
{        if (conf.getBoolean(ParquetInputFormat.SPLIT_FILES, true)) {                Set<Encoding> encodings = new HashSet<Encoding>();        for (ColumnChunkMetaData column : block.getColumns()) {            encodings.addAll(column.getEncodings());        }        for (Encoding encoding : encodings) {            if (CorruptDeltaByteArrays.requiresSequentialReads(meta.getCreatedBy(), encoding)) {                throw new ParquetDecodingException("Cannot read data due to " + "PARQUET-246: to read safely, set " + SPLIT_FILES + " to false");            }        }    }}
ea3a7eba5daf72a5cdc712e0c558af9956bcee4d2482e651bd64ac1a2c167657
nextKeyValue
public boolean nextKeyValue() throws IOException, InterruptedException
{    return internalReader.nextKeyValue();}
e92f8f6faac6907102862fa5090a03c3188195428dbaef8158971ada45e0e78b
toParquetSplit
private ParquetInputSplit toParquetSplit(InputSplit split) throws IOException
{    if (split instanceof ParquetInputSplit) {        return (ParquetInputSplit) split;    } else if (split instanceof FileSplit) {        return ParquetInputSplit.from((FileSplit) split);    } else if (split instanceof org.apache.hadoop.mapred.FileSplit) {        return ParquetInputSplit.from((org.apache.hadoop.mapred.FileSplit) split);    } else {        throw new IllegalArgumentException("Invalid split (not a FileSplit or ParquetInputSplit): " + split);    }}
b8b34e2eb30c67c8979d27754340818dab91e35c6af795f1b114e238b3f0efd0
close
public void close(TaskAttemptContext context) throws IOException, InterruptedException
{    try {        internalWriter.close();        } finally {        if (codecFactory != null) {            codecFactory.release();        }        if (memoryManager != null) {            memoryManager.removeWriter(internalWriter);        }    }}
263eb303fe2efba08304376afb759e2f4707f27c67cc38959aa34c8978765145
write
public void write(Void key, T value) throws IOException, InterruptedException
{    internalWriter.write(value);}
34ed69f1bf11fd29f333b35eaf660ef560250350be1188890e847efb8c1598a0
write
public void write(T object) throws IOException
{    try {        writer.write(object);    } catch (InterruptedException e) {        throw new IOException(e);    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    try {        writer.close();    } catch (InterruptedException e) {        throw new IOException(e);    } finally {                codecFactory.release();    }}
4c5838da1bbb7f272d023072572656ee488689766654d779a053dc4e7986bc90
getFooter
public ParquetMetadata getFooter()
{    return writer.getFooter();}
8b21c504b91af76d414f19385993fbd468bb14899ecb91a63f6f9d1f3eb58f84
getDataSize
public long getDataSize()
{    return writer.getDataSize();}
03c0503649266d8d8e4e9b89560a4808d0036edb4d840a8a6d07010afff4ee5f
withConf
public SELF withConf(Configuration conf)
{    this.conf = conf;    return self();}
a85a783da82e2dc1069ecfd2d101a22d814729d51de7c1864709394f68de668b
withWriteMode
public SELF withWriteMode(ParquetFileWriter.Mode mode)
{    this.mode = mode;    return self();}
d56fb43730f6dce9b028249c48ccda3f4d7d1cce5a6a47bc3e8e7e1035b080f8
withCompressionCodec
public SELF withCompressionCodec(CompressionCodecName codecName)
{    this.codecName = codecName;    return self();}
939fbe8780792707d878f2392f8e743ac2b4ddb915e7e53aa120f13d1560c135
withRowGroupSize
public SELF withRowGroupSize(int rowGroupSize)
{    this.rowGroupSize = rowGroupSize;    return self();}
157123f28b3255e61a9705ddc83e91b6bca4d4db44b8b77f3e05e5285d1415ee
withPageSize
public SELF withPageSize(int pageSize)
{    encodingPropsBuilder.withPageSize(pageSize);    return self();}
e45f41503a00abced001411efc2621951723f2d55d4fb0ef0080c9110d30eed2
withPageRowCountLimit
public SELF withPageRowCountLimit(int rowCount)
{    encodingPropsBuilder.withPageRowCountLimit(rowCount);    return self();}
2b2ebae64a1130d54743f0bbcc17136489d278a2a65cceea672fd77aab94648a
withDictionaryPageSize
public SELF withDictionaryPageSize(int dictionaryPageSize)
{    encodingPropsBuilder.withDictionaryPageSize(dictionaryPageSize);    return self();}
3f027a0935ed34e5b6a9d9a4d18644bc8da7d568e861b5e4021a725383211551
withMaxPaddingSize
public SELF withMaxPaddingSize(int maxPaddingSize)
{    this.maxPaddingSize = maxPaddingSize;    return self();}
188e02d12527a6464e002d656e030090cb033397bf5cbd003477b2eb59887359
enableDictionaryEncoding
public SELF enableDictionaryEncoding()
{    encodingPropsBuilder.withDictionaryEncoding(true);    return self();}
b11866127eb8f72f862e322d087165cb161580855d87550fba32637953e16299
withDictionaryEncoding
public SELF withDictionaryEncoding(boolean enableDictionary)
{    encodingPropsBuilder.withDictionaryEncoding(enableDictionary);    return self();}
7baed30202cc38c00a89757de44a3d2161dff678a431f263b635b9853057723c
enableValidation
public SELF enableValidation()
{    this.enableValidation = true;    return self();}
bee0ddbd8f7d86f11d6c49810992c2732e7bbcf91abfbe008eae13b1a7cb55a3
withValidation
public SELF withValidation(boolean enableValidation)
{    this.enableValidation = enableValidation;    return self();}
ee8efbef08aba34f181e9001aebcee4c0a2c62fc6b8b529addd3df6227221b6a
withWriterVersion
public SELF withWriterVersion(WriterVersion version)
{    encodingPropsBuilder.withWriterVersion(version);    return self();}
7e49abf7a881c512241f3cf2fa3678aac257d5ca685a4a0b2d5e45e9385af95f
enablePageWriteChecksum
public SELF enablePageWriteChecksum()
{    encodingPropsBuilder.withPageWriteChecksumEnabled(true);    return self();}
02c98943aa86991545dd8cf0a6d027cd842a41d61858cdf3bbbbf58514ee69ba
withPageWriteChecksumEnabled
public SELF withPageWriteChecksumEnabled(boolean enablePageWriteChecksum)
{    encodingPropsBuilder.withPageWriteChecksumEnabled(enablePageWriteChecksum);    return self();}
8d941adf93e2eb64f54534f58ce863d72ccf1798d7f23cfedd7bfc10568daf2f
config
public SELF config(String property, String value)
{    conf.set(property, value);    return self();}
d8168cac2cec4ec85ebacafe4a63b7fbc4932bbec6799f8e8c47fda0010bc271
build
public ParquetWriter<T> build() throws IOException
{    if (file != null) {        return new ParquetWriter<>(file, mode, getWriteSupport(conf), codecName, rowGroupSize, enableValidation, conf, maxPaddingSize, encodingPropsBuilder.build());    } else {        return new ParquetWriter<>(HadoopOutputFile.fromPath(path, conf), mode, getWriteSupport(conf), codecName, rowGroupSize, enableValidation, conf, maxPaddingSize, encodingPropsBuilder.build());    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    if (args.length != 1) {        System.err.println("usage PrintFooter <path>");        return;    }    Path path = new Path(new URI(args[0]));    final Configuration configuration = new Configuration();    final FileSystem fs = path.getFileSystem(configuration);    FileStatus fileStatus = fs.getFileStatus(path);    Path summary = new Path(fileStatus.getPath(), PARQUET_METADATA_FILE);    if (fileStatus.isDir() && fs.exists(summary)) {        System.out.println("reading summary file");        FileStatus summaryStatus = fs.getFileStatus(summary);        List<Footer> readSummaryFile = ParquetFileReader.readSummaryFile(configuration, summaryStatus);        for (Footer footer : readSummaryFile) {            add(footer.getParquetMetadata());        }    } else {        List<FileStatus> statuses;        if (fileStatus.isDir()) {            System.out.println("listing files in " + fileStatus.getPath());            statuses = Arrays.asList(fs.listStatus(fileStatus.getPath(), HiddenFileFilter.INSTANCE));        } else {            statuses = new ArrayList<FileStatus>();            statuses.add(fileStatus);        }        System.out.println("opening " + statuses.size() + " files");        int i = 0;        ExecutorService threadPool = Executors.newFixedThreadPool(5);        try {            long t0 = System.currentTimeMillis();            Deque<Future<ParquetMetadata>> footers = new LinkedBlockingDeque<Future<ParquetMetadata>>();            for (final FileStatus currentFile : statuses) {                footers.add(threadPool.submit(() -> {                    try {                        return ParquetFileReader.readFooter(configuration, currentFile, NO_FILTER);                    } catch (Exception e) {                        throw new ParquetDecodingException("could not read footer", e);                    }                }));            }            int previousPercent = 0;            int n = 60;            System.out.print("0% [");            for (int j = 0; j < n; j++) {                System.out.print(" ");            }            System.out.print("] 100%");            for (int j = 0; j < n + 6; j++) {                System.out.print('\b');            }            while (!footers.isEmpty()) {                Future<ParquetMetadata> futureFooter = footers.removeFirst();                if (!futureFooter.isDone()) {                    footers.addLast(futureFooter);                    continue;                }                ParquetMetadata footer = futureFooter.get();                int currentPercent = (++i * n / statuses.size());                while (currentPercent > previousPercent) {                    System.out.print("*");                    previousPercent++;                }                add(footer);            }            System.out.println("");            long t1 = System.currentTimeMillis();            System.out.println("read all footers in " + (t1 - t0) + " ms");        } finally {            threadPool.shutdownNow();        }    }    Set<Entry<ColumnDescriptor, ColStats>> entries = stats.entrySet();    long total = 0;    long totalUnc = 0;    for (Entry<ColumnDescriptor, ColStats> entry : entries) {        ColStats colStats = entry.getValue();        total += colStats.allStats.total;        totalUnc += colStats.uncStats.total;    }    for (Entry<ColumnDescriptor, ColStats> entry : entries) {        ColStats colStats = entry.getValue();        System.out.println(entry.getKey() + " " + percent(colStats.allStats.total, total) + "% of all space " + colStats);    }    System.out.println("number of blocks: " + blockCount);    System.out.println("total data size: " + humanReadable(total) + " (raw " + humanReadable(totalUnc) + ")");    System.out.println("total record: " + humanReadable(recordCount));    System.out.println("average block size: " + humanReadable(total / blockCount) + " (raw " + humanReadable(totalUnc / blockCount) + ")");    System.out.println("average record count: " + humanReadable(recordCount / blockCount));}
a486648ee8a4ab2839480b3dd0317d563f07300d1f947e99a0b330bcbf201e8d
add
private static void add(ParquetMetadata footer)
{    for (BlockMetaData blockMetaData : footer.getBlocks()) {        ++blockCount;        MessageType schema = footer.getFileMetaData().getSchema();        recordCount += blockMetaData.getRowCount();        List<ColumnChunkMetaData> columns = blockMetaData.getColumns();        for (ColumnChunkMetaData columnMetaData : columns) {            ColumnDescriptor desc = schema.getColumnDescription(columnMetaData.getPath().toArray());            add(desc, columnMetaData.getValueCount(), columnMetaData.getTotalSize(), columnMetaData.getTotalUncompressedSize(), columnMetaData.getEncodings(), columnMetaData.getStatistics());        }    }}
9db6484dfab837d6b98103e8486c5c9a48a37c9fdec61a70e234a30f81aa375e
printTotalString
private static void printTotalString(String message, long total, long totalUnc)
{    System.out.println("total " + message + ": " + humanReadable(total) + " (raw " + humanReadable(totalUnc) + " saved " + percentComp(totalUnc, total) + "%)");}
2fc29239e79c695bb17425fea87cc24428670c4e96113e8120f9dc5d8c7c93bb
percentComp
private static float percentComp(long raw, long compressed)
{    return percent(raw - compressed, raw);}
6e2d8a28147c5f7d3e7c4e81ddf8f1bec4232a15305727b9f438d153abf07ab2
percent
private static float percent(long numerator, long denominator)
{    return ((float) ((numerator) * 1000 / denominator)) / 10;}
535a1b6b9a2c7b19d01269f5610a0da4876a48374cced50c189ffda04c00f299
humanReadable
private static String humanReadable(long size)
{    if (size < 1000) {        return String.valueOf(size);    }    long currentSize = size;    long previousSize = size * 1000;    int count = 0;    String[] unit = { "", "K", "M", "G", "T", "P" };    while (currentSize >= 1000) {        previousSize = currentSize;        currentSize = currentSize / 1000;        ++count;    }    return ((float) previousSize / 1000) + unit[count];}
936c828498a598b538ff82fec0a57c314b8871dfc92a2abbb910aba3e1b5b2e4
add
public void add(long length)
{    min = Math.min(length, min);    max = Math.max(length, max);    total += length;}
e4a3076a0e0e36cf02e8cf72e15883f78c0dc39833c41ed8b63668e404a2ec7e
toString
public String toString(int blocks)
{    return "min: " + humanReadable(min) + " max: " + humanReadable(max) + " average: " + humanReadable(total / blocks) + " total: " + humanReadable(total);}
9a8397b97c540e46af27c30fe8c4b561471961459f2643e54204ce1f4901d1f3
add
public void add(long valueCount, long size, long uncSize, Collection<Encoding> encodings, Statistics colValuesStats)
{    ++blocks;    valueCountStats.add(valueCount);    allStats.add(size);    uncStats.add(uncSize);    this.encodings.addAll(encodings);    this.colValuesStats = colValuesStats;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    long raw = uncStats.total;    long compressed = allStats.total;    return encodings + " " + allStats.toString(blocks) + " (raw data: " + humanReadable(raw) + (raw == 0 ? "" : " saving " + (raw - compressed) * 100 / raw + "%") + ")\n" + "  values: " + valueCountStats.toString(blocks) + "\n" + "  uncompressed: " + uncStats.toString(blocks) + "\n" + "  column values statistics: " + colValuesStats.toString();}
e7c1f81920405b995cca007f335a499b55cfbfb55ea7b63fb7c532d9dbd74974
add
private static void add(ColumnDescriptor desc, long valueCount, long size, long uncSize, Collection<Encoding> encodings, Statistics colValuesStats)
{    ColStats colStats = stats.get(desc);    if (colStats == null) {        colStats = new ColStats();        stats.put(desc, colStats);    }    colStats.add(valueCount, size, uncSize, encodings, colValuesStats);}
fd3de9acab145efbaf03725db5016d73ff34198b98d2158b8590987610bde498
incErrors
public void incErrors(RecordMaterializationException cause) throws ParquetDecodingException
{    numErrors++;    LOG.warn(String.format("Error while reading an input record (%s out of %s): ", numErrors, totalNumRecords), cause);    if (numErrors > 0 && errorThreshold <= 0) {                throw new ParquetDecodingException("Error while decoding records", cause);    }    double errRate = numErrors / (double) totalNumRecords;    if (errRate > errorThreshold) {        String message = String.format("Decoding error rate of at least %s/%s crosses configured threshold of %s", numErrors, totalNumRecords, errorThreshold);        LOG.error(message);        throw new ParquetDecodingException(message, cause);    }}
dc00b5560a86bc50554163447aef2266280ff91391ca9696962ce0376ea5602c
getFloat
private static float getFloat(ParquetReadOptions options, String key, float defaultValue)
{    String value = options.getProperty(key);    if (value != null) {        return Float.valueOf(value);    } else {        return defaultValue;    }}
e20aeb6bce02b497f314aba465fa0746c6533919648287c032423c7473da2adb
getClassFromConfig
public static Class<?> getClassFromConfig(Configuration configuration, String configName, Class<?> assignableFrom)
{    final String className = configuration.get(configName);    if (className == null) {        return null;    }    try {        final Class<?> foundClass = configuration.getClassByName(className);        if (!assignableFrom.isAssignableFrom(foundClass)) {            throw new BadConfigurationException("class " + className + " set in job conf at " + configName + " is not a subclass of " + assignableFrom.getCanonicalName());        }        return foundClass;    } catch (ClassNotFoundException e) {        throw new BadConfigurationException("could not instantiate class " + className + " set in job conf at " + configName, e);    }}
b0ce48927b9e5faab5fded272bbafe508bf2064ce27f46a92bced19807cd4098
newJobContext
public static JobContext newJobContext(Configuration conf, JobID jobId)
{    try {        return (JobContext) JOB_CONTEXT_CONSTRUCTOR.newInstance(conf, jobId);    } catch (InstantiationException e) {        throw new IllegalArgumentException("Can't instantiate JobContext", e);    } catch (IllegalAccessException e) {        throw new IllegalArgumentException("Can't instantiate JobContext", e);    } catch (InvocationTargetException e) {        throw new IllegalArgumentException("Can't instantiate JobContext", e);    }}
37a944aee7eed27d569ca5a896287cb4b3d8e39bdb1f24a9c7a281987684458b
newTaskAttemptContext
public static TaskAttemptContext newTaskAttemptContext(Configuration conf, TaskAttemptID taskAttemptId)
{    try {        return (TaskAttemptContext) TASK_CONTEXT_CONSTRUCTOR.newInstance(conf, taskAttemptId);    } catch (InstantiationException e) {        throw new IllegalArgumentException("Can't instantiate TaskAttemptContext", e);    } catch (IllegalAccessException e) {        throw new IllegalArgumentException("Can't instantiate TaskAttemptContext", e);    } catch (InvocationTargetException e) {        throw new IllegalArgumentException("Can't instantiate TaskAttemptContext", e);    }}
ce37a8a71bd6aa32502ab3d6f3ffc38d5ab4febad6ea3509ae884c20a6b8918b
newGenericCounter
public static Counter newGenericCounter(String name, String displayName, long value)
{    try {        return (Counter) GENERIC_COUNTER_CONSTRUCTOR.newInstance(name, displayName, value);    } catch (InstantiationException e) {        throw new IllegalArgumentException("Can't instantiate Counter", e);    } catch (IllegalAccessException e) {        throw new IllegalArgumentException("Can't instantiate Counter", e);    } catch (InvocationTargetException e) {        throw new IllegalArgumentException("Can't instantiate Counter", e);    }}
60bf8269013d128548eb3c2bf268dd8b27c9f9a7af56d3c6ebc7b084016c8f59
getConfiguration
public static Configuration getConfiguration(JobContext context)
{    try {        return (Configuration) GET_CONFIGURATION_METHOD.invoke(context);    } catch (IllegalAccessException e) {        throw new IllegalArgumentException("Can't invoke method", e);    } catch (InvocationTargetException e) {        throw new IllegalArgumentException("Can't invoke method", e);    }}
9c74f87993f4a9f0c6fb356c1846dbe360e296e1052fc58fda2cc26a487c0ac2
getCounter
public static Counter getCounter(TaskAttemptContext context, String groupName, String counterName)
{    Method counterMethod = findCounterMethod(context);    return (Counter) invoke(counterMethod, context, groupName, counterName);}
469ef1b5bfc2ee70f241640ed64dff932c869a840d63f5bd7d43223a2ae8dbd3
hasCounterMethod
public static boolean hasCounterMethod(TaskAttemptContext context)
{    return findCounterMethod(context) != null;}
345b42385fc263a525562ba5c9b899bb031605a7e64fbff817a954c234459d97
findCounterMethod
private static Method findCounterMethod(TaskAttemptContext context)
{    if (context != null) {        if (COUNTER_METHODS_BY_CLASS.containsKey(context.getClass())) {            return COUNTER_METHODS_BY_CLASS.get(context.getClass());        }        try {            Method method = context.getClass().getMethod("getCounter", String.class, String.class);            if (method.getReturnType().isAssignableFrom(Counter.class)) {                COUNTER_METHODS_BY_CLASS.put(context.getClass(), method);                return method;            }        } catch (NoSuchMethodException e) {            return null;        }    }    return null;}
1fe993767eb50d44e72d0abc605e2825d7cccbbf0c46cf56823db5ee8e652365
invoke
private static Object invoke(Method method, Object obj, Object... args)
{    try {        return method.invoke(obj, args);    } catch (IllegalAccessException e) {        throw new IllegalArgumentException("Can't invoke method " + method.getName(), e);    } catch (InvocationTargetException e) {        throw new IllegalArgumentException("Can't invoke method " + method.getName(), e);    }}
ab86320e2d6659c8e4d787e76f5153aad7ed3deb0795de30636b064add600c7e
incrementCounter
public static void incrementCounter(Counter counter, long increment)
{    invoke(INCREMENT_COUNTER_METHOD, counter, increment);}
fa4216b0a79da11d20b16cfdefbe2157b5c23caf85b39c5ece77ba7797a2c7cd
initCounterFromContext
public static void initCounterFromContext(TaskAttemptContext context)
{    counterLoader = new MapReduceCounterLoader(context);    loadCounters();}
f6ff19a44611109557a8381207d6ae28dde11ce7e9aa09e4fe1d05eae5064630
initCounterFromReporter
public static void initCounterFromReporter(Reporter reporter, Configuration configuration)
{    counterLoader = new MapRedCounterLoader(reporter, configuration);    loadCounters();}
eb7a33d68ca9463cd1816bdc19b6762963b22cb2b7f8780b1823d0f81318236a
loadCounters
private static void loadCounters()
{    bytesReadCounter = getCounterWhenFlagIsSet(COUNTER_GROUP_NAME, BYTES_READ_COUNTER_NAME, ENABLE_BYTES_READ_COUNTER);    totalBytesCounter = getCounterWhenFlagIsSet(COUNTER_GROUP_NAME, BYTES_TOTAL_COUNTER_NAME, ENABLE_BYTES_TOTAL_COUNTER);    timeCounter = getCounterWhenFlagIsSet(COUNTER_GROUP_NAME, TIME_READ_COUNTER_NAME, ENABLE_TIME_READ_COUNTER);}
74c40a86c5d7a63cc9ff3570c3d8ae6b0118039b2ead0910068d7d3a5c8aa234
getCounterWhenFlagIsSet
private static ICounter getCounterWhenFlagIsSet(String groupName, String counterName, String counterFlag)
{    return counterLoader.getCounterByNameAndFlag(groupName, counterName, counterFlag);}
db572e9b2564ac5a4eea664b012119bbaf706d5bd9948537aebaa7ad9e46a2bb
incrementTotalBytes
public static void incrementTotalBytes(long val)
{    totalBytesCounter.increment(val);}
aafbb467c8878c9de2931af6efba64028a67abd059e5efe61700c1df6a02e509
getTotalBytes
public static long getTotalBytes()
{    return totalBytesCounter.getCount();}
7a4bf79108d193764d4cdf81f79a59e5600aa46d6046bfa950052e97321e2f0e
incrementBytesRead
public static void incrementBytesRead(long val)
{    bytesReadCounter.increment(val);}
5ddca891badf7b7132ff8680ba972032af155d9daebb50d8630c39523fb3b511
getBytesRead
public static long getBytesRead()
{    return bytesReadCounter.getCount();}
91d624131ab2fd25e9906cd7e355accd98b348d4ee9275537552bb924512ec6b
incrementTime
public static void incrementTime(long val)
{    timeCounter.increment(val);}
fd5450d299b06d49bafba25b7801a822c3850d8d9e748acbc8609aad7336c3be
getTime
public static long getTime()
{    return timeCounter.getCount();}
b5084c9ea0f2698444281179d8b05f71da9da42714fa104f5501698bd3b2bc1a
increment
public void increment(long val)
{}
4bf990342727536109cd77a29149345256f33b328f596b96f11cb4f2c9906922
getCount
public long getCount()
{    return 0;}
b5084c9ea0f2698444281179d8b05f71da9da42714fa104f5501698bd3b2bc1a
increment
public void increment(long val)
{    adaptee.increment(val);}
4bf990342727536109cd77a29149345256f33b328f596b96f11cb4f2c9906922
getCount
public long getCount()
{    return adaptee.getCounter();}
a02afcef16901b2219b04a1a6e55f6e00efa73219017f64bfa82db45263e70a9
getCounterByNameAndFlag
public ICounter getCounterByNameAndFlag(String groupName, String counterName, String counterFlag)
{    if (conf.getBoolean(counterFlag, true)) {        Counters.Counter counter = reporter.getCounter(groupName, counterName);        if (counter != null) {            return new MapRedCounterAdapter(reporter.getCounter(groupName, counterName));        }    }    return new BenchmarkCounter.NullCounter();}
b5084c9ea0f2698444281179d8b05f71da9da42714fa104f5501698bd3b2bc1a
increment
public void increment(long val)
{    ContextUtil.incrementCounter(adaptee, val);}
4bf990342727536109cd77a29149345256f33b328f596b96f11cb4f2c9906922
getCount
public long getCount()
{        return adaptee.getValue();}
a02afcef16901b2219b04a1a6e55f6e00efa73219017f64bfa82db45263e70a9
getCounterByNameAndFlag
public ICounter getCounterByNameAndFlag(String groupName, String counterName, String counterFlag)
{    if (ContextUtil.getConfiguration(context).getBoolean(counterFlag, true)) {        return new MapReduceCounterAdapter(ContextUtil.getCounter(context, groupName, counterName));    } else {        return new BenchmarkCounter.NullCounter();    }}
5800a0f531c192e683ef74c0c5de6015daf6261d1f8e5c0ce6d8e043b01926c7
getPos
public long getPos() throws IOException
{    return stream.getPos();}
87184ca04fb22c88c7d27f227ff6911e4e0b7e0b641209e4480afef7731a0d49
seek
public void seek(long newPos) throws IOException
{    stream.seek(newPos);}
6393462ea979ef8532c28bb0edd9b6422e4a0d9ddd3547cc24589fe4a0d75955
readFully
public void readFully(byte[] bytes) throws IOException
{    stream.readFully(bytes, 0, bytes.length);}
715c9d664f161880709dd932f02fb9e3cc1877d4eb29878dabf25a019b03537c
readFully
public void readFully(byte[] bytes, int start, int len) throws IOException
{    stream.readFully(bytes);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    stream.close();}
5800a0f531c192e683ef74c0c5de6015daf6261d1f8e5c0ce6d8e043b01926c7
getPos
public long getPos() throws IOException
{    return stream.getPos();}
87184ca04fb22c88c7d27f227ff6911e4e0b7e0b641209e4480afef7731a0d49
seek
public void seek(long newPos) throws IOException
{    stream.seek(newPos);}
715c9d664f161880709dd932f02fb9e3cc1877d4eb29878dabf25a019b03537c
readFully
public void readFully(byte[] bytes, int start, int len) throws IOException
{    stream.readFully(bytes);}
f6cf5cebd4378bf21b6f722e4d539ff0fb218c112d1691f1f0bbd0eda4e34078
read
public int read(ByteBuffer buf) throws IOException
{    return stream.read(buf);}
830af4e995db0d11aa62bd34816b2f9fc08bdeadd196b209feb6be1c304ce330
readFully
public void readFully(ByteBuffer buf) throws IOException
{    readFully(reader, buf);}
f6cf5cebd4378bf21b6f722e4d539ff0fb218c112d1691f1f0bbd0eda4e34078
read
public int read(ByteBuffer buf) throws IOException
{    return stream.read(buf);}
023abf764a9aec4fe7813367c043759caa0f077703aa48ce711a60fdac3976b5
readFully
public static void readFully(Reader reader, ByteBuffer buf) throws IOException
{        while (buf.hasRemaining()) {        int readCount = reader.read(buf);        if (readCount == -1) {                        throw new EOFException("Reached the end of stream. Still have: " + buf.remaining() + " bytes left");        }    }}
3d57dfce42869619cd4ea535dff90db9ea714680c590a2738157774b425f45cf
newFactory
public static CompressionCodecFactory newFactory(int sizeHint)
{    return new CodecFactory(new Configuration(), sizeHint);}
bb4f3fa7690cfa8d7210853ef62bb79a6d4825056f59108a6ad1cf5727da3e24
newFactory
public static CompressionCodecFactory newFactory(Configuration conf, int sizeHint)
{    return new CodecFactory(conf, sizeHint);}
1f92853eac9523b7d4eb3d4c6cefe87356ce7f9314b239f00980080d91b505e1
newDirectFactory
public static CompressionCodecFactory newDirectFactory(Configuration conf, ByteBufferAllocator allocator, int sizeHint)
{    return CodecFactory.createDirectCodecFactory(conf, allocator, sizeHint);}
7454c4c9f7a5921ff9f2e77075c80be3a4bf5b4676554545b0f22fbefaa638e1
fromPath
public static HadoopInputFile fromPath(Path path, Configuration conf) throws IOException
{    FileSystem fs = path.getFileSystem(conf);    return new HadoopInputFile(fs, fs.getFileStatus(path), conf);}
9f08eb9334e30dce9720c2e79eaecd5f265d72a990232a787866b7805dc53e8a
fromStatus
public static HadoopInputFile fromStatus(FileStatus stat, Configuration conf) throws IOException
{    FileSystem fs = stat.getPath().getFileSystem(conf);    return new HadoopInputFile(fs, stat, conf);}
4ab32fd1c0fc8b7e0975a577f547cc7a82d509b4844a391bcce9e94e9bd47854
getConfiguration
public Configuration getConfiguration()
{    return conf;}
06efe89013376b2c8901b8c2f25c9d64c09dc3ad3ebdfda3159e0662716680cc
getLength
public long getLength()
{    return stat.getLen();}
b7448de0d4b6dca34d27a306e3da000bbfc0fd4c88e6ba00d2acac5a93ab0b2b
newStream
public SeekableInputStream newStream() throws IOException
{    return HadoopStreams.wrap(fs.open(stat.getPath()));}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return stat.getPath().toString();}
a6c6c87caf7d9e28148b927981ec2bd654ab1892ca417d76f458615749d9083e
getBlockFileSystems
public static Set<String> getBlockFileSystems()
{    return BLOCK_FS_SCHEMES;}
0539291d7a0f542613a6ec204b8901e766854902f61c30e00fc915d3f64c221b
supportsBlockSize
private static boolean supportsBlockSize(FileSystem fs)
{    return BLOCK_FS_SCHEMES.contains(fs.getUri().getScheme());}
3b7e9246091df8cb36c1276700f3d234c45c8a4d5cd33266bf6f5ee3e2bad1d9
fromPath
public static HadoopOutputFile fromPath(Path path, Configuration conf) throws IOException
{    FileSystem fs = path.getFileSystem(conf);    return new HadoopOutputFile(fs, fs.makeQualified(path), conf);}
4ab32fd1c0fc8b7e0975a577f547cc7a82d509b4844a391bcce9e94e9bd47854
getConfiguration
public Configuration getConfiguration()
{    return conf;}
7c8841f64c2a7b7b7e43c5621867414cbae427530b315264a2343984382ef974
create
public PositionOutputStream create(long blockSizeHint) throws IOException
{    return HadoopStreams.wrap(fs.create(path, false, /* do not overwrite */    DFS_BUFFER_SIZE_DEFAULT, fs.getDefaultReplication(path), Math.max(fs.getDefaultBlockSize(path), blockSizeHint)));}
f9968af1ba1aff17d3c01eb4a48ed29994cc60e3cbcd79ba698a109030c6a800
createOrOverwrite
public PositionOutputStream createOrOverwrite(long blockSizeHint) throws IOException
{    return HadoopStreams.wrap(fs.create(path, true, /* overwrite if exists */    DFS_BUFFER_SIZE_DEFAULT, fs.getDefaultReplication(path), Math.max(fs.getDefaultBlockSize(path), blockSizeHint)));}
25e7ad709bee723c87fc07351f3d9f072baaff241104b7d2663fe4d7edbe7ff5
supportsBlockSize
public boolean supportsBlockSize()
{    return supportsBlockSize(fs);}
fdebbca15f0d2b8bcb26e93cdc926ee87ad94cd1c7f686e4202d0942b709884f
defaultBlockSize
public long defaultBlockSize()
{    return fs.getDefaultBlockSize(path);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return path.toString();}
5800a0f531c192e683ef74c0c5de6015daf6261d1f8e5c0ce6d8e043b01926c7
getPos
public long getPos() throws IOException
{    return wrapped.getPos();}
28b71ced43af8c83f8eb799b762b9363eea3393c08bf12a29b90de2304757b0c
write
public void write(int b) throws IOException
{    wrapped.write(b);}
9dc05e09d787e6afa8b5d2cf4cacaf1f65f348fcc597daca5502cd46ac6e898a
write
public void write(byte[] b) throws IOException
{    wrapped.write(b);}
6426ce3b66c4d2446558d8b5b93fe8a019e350f1ed5c2b61732f1efce14f0e67
write
public void write(byte[] b, int off, int len) throws IOException
{    wrapped.write(b, off, len);}
ebf6369c0a538e889b3acec39360edad82f3c2ebed8c3c27b004adbf0ab4b95a
sync
public void sync() throws IOException
{    wrapped.hsync();}
c3e67ec76f1b008887f1caba645a2614900cde6e477acca1bc3ecc36bf357fcf
flush
public void flush() throws IOException
{    wrapped.flush();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    wrapped.close();}
60a3c03849d2549433e2b6ba34585c5d55a6ee7f693635ffaf295c0b1f94da0b
wrap
public static SeekableInputStream wrap(FSDataInputStream stream)
{    Preconditions.checkNotNull(stream, "Cannot wrap a null input stream");    if (byteBufferReadableClass != null && h2SeekableConstructor != null && byteBufferReadableClass.isInstance(stream.getWrappedStream())) {        try {            return h2SeekableConstructor.newInstance(stream);        } catch (InstantiationException e) {            LOG.warn("Could not instantiate H2SeekableInputStream, falling back to byte array reads", e);            return new H1SeekableInputStream(stream);        } catch (IllegalAccessException e) {            LOG.warn("Could not instantiate H2SeekableInputStream, falling back to byte array reads", e);            return new H1SeekableInputStream(stream);        } catch (InvocationTargetException e) {            throw new ParquetDecodingException("Could not instantiate H2SeekableInputStream", e.getTargetException());        }    } else {        return new H1SeekableInputStream(stream);    }}
d8b52d76ff666e7cfdb9906d25d6a9a567e57f606682ddc8d2b3ae7821a45ce4
getReadableClass
private static Class<?> getReadableClass()
{    try {        return Class.forName("org.apache.hadoop.fs.ByteBufferReadable");    } catch (ClassNotFoundException e) {        return null;    } catch (NoClassDefFoundError e) {        return null;    }}
ef8edfda8685eb9f27fb3290134c8001e03ab43b6ed14de9c3265e2bad974747
getH2SeekableClass
private static Class<SeekableInputStream> getH2SeekableClass()
{    try {        return (Class<SeekableInputStream>) Class.forName("org.apache.parquet.hadoop.util.H2SeekableInputStream");    } catch (ClassNotFoundException e) {        return null;    } catch (NoClassDefFoundError e) {        return null;    }}
609405fa1a6d9df1030dee26b491ede22c6ae14dd425986305f5839d5194f0d7
getH2SeekableConstructor
private static Constructor<SeekableInputStream> getH2SeekableConstructor()
{    Class<SeekableInputStream> h2SeekableClass = getH2SeekableClass();    if (h2SeekableClass != null) {        try {            return h2SeekableClass.getConstructor(FSDataInputStream.class);        } catch (NoSuchMethodException e) {            return null;        }    }    return null;}
ee815221b684f91611f9bb01fe717174a56a7e38e51811acfa64d6423f90dd8c
wrap
public static PositionOutputStream wrap(FSDataOutputStream stream)
{    Preconditions.checkNotNull(stream, "Cannot wrap a null output stream");    return new HadoopPositionOutputStream(stream);}
c94aa625c3916f72280a7b0e313c3a037e072f791e4847551ba71c8a420468c3
accept
public boolean accept(Path p)
{    final char c = p.getName().charAt(0);    return c != '.' && c != '_';}
33afa01519bb8eb1c29d88ffc52bbf916c662cd97c1eaa6d41c04b6af03a3376
writeObjectToConfAsBase64
public static void writeObjectToConfAsBase64(String key, Object obj, Configuration conf) throws IOException
{    try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {        try (GZIPOutputStream gos = new GZIPOutputStream(baos);            ObjectOutputStream oos = new ObjectOutputStream(gos)) {            oos.writeObject(obj);        }        conf.set(key, new String(Base64.getMimeEncoder().encode(baos.toByteArray()), StandardCharsets.UTF_8));    }}
cf187356005083f9fcb08a14a6274d53a5c7eaef81db5712f92a5ec8bfbec010
readObjectFromConfAsBase64
public static T readObjectFromConfAsBase64(String key, Configuration conf) throws IOException
{    String b64 = conf.get(key);    if (b64 == null) {        return null;    }    byte[] bytes = Base64.getMimeDecoder().decode(b64.getBytes(StandardCharsets.UTF_8));    try (ByteArrayInputStream bais = new ByteArrayInputStream(bytes);        GZIPInputStream gis = new GZIPInputStream(bais);        ObjectInputStream ois = new ObjectInputStream(gis)) {        return (T) ois.readObject();    } catch (ClassNotFoundException e) {        throw new IOException("Could not read object from config with key " + key, e);    } catch (ClassCastException e) {        throw new IOException("Could not cast object read from config with key " + key, e);    }}
c3268e2ece5b28525b48ee82627100677896dcf64c94807d3507037db2d110ef
getProperty
public String getProperty(String property)
{    String value = super.getProperty(property);    if (value != null) {        return value;    }    return conf.get(property);}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
58c70d4f65f9b70838592968b1e513188d01ef21319ad10994bcf36bb92e4e81
builder
public static Builder builder(Configuration conf)
{    return new Builder(conf);}
7eb6301b2631bbc8cdb05515e1d16408b522e866298c0536ead8c8a8a1ee8bc7
build
public ParquetReadOptions build()
{    return new HadoopReadOptions(useSignedStringMinMax, useStatsFilter, useDictionaryFilter, useRecordFilter, useColumnIndexFilter, usePageChecksumVerification, recordFilter, metadataFilter, codecFactory, allocator, maxAllocationSize, properties, conf);}
35116e965c976c739af649afcfbd43b9becbeb0070de2600f48a5259dddd953b
getOffset
public long getOffset()
{    return offset;}
1e7a9ccf869d4ffcaafdb7996c8f1f820d6f2af9eb816b65ead1db5bcfc3f744
getLength
public int getLength()
{    return length;}
508c8349bb71cc311447945f7e4c6d86c8d5d5fc50e57358d595500a8fe9f9e2
useSignedStringMinMax
public boolean useSignedStringMinMax()
{    return useSignedStringMinMax;}
b7ca9f4549ccc0318846cc89c92e4e78c9363b7c09c3e26013dc4eda79ffb577
useStatsFilter
public boolean useStatsFilter()
{    return useStatsFilter;}
f3ccb5be69263b7ebe22299d47a357bff38c51f7b3da488f03fd7d8ea8136a25
useDictionaryFilter
public boolean useDictionaryFilter()
{    return useDictionaryFilter;}
4d027b3ab0fc85a7ad29cd4d33900fa9d89c36cab248d9f83caa6a7e8216506c
useRecordFilter
public boolean useRecordFilter()
{    return useRecordFilter;}
cca3dce000e2f927fe9b7b9f279b5d83a38fc7cc3f222c1b12a04db680c962a1
useColumnIndexFilter
public boolean useColumnIndexFilter()
{    return useColumnIndexFilter;}
e53d9f06d49dcf8dc57fad0544ce94fa1b84245a1f91641fcc446627d4ad9a49
usePageChecksumVerification
public boolean usePageChecksumVerification()
{    return usePageChecksumVerification;}
fcea392398f881ef8cefefae21af8c4358c05b2f263804a80f6fba414f9316f2
getRecordFilter
public FilterCompat.Filter getRecordFilter()
{    return recordFilter;}
12f83ac0524c5ed25fe217b4895d2f86b5c2a422d5b8168a904d6e027cdee73e
getMetadataFilter
public ParquetMetadataConverter.MetadataFilter getMetadataFilter()
{    return metadataFilter;}
985b1186383265f87502f760f67cf4d6737d53d7cd13b8877b5787ba331b6692
getCodecFactory
public CompressionCodecFactory getCodecFactory()
{    return codecFactory;}
8da478be30239be43934a3f5a312089be6187deb04bc104c2e3a45f410bfd206
getAllocator
public ByteBufferAllocator getAllocator()
{    return allocator;}
cead1db00ddbdda2a79fcb969a892a737c16d477dfdf89b833d85edfac54f642
getMaxAllocationSize
public int getMaxAllocationSize()
{    return maxAllocationSize;}
2bab38b1652c8c23f61bd43b13fa09c8438a08af6948e5ae6af26f026cbe5b9e
getPropertyNames
public Set<String> getPropertyNames()
{    return properties.keySet();}
c3268e2ece5b28525b48ee82627100677896dcf64c94807d3507037db2d110ef
getProperty
public String getProperty(String property)
{    return properties.get(property);}
e071fafda942248155ce4a235f3867cdc1a4afb3c35569d7adefd621137f5080
isEnabled
public boolean isEnabled(String property, boolean defaultValue)
{    if (properties.containsKey(property)) {        return Boolean.valueOf(properties.get(property));    } else {        return defaultValue;    }}
cf558fab344ef794057daaaf3d4721487c20c3f85d09e31f5c8f20f006d4a450
builder
public static Builder builder()
{    return new Builder();}
050e905a3ab0f2ffc8829ee3be349762de44c557757f13acffc80c9edb04cf5b
useSignedStringMinMax
public Builder useSignedStringMinMax(boolean useSignedStringMinMax)
{    this.useSignedStringMinMax = useSignedStringMinMax;    return this;}
1915bfd4aa33c6f873f9e9d97b50b3fdb178ddf75a3f748484f4af8729f2fce9
useSignedStringMinMax
public Builder useSignedStringMinMax()
{    this.useSignedStringMinMax = true;    return this;}
07c4d75dc957a8103b1e16dc90fa10f90380713e704d64845499a75c3e4aad7d
useStatsFilter
public Builder useStatsFilter(boolean useStatsFilter)
{    this.useStatsFilter = useStatsFilter;    return this;}
5356c50e40357684f06c66cf5e8f52f054cdb9b0662c46e3c60f4938b5d625d4
useStatsFilter
public Builder useStatsFilter()
{    this.useStatsFilter = true;    return this;}
f32e9f49428abecb0ebb21d363fac08e0734411ddc2498669432466a649394e9
useDictionaryFilter
public Builder useDictionaryFilter(boolean useDictionaryFilter)
{    this.useDictionaryFilter = useDictionaryFilter;    return this;}
27aab7add79d29ecbb3cea40d11ac0b7b0847467a623b8613e5e96bb13abfee1
useDictionaryFilter
public Builder useDictionaryFilter()
{    this.useDictionaryFilter = true;    return this;}
66316e30f9a7f4c23486bdc657528265fdb0aeb0a3b66302d8aacd10406b0638
useRecordFilter
public Builder useRecordFilter(boolean useRecordFilter)
{    this.useRecordFilter = useRecordFilter;    return this;}
99984cdcda4a87480597f27ca7f5986ebf467fa44ca695652b1865c20b7e8ec5
useRecordFilter
public Builder useRecordFilter()
{    this.useRecordFilter = true;    return this;}
27fa312506aac824a936cd749fc08ad48520cc7b0fb4a9e62a56747f52e9e11e
useColumnIndexFilter
public Builder useColumnIndexFilter(boolean useColumnIndexFilter)
{    this.useColumnIndexFilter = useColumnIndexFilter;    return this;}
b3dc029daf2af5637b9f25773d3cea9ff962bdee4d17c484e9ce8a742d8aabfd
useColumnIndexFilter
public Builder useColumnIndexFilter()
{    return useColumnIndexFilter(true);}
a0568d797179a0a5d3c74fa03a97677551eb475617f99ec0a59839a8e56e8dec
usePageChecksumVerification
public Builder usePageChecksumVerification(boolean usePageChecksumVerification)
{    this.usePageChecksumVerification = usePageChecksumVerification;    return this;}
68ca4baa5c6505d8fdb5879cfcd0c49ac9d067fa263ac0a5b7937d5407981bf2
usePageChecksumVerification
public Builder usePageChecksumVerification()
{    return usePageChecksumVerification(true);}
b0f65cdffe6d177c396577974282dff97d52f9fc45fa97b4858dfa63cc151e3d
withRecordFilter
public Builder withRecordFilter(FilterCompat.Filter rowGroupFilter)
{    this.recordFilter = rowGroupFilter;    return this;}
93bd61d23a67c393cf8a0710464a867cf94fc6f762e945fb1bcd966f8abb2a84
withRange
public Builder withRange(long start, long end)
{    this.metadataFilter = ParquetMetadataConverter.range(start, end);    return this;}
126b2e067ad8371f4012bfcd1e0e3a22f43c08d67445aa85bcadc8fb043cd08a
withOffsets
public Builder withOffsets(long... rowGroupOffsets)
{    this.metadataFilter = ParquetMetadataConverter.offsets(rowGroupOffsets);    return this;}
96ec8d52c5de5219375606bd160bef0154e584656affa2ed9e3b577f0111f213
withMetadataFilter
public Builder withMetadataFilter(ParquetMetadataConverter.MetadataFilter metadataFilter)
{    this.metadataFilter = metadataFilter;    return this;}
89cdd49a44837470304d8c7a305c328876db2aa521a4b21d6305428a393efe0c
withCodecFactory
public Builder withCodecFactory(CompressionCodecFactory codecFactory)
{    this.codecFactory = codecFactory;    return this;}
8e62c0fd64b4a0c5a706f4d7bc609ac6ba4b16704389c118f5dac9634aace7eb
withAllocator
public Builder withAllocator(ByteBufferAllocator allocator)
{    this.allocator = allocator;    return this;}
6e83a9211eabc9c0eeab66528c31dd541d0b9a207d99fab63fc401e25451b72e
withMaxAllocationInBytes
public Builder withMaxAllocationInBytes(int allocationSizeInBytes)
{    this.maxAllocationSize = allocationSizeInBytes;    return this;}
9dc555470ef5ebb05f276ad91af235208891ef6767e93ee0fa32f30a730d9b87
withPageChecksumVerification
public Builder withPageChecksumVerification(boolean val)
{    this.usePageChecksumVerification = val;    return this;}
54052c0881e9fa2c9a500cda0ed67f5c6ab697a10d7a3843ed10ef9650971715
set
public Builder set(String key, String value)
{    properties.put(key, value);    return this;}
4ad6a2674d43e9397d3c4ce05a571be016fd43a602b5a9ad8871e64a9ffc6e21
copy
public Builder copy(ParquetReadOptions options)
{    useSignedStringMinMax(options.useSignedStringMinMax);    useStatsFilter(options.useStatsFilter);    useDictionaryFilter(options.useDictionaryFilter);    useRecordFilter(options.useRecordFilter);    withRecordFilter(options.recordFilter);    withMetadataFilter(options.metadataFilter);    withCodecFactory(options.codecFactory);    withAllocator(options.allocator);    withPageChecksumVerification(options.usePageChecksumVerification);    for (Map.Entry<String, String> keyValue : options.properties.entrySet()) {        set(keyValue.getKey(), keyValue.getValue());    }    return this;}
7eb6301b2631bbc8cdb05515e1d16408b522e866298c0536ead8c8a8a1ee8bc7
build
public ParquetReadOptions build()
{    return new ParquetReadOptions(useSignedStringMinMax, useStatsFilter, useDictionaryFilter, useRecordFilter, useColumnIndexFilter, usePageChecksumVerification, recordFilter, metadataFilter, codecFactory, allocator, maxAllocationSize, properties);}
bdb5eadd235804c25a9b808e0d7a6f2536b5e261f7a277a353c5137f1a706e77
writeDirect
protected Path writeDirect(String type, DirectWriter writer) throws IOException
{    return writeDirect(MessageTypeParser.parseMessageType(type), writer);}
34e5215c2bb0d347f316d14a28852825c53a695a739e1edbe4d1b54af70f511b
writeDirect
protected Path writeDirect(String type, DirectWriter writer, Map<String, String> metadata) throws IOException
{    return writeDirect(MessageTypeParser.parseMessageType(type), writer, metadata);}
382b0ce80251ad674a0f9ed92023c749bed8c8b9bc26c0a6ebdf93e4f893f036
writeDirect
protected Path writeDirect(MessageType type, DirectWriter writer) throws IOException
{    return writeDirect(type, writer, new HashMap<String, String>());}
7ef0ffc4986ad1a02508afa35e879b461d4735b3fb62294e4d1faacdd588e9a6
writeDirect
protected Path writeDirect(MessageType type, DirectWriter writer, Map<String, String> metadata) throws IOException
{    File temp = tempDir.newFile(UUID.randomUUID().toString());    temp.deleteOnExit();    temp.delete();    Path path = new Path(temp.getPath());    ParquetWriter<Void> parquetWriter = new ParquetWriter<Void>(path, new DirectWriteSupport(type, writer, metadata));    parquetWriter.write(null);    parquetWriter.close();    return path;}
89835da140a91d5cb5181a85b8db073a92d794e99966f7422502dbb7d5467b7c
init
public WriteContext init(Configuration configuration)
{    return new WriteContext(type, metadata);}
da9aef78cf181856102b820ffa7d5248e8581747b3f0670a7b049c4649b962ef
prepareForWrite
public void prepareForWrite(RecordConsumer recordConsumer)
{    this.recordConsumer = recordConsumer;}
e5dbc693db06d6f361c85f9142dbe37c498905e00ab685fe5207250ea99c9e59
write
public void write(Void record)
{    writer.write(recordConsumer);}
104a064620f1ef60e1f712f4008dd05768d523b8dae353edb97fd4ba525d723e
getParameters
public static Collection<Object[]> getParameters()
{    List<PrimitiveTypeName> types = Arrays.asList(PrimitiveTypeName.BOOLEAN, PrimitiveTypeName.INT32, PrimitiveTypeName.INT64, PrimitiveTypeName.INT96, PrimitiveTypeName.FLOAT, PrimitiveTypeName.DOUBLE, PrimitiveTypeName.BINARY, PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY);    List<CompressionCodecName> codecs;    String codecList = System.getenv("TEST_CODECS");    if (codecList != null) {        codecs = new ArrayList<CompressionCodecName>();        for (String codec : codecList.split(",")) {            codecs.add(CompressionCodecName.valueOf(codec.toUpperCase(Locale.ENGLISH)));        }    } else {                codecs = Arrays.asList(CompressionCodecName.UNCOMPRESSED);    }    System.err.println("Testing codecs: " + codecs);    List<Object[]> parameters = new ArrayList<Object[]>();    for (PrimitiveTypeName type : types) {        for (CompressionCodecName codec : codecs) {            parameters.add(new Object[] { type, codec });        }    }    return parameters;}
24301d2bf3c1427628cfca3040301af054d159e1dca12c0facce7040935b8f68
initialize
public static void initialize() throws IOException
{    Random random = new Random(RANDOM_SEED);    intGenerator = new RandomValues.IntGenerator(random.nextLong());    longGenerator = new RandomValues.LongGenerator(random.nextLong());    int96Generator = new RandomValues.Int96Generator(random.nextLong());    floatGenerator = new RandomValues.FloatGenerator(random.nextLong());    doubleGenerator = new RandomValues.DoubleGenerator(random.nextLong());    binaryGenerator = new RandomValues.BinaryGenerator(random.nextLong());    fixedBinaryGenerator = new RandomValues.FixedGenerator(random.nextLong(), FIXED_LENGTH);}
c1bd7d88b8bf0535ed1a529ce8811e2edc57ced22292bf827eb61c4ba433bd0f
testFileEncodingsWithoutDictionary
public void testFileEncodingsWithoutDictionary() throws Exception
{    final boolean DISABLE_DICTIONARY = false;    List<?> randomValues;    randomValues = generateRandomValues(this.paramTypeName, RECORD_COUNT);    /* Run an encoding test per each writer version.     * This loop will make sure to test future writer versions added to WriterVersion enum.     */    for (WriterVersion writerVersion : WriterVersion.values()) {        System.out.println(String.format("Testing %s/%s/%s encodings using ROW_GROUP_SIZE=%d PAGE_SIZE=%d", writerVersion, this.paramTypeName, this.compression, TEST_ROW_GROUP_SIZE, TEST_PAGE_SIZE));        Path parquetFile = createTempFile();        writeValuesToFile(parquetFile, this.paramTypeName, randomValues, TEST_ROW_GROUP_SIZE, TEST_PAGE_SIZE, DISABLE_DICTIONARY, writerVersion);        PageGroupValidator.validatePages(parquetFile, randomValues);    }}
cdfac2aa0510f2e94dd6e0050be90d6ff6a4a73d69a42fb8615635382e03e732
testFileEncodingsWithDictionary
public void testFileEncodingsWithDictionary() throws Exception
{    final boolean ENABLE_DICTIONARY = true;    List<?> dictionaryValues = generateDictionaryValues(this.paramTypeName, RECORD_COUNT);    /* Run an encoding test per each writer version.     * This loop will make sure to test future writer versions added to WriterVersion enum.     */    for (WriterVersion writerVersion : WriterVersion.values()) {        System.out.println(String.format("Testing %s/%s/%s + DICTIONARY encodings using ROW_GROUP_SIZE=%d PAGE_SIZE=%d", writerVersion, this.paramTypeName, this.compression, TEST_ROW_GROUP_SIZE, TEST_PAGE_SIZE));        Path parquetFile = createTempFile();        writeValuesToFile(parquetFile, this.paramTypeName, dictionaryValues, TEST_ROW_GROUP_SIZE, TEST_PAGE_SIZE, ENABLE_DICTIONARY, writerVersion);        PageGroupValidator.validatePages(parquetFile, dictionaryValues);    }}
e54aaa347a19efdead496803ae7b4db64974951bf7f2e5503071434e0c7e73d0
createTempFile
private Path createTempFile() throws IOException
{    File tempFile = tempFolder.newFile();    tempFile.delete();    return new Path(tempFile.getAbsolutePath());}
f511c974f8fb481f8eb2bfb077132d0202a8ded96b85525e112602aaefaccbb3
writeValuesToFile
private void writeValuesToFile(Path file, PrimitiveTypeName type, List<?> values, int rowGroupSize, int pageSize, boolean enableDictionary, WriterVersion version) throws IOException
{    MessageType schema;    if (type == PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY) {        schema = Types.buildMessage().required(type).length(FIXED_LENGTH).named("field").named("test");    } else {        schema = Types.buildMessage().required(type).named("field").named("test");    }    SimpleGroupFactory message = new SimpleGroupFactory(schema);    GroupWriteSupport.setSchema(schema, configuration);    ParquetWriter<Group> writer = ExampleParquetWriter.builder(file).withCompressionCodec(compression).withRowGroupSize(rowGroupSize).withPageSize(pageSize).withDictionaryPageSize(TEST_DICT_PAGE_SIZE).withDictionaryEncoding(enableDictionary).withWriterVersion(version).withConf(configuration).build();    for (Object o : values) {        switch(type) {            case BOOLEAN:                writer.write(message.newGroup().append("field", (Boolean) o));                break;            case INT32:                writer.write(message.newGroup().append("field", (Integer) o));                break;            case INT64:                writer.write(message.newGroup().append("field", (Long) o));                break;            case FLOAT:                writer.write(message.newGroup().append("field", (Float) o));                break;            case DOUBLE:                writer.write(message.newGroup().append("field", (Double) o));                break;            case INT96:            case BINARY:            case FIXED_LEN_BYTE_ARRAY:                writer.write(message.newGroup().append("field", (Binary) o));                break;            default:                throw new IllegalArgumentException("Unknown type name: " + type);        }    }    writer.close();}
71df4d073bcb71b8ef172e82a8fd7b33909d3e91a797a7de30358ab23834aee6
generateRandomValues
private List<?> generateRandomValues(PrimitiveTypeName type, int count)
{    List<Object> values = new ArrayList<Object>();    for (int i = 0; i < count; i++) {        Object value;        switch(type) {            case BOOLEAN:                value = (intGenerator.nextValue() % 2 == 0) ? true : false;                break;            case INT32:                value = intGenerator.nextValue();                break;            case INT64:                value = longGenerator.nextValue();                break;            case FLOAT:                value = floatGenerator.nextValue();                break;            case DOUBLE:                value = doubleGenerator.nextValue();                break;            case INT96:                value = int96Generator.nextBinaryValue();                break;            case BINARY:                value = binaryGenerator.nextBinaryValue();                break;            case FIXED_LEN_BYTE_ARRAY:                value = fixedBinaryGenerator.nextBinaryValue();                break;            default:                throw new IllegalArgumentException("Unknown type name: " + type);        }        values.add(value);    }    return values;}
a407545a4ba587757807c4646daef27b00e82eb9c24bb54eb68e7caaa68d95f2
generateDictionaryValues
private List<?> generateDictionaryValues(PrimitiveTypeName type, int count)
{    final int DICT_VALUES_SIZE = 100;    final List<?> DICT_BINARY_VALUES = generateRandomValues(PrimitiveTypeName.BINARY, DICT_VALUES_SIZE);    final List<?> DICT_INT96_VALUES = generateRandomValues(PrimitiveTypeName.INT96, DICT_VALUES_SIZE);    final List<?> DICT_FIXED_LEN_VALUES = generateRandomValues(PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY, DICT_VALUES_SIZE);    List<Object> values = new ArrayList<Object>();    for (int i = 0; i < count; i++) {        int dictValue = i % DICT_VALUES_SIZE;        Object value;        switch(type) {            case BOOLEAN:                value = (i % 2 == 0) ? true : false;                break;            case INT32:                value = dictValue;                break;            case INT64:                value = (long) dictValue;                break;            case FLOAT:                value = (float) dictValue;                break;            case DOUBLE:                value = (double) dictValue;                break;            case INT96:                value = DICT_INT96_VALUES.get(dictValue);                break;            case BINARY:                value = DICT_BINARY_VALUES.get(dictValue);                break;            case FIXED_LEN_BYTE_ARRAY:                value = DICT_FIXED_LEN_VALUES.get(dictValue);                break;            default:                throw new IllegalArgumentException("Unknown type name: " + type);        }        values.add(value);    }    return values;}
ccf87c6961e7407fbc0fe533f504f08798aa4db163199b00370661f9b117c1dc
validatePages
public static void validatePages(Path file, List<?> expectedValues) throws IOException
{    List<PageReadStore> blockReaders = readBlocksFromFile(file);    MessageType fileSchema = readSchemaFromFile(file);    int rowGroupID = 0;    int rowsRead = 0;    for (PageReadStore pageReadStore : blockReaders) {        for (ColumnDescriptor columnsDesc : fileSchema.getColumns()) {            List<DataPage> pageGroup = getPageGroupForColumn(pageReadStore, columnsDesc);            DictionaryPage dictPage = reusableCopy(getDictionaryPageForColumn(pageReadStore, columnsDesc));            List<?> expectedRowGroupValues = expectedValues.subList(rowsRead, (int) (rowsRead + pageReadStore.getRowCount()));            validateFirstToLast(rowGroupID, dictPage, pageGroup, columnsDesc, expectedRowGroupValues);            validateLastToFirst(rowGroupID, dictPage, pageGroup, columnsDesc, expectedRowGroupValues);        }        rowsRead += pageReadStore.getRowCount();        rowGroupID++;    }}
071a9e3369a4a68607b66d572b558617f564a7565a1cf2d24970fc67c5d373ce
reusableCopy
private static DictionaryPage reusableCopy(DictionaryPage dict)
{    if (dict == null) {        return null;    }    try {        return new DictionaryPage(BytesInput.from(dict.getBytes().toByteArray()), dict.getDictionarySize(), dict.getEncoding());    } catch (IOException e) {        throw new ParquetDecodingException("Cannot read dictionary", e);    }}
934a356701b16e2b4cacfa5572cf6b29ab5065be5560406d46ea317e3b09e3de
reusableCopy
private static DataPage reusableCopy(DataPage page)
{    return page.accept(new DataPage.Visitor<DataPage>() {        @Override        public DataPage visit(DataPageV1 data) {            try {                return new DataPageV1(BytesInput.from(data.getBytes().toByteArray()), data.getValueCount(), data.getUncompressedSize(), data.getStatistics(), data.getRlEncoding(), data.getDlEncoding(), data.getValueEncoding());            } catch (IOException e) {                throw new ParquetDecodingException("Cannot read data", e);            }        }        @Override        public DataPage visit(DataPageV2 data) {            try {                return new DataPageV2(data.getRowCount(), data.getNullCount(), data.getValueCount(), BytesInput.from(data.getRepetitionLevels().toByteArray()), BytesInput.from(data.getDefinitionLevels().toByteArray()), data.getDataEncoding(), BytesInput.from(data.getData().toByteArray()), data.getUncompressedSize(), data.getStatistics(), data.isCompressed());            } catch (IOException e) {                throw new ParquetDecodingException("Cannot read data", e);            }        }    });}
c4d940cae91a3cfb05ef87075ae200b8371422bcb4ea465d1a96f3742b4022d8
visit
public DataPage visit(DataPageV1 data)
{    try {        return new DataPageV1(BytesInput.from(data.getBytes().toByteArray()), data.getValueCount(), data.getUncompressedSize(), data.getStatistics(), data.getRlEncoding(), data.getDlEncoding(), data.getValueEncoding());    } catch (IOException e) {        throw new ParquetDecodingException("Cannot read data", e);    }}
770bbaf30c72260f308904765c2e4942d726da91936a7c8a8e49c8d48446627f
visit
public DataPage visit(DataPageV2 data)
{    try {        return new DataPageV2(data.getRowCount(), data.getNullCount(), data.getValueCount(), BytesInput.from(data.getRepetitionLevels().toByteArray()), BytesInput.from(data.getDefinitionLevels().toByteArray()), data.getDataEncoding(), BytesInput.from(data.getData().toByteArray()), data.getUncompressedSize(), data.getStatistics(), data.isCompressed());    } catch (IOException e) {        throw new ParquetDecodingException("Cannot read data", e);    }}
9acd03149282edf219fea517a1c2028f3c1fd93f0aebaa0a4e3464aa19488f41
validateFirstToLast
private static void validateFirstToLast(int rowGroupID, DictionaryPage dictPage, List<DataPage> pageGroup, ColumnDescriptor desc, List<?> expectedValues)
{    int rowsRead = 0, pageID = 0;    for (DataPage page : pageGroup) {        List<?> expectedPageValues = expectedValues.subList(rowsRead, rowsRead + page.getValueCount());        PageValuesValidator.validateValuesForPage(rowGroupID, pageID, dictPage, page, desc, expectedPageValues);        rowsRead += page.getValueCount();        pageID++;    }}
34bb12cd9d211d117719d51e27a37d36aff5e9e929b61eda31ad655eb1616e6e
validateLastToFirst
private static void validateLastToFirst(int rowGroupID, DictionaryPage dictPage, List<DataPage> pageGroup, ColumnDescriptor desc, List<?> expectedValues)
{    int rowsLeft = expectedValues.size();    for (int pageID = pageGroup.size() - 1; pageID >= 0; pageID--) {        DataPage page = pageGroup.get(pageID);        int offset = rowsLeft - page.getValueCount();        List<?> expectedPageValues = expectedValues.subList(offset, offset + page.getValueCount());        PageValuesValidator.validateValuesForPage(rowGroupID, pageID, dictPage, page, desc, expectedPageValues);        rowsLeft -= page.getValueCount();    }}
140374839295aedf8d3374f5eb1af9ae255a4b7d18e03cb8b1b7145f6892385b
getDictionaryPageForColumn
private static DictionaryPage getDictionaryPageForColumn(PageReadStore pageReadStore, ColumnDescriptor columnDescriptor)
{    PageReader pageReader = pageReadStore.getPageReader(columnDescriptor);    return pageReader.readDictionaryPage();}
f38eb57c56eba0a3cefc9bfae91b0fbabc9ae47db3df5b0b7a0236dad082f3eb
getPageGroupForColumn
private static List<DataPage> getPageGroupForColumn(PageReadStore pageReadStore, ColumnDescriptor columnDescriptor)
{    PageReader pageReader = pageReadStore.getPageReader(columnDescriptor);    List<DataPage> pageGroup = new ArrayList<DataPage>();    DataPage page;    while ((page = pageReader.readPage()) != null) {        pageGroup.add(reusableCopy(page));    }    return pageGroup;}
09e96c4f3bea6b0e08e9d27d81f06d8da90b3037ff36824df470a0aa067768b8
readSchemaFromFile
private static MessageType readSchemaFromFile(Path file) throws IOException
{    ParquetMetadata metadata = ParquetFileReader.readFooter(configuration, file, ParquetMetadataConverter.NO_FILTER);    return metadata.getFileMetaData().getSchema();}
6e360e587c2da0e1ed5a76638c46e921011ec1270760908ef6dfc415ad8d034f
readBlocksFromFile
private static List<PageReadStore> readBlocksFromFile(Path file) throws IOException
{    List<PageReadStore> rowGroups = new ArrayList<PageReadStore>();    ParquetMetadata metadata = ParquetFileReader.readFooter(configuration, file, ParquetMetadataConverter.NO_FILTER);    ParquetFileReader fileReader = new ParquetFileReader(configuration, metadata.getFileMetaData(), file, metadata.getBlocks(), metadata.getFileMetaData().getSchema().getColumns());    PageReadStore group;    while ((group = fileReader.readNextRowGroup()) != null) {        rowGroups.add(group);    }    return rowGroups;}
5e8213d4999f29cca671a8e92a45a3641a2f9df6d4329007a693d8c433b683d7
validateNextValue
public void validateNextValue(Object value)
{    assertEquals(String.format("Value from page is different than expected, ROW_GROUP_ID=%d PAGE_ID=%d VALUE_POS=%d", rowGroupID, pageID, currentPos), expectedValues.get(currentPos++), value);}
9d83898aa35760c59d231775fe175a5fb2274c2cf79e0ff37a6657a01cfa2488
validateValuesForPage
public static void validateValuesForPage(int rowGroupID, int pageID, DictionaryPage dictPage, DataPage page, ColumnDescriptor columnDesc, List<?> expectedValues)
{    TestStatistics.SingletonPageReader pageReader = new TestStatistics.SingletonPageReader(dictPage, page);    PrimitiveConverter converter = getConverter(rowGroupID, pageID, columnDesc.getType(), expectedValues);    ColumnReaderImpl column = new ColumnReaderImpl(columnDesc, pageReader, converter, null);    for (int i = 0; i < pageReader.getTotalValueCount(); i += 1) {        column.writeCurrentValueToConverter();        column.consume();    }}
72f3874771c7de14d6ff39d4874ae31c4ad3bf296eac193db1244a4ffe54ab2b
getConverter
private static PrimitiveConverter getConverter(final int rowGroupID, final int pageID, PrimitiveTypeName type, final List<?> expectedValues)
{    return type.convert(new PrimitiveType.PrimitiveTypeNameConverter<PrimitiveConverter, RuntimeException>() {        @Override        public PrimitiveConverter convertFLOAT(PrimitiveTypeName primitiveTypeName) throws RuntimeException {            final PageValuesValidator validator = new PageValuesValidator(rowGroupID, pageID, expectedValues);            return new PrimitiveConverter() {                @Override                public void addFloat(float value) {                    validator.validateNextValue(value);                }            };        }        @Override        public PrimitiveConverter convertDOUBLE(PrimitiveTypeName primitiveTypeName) throws RuntimeException {            final PageValuesValidator validator = new PageValuesValidator(rowGroupID, pageID, expectedValues);            return new PrimitiveConverter() {                @Override                public void addDouble(double value) {                    validator.validateNextValue(value);                }            };        }        @Override        public PrimitiveConverter convertINT32(PrimitiveTypeName primitiveTypeName) throws RuntimeException {            final PageValuesValidator validator = new PageValuesValidator(rowGroupID, pageID, expectedValues);            return new PrimitiveConverter() {                @Override                public void addInt(int value) {                    validator.validateNextValue(value);                }            };        }        @Override        public PrimitiveConverter convertINT64(PrimitiveTypeName primitiveTypeName) throws RuntimeException {            final PageValuesValidator validator = new PageValuesValidator(rowGroupID, pageID, expectedValues);            return new PrimitiveConverter() {                @Override                public void addLong(long value) {                    validator.validateNextValue(value);                }            };        }        @Override        public PrimitiveConverter convertINT96(PrimitiveTypeName primitiveTypeName) throws RuntimeException {            return convertBINARY(primitiveTypeName);        }        @Override        public PrimitiveConverter convertFIXED_LEN_BYTE_ARRAY(PrimitiveTypeName primitiveTypeName) throws RuntimeException {            return convertBINARY(primitiveTypeName);        }        @Override        public PrimitiveConverter convertBOOLEAN(PrimitiveTypeName primitiveTypeName) throws RuntimeException {            final PageValuesValidator validator = new PageValuesValidator(rowGroupID, pageID, expectedValues);            return new PrimitiveConverter() {                @Override                public void addBoolean(boolean value) {                    validator.validateNextValue(value);                }            };        }        @Override        public PrimitiveConverter convertBINARY(PrimitiveTypeName primitiveTypeName) throws RuntimeException {            final PageValuesValidator validator = new PageValuesValidator(rowGroupID, pageID, expectedValues);            return new PrimitiveConverter() {                @Override                public void addBinary(Binary value) {                    validator.validateNextValue(value);                }            };        }    });}
8fef486b60b7e47d085df9593101dd951dd4204b0024ba651258cc2bd951257b
convertFLOAT
public PrimitiveConverter convertFLOAT(PrimitiveTypeName primitiveTypeName) throws RuntimeException
{    final PageValuesValidator validator = new PageValuesValidator(rowGroupID, pageID, expectedValues);    return new PrimitiveConverter() {        @Override        public void addFloat(float value) {            validator.validateNextValue(value);        }    };}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    validator.validateNextValue(value);}
8dbe22ce3cd906056c1c484791bfd4d9a519d6750fd1eb373f7542f7f026bbc1
convertDOUBLE
public PrimitiveConverter convertDOUBLE(PrimitiveTypeName primitiveTypeName) throws RuntimeException
{    final PageValuesValidator validator = new PageValuesValidator(rowGroupID, pageID, expectedValues);    return new PrimitiveConverter() {        @Override        public void addDouble(double value) {            validator.validateNextValue(value);        }    };}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    validator.validateNextValue(value);}
9ad5b8c54954b7b74342655806b746126e96644bc037d53b10038fb03b13bc7b
convertINT32
public PrimitiveConverter convertINT32(PrimitiveTypeName primitiveTypeName) throws RuntimeException
{    final PageValuesValidator validator = new PageValuesValidator(rowGroupID, pageID, expectedValues);    return new PrimitiveConverter() {        @Override        public void addInt(int value) {            validator.validateNextValue(value);        }    };}
a2ac1f40a6e220ec515710128c8baf77a725ad0b9f1767a998f776f27fff6cf6
addInt
public void addInt(int value)
{    validator.validateNextValue(value);}
b8459210aa076caab20b0398afa82ccd1e0d8473d31e0e7c634b7c4b26e7a5f8
convertINT64
public PrimitiveConverter convertINT64(PrimitiveTypeName primitiveTypeName) throws RuntimeException
{    final PageValuesValidator validator = new PageValuesValidator(rowGroupID, pageID, expectedValues);    return new PrimitiveConverter() {        @Override        public void addLong(long value) {            validator.validateNextValue(value);        }    };}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    validator.validateNextValue(value);}
87e2d1651d316d7831815ce7fb592bf431477a93f914fd28c1af8db2823da54a
convertINT96
public PrimitiveConverter convertINT96(PrimitiveTypeName primitiveTypeName) throws RuntimeException
{    return convertBINARY(primitiveTypeName);}
b68e10cf29749033bc295e933a4703400a9edf7165f71c22e834917d4456c38f
convertFIXED_LEN_BYTE_ARRAY
public PrimitiveConverter convertFIXED_LEN_BYTE_ARRAY(PrimitiveTypeName primitiveTypeName) throws RuntimeException
{    return convertBINARY(primitiveTypeName);}
59802b1353499e9e1b8cc1889a28a83df4da1c0b6884e2aa02d15db26369590b
convertBOOLEAN
public PrimitiveConverter convertBOOLEAN(PrimitiveTypeName primitiveTypeName) throws RuntimeException
{    final PageValuesValidator validator = new PageValuesValidator(rowGroupID, pageID, expectedValues);    return new PrimitiveConverter() {        @Override        public void addBoolean(boolean value) {            validator.validateNextValue(value);        }    };}
23123f6657c241ab9b9f31f8efedc28a553ed91046d705121ce2667b065d6c17
addBoolean
public void addBoolean(boolean value)
{    validator.validateNextValue(value);}
d3d8ffa51631cecae3feae6023637ca2076fc5d484cdf77228f82139c32d3fbb
convertBINARY
public PrimitiveConverter convertBINARY(PrimitiveTypeName primitiveTypeName) throws RuntimeException
{    final PageValuesValidator validator = new PageValuesValidator(rowGroupID, pageID, expectedValues);    return new PrimitiveConverter() {        @Override        public void addBinary(Binary value) {            validator.validateNextValue(value);        }    };}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    validator.validateNextValue(value);}
021932e792feee9f862d8b45dad0af4cb5446ff1499484d2f307723adf558290
testApplyRowGroupFilters
public void testApplyRowGroupFilters()
{    List<BlockMetaData> blocks = new ArrayList<BlockMetaData>();    IntStatistics stats1 = new IntStatistics();    stats1.setMinMax(10, 100);    stats1.setNumNulls(4);    BlockMetaData b1 = makeBlockFromStats(stats1, 301);    blocks.add(b1);    IntStatistics stats2 = new IntStatistics();    stats2.setMinMax(8, 102);    stats2.setNumNulls(0);    BlockMetaData b2 = makeBlockFromStats(stats2, 302);    blocks.add(b2);    IntStatistics stats3 = new IntStatistics();    stats3.setMinMax(100, 102);    stats3.setNumNulls(12);    BlockMetaData b3 = makeBlockFromStats(stats3, 303);    blocks.add(b3);    IntStatistics stats4 = new IntStatistics();    stats4.setMinMax(0, 0);    stats4.setNumNulls(304);    BlockMetaData b4 = makeBlockFromStats(stats4, 304);    blocks.add(b4);    IntStatistics stats5 = new IntStatistics();    stats5.setMinMax(50, 50);    stats5.setNumNulls(7);    BlockMetaData b5 = makeBlockFromStats(stats5, 305);    blocks.add(b5);    IntStatistics stats6 = new IntStatistics();    stats6.setMinMax(0, 0);    stats6.setNumNulls(12);    BlockMetaData b6 = makeBlockFromStats(stats6, 306);    blocks.add(b6);    MessageType schema = MessageTypeParser.parseMessageType("message Document { optional int32 foo; }");    IntColumn foo = intColumn("foo");    List<BlockMetaData> filtered = RowGroupFilter.filterRowGroups(FilterCompat.get(eq(foo, 50)), blocks, schema);    assertEquals(Arrays.asList(b1, b2, b5), filtered);    filtered = RowGroupFilter.filterRowGroups(FilterCompat.get(notEq(foo, 50)), blocks, schema);    assertEquals(Arrays.asList(b1, b2, b3, b4, b5, b6), filtered);    filtered = RowGroupFilter.filterRowGroups(FilterCompat.get(eq(foo, null)), blocks, schema);    assertEquals(Arrays.asList(b1, b3, b4, b5, b6), filtered);    filtered = RowGroupFilter.filterRowGroups(FilterCompat.get(notEq(foo, null)), blocks, schema);    assertEquals(Arrays.asList(b1, b2, b3, b5, b6), filtered);    filtered = RowGroupFilter.filterRowGroups(FilterCompat.get(eq(foo, 0)), blocks, schema);    assertEquals(Arrays.asList(b6), filtered);}
c1c77c97e5b5caa723291f8d795fd86296830886c918f758b9c6a74014d0051d
toBinary
private static Binary toBinary(String decimalWithoutScale, int byteCount)
{    return toBinary(new BigInteger(decimalWithoutScale), byteCount);}
9f896aeb74ea64874dd017ddea4a41913d07f414a3f1a58e80e8a12b4fe3da3b
toBinary
private static Binary toBinary(BigInteger decimalWithoutScale, int byteCount)
{    byte[] src = decimalWithoutScale.toByteArray();    if (src.length > byteCount) {        throw new IllegalArgumentException("Too large decimal value for byte count " + byteCount);    }    byte[] dest = new byte[byteCount];    System.arraycopy(src, 0, dest, dest.length - src.length, src.length);    return Binary.fromConstantByteArray(dest);}
646684b50672ce3ab0f7d1ef4bb07c9575d90ddaf1b9c4ef4212f909fb8e4e1b
writeData
private static void writeData(SimpleGroupFactory f, ParquetWriter<Group> writer) throws IOException
{    for (int i = 0; i < nElements; i++) {        int index = i % ALPHABET.length();        Group group = f.newGroup().append("binary_field", ALPHABET.substring(index, index + 1)).append("single_value_field", "sharp").append("fixed_field", DECIMAL_VALUES[i % DECIMAL_VALUES.length]).append("int32_field", intValues[i % intValues.length]).append("int64_field", longValues[i % longValues.length]).append("double_field", toDouble(intValues[i % intValues.length])).append("float_field", toFloat(intValues[i % intValues.length])).append("plain_int32_field", i).append("fallback_binary_field", i < (nElements / 2) ? ALPHABET.substring(index, index + 1) : UUID.randomUUID().toString()).append("int96_field", INT96_VALUES[i % INT96_VALUES.length]);                if (index % 10 > 0) {            group.append("optional_single_value_field", "sharp");        }        writer.write(group);    }    writer.close();}
71f3a732d120b0bfedf080b20f6a14ae2cf687e13741a9135c76f6718079729e
prepareFile
public static void prepareFile() throws IOException
{    cleanup();    prepareFile(PARQUET_1_0, FILE_V1);    prepareFile(PARQUET_2_0, FILE_V2);}
a254947b4035af707f86e044b41c43ab0b6b081ac0731851e0d27c3730e6b139
prepareFile
private static void prepareFile(WriterVersion version, Path file) throws IOException
{    GroupWriteSupport.setSchema(schema, conf);    SimpleGroupFactory f = new SimpleGroupFactory(schema);    ParquetWriter<Group> writer = ExampleParquetWriter.builder(file).withWriterVersion(version).withCompressionCodec(GZIP).withRowGroupSize(1024 * 1024).withPageSize(1024).enableDictionaryEncoding().withDictionaryPageSize(2 * 1024).withConf(conf).build();    writeData(f, writer);}
5732be44c5f5bfb20b7f7362fbb9334758a27e00d27b72a1bb7efe725d6b3a84
cleanup
public static void cleanup() throws IOException
{    deleteFile(FILE_V1);    deleteFile(FILE_V2);}
cc1b919b6ce0e52a2a7d4fc55355929f79b6da15629b714887d635befa116170
deleteFile
private static void deleteFile(Path file) throws IOException
{    FileSystem fs = file.getFileSystem(conf);    if (fs.exists(file)) {        fs.delete(file, true);    }}
32a0af660caf746f4b0aef8329b29e45e4f3f41f03623313298125c7e1cdc6cc
params
public static Object[] params()
{    return new Object[] { PARQUET_1_0, PARQUET_2_0 };}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    reader = ParquetFileReader.open(conf, file);    ParquetMetadata meta = reader.getFooter();    ccmd = meta.getBlocks().get(0).getColumns();    dictionaries = reader.getDictionaryReader(meta.getBlocks().get(0));}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    reader.close();}
47210bc7e654cdcd234d1d5de0f1ca2943dc7c7b506570e6d09415d926fc2e52
testDictionaryEncodedColumns
public void testDictionaryEncodedColumns() throws Exception
{    switch(version) {        case PARQUET_1_0:            testDictionaryEncodedColumnsV1();            break;        case PARQUET_2_0:            testDictionaryEncodedColumnsV2();            break;    }}
c3669eecf47beec37a4c9ccb9695d2797ebdf589cbf3d02b6a8407bb85bedae3
testDictionaryEncodedColumnsV1
private void testDictionaryEncodedColumnsV1() throws Exception
{    Set<String> dictionaryEncodedColumns = new HashSet<String>(Arrays.asList("binary_field", "single_value_field", "optional_single_value_field", "int32_field", "int64_field", "double_field", "float_field", "int96_field"));    for (ColumnChunkMetaData column : ccmd) {        String name = column.getPath().toDotString();        if (dictionaryEncodedColumns.contains(name)) {            assertTrue("Column should be dictionary encoded: " + name, column.getEncodings().contains(Encoding.PLAIN_DICTIONARY));            assertFalse("Column should not have plain data pages" + name, column.getEncodings().contains(Encoding.PLAIN));        } else {            assertTrue("Column should have plain encoding: " + name, column.getEncodings().contains(Encoding.PLAIN));            if (name.startsWith("fallback")) {                assertTrue("Column should have some dictionary encoding: " + name, column.getEncodings().contains(Encoding.PLAIN_DICTIONARY));            } else {                assertFalse("Column should have no dictionary encoding: " + name, column.getEncodings().contains(Encoding.PLAIN_DICTIONARY));            }        }    }}
f3a1457d9dadd3f45adb8f9476aa1c5080f125449ee87c506f815f16c4bc4eda
testDictionaryEncodedColumnsV2
private void testDictionaryEncodedColumnsV2() throws Exception
{    Set<String> dictionaryEncodedColumns = new HashSet<String>(Arrays.asList("binary_field", "single_value_field", "optional_single_value_field", "fixed_field", "int32_field", "int64_field", "double_field", "float_field", "int96_field"));    for (ColumnChunkMetaData column : ccmd) {        EncodingStats encStats = column.getEncodingStats();        String name = column.getPath().toDotString();        if (dictionaryEncodedColumns.contains(name)) {            assertTrue("Column should have dictionary pages: " + name, encStats.hasDictionaryPages());            assertTrue("Column should have dictionary encoded pages: " + name, encStats.hasDictionaryEncodedPages());            assertFalse("Column should not have non-dictionary encoded pages: " + name, encStats.hasNonDictionaryEncodedPages());        } else {            assertTrue("Column should have non-dictionary encoded pages: " + name, encStats.hasNonDictionaryEncodedPages());            if (name.startsWith("fallback")) {                assertTrue("Column should have dictionary pages: " + name, encStats.hasDictionaryPages());                assertTrue("Column should have dictionary encoded pages: " + name, encStats.hasDictionaryEncodedPages());            } else {                assertFalse("Column should not have dictionary pages: " + name, encStats.hasDictionaryPages());                assertFalse("Column should not have dictionary encoded pages: " + name, encStats.hasDictionaryEncodedPages());            }        }    }}
d53e112ac3227425984922654c31d8e857e35832fb37dad68ab927577ab6570f
testEqBinary
public void testEqBinary() throws Exception
{    BinaryColumn b = binaryColumn("binary_field");    FilterPredicate pred = eq(b, Binary.fromString("c"));    assertFalse("Should not drop block for lower case letters", canDrop(pred, ccmd, dictionaries));    assertTrue("Should drop block for upper case letters", canDrop(eq(b, Binary.fromString("A")), ccmd, dictionaries));    assertFalse("Should not drop block for null", canDrop(eq(b, null), ccmd, dictionaries));}
02d0fbb0b096e882ab8cd91cbe6823e07cf92aa5291d6916f4149fc70e6fe912
testEqFixed
public void testEqFixed() throws Exception
{    BinaryColumn b = binaryColumn("fixed_field");        if (version == PARQUET_2_0) {        assertTrue("Should drop block for -2", canDrop(eq(b, toBinary("-2", 17)), ccmd, dictionaries));    }    assertFalse("Should not drop block for -1", canDrop(eq(b, toBinary("-1", 17)), ccmd, dictionaries));    assertFalse("Should not drop block for null", canDrop(eq(b, null), ccmd, dictionaries));}
81ed2b229b119d19bb9f4b25e8e1f25f72561390ab1077695fdbcf7e5e161f61
testEqInt96
public void testEqInt96() throws Exception
{    BinaryColumn b = binaryColumn("int96_field");        assertFalse("Should not drop block for -2", canDrop(eq(b, toBinary("-2", 12)), ccmd, dictionaries));    assertFalse("Should not drop block for -1", canDrop(eq(b, toBinary("-1", 12)), ccmd, dictionaries));    assertFalse("Should not drop block for null", canDrop(eq(b, null), ccmd, dictionaries));}
f1d2bc3d064e4e1a44631fd171dad7e200a900a35f3a976fa4940520cee5e6d9
testNotEqBinary
public void testNotEqBinary() throws Exception
{    BinaryColumn sharp = binaryColumn("single_value_field");    BinaryColumn sharpAndNull = binaryColumn("optional_single_value_field");    BinaryColumn b = binaryColumn("binary_field");    assertTrue("Should drop block with only the excluded value", canDrop(notEq(sharp, Binary.fromString("sharp")), ccmd, dictionaries));    assertFalse("Should not drop block with any other value", canDrop(notEq(sharp, Binary.fromString("applause")), ccmd, dictionaries));    assertFalse("Should not drop block with only the excluded value and null", canDrop(notEq(sharpAndNull, Binary.fromString("sharp")), ccmd, dictionaries));    assertFalse("Should not drop block with any other value", canDrop(notEq(sharpAndNull, Binary.fromString("applause")), ccmd, dictionaries));    assertFalse("Should not drop block with a known value", canDrop(notEq(b, Binary.fromString("x")), ccmd, dictionaries));    assertFalse("Should not drop block with a known value", canDrop(notEq(b, Binary.fromString("B")), ccmd, dictionaries));    assertFalse("Should not drop block for null", canDrop(notEq(b, null), ccmd, dictionaries));}
9f0ce9e345d947f0035234bc0579e62ca4dd7460a252e15b59cf7d585df928ec
testLtInt
public void testLtInt() throws Exception
{    IntColumn i32 = intColumn("int32_field");    int lowest = Integer.MAX_VALUE;    for (int value : intValues) {        lowest = Math.min(lowest, value);    }    assertTrue("Should drop: < lowest value", canDrop(lt(i32, lowest), ccmd, dictionaries));    assertFalse("Should not drop: < (lowest value + 1)", canDrop(lt(i32, lowest + 1), ccmd, dictionaries));    assertFalse("Should not drop: contains matching values", canDrop(lt(i32, Integer.MAX_VALUE), ccmd, dictionaries));}
07439777cd7f6a1f6e354564884f46f70abd5db15d6949ffdc7fa76f264952cf
testLtFixed
public void testLtFixed() throws Exception
{    BinaryColumn fixed = binaryColumn("fixed_field");        if (version == PARQUET_2_0) {        assertTrue("Should drop: < lowest value", canDrop(lt(fixed, DECIMAL_VALUES[0]), ccmd, dictionaries));    }    assertFalse("Should not drop: < 2nd lowest value", canDrop(lt(fixed, DECIMAL_VALUES[1]), ccmd, dictionaries));}
ae46729881ea07008b6fefa74aefc5bcfe13f9a5c2cfcfd79538b32000059815
testLtEqLong
public void testLtEqLong() throws Exception
{    LongColumn i64 = longColumn("int64_field");    long lowest = Long.MAX_VALUE;    for (long value : longValues) {        lowest = Math.min(lowest, value);    }    assertTrue("Should drop: <= lowest - 1", canDrop(ltEq(i64, lowest - 1), ccmd, dictionaries));    assertFalse("Should not drop: <= lowest", canDrop(ltEq(i64, lowest), ccmd, dictionaries));    assertFalse("Should not drop: contains matching values", canDrop(ltEq(i64, Long.MAX_VALUE), ccmd, dictionaries));}
a574e8e08ac90a36a25b706f3496b85878d06ca7a1518ee89aecd9c5add85c5d
testGtFloat
public void testGtFloat() throws Exception
{    FloatColumn f = floatColumn("float_field");    float highest = Float.MIN_VALUE;    for (int value : intValues) {        highest = Math.max(highest, toFloat(value));    }    assertTrue("Should drop: > highest value", canDrop(gt(f, highest), ccmd, dictionaries));    assertFalse("Should not drop: > (highest value - 1.0)", canDrop(gt(f, highest - 1.0f), ccmd, dictionaries));    assertFalse("Should not drop: contains matching values", canDrop(gt(f, Float.MIN_VALUE), ccmd, dictionaries));}
ad74935f2ee92af2ac458fe6c45837c00da4acc91f8815d0a769410b1d515fdf
testGtEqDouble
public void testGtEqDouble() throws Exception
{    DoubleColumn d = doubleColumn("double_field");    double highest = Double.MIN_VALUE;    for (int value : intValues) {        highest = Math.max(highest, toDouble(value));    }    assertTrue("Should drop: >= highest + 0.00000001", canDrop(gtEq(d, highest + 0.00000001), ccmd, dictionaries));    assertFalse("Should not drop: >= highest", canDrop(gtEq(d, highest), ccmd, dictionaries));    assertFalse("Should not drop: contains matching values", canDrop(gtEq(d, Double.MIN_VALUE), ccmd, dictionaries));}
1db8b96879b2f6b040ad2147b10ac82fba86d8ab5499d1a488b5afc24e5c8b28
testAnd
public void testAnd() throws Exception
{    BinaryColumn col = binaryColumn("binary_field");        FilterPredicate B = eq(col, Binary.fromString("B"));    FilterPredicate C = eq(col, Binary.fromString("C"));        FilterPredicate x = eq(col, Binary.fromString("x"));    FilterPredicate y = eq(col, Binary.fromString("y"));    assertTrue("Should drop when either predicate must be false", canDrop(and(B, y), ccmd, dictionaries));    assertTrue("Should drop when either predicate must be false", canDrop(and(x, C), ccmd, dictionaries));    assertTrue("Should drop when either predicate must be false", canDrop(and(B, C), ccmd, dictionaries));    assertFalse("Should not drop when either predicate could be true", canDrop(and(x, y), ccmd, dictionaries));}
e628d9e4706ff06aa550c84d4fe633a0051896a13f7c4e2cb30b022a7d2a3456
testOr
public void testOr() throws Exception
{    BinaryColumn col = binaryColumn("binary_field");        FilterPredicate B = eq(col, Binary.fromString("B"));    FilterPredicate C = eq(col, Binary.fromString("C"));        FilterPredicate x = eq(col, Binary.fromString("x"));    FilterPredicate y = eq(col, Binary.fromString("y"));    assertFalse("Should not drop when one predicate could be true", canDrop(or(B, y), ccmd, dictionaries));    assertFalse("Should not drop when one predicate could be true", canDrop(or(x, C), ccmd, dictionaries));    assertTrue("Should drop when both predicates must be false", canDrop(or(B, C), ccmd, dictionaries));    assertFalse("Should not drop when one predicate could be true", canDrop(or(x, y), ccmd, dictionaries));}
ee1343d6d4323af6532e1be85d09e57d0228b603b63d34f6a1e938b963cd0cea
testUdp
public void testUdp() throws Exception
{    InInt32UDP dropabble = new InInt32UDP(ImmutableSet.of(42));    InInt32UDP undroppable = new InInt32UDP(ImmutableSet.of(205));    assertTrue("Should drop block for non-matching UDP", canDrop(userDefined(intColumn("int32_field"), dropabble), ccmd, dictionaries));    assertFalse("Should not drop block for matching UDP", canDrop(userDefined(intColumn("int32_field"), undroppable), ccmd, dictionaries));}
4e54c27e584286f8584c9f8f0f4ba1f736957ca063eaa95e92b0b63479746247
testInverseUdp
public void testInverseUdp() throws Exception
{    InInt32UDP droppable = new InInt32UDP(ImmutableSet.of(42));    InInt32UDP undroppable = new InInt32UDP(ImmutableSet.of(205));    Set<Integer> allValues = ImmutableSet.copyOf(Arrays.asList(ArrayUtils.toObject(intValues)));    InInt32UDP completeMatch = new InInt32UDP(allValues);    FilterPredicate inverse = LogicalInverseRewriter.rewrite(not(userDefined(intColumn("int32_field"), droppable)));    FilterPredicate inverse1 = LogicalInverseRewriter.rewrite(not(userDefined(intColumn("int32_field"), undroppable)));    FilterPredicate inverse2 = LogicalInverseRewriter.rewrite(not(userDefined(intColumn("int32_field"), completeMatch)));    assertFalse("Should not drop block for inverse of non-matching UDP", canDrop(inverse, ccmd, dictionaries));    assertFalse("Should not drop block for inverse of UDP with some matches", canDrop(inverse1, ccmd, dictionaries));    assertTrue("Should drop block for inverse of UDP with all matches", canDrop(inverse2, ccmd, dictionaries));}
f2d52e197d0913b89bcf303a1f91527857e1d8c6b1aae2a3c5d5fbd2f7b918b0
testColumnWithoutDictionary
public void testColumnWithoutDictionary() throws Exception
{    IntColumn plain = intColumn("plain_int32_field");    DictionaryPageReadStore dictionaryStore = mock(DictionaryPageReadStore.class);    assertFalse("Should never drop block using plain encoding", canDrop(eq(plain, -10), ccmd, dictionaryStore));    assertFalse("Should never drop block using plain encoding", canDrop(lt(plain, -10), ccmd, dictionaryStore));    assertFalse("Should never drop block using plain encoding", canDrop(ltEq(plain, -10), ccmd, dictionaryStore));    assertFalse("Should never drop block using plain encoding", canDrop(gt(plain, nElements + 10), ccmd, dictionaryStore));    assertFalse("Should never drop block using plain encoding", canDrop(gtEq(plain, nElements + 10), ccmd, dictionaryStore));    assertFalse("Should never drop block using plain encoding", canDrop(notEq(plain, nElements + 10), ccmd, dictionaryStore));    verifyZeroInteractions(dictionaryStore);}
e4bfbc9e5c5dfc4189bc0b87cd7b64ab471112e2fd1383e49887c663924b25a2
testColumnWithDictionaryAndPlainEncodings
public void testColumnWithDictionaryAndPlainEncodings() throws Exception
{    IntColumn plain = intColumn("fallback_binary_field");    DictionaryPageReadStore dictionaryStore = mock(DictionaryPageReadStore.class);    assertFalse("Should never drop block using plain encoding", canDrop(eq(plain, -10), ccmd, dictionaryStore));    assertFalse("Should never drop block using plain encoding", canDrop(lt(plain, -10), ccmd, dictionaryStore));    assertFalse("Should never drop block using plain encoding", canDrop(ltEq(plain, -10), ccmd, dictionaryStore));    assertFalse("Should never drop block using plain encoding", canDrop(gt(plain, nElements + 10), ccmd, dictionaryStore));    assertFalse("Should never drop block using plain encoding", canDrop(gtEq(plain, nElements + 10), ccmd, dictionaryStore));    assertFalse("Should never drop block using plain encoding", canDrop(notEq(plain, nElements + 10), ccmd, dictionaryStore));    verifyZeroInteractions(dictionaryStore);}
a3add2268f0b22cc55183f6bac012b395dbc905cbcb72a963d4d4e617181fcff
testEqMissingColumn
public void testEqMissingColumn() throws Exception
{    BinaryColumn b = binaryColumn("missing_column");    assertTrue("Should drop block for non-null query", canDrop(eq(b, Binary.fromString("any")), ccmd, dictionaries));    assertFalse("Should not drop block null query", canDrop(eq(b, null), ccmd, dictionaries));}
4a7abe9f73e13158c9aff38f5b18e93080a56d9cdedc30d0b20aa8f2fd1dba5d
testNotEqMissingColumn
public void testNotEqMissingColumn() throws Exception
{    BinaryColumn b = binaryColumn("missing_column");    assertFalse("Should not drop block for non-null query", canDrop(notEq(b, Binary.fromString("any")), ccmd, dictionaries));    assertTrue("Should not drop block null query", canDrop(notEq(b, null), ccmd, dictionaries));}
8ebdeeb92d1eabfa35cb4a1e8a575afa8c5752ac0493bcbc25557b453023d15c
testLtMissingColumn
public void testLtMissingColumn() throws Exception
{    BinaryColumn b = binaryColumn("missing_column");    assertTrue("Should drop block for any non-null query", canDrop(lt(b, Binary.fromString("any")), ccmd, dictionaries));}
cacf5c26fc1df9e5d046f227104c9ed3ab106895368fefcd7955ab6fc45da20b
testLtEqMissingColumn
public void testLtEqMissingColumn() throws Exception
{    BinaryColumn b = binaryColumn("missing_column");    assertTrue("Should drop block for any non-null query", canDrop(ltEq(b, Binary.fromString("any")), ccmd, dictionaries));}
e7c25242b8b704c903c3346c1d215ca34bf9e36de359dedef989113b13d19379
testGtMissingColumn
public void testGtMissingColumn() throws Exception
{    BinaryColumn b = binaryColumn("missing_column");    assertTrue("Should drop block for any non-null query", canDrop(gt(b, Binary.fromString("any")), ccmd, dictionaries));}
a2affb9a7dcbe869870a6275ce9d417599e9fb27c1f61a45b0881aa85b73d7be
testGtEqMissingColumn
public void testGtEqMissingColumn() throws Exception
{    BinaryColumn b = binaryColumn("missing_column");    assertTrue("Should drop block for any non-null query", canDrop(gtEq(b, Binary.fromString("any")), ccmd, dictionaries));}
4e79d4c55e618f7f9e2093ee6ec89a34d04a85e2c82e9845462e46d73a119fb3
testUdpMissingColumn
public void testUdpMissingColumn() throws Exception
{    InInt32UDP nullRejecting = new InInt32UDP(ImmutableSet.of(42));    InInt32UDP nullAccepting = new InInt32UDP(Sets.newHashSet((Integer) null));    IntColumn fake = intColumn("missing_column");    assertTrue("Should drop block for null rejecting udp", canDrop(userDefined(fake, nullRejecting), ccmd, dictionaries));    assertFalse("Should not drop block for null accepting udp", canDrop(userDefined(fake, nullAccepting), ccmd, dictionaries));}
54d56e43f335a1407b5c703a73d40f99d27f027755c0bc62938e3d0314049bf3
testInverseUdpMissingColumn
public void testInverseUdpMissingColumn() throws Exception
{    InInt32UDP nullRejecting = new InInt32UDP(ImmutableSet.of(42));    InInt32UDP nullAccepting = new InInt32UDP(Sets.newHashSet((Integer) null));    IntColumn fake = intColumn("missing_column");    assertTrue("Should drop block for null accepting udp", canDrop(LogicalInverseRewriter.rewrite(not(userDefined(fake, nullAccepting))), ccmd, dictionaries));    assertFalse("Should not drop block for null rejecting udp", canDrop(LogicalInverseRewriter.rewrite(not(userDefined(fake, nullRejecting))), ccmd, dictionaries));}
7f7f3f19704e2a738e37683ea1e845cc8989f3ea09f4b8dd10734db5795ded63
keep
public boolean keep(Integer value)
{    return ints.contains(value);}
c7a72c7a33471a778e8b2a612fa9450efb2b3f8c5a5ec016b75b49a1a893850b
canDrop
public boolean canDrop(Statistics<Integer> statistics)
{    return false;}
ebdbd08b714a5ea0982d87cfe65d5c0cbd451cc408d5f216453963845d6ce249
inverseCanDrop
public boolean inverseCanDrop(Statistics<Integer> statistics)
{    return false;}
65d0b2b7023a1ac8f580556c0bff58069c64a1bbb2aba5a73fe2546e0df7a8a7
toDouble
private static double toDouble(int value)
{    return (value * 1.0);}
8907ee17c2365830be3ccea661444290072a60e46f9f16e66bea2e941ea161a3
toFloat
private static float toFloat(int value)
{    return (float) (value * 2.0);}
487eb55a3615d41e26ffdbc1ddfea28a07881e34d460eee1f4d5e3a15d755c12
getLon
public Double getLon()
{    return lon;}
d70d18f3165beb13c9ddb407f76ea7134eefbe3cbf63822e2f177b5c835493b4
getLat
public Double getLat()
{    return lat;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    Location location = (Location) o;    if (lat != null ? !lat.equals(location.lat) : location.lat != null)        return false;    if (lon != null ? !lon.equals(location.lon) : location.lon != null)        return false;    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = lon != null ? lon.hashCode() : 0;    result = 31 * result + (lat != null ? lat.hashCode() : 0);    return result;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "Location [lon=" + lon + ", lat=" + lat + "]";}
497d96a59910be6ad82909ca3f254dd422ba1a6a76f79be53c3ef3ed155bfdff
getNumber
public long getNumber()
{    return number;}
fda1e952ebbdad0bba153b131a02ac894a1a2a870a39f24bdd51e458a14a9ed7
getKind
public String getKind()
{    return kind;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    PhoneNumber that = (PhoneNumber) o;    if (number != that.number)        return false;    if (kind != null ? !kind.equals(that.kind) : that.kind != null)        return false;    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = (int) (number ^ (number >>> 32));    result = 31 * result + (kind != null ? kind.hashCode() : 0);    return result;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "PhoneNumber [number=" + number + ", kind=" + kind + "]";}
12988e32fb9e7822231bf05b7d2b2013fd70cf350e185d48e6fdacbe7847e62e
getId
public long getId()
{    return id;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
bd949d38383bfd98a37fdd3587b9ce7dc658e56ed3e3295e63bd59143a4198ee
getPhoneNumbers
public List<PhoneNumber> getPhoneNumbers()
{    return phoneNumbers;}
a6a4ebfeb9388d4e89f8536c9318fa42a533dcfa6300eee2e7f97db54acd96c0
getLocation
public Location getLocation()
{    return location;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    User user = (User) o;    if (id != user.id)        return false;    if (location != null ? !location.equals(user.location) : user.location != null)        return false;    if (name != null ? !name.equals(user.name) : user.name != null)        return false;    if (phoneNumbers != null ? !phoneNumbers.equals(user.phoneNumbers) : user.phoneNumbers != null)        return false;    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = (int) (id ^ (id >>> 32));    result = 31 * result + (name != null ? name.hashCode() : 0);    result = 31 * result + (phoneNumbers != null ? phoneNumbers.hashCode() : 0);    result = 31 * result + (location != null ? location.hashCode() : 0);    return result;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "User [id=" + id + ", name=" + name + ", phoneNumbers=" + phoneNumbers + ", location=" + location + "]";}
e79cad9fd33bf346439ec8d08dd14f184e605213acc429da37cab1b6b536b518
groupFromUser
public static SimpleGroup groupFromUser(User user)
{    SimpleGroup root = new SimpleGroup(schema);    root.append("id", user.getId());    if (user.getName() != null) {        root.append("name", user.getName());    }    if (user.getPhoneNumbers() != null) {        Group phoneNumbers = root.addGroup("phoneNumbers");        for (PhoneNumber number : user.getPhoneNumbers()) {            Group phone = phoneNumbers.addGroup("phone");            phone.append("number", number.getNumber());            if (number.getKind() != null) {                phone.append("kind", number.getKind());            }        }    }    if (user.getLocation() != null) {        Group location = root.addGroup("location");        if (user.getLocation().getLon() != null) {            location.append("lon", user.getLocation().getLon());        }        if (user.getLocation().getLat() != null) {            location.append("lat", user.getLocation().getLat());        }    }    return root;}
40bcfd326f78b58231ae50a0d4a2756ae279c04a65f98d999ef66a30140b463c
userFromGroup
private static User userFromGroup(Group root)
{    return new User(getLong(root, "id"), getString(root, "name"), getPhoneNumbers(getGroup(root, "phoneNumbers")), getLocation(getGroup(root, "location")));}
17d66358ec7810b3ab20247ae51e46f096bdf06418a3f5a76eba358ed1aece94
getPhoneNumbers
private static List<PhoneNumber> getPhoneNumbers(Group phoneNumbers)
{    if (phoneNumbers == null) {        return null;    }    List<PhoneNumber> list = new ArrayList<>();    for (int i = 0, n = phoneNumbers.getFieldRepetitionCount("phone"); i < n; ++i) {        Group phone = phoneNumbers.getGroup("phone", i);        list.add(new PhoneNumber(getLong(phone, "number"), getString(phone, "kind")));    }    return list;}
1f5339d2738b2d1fa3d5b4079a544fa855e655157660f63dacbae76ebf4a3dde
getLocation
private static Location getLocation(Group location)
{    if (location == null) {        return null;    }    return new Location(getDouble(location, "lon"), getDouble(location, "lat"));}
1b278051de5d21e16248efc2f9a066ce360bd11a42626ae079412a00526daa04
isNull
private static boolean isNull(Group group, String field)
{    int repetition = group.getFieldRepetitionCount(field);    if (repetition == 0) {        return true;    } else if (repetition == 1) {        return false;    }    throw new AssertionError("Invalid repetitionCount " + repetition + " for field " + field + " in group " + group);}
6dcbb414fb7aa77af8f51c954ef276d80d16423533384b32e83d8b290b947be6
getLong
private static Long getLong(Group group, String field)
{    return isNull(group, field) ? null : group.getLong(field, 0);}
98f1bf9558d2ef576a8eb8f37559172e5b3f38ca43a7c831bfce8171ef22f7c2
getString
private static String getString(Group group, String field)
{    return isNull(group, field) ? null : group.getString(field, 0);}
811e69f267c69101e92f15470a9cb9c046560dfbc895fa09621041828789b655
getDouble
private static Double getDouble(Group group, String field)
{    return isNull(group, field) ? null : group.getDouble(field, 0);}
55b7af2503b89d35dd04694037d651a4ee37c187c8b7d531f237631e7cabd6d2
getGroup
private static Group getGroup(Group group, String field)
{    return isNull(group, field) ? null : group.getGroup(field, 0);}
289b06a795f975b3925b5cf6165f5870e28fbf040af4bee98428cfdc95ea4ecd
writeToFile
public static File writeToFile(List<User> users) throws IOException
{    File f = File.createTempFile("phonebook", ".parquet");    f.deleteOnExit();    if (!f.delete()) {        throw new IOException("couldn't delete tmp file" + f);    }    writeToFile(f, users);    return f;}
531385cc99e465c0487ce73bacad1c024f0000c478d24b2ef69ff4aaf2ec8276
writeToFile
public static void writeToFile(File f, List<User> users) throws IOException
{    write(ExampleParquetWriter.builder(new Path(f.getAbsolutePath())), users);}
5e73a3dbda4bc7638bc611f0382f30700cf80b67cc672401db9ea32523e4a44c
write
public static void write(ParquetWriter.Builder<Group, ?> builder, List<User> users) throws IOException
{    builder.config(GroupWriteSupport.PARQUET_EXAMPLE_SCHEMA, schema.toString());    try (ParquetWriter<Group> writer = builder.build()) {        for (User u : users) {            writer.write(groupFromUser(u));        }    }}
a11afb05a64ee609f666f84a7a62b5c9022e3063ceebad9c4bc8fac59b6810d5
createReader
private static ParquetReader<Group> createReader(Path file, Filter filter) throws IOException
{    Configuration conf = new Configuration();    GroupWriteSupport.setSchema(schema, conf);    return ParquetReader.builder(new GroupReadSupport(), file).withConf(conf).withFilter(filter).build();}
87af9616620c2d8c17e0a710777b820bca9794cc3d5a2c66b5e032dc6468a7e2
readFile
public static List<Group> readFile(File f, Filter filter) throws IOException
{    ParquetReader<Group> reader = createReader(new Path(f.getAbsolutePath()), filter);    Group current;    List<Group> users = new ArrayList<Group>();    current = reader.read();    while (current != null) {        users.add(current);        current = reader.read();    }    return users;}
6215dac1ac5eb8850ea88896b8c53cf72d2a4290c4c753136917c8775b58ede1
readUsers
public static List<User> readUsers(ParquetReader.Builder<Group> builder) throws IOException
{    ParquetReader<Group> reader = builder.set(GroupWriteSupport.PARQUET_EXAMPLE_SCHEMA, schema.toString()).build();    List<User> users = new ArrayList<>();    for (Group group = reader.read(); group != null; group = reader.read()) {        users.add(userFromGroup(group));    }    return users;}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    File f = new File(args[0]);    writeToFile(f, TestRecordLevelFilters.makeUsers());}
db199a605a9c2722d1ce5ac1b1bb6d823b5a541e48ab877eccae56a308ea7445
makeUsers
public static List<User> makeUsers()
{    List<User> users = new ArrayList<User>();    users.add(new User(17, null, null, null));    users.add(new User(18, "bob", null, null));    users.add(new User(19, "alice", new ArrayList<PhoneNumber>(), null));    users.add(new User(20, "thing1", Arrays.asList(new PhoneNumber(5555555555L, null)), null));    users.add(new User(27, "thing2", Arrays.asList(new PhoneNumber(1111111111L, "home")), null));    users.add(new User(28, "popular", Arrays.asList(new PhoneNumber(1111111111L, "home"), new PhoneNumber(2222222222L, null), new PhoneNumber(3333333333L, "mobile")), null));    users.add(new User(30, null, Arrays.asList(new PhoneNumber(1111111111L, "home")), null));    for (int i = 100; i < 200; i++) {        Location location = null;        if (i % 3 == 1) {            location = new Location((double) i, (double) i * 2);        }        if (i % 3 == 2) {            location = new Location((double) i, null);        }        users.add(new User(i, "p" + i, Arrays.asList(new PhoneNumber(i, "cell")), location));    }    return users;}
b0e4f4e9883c6e30a76a69d8bdb4dd47fe10432f8449ddcd8f495020661c0209
setup
public static void setup() throws IOException
{    users = makeUsers();    phonebookFile = PhoneBookWriter.writeToFile(users);}
064f14512e4244844bfba1615c45e8a7287f22522d84785ab6a15d54da19781d
getExpected
private static List<Group> getExpected(UserFilter f)
{    List<Group> expected = new ArrayList<Group>();    for (User u : users) {        if (f.keep(u)) {            expected.add(PhoneBookWriter.groupFromUser(u));        }    }    return expected;}
bcdf0c07b1a71fb178121f6c9d38daedfde3ea67fa8500aa0db256eb20737df7
assertFilter
private static void assertFilter(List<Group> found, UserFilter f)
{    List<Group> expected = getExpected(f);    assertEquals(expected.size(), found.size());    Iterator<Group> expectedIter = expected.iterator();    Iterator<Group> foundIter = found.iterator();    while (expectedIter.hasNext()) {        assertEquals(expectedIter.next().toString(), foundIter.next().toString());    }}
d26fb415c2b37c484db4dcee2717ff37792856005edbcbca1327e8fb2190deb3
testNoFilter
public void testNoFilter() throws Exception
{    List<Group> found = PhoneBookWriter.readFile(phonebookFile, FilterCompat.NOOP);    assertFilter(found, new UserFilter() {        @Override        public boolean keep(User u) {            return true;        }    });}
426063b1d6120179dfa72113da024a7e1c02aa8297b4d647a2434e58d300554a
keep
public boolean keep(User u)
{    return true;}
d106a997f378bbc1916e3e30d280d3319e23b9f0b52d7de9d51ec1f6a95d54f5
testAllFilter
public void testAllFilter() throws Exception
{    BinaryColumn name = binaryColumn("name");    FilterPredicate pred = eq(name, Binary.fromString("no matches"));    List<Group> found = PhoneBookWriter.readFile(phonebookFile, FilterCompat.get(pred));    assertEquals(new ArrayList<Group>(), found);}
e5e0641dcfbd7aea33b4c2e82f105dd310f39149ba8d22002db3c102b2c77d97
testNameNotNull
public void testNameNotNull() throws Exception
{    BinaryColumn name = binaryColumn("name");    FilterPredicate pred = notEq(name, null);    List<Group> found = PhoneBookWriter.readFile(phonebookFile, FilterCompat.get(pred));    assertFilter(found, new UserFilter() {        @Override        public boolean keep(User u) {            return u.getName() != null;        }    });}
426063b1d6120179dfa72113da024a7e1c02aa8297b4d647a2434e58d300554a
keep
public boolean keep(User u)
{    return u.getName() != null;}
1d830f6b642fa3232a3173f18fb7638d7113fe65b683f2be7e994bb1091c6bb1
keep
public boolean keep(Binary value)
{    if (value == null) {        return false;    }    return value.toStringUsingUTF8().startsWith("p");}
83f1f836020cb0268463e637d35d40decc8bfd13fc8c7cef95c4065617f8ee34
canDrop
public boolean canDrop(Statistics<Binary> statistics)
{    return false;}
49cb432a1c15577fdafed299fd1810441fbd2ac8ce3056305de4e5aec9babf28
inverseCanDrop
public boolean inverseCanDrop(Statistics<Binary> statistics)
{    return false;}
6a0ad857c4f18f2d64da235f3e095c2ada5780c75df3139c572f63f22a8e65a5
keep
public boolean keep(Long value)
{    if (value == null) {        return false;    }    return hSet.contains(value);}
9dc064c84e7b360a598629007633ef115befb8e2ff84a21a63d976d15c28aa30
canDrop
public boolean canDrop(Statistics<Long> statistics)
{    return false;}
24d038c437c6c7c61085c1cd71d35f9d7ea6ee4a52d448b6b35d55f55712b809
inverseCanDrop
public boolean inverseCanDrop(Statistics<Long> statistics)
{    return false;}
f97c094675e7f958e304df1aa338540a8877f3a572eb0c7bc9297a75314bdd7d
testNameNotStartWithP
public void testNameNotStartWithP() throws Exception
{    BinaryColumn name = binaryColumn("name");    FilterPredicate pred = not(userDefined(name, StartWithP.class));    List<Group> found = PhoneBookWriter.readFile(phonebookFile, FilterCompat.get(pred));    assertFilter(found, new UserFilter() {        @Override        public boolean keep(User u) {            return u.getName() == null || !u.getName().startsWith("p");        }    });}
426063b1d6120179dfa72113da024a7e1c02aa8297b4d647a2434e58d300554a
keep
public boolean keep(User u)
{    return u.getName() == null || !u.getName().startsWith("p");}
d6461680e4b13a40e1909dc0c012ef158edbe39da8918341ad1012d5a5cd5467
testUserDefinedByInstance
public void testUserDefinedByInstance() throws Exception
{    LongColumn name = longColumn("id");    final HashSet<Long> h = new HashSet<Long>();    h.add(20L);    h.add(27L);    h.add(28L);    FilterPredicate pred = userDefined(name, new SetInFilter(h));    List<Group> found = PhoneBookWriter.readFile(phonebookFile, FilterCompat.get(pred));    assertFilter(found, new UserFilter() {        @Override        public boolean keep(User u) {            return u != null && h.contains(u.getId());        }    });}
426063b1d6120179dfa72113da024a7e1c02aa8297b4d647a2434e58d300554a
keep
public boolean keep(User u)
{    return u != null && h.contains(u.getId());}
6c59f36aa84086177a2b75955aea6343b63ef9e07818b9ec5cce370436246ff6
testComplex
public void testComplex() throws Exception
{    BinaryColumn name = binaryColumn("name");    DoubleColumn lon = doubleColumn("location.lon");    DoubleColumn lat = doubleColumn("location.lat");    FilterPredicate pred = or(and(gt(lon, 150.0), notEq(lat, null)), eq(name, Binary.fromString("alice")));    List<Group> found = PhoneBookWriter.readFile(phonebookFile, FilterCompat.get(pred));    assertFilter(found, new UserFilter() {        @Override        public boolean keep(User u) {            String name = u.getName();            Double lat = null;            Double lon = null;            if (u.getLocation() != null) {                lat = u.getLocation().getLat();                lon = u.getLocation().getLon();            }            return (lon != null && lon > 150.0 && lat != null) || "alice".equals(name);        }    });}
426063b1d6120179dfa72113da024a7e1c02aa8297b4d647a2434e58d300554a
keep
public boolean keep(User u)
{    String name = u.getName();    Double lat = null;    Double lon = null;    if (u.getLocation() != null) {        lat = u.getLocation().getLat();        lon = u.getLocation().getLon();    }    return (lon != null && lon > 150.0 && lat != null) || "alice".equals(name);}
ed70464a0131d1f36135e843bb193217fe1fd017eb4520a01fff6a23d56cd64d
getIntColumnMeta
private static ColumnChunkMetaData getIntColumnMeta(org.apache.parquet.column.statistics.Statistics<?> stats, long valueCount)
{    return ColumnChunkMetaData.get(ColumnPath.get("int", "column"), PrimitiveTypeName.INT32, CompressionCodecName.GZIP, new HashSet<Encoding>(Arrays.asList(Encoding.PLAIN)), stats, 0L, 0L, valueCount, 0L, 0L);}
7b7e02c765aeaef521e3ad774f6bd8e8b9ec053d3ce3a0665b97a4a723d71f68
getDoubleColumnMeta
private static ColumnChunkMetaData getDoubleColumnMeta(org.apache.parquet.column.statistics.Statistics<?> stats, long valueCount)
{    return ColumnChunkMetaData.get(ColumnPath.get("double", "column"), PrimitiveTypeName.DOUBLE, CompressionCodecName.GZIP, new HashSet<Encoding>(Arrays.asList(Encoding.PLAIN)), stats, 0L, 0L, valueCount, 0L, 0L);}
30fe6c631dff1d9ea6e9602410f4f4b135e3d76ba688536ebd851dd760f7b574
testEqNonNull
public void testEqNonNull()
{    assertTrue(canDrop(eq(intColumn, 9), columnMetas));    assertFalse(canDrop(eq(intColumn, 10), columnMetas));    assertFalse(canDrop(eq(intColumn, 100), columnMetas));    assertTrue(canDrop(eq(intColumn, 101), columnMetas));        assertTrue(canDrop(eq(intColumn, 0), nullColumnMetas));    assertTrue(canDrop(eq(missingColumn, fromString("any")), columnMetas));    assertFalse(canDrop(eq(intColumn, 50), missingMinMaxColumnMetas));    assertFalse(canDrop(eq(doubleColumn, 50.0), missingMinMaxColumnMetas));}
27a2c54ef7a32136427ea110a264f7231329fefa02a6879a7d6215ab9f4b4d10
testEqNull
public void testEqNull()
{    IntStatistics statsNoNulls = new IntStatistics();    statsNoNulls.setMinMax(10, 100);    statsNoNulls.setNumNulls(0);    IntStatistics statsSomeNulls = new IntStatistics();    statsSomeNulls.setMinMax(10, 100);    statsSomeNulls.setNumNulls(3);    assertTrue(canDrop(eq(intColumn, null), Arrays.asList(getIntColumnMeta(statsNoNulls, 177L), getDoubleColumnMeta(doubleStats, 177L))));    assertFalse(canDrop(eq(intColumn, null), Arrays.asList(getIntColumnMeta(statsSomeNulls, 177L), getDoubleColumnMeta(doubleStats, 177L))));    assertFalse(canDrop(eq(missingColumn, null), columnMetas));    assertFalse(canDrop(eq(intColumn, null), missingMinMaxColumnMetas));    assertFalse(canDrop(eq(doubleColumn, null), missingMinMaxColumnMetas));}
7a6b720809f946a80534fb46fe2a76d5049f023be9bd0c1b21ed8dcda166a1c3
testNotEqNonNull
public void testNotEqNonNull()
{    assertFalse(canDrop(notEq(intColumn, 9), columnMetas));    assertFalse(canDrop(notEq(intColumn, 10), columnMetas));    assertFalse(canDrop(notEq(intColumn, 100), columnMetas));    assertFalse(canDrop(notEq(intColumn, 101), columnMetas));    IntStatistics allSevens = new IntStatistics();    allSevens.setMinMax(7, 7);    assertTrue(canDrop(notEq(intColumn, 7), Arrays.asList(getIntColumnMeta(allSevens, 177L), getDoubleColumnMeta(doubleStats, 177L))));    allSevens.setNumNulls(100L);    assertFalse(canDrop(notEq(intColumn, 7), Arrays.asList(getIntColumnMeta(allSevens, 177L), getDoubleColumnMeta(doubleStats, 177L))));    allSevens.setNumNulls(177L);    assertFalse(canDrop(notEq(intColumn, 7), Arrays.asList(getIntColumnMeta(allSevens, 177L), getDoubleColumnMeta(doubleStats, 177L))));    assertFalse(canDrop(notEq(missingColumn, fromString("any")), columnMetas));    assertFalse(canDrop(notEq(intColumn, 50), missingMinMaxColumnMetas));    assertFalse(canDrop(notEq(doubleColumn, 50.0), missingMinMaxColumnMetas));}
078e855152cbe7900d3206515ec0f787406b4751089da955c468e1f44bcb0f77
testNotEqNull
public void testNotEqNull()
{    IntStatistics statsNoNulls = new IntStatistics();    statsNoNulls.setMinMax(10, 100);    statsNoNulls.setNumNulls(0);    IntStatistics statsSomeNulls = new IntStatistics();    statsSomeNulls.setMinMax(10, 100);    statsSomeNulls.setNumNulls(3);    IntStatistics statsAllNulls = new IntStatistics();    statsAllNulls.setMinMax(0, 0);    statsAllNulls.setNumNulls(177);    assertFalse(canDrop(notEq(intColumn, null), Arrays.asList(getIntColumnMeta(statsNoNulls, 177L), getDoubleColumnMeta(doubleStats, 177L))));    assertFalse(canDrop(notEq(intColumn, null), Arrays.asList(getIntColumnMeta(statsSomeNulls, 177L), getDoubleColumnMeta(doubleStats, 177L))));    assertTrue(canDrop(notEq(intColumn, null), Arrays.asList(getIntColumnMeta(statsAllNulls, 177L), getDoubleColumnMeta(doubleStats, 177L))));    assertTrue(canDrop(notEq(missingColumn, null), columnMetas));    assertFalse(canDrop(notEq(intColumn, null), missingMinMaxColumnMetas));    assertFalse(canDrop(notEq(doubleColumn, null), missingMinMaxColumnMetas));}
6f76fac7f7bcda177895146ceb552e0c70c6cf47a4d7edc925e16e847d595fcf
testLt
public void testLt()
{    assertTrue(canDrop(lt(intColumn, 9), columnMetas));    assertTrue(canDrop(lt(intColumn, 10), columnMetas));    assertFalse(canDrop(lt(intColumn, 100), columnMetas));    assertFalse(canDrop(lt(intColumn, 101), columnMetas));    assertTrue(canDrop(lt(intColumn, 0), nullColumnMetas));    assertTrue(canDrop(lt(intColumn, 7), nullColumnMetas));    assertTrue(canDrop(lt(missingColumn, fromString("any")), columnMetas));    assertFalse(canDrop(lt(intColumn, 0), missingMinMaxColumnMetas));    assertFalse(canDrop(lt(doubleColumn, 0.0), missingMinMaxColumnMetas));}
b818f151bcf920cc4b7d4c60d27f67b04e1d1f84ec10bfff0753294d7f73825d
testLtEq
public void testLtEq()
{    assertTrue(canDrop(ltEq(intColumn, 9), columnMetas));    assertFalse(canDrop(ltEq(intColumn, 10), columnMetas));    assertFalse(canDrop(ltEq(intColumn, 100), columnMetas));    assertFalse(canDrop(ltEq(intColumn, 101), columnMetas));    assertTrue(canDrop(ltEq(intColumn, 0), nullColumnMetas));    assertTrue(canDrop(ltEq(intColumn, 7), nullColumnMetas));    assertTrue(canDrop(ltEq(missingColumn, fromString("any")), columnMetas));    assertFalse(canDrop(ltEq(intColumn, -1), missingMinMaxColumnMetas));    assertFalse(canDrop(ltEq(doubleColumn, -0.1), missingMinMaxColumnMetas));}
63d8c41ea734c9a51957a23db78d88c3561159d59894807cf943759eaad8fe57
testGt
public void testGt()
{    assertFalse(canDrop(gt(intColumn, 9), columnMetas));    assertFalse(canDrop(gt(intColumn, 10), columnMetas));    assertTrue(canDrop(gt(intColumn, 100), columnMetas));    assertTrue(canDrop(gt(intColumn, 101), columnMetas));    assertTrue(canDrop(gt(intColumn, 0), nullColumnMetas));    assertTrue(canDrop(gt(intColumn, 7), nullColumnMetas));    assertTrue(canDrop(gt(missingColumn, fromString("any")), columnMetas));    assertFalse(canDrop(gt(intColumn, 0), missingMinMaxColumnMetas));    assertFalse(canDrop(gt(doubleColumn, 0.0), missingMinMaxColumnMetas));}
d35ff48a2d5bd02cd3df2675d3b8f2d5e92eb53138dd6776f9dce96a107efeb7
testGtEq
public void testGtEq()
{    assertFalse(canDrop(gtEq(intColumn, 9), columnMetas));    assertFalse(canDrop(gtEq(intColumn, 10), columnMetas));    assertFalse(canDrop(gtEq(intColumn, 100), columnMetas));    assertTrue(canDrop(gtEq(intColumn, 101), columnMetas));    assertTrue(canDrop(gtEq(intColumn, 0), nullColumnMetas));    assertTrue(canDrop(gtEq(intColumn, 7), nullColumnMetas));    assertTrue(canDrop(gtEq(missingColumn, fromString("any")), columnMetas));    assertFalse(canDrop(gtEq(intColumn, 1), missingMinMaxColumnMetas));    assertFalse(canDrop(gtEq(doubleColumn, 0.1), missingMinMaxColumnMetas));}
add54cff8d9e6cbc84149e95c16e650ba05c5e54a19557393f3a6ad198b62cde
testAnd
public void testAnd()
{    FilterPredicate yes = eq(intColumn, 9);    FilterPredicate no = eq(doubleColumn, 50D);    assertTrue(canDrop(and(yes, yes), columnMetas));    assertTrue(canDrop(and(yes, no), columnMetas));    assertTrue(canDrop(and(no, yes), columnMetas));    assertFalse(canDrop(and(no, no), columnMetas));}
03468a694e1f76feba169429f64eb0afb2df050c46a06529a9d234068be47808
testOr
public void testOr()
{    FilterPredicate yes = eq(intColumn, 9);    FilterPredicate no = eq(doubleColumn, 50D);    assertTrue(canDrop(or(yes, yes), columnMetas));    assertFalse(canDrop(or(yes, no), columnMetas));    assertFalse(canDrop(or(no, yes), columnMetas));    assertFalse(canDrop(or(no, no), columnMetas));}
7f7f3f19704e2a738e37683ea1e845cc8989f3ea09f4b8dd10734db5795ded63
keep
public boolean keep(Integer value)
{    if (value == null) {        return true;    }    throw new RuntimeException("this method should not be called with value != null");}
c7a72c7a33471a778e8b2a612fa9450efb2b3f8c5a5ec016b75b49a1a893850b
canDrop
public boolean canDrop(Statistics<Integer> statistics)
{    return statistics.getMin() == 7 && statistics.getMax() == 7;}
ebdbd08b714a5ea0982d87cfe65d5c0cbd451cc408d5f216453963845d6ce249
inverseCanDrop
public boolean inverseCanDrop(Statistics<Integer> statistics)
{    return statistics.getMin() == 8 && statistics.getMax() == 8;}
7f7f3f19704e2a738e37683ea1e845cc8989f3ea09f4b8dd10734db5795ded63
keep
public boolean keep(Integer value)
{    if (value == null) {        return false;    }    throw new RuntimeException("this method should not be called with value != null");}
c058f73d6caff4aa161bdd3c24456a287edecb4d1bd073acfc183ec49054ae21
keep
public boolean keep(Double value)
{    if (value == null) {        return true;    }    throw new RuntimeException("this method should not be called with value != null");}
ede5a96db96b37ccf376fb0e026288b9705bdb7ae627cf36de17cfff9dafec8b
canDrop
public boolean canDrop(Statistics<Double> statistics)
{    return statistics.getMin() <= 0.0;}
4edc2312ed529d294bb167154779483408fbf0339a618a7c2aa16959c8d35374
inverseCanDrop
public boolean inverseCanDrop(Statistics<Double> statistics)
{    return statistics.getMin() > 0.0;}
cc0fcc2577b27f69277ce241caa2ebe9edf24b5a2bcda022d5574f15933c392f
testUdp
public void testUdp()
{    FilterPredicate pred = userDefined(intColumn, SevensAndEightsUdp.class);    FilterPredicate invPred = LogicalInverseRewriter.rewrite(not(userDefined(intColumn, SevensAndEightsUdp.class)));    FilterPredicate udpDropMissingColumn = userDefined(missingColumn2, DropNullUdp.class);    FilterPredicate invUdpDropMissingColumn = LogicalInverseRewriter.rewrite(not(userDefined(missingColumn2, DropNullUdp.class)));    FilterPredicate udpKeepMissingColumn = userDefined(missingColumn2, SevensAndEightsUdp.class);    FilterPredicate invUdpKeepMissingColumn = LogicalInverseRewriter.rewrite(not(userDefined(missingColumn2, SevensAndEightsUdp.class)));    FilterPredicate allPositivePred = userDefined(doubleColumn, AllPositiveUdp.class);    IntStatistics seven = new IntStatistics();    seven.setMinMax(7, 7);    IntStatistics eight = new IntStatistics();    eight.setMinMax(8, 8);    IntStatistics neither = new IntStatistics();    neither.setMinMax(1, 2);    assertTrue(canDrop(pred, Arrays.asList(getIntColumnMeta(seven, 177L), getDoubleColumnMeta(doubleStats, 177L))));    assertFalse(canDrop(pred, Arrays.asList(getIntColumnMeta(eight, 177L), getDoubleColumnMeta(doubleStats, 177L))));    assertFalse(canDrop(pred, Arrays.asList(getIntColumnMeta(neither, 177L), getDoubleColumnMeta(doubleStats, 177L))));    assertFalse(canDrop(invPred, Arrays.asList(getIntColumnMeta(seven, 177L), getDoubleColumnMeta(doubleStats, 177L))));    assertTrue(canDrop(invPred, Arrays.asList(getIntColumnMeta(eight, 177L), getDoubleColumnMeta(doubleStats, 177L))));    assertFalse(canDrop(invPred, Arrays.asList(getIntColumnMeta(neither, 177L), getDoubleColumnMeta(doubleStats, 177L))));        assertTrue(canDrop(udpDropMissingColumn, Arrays.asList(getIntColumnMeta(seven, 177L), getDoubleColumnMeta(doubleStats, 177L))));    assertTrue(canDrop(udpDropMissingColumn, Arrays.asList(getIntColumnMeta(eight, 177L), getDoubleColumnMeta(doubleStats, 177L))));    assertTrue(canDrop(udpDropMissingColumn, Arrays.asList(getIntColumnMeta(neither, 177L), getDoubleColumnMeta(doubleStats, 177L))));        assertFalse(canDrop(invUdpDropMissingColumn, Arrays.asList(getIntColumnMeta(seven, 177L), getDoubleColumnMeta(doubleStats, 177L))));    assertFalse(canDrop(invUdpDropMissingColumn, Arrays.asList(getIntColumnMeta(eight, 177L), getDoubleColumnMeta(doubleStats, 177L))));    assertFalse(canDrop(invUdpDropMissingColumn, Arrays.asList(getIntColumnMeta(neither, 177L), getDoubleColumnMeta(doubleStats, 177L))));        assertFalse(canDrop(udpKeepMissingColumn, Arrays.asList(getIntColumnMeta(seven, 177L), getDoubleColumnMeta(doubleStats, 177L))));    assertFalse(canDrop(udpKeepMissingColumn, Arrays.asList(getIntColumnMeta(eight, 177L), getDoubleColumnMeta(doubleStats, 177L))));    assertFalse(canDrop(udpKeepMissingColumn, Arrays.asList(getIntColumnMeta(neither, 177L), getDoubleColumnMeta(doubleStats, 177L))));        assertTrue(canDrop(invUdpKeepMissingColumn, Arrays.asList(getIntColumnMeta(seven, 177L), getDoubleColumnMeta(doubleStats, 177L))));    assertTrue(canDrop(invUdpKeepMissingColumn, Arrays.asList(getIntColumnMeta(eight, 177L), getDoubleColumnMeta(doubleStats, 177L))));    assertTrue(canDrop(invUdpKeepMissingColumn, Arrays.asList(getIntColumnMeta(neither, 177L), getDoubleColumnMeta(doubleStats, 177L))));    assertFalse(canDrop(allPositivePred, missingMinMaxColumnMetas));}
ca50d3722936d0010a21890cc71ecb30cfc5c1b7de86d3170353c41c6d8b5114
testClearExceptionForNots
public void testClearExceptionForNots()
{    List<ColumnChunkMetaData> columnMetas = Arrays.asList(getDoubleColumnMeta(new DoubleStatistics(), 0L), getIntColumnMeta(new IntStatistics(), 0L));    FilterPredicate pred = and(not(eq(doubleColumn, 12.0)), eq(intColumn, 17));    try {        canDrop(pred, columnMetas);        fail("This should throw");    } catch (IllegalArgumentException e) {        assertEquals("This predicate contains a not! Did you forget to run this predicate through LogicalInverseRewriter?" + " not(eq(double.column, 12.0))", e.getMessage());    }}
305cd5e3c92fc65c509ad2cd5942523e0654de5178e940b0cf5dacd96ac7132e
createDataFile
public void createDataFile() throws Exception
{    File file = temp.newFile("test.parquet");    this.path = new Path(file.toString());    MessageType type = Types.buildMessage().required(INT64).named("id").required(BINARY).as(UTF8).named("data").named("test");    SimpleGroupFactory factory = new SimpleGroupFactory(type);    ParquetWriter<Group> writer = ExampleParquetWriter.builder(path).withWriteMode(ParquetFileWriter.Mode.OVERWRITE).withType(type).build();    try {        for (long i = 0; i < 1000; i += 1) {            Group g = factory.newGroup();            g.add(0, i);            g.add(1, "data-" + i);            writer.write(g);        }    } finally {        writer.close();    }}
63084f2d6322637c0db428c45b4ac55ba2ea77a4de7564c3182e213e830f1e45
testNormalFilter
public void testNormalFilter() throws Exception
{    assertEquals(500, countFilteredRecords(path, lt(longColumn("id"), 500L)));}
69a4834ce82e08d4817c1318ac5915edd8a22543eb347954974c044d27643a5c
testSimpleMissingColumnFilter
public void testSimpleMissingColumnFilter() throws Exception
{    assertEquals(0, countFilteredRecords(path, lt(longColumn("missing"), 500L)));}
ff9bcb869555066a327ef7b6d852aede2546e832f7b0e6ccdacbfe4847f2a68c
testAndMissingColumnFilter
public void testAndMissingColumnFilter() throws Exception
{        assertEquals(500, countFilteredRecords(path, and(lt(longColumn("id"), 500L), eq(binaryColumn("missing"), null))));    assertEquals(500, countFilteredRecords(path, and(lt(longColumn("id"), 500L), notEq(binaryColumn("missing"), fromString("any")))));    assertEquals(500, countFilteredRecords(path, and(eq(binaryColumn("missing"), null), lt(longColumn("id"), 500L))));    assertEquals(500, countFilteredRecords(path, and(notEq(binaryColumn("missing"), fromString("any")), lt(longColumn("id"), 500L))));        assertEquals(0, countFilteredRecords(path, and(lt(longColumn("id"), 500L), eq(binaryColumn("missing"), fromString("any")))));    assertEquals(0, countFilteredRecords(path, and(lt(longColumn("id"), 500L), notEq(binaryColumn("missing"), null))));    assertEquals(0, countFilteredRecords(path, and(lt(longColumn("id"), 500L), lt(doubleColumn("missing"), 33.33))));    assertEquals(0, countFilteredRecords(path, and(lt(longColumn("id"), 500L), ltEq(doubleColumn("missing"), 33.33))));    assertEquals(0, countFilteredRecords(path, and(lt(longColumn("id"), 500L), gt(doubleColumn("missing"), 33.33))));    assertEquals(0, countFilteredRecords(path, and(lt(longColumn("id"), 500L), gtEq(doubleColumn("missing"), 33.33))));    assertEquals(0, countFilteredRecords(path, and(eq(binaryColumn("missing"), fromString("any")), lt(longColumn("id"), 500L))));    assertEquals(0, countFilteredRecords(path, and(notEq(binaryColumn("missing"), null), lt(longColumn("id"), 500L))));    assertEquals(0, countFilteredRecords(path, and(lt(doubleColumn("missing"), 33.33), lt(longColumn("id"), 500L))));    assertEquals(0, countFilteredRecords(path, and(ltEq(doubleColumn("missing"), 33.33), lt(longColumn("id"), 500L))));    assertEquals(0, countFilteredRecords(path, and(gt(doubleColumn("missing"), 33.33), lt(longColumn("id"), 500L))));    assertEquals(0, countFilteredRecords(path, and(gtEq(doubleColumn("missing"), 33.33), lt(longColumn("id"), 500L))));}
95f6cd9b1fc08945ad87944c6d41c2a7c97f61ac4d169ce9f0edc5d5299a8666
testOrMissingColumnFilter
public void testOrMissingColumnFilter() throws Exception
{        assertEquals(500, countFilteredRecords(path, or(lt(longColumn("id"), 500L), eq(binaryColumn("missing"), fromString("any")))));    assertEquals(500, countFilteredRecords(path, or(lt(longColumn("id"), 500L), notEq(binaryColumn("missing"), null))));    assertEquals(500, countFilteredRecords(path, or(lt(longColumn("id"), 500L), lt(doubleColumn("missing"), 33.33))));    assertEquals(500, countFilteredRecords(path, or(lt(longColumn("id"), 500L), ltEq(doubleColumn("missing"), 33.33))));    assertEquals(500, countFilteredRecords(path, or(lt(longColumn("id"), 500L), gt(doubleColumn("missing"), 33.33))));    assertEquals(500, countFilteredRecords(path, or(lt(longColumn("id"), 500L), gtEq(doubleColumn("missing"), 33.33))));    assertEquals(500, countFilteredRecords(path, or(eq(binaryColumn("missing"), fromString("any")), lt(longColumn("id"), 500L))));    assertEquals(500, countFilteredRecords(path, or(notEq(binaryColumn("missing"), null), lt(longColumn("id"), 500L))));    assertEquals(500, countFilteredRecords(path, or(lt(doubleColumn("missing"), 33.33), lt(longColumn("id"), 500L))));    assertEquals(500, countFilteredRecords(path, or(ltEq(doubleColumn("missing"), 33.33), lt(longColumn("id"), 500L))));    assertEquals(500, countFilteredRecords(path, or(gt(doubleColumn("missing"), 33.33), lt(longColumn("id"), 500L))));    assertEquals(500, countFilteredRecords(path, or(gtEq(doubleColumn("missing"), 33.33), lt(longColumn("id"), 500L))));        assertEquals(1000, countFilteredRecords(path, or(lt(longColumn("id"), 500L), eq(binaryColumn("missing"), null))));    assertEquals(1000, countFilteredRecords(path, or(lt(longColumn("id"), 500L), notEq(binaryColumn("missing"), fromString("any")))));    assertEquals(1000, countFilteredRecords(path, or(eq(binaryColumn("missing"), null), lt(longColumn("id"), 500L))));    assertEquals(1000, countFilteredRecords(path, or(notEq(binaryColumn("missing"), fromString("any")), lt(longColumn("id"), 500L))));}
fd4e92af277315847faaf420815e3717261d167588a9002732a5211a8ee60fa7
countFilteredRecords
public static long countFilteredRecords(Path path, FilterPredicate pred) throws IOException
{    ParquetReader<Group> reader = ParquetReader.builder(new GroupReadSupport(), path).withFilter(FilterCompat.get(pred)).build();    long count = 0;    try {        while (reader.read() != null) {            count += 1;        }    } finally {        reader.close();    }    return count;}
4e53151a9cc56bebd7457d2431715127f9fec9f88107d9e4e9986dd13f93f622
testPageHeader
public void testPageHeader() throws IOException
{    ByteArrayOutputStream out = new ByteArrayOutputStream();    PageType type = PageType.DATA_PAGE;    int compSize = 10;    int uncSize = 20;    PageHeader pageHeader = new PageHeader(type, uncSize, compSize);    writePageHeader(pageHeader, out);    PageHeader readPageHeader = readPageHeader(new ByteArrayInputStream(out.toByteArray()));    assertEquals(pageHeader, readPageHeader);}
4b873fc20686dc4ac6a1de2265bb52520fc0bca0e2941cad916b58ee740139c7
testSchemaConverter
public void testSchemaConverter()
{    ParquetMetadataConverter parquetMetadataConverter = new ParquetMetadataConverter();    List<SchemaElement> parquetSchema = parquetMetadataConverter.toParquetSchema(Paper.schema);    MessageType schema = parquetMetadataConverter.fromParquetSchema(parquetSchema, null);    assertEquals(Paper.schema, schema);}
d2e9d9adaeeadb3a8b5e2cf9ab518defd104893690fd13048233118660f0b2d6
testSchemaConverterDecimal
public void testSchemaConverterDecimal()
{    ParquetMetadataConverter parquetMetadataConverter = new ParquetMetadataConverter();    List<SchemaElement> schemaElements = parquetMetadataConverter.toParquetSchema(Types.buildMessage().required(PrimitiveTypeName.BINARY).as(OriginalType.DECIMAL).precision(9).scale(2).named("aBinaryDecimal").optional(PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY).length(4).as(OriginalType.DECIMAL).precision(9).scale(2).named("aFixedDecimal").named("Message"));    List<SchemaElement> expected = Lists.newArrayList(new SchemaElement("Message").setNum_children(2), new SchemaElement("aBinaryDecimal").setRepetition_type(FieldRepetitionType.REQUIRED).setType(Type.BYTE_ARRAY).setConverted_type(ConvertedType.DECIMAL).setLogicalType(LogicalType.DECIMAL(new DecimalType(2, 9))).setPrecision(9).setScale(2), new SchemaElement("aFixedDecimal").setRepetition_type(FieldRepetitionType.OPTIONAL).setType(Type.FIXED_LEN_BYTE_ARRAY).setType_length(4).setConverted_type(ConvertedType.DECIMAL).setLogicalType(LogicalType.DECIMAL(new DecimalType(2, 9))).setPrecision(9).setScale(2));    Assert.assertEquals(expected, schemaElements);}
aae2eedeaa3bc3b962f8a42e2ab9e7de11c4377c4ed61cdf7a7311ea25a2d40d
testLogicalTypesBackwardCompatibleWithConvertedTypes
public void testLogicalTypesBackwardCompatibleWithConvertedTypes()
{    ParquetMetadataConverter parquetMetadataConverter = new ParquetMetadataConverter();    MessageType expected = Types.buildMessage().required(PrimitiveTypeName.BINARY).as(OriginalType.DECIMAL).precision(9).scale(2).named("aBinaryDecimal").named("Message");    List<SchemaElement> parquetSchema = parquetMetadataConverter.toParquetSchema(expected);            parquetSchema.get(1).setLogicalType(null);    MessageType schema = parquetMetadataConverter.fromParquetSchema(parquetSchema, null);    assertEquals(expected, schema);}
944de015eb66bbf8a71e610b092c57b46dfe768bf07c6f4437fe51148cebde00
testIncompatibleLogicalAndConvertedTypes
public void testIncompatibleLogicalAndConvertedTypes()
{    ParquetMetadataConverter parquetMetadataConverter = new ParquetMetadataConverter();    MessageType schema = Types.buildMessage().required(PrimitiveTypeName.BINARY).as(OriginalType.DECIMAL).precision(9).scale(2).named("aBinary").named("Message");    MessageType expected = Types.buildMessage().required(PrimitiveTypeName.BINARY).as(LogicalTypeAnnotation.jsonType()).named("aBinary").named("Message");    List<SchemaElement> parquetSchema = parquetMetadataConverter.toParquetSchema(schema);        parquetSchema.get(1).setConverted_type(ConvertedType.JSON);    MessageType actual = parquetMetadataConverter.fromParquetSchema(parquetSchema, null);    assertEquals(expected, actual);}
032f9958682fbbded6d1f95ae7daaddcdb822a8e39cb536a8c9fec169b98dd83
testTimeLogicalTypes
public void testTimeLogicalTypes()
{    ParquetMetadataConverter parquetMetadataConverter = new ParquetMetadataConverter();    MessageType expected = Types.buildMessage().required(PrimitiveTypeName.INT64).as(timestampType(false, MILLIS)).named("aTimestampNonUtcMillis").required(PrimitiveTypeName.INT64).as(timestampType(true, MILLIS)).named("aTimestampUtcMillis").required(PrimitiveTypeName.INT64).as(timestampType(false, MICROS)).named("aTimestampNonUtcMicros").required(PrimitiveTypeName.INT64).as(timestampType(true, MICROS)).named("aTimestampUtcMicros").required(PrimitiveTypeName.INT64).as(timestampType(false, NANOS)).named("aTimestampNonUtcNanos").required(PrimitiveTypeName.INT64).as(timestampType(true, NANOS)).named("aTimestampUtcNanos").required(PrimitiveTypeName.INT32).as(timeType(false, MILLIS)).named("aTimeNonUtcMillis").required(PrimitiveTypeName.INT32).as(timeType(true, MILLIS)).named("aTimeUtcMillis").required(PrimitiveTypeName.INT64).as(timeType(false, MICROS)).named("aTimeNonUtcMicros").required(PrimitiveTypeName.INT64).as(timeType(true, MICROS)).named("aTimeUtcMicros").required(PrimitiveTypeName.INT64).as(timeType(false, NANOS)).named("aTimeNonUtcNanos").required(PrimitiveTypeName.INT64).as(timeType(true, NANOS)).named("aTimeUtcNanos").named("Message");    List<SchemaElement> parquetSchema = parquetMetadataConverter.toParquetSchema(expected);    MessageType schema = parquetMetadataConverter.fromParquetSchema(parquetSchema, null);    assertEquals(expected, schema);}
3b43850770f1d34fb9315be660f43aee22f9ba9315fed8e73e6617cb0d4e7bce
testLogicalToConvertedTypeConversion
public void testLogicalToConvertedTypeConversion()
{    ParquetMetadataConverter parquetMetadataConverter = new ParquetMetadataConverter();    assertEquals(ConvertedType.UTF8, parquetMetadataConverter.convertToConvertedType(stringType()));    assertEquals(ConvertedType.ENUM, parquetMetadataConverter.convertToConvertedType(enumType()));    assertEquals(ConvertedType.INT_8, parquetMetadataConverter.convertToConvertedType(intType(8, true)));    assertEquals(ConvertedType.INT_16, parquetMetadataConverter.convertToConvertedType(intType(16, true)));    assertEquals(ConvertedType.INT_32, parquetMetadataConverter.convertToConvertedType(intType(32, true)));    assertEquals(ConvertedType.INT_64, parquetMetadataConverter.convertToConvertedType(intType(64, true)));    assertEquals(ConvertedType.UINT_8, parquetMetadataConverter.convertToConvertedType(intType(8, false)));    assertEquals(ConvertedType.UINT_16, parquetMetadataConverter.convertToConvertedType(intType(16, false)));    assertEquals(ConvertedType.UINT_32, parquetMetadataConverter.convertToConvertedType(intType(32, false)));    assertEquals(ConvertedType.UINT_64, parquetMetadataConverter.convertToConvertedType(intType(64, false)));    assertEquals(ConvertedType.DECIMAL, parquetMetadataConverter.convertToConvertedType(decimalType(8, 16)));    assertEquals(ConvertedType.TIMESTAMP_MILLIS, parquetMetadataConverter.convertToConvertedType(timestampType(true, MILLIS)));    assertEquals(ConvertedType.TIMESTAMP_MICROS, parquetMetadataConverter.convertToConvertedType(timestampType(true, MICROS)));    assertNull(parquetMetadataConverter.convertToConvertedType(timestampType(true, NANOS)));    assertNull(parquetMetadataConverter.convertToConvertedType(timestampType(false, MILLIS)));    assertNull(parquetMetadataConverter.convertToConvertedType(timestampType(false, MICROS)));    assertNull(parquetMetadataConverter.convertToConvertedType(timestampType(false, NANOS)));    assertEquals(ConvertedType.TIME_MILLIS, parquetMetadataConverter.convertToConvertedType(timeType(true, MILLIS)));    assertEquals(ConvertedType.TIME_MICROS, parquetMetadataConverter.convertToConvertedType(timeType(true, MICROS)));    assertNull(parquetMetadataConverter.convertToConvertedType(timeType(true, NANOS)));    assertNull(parquetMetadataConverter.convertToConvertedType(timeType(false, MILLIS)));    assertNull(parquetMetadataConverter.convertToConvertedType(timeType(false, MICROS)));    assertNull(parquetMetadataConverter.convertToConvertedType(timeType(false, NANOS)));    assertEquals(ConvertedType.DATE, parquetMetadataConverter.convertToConvertedType(dateType()));    assertEquals(ConvertedType.INTERVAL, parquetMetadataConverter.convertToConvertedType(LogicalTypeAnnotation.IntervalLogicalTypeAnnotation.getInstance()));    assertEquals(ConvertedType.JSON, parquetMetadataConverter.convertToConvertedType(jsonType()));    assertEquals(ConvertedType.BSON, parquetMetadataConverter.convertToConvertedType(bsonType()));    assertEquals(ConvertedType.LIST, parquetMetadataConverter.convertToConvertedType(listType()));    assertEquals(ConvertedType.MAP, parquetMetadataConverter.convertToConvertedType(mapType()));    assertEquals(ConvertedType.MAP_KEY_VALUE, parquetMetadataConverter.convertToConvertedType(LogicalTypeAnnotation.MapKeyValueTypeAnnotation.getInstance()));}
7e82700f11762c8a98e28d77fde12a5ca211d69a1f9e00a60cf1ed4bb1c5e416
testEnumEquivalence
public void testEnumEquivalence()
{    ParquetMetadataConverter parquetMetadataConverter = new ParquetMetadataConverter();    for (org.apache.parquet.column.Encoding encoding : org.apache.parquet.column.Encoding.values()) {        assertEquals(encoding, parquetMetadataConverter.getEncoding(parquetMetadataConverter.getEncoding(encoding)));    }    for (org.apache.parquet.format.Encoding encoding : org.apache.parquet.format.Encoding.values()) {        assertEquals(encoding, parquetMetadataConverter.getEncoding(parquetMetadataConverter.getEncoding(encoding)));    }    for (Repetition repetition : Repetition.values()) {        assertEquals(repetition, parquetMetadataConverter.fromParquetRepetition(parquetMetadataConverter.toParquetRepetition(repetition)));    }    for (FieldRepetitionType repetition : FieldRepetitionType.values()) {        assertEquals(repetition, parquetMetadataConverter.toParquetRepetition(parquetMetadataConverter.fromParquetRepetition(repetition)));    }    for (PrimitiveTypeName primitiveTypeName : PrimitiveTypeName.values()) {        assertEquals(primitiveTypeName, parquetMetadataConverter.getPrimitive(parquetMetadataConverter.getType(primitiveTypeName)));    }    for (Type type : Type.values()) {        assertEquals(type, parquetMetadataConverter.getType(parquetMetadataConverter.getPrimitive(type)));    }    for (OriginalType original : OriginalType.values()) {        assertEquals(original, parquetMetadataConverter.getLogicalTypeAnnotation(parquetMetadataConverter.convertToConvertedType(LogicalTypeAnnotation.fromOriginalType(original, null)), null).toOriginalType());    }    for (ConvertedType converted : ConvertedType.values()) {        assertEquals(converted, parquetMetadataConverter.convertToConvertedType(parquetMetadataConverter.getLogicalTypeAnnotation(converted, null)));    }}
645d8e956d057f458d81ccc606f22ef588caa956c0a4f39f5a649497ac7e112f
metadata
private FileMetaData metadata(long... sizes)
{    List<SchemaElement> schema = emptyList();    List<RowGroup> rowGroups = new ArrayList<RowGroup>();    long offset = 0;    for (long size : sizes) {        ColumnChunk columnChunk = new ColumnChunk(offset);        columnChunk.setMeta_data(new ColumnMetaData(INT32, Collections.<org.apache.parquet.format.Encoding>emptyList(), Collections.<String>emptyList(), UNCOMPRESSED, 10l, size * 2, size, offset));        rowGroups.add(new RowGroup(Arrays.asList(columnChunk), size, 1));        offset += size;    }    return new FileMetaData(1, schema, sizes.length, rowGroups);}
a1d6d58c2349efc1ee3657e4b7da8adb7f19b446a9dc939986db4c3a2cfa6b34
filter
private FileMetaData filter(FileMetaData md, long start, long end)
{    return filterFileMetaDataByMidpoint(new FileMetaData(md), new ParquetMetadataConverter.RangeMetadataFilter(start, end));}
7a4beb692f42b34750f9fce82bfef059958a051a28b599358cfd3f4d4ee1bdd7
find
private FileMetaData find(FileMetaData md, Long... blockStart)
{    return filterFileMetaDataByStart(new FileMetaData(md), new ParquetMetadataConverter.OffsetMetadataFilter(Sets.newHashSet((Long[]) blockStart)));}
78d312e4027db3e3f999ad3c96b779ad47461ff39dbba1e4ec895bb159ce791d
find
private FileMetaData find(FileMetaData md, long blockStart)
{    return filterFileMetaDataByStart(new FileMetaData(md), new ParquetMetadataConverter.OffsetMetadataFilter(Sets.newHashSet(blockStart)));}
78cace8ed35c534e4772e3e7295b18d931dd4f04f769dd7153423fcd5e2030e1
verifyMD
private void verifyMD(FileMetaData md, long... offsets)
{    assertEquals(offsets.length, md.row_groups.size());    for (int i = 0; i < offsets.length; i++) {        long offset = offsets[i];        RowGroup rowGroup = md.getRow_groups().get(i);        assertEquals(offset, getOffset(rowGroup));    }}
ded0d36e676d900db4fac042cde03eba4726fe07db8c079d1d1a76e15355188b
verifyAllFilters
private void verifyAllFilters(FileMetaData md, long splitWidth)
{    Set<Long> offsetsFound = new TreeSet<Long>();    for (long start = 0; start < fileSize(md); start += splitWidth) {        FileMetaData filtered = filter(md, start, start + splitWidth);        for (RowGroup rg : filtered.getRow_groups()) {            long o = getOffset(rg);            if (offsetsFound.contains(o)) {                fail("found the offset twice: " + o);            } else {                offsetsFound.add(o);            }        }    }    if (offsetsFound.size() != md.row_groups.size()) {        fail("missing row groups, " + "found: " + offsetsFound + "\nexpected " + md.getRow_groups());    }}
bc4783af84296e021480bb26a3122b162c64fc005da572085eb51e9ef3229727
fileSize
private long fileSize(FileMetaData md)
{    long size = 0;    for (RowGroup rg : md.getRow_groups()) {        size += rg.total_byte_size;    }    return size;}
4b08862a13161a565d86e6f9bcb49f2086bedbe5401f29f5b878d0941f2d4164
testFilterMetaData
public void testFilterMetaData()
{    verifyMD(filter(metadata(50, 50, 50), 0, 50), 0);    verifyMD(filter(metadata(50, 50, 50), 50, 100), 50);    verifyMD(filter(metadata(50, 50, 50), 100, 150), 100);        verifyMD(filter(metadata(50, 50, 50), 25, 75), 0);        verifyMD(filter(metadata(50, 50, 50), 26, 75));        verifyMD(filter(metadata(50, 50, 50), 26, 76), 50);    verifyAllFilters(metadata(50, 50, 50), 10);    verifyAllFilters(metadata(50, 50, 50), 51);        verifyAllFilters(metadata(50, 50, 50), 25);    verifyAllFilters(metadata(50, 50, 50), 24);    verifyAllFilters(metadata(50, 50, 50), 26);    verifyAllFilters(metadata(50, 50, 50), 110);    verifyAllFilters(metadata(10, 50, 500), 110);    verifyAllFilters(metadata(10, 50, 500), 10);    verifyAllFilters(metadata(10, 50, 500), 600);    verifyAllFilters(metadata(11, 9, 10), 10);    verifyAllFilters(metadata(11, 9, 10), 9);    verifyAllFilters(metadata(11, 9, 10), 8);}
70c0764e47aab4b3df5f10d34b26fe30260d1daa74ad62e21d5f86a3b29b77a6
testFindRowGroups
public void testFindRowGroups()
{    verifyMD(find(metadata(50, 50, 50), 0), 0);    verifyMD(find(metadata(50, 50, 50), 50), 50);    verifyMD(find(metadata(50, 50, 50), 100), 100);    verifyMD(find(metadata(50, 50, 50), 0L, 50L), 0, 50);    verifyMD(find(metadata(50, 50, 50), 0L, 50L, 100L), 0, 50, 100);    verifyMD(find(metadata(50, 50, 50), 50L, 100L), 50, 100);        verifyMD(find(metadata(50, 50, 50), 10));}
8a187104168b2381857fecfab8d8caef2d0121e7edf861cf114e6592eece319d
randomTestFilterMetaData
public void randomTestFilterMetaData()
{            Random random = new Random(42);    for (int j = 0; j < 100; j++) {        long[] rgs = new long[random.nextInt(50)];        for (int i = 0; i < rgs.length; i++) {                        rgs[i] = random.nextInt(10000) + 1;        }                int splitSize = random.nextInt(10000) + 1;        try {            verifyAllFilters(metadata(rgs), splitSize);        } catch (AssertionError e) {            throw (AssertionError) new AssertionError("fail verifyAllFilters(metadata(" + Arrays.toString(rgs) + "), " + splitSize + ")").initCause(e);        }    }}
0889f91b97c81f4355d264a7724b1b905b5628c9696ac0fe2c643b148a2074bb
testNullFieldMetadataDebugLogging
public void testNullFieldMetadataDebugLogging()
{    MessageType schema = parseMessageType("message test { optional binary some_null_field; }");    org.apache.parquet.hadoop.metadata.FileMetaData fileMetaData = new org.apache.parquet.hadoop.metadata.FileMetaData(schema, new HashMap<String, String>(), null);    List<BlockMetaData> blockMetaDataList = new ArrayList<BlockMetaData>();    BlockMetaData blockMetaData = new BlockMetaData();    blockMetaData.addColumn(createColumnChunkMetaData());    blockMetaDataList.add(blockMetaData);    ParquetMetadata metadata = new ParquetMetadata(fileMetaData, blockMetaDataList);    ParquetMetadata.toJSON(metadata);}
be1e44391cad726f42ecfe67d975c6030b8d81e8a5ec61fc3d1febfd8a6875f7
testMetadataToJson
public void testMetadataToJson()
{    ParquetMetadata metadata = new ParquetMetadata(null, null);    assertEquals("{\"fileMetaData\":null,\"blocks\":null}", ParquetMetadata.toJSON(metadata));    assertEquals("{\n" + "  \"fileMetaData\" : null,\n" + "  \"blocks\" : null\n" + "}", ParquetMetadata.toPrettyJSON(metadata));}
29ef738af0b933f5103a6c2a5d4270a378c5741337fd32090a092a63b7f0fc5f
createColumnChunkMetaData
private ColumnChunkMetaData createColumnChunkMetaData()
{    Set<org.apache.parquet.column.Encoding> e = new HashSet<org.apache.parquet.column.Encoding>();    PrimitiveTypeName t = PrimitiveTypeName.BINARY;    ColumnPath p = ColumnPath.get("foo");    CompressionCodecName c = CompressionCodecName.GZIP;    BinaryStatistics s = new BinaryStatistics();    ColumnChunkMetaData md = ColumnChunkMetaData.get(p, t, c, e, s, 0, 0, 0, 0, 0);    return md;}
213947c6241c431574525a5588eca9fe320d24994d47815f9fb4bd2bafcef9db
testEncodingsCache
public void testEncodingsCache()
{    ParquetMetadataConverter parquetMetadataConverter = new ParquetMetadataConverter();    List<org.apache.parquet.format.Encoding> formatEncodingsCopy1 = Arrays.asList(org.apache.parquet.format.Encoding.BIT_PACKED, org.apache.parquet.format.Encoding.RLE_DICTIONARY, org.apache.parquet.format.Encoding.DELTA_LENGTH_BYTE_ARRAY);    List<org.apache.parquet.format.Encoding> formatEncodingsCopy2 = Arrays.asList(org.apache.parquet.format.Encoding.BIT_PACKED, org.apache.parquet.format.Encoding.RLE_DICTIONARY, org.apache.parquet.format.Encoding.DELTA_LENGTH_BYTE_ARRAY);    Set<org.apache.parquet.column.Encoding> expected = new HashSet<org.apache.parquet.column.Encoding>();    expected.add(org.apache.parquet.column.Encoding.BIT_PACKED);    expected.add(org.apache.parquet.column.Encoding.RLE_DICTIONARY);    expected.add(org.apache.parquet.column.Encoding.DELTA_LENGTH_BYTE_ARRAY);    Set<org.apache.parquet.column.Encoding> res1 = parquetMetadataConverter.fromFormatEncodings(formatEncodingsCopy1);    Set<org.apache.parquet.column.Encoding> res2 = parquetMetadataConverter.fromFormatEncodings(formatEncodingsCopy1);    Set<org.apache.parquet.column.Encoding> res3 = parquetMetadataConverter.fromFormatEncodings(formatEncodingsCopy2);        assertEquals(expected, res1);    assertEquals(expected, res2);    assertEquals(expected, res3);        assertSame(res1, res2);    assertSame(res1, res3);        assertEquals("java.util.Collections$UnmodifiableSet", res1.getClass().getName());    assertEquals("java.util.Collections$UnmodifiableSet", res2.getClass().getName());    assertEquals("java.util.Collections$UnmodifiableSet", res3.getClass().getName());}
66256aeb9410b26a5531167316dd885dc2bc8a73ba4462e1de41ff7997f2c126
testBinaryStatsV1
public void testBinaryStatsV1()
{    testBinaryStats(StatsHelper.V1);}
f990ed8cd37dcf0cc5b4d2ee06438b9026d25e7062103747731bbaa9bfe95e8f
testBinaryStatsV2
public void testBinaryStatsV2()
{    testBinaryStats(StatsHelper.V2);}
7fc9022f2d58303dd346646e3247b36e883c5eaa5033acb1511b8117de4c3c7f
testBinaryStats
private void testBinaryStats(StatsHelper helper)
{        BinaryStatistics stats = new BinaryStatistics();    stats.incrementNumNulls(3004);    byte[] min = new byte[904];    byte[] max = new byte[2388];    stats.updateStats(Binary.fromConstantByteArray(min));    stats.updateStats(Binary.fromConstantByteArray(max));    long totalLen = min.length + max.length;    Assert.assertFalse("Should not be smaller than min + max size", stats.isSmallerThan(totalLen));    Assert.assertTrue("Should be smaller than min + max size + 1", stats.isSmallerThan(totalLen + 1));    org.apache.parquet.format.Statistics formatStats = helper.toParquetStatistics(stats);    assertFalse("Min should not be set", formatStats.isSetMin());    assertFalse("Max should not be set", formatStats.isSetMax());    if (helper == StatsHelper.V2) {        Assert.assertArrayEquals("Min_value should match", min, formatStats.getMin_value());        Assert.assertArrayEquals("Max_value should match", max, formatStats.getMax_value());    }    Assert.assertEquals("Num nulls should match", 3004, formatStats.getNull_count());        stats.setMinMaxFromBytes(max, max);    formatStats = helper.toParquetStatistics(stats);    Assert.assertFalse("Min should not be set", formatStats.isSetMin());    Assert.assertFalse("Max should not be set", formatStats.isSetMax());    Assert.assertFalse("Min_value should not be set", formatStats.isSetMin_value());    Assert.assertFalse("Max_value should not be set", formatStats.isSetMax_value());    Assert.assertFalse("Num nulls should not be set", formatStats.isSetNull_count());    Statistics roundTripStats = ParquetMetadataConverter.fromParquetStatisticsInternal(Version.FULL_VERSION, formatStats, new PrimitiveType(Repetition.OPTIONAL, PrimitiveTypeName.BINARY, ""), ParquetMetadataConverter.SortOrder.SIGNED);    Assert.assertTrue(roundTripStats.isEmpty());}
e10c4b7f32a75782953b84d76f46302bae685e392900f59dfd9ae693e7177bd4
testIntegerStatsV1
public void testIntegerStatsV1()
{    testIntegerStats(StatsHelper.V1);}
ddfdfdd5adec9a5ef091ae588579a03adfb35d2272c40f4b8cd0bbf59ce213ac
testIntegerStatsV2
public void testIntegerStatsV2()
{    testIntegerStats(StatsHelper.V2);}
320c4729585ad2ca7b9e2a48b80d13add7e65f0178f5cb2e360a847bc264ad2f
testIntegerStats
private void testIntegerStats(StatsHelper helper)
{        IntStatistics stats = new IntStatistics();    stats.incrementNumNulls(3004);    int min = Integer.MIN_VALUE;    int max = Integer.MAX_VALUE;    stats.updateStats(min);    stats.updateStats(max);    org.apache.parquet.format.Statistics formatStats = helper.toParquetStatistics(stats);    Assert.assertEquals("Min should match", min, BytesUtils.bytesToInt(formatStats.getMin()));    Assert.assertEquals("Max should match", max, BytesUtils.bytesToInt(formatStats.getMax()));    Assert.assertEquals("Num nulls should match", 3004, formatStats.getNull_count());}
3f73e3c8cd7b0ba30f00bbe1a60d3374ba19d991eff21ac7f571d5de92f0b113
testLongStatsV1
public void testLongStatsV1()
{    testLongStats(StatsHelper.V1);}
90ce0c958cc7b16571cd95f0a678aa91655d9e7da8a73a5f4b7f3ef44273c376
testLongStatsV2
public void testLongStatsV2()
{    testLongStats(StatsHelper.V2);}
40663962da3a46e26756a690580a9206017d69dcae3a3eb3aa28b46f7476dd5f
testLongStats
private void testLongStats(StatsHelper helper)
{        LongStatistics stats = new LongStatistics();    stats.incrementNumNulls(3004);    long min = Long.MIN_VALUE;    long max = Long.MAX_VALUE;    stats.updateStats(min);    stats.updateStats(max);    org.apache.parquet.format.Statistics formatStats = helper.toParquetStatistics(stats);    Assert.assertEquals("Min should match", min, BytesUtils.bytesToLong(formatStats.getMin()));    Assert.assertEquals("Max should match", max, BytesUtils.bytesToLong(formatStats.getMax()));    Assert.assertEquals("Num nulls should match", 3004, formatStats.getNull_count());}
0519086f5f4360ac4187852eab71020e7ce1fefc6f39211bd39c374b7ea05a6f
testFloatStatsV1
public void testFloatStatsV1()
{    testFloatStats(StatsHelper.V1);}
fc9c8dd19d7b273029bb28a047f022d6356494c2233dd5dabec9c1db43e08015
testFloatStatsV2
public void testFloatStatsV2()
{    testFloatStats(StatsHelper.V2);}
151d01688b0cff867d1798d8aa255ef78e88ebfcce6fd1839802aef68472bcc0
testFloatStats
private void testFloatStats(StatsHelper helper)
{        FloatStatistics stats = new FloatStatistics();    stats.incrementNumNulls(3004);    float min = Float.MIN_VALUE;    float max = Float.MAX_VALUE;    stats.updateStats(min);    stats.updateStats(max);    org.apache.parquet.format.Statistics formatStats = helper.toParquetStatistics(stats);    Assert.assertEquals("Min should match", min, Float.intBitsToFloat(BytesUtils.bytesToInt(formatStats.getMin())), 0.000001);    Assert.assertEquals("Max should match", max, Float.intBitsToFloat(BytesUtils.bytesToInt(formatStats.getMax())), 0.000001);    Assert.assertEquals("Num nulls should match", 3004, formatStats.getNull_count());}
6dfc315b6f8b3da996f110a5b5875fff5302f74b6b7db0dec7d8c371cbaad7c6
testDoubleStatsV1
public void testDoubleStatsV1()
{    testDoubleStats(StatsHelper.V1);}
636fc4c2e07a4dbbc51b454eadfaaa187d1d5d4fb359503ce49252121f439006
testDoubleStatsV2
public void testDoubleStatsV2()
{    testDoubleStats(StatsHelper.V2);}
150e6441a7948441625fc542d063d6f90873424969ed0ee5e005499bb4e3eb21
testDoubleStats
private void testDoubleStats(StatsHelper helper)
{        DoubleStatistics stats = new DoubleStatistics();    stats.incrementNumNulls(3004);    double min = Double.MIN_VALUE;    double max = Double.MAX_VALUE;    stats.updateStats(min);    stats.updateStats(max);    org.apache.parquet.format.Statistics formatStats = helper.toParquetStatistics(stats);    Assert.assertEquals("Min should match", min, Double.longBitsToDouble(BytesUtils.bytesToLong(formatStats.getMin())), 0.000001);    Assert.assertEquals("Max should match", max, Double.longBitsToDouble(BytesUtils.bytesToLong(formatStats.getMax())), 0.000001);    Assert.assertEquals("Num nulls should match", 3004, formatStats.getNull_count());}
49fe0eeb616f73399f4010f87e8d5ba93e574818e0659f1288917ad4b4ded18c
testBooleanStatsV1
public void testBooleanStatsV1()
{    testBooleanStats(StatsHelper.V1);}
2131cde4badce3cdbafcd13dc9781930712d27f4405e3144cf54934d81828d65
testBooleanStatsV2
public void testBooleanStatsV2()
{    testBooleanStats(StatsHelper.V2);}
6ced472eba3b63299fb11363642590ec37903a360c9ed384cc8492ebcf101ad2
testBooleanStats
private void testBooleanStats(StatsHelper helper)
{        BooleanStatistics stats = new BooleanStatistics();    stats.incrementNumNulls(3004);    boolean min = Boolean.FALSE;    boolean max = Boolean.TRUE;    stats.updateStats(min);    stats.updateStats(max);    org.apache.parquet.format.Statistics formatStats = helper.toParquetStatistics(stats);    Assert.assertEquals("Min should match", min, BytesUtils.bytesToBool(formatStats.getMin()));    Assert.assertEquals("Max should match", max, BytesUtils.bytesToBool(formatStats.getMax()));    Assert.assertEquals("Num nulls should match", 3004, formatStats.getNull_count());}
a315983a7a1927eebb04246294d054ee9b41b50f9ccd0efd20253fc247e59c28
testIgnoreStatsWithSignedSortOrder
public void testIgnoreStatsWithSignedSortOrder()
{    ParquetMetadataConverter converter = new ParquetMetadataConverter();    BinaryStatistics stats = new BinaryStatistics();    stats.incrementNumNulls();    stats.updateStats(Binary.fromString("A"));    stats.incrementNumNulls();    stats.updateStats(Binary.fromString("z"));    stats.incrementNumNulls();    PrimitiveType binaryType = Types.required(PrimitiveTypeName.BINARY).as(OriginalType.UTF8).named("b");    Statistics convertedStats = converter.fromParquetStatistics(Version.FULL_VERSION, StatsHelper.V1.toParquetStatistics(stats), binaryType);    Assert.assertFalse("Stats should not include min/max: " + convertedStats, convertedStats.hasNonNullValue());    Assert.assertTrue("Stats should have null count: " + convertedStats, convertedStats.isNumNullsSet());    Assert.assertEquals("Stats should have 3 nulls: " + convertedStats, 3L, convertedStats.getNumNulls());}
e766abd9decb143ffd35faa605007bf1b2c8355f01eb47c0b513ad7c6e1feb3a
testStillUseStatsWithSignedSortOrderIfSingleValueV1
public void testStillUseStatsWithSignedSortOrderIfSingleValueV1()
{    testStillUseStatsWithSignedSortOrderIfSingleValue(StatsHelper.V1);}
1183b9710038f63de49fd355e5cebff58c760fdba5bf889ef2a3059cfdc62cd9
testStillUseStatsWithSignedSortOrderIfSingleValueV2
public void testStillUseStatsWithSignedSortOrderIfSingleValueV2()
{    testStillUseStatsWithSignedSortOrderIfSingleValue(StatsHelper.V2);}
88961e5a889211c482216de6c12019003778c1391eb302220d61582e3666ea22
testStillUseStatsWithSignedSortOrderIfSingleValue
private void testStillUseStatsWithSignedSortOrderIfSingleValue(StatsHelper helper)
{    ParquetMetadataConverter converter = new ParquetMetadataConverter();    BinaryStatistics stats = new BinaryStatistics();    stats.incrementNumNulls();    stats.updateStats(Binary.fromString("A"));    stats.incrementNumNulls();    stats.updateStats(Binary.fromString("A"));    stats.incrementNumNulls();    PrimitiveType binaryType = Types.required(PrimitiveTypeName.BINARY).as(OriginalType.UTF8).named("b");    Statistics convertedStats = converter.fromParquetStatistics(Version.FULL_VERSION, ParquetMetadataConverter.toParquetStatistics(stats), binaryType);    Assert.assertFalse("Stats should not be empty: " + convertedStats, convertedStats.isEmpty());    Assert.assertArrayEquals("min == max: " + convertedStats, convertedStats.getMaxBytes(), convertedStats.getMinBytes());}
c7f921003d7a26e7a3a2a0cb7ca5e793a59ecd44efaa1f1d20794a42281c9079
testUseStatsWithSignedSortOrderV1
public void testUseStatsWithSignedSortOrderV1()
{    testUseStatsWithSignedSortOrder(StatsHelper.V1);}
aced7517d35d691f88276221fd72a344626cb6a1710bff172014cb9e139c921a
testUseStatsWithSignedSortOrderV2
public void testUseStatsWithSignedSortOrderV2()
{    testUseStatsWithSignedSortOrder(StatsHelper.V2);}
4de64ba696314a5314d5eec724109760e8e5694908d323423f200e71c469d17c
testUseStatsWithSignedSortOrder
private void testUseStatsWithSignedSortOrder(StatsHelper helper)
{        Configuration conf = new Configuration();    conf.setBoolean("parquet.strings.signed-min-max.enabled", true);    ParquetMetadataConverter converter = new ParquetMetadataConverter(conf);    BinaryStatistics stats = new BinaryStatistics();    stats.incrementNumNulls();    stats.updateStats(Binary.fromString("A"));    stats.incrementNumNulls();    stats.updateStats(Binary.fromString("z"));    stats.incrementNumNulls();    PrimitiveType binaryType = Types.required(PrimitiveTypeName.BINARY).as(OriginalType.UTF8).named("b");    Statistics convertedStats = converter.fromParquetStatistics(Version.FULL_VERSION, helper.toParquetStatistics(stats), binaryType);    Assert.assertFalse("Stats should not be empty", convertedStats.isEmpty());    Assert.assertTrue(convertedStats.isNumNullsSet());    Assert.assertEquals("Should have 3 nulls", 3, convertedStats.getNumNulls());    if (helper == StatsHelper.V1) {        assertFalse("Min-max should be null for V1 stats", convertedStats.hasNonNullValue());    } else {        Assert.assertEquals("Should have correct min (unsigned sort)", Binary.fromString("A"), convertedStats.genericGetMin());        Assert.assertEquals("Should have correct max (unsigned sort)", Binary.fromString("z"), convertedStats.genericGetMax());    }}
bf2efa3f165fd93dc3efe911baece451085a6e14ed6112a690114b1db0800ca2
testMissingValuesFromStats
public void testMissingValuesFromStats()
{    ParquetMetadataConverter converter = new ParquetMetadataConverter();    PrimitiveType type = Types.required(PrimitiveTypeName.INT32).named("test_int32");    org.apache.parquet.format.Statistics formatStats = new org.apache.parquet.format.Statistics();    Statistics<?> stats = converter.fromParquetStatistics(Version.FULL_VERSION, formatStats, type);    assertFalse(stats.isNumNullsSet());    assertFalse(stats.hasNonNullValue());    assertTrue(stats.isEmpty());    assertEquals(-1, stats.getNumNulls());    formatStats.clear();    formatStats.setMin(BytesUtils.intToBytes(-100));    formatStats.setMax(BytesUtils.intToBytes(100));    stats = converter.fromParquetStatistics(Version.FULL_VERSION, formatStats, type);    assertFalse(stats.isNumNullsSet());    assertTrue(stats.hasNonNullValue());    assertFalse(stats.isEmpty());    assertEquals(-1, stats.getNumNulls());    assertEquals(-100, stats.genericGetMin());    assertEquals(100, stats.genericGetMax());    formatStats.clear();    formatStats.setNull_count(2000);    stats = converter.fromParquetStatistics(Version.FULL_VERSION, formatStats, type);    assertTrue(stats.isNumNullsSet());    assertFalse(stats.hasNonNullValue());    assertFalse(stats.isEmpty());    assertEquals(2000, stats.getNumNulls());}
a3369ee46b045ed5d92e278c6404b87d6c27f8acefb8e9b17442d485471034f0
testSkippedV2Stats
public void testSkippedV2Stats()
{    testSkippedV2Stats(Types.optional(PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY).length(12).as(OriginalType.INTERVAL).named(""), new BigInteger("12345678"), new BigInteger("12345679"));    testSkippedV2Stats(Types.optional(PrimitiveTypeName.INT96).named(""), new BigInteger("-75687987"), new BigInteger("45367657"));}
4a4e9555c20f8e3d235ee60ffd06c79d2f4e6fd0643a07782c743c5cf7a8f072
testSkippedV2Stats
private void testSkippedV2Stats(PrimitiveType type, Object min, Object max)
{    Statistics<?> stats = createStats(type, min, max);    org.apache.parquet.format.Statistics statistics = ParquetMetadataConverter.toParquetStatistics(stats);    assertFalse(statistics.isSetMin());    assertFalse(statistics.isSetMax());    assertFalse(statistics.isSetMin_value());    assertFalse(statistics.isSetMax_value());}
dda8547caf3696234fc3927ec9c89e90c86688df6772fff5181426a340793808
testV2OnlyStats
public void testV2OnlyStats()
{    testV2OnlyStats(Types.optional(PrimitiveTypeName.INT32).as(OriginalType.UINT_8).named(""), 0x7F, 0x80);    testV2OnlyStats(Types.optional(PrimitiveTypeName.INT32).as(OriginalType.UINT_16).named(""), 0x7FFF, 0x8000);    testV2OnlyStats(Types.optional(PrimitiveTypeName.INT32).as(OriginalType.UINT_32).named(""), 0x7FFFFFFF, 0x80000000);    testV2OnlyStats(Types.optional(PrimitiveTypeName.INT64).as(OriginalType.UINT_64).named(""), 0x7FFFFFFFFFFFFFFFL, 0x8000000000000000L);    testV2OnlyStats(Types.optional(PrimitiveTypeName.BINARY).as(OriginalType.DECIMAL).precision(6).named(""), new BigInteger("-765875"), new BigInteger("876856"));    testV2OnlyStats(Types.optional(PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY).length(14).as(OriginalType.DECIMAL).precision(7).named(""), new BigInteger("-6769643"), new BigInteger("9864675"));}
628f8667454880adc836ac3eafccfcf724ae3ec5a1a240629e78bc88e44e6ea0
testV2OnlyStats
private void testV2OnlyStats(PrimitiveType type, Object min, Object max)
{    Statistics<?> stats = createStats(type, min, max);    org.apache.parquet.format.Statistics statistics = ParquetMetadataConverter.toParquetStatistics(stats);    assertFalse(statistics.isSetMin());    assertFalse(statistics.isSetMax());    assertEquals(ByteBuffer.wrap(stats.getMinBytes()), statistics.min_value);    assertEquals(ByteBuffer.wrap(stats.getMaxBytes()), statistics.max_value);}
c2037be90a126415d4bc1d98f2d646c40031cdea23c7e00224704a629a61eaa8
testV2StatsEqualMinMax
public void testV2StatsEqualMinMax()
{    testV2StatsEqualMinMax(Types.optional(PrimitiveTypeName.INT32).as(OriginalType.UINT_8).named(""), 93, 93);    testV2StatsEqualMinMax(Types.optional(PrimitiveTypeName.INT32).as(OriginalType.UINT_16).named(""), -5892, -5892);    testV2StatsEqualMinMax(Types.optional(PrimitiveTypeName.INT32).as(OriginalType.UINT_32).named(""), 234998934, 234998934);    testV2StatsEqualMinMax(Types.optional(PrimitiveTypeName.INT64).as(OriginalType.UINT_64).named(""), -2389943895984985L, -2389943895984985L);    testV2StatsEqualMinMax(Types.optional(PrimitiveTypeName.BINARY).as(OriginalType.DECIMAL).precision(6).named(""), new BigInteger("823749"), new BigInteger("823749"));    testV2StatsEqualMinMax(Types.optional(PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY).length(14).as(OriginalType.DECIMAL).precision(7).named(""), new BigInteger("-8752832"), new BigInteger("-8752832"));    testV2StatsEqualMinMax(Types.optional(PrimitiveTypeName.INT96).named(""), new BigInteger("81032984"), new BigInteger("81032984"));}
4e02dcc4581858c7edd740561717a39c72128a7b88d7ec220c3f366f1a6cd226
testV2StatsEqualMinMax
private void testV2StatsEqualMinMax(PrimitiveType type, Object min, Object max)
{    Statistics<?> stats = createStats(type, min, max);    org.apache.parquet.format.Statistics statistics = ParquetMetadataConverter.toParquetStatistics(stats);    assertEquals(ByteBuffer.wrap(stats.getMinBytes()), statistics.min);    assertEquals(ByteBuffer.wrap(stats.getMaxBytes()), statistics.max);    assertEquals(ByteBuffer.wrap(stats.getMinBytes()), statistics.min_value);    assertEquals(ByteBuffer.wrap(stats.getMaxBytes()), statistics.max_value);}
9de29b749ee454dd0a5d4af79e076964b57210962613c6d242f3e1ad9060b458
createStats
private static Statistics<?> createStats(PrimitiveType type, T min, T max)
{    Class<?> c = min.getClass();    if (c == Integer.class) {        return createStatsTyped(type, (Integer) min, (Integer) max);    } else if (c == Long.class) {        return createStatsTyped(type, (Long) min, (Long) max);    } else if (c == BigInteger.class) {        return createStatsTyped(type, (BigInteger) min, (BigInteger) max);    }    fail("Not implemented");    return null;}
1f8cffa0d406fdd9a9bd29091ab3fea3fe27bdb937ff241f15e6396e0a5b95ef
createStatsTyped
private static Statistics<?> createStatsTyped(PrimitiveType type, int min, int max)
{    Statistics<?> stats = Statistics.createStats(type);    stats.updateStats(max);    stats.updateStats(min);    assertEquals(min, stats.genericGetMin());    assertEquals(max, stats.genericGetMax());    return stats;}
8184b7ed228fc9e2a81f21184076d5a7a9fd1daee712fc179b0c9696cd8b0faf
createStatsTyped
private static Statistics<?> createStatsTyped(PrimitiveType type, long min, long max)
{    Statistics<?> stats = Statistics.createStats(type);    stats.updateStats(max);    stats.updateStats(min);    assertEquals(min, stats.genericGetMin());    assertEquals(max, stats.genericGetMax());    return stats;}
96b0dff023532ba53d297621939f769ab5dc69f7ace1fb18e7e27ea0cf89e5d4
createStatsTyped
private static Statistics<?> createStatsTyped(PrimitiveType type, BigInteger min, BigInteger max)
{    Statistics<?> stats = Statistics.createStats(type);    Binary minBinary = Binary.fromConstantByteArray(min.toByteArray());    Binary maxBinary = Binary.fromConstantByteArray(max.toByteArray());    stats.updateStats(maxBinary);    stats.updateStats(minBinary);    assertEquals(minBinary, stats.genericGetMin());    assertEquals(maxBinary, stats.genericGetMax());    return stats;}
d35b6870dd1b33569dc29fc1b826033fdd8aff39338c589017e50ecc0ae0d3f1
toParquetStatistics
public org.apache.parquet.format.Statistics toParquetStatistics(Statistics<?> stats)
{    org.apache.parquet.format.Statistics statistics = ParquetMetadataConverter.toParquetStatistics(stats);    statistics.unsetMin_value();    statistics.unsetMax_value();    return statistics;}
d35b6870dd1b33569dc29fc1b826033fdd8aff39338c589017e50ecc0ae0d3f1
toParquetStatistics
public org.apache.parquet.format.Statistics toParquetStatistics(Statistics<?> stats)
{    return ParquetMetadataConverter.toParquetStatistics(stats);}
d19ac4186ed1a45835dddd3ffcd71e61e76e2aa93a60c9bc97f55a79e7dd4f53
testColumnOrders
public void testColumnOrders() throws IOException
{    MessageType schema = parseMessageType("message test {" +     "  optional binary binary_col;" + "  optional group map_col (MAP) {" + "    repeated group map (MAP_KEY_VALUE) {" +     "        required binary key (UTF8);" + "        optional group list_col (LIST) {" + "          repeated group list {" +     "            optional int96 array_element;" + "          }" + "        }" + "    }" + "  }" + "}");    org.apache.parquet.hadoop.metadata.FileMetaData fileMetaData = new org.apache.parquet.hadoop.metadata.FileMetaData(schema, new HashMap<String, String>(), null);    ParquetMetadata metadata = new ParquetMetadata(fileMetaData, new ArrayList<BlockMetaData>());    ParquetMetadataConverter converter = new ParquetMetadataConverter();    FileMetaData formatMetadata = converter.toParquetMetadata(1, metadata);    List<org.apache.parquet.format.ColumnOrder> columnOrders = formatMetadata.getColumn_orders();    assertEquals(3, columnOrders.size());    for (org.apache.parquet.format.ColumnOrder columnOrder : columnOrders) {        assertTrue(columnOrder.isSetTYPE_ORDER());    }            columnOrders.get(1).clear();    MessageType resultSchema = converter.fromParquetMetadata(formatMetadata).getFileMetaData().getSchema();    List<ColumnDescriptor> columns = resultSchema.getColumns();    assertEquals(3, columns.size());    assertEquals(ColumnOrder.typeDefined(), columns.get(0).getPrimitiveType().columnOrder());    assertEquals(ColumnOrder.undefined(), columns.get(1).getPrimitiveType().columnOrder());    assertEquals(ColumnOrder.undefined(), columns.get(2).getPrimitiveType().columnOrder());}
7f2241364c5c2205aa34f553c216676ff094b5c898799aac62cdfdfced1c290a
testOffsetIndexConversion
public void testOffsetIndexConversion()
{    OffsetIndexBuilder builder = OffsetIndexBuilder.getBuilder();    builder.add(1000, 10000, 0);    builder.add(22000, 12000, 100);    OffsetIndex offsetIndex = ParquetMetadataConverter.fromParquetOffsetIndex(ParquetMetadataConverter.toParquetOffsetIndex(builder.build(100000)));    assertEquals(2, offsetIndex.getPageCount());    assertEquals(101000, offsetIndex.getOffset(0));    assertEquals(10000, offsetIndex.getCompressedPageSize(0));    assertEquals(0, offsetIndex.getFirstRowIndex(0));    assertEquals(122000, offsetIndex.getOffset(1));    assertEquals(12000, offsetIndex.getCompressedPageSize(1));    assertEquals(100, offsetIndex.getFirstRowIndex(1));}
16266a028f48e659029733dcc378ecd6c6472105f923eb20a026bf2c5d84267f
testColumnIndexConversion
public void testColumnIndexConversion()
{    PrimitiveType type = Types.required(PrimitiveTypeName.INT64).named("test_int64");    ColumnIndexBuilder builder = ColumnIndexBuilder.getBuilder(type, Integer.MAX_VALUE);    Statistics<?> stats = Statistics.createStats(type);    stats.incrementNumNulls(16);    stats.updateStats(-100l);    stats.updateStats(100l);    builder.add(stats);    stats = Statistics.createStats(type);    stats.incrementNumNulls(111);    builder.add(stats);    stats = Statistics.createStats(type);    stats.updateStats(200l);    stats.updateStats(500l);    builder.add(stats);    org.apache.parquet.format.ColumnIndex parquetColumnIndex = ParquetMetadataConverter.toParquetColumnIndex(type, builder.build());    ColumnIndex columnIndex = ParquetMetadataConverter.fromParquetColumnIndex(type, parquetColumnIndex);    assertEquals(BoundaryOrder.ASCENDING, columnIndex.getBoundaryOrder());    assertTrue(Arrays.asList(false, true, false).equals(columnIndex.getNullPages()));    assertTrue(Arrays.asList(16l, 111l, 0l).equals(columnIndex.getNullCounts()));    assertTrue(Arrays.asList(ByteBuffer.wrap(BytesUtils.longToBytes(-100l)), ByteBuffer.allocate(0), ByteBuffer.wrap(BytesUtils.longToBytes(200l))).equals(columnIndex.getMinValues()));    assertTrue(Arrays.asList(ByteBuffer.wrap(BytesUtils.longToBytes(100l)), ByteBuffer.allocate(0), ByteBuffer.wrap(BytesUtils.longToBytes(500l))).equals(columnIndex.getMaxValues()));    assertNull("Should handle null column index", ParquetMetadataConverter.toParquetColumnIndex(Types.required(PrimitiveTypeName.INT32).named("test_int32"), null));    assertNull("Should ignore unsupported types", ParquetMetadataConverter.toParquetColumnIndex(Types.required(PrimitiveTypeName.INT96).named("test_int96"), columnIndex));    assertNull("Should ignore unsupported types", ParquetMetadataConverter.fromParquetColumnIndex(Types.required(PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY).length(12).as(OriginalType.INTERVAL).named("test_interval"), parquetColumnIndex));}
fa8c0857b80646d1b93d3c599967d4b46af09ac64746394f0d313b155a01b159
testReadingCodecs
public void testReadingCodecs() throws IOException
{    shouldUseParquetFlagToSetCodec("gzip", CompressionCodecName.GZIP);    shouldUseHadoopFlagToSetCodec(CompressionCodecName.GZIP.getHadoopCompressionCodecClassName(), CompressionCodecName.GZIP);    shouldUseParquetFlagToSetCodec("snappy", CompressionCodecName.SNAPPY);    shouldUseHadoopFlagToSetCodec(CompressionCodecName.SNAPPY.getHadoopCompressionCodecClassName(), CompressionCodecName.SNAPPY);        shouldUseHadoopFlagToSetCodec("unexistedCodec", CompressionCodecName.UNCOMPRESSED);        shouldUseHadoopFlagToSetCodec("org.apache.hadoop.io.compress.DefaultCodec", CompressionCodecName.UNCOMPRESSED);}
36704e21db3df95107f179a0190fac6d6c7543d86c374d1ef887938ba598fb38
shouldUseParquetFlagToSetCodec
public void shouldUseParquetFlagToSetCodec(String codecNameStr, CompressionCodecName expectedCodec) throws IOException
{        Job job = new Job();    Configuration conf = job.getConfiguration();    conf.set(ParquetOutputFormat.COMPRESSION, codecNameStr);    TaskAttemptContext task = ContextUtil.newTaskAttemptContext(conf, new TaskAttemptID(new TaskID(new JobID("test", 1), false, 1), 1));    Assert.assertEquals(CodecConfig.from(task).getCodec(), expectedCodec);        JobConf jobConf = new JobConf();    jobConf.set(ParquetOutputFormat.COMPRESSION, codecNameStr);    Assert.assertEquals(CodecConfig.from(jobConf).getCodec(), expectedCodec);}
c4e1fa5fd4d71d6f9d6b44ffb7c467a10ccad6f34fc19485c1b79e5d8efdced6
shouldUseHadoopFlagToSetCodec
public void shouldUseHadoopFlagToSetCodec(String codecClassStr, CompressionCodecName expectedCodec) throws IOException
{        Job job = new Job();    Configuration conf = job.getConfiguration();    conf.setBoolean("mapred.output.compress", true);    conf.set("mapred.output.compression.codec", codecClassStr);    TaskAttemptContext task = ContextUtil.newTaskAttemptContext(conf, new TaskAttemptID(new TaskID(new JobID("test", 1), false, 1), 1));    Assert.assertEquals(expectedCodec, CodecConfig.from(task).getCodec());        JobConf jobConf = new JobConf();    jobConf.setBoolean("mapred.output.compress", true);    jobConf.set("mapred.output.compression.codec", codecClassStr);    Assert.assertEquals(CodecConfig.from(jobConf).getCodec(), expectedCodec);}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    conf = new Configuration();    jobConf = new JobConf();    writeSchema = "message example {\n" + "required int32 line;\n" + "required binary content;\n" + "}";    readSchema = "message example {\n" + "required int32 line;\n" + "required binary content;\n" + "}";}
d51a84cdc77eff495c132c84e7ba0e7379b1f2cd65e8e85f4bcbf217af1cccb4
runMapReduceJob
private void runMapReduceJob(CompressionCodecName codec) throws IOException, ClassNotFoundException, InterruptedException
{    final FileSystem fileSystem = parquetPath.getFileSystem(conf);    fileSystem.delete(parquetPath, true);    fileSystem.delete(outputPath, true);    {        writeJob = new Job(conf, "write");        TextInputFormat.addInputPath(writeJob, inputPath);        writeJob.setInputFormatClass(TextInputFormat.class);        writeJob.setNumReduceTasks(0);        ExampleOutputFormat.setCompression(writeJob, codec);        ExampleOutputFormat.setOutputPath(writeJob, parquetPath);        writeJob.setOutputFormatClass(ExampleOutputFormat.class);        writeJob.setMapperClass(ReadMapper.class);        ExampleOutputFormat.setSchema(writeJob, MessageTypeParser.parseMessageType(writeSchema));        writeJob.submit();        waitForJob(writeJob);    }    {        jobConf.set(ReadSupport.PARQUET_READ_SCHEMA, readSchema);        jobConf.set(ParquetInputFormat.READ_SUPPORT_CLASS, GroupReadSupport.class.getCanonicalName());        jobConf.setInputFormat(MyDeprecatedInputFormat.class);        MyDeprecatedInputFormat.setInputPaths(jobConf, parquetPath);        jobConf.setOutputFormat(org.apache.hadoop.mapred.TextOutputFormat.class);        org.apache.hadoop.mapred.TextOutputFormat.setOutputPath(jobConf, outputPath);        jobConf.setMapperClass(DeprecatedWriteMapper.class);        jobConf.setNumReduceTasks(0);        mapRedJob = JobClient.runJob(jobConf);    }}
7ed163f09048baa3fede73807dd668213a4f77852692e5b4dce9973ab4528665
testReadWriteWithCountDeprecated
public void testReadWriteWithCountDeprecated() throws Exception
{    runMapReduceJob(CompressionCodecName.GZIP);    assertTrue(mapRedJob.getCounters().getGroup("parquet").getCounterForName("bytesread").getValue() > 0L);    assertTrue(mapRedJob.getCounters().getGroup("parquet").getCounterForName("bytestotal").getValue() > 0L);    assertTrue(mapRedJob.getCounters().getGroup("parquet").getCounterForName("bytesread").getValue() == mapRedJob.getCounters().getGroup("parquet").getCounterForName("bytestotal").getValue());}
81b008ebaf505e88f8d7ef0603d5e6527af061ec7e949509c33ec80296139d2f
testReadWriteWithoutCounter
public void testReadWriteWithoutCounter() throws Exception
{    jobConf.set("parquet.benchmark.time.read", "false");    jobConf.set("parquet.benchmark.bytes.total", "false");    jobConf.set("parquet.benchmark.bytes.read", "false");    runMapReduceJob(CompressionCodecName.GZIP);    assertEquals(mapRedJob.getCounters().getGroup("parquet").getCounterForName("bytesread").getValue(), 0L);    assertEquals(mapRedJob.getCounters().getGroup("parquet").getCounterForName("bytestotal").getValue(), 0L);    assertEquals(mapRedJob.getCounters().getGroup("parquet").getCounterForName("timeread").getValue(), 0L);}
373f973defa350ae181eeac6a7ce06249e6633c25bdcc3b87ddd2cc29321df47
waitForJob
private void waitForJob(Job job) throws InterruptedException, IOException
{    while (!job.isComplete()) {        System.out.println("waiting for job " + job.getJobName());        sleep(100);    }    System.out.println("status for job " + job.getJobName() + ": " + (job.isSuccessful() ? "SUCCESS" : "FAILURE"));    if (!job.isSuccessful()) {        throw new RuntimeException("job failed " + job.getJobName());    }}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    factory = new SimpleGroupFactory(GroupWriteSupport.getSchema(ContextUtil.getConfiguration(context)));}
364372c8c0a17a2c3987e3f0d31a4140befe124df0e3310d5d0fe71e39f33b0f
map
protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException
{    Group group = factory.newGroup().append("line", (int) key.get()).append("content", value.toString());    context.write(null, group);}
0980a7cfadfe92bf71c5a8b2ee34b95a24755427ed6975fbd9d3117871f69a20
map
public void map(Void aVoid, Container<Group> valueContainer, OutputCollector<LongWritable, Text> longWritableTextOutputCollector, Reporter reporter) throws IOException
{    Group value = valueContainer.get();    longWritableTextOutputCollector.collect(new LongWritable(value.getInteger("line", 0)), new Text(value.getString("content", 0)));}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{}
6c10c68c6d5ba7d937cb8718b8ec5156f1cc27e4cb838345a5365dcaec2b7745
configure
public void configure(JobConf entries)
{}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    conf = new Configuration();    jobConf = new JobConf();    writeSchema = "message example {\n" + "required int32 line;\n" + "required binary content;\n" + "}";}
d51a84cdc77eff495c132c84e7ba0e7379b1f2cd65e8e85f4bcbf217af1cccb4
runMapReduceJob
private void runMapReduceJob(CompressionCodecName codec) throws IOException, ClassNotFoundException, InterruptedException
{    final FileSystem fileSystem = parquetPath.getFileSystem(conf);    fileSystem.delete(parquetPath, true);    fileSystem.delete(outputPath, true);    {        jobConf.setInputFormat(TextInputFormat.class);        TextInputFormat.addInputPath(jobConf, inputPath);        jobConf.setNumReduceTasks(0);        jobConf.setOutputFormat(DeprecatedParquetOutputFormat.class);        DeprecatedParquetOutputFormat.setCompression(jobConf, codec);        DeprecatedParquetOutputFormat.setOutputPath(jobConf, parquetPath);        DeprecatedParquetOutputFormat.setWriteSupportClass(jobConf, GroupWriteSupport.class);        GroupWriteSupport.setSchema(MessageTypeParser.parseMessageType(writeSchema), jobConf);        jobConf.setMapperClass(DeprecatedMapper.class);        mapRedJob = JobClient.runJob(jobConf);    }}
c2c75b5eb5762dda20687d84e7565d4cf3b9de60742e0694a6cffba3f16ea18a
testReadWrite
public void testReadWrite() throws Exception
{    runMapReduceJob(CompressionCodecName.GZIP);    assert (mapRedJob.isSuccessful());}
826e0097aae3ab29fbd42337efb5b1f3fc6505609821bc6b5020f129d1f3f721
configure
public void configure(JobConf job)
{    factory = new SimpleGroupFactory(GroupWriteSupport.getSchema(job));}
b32c5f28882cd8d4f48b6596dc08760d2b4640257a916d1c1ddeed9d6878c890
map
public void map(LongWritable key, Text value, OutputCollector<Void, Group> outputCollector, Reporter reporter) throws IOException
{    Group group = factory.newGroup().append("line", (int) key.get()).append("content", value.toString());    outputCollector.collect(null, group);}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{}
8c6854261f26ce0649154b8e6a2fd26ec99172b57b308355f25dd60857bab1be
testInitWithoutSpecifyingRequestSchema
public void testInitWithoutSpecifyingRequestSchema() throws Exception
{    GroupReadSupport s = new GroupReadSupport();    Configuration configuration = new Configuration();    Map<String, String> keyValueMetaData = new HashMap<String, String>();    MessageType fileSchema = MessageTypeParser.parseMessageType(fullSchemaStr);    ReadSupport.ReadContext context = s.init(configuration, keyValueMetaData, fileSchema);    assertEquals(context.getRequestedSchema(), fileSchema);}
5361f58f82f318e190d7db4baf35acea70294f23702596b1f7e30f6e94aae43b
testInitWithPartialSchema
public void testInitWithPartialSchema()
{    GroupReadSupport s = new GroupReadSupport();    Configuration configuration = new Configuration();    Map<String, String> keyValueMetaData = new HashMap<String, String>();    MessageType fileSchema = MessageTypeParser.parseMessageType(fullSchemaStr);    MessageType partialSchema = MessageTypeParser.parseMessageType(partialSchemaStr);    configuration.set(ReadSupport.PARQUET_READ_SCHEMA, partialSchemaStr);    ReadSupport.ReadContext context = s.init(configuration, keyValueMetaData, fileSchema);    assertEquals(context.getRequestedSchema(), partialSchema);}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    conf = new Configuration();    writeSchema = "message example {\n" + "required int32 line;\n" + "required binary content;\n" + "}";    readSchema = "message example {\n" + "required int32 line;\n" + "required binary content;\n" + "}";    partialSchema = "message example {\n" + "required int32 line;\n" + "}";    readMapperClass = ReadMapper.class;    writeMapperClass = WriteMapper.class;}
31152d423e0a60e22d40aa015c8820bfc90d8884efa80a948aad1400e6ecebab
write
public void write(Group record)
{    super.write(record);    ++count;}
4e9f70421b12aa4eee210b4b5044c8b75e5f4d0eed398dc93aa50b299680497e
finalizeWrite
public org.apache.parquet.hadoop.api.WriteSupport.FinalizedWriteContext finalizeWrite()
{    Map<String, String> extraMetadata = new HashMap<String, String>();    extraMetadata.put("my.count", String.valueOf(count));    return new FinalizedWriteContext(extraMetadata);}
2f61bf478c8f6fb4c9e685ae0c4f7abf2adb09bb251de804b2d202fe37548f36
init
public org.apache.parquet.hadoop.api.ReadSupport.ReadContext init(InitContext context)
{    Set<String> counts = context.getKeyValueMetadata().get("my.count");    assertTrue("counts: " + counts, counts.size() > 0);    return super.init(context);}
84a883962148537987dead55bfff88ccbb8eedf72d9da97cf90109ae3b4f20a4
setup
protected void setup(org.apache.hadoop.mapreduce.Mapper<LongWritable, Text, Void, Group>.Context context) throws java.io.IOException, InterruptedException
{    factory = new SimpleGroupFactory(GroupWriteSupport.getSchema(ContextUtil.getConfiguration(context)));}
dfd9bc805b02fcd41108d4a25caa45c53cdbeb00a90353328b58d0a2725284c8
map
protected void map(LongWritable key, Text value, Mapper<LongWritable, Text, Void, Group>.Context context) throws java.io.IOException, InterruptedException
{    Group group = factory.newGroup().append("line", (int) key.get()).append("content", value.toString());    context.write(null, group);}
bc9cc828e35c38cb0f7ecc894f65be98706fff0757198e3575fc195c04ac568b
map
protected void map(Void key, Group value, Mapper<Void, Group, LongWritable, Text>.Context context) throws IOException, InterruptedException
{    context.write(new LongWritable(value.getInteger("line", 0)), new Text(value.getString("content", 0)));}
bc9cc828e35c38cb0f7ecc894f65be98706fff0757198e3575fc195c04ac568b
map
protected void map(Void key, Group value, Mapper<Void, Group, LongWritable, Text>.Context context) throws IOException, InterruptedException
{    context.write(new LongWritable(value.getInteger("line", 0)), new Text("dummy"));}
d51a84cdc77eff495c132c84e7ba0e7379b1f2cd65e8e85f4bcbf217af1cccb4
runMapReduceJob
private void runMapReduceJob(CompressionCodecName codec) throws IOException, ClassNotFoundException, InterruptedException
{    runMapReduceJob(codec, Collections.<String, String>emptyMap());}
71be70074a64874dbd1a74e3c2d5df11a8e64cd317add09ce0f96ca0e8f820e9
runMapReduceJob
private void runMapReduceJob(CompressionCodecName codec, Map<String, String> extraConf) throws IOException, ClassNotFoundException, InterruptedException
{    Configuration conf = new Configuration(this.conf);    for (Map.Entry<String, String> entry : extraConf.entrySet()) {        conf.set(entry.getKey(), entry.getValue());    }    final FileSystem fileSystem = parquetPath.getFileSystem(conf);    fileSystem.delete(parquetPath, true);    fileSystem.delete(outputPath, true);    {        writeJob = new Job(conf, "write");        TextInputFormat.addInputPath(writeJob, inputPath);        writeJob.setInputFormatClass(TextInputFormat.class);        writeJob.setNumReduceTasks(0);        ParquetOutputFormat.setCompression(writeJob, codec);        ParquetOutputFormat.setOutputPath(writeJob, parquetPath);        writeJob.setOutputFormatClass(ParquetOutputFormat.class);        writeJob.setMapperClass(readMapperClass);        ParquetOutputFormat.setWriteSupportClass(writeJob, MyWriteSupport.class);        GroupWriteSupport.setSchema(MessageTypeParser.parseMessageType(writeSchema), writeJob.getConfiguration());        writeJob.submit();        waitForJob(writeJob);    }    {        conf.set(ReadSupport.PARQUET_READ_SCHEMA, readSchema);        readJob = new Job(conf, "read");        readJob.setInputFormatClass(ParquetInputFormat.class);        ParquetInputFormat.setReadSupportClass(readJob, MyReadSupport.class);        ParquetInputFormat.setInputPaths(readJob, parquetPath);        readJob.setOutputFormatClass(TextOutputFormat.class);        TextOutputFormat.setOutputPath(readJob, outputPath);        readJob.setMapperClass(writeMapperClass);        readJob.setNumReduceTasks(0);        readJob.submit();        waitForJob(readJob);    }}
c56b200a359ab06c2d3d2309718ac6ad2965d96f0eaad792f4c583fdee632e04
testReadWrite
private void testReadWrite(CompressionCodecName codec) throws IOException, ClassNotFoundException, InterruptedException
{    testReadWrite(codec, Collections.<String, String>emptyMap());}
5ab77d33364c6e32d661a91fce38c4c8927ecbe0c37964251532d67d3a42d18c
testReadWrite
private void testReadWrite(CompressionCodecName codec, Map<String, String> conf) throws IOException, ClassNotFoundException, InterruptedException
{    runMapReduceJob(codec, conf);    final BufferedReader in = new BufferedReader(new FileReader(new File(inputPath.toString())));    final BufferedReader out = new BufferedReader(new FileReader(new File(outputPath.toString(), "part-m-00000")));    String lineIn;    String lineOut = null;    int lineNumber = 0;    while ((lineIn = in.readLine()) != null && (lineOut = out.readLine()) != null) {        ++lineNumber;        lineOut = lineOut.substring(lineOut.indexOf("\t") + 1);        assertEquals("line " + lineNumber, lineIn, lineOut);    }    assertNull("line " + lineNumber, out.readLine());    assertNull("line " + lineNumber, lineIn);    in.close();    out.close();}
1caa7788e8c3fbc02d7039375032ef8886d3b606a4b82b94c121798c2ac3a9ec
testReadWrite
public void testReadWrite() throws IOException, ClassNotFoundException, InterruptedException
{        testReadWrite(CompressionCodecName.GZIP);    testReadWrite(CompressionCodecName.UNCOMPRESSED);    testReadWrite(CompressionCodecName.SNAPPY);}
75abda64a52a9c37f48811f5276e5bc07a2a57a11444ceae113bf3885fda8d58
testReadWriteTaskSideMD
public void testReadWriteTaskSideMD() throws IOException, ClassNotFoundException, InterruptedException
{    testReadWrite(CompressionCodecName.UNCOMPRESSED, new HashMap<String, String>() {        {            put("parquet.task.side.metadata", "true");        }    });}
dcf45dae08748b10334a9f1bc5c508eee13cca64b6e07ba9afd83212b30de03b
testReadWriteTaskSideMDAggressiveFilter
public void testReadWriteTaskSideMDAggressiveFilter() throws IOException, ClassNotFoundException, InterruptedException
{    Configuration conf = new Configuration();        ParquetInputFormat.setFilterPredicate(conf, FilterApi.eq(FilterApi.intColumn("line"), -1000));    final String fpString = conf.get(ParquetInputFormat.FILTER_PREDICATE);    runMapReduceJob(CompressionCodecName.UNCOMPRESSED, new HashMap<String, String>() {        {            put("parquet.task.side.metadata", "true");            put(ParquetInputFormat.FILTER_PREDICATE, fpString);        }    });    File file = new File(outputPath.toString(), "part-m-00000");    List<String> lines = Files.readAllLines(file.toPath(), StandardCharsets.UTF_8);    assertTrue(lines.isEmpty());}
54e9b53b0af2dab849b1968191ab8089f0c0d914b20c05e3f317a4e81eeb7ad0
testReadWriteFilter
public void testReadWriteFilter() throws IOException, ClassNotFoundException, InterruptedException
{    Configuration conf = new Configuration();            ParquetInputFormat.setFilterPredicate(conf, FilterApi.lt(FilterApi.intColumn("line"), 500));    final String fpString = conf.get(ParquetInputFormat.FILTER_PREDICATE);    runMapReduceJob(CompressionCodecName.UNCOMPRESSED, new HashMap<String, String>() {        {            put("parquet.task.side.metadata", "true");            put(ParquetInputFormat.FILTER_PREDICATE, fpString);        }    });    File file = new File(inputPath.toString());    List<String> expected = Files.readAllLines(file.toPath(), StandardCharsets.UTF_8);        int size = 0;    Iterator<String> iter = expected.iterator();    while (iter.hasNext()) {        String next = iter.next();        if (size < 500) {            size += next.length();            continue;        }        iter.remove();    }        File file2 = new File(outputPath.toString(), "part-m-00000");    List<String> found = Files.readAllLines(file2.toPath(), StandardCharsets.UTF_8);    StringBuilder sbFound = new StringBuilder();    for (String line : found) {        sbFound.append(line.split("\t", -1)[1]);        sbFound.append("\n");    }    sbFound.deleteCharAt(sbFound.length() - 1);    assertEquals(Strings.join(expected, "\n"), sbFound.toString());}
13d2cf1d3e5b307343f7ca76a2c5299e25fd4739172332fafb37a67e27d08553
testProjection
public void testProjection() throws Exception
{    readSchema = partialSchema;    writeMapperClass = PartialWriteMapper.class;    runMapReduceJob(CompressionCodecName.GZIP);}
7ccacc5965fda091d56636f655e5b2c23fb8d0b509f38c4866a622d36266c0aa
value
private static long value(Job job, String groupName, String name) throws Exception
{        Method getGroup = org.apache.hadoop.mapreduce.Counters.class.getMethod("getGroup", String.class);        Method findCounter = org.apache.hadoop.mapreduce.CounterGroup.class.getMethod("findCounter", String.class);        Method getValue = org.apache.hadoop.mapreduce.Counter.class.getMethod("getValue");    CounterGroup group = (CounterGroup) getGroup.invoke(job.getCounters(), groupName);    Counter counter = (Counter) findCounter.invoke(group, name);    return (Long) getValue.invoke(counter);}
d818a239da62e3ea645e0c349d231b4a48493e636f25c91110c677bae5e47beb
testReadWriteWithCounter
public void testReadWriteWithCounter() throws Exception
{    runMapReduceJob(CompressionCodecName.GZIP);    assertTrue(value(readJob, "parquet", "bytesread") > 0L);    assertTrue(value(readJob, "parquet", "bytestotal") > 0L);    assertTrue(value(readJob, "parquet", "bytesread") == value(readJob, "parquet", "bytestotal"));}
81b008ebaf505e88f8d7ef0603d5e6527af061ec7e949509c33ec80296139d2f
testReadWriteWithoutCounter
public void testReadWriteWithoutCounter() throws Exception
{    conf.set("parquet.benchmark.time.read", "false");    conf.set("parquet.benchmark.bytes.total", "false");    conf.set("parquet.benchmark.bytes.read", "false");    runMapReduceJob(CompressionCodecName.GZIP);    assertTrue(value(readJob, "parquet", "bytesread") == 0L);    assertTrue(value(readJob, "parquet", "bytestotal") == 0L);    assertTrue(value(readJob, "parquet", "timeread") == 0L);}
373f973defa350ae181eeac6a7ce06249e6633c25bdcc3b87ddd2cc29321df47
waitForJob
private void waitForJob(Job job) throws InterruptedException, IOException
{    while (!job.isComplete()) {        LOG.debug("waiting for job {}", job.getJobName());        sleep(100);    }    LOG.info("status for job {}: {}", job.getJobName(), (job.isSuccessful() ? "SUCCESS" : "FAILURE"));    if (!job.isSuccessful()) {        throw new RuntimeException("job failed " + job.getJobName());    }}
4f9d58f2a2e4fe32d7ebbb4e878e9142be83f75f5aec348bbb50e8bac679595b
testConversionBig
public void testConversionBig()
{    long big = (long) Integer.MAX_VALUE + 1;    ColumnChunkMetaData md = newMD(big);    assertTrue(md instanceof IntColumnChunkMetaData);    assertEquals(big, md.getFirstDataPageOffset());}
c558a6ce76424c8ea84d5b3a976b13e2538ab7c0a5d96284e874fd7a4ae1380c
testConversionSmall
public void testConversionSmall()
{    long small = 1;    ColumnChunkMetaData md = newMD(small);    assertTrue(md instanceof IntColumnChunkMetaData);    assertEquals(small, md.getFirstDataPageOffset());}
f169a68fa24d8c6daffa0ed42726be22047727e9337a210fe1b1bee397d006c8
testConversionVeryBig
public void testConversionVeryBig()
{    long veryBig = (long) Integer.MAX_VALUE * 3;    ColumnChunkMetaData md = newMD(veryBig);    assertTrue(md instanceof LongColumnChunkMetaData);    assertEquals(veryBig, md.getFirstDataPageOffset());}
ad8c1ff573e9aeb844b43683aef2a8165ad82f6cd56f9f213f7f670555d66b6a
testConversionNeg
public void testConversionNeg()
{    long neg = -1;    ColumnChunkMetaData md = newMD(neg);    assertTrue(md instanceof LongColumnChunkMetaData);    assertEquals(neg, md.getFirstDataPageOffset());}
71524a8ef12664a81071beee2281a58890e44d867f7b85365dc2edcfcfcbefbc
newMD
private ColumnChunkMetaData newMD(long big)
{    Set<Encoding> e = new HashSet<Encoding>();    PrimitiveTypeName t = BINARY;    ColumnPath p = ColumnPath.get("foo");    CompressionCodecName c = CompressionCodecName.GZIP;    BinaryStatistics s = new BinaryStatistics();    ColumnChunkMetaData md = ColumnChunkMetaData.get(p, t, c, e, s, big, 0, 0, 0, 0);    return md;}
c3611c4e1b161706110837b58d49440b96fea02eecdfd890fb1abe3ea51e86b9
out
 PositionOutputStream out()
{    return out;}
7c8841f64c2a7b7b7e43c5621867414cbae427530b315264a2343984382ef974
create
public PositionOutputStream create(long blockSizeHint) throws IOException
{    return out = file.create(blockSizeHint);}
f9968af1ba1aff17d3c01eb4a48ed29994cc60e3cbcd79ba698a109030c6a800
createOrOverwrite
public PositionOutputStream createOrOverwrite(long blockSizeHint) throws IOException
{    return out = file.createOrOverwrite(blockSizeHint);}
25e7ad709bee723c87fc07351f3d9f072baaff241104b7d2663fe4d7edbe7ff5
supportsBlockSize
public boolean supportsBlockSize()
{    return file.supportsBlockSize();}
fdebbca15f0d2b8bcb26e93cdc926ee87ad94cd1c7f686e4202d0942b709884f
defaultBlockSize
public long defaultBlockSize()
{    return file.defaultBlockSize();}
8fd98e96bb17d9363593f9d3bebac1f3cba13fc781c53c9caf661c7569784c1a
initConfiguration
public void initConfiguration()
{    this.conf = new Configuration();}
ced3637227837bc8935023b279f6d11e541ba2dd6bbaff26ba3afa81b2fd1240
test
public void test() throws Exception
{    Path file = new Path("target/test/TestColumnChunkPageWriteStore/test.parquet");    Path root = file.getParent();    FileSystem fs = file.getFileSystem(conf);    if (fs.exists(root)) {        fs.delete(root, true);    }    fs.mkdirs(root);    MessageType schema = MessageTypeParser.parseMessageType("message test { repeated binary bar; }");    ColumnDescriptor col = schema.getColumns().get(0);    Encoding dataEncoding = PLAIN;    int valueCount = 10;    int d = 1;    int r = 2;    int v = 3;    BytesInput definitionLevels = BytesInput.fromInt(d);    BytesInput repetitionLevels = BytesInput.fromInt(r);    Statistics<?> statistics = Statistics.getBuilderForReading(Types.required(PrimitiveTypeName.BINARY).named("test_binary")).build();    BytesInput data = BytesInput.fromInt(v);    int rowCount = 5;    int nullCount = 1;    statistics.incrementNumNulls(nullCount);    statistics.setMinMaxFromBytes(new byte[] { 0, 1, 2 }, new byte[] { 0, 1, 2, 3 });    long pageOffset;    long pageSize;    {        OutputFileForTesting outputFile = new OutputFileForTesting(file, conf);        ParquetFileWriter writer = new ParquetFileWriter(outputFile, schema, Mode.CREATE, ParquetWriter.DEFAULT_BLOCK_SIZE, ParquetWriter.MAX_PADDING_SIZE_DEFAULT);        writer.start();        writer.startBlock(rowCount);        pageOffset = outputFile.out().getPos();        {            ColumnChunkPageWriteStore store = new ColumnChunkPageWriteStore(compressor(GZIP), schema, new HeapByteBufferAllocator(), Integer.MAX_VALUE);            PageWriter pageWriter = store.getPageWriter(col);            pageWriter.writePageV2(rowCount, nullCount, valueCount, repetitionLevels, definitionLevels, dataEncoding, data, statistics);            store.flushToFileWriter(writer);            pageSize = outputFile.out().getPos() - pageOffset;        }        writer.endBlock();        writer.end(new HashMap<String, String>());    }    {        ParquetMetadata footer = ParquetFileReader.readFooter(conf, file, NO_FILTER);        ParquetFileReader reader = new ParquetFileReader(conf, footer.getFileMetaData(), file, footer.getBlocks(), schema.getColumns());        PageReadStore rowGroup = reader.readNextRowGroup();        PageReader pageReader = rowGroup.getPageReader(col);        DataPageV2 page = (DataPageV2) pageReader.readPage();        assertEquals(rowCount, page.getRowCount());        assertEquals(nullCount, page.getNullCount());        assertEquals(valueCount, page.getValueCount());        assertEquals(d, intValue(page.getDefinitionLevels()));        assertEquals(r, intValue(page.getRepetitionLevels()));        assertEquals(dataEncoding, page.getDataEncoding());        assertEquals(v, intValue(page.getData()));                ColumnChunkMetaData column = footer.getBlocks().get(0).getColumns().get(0);        ColumnIndex columnIndex = reader.readColumnIndex(column);        assertArrayEquals(statistics.getMinBytes(), columnIndex.getMinValues().get(0).array());        assertArrayEquals(statistics.getMaxBytes(), columnIndex.getMaxValues().get(0).array());        assertEquals(statistics.getNumNulls(), columnIndex.getNullCounts().get(0).longValue());        assertFalse(columnIndex.getNullPages().get(0));        OffsetIndex offsetIndex = reader.readOffsetIndex(column);        assertEquals(1, offsetIndex.getPageCount());        assertEquals(pageSize, offsetIndex.getCompressedPageSize(0));        assertEquals(0, offsetIndex.getFirstRowIndex(0));        assertEquals(pageOffset, offsetIndex.getOffset(0));        reader.close();    }}
d7871ff2a4ced6f58f4edfb625b91c83de14e5964b4f313f5b79b82dba4fa069
intValue
private int intValue(BytesInput in) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    in.writeAllTo(baos);    LittleEndianDataInputStream os = new LittleEndianDataInputStream(new ByteArrayInputStream(baos.toByteArray()));    int i = os.readInt();    os.close();    return i;}
41e1f0fd15ddf6c4db94e959cb1a5a99f3ce90bd8689f6c49ebd940050e05cb9
testColumnOrderV1
public void testColumnOrderV1() throws IOException
{    ParquetFileWriter mockFileWriter = Mockito.mock(ParquetFileWriter.class);    InOrder inOrder = inOrder(mockFileWriter);    MessageType schema = Types.buildMessage().required(BINARY).as(UTF8).named("a_string").required(INT32).named("an_int").required(INT64).named("a_long").required(FLOAT).named("a_float").required(DOUBLE).named("a_double").named("order_test");    BytesInput fakeData = BytesInput.fromInt(34);    int fakeCount = 3;    BinaryStatistics fakeStats = new BinaryStatistics();            ColumnChunkPageWriteStore store = new ColumnChunkPageWriteStore(compressor(UNCOMPRESSED), schema, new HeapByteBufferAllocator(), Integer.MAX_VALUE);    for (ColumnDescriptor col : schema.getColumns()) {        PageWriter pageWriter = store.getPageWriter(col);        pageWriter.writePage(fakeData, fakeCount, fakeStats, RLE, RLE, PLAIN);    }        store.flushToFileWriter(mockFileWriter);    for (ColumnDescriptor col : schema.getColumns()) {        inOrder.verify(mockFileWriter).writeColumnChunk(eq(col), eq((long) fakeCount), eq(UNCOMPRESSED), isNull(DictionaryPage.class), any(), eq(fakeData.size()), eq(fakeData.size()), eq(fakeStats),         same(ColumnIndexBuilder.getNoOpBuilder()),         same(OffsetIndexBuilder.getNoOpBuilder()), any(), any(), any());    }}
078b95e5bb825acb685f8c89ffc85b09c2654bb2d19223bd6f46f3907b1ae263
compressor
private CodecFactory.BytesCompressor compressor(CompressionCodecName codec)
{    return new CodecFactory(conf, pageSize).getCompressor(codec);}
d7beb7f07401f81ab11d2b4022efc5306fa698be37de1327426d5fd4d815a792
params
public static Collection<Object[]> params()
{    return Arrays.asList(new Object[] { FILE_V1 }, new Object[] { FILE_V2 });}
014831db5dbe3f98ab6e450067233e1c65d0db8b1936b6bc352e335088f7fd66
generateData
private static List<User> generateData(int rowCount)
{    List<User> users = new ArrayList<>();    List<String> names = generateNames(rowCount);    for (int i = 0; i < rowCount; ++i) {        users.add(new User(i, names.get(i), generatePhoneNumbers(), generateLocation(i, rowCount)));    }    return users;}
c3055d578d55a93ea7b9c1b6a275072f482e3f13c8991e37e38eead093047732
generateNames
private static List<String> generateNames(int rowCount)
{    List<String> list = new ArrayList<>();        list.add("anderson");    list.add("anderson");    list.add("miller");    list.add("miller");    list.add("miller");    list.add("thomas");    list.add("thomas");    list.add("williams");    int nullCount = rowCount / 100;    String alphabet = "aabcdeefghiijklmnoopqrstuuvwxyz";    int maxLength = 8;    for (int i = rowCount - list.size() - nullCount; i >= 0; --i) {        int l = RANDOM.nextInt(maxLength);        StringBuilder builder = new StringBuilder(l);        for (int j = 0; j < l; ++j) {            builder.append(alphabet.charAt(RANDOM.nextInt(alphabet.length())));        }        list.add(builder.toString());    }    Collections.sort(list, (str1, str2) -> -str1.compareTo(str2));        for (int i = 0; i < nullCount; ++i) {        list.add(RANDOM.nextInt(list.size()), null);    }    return list;}
aef3f158550b4580fe42cd452bd29d4c0cdb61bab86d8598687fbdf68ee27211
generatePhoneNumbers
private static List<PhoneNumber> generatePhoneNumbers()
{    int length = RANDOM.nextInt(5) - 1;    if (length < 0) {        return null;    }    List<PhoneNumber> phoneNumbers = new ArrayList<>(length);    for (int i = 0; i < length; ++i) {                long number = Math.abs(RANDOM.nextLong() % 900000) + 100000;        phoneNumbers.add(new PhoneNumber(number, PHONE_KINDS[RANDOM.nextInt(PHONE_KINDS.length)]));    }    return phoneNumbers;}
b59575e615901c25f46ccb2e75208ede9b66955e817e8722ba6f025ef1b2bf0f
generateLocation
private static Location generateLocation(int id, int rowCount)
{    if (RANDOM.nextDouble() < 0.01) {        return null;    }    double lat = RANDOM.nextDouble() * 90.0 - (id < rowCount / 2 ? 90.0 : 0.0);    double lon = RANDOM.nextDouble() * 90.0 - (id < rowCount / 4 || id >= 3 * rowCount / 4 ? 90.0 : 0.0);    return new Location(RANDOM.nextDouble() < 0.01 ? null : lat, RANDOM.nextDouble() < 0.01 ? null : lon);}
bff99b16acd0170f122fe8914d2b496b84f466417bbb0795d0577332336de9de
createTempFile
private static Path createTempFile()
{    try {        return new Path(Files.createTempFile("test-ci_", ".parquet").toAbsolutePath().toString());    } catch (IOException e) {        throw new AssertionError("Unable to create temporary file", e);    }}
97d1e9b40b3e71f0b00829a4a68ecac1dc4c06de270351ab99cf3ed95f692387
readUsers
private List<User> readUsers(FilterPredicate filter, boolean useOtherFiltering) throws IOException
{    return readUsers(FilterCompat.get(filter), useOtherFiltering, true);}
3a710de25f72b0e6dc82270955da7ff1a4afdc08b354dd424673e2453f276ea2
readUsers
private List<User> readUsers(FilterPredicate filter, boolean useOtherFiltering, boolean useColumnIndexFilter) throws IOException
{    return readUsers(FilterCompat.get(filter), useOtherFiltering, useColumnIndexFilter);}
848910a9bb9aee11d4e9de34bd67b0e9d780383cad2778ceddabb8c3ac824a98
readUsers
private List<User> readUsers(Filter filter, boolean useOtherFiltering) throws IOException
{    return readUsers(filter, useOtherFiltering, true);}
f113448a5987c05c21894fc626e433cca990a2035997e18836d13f8de9797b6d
readUsers
private List<User> readUsers(Filter filter, boolean useOtherFiltering, boolean useColumnIndexFilter) throws IOException
{    return PhoneBookWriter.readUsers(ParquetReader.builder(new GroupReadSupport(), file).withFilter(filter).useDictionaryFilter(useOtherFiltering).useStatsFilter(useOtherFiltering).useRecordFilter(useOtherFiltering).useColumnIndexFilter(useColumnIndexFilter));}
807ec4e9edb693cd882bb465d66d03653d11cbad3d821f2c9e362ffa635bf9df
assertContains
private static void assertContains(Stream<User> expected, List<User> actual)
{    Iterator<User> expIt = expected.iterator();    if (!expIt.hasNext()) {        return;    }    User exp = expIt.next();    for (User act : actual) {        if (act.equals(exp)) {            if (!expIt.hasNext()) {                break;            }            exp = expIt.next();        }    }    assertFalse("Not all expected elements are in the actual list. E.g.: " + exp, expIt.hasNext());}
4344ea4e4f62b94b3c6b7a60b88bc2be2136b9d2fa364f2b13824d37ebc15bfa
assertCorrectFiltering
private void assertCorrectFiltering(Predicate<User> expectedFilter, FilterPredicate actualFilter) throws IOException
{        List<User> result = readUsers(actualFilter, false);    assertTrue("Column-index filtering should drop some pages", result.size() < DATA.size());    LOGGER.info("{}/{} records read; filtering ratio: {}%", result.size(), DATA.size(), 100 * result.size() / DATA.size());        assertContains(DATA.stream().filter(expectedFilter), result);        assertContains(result.stream(), DATA);        result = readUsers(actualFilter, true);    assertEquals(DATA.stream().filter(expectedFilter).collect(Collectors.toList()), result);}
03b1d188c9e00aa59553fe38b3da397350b4a01a163909f1fa5c2a1c6377ee33
createFile
public static void createFile() throws IOException
{        int pageSize = DATA.size() / 10;        int rowGroupSize = pageSize * 6 * 5;    PhoneBookWriter.write(ExampleParquetWriter.builder(FILE_V1).withWriteMode(OVERWRITE).withRowGroupSize(rowGroupSize).withPageSize(pageSize).withWriterVersion(WriterVersion.PARQUET_1_0), DATA);    PhoneBookWriter.write(ExampleParquetWriter.builder(FILE_V2).withWriteMode(OVERWRITE).withRowGroupSize(rowGroupSize).withPageSize(pageSize).withWriterVersion(WriterVersion.PARQUET_2_0), DATA);}
86ea67a2c7270610a6adeb6644435a1c150997c6536ca1e1af3229caf4f73791
deleteFile
public static void deleteFile() throws IOException
{    FILE_V1.getFileSystem(new Configuration()).delete(FILE_V1, false);    FILE_V2.getFileSystem(new Configuration()).delete(FILE_V2, false);}
c227e8862f27f8ff02038f572f9f91849a184c2a226a30410f5c3f4eec955a35
testSimpleFiltering
public void testSimpleFiltering() throws IOException
{    assertCorrectFiltering(record -> record.getId() == 1234, eq(longColumn("id"), 1234l));    assertCorrectFiltering(record -> "miller".equals(record.getName()), eq(binaryColumn("name"), Binary.fromString("miller")));    assertCorrectFiltering(record -> record.getName() == null, eq(binaryColumn("name"), null));}
4fd270a590ba79392ad8bb2823a10e9ee94fad3af9ab1dde6835c8f546daa790
testNoFiltering
public void testNoFiltering() throws IOException
{        assertEquals(DATA, readUsers(FilterCompat.NOOP, false));    assertEquals(DATA, readUsers(FilterCompat.NOOP, true));        assertEquals(DATA.stream().filter(user -> user.getId() == 1234).collect(Collectors.toList()), readUsers(eq(longColumn("id"), 1234l), true, false));    assertEquals(DATA.stream().filter(user -> "miller".equals(user.getName())).collect(Collectors.toList()), readUsers(eq(binaryColumn("name"), Binary.fromString("miller")), true, false));    assertEquals(DATA.stream().filter(user -> user.getName() == null).collect(Collectors.toList()), readUsers(eq(binaryColumn("name"), null), true, false));        assertEquals(DATA, readUsers(eq(longColumn("id"), 1234l), false, false));    assertEquals(DATA, readUsers(eq(binaryColumn("name"), Binary.fromString("miller")), false, false));    assertEquals(DATA, readUsers(eq(binaryColumn("name"), null), false, false));}
c4b61fa0deaff9e7fd0bed5248c2639e868b02fc5651c973e499c03cf464e5a6
testComplexFiltering
public void testComplexFiltering() throws IOException
{    assertCorrectFiltering(record -> {        Location loc = record.getLocation();        Double lat = loc == null ? null : loc.getLat();        Double lon = loc == null ? null : loc.getLon();        return lat != null && lon != null && 37 <= lat && lat <= 70 && -21 <= lon && lon <= 35;    }, and(and(gtEq(doubleColumn("location.lat"), 37.0), ltEq(doubleColumn("location.lat"), 70.0)), and(gtEq(doubleColumn("location.lon"), -21.0), ltEq(doubleColumn("location.lon"), 35.0))));    assertCorrectFiltering(record -> {        Location loc = record.getLocation();        return loc == null || (loc.getLat() == null && loc.getLon() == null);    }, and(eq(doubleColumn("location.lat"), null), eq(doubleColumn("location.lon"), null)));    assertCorrectFiltering(record -> {        String name = record.getName();        return name != null && name.compareTo("thomas") < 0 && record.getId() <= 3 * DATA.size() / 4;    }, and(lt(binaryColumn("name"), Binary.fromString("thomas")), ltEq(longColumn("id"), 3l * DATA.size() / 4)));}
bc80a40d68893c9e39ef3229b081e24e97f219c28cd6b25322118f80ea618852
isStartingWithVowel
private static boolean isStartingWithVowel(String str)
{    if (str == null || str.isEmpty()) {        return false;    }    switch(str.charAt(0)) {        case 'a':        case 'e':        case 'i':        case 'o':        case 'u':            return true;        default:            return false;    }}
1d830f6b642fa3232a3173f18fb7638d7113fe65b683f2be7e994bb1091c6bb1
keep
public boolean keep(Binary value)
{    return value != null && isStartingWithVowel(value.toStringUsingUTF8());}
83f1f836020cb0268463e637d35d40decc8bfd13fc8c7cef95c4065617f8ee34
canDrop
public boolean canDrop(Statistics<Binary> statistics)
{    Comparator<Binary> cmp = statistics.getComparator();    Binary min = statistics.getMin();    Binary max = statistics.getMax();    return cmp.compare(max, A) < 0 || (cmp.compare(min, B) >= 0 && cmp.compare(max, E) < 0) || (cmp.compare(min, F) >= 0 && cmp.compare(max, I) < 0) || (cmp.compare(min, J) >= 0 && cmp.compare(max, O) < 0) || (cmp.compare(min, P) >= 0 && cmp.compare(max, U) < 0) || cmp.compare(min, V) >= 0;}
49cb432a1c15577fdafed299fd1810441fbd2ac8ce3056305de4e5aec9babf28
inverseCanDrop
public boolean inverseCanDrop(Statistics<Binary> statistics)
{    Comparator<Binary> cmp = statistics.getComparator();    Binary min = statistics.getMin();    Binary max = statistics.getMax();    return (cmp.compare(min, A) >= 0 && cmp.compare(max, B) < 0) || (cmp.compare(min, E) >= 0 && cmp.compare(max, F) < 0) || (cmp.compare(min, I) >= 0 && cmp.compare(max, J) < 0) || (cmp.compare(min, O) >= 0 && cmp.compare(max, P) < 0) || (cmp.compare(min, U) >= 0 && cmp.compare(max, V) < 0);}
6a0ad857c4f18f2d64da235f3e095c2ada5780c75df3139c572f63f22a8e65a5
keep
public boolean keep(Long value)
{        return value % divisor == 0;}
9dc064c84e7b360a598629007633ef115befb8e2ff84a21a63d976d15c28aa30
canDrop
public boolean canDrop(Statistics<Long> statistics)
{    long min = statistics.getMin();    long max = statistics.getMax();    return min % divisor != 0 && max % divisor != 0 && min / divisor == max / divisor;}
24d038c437c6c7c61085c1cd71d35f9d7ea6ee4a52d448b6b35d55f55712b809
inverseCanDrop
public boolean inverseCanDrop(Statistics<Long> statistics)
{    long min = statistics.getMin();    long max = statistics.getMax();    return min == max && min % divisor == 0;}
c3650a4f47916777a2484100765425b1158865f62cacc5424208c2b921b8a148
testUDF
public void testUDF() throws IOException
{    assertCorrectFiltering(record -> NameStartsWithVowel.isStartingWithVowel(record.getName()) || record.getId() % 234 == 0, or(userDefined(binaryColumn("name"), NameStartsWithVowel.class), userDefined(longColumn("id"), new IsDivisibleBy(234))));    assertCorrectFiltering(record -> !(NameStartsWithVowel.isStartingWithVowel(record.getName()) || record.getId() % 234 == 0), not(or(userDefined(binaryColumn("name"), NameStartsWithVowel.class), userDefined(longColumn("id"), new IsDivisibleBy(234)))));}
58cadf03e1ec10d773dd232cb54a2a3f385967392c2e83254a1ec2a2861f3189
testFilteringWithMissingColumns
public void testFilteringWithMissingColumns() throws IOException
{        assertEquals(DATA, readUsers(notEq(binaryColumn("not-existing-binary"), Binary.EMPTY), true));    assertCorrectFiltering(record -> record.getId() == 1234, and(eq(longColumn("id"), 1234l), eq(longColumn("not-existing-long"), null)));    assertCorrectFiltering(record -> "miller".equals(record.getName()), and(eq(binaryColumn("name"), Binary.fromString("miller")), invert(userDefined(binaryColumn("not-existing-binary"), NameStartsWithVowel.class))));        assertEquals(emptyList(), readUsers(lt(longColumn("not-existing-long"), 0l), true));    assertCorrectFiltering(record -> "miller".equals(record.getName()), or(eq(binaryColumn("name"), Binary.fromString("miller")), gtEq(binaryColumn("not-existing-binary"), Binary.EMPTY)));    assertCorrectFiltering(record -> record.getId() == 1234, or(eq(longColumn("id"), 1234l), userDefined(longColumn("not-existing-long"), new IsDivisibleBy(1))));}
41d1b781cd9918f63966a1158859335c1a6f5b4900b59a3078fe790e01a55053
writeSimpleParquetFile
private Path writeSimpleParquetFile(Configuration conf, CompressionCodecName compression) throws IOException
{    File file = tempFolder.newFile();    file.delete();    Path path = new Path(file.toURI());    for (int i = 0; i < PAGE_SIZE; i++) {        colAPage1Bytes[i] = (byte) i;        colAPage2Bytes[i] = (byte) -i;        colBPage1Bytes[i] = (byte) (i + 100);        colBPage2Bytes[i] = (byte) (i - 100);    }    ParquetFileWriter writer = new ParquetFileWriter(conf, schemaSimple, path, ParquetWriter.DEFAULT_BLOCK_SIZE, ParquetWriter.MAX_PADDING_SIZE_DEFAULT);    writer.start();    writer.startBlock(numRecordsLargeFile);    CodecFactory codecFactory = new CodecFactory(conf, PAGE_SIZE);    CodecFactory.BytesCompressor compressor = codecFactory.getCompressor(compression);    ColumnChunkPageWriteStore writeStore = new ColumnChunkPageWriteStore(compressor, schemaSimple, new HeapByteBufferAllocator(), Integer.MAX_VALUE, ParquetOutputFormat.getPageWriteChecksumEnabled(conf));    PageWriter pageWriter = writeStore.getPageWriter(colADesc);    pageWriter.writePage(BytesInput.from(colAPage1Bytes), numRecordsLargeFile / 2, numRecordsLargeFile / 2, EMPTY_STATS_INT32, Encoding.RLE, Encoding.RLE, Encoding.PLAIN);    pageWriter.writePage(BytesInput.from(colAPage2Bytes), numRecordsLargeFile / 2, numRecordsLargeFile / 2, EMPTY_STATS_INT32, Encoding.RLE, Encoding.RLE, Encoding.PLAIN);    pageWriter = writeStore.getPageWriter(colBDesc);    pageWriter.writePage(BytesInput.from(colBPage1Bytes), numRecordsLargeFile / 2, numRecordsLargeFile / 2, EMPTY_STATS_INT32, Encoding.RLE, Encoding.RLE, Encoding.PLAIN);    pageWriter.writePage(BytesInput.from(colBPage2Bytes), numRecordsLargeFile / 2, numRecordsLargeFile / 2, EMPTY_STATS_INT32, Encoding.RLE, Encoding.RLE, Encoding.PLAIN);    writeStore.flushToFileWriter(writer);    writer.endBlock();    writer.end(new HashMap<>());    codecFactory.release();    return path;}
7a90aaa3aec21bf9aabdd1ead236485da3cd3397214aae6a6611f9b9afe2a44d
writeNestedWithNullsSampleParquetFile
private Path writeNestedWithNullsSampleParquetFile(Configuration conf, boolean dictionaryEncoding, CompressionCodecName compression) throws IOException
{    File file = tempFolder.newFile();    file.delete();    Path path = new Path(file.toURI());    try (ParquetWriter<Group> writer = ExampleParquetWriter.builder(path).withConf(conf).withWriteMode(ParquetFileWriter.Mode.OVERWRITE).withCompressionCodec(compression).withDictionaryEncoding(dictionaryEncoding).withType(schemaNestedWithNulls).withPageWriteChecksumEnabled(ParquetOutputFormat.getPageWriteChecksumEnabled(conf)).build()) {        GroupFactory groupFactory = new SimpleGroupFactory(schemaNestedWithNulls);        Random rand = new Random(42);        for (int i = 0; i < numRecordsNestedWithNullsFile; i++) {            Group group = groupFactory.newGroup();            if (rand.nextDouble() > nullRatio) {                                if (rand.nextDouble() > 0.5) {                    group.addGroup("c").append("id", (long) i).addGroup("d").append("val", rand.nextInt() % 10);                } else {                    group.addGroup("c").append("id", (long) i).addGroup("d").append("val", rand.nextInt() % 10).append("val", rand.nextInt() % 10).append("val", rand.nextInt() % 10);                }            }            writer.write(group);        }    }    return path;}
f72f88a6ce35a1fc9a5eb02f349fd22f8eb5c435fb4dc979d62ea46c12146212
testWriteOnVerifyOff
public void testWriteOnVerifyOff() throws IOException
{    Configuration conf = new Configuration();    conf.setBoolean(ParquetOutputFormat.PAGE_WRITE_CHECKSUM_ENABLED, true);    conf.setBoolean(ParquetInputFormat.PAGE_VERIFY_CHECKSUM_ENABLED, false);    Path path = writeSimpleParquetFile(conf, CompressionCodecName.UNCOMPRESSED);    try (ParquetFileReader reader = getParquetFileReader(path, conf, Arrays.asList(colADesc, colBDesc))) {        PageReadStore pageReadStore = reader.readNextRowGroup();        DataPageV1 colAPage1 = readNextPage(colADesc, pageReadStore);        assertCrcSetAndCorrect(colAPage1, colAPage1Bytes);        assertCorrectContent(colAPage1.getBytes().toByteArray(), colAPage1Bytes);        DataPageV1 colAPage2 = readNextPage(colADesc, pageReadStore);        assertCrcSetAndCorrect(colAPage2, colAPage2Bytes);        assertCorrectContent(colAPage2.getBytes().toByteArray(), colAPage2Bytes);        DataPageV1 colBPage1 = readNextPage(colBDesc, pageReadStore);        assertCrcSetAndCorrect(colBPage1, colBPage1Bytes);        assertCorrectContent(colBPage1.getBytes().toByteArray(), colBPage1Bytes);        DataPageV1 colBPage2 = readNextPage(colBDesc, pageReadStore);        assertCrcSetAndCorrect(colBPage2, colBPage2Bytes);        assertCorrectContent(colBPage2.getBytes().toByteArray(), colBPage2Bytes);    }}
15fa295c777bdfcc27b3a5056a7d856efdffdbfd2d1ad78bb08a107cef9c84e5
testWriteOffVerifyOff
public void testWriteOffVerifyOff() throws IOException
{    Configuration conf = new Configuration();    conf.setBoolean(ParquetOutputFormat.PAGE_WRITE_CHECKSUM_ENABLED, false);    conf.setBoolean(ParquetInputFormat.PAGE_VERIFY_CHECKSUM_ENABLED, false);    Path path = writeSimpleParquetFile(conf, CompressionCodecName.UNCOMPRESSED);    try (ParquetFileReader reader = getParquetFileReader(path, conf, Arrays.asList(colADesc, colBDesc))) {        PageReadStore pageReadStore = reader.readNextRowGroup();        assertCrcNotSet(readNextPage(colADesc, pageReadStore));        assertCrcNotSet(readNextPage(colADesc, pageReadStore));        assertCrcNotSet(readNextPage(colBDesc, pageReadStore));        assertCrcNotSet(readNextPage(colBDesc, pageReadStore));    }}
addd50cecf23f34a94ee7f4d60e0cb3f2f5690f23de9c28e5589c0e741079e82
testWriteOffVerifyOn
public void testWriteOffVerifyOn() throws IOException
{    Configuration conf = new Configuration();    conf.setBoolean(ParquetOutputFormat.PAGE_WRITE_CHECKSUM_ENABLED, false);    conf.setBoolean(ParquetInputFormat.PAGE_VERIFY_CHECKSUM_ENABLED, true);    Path path = writeSimpleParquetFile(conf, CompressionCodecName.UNCOMPRESSED);    try (ParquetFileReader reader = getParquetFileReader(path, conf, Arrays.asList(colADesc, colBDesc))) {        PageReadStore pageReadStore = reader.readNextRowGroup();        assertCorrectContent(readNextPage(colADesc, pageReadStore).getBytes().toByteArray(), colAPage1Bytes);        assertCorrectContent(readNextPage(colADesc, pageReadStore).getBytes().toByteArray(), colAPage2Bytes);        assertCorrectContent(readNextPage(colBDesc, pageReadStore).getBytes().toByteArray(), colBPage1Bytes);        assertCorrectContent(readNextPage(colBDesc, pageReadStore).getBytes().toByteArray(), colBPage2Bytes);    }}
f8bffe3941af6a7c770ec334e3d9a67620c9c58ef41b0220a6b02322c8d136a1
testWriteOnVerifyOn
public void testWriteOnVerifyOn() throws IOException
{    Configuration conf = new Configuration();    conf.setBoolean(ParquetOutputFormat.PAGE_WRITE_CHECKSUM_ENABLED, true);    conf.setBoolean(ParquetInputFormat.PAGE_VERIFY_CHECKSUM_ENABLED, true);    Path path = writeSimpleParquetFile(conf, CompressionCodecName.UNCOMPRESSED);    try (ParquetFileReader reader = getParquetFileReader(path, conf, Arrays.asList(colADesc, colBDesc))) {        PageReadStore pageReadStore = reader.readNextRowGroup();        DataPageV1 colAPage1 = readNextPage(colADesc, pageReadStore);        assertCrcSetAndCorrect(colAPage1, colAPage1Bytes);        assertCorrectContent(colAPage1.getBytes().toByteArray(), colAPage1Bytes);        DataPageV1 colAPage2 = readNextPage(colADesc, pageReadStore);        assertCrcSetAndCorrect(colAPage2, colAPage2Bytes);        assertCorrectContent(colAPage2.getBytes().toByteArray(), colAPage2Bytes);        DataPageV1 colBPage1 = readNextPage(colBDesc, pageReadStore);        assertCrcSetAndCorrect(colBPage1, colBPage1Bytes);        assertCorrectContent(colBPage1.getBytes().toByteArray(), colBPage1Bytes);        DataPageV1 colBPage2 = readNextPage(colBDesc, pageReadStore);        assertCrcSetAndCorrect(colBPage2, colBPage2Bytes);        assertCorrectContent(colBPage2.getBytes().toByteArray(), colBPage2Bytes);    }}
d37c149172dfaf09b9cd8571ffeca74f1fe6a2a2f51663a4fe6ad8dc32832ebc
testCorruptedPage
public void testCorruptedPage() throws IOException
{    Configuration conf = new Configuration();    conf.setBoolean(ParquetOutputFormat.PAGE_WRITE_CHECKSUM_ENABLED, true);    Path path = writeSimpleParquetFile(conf, CompressionCodecName.UNCOMPRESSED);    InputFile inputFile = HadoopInputFile.fromPath(path, conf);    try (SeekableInputStream inputStream = inputFile.newStream()) {        int fileLen = (int) inputFile.getLength();        byte[] fileBytes = new byte[fileLen];        inputStream.readFully(fileBytes);        inputStream.close();                                fileBytes[fileLen / 8]++;        fileBytes[fileLen / 8 + ((fileLen / 4) * 3)]++;        OutputFile outputFile = HadoopOutputFile.fromPath(path, conf);        try (PositionOutputStream outputStream = outputFile.createOrOverwrite(1024 * 1024)) {            outputStream.write(fileBytes);            outputStream.close();                                    conf.setBoolean(ParquetInputFormat.PAGE_VERIFY_CHECKSUM_ENABLED, false);            try (ParquetFileReader reader = getParquetFileReader(path, conf, Arrays.asList(colADesc, colBDesc))) {                PageReadStore pageReadStore = reader.readNextRowGroup();                DataPageV1 colAPage1 = readNextPage(colADesc, pageReadStore);                assertFalse("Data in page was not corrupted", Arrays.equals(colAPage1.getBytes().toByteArray(), colAPage1Bytes));                readNextPage(colADesc, pageReadStore);                readNextPage(colBDesc, pageReadStore);                DataPageV1 colBPage2 = readNextPage(colBDesc, pageReadStore);                assertFalse("Data in page was not corrupted", Arrays.equals(colBPage2.getBytes().toByteArray(), colBPage2Bytes));            }                        conf.setBoolean(ParquetInputFormat.PAGE_VERIFY_CHECKSUM_ENABLED, true);            try (ParquetFileReader reader = getParquetFileReader(path, conf, Arrays.asList(colADesc, colBDesc))) {                                assertVerificationFailed(reader);            }        }    }}
29094f52ad76d295cd7009ce57e5f3ccf3881f173d92f7774e6a426dae5295da
testCompression
public void testCompression() throws IOException
{    Configuration conf = new Configuration();    conf.setBoolean(ParquetOutputFormat.PAGE_WRITE_CHECKSUM_ENABLED, true);    conf.setBoolean(ParquetInputFormat.PAGE_VERIFY_CHECKSUM_ENABLED, true);    Path path = writeSimpleParquetFile(conf, CompressionCodecName.SNAPPY);    try (ParquetFileReader reader = getParquetFileReader(path, conf, Arrays.asList(colADesc, colBDesc))) {        PageReadStore pageReadStore = reader.readNextRowGroup();        DataPageV1 colAPage1 = readNextPage(colADesc, pageReadStore);        assertCrcSetAndCorrect(colAPage1, snappy(colAPage1Bytes));        assertCorrectContent(colAPage1.getBytes().toByteArray(), colAPage1Bytes);        DataPageV1 colAPage2 = readNextPage(colADesc, pageReadStore);        assertCrcSetAndCorrect(colAPage2, snappy(colAPage2Bytes));        assertCorrectContent(colAPage2.getBytes().toByteArray(), colAPage2Bytes);        DataPageV1 colBPage1 = readNextPage(colBDesc, pageReadStore);        assertCrcSetAndCorrect(colBPage1, snappy(colBPage1Bytes));        assertCorrectContent(colBPage1.getBytes().toByteArray(), colBPage1Bytes);        DataPageV1 colBPage2 = readNextPage(colBDesc, pageReadStore);        assertCrcSetAndCorrect(colBPage2, snappy(colBPage2Bytes));        assertCorrectContent(colBPage2.getBytes().toByteArray(), colBPage2Bytes);    }}
79241c79555b1b037ee961ee52f6cbaffecfbb6471bbb68180454737c4253ccc
testNestedWithNulls
public void testNestedWithNulls() throws IOException
{    Configuration conf = new Configuration();            conf.setBoolean(ParquetOutputFormat.PAGE_WRITE_CHECKSUM_ENABLED, false);    conf.setBoolean(ParquetInputFormat.PAGE_VERIFY_CHECKSUM_ENABLED, false);    Path refPath = writeNestedWithNullsSampleParquetFile(conf, false, CompressionCodecName.SNAPPY);    try (ParquetFileReader refReader = getParquetFileReader(refPath, conf, Arrays.asList(colCIdDesc, colDValDesc))) {        PageReadStore refPageReadStore = refReader.readNextRowGroup();        byte[] colCIdPageBytes = readNextPage(colCIdDesc, refPageReadStore).getBytes().toByteArray();        byte[] colDValPageBytes = readNextPage(colDValDesc, refPageReadStore).getBytes().toByteArray();                conf.setBoolean(ParquetOutputFormat.PAGE_WRITE_CHECKSUM_ENABLED, true);        conf.setBoolean(ParquetInputFormat.PAGE_VERIFY_CHECKSUM_ENABLED, true);        Path path = writeNestedWithNullsSampleParquetFile(conf, false, CompressionCodecName.SNAPPY);        try (ParquetFileReader reader = getParquetFileReader(path, conf, Arrays.asList(colCIdDesc, colDValDesc))) {            PageReadStore pageReadStore = reader.readNextRowGroup();            DataPageV1 colCIdPage = readNextPage(colCIdDesc, pageReadStore);            assertCrcSetAndCorrect(colCIdPage, snappy(colCIdPageBytes));            assertCorrectContent(colCIdPage.getBytes().toByteArray(), colCIdPageBytes);            DataPageV1 colDValPage = readNextPage(colDValDesc, pageReadStore);            assertCrcSetAndCorrect(colDValPage, snappy(colDValPageBytes));            assertCorrectContent(colDValPage.getBytes().toByteArray(), colDValPageBytes);        }    }}
8374fb4763245fd1bb11b28a190fbb758dac482aefc6e81de6613f3d58aa383a
testDictionaryEncoding
public void testDictionaryEncoding() throws IOException
{    Configuration conf = new Configuration();            conf.setBoolean(ParquetOutputFormat.PAGE_WRITE_CHECKSUM_ENABLED, false);    conf.setBoolean(ParquetInputFormat.PAGE_VERIFY_CHECKSUM_ENABLED, false);    Path refPath = writeNestedWithNullsSampleParquetFile(conf, true, CompressionCodecName.SNAPPY);    try (ParquetFileReader refReader = getParquetFileReader(refPath, conf, Collections.singletonList(colDValDesc))) {        PageReadStore refPageReadStore = refReader.readNextRowGroup();                byte[] dictPageBytes = readDictPage(colDValDesc, refPageReadStore).getBytes().toByteArray();        byte[] colDValPageBytes = readNextPage(colDValDesc, refPageReadStore).getBytes().toByteArray();                conf.setBoolean(ParquetOutputFormat.PAGE_WRITE_CHECKSUM_ENABLED, true);        conf.setBoolean(ParquetInputFormat.PAGE_VERIFY_CHECKSUM_ENABLED, true);        Path path = writeNestedWithNullsSampleParquetFile(conf, true, CompressionCodecName.SNAPPY);        try (ParquetFileReader reader = getParquetFileReader(path, conf, Collections.singletonList(colDValDesc))) {            PageReadStore pageReadStore = reader.readNextRowGroup();            DictionaryPage dictPage = readDictPage(colDValDesc, pageReadStore);            assertCrcSetAndCorrect(dictPage, snappy(dictPageBytes));            assertCorrectContent(dictPage.getBytes().toByteArray(), dictPageBytes);            DataPageV1 colDValPage = readNextPage(colDValDesc, pageReadStore);            assertCrcSetAndCorrect(colDValPage, snappy(colDValPageBytes));            assertCorrectContent(colDValPage.getBytes().toByteArray(), colDValPageBytes);        }    }}
4a4a25f041f5734c7ec1acb4361ea828bd11434ed68ed9fe545b8bc01e82c1b4
snappy
private byte[] snappy(byte[] bytes) throws IOException
{    SnappyCompressor compressor = new SnappyCompressor();    compressor.reset();    compressor.setInput(bytes, 0, bytes.length);    compressor.finish();    byte[] buffer = new byte[bytes.length * 2];    int compressedSize = compressor.compress(buffer, 0, buffer.length);    return Arrays.copyOfRange(buffer, 0, compressedSize);}
d9e752e99bcb7e19e9a6517bfdfb1ce8b1e4ecf4e2a4f103c2cf543328d64092
getParquetFileReader
private ParquetFileReader getParquetFileReader(Path path, Configuration conf, List<ColumnDescriptor> columns) throws IOException
{    ParquetMetadata footer = ParquetFileReader.readFooter(conf, path);    return new ParquetFileReader(conf, footer.getFileMetaData(), path, footer.getBlocks(), columns);}
2db11d2c04e96e6aac9a7737c2c95123562e4c003385ce3493158d9eb2da2570
readDictPage
private DictionaryPage readDictPage(ColumnDescriptor colDesc, PageReadStore pageReadStore)
{    return pageReadStore.getPageReader(colDesc).readDictionaryPage();}
a8b141d73443f55b1ba941be7c674ef5a08d8105de9afb1adbc2040519b57a34
readNextPage
private DataPageV1 readNextPage(ColumnDescriptor colDesc, PageReadStore pageReadStore)
{    return (DataPageV1) pageReadStore.getPageReader(colDesc).readPage();}
07f7310155cbdd14c9b57d5c714177b2009164edc9404b2b58634db610f19d57
assertCorrectContent
private void assertCorrectContent(byte[] pageBytes, byte[] referenceBytes)
{    assertArrayEquals("Read page content was different from expected page content", referenceBytes, pageBytes);}
a324431109076ecf799640af16fdd5a60526a9e4b21e34053c637f0e8cbd98f0
assertCrcSetAndCorrect
private void assertCrcSetAndCorrect(Page page, byte[] referenceBytes)
{    assertTrue("Checksum was not set in page", page.getCrc().isPresent());    int crcFromPage = page.getCrc().getAsInt();    crc.reset();    crc.update(referenceBytes);    assertEquals("Checksum found in page did not match calculated reference checksum", crc.getValue(), (long) crcFromPage & 0xffffffffL);}
94bd03a976bd9c7fd23fcb66abd74293f5abe0f59e630a6f4b4b1e4b85580ce7
assertCrcNotSet
private void assertCrcNotSet(Page page)
{    assertFalse("Checksum was set in page", page.getCrc().isPresent());}
9c5877c6e656dc039b044b5d75276678921ed3e5a850b9a38a0c8021395f934e
assertVerificationFailed
private void assertVerificationFailed(ParquetFileReader reader)
{    try {        reader.readNextRowGroup();        fail("Expected checksum verification exception to be thrown");    } catch (Exception e) {        assertTrue("Thrown exception is of incorrect type", e instanceof ParquetDecodingException);        assertTrue("Did not catch checksum verification ParquetDecodingException", e.getMessage().contains("CRC checksum verification failed"));    }}
361f9e15617e47e93ee8186339c5cf451c71c7549c55bf59d76f50a478931919
test
private void test(int size, CompressionCodecName codec, boolean useOnHeapCompression, Decompression decomp)
{    ByteBuffer rawBuf = null;    ByteBuffer outBuf = null;    ByteBufferAllocator allocator = null;    try {        allocator = new DirectByteBufferAllocator();        final CodecFactory codecFactory = CodecFactory.createDirectCodecFactory(new Configuration(), allocator, pageSize);        rawBuf = allocator.allocate(size);        final byte[] rawArr = new byte[size];        outBuf = allocator.allocate(size * 2);        final Random r = new Random();        final byte[] random = new byte[1024];        int pos = 0;        while (pos < size) {            r.nextBytes(random);            rawBuf.put(random);            System.arraycopy(random, 0, rawArr, pos, random.length);            pos += random.length;        }        rawBuf.flip();        final DirectCodecFactory.BytesCompressor c = codecFactory.getCompressor(codec);        final CodecFactory.BytesDecompressor d = codecFactory.getDecompressor(codec);        final BytesInput compressed;        if (useOnHeapCompression) {            compressed = c.compress(BytesInput.from(rawArr));        } else {            compressed = c.compress(BytesInput.from(rawBuf));        }        switch(decomp) {            case OFF_HEAP:                {                    final ByteBuffer buf = compressed.toByteBuffer();                    final ByteBuffer b = allocator.allocate(buf.capacity());                    try {                        b.put(buf);                        b.flip();                        d.decompress(b, (int) compressed.size(), outBuf, size);                        for (int i = 0; i < size; i++) {                            Assert.assertTrue("Data didn't match at " + i, outBuf.get(i) == rawBuf.get(i));                        }                    } finally {                        allocator.release(b);                    }                    break;                }            case OFF_HEAP_BYTES_INPUT:                {                    final ByteBuffer buf = compressed.toByteBuffer();                    final ByteBuffer b = allocator.allocate(buf.limit());                    try {                        b.put(buf);                        b.flip();                        final BytesInput input = d.decompress(BytesInput.from(b), size);                        Assert.assertArrayEquals(String.format("While testing codec %s", codec), input.toByteArray(), rawArr);                    } finally {                        allocator.release(b);                    }                    break;                }            case ON_HEAP:                {                    final byte[] buf = compressed.toByteArray();                    final BytesInput input = d.decompress(BytesInput.from(buf), size);                    Assert.assertArrayEquals(input.toByteArray(), rawArr);                    break;                }        }    } catch (Exception e) {        final String msg = String.format("Failure while testing Codec: %s, OnHeapCompressionInput: %s, Decompression Mode: %s, Data Size: %d", codec.name(), useOnHeapCompression, decomp.name(), size);        System.out.println(msg);        throw new RuntimeException(msg, e);    } finally {        if (rawBuf != null) {            allocator.release(rawBuf);        }        if (outBuf != null) {            allocator.release(rawBuf);        }    }}
a1577b98f2a88a7f17f48909dff63b1c317dfeacfeb43641d006fc2888f58b80
createDirectFactoryWithHeapAllocatorFails
public void createDirectFactoryWithHeapAllocatorFails()
{    String errorMsg = "Test failed, creation of a direct codec factory should have failed when passed a non-direct allocator.";    try {        CodecFactory.createDirectCodecFactory(new Configuration(), new HeapByteBufferAllocator(), 0);        throw new RuntimeException(errorMsg);    } catch (IllegalStateException ex) {                Assert.assertTrue("Missing expected error message.", ex.getMessage().contains("A DirectCodecFactory requires a direct buffer allocator be provided."));    } catch (Exception ex) {        throw new RuntimeException(errorMsg + " Failed with the wrong error.");    }}
3abc4dbaf67e335884b23225b3c7163e953fe0bdf85a07d5e7d77a0550cfae8d
compressionCodecs
public void compressionCodecs() throws Exception
{    final int[] sizes = { 4 * 1024, 1 * 1024 * 1024 };    final boolean[] comp = { true, false };    Set<CompressionCodecName> codecsToSkip = new HashSet<>();        codecsToSkip.add(LZO);        codecsToSkip.add(LZ4);        codecsToSkip.add(ZSTD);    for (final int size : sizes) {        for (final boolean useOnHeapComp : comp) {            for (final Decompression decomp : Decompression.values()) {                for (final CompressionCodecName codec : CompressionCodecName.values()) {                    if (codecsToSkip.contains(codec)) {                        continue;                    }                    test(size, codec, useOnHeapComp, decomp);                }            }        }    }}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    blocks = new ArrayList<BlockMetaData>();    for (int i = 0; i < 10; i++) {        blocks.add(newBlock(i * 10, 10));    }    schema = MessageTypeParser.parseMessageType("message doc { required binary foo; }");    fileMetaData = new FileMetaData(schema, new HashMap<String, String>(), "parquet-mr");}
7655848713b7f4c796d3e9c2d1569ff2778768555a0f627b488fdbf739c11a8c
testThrowExceptionWhenMaxSplitSizeIsSmallerThanMinSplitSize
public void testThrowExceptionWhenMaxSplitSizeIsSmallerThanMinSplitSize() throws IOException
{    try {        generateSplitByMinMaxSize(50, 49);        fail("should throw exception when max split size is smaller than the min split size");    } catch (ParquetDecodingException e) {        assertEquals("maxSplitSize and minSplitSize should be positive and max should be greater or equal to the minSplitSize: maxSplitSize = 49; minSplitSize is 50", e.getMessage());    }}
4ec9a79afffc2fe569d37a7119aed8e45abedbfc7fe7eb9c8240041c2b744964
testThrowExceptionWhenMaxSplitSizeIsNegative
public void testThrowExceptionWhenMaxSplitSizeIsNegative() throws IOException
{    try {        generateSplitByMinMaxSize(-100, -50);        fail("should throw exception when max split size is negative");    } catch (ParquetDecodingException e) {        assertEquals("maxSplitSize and minSplitSize should be positive and max should be greater or equal to the minSplitSize: maxSplitSize = -50; minSplitSize is -100", e.getMessage());    }}
30a0cf9983e4c7387dfdc8dda63cc9286fa537fac5f07668b4a18a6a392b6cd9
testGetFilter
public void testGetFilter() throws IOException
{    IntColumn intColumn = intColumn("foo");    FilterPredicate p = or(eq(intColumn, 7), eq(intColumn, 12));    Configuration conf = new Configuration();    ParquetInputFormat.setFilterPredicate(conf, p);    Filter read = ParquetInputFormat.getFilter(conf);    assertTrue(read instanceof FilterPredicateCompat);    assertEquals(p, ((FilterPredicateCompat) read).getFilterPredicate());    conf = new Configuration();    ParquetInputFormat.setFilterPredicate(conf, not(p));    read = ParquetInputFormat.getFilter(conf);    assertTrue(read instanceof FilterPredicateCompat);    assertEquals(and(notEq(intColumn, 7), notEq(intColumn, 12)), ((FilterPredicateCompat) read).getFilterPredicate());    assertEquals(FilterCompat.NOOP, ParquetInputFormat.getFilter(new Configuration()));}
a40cc35b808899b7ecb58e5328333ad537816a4c7fc43348b03c53827faab22e
testGenerateSplitsAlignedWithHDFSBlock
public void testGenerateSplitsAlignedWithHDFSBlock() throws IOException
{    withHDFSBlockSize(50, 50);    List<ParquetInputSplit> splits = generateSplitByMinMaxSize(50, 50);    shouldSplitBlockSizeBe(splits, 5, 5);    shouldSplitLocationBe(splits, 0, 1);    shouldSplitLengthBe(splits, 50, 50);    splits = generateSplitByMinMaxSize(0, Long.MAX_VALUE);    shouldSplitBlockSizeBe(splits, 5, 5);    shouldSplitLocationBe(splits, 0, 1);    shouldSplitLengthBe(splits, 50, 50);}
699b959d00c49954db8cd4cc8e1f52f847d4bf7a2ce6f59e23110285a0f1bbbb
testRowGroupNotAlignToHDFSBlock
public void testRowGroupNotAlignToHDFSBlock() throws IOException
{        withHDFSBlockSize(51, 51);    List<ParquetInputSplit> splits = generateSplitByMinMaxSize(50, 50);    shouldSplitBlockSizeBe(splits, 5, 5);        shouldSplitLocationBe(splits, 0, 0);    shouldSplitLengthBe(splits, 50, 50);        withHDFSBlockSize(49, 49);    splits = generateSplitByMinMaxSize(50, 50);    shouldSplitBlockSizeBe(splits, 5, 5);    shouldSplitLocationBe(splits, 0, 1);    shouldSplitLengthBe(splits, 50, 50);    /*    aaaa bbbbb c    for the 5th row group, the midpoint is 45, but the end of first hdfsBlock is 44, therefore a new split(b) will be created    for 9th group, the mid point is 85, the end of second block is 88, so it's considered mainly in the 2nd hdfs block, and therefore inserted as    a row group of split b     */    withHDFSBlockSize(44, 44, 44);    splits = generateSplitByMinMaxSize(40, 50);    shouldSplitBlockSizeBe(splits, 4, 5, 1);    shouldSplitLocationBe(splits, 0, 0, 2);    shouldSplitLengthBe(splits, 40, 50, 10);}
4f72ff070079e0de54143dec34f82e16ed230da781e501d2d4734d30134be68d
testGenerateSplitsNotAlignedWithHDFSBlock
public void testGenerateSplitsNotAlignedWithHDFSBlock() throws IOException, InterruptedException
{    withHDFSBlockSize(50, 50);    List<ParquetInputSplit> splits = generateSplitByMinMaxSize(55, 56);    shouldSplitBlockSizeBe(splits, 6, 4);    shouldSplitLocationBe(splits, 0, 1);    shouldSplitLengthBe(splits, 60, 40);    withHDFSBlockSize(51, 51);    splits = generateSplitByMinMaxSize(55, 56);    shouldSplitBlockSizeBe(splits, 6, 4);        shouldSplitLocationBe(splits, 0, 1);    shouldSplitLengthBe(splits, 60, 40);    withHDFSBlockSize(49, 49, 49);    splits = generateSplitByMinMaxSize(55, 56);    shouldSplitBlockSizeBe(splits, 6, 4);    shouldSplitLocationBe(splits, 0, 1);    shouldSplitLengthBe(splits, 60, 40);}
6a278c5f4455f8a9bd7df53bf6c9c7e9291ceb794b3b483a901691affa981a23
testGenerateSplitsSmallerThanMaxSizeAndAlignToHDFS
public void testGenerateSplitsSmallerThanMaxSizeAndAlignToHDFS() throws Exception
{    withHDFSBlockSize(50, 50);    List<ParquetInputSplit> splits = generateSplitByMinMaxSize(18, 30);    shouldSplitBlockSizeBe(splits, 3, 2, 3, 2);    shouldSplitLocationBe(splits, 0, 0, 1, 1);    shouldSplitLengthBe(splits, 30, 20, 30, 20);    /*    aaabb cccdd         */    withHDFSBlockSize(51, 51);    splits = generateSplitByMinMaxSize(18, 30);    shouldSplitBlockSizeBe(splits, 3, 2, 3, 2);        shouldSplitLocationBe(splits, 0, 0, 0, 1);    shouldSplitLengthBe(splits, 30, 20, 30, 20);    /*    aaabb cccdd     */    withHDFSBlockSize(49, 49, 49);    splits = generateSplitByMinMaxSize(18, 30);    shouldSplitBlockSizeBe(splits, 3, 2, 3, 2);    shouldSplitLocationBe(splits, 0, 0, 1, 1);    shouldSplitLengthBe(splits, 30, 20, 30, 20);}
09bc81cf6f3b3282da153e12b122869288f95d65249b99f863a05e09b7df5eb1
testGenerateSplitsCrossHDFSBlockBoundaryToSatisfyMinSize
public void testGenerateSplitsCrossHDFSBlockBoundaryToSatisfyMinSize() throws Exception
{    withHDFSBlockSize(50, 50);    List<ParquetInputSplit> splits = generateSplitByMinMaxSize(25, 30);    shouldSplitBlockSizeBe(splits, 3, 3, 3, 1);    shouldSplitLocationBe(splits, 0, 0, 1, 1);    shouldSplitLengthBe(splits, 30, 30, 30, 10);}
86132081e6b75c080ab874b56bda97dff11f5f8a412358d34ae22653a84e68ff
testMultipleRowGroupsInABlockToAlignHDFSBlock
public void testMultipleRowGroupsInABlockToAlignHDFSBlock() throws Exception
{    withHDFSBlockSize(50, 50);    List<ParquetInputSplit> splits = generateSplitByMinMaxSize(10, 18);    shouldSplitBlockSizeBe(splits, 2, 2, 1, 2, 2, 1);    shouldSplitLocationBe(splits, 0, 0, 0, 1, 1, 1);    shouldSplitLengthBe(splits, 20, 20, 10, 20, 20, 10);    /*    aabbc ddeef    notice the first byte of split d is in the first hdfs block:    when adding the 6th row group, although the first byte of it is in the first hdfs block    , but the mid point of the row group is in the second hdfs block, there for a new split(d) is created including that row group     */    withHDFSBlockSize(51, 51);    splits = generateSplitByMinMaxSize(10, 18);    shouldSplitBlockSizeBe(splits, 2, 2, 1, 2, 2, 1);        shouldSplitLocationBe(splits, 0, 0, 0, 0, 1, 1);    shouldSplitLengthBe(splits, 20, 20, 10, 20, 20, 10);    /*    aabbc ddeef    same as the case where block sizes are 50 50     */    withHDFSBlockSize(49, 49);    splits = generateSplitByMinMaxSize(10, 18);    shouldSplitBlockSizeBe(splits, 2, 2, 1, 2, 2, 1);    shouldSplitLocationBe(splits, 0, 0, 0, 1, 1, 1);    shouldSplitLengthBe(splits, 20, 20, 10, 20, 20, 10);}
2cb2b8c29fc2760c915562b8d3ac4268c4018003c9027c17b546700c2a89961d
bind
public RecordFilter bind(Iterable<ColumnReader> readers)
{    return null;}
2d3e6ed1520e5f73c639881f682dacd6d93801189b6c7961946ae9c69e5bec0d
testOnlyOneKindOfFilterSupported
public void testOnlyOneKindOfFilterSupported() throws Exception
{    IntColumn foo = intColumn("foo");    FilterPredicate p = or(eq(foo, 10), eq(foo, 11));    Job job = new Job();    Configuration conf = job.getConfiguration();    ParquetInputFormat.setUnboundRecordFilter(job, DummyUnboundRecordFilter.class);    try {        ParquetInputFormat.setFilterPredicate(conf, p);        fail("this should throw");    } catch (IllegalArgumentException e) {        assertEquals("You cannot provide a FilterPredicate after providing an UnboundRecordFilter", e.getMessage());    }    job = new Job();    conf = job.getConfiguration();    ParquetInputFormat.setFilterPredicate(conf, p);    try {        ParquetInputFormat.setUnboundRecordFilter(job, DummyUnboundRecordFilter.class);        fail("this should throw");    } catch (IllegalArgumentException e) {        assertEquals("You cannot provide an UnboundRecordFilter after providing a FilterPredicate", e.getMessage());    }}
7caa361806f44cac9e5c7974776862eb920dccfa03cf323ccb919d23a345d80c
makeBlockFromStats
public static BlockMetaData makeBlockFromStats(IntStatistics stats, long valueCount)
{    BlockMetaData blockMetaData = new BlockMetaData();    ColumnChunkMetaData column = ColumnChunkMetaData.get(ColumnPath.get("foo"), PrimitiveTypeName.INT32, CompressionCodecName.GZIP, new HashSet<Encoding>(Arrays.asList(Encoding.PLAIN)), stats, 100l, 100l, valueCount, 100l, 100l);    blockMetaData.addColumn(column);    blockMetaData.setTotalByteSize(200l);    blockMetaData.setRowCount(valueCount);    return blockMetaData;}
9b7272eeda3023c16edf164fac0d5cdeec806dd44bf7da8f0cc2be6526d87502
testFooterCacheValueIsCurrent
public void testFooterCacheValueIsCurrent() throws IOException, InterruptedException
{    File tempFile = getTempFile();    FileSystem fs = FileSystem.getLocal(new Configuration());    ParquetInputFormat.FootersCacheValue cacheValue = getDummyCacheValue(tempFile, fs);    assertTrue(tempFile.setLastModified(tempFile.lastModified() + 5000));    assertFalse(cacheValue.isCurrent(new ParquetInputFormat.FileStatusWrapper(fs.getFileStatus(new Path(tempFile.getAbsolutePath())))));}
223818f1c50ac0965fd860d025d704f44820f27489cd5217ae165bf46be949d3
testFooterCacheValueIsNewer
public void testFooterCacheValueIsNewer() throws IOException
{    File tempFile = getTempFile();    FileSystem fs = FileSystem.getLocal(new Configuration());    ParquetInputFormat.FootersCacheValue cacheValue = getDummyCacheValue(tempFile, fs);    assertTrue(cacheValue.isNewerThan(null));    assertFalse(cacheValue.isNewerThan(cacheValue));    assertTrue(tempFile.setLastModified(tempFile.lastModified() + 5000));    ParquetInputFormat.FootersCacheValue newerCacheValue = getDummyCacheValue(tempFile, fs);    assertTrue(newerCacheValue.isNewerThan(cacheValue));    assertFalse(cacheValue.isNewerThan(newerCacheValue));}
1644bf1c07f63a9eb0a67f4152d4cca33d07a1f80dfb0cf852f679464ae258e8
testDeprecatedConstructorOfParquetInputSplit
public void testDeprecatedConstructorOfParquetInputSplit() throws Exception
{    withHDFSBlockSize(50, 50);    List<ParquetInputSplit> splits = generateSplitByDeprecatedConstructor(50, 50);    shouldSplitBlockSizeBe(splits, 5, 5);    shouldOneSplitRowGroupOffsetBe(splits.get(0), 0, 10, 20, 30, 40);    shouldOneSplitRowGroupOffsetBe(splits.get(1), 50, 60, 70, 80, 90);    shouldSplitLengthBe(splits, 50, 50);    shouldSplitStartBe(splits, 0, 50);}
7e29ad8a9d79c0e92c662f3be251e1d15412f03c73ca947a2b41ea19d67f195e
testGetFootersReturnsInPredictableOrder
public void testGetFootersReturnsInPredictableOrder() throws IOException
{    File tempDir = Files.createTempDir();    tempDir.deleteOnExit();        int numFiles = 10;    String url = "";    for (int i = 0; i < numFiles; i++) {        File file = new File(tempDir, String.format("part-%05d.parquet", i));        createParquetFile(file);        if (i > 0) {            url += ",";        }        url += "file:" + file.getAbsolutePath();    }    Job job = new Job();    FileInputFormat.setInputPaths(job, url);    List<Footer> footers = new ParquetInputFormat<Object>().getFooters(job);    for (int i = 0; i < numFiles; i++) {        Footer footer = footers.get(i);        File file = new File(tempDir, String.format("part-%05d.parquet", i));        assertEquals("file:" + file.getAbsolutePath(), footer.getFile().toString());    }}
00140a4714a966b8796b7c292c93ae003a1d8097a48c5f3b76848f74d411dd59
createParquetFile
private void createParquetFile(File file) throws IOException
{    Path path = new Path(file.toURI());    Configuration configuration = new Configuration();    MessageType schema = MessageTypeParser.parseMessageType("message m { required group a {required binary b;}}");    String[] columnPath = { "a", "b" };    ColumnDescriptor c1 = schema.getColumnDescription(columnPath);    byte[] bytes1 = { 0, 1, 2, 3 };    byte[] bytes2 = { 2, 3, 4, 5 };    CompressionCodecName codec = CompressionCodecName.UNCOMPRESSED;    BinaryStatistics stats = new BinaryStatistics();    ParquetFileWriter w = new ParquetFileWriter(configuration, schema, path);    w.start();    w.startBlock(3);    w.startColumn(c1, 5, codec);    w.writeDataPage(2, 4, BytesInput.from(bytes1), stats, BIT_PACKED, BIT_PACKED, PLAIN);    w.writeDataPage(3, 4, BytesInput.from(bytes1), stats, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    w.endBlock();    w.startBlock(4);    w.startColumn(c1, 7, codec);    w.writeDataPage(7, 4, BytesInput.from(bytes2), stats, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    w.endBlock();    w.end(new HashMap<String, String>());}
0597054ccde6a68aa63befe7a58d3f46de90e4cbd2f6f8ff556584b90f856a40
getTempFile
private File getTempFile() throws IOException
{    File tempFile = File.createTempFile("footer_", ".txt");    tempFile.deleteOnExit();    return tempFile;}
8f88df9233feb79268f38fbbc02822ddfcf7e398cc869b913bd543efdb85be2a
getDummyCacheValue
private ParquetInputFormat.FootersCacheValue getDummyCacheValue(File file, FileSystem fs) throws IOException
{    Path path = new Path(file.getPath());    FileStatus status = fs.getFileStatus(path);    ParquetInputFormat.FileStatusWrapper statusWrapper = new ParquetInputFormat.FileStatusWrapper(status);    ParquetMetadata mockMetadata = mock(ParquetMetadata.class);    ParquetInputFormat.FootersCacheValue cacheValue = new ParquetInputFormat.FootersCacheValue(statusWrapper, new Footer(path, mockMetadata));    assertTrue(cacheValue.isCurrent(statusWrapper));    return cacheValue;}
19db205830278ba0fb8c94ef579d50c2dcc260040d4303e45e94165691fc15d4
generateSplitByMinMaxSize
private List<ParquetInputSplit> generateSplitByMinMaxSize(long min, long max) throws IOException
{    return ClientSideMetadataSplitStrategy.generateSplits(blocks, hdfsBlocks, fileStatus, schema.toString(), extramd, min, max);}
629827cb6ebae07c5d62dea59c8a2ecf99f986e3976c76fadd17445bc8eadb4b
generateSplitByDeprecatedConstructor
private List<ParquetInputSplit> generateSplitByDeprecatedConstructor(long min, long max) throws IOException
{    List<ParquetInputSplit> splits = new ArrayList<ParquetInputSplit>();    List<ClientSideMetadataSplitStrategy.SplitInfo> splitInfos = ClientSideMetadataSplitStrategy.generateSplitInfo(blocks, hdfsBlocks, min, max);    for (ClientSideMetadataSplitStrategy.SplitInfo splitInfo : splitInfos) {        ParquetInputSplit split = new ParquetInputSplit(fileStatus.getPath(), splitInfo.hdfsBlock.getOffset(), splitInfo.hdfsBlock.getLength(), splitInfo.hdfsBlock.getHosts(), splitInfo.rowGroups, schema.toString(), null, null, extramd);        splits.add(split);    }    return splits;}
40dc71b721bdeaf4d1b09ff8691e4c087c87269b08c9a4a7fba9d6d9c7b93cce
shouldSplitStartBe
private void shouldSplitStartBe(List<ParquetInputSplit> splits, long... offsets)
{    assertEquals(message(splits), offsets.length, splits.size());    for (int i = 0; i < offsets.length; i++) {        assertEquals(message(splits) + i, offsets[i], splits.get(i).getStart());    }}
fe2b01b13085da9d971c91d230d8b9d232b9c2cb35f05eae3efadc6c26ea8d34
shouldSplitBlockSizeBe
private void shouldSplitBlockSizeBe(List<ParquetInputSplit> splits, int... sizes)
{    assertEquals(message(splits), sizes.length, splits.size());    for (int i = 0; i < sizes.length; i++) {        assertEquals(message(splits) + i, sizes[i], splits.get(i).getRowGroupOffsets().length);    }}
ff54474c4cea2e8e82498d54c7c4f89ddfd23700286835dbee7e2e9cc95efa08
shouldSplitLocationBe
private void shouldSplitLocationBe(List<ParquetInputSplit> splits, int... locations) throws IOException
{    assertEquals(message(splits), locations.length, splits.size());    for (int i = 0; i < locations.length; i++) {        int loc = locations[i];        ParquetInputSplit split = splits.get(i);        assertEquals(message(splits) + i, "[foo" + loc + ".datanode, bar" + loc + ".datanode]", Arrays.toString(split.getLocations()));    }}
354cc3e84be0f9b04ac7cb36f1f2c7b9072d34876c2ade5035bf85f41770d9b8
shouldOneSplitRowGroupOffsetBe
private void shouldOneSplitRowGroupOffsetBe(ParquetInputSplit split, int... rowGroupOffsets)
{    assertEquals(split.toString(), rowGroupOffsets.length, split.getRowGroupOffsets().length);    for (int i = 0; i < rowGroupOffsets.length; i++) {        assertEquals(split.toString(), rowGroupOffsets[i], split.getRowGroupOffsets()[i]);    }}
838851bd7a31c794c0a154a22a01da81b3445158213309e681a28079e82ff6c8
message
private String message(List<ParquetInputSplit> splits)
{    return String.valueOf(splits) + " " + Arrays.toString(hdfsBlocks) + "\n";}
66a0130989623ad8e4f99516aeb07a16cfa70260c0c2649f9d50a490796ac993
shouldSplitLengthBe
private void shouldSplitLengthBe(List<ParquetInputSplit> splits, int... lengths)
{    assertEquals(message(splits), lengths.length, splits.size());    for (int i = 0; i < lengths.length; i++) {        assertEquals(message(splits) + i, lengths[i], splits.get(i).getLength());    }}
94df67af78b59b35a705a3b9df58471c58cd13bd0c4115c7f5d9628614fdc021
withHDFSBlockSize
private void withHDFSBlockSize(long... blockSizes)
{    hdfsBlocks = new BlockLocation[blockSizes.length];    long offset = 0;    for (int i = 0; i < blockSizes.length; i++) {        long blockSize = blockSizes[i];        hdfsBlocks[i] = new BlockLocation(new String[0], new String[] { "foo" + i + ".datanode", "bar" + i + ".datanode" }, offset, blockSize);        offset += blockSize;    }    fileStatus = new FileStatus(offset, false, 2, 50, 0, new Path("hdfs://foo.namenode:1234/bar"));}
9b81a9cb6d8aaacdc6c51647799edaf7ebd1317afc528e2c0123185825a64bdb
newBlock
private BlockMetaData newBlock(long start, long compressedBlockSize)
{    BlockMetaData blockMetaData = new BlockMetaData();        long uncompressedSize = compressedBlockSize * 2;    ColumnChunkMetaData column = ColumnChunkMetaData.get(ColumnPath.get("foo"), PrimitiveTypeName.BINARY, CompressionCodecName.GZIP, new HashSet<Encoding>(Arrays.asList(Encoding.PLAIN)), new BinaryStatistics(), start, 0l, 0l, compressedBlockSize, uncompressedSize);    blockMetaData.addColumn(column);    blockMetaData.setTotalByteSize(uncompressedSize);    return blockMetaData;}
364372c8c0a17a2c3987e3f0d31a4140befe124df0e3310d5d0fe71e39f33b0f
map
protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException
{        String line = value.toString();    for (int i = 0; i < line.length(); i += 1) {        Group group = GROUP_FACTORY.newGroup();        group.add(0, Binary.fromString(UUID.randomUUID().toString()));        group.add(1, Binary.fromString(line.substring(i, i + 1)));        context.write(null, group);    }}
9f2105bc9b3a5f10fe226d8674afa9904a9ebe0cc8995ec66e42285ddeb157ef
setBytesReadCounter
public static void setBytesReadCounter(Counter bytesRead)
{    bytesReadCounter = bytesRead;}
4d4a395ad3ce11d7bd0fb02bb52b655b35f9037f87e01f0cfc88ed2afcefbdc0
map
protected void map(Void key, Group value, Context context) throws IOException, InterruptedException
{        setBytesReadCounter(ContextUtil.getCounter(context, "parquet", "bytesread"));}
60054edd71878fd848d2ed0af5b24a970f57c3003f007355a45b26c469cb96f9
testProjectionSize
public void testProjectionSize() throws Exception
{        Assume.assumeTrue(org.apache.hadoop.mapreduce.JobContext.class.isInterface());    File inputFile = temp.newFile();    FileOutputStream out = new FileOutputStream(inputFile);    out.write(FILE_CONTENT.getBytes("UTF-8"));    out.close();    File tempFolder = temp.newFolder();    tempFolder.delete();    Path tempPath = new Path(tempFolder.toURI());    File outputFolder = temp.newFile();    outputFolder.delete();    Configuration conf = new Configuration();        conf.set("parquet.read.schema", Types.buildMessage().required(BINARY).as(UTF8).named("char").named("FormatTestObject").toString());        conf.set("parquet.enable.summary-metadata", "false");    conf.set("parquet.example.schema", PARQUET_TYPE.toString());    {        Job writeJob = new Job(conf, "write");        writeJob.setInputFormatClass(TextInputFormat.class);        TextInputFormat.addInputPath(writeJob, new Path(inputFile.toString()));        writeJob.setOutputFormatClass(ExampleOutputFormat.class);        writeJob.setMapperClass(Writer.class);                writeJob.setNumReduceTasks(0);        ParquetOutputFormat.setBlockSize(writeJob, 10240);        ParquetOutputFormat.setPageSize(writeJob, 512);        ParquetOutputFormat.setDictionaryPageSize(writeJob, 1024);        ParquetOutputFormat.setEnableDictionary(writeJob, true);                ParquetOutputFormat.setMaxPaddingSize(writeJob, 1023);        ParquetOutputFormat.setOutputPath(writeJob, tempPath);        waitForJob(writeJob);    }    long bytesWritten = 0;    FileSystem fs = FileSystem.getLocal(conf);    for (FileStatus file : fs.listStatus(tempPath)) {        bytesWritten += file.getLen();    }    long bytesRead;    {        Job readJob = new Job(conf, "read");        readJob.setInputFormatClass(ExampleInputFormat.class);        TextInputFormat.addInputPath(readJob, tempPath);        readJob.setOutputFormatClass(TextOutputFormat.class);        readJob.setMapperClass(Reader.class);                readJob.setNumReduceTasks(0);        TextOutputFormat.setOutputPath(readJob, new Path(outputFolder.toString()));        waitForJob(readJob);        bytesRead = Reader.bytesReadCounter.getValue();    }    Assert.assertTrue("Should read less than 10% of the input file size", bytesRead < (bytesWritten / 10));}
1ae73b30cdadc8449c547b5e2074b79321881a77c70d90b50bd9f3775f37e746
waitForJob
private void waitForJob(Job job) throws Exception
{    job.submit();    while (!job.isComplete()) {        sleep(100);    }    if (!job.isSuccessful()) {        throw new RuntimeException("job failed " + job.getJobName());    }}
37d29e851ed2078ac990b63cf4a0099a8630e39fcc6a1d470b5df49da324219e
isSplitable
protected boolean isSplitable(JobContext context, Path filename)
{    return false;}
364372c8c0a17a2c3987e3f0d31a4140befe124df0e3310d5d0fe71e39f33b0f
map
protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException
{        String line = value.toString();    for (int i = 0; i < line.length(); i += 1) {        Group group = GROUP_FACTORY.newGroup();        group.add(0, Binary.fromString(UUID.randomUUID().toString()));        group.add(1, Binary.fromString(line.substring(i, i + 1)));        context.write(null, group);    }}
4d4a395ad3ce11d7bd0fb02bb52b655b35f9037f87e01f0cfc88ed2afcefbdc0
map
protected void map(Void key, Group value, Context context) throws IOException, InterruptedException
{    context.write(null, new Text(value.getString("char", 0)));}
3e68a4e527a415c1e85cdae8c76d252be517b60de2eb3f8743465c85f29c1974
testBasicBehaviorWithPadding
public void testBasicBehaviorWithPadding() throws Exception
{    HadoopOutputFile.getBlockFileSystems().add("file");    File inputFile = temp.newFile();    FileOutputStream out = new FileOutputStream(inputFile);    out.write(FILE_CONTENT.getBytes("UTF-8"));    out.close();    File tempFolder = temp.newFolder();    tempFolder.delete();    Path tempPath = new Path(tempFolder.toURI());    File outputFolder = temp.newFile();    outputFolder.delete();    Configuration conf = new Configuration();        conf.set("dfs.block.size", "1024");    conf.set("dfs.blocksize", "1024");    conf.set("dfs.blockSize", "1024");    conf.set("fs.local.block.size", "1024");        conf.set("fs.file.impl.disable.cache", "true");        conf.set("parquet.enable.summary-metadata", "false");    conf.set("parquet.example.schema", PARQUET_TYPE.toString());    {        Job writeJob = new Job(conf, "write");        writeJob.setInputFormatClass(TextInputFormat.class);        TextInputFormat.addInputPath(writeJob, new Path(inputFile.toString()));        writeJob.setOutputFormatClass(ParquetOutputFormat.class);        writeJob.setMapperClass(Writer.class);                writeJob.setNumReduceTasks(0);        ParquetOutputFormat.setWriteSupportClass(writeJob, GroupWriteSupport.class);        ParquetOutputFormat.setBlockSize(writeJob, 1024);        ParquetOutputFormat.setPageSize(writeJob, 512);        ParquetOutputFormat.setDictionaryPageSize(writeJob, 512);        ParquetOutputFormat.setEnableDictionary(writeJob, true);                ParquetOutputFormat.setMaxPaddingSize(writeJob, 1023);        ParquetOutputFormat.setOutputPath(writeJob, tempPath);        waitForJob(writeJob);    }        File parquetFile = getDataFile(tempFolder);    ParquetMetadata footer = ParquetFileReader.readFooter(conf, new Path(parquetFile.toString()), ParquetMetadataConverter.NO_FILTER);    for (BlockMetaData block : footer.getBlocks()) {        Assert.assertTrue("Block should start at a multiple of the block size", block.getStartingPos() % 1024 == 0);    }    {        Job readJob = new Job(conf, "read");        readJob.setInputFormatClass(NoSplits.class);        ParquetInputFormat.setReadSupportClass(readJob, GroupReadSupport.class);        TextInputFormat.addInputPath(readJob, tempPath);        readJob.setOutputFormatClass(TextOutputFormat.class);        readJob.setMapperClass(Reader.class);                readJob.setNumReduceTasks(0);        TextOutputFormat.setOutputPath(readJob, new Path(outputFolder.toString()));        waitForJob(readJob);    }    File dataFile = getDataFile(outputFolder);    Assert.assertNotNull("Should find a data file", dataFile);    StringBuilder contentBuilder = new StringBuilder();    for (String line : Files.readAllLines(dataFile.toPath(), StandardCharsets.UTF_8)) {        contentBuilder.append(line);    }    String reconstructed = contentBuilder.toString();    Assert.assertEquals("Should match written file content", FILE_CONTENT, reconstructed);    HadoopOutputFile.getBlockFileSystems().remove("file");}
1ae73b30cdadc8449c547b5e2074b79321881a77c70d90b50bd9f3775f37e746
waitForJob
private void waitForJob(Job job) throws Exception
{    job.submit();    while (!job.isComplete()) {        sleep(100);    }    if (!job.isSuccessful()) {        throw new RuntimeException("job failed " + job.getJobName());    }}
39d9e3949e21c360b0e741183a67ad69efb2c46948873b3b9856ff79d361ed52
getDataFile
private File getDataFile(File location)
{    File[] files = location.listFiles();    File dataFile = null;    if (files != null) {        for (File file : files) {            if (file.getName().startsWith("part-")) {                dataFile = file;                break;            }        }    }    return dataFile;}
2361cf30065adff4bca7c6c915b9b7fe24128a79c751897c2519dbbb0b7f3f83
isCurrent
public boolean isCurrent(String key)
{    return current;}
6c5176491f317f6a8c1782ad1a32daa0b823510cb8bf4543db1848902f3939a5
setCurrent
public void setCurrent(boolean current)
{    this.current = current;}
594f0626c8a70ddc188158cff3402a76873bd1e40ea6ee1c3f97c6fed50cfd00
isNewerThan
public boolean isNewerThan(SimpleValue otherValue)
{    return newerThan;}
3bf3512fcac5bbd972aef924f61ae208b4f6d41fbfdfec26d27a473c8e5af507
testMaxSize
public void testMaxSize()
{    LruCache<String, SimpleValue> cache = new LruCache<String, SimpleValue>(1);    String oldKey = DEFAULT_KEY;    String newKey = oldKey + "_new";    SimpleValue oldValue = new SimpleValue(true, true);    cache.put(oldKey, oldValue);    assertEquals(oldValue, cache.getCurrentValue(oldKey));    assertEquals(1, cache.size());    SimpleValue newValue = new SimpleValue(true, true);    cache.put(newKey, newValue);    assertNull(cache.getCurrentValue(oldKey));    assertEquals(newValue, cache.getCurrentValue(newKey));    assertEquals(1, cache.size());}
aa4f2bdf36c2b4a2d99737743b5bdb49b33da0d74b3f41d6bf3527311edac4e8
testOlderValueIsIgnored
public void testOlderValueIsIgnored()
{    LruCache<String, SimpleValue> cache = new LruCache<String, SimpleValue>(1);    SimpleValue currentValue = new SimpleValue(true, true);    SimpleValue notAsCurrentValue = new SimpleValue(true, false);    cache.put(DEFAULT_KEY, currentValue);    cache.put(DEFAULT_KEY, notAsCurrentValue);    assertEquals("The existing value in the cache was overwritten", currentValue, cache.getCurrentValue(DEFAULT_KEY));}
f58d4d41aba3797e465a019ef6f2e8156746de258463a5a708b7f4746f6a5bf4
testOutdatedValueIsIgnored
public void testOutdatedValueIsIgnored()
{    LruCache<String, SimpleValue> cache = new LruCache<String, SimpleValue>(1);    SimpleValue outdatedValue = new SimpleValue(false, true);    cache.put(DEFAULT_KEY, outdatedValue);    assertEquals(0, cache.size());    assertNull(cache.getCurrentValue(DEFAULT_KEY));}
024aee0fd66208cf9e509da43280f455ada02101cf613343be2942ca396ddafb
testCurrentValueOverwritesExisting
public void testCurrentValueOverwritesExisting()
{    LruCache<String, SimpleValue> cache = new LruCache<String, SimpleValue>(1);    SimpleValue currentValue = new SimpleValue(true, true);    SimpleValue notAsCurrentValue = new SimpleValue(true, false);    cache.put(DEFAULT_KEY, notAsCurrentValue);    assertEquals(1, cache.size());    cache.put(DEFAULT_KEY, currentValue);    assertEquals(1, cache.size());    assertEquals("The existing value in the cache was NOT overwritten", currentValue, cache.getCurrentValue(DEFAULT_KEY));}
a2317ad89af6c9bbbd83e2cef6a73ef81513a894a691dfd96b62b51d14ac379f
testGetOutdatedValueReturnsNull
public void testGetOutdatedValueReturnsNull()
{    LruCache<String, SimpleValue> cache = new LruCache<String, SimpleValue>(1);    SimpleValue value = new SimpleValue(true, true);    cache.put(DEFAULT_KEY, value);    assertEquals(1, cache.size());    assertEquals(value, cache.getCurrentValue(DEFAULT_KEY));    value.setCurrent(false);    assertNull("The value should not be current anymore", cache.getCurrentValue(DEFAULT_KEY));    assertEquals(0, cache.size());}
1fb42763547253cf7ffda7bc5ce98fdf5b96f7ca09e3b84b3ad86b00938441dc
testRemove
public void testRemove()
{    LruCache<String, SimpleValue> cache = new LruCache<String, SimpleValue>(1);    SimpleValue value = new SimpleValue(true, true);    cache.put(DEFAULT_KEY, value);    assertEquals(1, cache.size());    assertEquals(value, cache.getCurrentValue(DEFAULT_KEY));        assertEquals(value, cache.remove(DEFAULT_KEY));    assertNull(cache.getCurrentValue(DEFAULT_KEY));    assertEquals(0, cache.size());}
3deceb959d5bccbc206b56a7d66d87a97414b3f736f3985705b56a10bf6f42a7
testClear
public void testClear()
{    LruCache<String, SimpleValue> cache = new LruCache<String, SimpleValue>(2);    String key1 = DEFAULT_KEY + 1;    String key2 = DEFAULT_KEY + 2;    SimpleValue value = new SimpleValue(true, true);    cache.put(key1, value);    cache.put(key2, value);    assertEquals(value, cache.getCurrentValue(key1));    assertEquals(value, cache.getCurrentValue(key2));    assertEquals(2, cache.size());    cache.clear();    assertNull(cache.getCurrentValue(key1));    assertNull(cache.getCurrentValue(key2));    assertEquals(0, cache.size());}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    parquetOutputFormat = new ParquetOutputFormat(new GroupWriteSupport());    GroupWriteSupport.setSchema(MessageTypeParser.parseMessageType(writeSchema), conf);    expectedPoolSize = Math.round((double) ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getMax() * MemoryManager.DEFAULT_MEMORY_POOL_RATIO);    long rowGroupSize = expectedPoolSize / 2;    conf.setLong(ParquetOutputFormat.BLOCK_SIZE, rowGroupSize);        createWriter(0).close(null);}
220cc7bb4cc3e7215a35a1c77e0d8fedb6736b46b59a9ddec2884a061b778275
testMemoryManagerUpperLimit
public void testMemoryManagerUpperLimit()
{                long poolSize = ParquetOutputFormat.getMemoryManager().getTotalMemoryPool();    Assert.assertTrue("Pool size should be within 10% of the expected value" + " (expected = " + expectedPoolSize + " actual = " + poolSize + ")", Math.abs(expectedPoolSize - poolSize) < (long) (expectedPoolSize * 0.10));}
9f626a7202f07123db31be52474b2392f0ed3afc7244c91e0363fb96ef8119aa
testMemoryManager
public void testMemoryManager() throws Exception
{    long poolSize = ParquetOutputFormat.getMemoryManager().getTotalMemoryPool();    long rowGroupSize = poolSize / 2;    conf.setLong(ParquetOutputFormat.BLOCK_SIZE, rowGroupSize);    Assert.assertTrue("Pool should hold 2 full row groups", (2 * rowGroupSize) <= poolSize);    Assert.assertTrue("Pool should not hold 3 full row groups", poolSize < (3 * rowGroupSize));    Assert.assertEquals("Allocations should start out at 0", 0, getTotalAllocation());    RecordWriter writer1 = createWriter(1);    Assert.assertTrue("Allocations should never exceed pool size", getTotalAllocation() <= poolSize);    Assert.assertEquals("First writer should be limited by row group size", rowGroupSize, getTotalAllocation());    RecordWriter writer2 = createWriter(2);    Assert.assertTrue("Allocations should never exceed pool size", getTotalAllocation() <= poolSize);    Assert.assertEquals("Second writer should be limited by row group size", 2 * rowGroupSize, getTotalAllocation());    RecordWriter writer3 = createWriter(3);    Assert.assertTrue("Allocations should never exceed pool size", getTotalAllocation() <= poolSize);    writer1.close(null);    Assert.assertTrue("Allocations should never exceed pool size", getTotalAllocation() <= poolSize);    Assert.assertEquals("Allocations should be increased to the row group size", 2 * rowGroupSize, getTotalAllocation());    writer2.close(null);    Assert.assertTrue("Allocations should never exceed pool size", getTotalAllocation() <= poolSize);    Assert.assertEquals("Allocations should be increased to the row group size", rowGroupSize, getTotalAllocation());    writer3.close(null);    Assert.assertEquals("Allocations should be increased to the row group size", 0, getTotalAllocation());}
72777d6dc65900d24e334b944921e55de4b7661a0e252b20710d8d45e67f6307
testReallocationCallback
public void testReallocationCallback() throws Exception
{        long poolSize = ParquetOutputFormat.getMemoryManager().getTotalMemoryPool();    long rowGroupSize = poolSize / 2;    conf.setLong(ParquetOutputFormat.BLOCK_SIZE, rowGroupSize);    Assert.assertTrue("Pool should hold 2 full row groups", (2 * rowGroupSize) <= poolSize);    Assert.assertTrue("Pool should not hold 3 full row groups", poolSize < (3 * rowGroupSize));    Runnable callback = () -> counter++;        ParquetOutputFormat.getMemoryManager().registerScaleCallBack("increment-test-counter", callback);    try {        ParquetOutputFormat.getMemoryManager().registerScaleCallBack("increment-test-counter", callback);        Assert.fail("Duplicated registering callback should throw duplicates exception.");    } catch (IllegalArgumentException e) {        }        RecordWriter writer1 = createWriter(1);    RecordWriter writer2 = createWriter(2);    RecordWriter writer3 = createWriter(3);    writer1.close(null);    writer2.close(null);    writer3.close(null);        Assert.assertEquals("Allocations should be adjusted once", 1, counter);    Assert.assertEquals("Should not allow duplicate callbacks", 1, ParquetOutputFormat.getMemoryManager().getScaleCallBacks().size());}
9267841d5fc194e11a5a59b87af8fe64cab800b91a658ed50ec8a6aa6cff0259
createWriter
private RecordWriter createWriter(int index) throws Exception
{    File file = temp.newFile(String.valueOf(index) + ".parquet");    if (!file.delete()) {        throw new RuntimeException("Could not delete file: " + file);    }    RecordWriter writer = parquetOutputFormat.getRecordWriter(conf, new Path(file.toString()), CompressionCodecName.UNCOMPRESSED);    return writer;}
d36ae50fa9cc2b05d76c24da1710e448497448b56ad2f357c2cef8f38d40825e
getTotalAllocation
private long getTotalAllocation()
{    Set<InternalParquetRecordWriter> writers = ParquetOutputFormat.getMemoryManager().getWriterList().keySet();    long total = 0;    for (InternalParquetRecordWriter writer : writers) {        total += writer.getRowGroupSizeThreshold();    }    return total;}
49ab4c3a3f1fabb063574910456184a0663bcf0a914b7283a848909d6c711849
writeFile
private static void writeFile(File out, Configuration conf, boolean useSchema2) throws IOException
{    if (!useSchema2) {        GroupWriteSupport.setSchema(schema, conf);    } else {        GroupWriteSupport.setSchema(schema2, conf);    }    SimpleGroupFactory f = new SimpleGroupFactory(schema);    Map<String, String> extraMetaData = new HashMap<String, String>();    extraMetaData.put("schema_num", useSchema2 ? "2" : "1");    ParquetWriter<Group> writer = ExampleParquetWriter.builder(new Path(out.getAbsolutePath())).withConf(conf).withExtraMetaData(extraMetaData).build();    for (int i = 0; i < 1000; i++) {        Group g = f.newGroup().append("binary_field", "test" + i).append("int32_field", i).append("int64_field", (long) i).append("boolean_field", i % 2 == 0).append("float_field", (float) i).append("double_field", (double) i).append("flba_field", "foo");        if (!useSchema2) {            g = g.append("int96_field", Binary.fromConstantByteArray(new byte[12]));        }        writer.write(g);    }    writer.close();}
6c1f2060a359117fc007a732dc49a6eef223f87ec24e04ce4d66b2a7b8c2d1f6
writeFiles
private WrittenFileInfo writeFiles(boolean mixedSchemas) throws Exception
{    WrittenFileInfo info = new WrittenFileInfo();    Configuration conf = new Configuration();    info.conf = conf;    File root1 = new File(temp.getRoot(), "out1");    File root2 = new File(temp.getRoot(), "out2");    Path rootPath1 = new Path(root1.getAbsolutePath());    Path rootPath2 = new Path(root2.getAbsolutePath());    for (int i = 0; i < 10; i++) {        writeFile(new File(root1, i + ".parquet"), conf, true);    }    List<Footer> footers = ParquetFileReader.readFooters(conf, rootPath1.getFileSystem(conf).getFileStatus(rootPath1), false);    ParquetFileWriter.writeMetadataFile(conf, rootPath1, footers, JobSummaryLevel.ALL);    for (int i = 0; i < 7; i++) {        writeFile(new File(root2, i + ".parquet"), conf, !mixedSchemas);    }    footers = ParquetFileReader.readFooters(conf, rootPath2.getFileSystem(conf).getFileStatus(rootPath2), false);    ParquetFileWriter.writeMetadataFile(conf, rootPath2, footers, JobSummaryLevel.ALL);    info.commonMetaPath1 = new Path(new File(root1, ParquetFileWriter.PARQUET_COMMON_METADATA_FILE).getAbsolutePath());    info.commonMetaPath2 = new Path(new File(root2, ParquetFileWriter.PARQUET_COMMON_METADATA_FILE).getAbsolutePath());    info.metaPath1 = new Path(new File(root1, ParquetFileWriter.PARQUET_METADATA_FILE).getAbsolutePath());    info.metaPath2 = new Path(new File(root2, ParquetFileWriter.PARQUET_METADATA_FILE).getAbsolutePath());    return info;}
96d358059c5b2a8d9104a7a25405f38815005e206aa5c36fa537267d38534435
testMergeMetadataFiles
public void testMergeMetadataFiles() throws Exception
{    WrittenFileInfo info = writeFiles(false);    ParquetMetadata commonMeta1 = ParquetFileReader.readFooter(info.conf, info.commonMetaPath1, ParquetMetadataConverter.NO_FILTER);    ParquetMetadata commonMeta2 = ParquetFileReader.readFooter(info.conf, info.commonMetaPath2, ParquetMetadataConverter.NO_FILTER);    ParquetMetadata meta1 = ParquetFileReader.readFooter(info.conf, info.metaPath1, ParquetMetadataConverter.NO_FILTER);    ParquetMetadata meta2 = ParquetFileReader.readFooter(info.conf, info.metaPath2, ParquetMetadataConverter.NO_FILTER);    assertTrue(commonMeta1.getBlocks().isEmpty());    assertTrue(commonMeta2.getBlocks().isEmpty());    assertEquals(commonMeta1.getFileMetaData().getSchema(), commonMeta2.getFileMetaData().getSchema());    assertFalse(meta1.getBlocks().isEmpty());    assertFalse(meta2.getBlocks().isEmpty());    assertEquals(meta1.getFileMetaData().getSchema(), meta2.getFileMetaData().getSchema());    assertEquals(commonMeta1.getFileMetaData().getKeyValueMetaData(), commonMeta2.getFileMetaData().getKeyValueMetaData());    assertEquals(meta1.getFileMetaData().getKeyValueMetaData(), meta2.getFileMetaData().getKeyValueMetaData());        Path mergedOut = new Path(new File(temp.getRoot(), "merged_meta").getAbsolutePath());    Path mergedCommonOut = new Path(new File(temp.getRoot(), "merged_common_meta").getAbsolutePath());    ParquetFileWriter.writeMergedMetadataFile(Arrays.asList(info.metaPath1, info.metaPath2), mergedOut, info.conf);    ParquetFileWriter.writeMergedMetadataFile(Arrays.asList(info.commonMetaPath1, info.commonMetaPath2), mergedCommonOut, info.conf);    ParquetMetadata mergedMeta = ParquetFileReader.readFooter(info.conf, mergedOut, ParquetMetadataConverter.NO_FILTER);    ParquetMetadata mergedCommonMeta = ParquetFileReader.readFooter(info.conf, mergedCommonOut, ParquetMetadataConverter.NO_FILTER);        assertEquals(meta1.getBlocks().size() + meta2.getBlocks().size(), mergedMeta.getBlocks().size());    assertTrue(mergedCommonMeta.getBlocks().isEmpty());    assertEquals(meta1.getFileMetaData().getSchema(), mergedMeta.getFileMetaData().getSchema());    assertEquals(commonMeta1.getFileMetaData().getSchema(), mergedCommonMeta.getFileMetaData().getSchema());    assertEquals(meta1.getFileMetaData().getKeyValueMetaData(), mergedMeta.getFileMetaData().getKeyValueMetaData());    assertEquals(commonMeta1.getFileMetaData().getKeyValueMetaData(), mergedCommonMeta.getFileMetaData().getKeyValueMetaData());}
d0282c8f507f88193490b289a706579a0daa59e4d363254e15adb9aeb3e2e9be
testThrowsWhenIncompatible
public void testThrowsWhenIncompatible() throws Exception
{    WrittenFileInfo info = writeFiles(true);    Path mergedOut = new Path(new File(temp.getRoot(), "merged_meta").getAbsolutePath());    Path mergedCommonOut = new Path(new File(temp.getRoot(), "merged_common_meta").getAbsolutePath());    try {        ParquetFileWriter.writeMergedMetadataFile(Arrays.asList(info.metaPath1, info.metaPath2), mergedOut, info.conf);        fail("this should throw");    } catch (RuntimeException e) {        boolean eq1 = e.getMessage().equals("could not merge metadata: key schema_num has conflicting values: [2, 1]");        boolean eq2 = e.getMessage().equals("could not merge metadata: key schema_num has conflicting values: [1, 2]");        assertEquals(eq1 || eq2, true);    }    try {        ParquetFileWriter.writeMergedMetadataFile(Arrays.asList(info.commonMetaPath1, info.commonMetaPath2), mergedCommonOut, info.conf);        fail("this should throw");    } catch (RuntimeException e) {        boolean eq1 = e.getMessage().equals("could not merge metadata: key schema_num has conflicting values: [2, 1]");        boolean eq2 = e.getMessage().equals("could not merge metadata: key schema_num has conflicting values: [1, 2]");        assertEquals(eq1 || eq2, true);    }}
468aea6ad8e09e5b9bf532981d69a4fceea34a45410040e22cce7f92c5924905
getString
private String getString(int minSize, int maxSize)
{    int size = random.nextInt(maxSize - minSize) + minSize;    StringBuilder builder = new StringBuilder(size);    for (int i = 0; i < size; ++i) {        builder.append(ALPHABET.charAt(random.nextInt(ALPHABET.length())));    }    return builder.toString();}
badce94fdf64d41c13a154a323414407e74be914ac5abb2109bd3c557e0c5a93
get
public Group get()
{    Group group = factory.newGroup();    group.add("id", random.nextInt());    group.add("name", getString(NAME_MIN_SIZE, NAME_MAX_SIZE));    Group phoneNumbers = group.addGroup("phone_numbers");    for (int i = 0, n = random.nextInt(PHONE_NUMBERS_MAX_SIZE); i < n; ++i) {        Group phoneNumber = phoneNumbers.addGroup(0);        phoneNumber.add(0, random.nextLong() % (MAX_PHONE_NUMBER - MIN_PHONE_NUMBER) + MIN_PHONE_NUMBER);    }    if (random.nextDouble() >= COMMENT_NULL_RATIO) {        group.add("comment", getString(0, COMMENT_MAX_SIZE));    }    return group;}
6fd7c0c9bb823f2c03ede1ac2744cf4aa97f36ce76cb0baae53b14e12fac5794
createTmpDir
public static void createTmpDir()
{    tmpDir = new Path(Files.createTempDir().getAbsolutePath().toString());}
4ef73dc9aa5da11245bd210d6fd3e3cff5d92fb22b0da3fe027fd147fbc7b3cd
deleteTmpDir
public static void deleteTmpDir() throws IOException
{    tmpDir.getFileSystem(new Configuration()).delete(tmpDir, true);}
e7894ddf80330b3852e025cfd87e3079ee4df7c977cbe02d22da5e74be71d414
writeFile
private Path writeFile(Iterable<Group> data) throws IOException
{    Path file = new Path(tmpDir, "testMultipleReadWrite_" + UUID.randomUUID() + ".parquet");    try (ParquetWriter<Group> writer = ExampleParquetWriter.builder(file).config(GroupWriteSupport.PARQUET_EXAMPLE_SCHEMA, SCHEMA.toString()).build()) {        for (Group group : data) {            writer.write(group);        }    }    return file;}
c2418badf8e1826fc5b8b2cd8f3d0a775160e7ba48e7db235eaaea688e9565a7
validateFile
private void validateFile(Path file, List<Group> data) throws IOException
{    try (ParquetReader<Group> reader = ParquetReader.builder(new GroupReadSupport(), file).build()) {        for (Group group : data) {            assertEquals(group.toString(), reader.read().toString());        }    }}
2008b1ab3591d946356efc44a4f267e370671fe86c0591f03adb486970594e39
validateFile
private void validateFile(Path file, Filter filter, Stream<Group> data) throws IOException
{    try (ParquetReader<Group> reader = ParquetReader.builder(new GroupReadSupport(), file).withFilter(filter).build()) {        for (Iterator<Group> it = data.iterator(); it.hasNext(); ) {            assertEquals(it.next().toString(), reader.read().toString());        }    }}
7794e410f86c399d0ab06ea3e348e0c57ecaad0a08b66d774313cf3048db0ffa
validateFileWithIdFilter
private void validateFileWithIdFilter(Path file, List<Group> data) throws IOException
{    validateFile(file, FilterCompat.get(eq(intColumn("id"), 0)), data.stream().filter(group -> group.getInteger("id", 0) == 0));}
2867def9d00c5011d8fccbeef141014da5a95ac780c1f76c16a822cfb8f07029
validateFileWithCommentFilter
private void validateFileWithCommentFilter(Path file, List<Group> data) throws IOException
{    validateFile(file, FilterCompat.get(eq(binaryColumn("comment"), null)), data.stream().filter(group -> group.getFieldRepetitionCount("comment") == 0));}
2ab776fe122fdd8f5d6125d7e54aa055aa428131953fe47f6d16b79f55ba68d8
validateFileWithComplexFilter
private void validateFileWithComplexFilter(Path file, List<Group> data) throws IOException
{    Binary binaryValueB = fromString("b");    Filter filter = FilterCompat.get(and(gtEq(intColumn("id"), 0), and(lt(binaryColumn("name"), binaryValueB), notEq(binaryColumn("comment"), null))));    Predicate<Group> predicate = group -> group.getInteger("id", 0) >= 0 && BINARY_COMPARATOR.compare(group.getBinary("name", 0), binaryValueB) < 0 && group.getFieldRepetitionCount("comment") > 0;    validateFile(file, filter, data.stream().filter(predicate));}
d0d0eb60607d6f566ebc1b60cd70f0c70f1ea336529e2a3453377b4693bea804
testWriteRead
public void testWriteRead() throws Throwable
{        List<List<Group>> data = new ArrayList<>();    for (int i = 0; i < 10; ++i) {        data.add(Stream.generate(new DataGenerator(i)).limit(10000 - i * 1000).collect(Collectors.toList()));    }        List<Future<Path>> futureFiles = new ArrayList<>();    ExecutorService exec = Executors.newFixedThreadPool(6);    for (List<Group> d : data) {        futureFiles.add(exec.submit(() -> {            Path file = writeFile(d);            validateFile(file, d);            return file;        }));    }    List<Path> files = new ArrayList<>();    for (Future<Path> future : futureFiles) {        try {            files.add(future.get());        } catch (ExecutionException e) {            throw e.getCause();        }    }        List<Future<?>> futures = new ArrayList<>();    for (int i = 0; i < 10; ++i) {        Path file = files.get(i);        List<Group> d = data.get(i);        futures.add(exec.submit(() -> {            validateFileWithIdFilter(file, d);            return null;        }));        futures.add(exec.submit(() -> {            validateFileWithCommentFilter(file, d);            return null;        }));        futures.add(exec.submit(() -> {            validateFileWithComplexFilter(file, d);            return null;        }));    }    for (Future<?> future : futures) {        try {            future.get();        } catch (ExecutionException e) {            throw e.getCause();        }    }}
d6d9d97977d1a11f2cc928f006950429a4d4a1b21925c28f8b48916ee332c7d0
testWriteMode
public void testWriteMode() throws Exception
{    File testFile = temp.newFile();    MessageType schema = MessageTypeParser.parseMessageType("message m { required group a {required binary b;} required group " + "c { required int64 d; }}");    Configuration conf = new Configuration();    ParquetFileWriter writer = null;    boolean exceptionThrown = false;    Path path = new Path(testFile.toURI());    try {        writer = new ParquetFileWriter(conf, schema, path, ParquetFileWriter.Mode.CREATE);    } catch (IOException ioe1) {        exceptionThrown = true;    }    assertTrue(exceptionThrown);    exceptionThrown = false;    try {        writer = new ParquetFileWriter(conf, schema, path, OVERWRITE);    } catch (IOException ioe2) {        exceptionThrown = true;    }    assertTrue(!exceptionThrown);    testFile.delete();}
90ee6962d1275dfbf80ccb9c6495b1e47c40025aebd2eb15c60b75e4bd8db4e2
testWriteRead
public void testWriteRead() throws Exception
{    File testFile = temp.newFile();    testFile.delete();    Path path = new Path(testFile.toURI());    Configuration configuration = new Configuration();    ParquetFileWriter w = new ParquetFileWriter(configuration, SCHEMA, path);    w.start();    w.startBlock(3);    w.startColumn(C1, 5, CODEC);    long c1Starts = w.getPos();    w.writeDataPage(2, 4, BytesInput.from(BYTES1), EMPTY_STATS, BIT_PACKED, BIT_PACKED, PLAIN);    w.writeDataPage(3, 4, BytesInput.from(BYTES1), EMPTY_STATS, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    long c1Ends = w.getPos();    w.startColumn(C2, 6, CODEC);    long c2Starts = w.getPos();    w.writeDataPage(2, 4, BytesInput.from(BYTES2), EMPTY_STATS, BIT_PACKED, BIT_PACKED, PLAIN);    w.writeDataPage(3, 4, BytesInput.from(BYTES2), EMPTY_STATS, BIT_PACKED, BIT_PACKED, PLAIN);    w.writeDataPage(1, 4, BytesInput.from(BYTES2), EMPTY_STATS, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    long c2Ends = w.getPos();    w.endBlock();    w.startBlock(4);    w.startColumn(C1, 7, CODEC);    w.writeDataPage(7, 4, BytesInput.from(BYTES3), EMPTY_STATS, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    w.startColumn(C2, 8, CODEC);    w.writeDataPage(8, 4, BytesInput.from(BYTES4), EMPTY_STATS, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    w.endBlock();    w.end(new HashMap<String, String>());    ParquetMetadata readFooter = ParquetFileReader.readFooter(configuration, path);    assertEquals("footer: " + readFooter, 2, readFooter.getBlocks().size());    assertEquals(c1Ends - c1Starts, readFooter.getBlocks().get(0).getColumns().get(0).getTotalSize());    assertEquals(c2Ends - c2Starts, readFooter.getBlocks().get(0).getColumns().get(1).getTotalSize());    assertEquals(c2Ends - c1Starts, readFooter.getBlocks().get(0).getTotalByteSize());    HashSet<Encoding> expectedEncoding = new HashSet<Encoding>();    expectedEncoding.add(PLAIN);    expectedEncoding.add(BIT_PACKED);    assertEquals(expectedEncoding, readFooter.getBlocks().get(0).getColumns().get(0).getEncodings());    {                ParquetFileReader r = new ParquetFileReader(configuration, readFooter.getFileMetaData(), path, Arrays.asList(readFooter.getBlocks().get(0)), Arrays.asList(SCHEMA.getColumnDescription(PATH1)));        PageReadStore pages = r.readNextRowGroup();        assertEquals(3, pages.getRowCount());        validateContains(SCHEMA, pages, PATH1, 2, BytesInput.from(BYTES1));        validateContains(SCHEMA, pages, PATH1, 3, BytesInput.from(BYTES1));        assertNull(r.readNextRowGroup());    }    {                ParquetFileReader r = new ParquetFileReader(configuration, readFooter.getFileMetaData(), path, readFooter.getBlocks(), Arrays.asList(SCHEMA.getColumnDescription(PATH1), SCHEMA.getColumnDescription(PATH2)));        PageReadStore pages = r.readNextRowGroup();        assertEquals(3, pages.getRowCount());        validateContains(SCHEMA, pages, PATH1, 2, BytesInput.from(BYTES1));        validateContains(SCHEMA, pages, PATH1, 3, BytesInput.from(BYTES1));        validateContains(SCHEMA, pages, PATH2, 2, BytesInput.from(BYTES2));        validateContains(SCHEMA, pages, PATH2, 3, BytesInput.from(BYTES2));        validateContains(SCHEMA, pages, PATH2, 1, BytesInput.from(BYTES2));        pages = r.readNextRowGroup();        assertEquals(4, pages.getRowCount());        validateContains(SCHEMA, pages, PATH1, 7, BytesInput.from(BYTES3));        validateContains(SCHEMA, pages, PATH2, 8, BytesInput.from(BYTES4));        assertNull(r.readNextRowGroup());    }    PrintFooter.main(new String[] { path.toString() });}
45cada25a2bb216f8c017349c0e9c167d26b5a99ad2a9133e01529635cf82597
testAlignmentWithPadding
public void testAlignmentWithPadding() throws Exception
{    File testFile = temp.newFile();    Path path = new Path(testFile.toURI());    Configuration conf = new Configuration();        conf.setBoolean(ParquetOutputFormat.PAGE_WRITE_CHECKSUM_ENABLED, false);        ParquetFileWriter w = new ParquetFileWriter(conf, SCHEMA, path, 120, 60);    w.start();    w.startBlock(3);    w.startColumn(C1, 5, CODEC);    long c1Starts = w.getPos();    w.writeDataPage(2, 4, BytesInput.from(BYTES1), EMPTY_STATS, BIT_PACKED, BIT_PACKED, PLAIN);    w.writeDataPage(3, 4, BytesInput.from(BYTES1), EMPTY_STATS, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    long c1Ends = w.getPos();    w.startColumn(C2, 6, CODEC);    long c2Starts = w.getPos();    w.writeDataPage(2, 4, BytesInput.from(BYTES2), EMPTY_STATS, BIT_PACKED, BIT_PACKED, PLAIN);    w.writeDataPage(3, 4, BytesInput.from(BYTES2), EMPTY_STATS, BIT_PACKED, BIT_PACKED, PLAIN);    w.writeDataPage(1, 4, BytesInput.from(BYTES2), EMPTY_STATS, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    long c2Ends = w.getPos();    w.endBlock();        long firstRowGroupEnds = w.getPos();    w.startBlock(4);    w.startColumn(C1, 7, CODEC);    w.writeDataPage(7, 4, BytesInput.from(BYTES3), EMPTY_STATS, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    w.startColumn(C2, 8, CODEC);    w.writeDataPage(8, 4, BytesInput.from(BYTES4), EMPTY_STATS, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    w.endBlock();    long secondRowGroupEnds = w.getPos();    w.end(new HashMap<String, String>());    FileSystem fs = path.getFileSystem(conf);    long fileLen = fs.getFileStatus(path).getLen();    FSDataInputStream data = fs.open(path);        data.seek(fileLen - 8);    long footerLen = BytesUtils.readIntLittleEndian(data);    long startFooter = fileLen - footerLen - 8;    assertEquals("Footer should start after second row group without padding", secondRowGroupEnds, startFooter);    ParquetMetadata readFooter = ParquetFileReader.readFooter(conf, path);    assertEquals("footer: " + readFooter, 2, readFooter.getBlocks().size());    assertEquals(c1Ends - c1Starts, readFooter.getBlocks().get(0).getColumns().get(0).getTotalSize());    assertEquals(c2Ends - c2Starts, readFooter.getBlocks().get(0).getColumns().get(1).getTotalSize());    assertEquals(c2Ends - c1Starts, readFooter.getBlocks().get(0).getTotalByteSize());    HashSet<Encoding> expectedEncoding = new HashSet<Encoding>();    expectedEncoding.add(PLAIN);    expectedEncoding.add(BIT_PACKED);    assertEquals(expectedEncoding, readFooter.getBlocks().get(0).getColumns().get(0).getEncodings());        assertEquals("First row group should start after magic", 4, readFooter.getBlocks().get(0).getStartingPos());    assertTrue("First row group should end before the block size (120)", firstRowGroupEnds < 120);    assertEquals("Second row group should start at the block size", 120, readFooter.getBlocks().get(1).getStartingPos());    {                ParquetFileReader r = new ParquetFileReader(conf, readFooter.getFileMetaData(), path, Arrays.asList(readFooter.getBlocks().get(0)), Arrays.asList(SCHEMA.getColumnDescription(PATH1)));        PageReadStore pages = r.readNextRowGroup();        assertEquals(3, pages.getRowCount());        validateContains(SCHEMA, pages, PATH1, 2, BytesInput.from(BYTES1));        validateContains(SCHEMA, pages, PATH1, 3, BytesInput.from(BYTES1));        assertNull(r.readNextRowGroup());    }    {                ParquetFileReader r = new ParquetFileReader(conf, readFooter.getFileMetaData(), path, readFooter.getBlocks(), Arrays.asList(SCHEMA.getColumnDescription(PATH1), SCHEMA.getColumnDescription(PATH2)));        PageReadStore pages = r.readNextRowGroup();        assertEquals(3, pages.getRowCount());        validateContains(SCHEMA, pages, PATH1, 2, BytesInput.from(BYTES1));        validateContains(SCHEMA, pages, PATH1, 3, BytesInput.from(BYTES1));        validateContains(SCHEMA, pages, PATH2, 2, BytesInput.from(BYTES2));        validateContains(SCHEMA, pages, PATH2, 3, BytesInput.from(BYTES2));        validateContains(SCHEMA, pages, PATH2, 1, BytesInput.from(BYTES2));        pages = r.readNextRowGroup();        assertEquals(4, pages.getRowCount());        validateContains(SCHEMA, pages, PATH1, 7, BytesInput.from(BYTES3));        validateContains(SCHEMA, pages, PATH2, 8, BytesInput.from(BYTES4));        assertNull(r.readNextRowGroup());    }    PrintFooter.main(new String[] { path.toString() });}
b06a6d6e4b74c27f585f62bc611d61bfd59faa3090e0a8fa53498ec057c0abe9
testAlignmentWithNoPaddingNeeded
public void testAlignmentWithNoPaddingNeeded() throws Exception
{    File testFile = temp.newFile();    Path path = new Path(testFile.toURI());    Configuration conf = new Configuration();        conf.setBoolean(ParquetOutputFormat.PAGE_WRITE_CHECKSUM_ENABLED, false);        ParquetFileWriter w = new ParquetFileWriter(conf, SCHEMA, path, 100, 50);    w.start();    w.startBlock(3);    w.startColumn(C1, 5, CODEC);    long c1Starts = w.getPos();    w.writeDataPage(2, 4, BytesInput.from(BYTES1), EMPTY_STATS, BIT_PACKED, BIT_PACKED, PLAIN);    w.writeDataPage(3, 4, BytesInput.from(BYTES1), EMPTY_STATS, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    long c1Ends = w.getPos();    w.startColumn(C2, 6, CODEC);    long c2Starts = w.getPos();    w.writeDataPage(2, 4, BytesInput.from(BYTES2), EMPTY_STATS, BIT_PACKED, BIT_PACKED, PLAIN);    w.writeDataPage(3, 4, BytesInput.from(BYTES2), EMPTY_STATS, BIT_PACKED, BIT_PACKED, PLAIN);    w.writeDataPage(1, 4, BytesInput.from(BYTES2), EMPTY_STATS, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    long c2Ends = w.getPos();    w.endBlock();        long firstRowGroupEnds = w.getPos();    w.startBlock(4);    w.startColumn(C1, 7, CODEC);    w.writeDataPage(7, 4, BytesInput.from(BYTES3), EMPTY_STATS, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    w.startColumn(C2, 8, CODEC);    w.writeDataPage(8, 4, BytesInput.from(BYTES4), EMPTY_STATS, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    w.endBlock();    long secondRowGroupEnds = w.getPos();    w.end(new HashMap<String, String>());    FileSystem fs = path.getFileSystem(conf);    long fileLen = fs.getFileStatus(path).getLen();    FSDataInputStream data = fs.open(path);        data.seek(fileLen - 8);    long footerLen = BytesUtils.readIntLittleEndian(data);    long startFooter = fileLen - footerLen - 8;    assertEquals("Footer should start after second row group without padding", secondRowGroupEnds, startFooter);    ParquetMetadata readFooter = ParquetFileReader.readFooter(conf, path);    assertEquals("footer: " + readFooter, 2, readFooter.getBlocks().size());    assertEquals(c1Ends - c1Starts, readFooter.getBlocks().get(0).getColumns().get(0).getTotalSize());    assertEquals(c2Ends - c2Starts, readFooter.getBlocks().get(0).getColumns().get(1).getTotalSize());    assertEquals(c2Ends - c1Starts, readFooter.getBlocks().get(0).getTotalByteSize());    HashSet<Encoding> expectedEncoding = new HashSet<Encoding>();    expectedEncoding.add(PLAIN);    expectedEncoding.add(BIT_PACKED);    assertEquals(expectedEncoding, readFooter.getBlocks().get(0).getColumns().get(0).getEncodings());        assertEquals("First row group should start after magic", 4, readFooter.getBlocks().get(0).getStartingPos());    assertTrue("First row group should end before the block size (120)", firstRowGroupEnds > 100);    assertEquals("Second row group should start after no padding", 109, readFooter.getBlocks().get(1).getStartingPos());    {                ParquetFileReader r = new ParquetFileReader(conf, readFooter.getFileMetaData(), path, Arrays.asList(readFooter.getBlocks().get(0)), Arrays.asList(SCHEMA.getColumnDescription(PATH1)));        PageReadStore pages = r.readNextRowGroup();        assertEquals(3, pages.getRowCount());        validateContains(SCHEMA, pages, PATH1, 2, BytesInput.from(BYTES1));        validateContains(SCHEMA, pages, PATH1, 3, BytesInput.from(BYTES1));        assertNull(r.readNextRowGroup());    }    {                ParquetFileReader r = new ParquetFileReader(conf, readFooter.getFileMetaData(), path, readFooter.getBlocks(), Arrays.asList(SCHEMA.getColumnDescription(PATH1), SCHEMA.getColumnDescription(PATH2)));        PageReadStore pages = r.readNextRowGroup();        assertEquals(3, pages.getRowCount());        validateContains(SCHEMA, pages, PATH1, 2, BytesInput.from(BYTES1));        validateContains(SCHEMA, pages, PATH1, 3, BytesInput.from(BYTES1));        validateContains(SCHEMA, pages, PATH2, 2, BytesInput.from(BYTES2));        validateContains(SCHEMA, pages, PATH2, 3, BytesInput.from(BYTES2));        validateContains(SCHEMA, pages, PATH2, 1, BytesInput.from(BYTES2));        pages = r.readNextRowGroup();        assertEquals(4, pages.getRowCount());        validateContains(SCHEMA, pages, PATH1, 7, BytesInput.from(BYTES3));        validateContains(SCHEMA, pages, PATH2, 8, BytesInput.from(BYTES4));        assertNull(r.readNextRowGroup());    }    PrintFooter.main(new String[] { path.toString() });}
8883cae499782a1ce86886556aadedd679969f05cb22d141c08beedeef5a4d9d
testConvertToThriftStatistics
public void testConvertToThriftStatistics() throws Exception
{    long[] longArray = new long[] { 39L, 99L, 12L, 1000L, 65L, 542L, 2533461316L, -253346131996L, Long.MAX_VALUE, Long.MIN_VALUE };    LongStatistics parquetMRstats = new LongStatistics();    for (long l : longArray) {        parquetMRstats.updateStats(l);    }    final String createdBy = "parquet-mr version 1.8.0 (build d4d5a07ec9bd262ca1e93c309f1d7d4a74ebda4c)";    Statistics thriftStats = org.apache.parquet.format.converter.ParquetMetadataConverter.toParquetStatistics(parquetMRstats);    LongStatistics convertedBackStats = (LongStatistics) org.apache.parquet.format.converter.ParquetMetadataConverter.fromParquetStatistics(createdBy, thriftStats, PrimitiveTypeName.INT64);    assertEquals(parquetMRstats.getMax(), convertedBackStats.getMax());    assertEquals(parquetMRstats.getMin(), convertedBackStats.getMin());    assertEquals(parquetMRstats.getNumNulls(), convertedBackStats.getNumNulls());}
b42e46d0aea6c1035c52e0eed1db4bbc73ae18122c2e7c56abc275ff2dcd8722
testWriteReadStatistics
public void testWriteReadStatistics() throws Exception
{        Assume.assumeTrue(!shouldIgnoreStatistics(Version.FULL_VERSION, BINARY));    File testFile = temp.newFile();    testFile.delete();    Path path = new Path(testFile.toURI());    Configuration configuration = new Configuration();    configuration.setBoolean("parquet.strings.signed-min-max.enabled", true);    MessageType schema = MessageTypeParser.parseMessageType("message m { required group a {required binary b (UTF8);} required group c { required int64 d; }}");    String[] path1 = { "a", "b" };    ColumnDescriptor c1 = schema.getColumnDescription(path1);    String[] path2 = { "c", "d" };    ColumnDescriptor c2 = schema.getColumnDescription(path2);    byte[] bytes1 = { 0, 1, 2, 3 };    byte[] bytes2 = { 1, 2, 3, 4 };    byte[] bytes3 = { 2, 3, 4, 5 };    byte[] bytes4 = { 3, 4, 5, 6 };    CompressionCodecName codec = CompressionCodecName.UNCOMPRESSED;    BinaryStatistics statsB1C1P1 = new BinaryStatistics();    BinaryStatistics statsB1C1P2 = new BinaryStatistics();    LongStatistics statsB1C2P1 = new LongStatistics();    LongStatistics statsB1C2P2 = new LongStatistics();    BinaryStatistics statsB2C1P1 = new BinaryStatistics();    LongStatistics statsB2C2P1 = new LongStatistics();    statsB1C1P1.setMinMax(Binary.fromString("s"), Binary.fromString("z"));    statsB1C1P2.setMinMax(Binary.fromString("a"), Binary.fromString("b"));    statsB1C2P1.setMinMax(2l, 10l);    statsB1C2P2.setMinMax(-6l, 4l);    statsB2C1P1.setMinMax(Binary.fromString("d"), Binary.fromString("e"));    statsB2C2P1.setMinMax(11l, 122l);    ParquetFileWriter w = new ParquetFileWriter(configuration, schema, path);    w.start();    w.startBlock(3);    w.startColumn(c1, 5, codec);    w.writeDataPage(2, 4, BytesInput.from(bytes1), statsB1C1P1, BIT_PACKED, BIT_PACKED, PLAIN);    w.writeDataPage(3, 4, BytesInput.from(bytes1), statsB1C1P2, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    w.startColumn(c2, 6, codec);    w.writeDataPage(3, 4, BytesInput.from(bytes2), statsB1C2P1, BIT_PACKED, BIT_PACKED, PLAIN);    w.writeDataPage(1, 4, BytesInput.from(bytes2), statsB1C2P2, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    w.endBlock();    w.startBlock(4);    w.startColumn(c1, 7, codec);    w.writeDataPage(7, 4, BytesInput.from(bytes3), statsB2C1P1, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    w.startColumn(c2, 8, codec);    w.writeDataPage(8, 4, BytesInput.from(bytes4), statsB2C2P1, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    w.endBlock();    w.end(new HashMap<String, String>());    ParquetMetadata readFooter = ParquetFileReader.readFooter(configuration, path);    for (BlockMetaData block : readFooter.getBlocks()) {        for (ColumnChunkMetaData col : block.getColumns()) {            col.getPath();        }    }        BinaryStatistics bs1 = new BinaryStatistics();    bs1.setMinMax(Binary.fromString("a"), Binary.fromString("z"));    LongStatistics ls1 = new LongStatistics();    ls1.setMinMax(-6l, 10l);    BinaryStatistics bs2 = new BinaryStatistics();    bs2.setMinMax(Binary.fromString("d"), Binary.fromString("e"));    LongStatistics ls2 = new LongStatistics();    ls2.setMinMax(11l, 122l);    {                BinaryStatistics bsout = (BinaryStatistics) readFooter.getBlocks().get(0).getColumns().get(0).getStatistics();        String str = new String(bsout.getMaxBytes());        String str2 = new String(bsout.getMinBytes());        TestUtils.assertStatsValuesEqual(bs1, readFooter.getBlocks().get(0).getColumns().get(0).getStatistics());        TestUtils.assertStatsValuesEqual(ls1, readFooter.getBlocks().get(0).getColumns().get(1).getStatistics());    }    {                TestUtils.assertStatsValuesEqual(bs2, readFooter.getBlocks().get(1).getColumns().get(0).getStatistics());        TestUtils.assertStatsValuesEqual(ls2, readFooter.getBlocks().get(1).getColumns().get(1).getStatistics());    }}
d52aef1fa758462beb33e95414559606461616b095bc8639940c36de2c9f21fd
testMetaDataFile
public void testMetaDataFile() throws Exception
{    File testDir = temp.newFolder();    Path testDirPath = new Path(testDir.toURI());    Configuration configuration = new Configuration();    final FileSystem fs = testDirPath.getFileSystem(configuration);    enforceEmptyDir(configuration, testDirPath);    MessageType schema = MessageTypeParser.parseMessageType("message m { required group a {required binary b;} required group c { required int64 d; }}");    createFile(configuration, new Path(testDirPath, "part0"), schema);    createFile(configuration, new Path(testDirPath, "part1"), schema);    createFile(configuration, new Path(testDirPath, "part2"), schema);    FileStatus outputStatus = fs.getFileStatus(testDirPath);    List<Footer> footers = ParquetFileReader.readFooters(configuration, outputStatus, false);    validateFooters(footers);    ParquetFileWriter.writeMetadataFile(configuration, testDirPath, footers, JobSummaryLevel.ALL);    footers = ParquetFileReader.readFooters(configuration, outputStatus, false);    validateFooters(footers);    footers = ParquetFileReader.readFooters(configuration, fs.getFileStatus(new Path(testDirPath, "part0")), false);    assertEquals(1, footers.size());    final FileStatus metadataFile = fs.getFileStatus(new Path(testDirPath, ParquetFileWriter.PARQUET_METADATA_FILE));    final FileStatus metadataFileLight = fs.getFileStatus(new Path(testDirPath, ParquetFileWriter.PARQUET_COMMON_METADATA_FILE));    final List<Footer> metadata = ParquetFileReader.readSummaryFile(configuration, metadataFile);    validateFooters(metadata);    footers = ParquetFileReader.readAllFootersInParallelUsingSummaryFiles(configuration, Arrays.asList(fs.listStatus(testDirPath, HiddenFileFilter.INSTANCE)), false);    validateFooters(footers);    fs.delete(metadataFile.getPath(), false);    fs.delete(metadataFileLight.getPath(), false);    footers = ParquetFileReader.readAllFootersInParallelUsingSummaryFiles(configuration, Arrays.asList(fs.listStatus(testDirPath)), false);    validateFooters(footers);}
7d726edf7d8675f0aa7401179e0814aedfbb254e4d5e9d80f80569a33b4da543
testWriteReadStatisticsAllNulls
public void testWriteReadStatisticsAllNulls() throws Exception
{        Assume.assumeTrue(!shouldIgnoreStatistics(Version.FULL_VERSION, BINARY));    File testFile = temp.newFile();    testFile.delete();    writeSchema = "message example {\n" + "required binary content (UTF8);\n" + "}";    Path path = new Path(testFile.toURI());    MessageType schema = MessageTypeParser.parseMessageType(writeSchema);    Configuration configuration = new Configuration();    configuration.setBoolean("parquet.strings.signed-min-max.enabled", true);    GroupWriteSupport.setSchema(schema, configuration);    ParquetWriter<Group> writer = new ParquetWriter<Group>(path, configuration, new GroupWriteSupport());    Group r1 = new SimpleGroup(schema);    writer.write(r1);    writer.close();    ParquetMetadata readFooter = ParquetFileReader.readFooter(configuration, path);        org.apache.parquet.column.statistics.Statistics stats = readFooter.getBlocks().get(0).getColumns().get(0).getStatistics();    assertFalse("is empty: " + stats, stats.isEmpty());        assertEquals("nulls: " + stats, 1, stats.getNumNulls());}
e8d82abfa1808657206bdfb6f0a47e6390e073bdfeacac4a55b749a0c8d76f7e
validateFooters
private void validateFooters(final List<Footer> metadata)
{    LOG.debug("{}", metadata);    assertEquals(String.valueOf(metadata), 3, metadata.size());    for (Footer footer : metadata) {        final File file = new File(footer.getFile().toUri());        assertTrue(file.getName(), file.getName().startsWith("part"));        assertTrue(file.getPath(), file.exists());        final ParquetMetadata parquetMetadata = footer.getParquetMetadata();        assertEquals(2, parquetMetadata.getBlocks().size());        final Map<String, String> keyValueMetaData = parquetMetadata.getFileMetaData().getKeyValueMetaData();        assertEquals("bar", keyValueMetaData.get("foo"));        assertEquals(footer.getFile().getName(), keyValueMetaData.get(footer.getFile().getName()));    }}
3a82ef0b4d80fb788d7ad731e3e5a5035bf6cc189c9544e924f58752354547d5
createFile
private void createFile(Configuration configuration, Path path, MessageType schema) throws IOException
{    String[] path1 = { "a", "b" };    ColumnDescriptor c1 = schema.getColumnDescription(path1);    String[] path2 = { "c", "d" };    ColumnDescriptor c2 = schema.getColumnDescription(path2);    byte[] bytes1 = { 0, 1, 2, 3 };    byte[] bytes2 = { 1, 2, 3, 4 };    byte[] bytes3 = { 2, 3, 4, 5 };    byte[] bytes4 = { 3, 4, 5, 6 };    CompressionCodecName codec = CompressionCodecName.UNCOMPRESSED;    BinaryStatistics stats1 = new BinaryStatistics();    BinaryStatistics stats2 = new BinaryStatistics();    ParquetFileWriter w = new ParquetFileWriter(configuration, schema, path);    w.start();    w.startBlock(3);    w.startColumn(c1, 5, codec);    w.writeDataPage(2, 4, BytesInput.from(bytes1), stats1, BIT_PACKED, BIT_PACKED, PLAIN);    w.writeDataPage(3, 4, BytesInput.from(bytes1), stats1, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    w.startColumn(c2, 6, codec);    w.writeDataPage(2, 4, BytesInput.from(bytes2), stats2, BIT_PACKED, BIT_PACKED, PLAIN);    w.writeDataPage(3, 4, BytesInput.from(bytes2), stats2, BIT_PACKED, BIT_PACKED, PLAIN);    w.writeDataPage(1, 4, BytesInput.from(bytes2), stats2, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    w.endBlock();    w.startBlock(4);    w.startColumn(c1, 7, codec);    w.writeDataPage(7, 4, BytesInput.from(bytes3), stats1, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    w.startColumn(c2, 8, codec);    w.writeDataPage(8, 4, BytesInput.from(bytes4), stats2, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    w.endBlock();    final HashMap<String, String> extraMetaData = new HashMap<String, String>();    extraMetaData.put("foo", "bar");    extraMetaData.put(path.getName(), path.getName());    w.end(extraMetaData);}
f5f3dd189830406f5feb7f44ab30a7f3bbf5d6ce9bbfc89e87a00f7b120f8ae8
validateContains
private void validateContains(MessageType schema, PageReadStore pages, String[] path, int values, BytesInput bytes) throws IOException
{    PageReader pageReader = pages.getPageReader(schema.getColumnDescription(path));    DataPage page = pageReader.readPage();    assertEquals(values, page.getValueCount());    assertArrayEquals(bytes.toByteArray(), ((DataPageV1) page).getBytes().toByteArray());}
50db6fa35b3faee3315b50a89d700488cfedd8297308858adad94c21f8c4829b
testMergeMetadata
public void testMergeMetadata()
{    FileMetaData md1 = new FileMetaData(new MessageType("root1", new PrimitiveType(REPEATED, BINARY, "a"), new PrimitiveType(OPTIONAL, BINARY, "b")), new HashMap<String, String>(), "test");    FileMetaData md2 = new FileMetaData(new MessageType("root2", new PrimitiveType(REQUIRED, BINARY, "c")), new HashMap<String, String>(), "test2");    GlobalMetaData merged = ParquetFileWriter.mergeInto(md2, ParquetFileWriter.mergeInto(md1, null));    assertEquals(merged.getSchema(), new MessageType("root1", new PrimitiveType(REPEATED, BINARY, "a"), new PrimitiveType(OPTIONAL, BINARY, "b"), new PrimitiveType(REQUIRED, BINARY, "c")));}
122d34032b0cbc79b4b600c708b0c8f148d90e3a55ffcdee2e6ccdf1644a8fd0
testMergeFooters
public void testMergeFooters()
{    List<BlockMetaData> oneBlocks = new ArrayList<BlockMetaData>();    oneBlocks.add(new BlockMetaData());    oneBlocks.add(new BlockMetaData());    List<BlockMetaData> twoBlocks = new ArrayList<BlockMetaData>();    twoBlocks.add(new BlockMetaData());    List<BlockMetaData> expected = new ArrayList<BlockMetaData>();    expected.addAll(oneBlocks);    expected.addAll(twoBlocks);    Footer one = new Footer(new Path("file:/tmp/output/one.parquet"), new ParquetMetadata(new FileMetaData(new MessageType("root1", new PrimitiveType(REPEATED, BINARY, "a"), new PrimitiveType(OPTIONAL, BINARY, "b")), new HashMap<String, String>(), "test"), oneBlocks));    Footer two = new Footer(new Path("/tmp/output/two.parquet"), new ParquetMetadata(new FileMetaData(new MessageType("root2", new PrimitiveType(REQUIRED, BINARY, "c")), new HashMap<String, String>(), "test2"), twoBlocks));    List<Footer> footers = new ArrayList<Footer>();    footers.add(one);    footers.add(two);    ParquetMetadata merged = ParquetFileWriter.mergeFooters(new Path("/tmp"), footers);    assertEquals(new MessageType("root1", new PrimitiveType(REPEATED, BINARY, "a"), new PrimitiveType(OPTIONAL, BINARY, "b"), new PrimitiveType(REQUIRED, BINARY, "c")), merged.getFileMetaData().getSchema());    assertEquals("Should have all blocks", expected, merged.getBlocks());}
27b622947f4631ca4a7955fbedc5f26f18c802b9848bec32c5584e9102c4fc6f
testWriteMetadataFileWithRelativeOutputPath
public void testWriteMetadataFileWithRelativeOutputPath() throws IOException
{    Configuration conf = new Configuration();    FileSystem fs = FileSystem.get(conf);    Path relativeRoot = new Path("target/_test_relative");    Path qualifiedRoot = fs.makeQualified(relativeRoot);    ParquetMetadata mock = Mockito.mock(ParquetMetadata.class);    FileMetaData fileMetaData = new FileMetaData(new MessageType("root1", new PrimitiveType(REPEATED, BINARY, "a")), new HashMap<String, String>(), "test");    Mockito.when(mock.getFileMetaData()).thenReturn(fileMetaData);    List<Footer> footers = new ArrayList<Footer>();    Footer footer = new Footer(new Path(qualifiedRoot, "one"), mock);    footers.add(footer);        ParquetFileWriter.writeMetadataFile(conf, relativeRoot, footers, JobSummaryLevel.ALL);}
5dd57f30648b561c2a27d087fdf0a1dd87420b6499f009b23c9cf8408b1ce81a
testColumnIndexWriteRead
public void testColumnIndexWriteRead() throws Exception
{    File testFile = temp.newFile();    testFile.delete();    Path path = new Path(testFile.toURI());    Configuration configuration = new Configuration();    ParquetFileWriter w = new ParquetFileWriter(configuration, SCHEMA, path);    w.start();    w.startBlock(4);    w.startColumn(C1, 7, CODEC);    w.writeDataPage(7, 4, BytesInput.from(BYTES3), EMPTY_STATS, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    w.startColumn(C2, 8, CODEC);    w.writeDataPage(8, 4, BytesInput.from(BYTES4), EMPTY_STATS, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    w.endBlock();    w.startBlock(4);    w.startColumn(C1, 5, CODEC);    long c1p1Starts = w.getPos();    w.writeDataPage(2, 4, BytesInput.from(BYTES1), statsC1(null, Binary.fromString("aaa")), 1, BIT_PACKED, BIT_PACKED, PLAIN);    long c1p2Starts = w.getPos();    w.writeDataPage(3, 4, BytesInput.from(BYTES1), statsC1(Binary.fromString("bbb"), Binary.fromString("ccc")), 3, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    long c1Ends = w.getPos();    w.startColumn(C2, 6, CODEC);    long c2p1Starts = w.getPos();    w.writeDataPage(2, 4, BytesInput.from(BYTES2), statsC2(117l, 100l), 1, BIT_PACKED, BIT_PACKED, PLAIN);    long c2p2Starts = w.getPos();    w.writeDataPage(3, 4, BytesInput.from(BYTES2), statsC2(null, null, null), 2, BIT_PACKED, BIT_PACKED, PLAIN);    long c2p3Starts = w.getPos();    w.writeDataPage(1, 4, BytesInput.from(BYTES2), statsC2(0l), 1, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    long c2Ends = w.getPos();    w.endBlock();    w.startBlock(4);    w.startColumn(C1, 7, CODEC);    w.writeDataPage(7, 4, BytesInput.from(BYTES3),     statsC1(Binary.fromConstantByteArray(new byte[(int) MAX_STATS_SIZE]), Binary.fromConstantByteArray(new byte[1])), 4, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    w.startColumn(C2, 8, CODEC);    w.writeDataPage(8, 4, BytesInput.from(BYTES4), EMPTY_STATS, BIT_PACKED, BIT_PACKED, PLAIN);    w.endColumn();    w.endBlock();    w.end(new HashMap<String, String>());    try (ParquetFileReader reader = new ParquetFileReader(HadoopInputFile.fromPath(path, configuration), ParquetReadOptions.builder().build())) {        ParquetMetadata footer = reader.getFooter();        assertEquals(3, footer.getBlocks().size());        BlockMetaData blockMeta = footer.getBlocks().get(1);        assertEquals(2, blockMeta.getColumns().size());        ColumnIndex columnIndex = reader.readColumnIndex(blockMeta.getColumns().get(0));        assertEquals(BoundaryOrder.ASCENDING, columnIndex.getBoundaryOrder());        assertTrue(Arrays.asList(1l, 0l).equals(columnIndex.getNullCounts()));        assertTrue(Arrays.asList(false, false).equals(columnIndex.getNullPages()));        List<ByteBuffer> minValues = columnIndex.getMinValues();        assertEquals(2, minValues.size());        List<ByteBuffer> maxValues = columnIndex.getMaxValues();        assertEquals(2, maxValues.size());        assertEquals("aaa", new String(minValues.get(0).array(), StandardCharsets.UTF_8));        assertEquals("aaa", new String(maxValues.get(0).array(), StandardCharsets.UTF_8));        assertEquals("bbb", new String(minValues.get(1).array(), StandardCharsets.UTF_8));        assertEquals("ccc", new String(maxValues.get(1).array(), StandardCharsets.UTF_8));        columnIndex = reader.readColumnIndex(blockMeta.getColumns().get(1));        assertEquals(BoundaryOrder.DESCENDING, columnIndex.getBoundaryOrder());        assertTrue(Arrays.asList(0l, 3l, 0l).equals(columnIndex.getNullCounts()));        assertTrue(Arrays.asList(false, true, false).equals(columnIndex.getNullPages()));        minValues = columnIndex.getMinValues();        assertEquals(3, minValues.size());        maxValues = columnIndex.getMaxValues();        assertEquals(3, maxValues.size());        assertEquals(100, BytesUtils.bytesToLong(minValues.get(0).array()));        assertEquals(117, BytesUtils.bytesToLong(maxValues.get(0).array()));        assertEquals(0, minValues.get(1).array().length);        assertEquals(0, maxValues.get(1).array().length);        assertEquals(0, BytesUtils.bytesToLong(minValues.get(2).array()));        assertEquals(0, BytesUtils.bytesToLong(maxValues.get(2).array()));        OffsetIndex offsetIndex = reader.readOffsetIndex(blockMeta.getColumns().get(0));        assertEquals(2, offsetIndex.getPageCount());        assertEquals(c1p1Starts, offsetIndex.getOffset(0));        assertEquals(c1p2Starts, offsetIndex.getOffset(1));        assertEquals(c1p2Starts - c1p1Starts, offsetIndex.getCompressedPageSize(0));        assertEquals(c1Ends - c1p2Starts, offsetIndex.getCompressedPageSize(1));        assertEquals(0, offsetIndex.getFirstRowIndex(0));        assertEquals(1, offsetIndex.getFirstRowIndex(1));        offsetIndex = reader.readOffsetIndex(blockMeta.getColumns().get(1));        assertEquals(3, offsetIndex.getPageCount());        assertEquals(c2p1Starts, offsetIndex.getOffset(0));        assertEquals(c2p2Starts, offsetIndex.getOffset(1));        assertEquals(c2p3Starts, offsetIndex.getOffset(2));        assertEquals(c2p2Starts - c2p1Starts, offsetIndex.getCompressedPageSize(0));        assertEquals(c2p3Starts - c2p2Starts, offsetIndex.getCompressedPageSize(1));        assertEquals(c2Ends - c2p3Starts, offsetIndex.getCompressedPageSize(2));        assertEquals(0, offsetIndex.getFirstRowIndex(0));        assertEquals(1, offsetIndex.getFirstRowIndex(1));        assertEquals(3, offsetIndex.getFirstRowIndex(2));        assertNull(reader.readColumnIndex(footer.getBlocks().get(2).getColumns().get(0)));    }}
054626e02d9188b67b4345afff5f494170f57325264a398ef1c24b84614e0a89
statsC1
private org.apache.parquet.column.statistics.Statistics<?> statsC1(Binary... values)
{    org.apache.parquet.column.statistics.Statistics<?> stats = org.apache.parquet.column.statistics.Statistics.createStats(C1.getPrimitiveType());    for (Binary value : values) {        if (value == null) {            stats.incrementNumNulls();        } else {            stats.updateStats(value);        }    }    return stats;}
4e3153fd4e32ad66dca2b21553927b327797b9dd035e308d8966a9f17b76da09
statsC2
private org.apache.parquet.column.statistics.Statistics<?> statsC2(Long... values)
{    org.apache.parquet.column.statistics.Statistics<?> stats = org.apache.parquet.column.statistics.Statistics.createStats(C2.getPrimitiveType());    for (Long value : values) {        if (value == null) {            stats.incrementNumNulls();        } else {            stats.updateStats(value);        }    }    return stats;}
d80a5b65702bdb1e10773b8be92e6dfb9effe6f857a43579935db07f5309308f
testDefault
public void testDefault() throws Exception
{    Configuration conf = new Configuration();        assertEquals(JobSummaryLevel.ALL, ParquetOutputFormat.getJobSummaryLevel(conf));}
4f166ab0b77b05d4be3107f3e7b269b74b69e07f3697e26aefb0f73eabd2fb6a
testDeprecatedStillWorks
public void testDeprecatedStillWorks() throws Exception
{    Configuration conf = new Configuration();    conf.set(ParquetOutputFormat.ENABLE_JOB_SUMMARY, "true");    assertEquals(JobSummaryLevel.ALL, ParquetOutputFormat.getJobSummaryLevel(conf));    conf.set(ParquetOutputFormat.ENABLE_JOB_SUMMARY, "false");    assertEquals(JobSummaryLevel.NONE, ParquetOutputFormat.getJobSummaryLevel(conf));}
32b5f6ce39317378ae12d70993ff95bbddd26daef7efb5caeda9e41ecf614c08
testLevelParses
public void testLevelParses() throws Exception
{    Configuration conf = new Configuration();    conf.set(ParquetOutputFormat.JOB_SUMMARY_LEVEL, "all");    assertEquals(JobSummaryLevel.ALL, ParquetOutputFormat.getJobSummaryLevel(conf));    conf.set(ParquetOutputFormat.JOB_SUMMARY_LEVEL, "common_only");    assertEquals(JobSummaryLevel.COMMON_ONLY, ParquetOutputFormat.getJobSummaryLevel(conf));    conf.set(ParquetOutputFormat.JOB_SUMMARY_LEVEL, "none");    assertEquals(JobSummaryLevel.NONE, ParquetOutputFormat.getJobSummaryLevel(conf));}
86d878f1e925f86ebebb9c416fdb36f1be5e0d755c3110fa8005ec54afd6d91c
testLevelTakesPrecedence
public void testLevelTakesPrecedence() throws Exception
{    Configuration conf = new Configuration();    conf.set(ParquetOutputFormat.JOB_SUMMARY_LEVEL, "common_only");    conf.set(ParquetOutputFormat.ENABLE_JOB_SUMMARY, "false");    assertEquals(JobSummaryLevel.COMMON_ONLY, ParquetOutputFormat.getJobSummaryLevel(conf));}
ced3637227837bc8935023b279f6d11e541ba2dd6bbaff26ba3afa81b2fd1240
test
public void test() throws Exception
{    Configuration conf = new Configuration();    Path root = new Path("target/tests/TestParquetWriter/");    enforceEmptyDir(conf, root);    MessageType schema = parseMessageType("message test { " + "required binary binary_field; " + "required int32 int32_field; " + "required int64 int64_field; " + "required boolean boolean_field; " + "required float float_field; " + "required double double_field; " + "required fixed_len_byte_array(3) flba_field; " + "required int96 int96_field; " + "} ");    GroupWriteSupport.setSchema(schema, conf);    SimpleGroupFactory f = new SimpleGroupFactory(schema);    Map<String, Encoding> expected = new HashMap<String, Encoding>();    expected.put("10-" + PARQUET_1_0, PLAIN_DICTIONARY);    expected.put("1000-" + PARQUET_1_0, PLAIN);    expected.put("10-" + PARQUET_2_0, RLE_DICTIONARY);    expected.put("1000-" + PARQUET_2_0, DELTA_BYTE_ARRAY);    for (int modulo : asList(10, 1000)) {        for (WriterVersion version : WriterVersion.values()) {            Path file = new Path(root, version.name() + "_" + modulo);            ParquetWriter<Group> writer = new ParquetWriter<Group>(file, new GroupWriteSupport(), UNCOMPRESSED, 1024, 1024, 512, true, false, version, conf);            for (int i = 0; i < 1000; i++) {                writer.write(f.newGroup().append("binary_field", "test" + (i % modulo)).append("int32_field", 32).append("int64_field", 64l).append("boolean_field", true).append("float_field", 1.0f).append("double_field", 2.0d).append("flba_field", "foo").append("int96_field", Binary.fromConstantByteArray(new byte[12])));            }            writer.close();            ParquetReader<Group> reader = ParquetReader.builder(new GroupReadSupport(), file).withConf(conf).build();            for (int i = 0; i < 1000; i++) {                Group group = reader.read();                assertEquals("test" + (i % modulo), group.getBinary("binary_field", 0).toStringUsingUTF8());                assertEquals(32, group.getInteger("int32_field", 0));                assertEquals(64l, group.getLong("int64_field", 0));                assertEquals(true, group.getBoolean("boolean_field", 0));                assertEquals(1.0f, group.getFloat("float_field", 0), 0.001);                assertEquals(2.0d, group.getDouble("double_field", 0), 0.001);                assertEquals("foo", group.getBinary("flba_field", 0).toStringUsingUTF8());                assertEquals(Binary.fromConstantByteArray(new byte[12]), group.getInt96("int96_field", 0));            }            reader.close();            ParquetMetadata footer = readFooter(conf, file, NO_FILTER);            for (BlockMetaData blockMetaData : footer.getBlocks()) {                for (ColumnChunkMetaData column : blockMetaData.getColumns()) {                    if (column.getPath().toDotString().equals("binary_field")) {                        String key = modulo + "-" + version;                        Encoding expectedEncoding = expected.get(key);                        assertTrue(key + ":" + column.getEncodings() + " should contain " + expectedEncoding, column.getEncodings().contains(expectedEncoding));                    }                }            }            assertEquals("Object model property should be example", "example", footer.getFileMetaData().getKeyValueMetaData().get(ParquetWriter.OBJECT_MODEL_NAME_PROP));        }    }}
c3849cbbecce4990b6f0c84a385ef2c81b847e26eeaf8d836ca72b4ebc3e2cfa
testBadWriteSchema
public void testBadWriteSchema() throws IOException
{    final File file = temp.newFile("test.parquet");    file.delete();    TestUtils.assertThrows("Should reject a schema with an empty group", InvalidSchemaException.class, (Callable<Void>) () -> {        ExampleParquetWriter.builder(new Path(file.toString())).withType(Types.buildMessage().addField(new GroupType(REQUIRED, "invalid_group")).named("invalid_message")).build();        return null;    });    Assert.assertFalse("Should not create a file when schema is rejected", file.exists());}
ce3022f53ecc6f759e9a5926f6206eea0fa2314933cb4706f014eb48a11ceba0
testNullValuesWithPageRowLimit
public void testNullValuesWithPageRowLimit() throws IOException
{    MessageType schema = Types.buildMessage().optionalList().optionalElement(BINARY).as(stringType()).named("str_list").named("msg");    final int recordCount = 100;    Configuration conf = new Configuration();    GroupWriteSupport.setSchema(schema, conf);    GroupFactory factory = new SimpleGroupFactory(schema);    Group listNull = factory.newGroup();    File file = temp.newFile();    file.delete();    Path path = new Path(file.getAbsolutePath());    try (ParquetWriter<Group> writer = ExampleParquetWriter.builder(path).withPageRowCountLimit(10).withConf(conf).build()) {        for (int i = 0; i < recordCount; ++i) {            writer.write(listNull);        }    }    try (ParquetReader<Group> reader = ParquetReader.builder(new GroupReadSupport(), path).build()) {        int readRecordCount = 0;        for (Group group = reader.read(); group != null; group = reader.read()) {            assertEquals(listNull.toString(), group.toString());            ++readRecordCount;        }        assertEquals("Number of written records should be equal to the read one", recordCount, readRecordCount);    }}
11f891cef85d26259ce1c28d0d8f2eeeca37e338fb01652856b92504656b9f90
createSourceData
public void createSourceData() throws IOException
{    this.file1 = newTemp();    this.file2 = newTemp();    ParquetWriter<Group> writer1 = ExampleParquetWriter.builder(file1).withType(FILE_SCHEMA).build();    ParquetWriter<Group> writer2 = ExampleParquetWriter.builder(file2).withType(FILE_SCHEMA).build();    for (int i = 0; i < FILE_SIZE; i += 1) {        Group group1 = GROUP_FACTORY.newGroup();        group1.add("id", i);        group1.add("string", UUID.randomUUID().toString());        writer1.write(group1);        file1content.add(group1);        Group group2 = GROUP_FACTORY.newGroup();        group2.add("id", FILE_SIZE + i);        group2.add("string", UUID.randomUUID().toString());        writer2.write(group2);        file2content.add(group2);    }    writer1.close();    writer2.close();}
c81af8e2c5778bb154becb0d99f8f309c47076edb04360a4621eb5e91897916f
testBasicBehavior
public void testBasicBehavior() throws IOException
{    Path combinedFile = newTemp();    ParquetFileWriter writer = new ParquetFileWriter(CONF, FILE_SCHEMA, combinedFile);    writer.start();    writer.appendFile(CONF, file1);    writer.appendFile(CONF, file2);    writer.end(EMPTY_METADATA);    LinkedList<Group> expected = new LinkedList<Group>();    expected.addAll(file1content);    expected.addAll(file2content);    ParquetReader<Group> reader = ParquetReader.builder(new GroupReadSupport(), combinedFile).build();    Group next;    while ((next = reader.read()) != null) {        Group expectedNext = expected.removeFirst();                Assert.assertEquals("Each id should match", expectedNext.getInteger("id", 0), next.getInteger("id", 0));        Assert.assertEquals("Each string should match", expectedNext.getString("string", 0), next.getString("string", 0));    }    Assert.assertEquals("All records should be present", 0, expected.size());}
033b92af3b568cac163c001e7cc85d7fed8be2edd596112ad72fe79f02cbd782
testMergedMetadata
public void testMergedMetadata() throws IOException
{    Path combinedFile = newTemp();    ParquetFileWriter writer = new ParquetFileWriter(CONF, FILE_SCHEMA, combinedFile);    writer.start();    writer.appendFile(CONF, file1);    writer.appendFile(CONF, file2);    writer.end(EMPTY_METADATA);    ParquetMetadata combinedFooter = ParquetFileReader.readFooter(CONF, combinedFile, NO_FILTER);    ParquetMetadata f1Footer = ParquetFileReader.readFooter(CONF, file1, NO_FILTER);    ParquetMetadata f2Footer = ParquetFileReader.readFooter(CONF, file2, NO_FILTER);    LinkedList<BlockMetaData> expectedRowGroups = new LinkedList<BlockMetaData>();    expectedRowGroups.addAll(f1Footer.getBlocks());    expectedRowGroups.addAll(f2Footer.getBlocks());    Assert.assertEquals("Combined should have the right number of row groups", expectedRowGroups.size(), combinedFooter.getBlocks().size());    long nextStart = 4;    for (BlockMetaData rowGroup : combinedFooter.getBlocks()) {        BlockMetaData expected = expectedRowGroups.removeFirst();        Assert.assertEquals("Row count should match", expected.getRowCount(), rowGroup.getRowCount());        Assert.assertEquals("Compressed size should match", expected.getCompressedSize(), rowGroup.getCompressedSize());        Assert.assertEquals("Total size should match", expected.getTotalByteSize(), rowGroup.getTotalByteSize());        Assert.assertEquals("Start pos should be at the last row group's end", nextStart, rowGroup.getStartingPos());        assertColumnsEquivalent(expected.getColumns(), rowGroup.getColumns());        nextStart = rowGroup.getStartingPos() + rowGroup.getTotalByteSize();    }}
a473ca4abb4984f5d97c0b6728b7525bfbb0b27be29b4e299617b0d5d2b402a6
assertColumnsEquivalent
public void assertColumnsEquivalent(List<ColumnChunkMetaData> expected, List<ColumnChunkMetaData> actual)
{    Assert.assertEquals("Should have the expected columns", expected.size(), actual.size());    for (int i = 0; i < actual.size(); i += 1) {        ColumnChunkMetaData current = actual.get(i);        if (i != 0) {            ColumnChunkMetaData previous = actual.get(i - 1);            long expectedStart = previous.getStartingPos() + previous.getTotalSize();            Assert.assertEquals("Should start after the previous column", expectedStart, current.getStartingPos());        }        assertColumnMetadataEquivalent(expected.get(i), current);    }}
a9713f9374cc9a00ac39e30de91c7edab33f4bf285de531354177db305d693c3
assertColumnMetadataEquivalent
public void assertColumnMetadataEquivalent(ColumnChunkMetaData expected, ColumnChunkMetaData actual)
{    Assert.assertEquals("Should be the expected column", expected.getPath(), expected.getPath());    Assert.assertEquals("Primitive type should not change", expected.getType(), actual.getType());    Assert.assertEquals("Compression codec should not change", expected.getCodec(), actual.getCodec());    Assert.assertEquals("Data encodings should not change", expected.getEncodings(), actual.getEncodings());    Assert.assertEquals("Statistics should not change", expected.getStatistics(), actual.getStatistics());    Assert.assertEquals("Uncompressed size should not change", expected.getTotalUncompressedSize(), actual.getTotalUncompressedSize());    Assert.assertEquals("Compressed size should not change", expected.getTotalSize(), actual.getTotalSize());    Assert.assertEquals("Number of values should not change", expected.getValueCount(), actual.getValueCount());}
102788af753204457f73703bcfd8551b382a78ad2dcde6869c7ac54632b595d7
testAllowDroppingColumns
public void testAllowDroppingColumns() throws IOException
{    MessageType droppedColumnSchema = Types.buildMessage().required(BINARY).as(UTF8).named("string").named("AppendTest");    Path droppedColumnFile = newTemp();    ParquetFileWriter writer = new ParquetFileWriter(CONF, droppedColumnSchema, droppedColumnFile);    writer.start();    writer.appendFile(CONF, file1);    writer.appendFile(CONF, file2);    writer.end(EMPTY_METADATA);    LinkedList<Group> expected = new LinkedList<Group>();    expected.addAll(file1content);    expected.addAll(file2content);    ParquetMetadata footer = ParquetFileReader.readFooter(CONF, droppedColumnFile, NO_FILTER);    for (BlockMetaData rowGroup : footer.getBlocks()) {        Assert.assertEquals("Should have only the string column", 1, rowGroup.getColumns().size());    }    ParquetReader<Group> reader = ParquetReader.builder(new GroupReadSupport(), droppedColumnFile).build();    Group next;    while ((next = reader.read()) != null) {        Group expectedNext = expected.removeFirst();        Assert.assertEquals("Each string should match", expectedNext.getString("string", 0), next.getString("string", 0));    }    Assert.assertEquals("All records should be present", 0, expected.size());}
ca2ed27b52e86fbd18a2c2eec0e2d720f8cd5d7d4ef6fba0406f04cb030ad35e
testFailDroppingColumns
public void testFailDroppingColumns() throws IOException
{    MessageType droppedColumnSchema = Types.buildMessage().required(BINARY).as(UTF8).named("string").named("AppendTest");    final ParquetMetadata footer = ParquetFileReader.readFooter(CONF, file1, NO_FILTER);    final FSDataInputStream incoming = file1.getFileSystem(CONF).open(file1);    Path droppedColumnFile = newTemp();    final ParquetFileWriter writer = new ParquetFileWriter(CONF, droppedColumnSchema, droppedColumnFile);    writer.start();    TestUtils.assertThrows("Should complain that id column is dropped", IllegalArgumentException.class, (Callable<Void>) () -> {        writer.appendRowGroups(incoming, footer.getBlocks(), false);        return null;    });}
48eb7bace2dd9412a609e0b61e397aac071c8c70c2a58d6e48c1d30301585e2f
testFailMissingColumn
public void testFailMissingColumn() throws IOException
{    MessageType fileSchema = Types.buildMessage().required(INT32).named("id").required(BINARY).as(UTF8).named("string").required(FLOAT).named("value").named("AppendTest");    Path missingColumnFile = newTemp();    final ParquetFileWriter writer = new ParquetFileWriter(CONF, fileSchema, missingColumnFile);    writer.start();    TestUtils.assertThrows("Should complain that value column is missing", IllegalArgumentException.class, (Callable<Void>) () -> {        writer.appendFile(CONF, file1);        return null;    });}
9915a533917d454e72a160c39fc817c41b08f32480df2eb42e2c59af15ac7163
newTemp
private Path newTemp() throws IOException
{    File file = temp.newFile();    Preconditions.checkArgument(file.delete(), "Could not remove temp file");    return new Path(file.toString());}
ced3637227837bc8935023b279f6d11e541ba2dd6bbaff26ba3afa81b2fd1240
test
public void test() throws Exception
{    Configuration conf = new Configuration();    Path root = new Path("target/tests/TestParquetWriter/");    FileSystem fs = root.getFileSystem(conf);    if (fs.exists(root)) {        fs.delete(root, true);    }    fs.mkdirs(root);    MessageType schema = parseMessageType("message test { " + "required binary binary_field; " + "required int32 int32_field; " + "required int64 int64_field; " + "required boolean boolean_field; " + "required float float_field; " + "required double double_field; " + "required fixed_len_byte_array(3) flba_field; " + "required int96 int96_field; " + "optional binary null_field; " + "} ");    GroupWriteSupport.setSchema(schema, conf);    SimpleGroupFactory f = new SimpleGroupFactory(schema);    Map<String, Encoding> expected = new HashMap<String, Encoding>();    expected.put("10-" + PARQUET_1_0, PLAIN_DICTIONARY);    expected.put("1000-" + PARQUET_1_0, PLAIN);    expected.put("10-" + PARQUET_2_0, RLE_DICTIONARY);    expected.put("1000-" + PARQUET_2_0, DELTA_BYTE_ARRAY);    for (int modulo : asList(10, 1000)) {        for (WriterVersion version : WriterVersion.values()) {            Path file = new Path(root, version.name() + "_" + modulo);            ParquetWriter<Group> writer = new ParquetWriter<Group>(file, new GroupWriteSupport(), UNCOMPRESSED, 1024, 1024, 512, true, false, version, conf);            for (int i = 0; i < 1000; i++) {                writer.write(f.newGroup().append("binary_field", "test" + (i % modulo)).append("int32_field", 32).append("int64_field", 64l).append("boolean_field", true).append("float_field", 1.0f).append("double_field", 2.0d).append("flba_field", "foo").append("int96_field", Binary.fromConstantByteArray(new byte[12])));            }            writer.close();            ParquetReader<Group> reader = ParquetReader.builder(new GroupReadSupport(), file).withConf(conf).build();            for (int i = 0; i < 1000; i++) {                Group group = reader.read();                assertEquals("test" + (i % modulo), group.getBinary("binary_field", 0).toStringUsingUTF8());                assertEquals(32, group.getInteger("int32_field", 0));                assertEquals(64l, group.getLong("int64_field", 0));                assertEquals(true, group.getBoolean("boolean_field", 0));                assertEquals(1.0f, group.getFloat("float_field", 0), 0.001);                assertEquals(2.0d, group.getDouble("double_field", 0), 0.001);                assertEquals("foo", group.getBinary("flba_field", 0).toStringUsingUTF8());                assertEquals(Binary.fromConstantByteArray(new byte[12]), group.getInt96("int96_field", 0));                assertEquals(0, group.getFieldRepetitionCount("null_field"));            }            reader.close();            ParquetMetadata footer = readFooter(conf, file, NO_FILTER);            for (BlockMetaData blockMetaData : footer.getBlocks()) {                for (ColumnChunkMetaData column : blockMetaData.getColumns()) {                    if (column.getPath().toDotString().equals("binary_field")) {                        String key = modulo + "-" + version;                        Encoding expectedEncoding = expected.get(key);                        assertTrue(key + ":" + column.getEncodings() + " should contain " + expectedEncoding, column.getEncodings().contains(expectedEncoding));                    }                }            }        }    }}
79d781dee2e779b5c7db3d847c444c9fd0ae0a7663ac608f1850651925cb80a0
writeData
private static void writeData(ParquetWriter<Group> writer) throws IOException
{    SimpleGroupFactory f = new SimpleGroupFactory(SCHEMA);    for (int i = 0; i < NUM_RECORDS; i += 1) {        int index = i % ALPHABET.length();        Group group = f.newGroup().append("dict_binary_field", ALPHABET.substring(index, index + 1)).append("plain_int32_field", i).append("fallback_binary_field", i < (NUM_RECORDS / 2) ? ALPHABET.substring(index, index + 1) : UUID.randomUUID().toString());        writer.write(group);    }}
c2c75b5eb5762dda20687d84e7565d4cf3b9de60742e0694a6cffba3f16ea18a
testReadWrite
public void testReadWrite() throws Exception
{    File file = temp.newFile("encoding-stats.parquet");    assertTrue(file.delete());    Path path = new Path(file.toString());    ParquetWriter<Group> writer = ExampleParquetWriter.builder(path).withWriterVersion(PARQUET_1_0).withPageSize(    1024).enableDictionaryEncoding().withDictionaryPageSize(2 * 1024).withConf(CONF).withType(SCHEMA).build();    writeData(writer);    writer.close();    ParquetFileReader reader = ParquetFileReader.open(CONF, path);    assertEquals("Should have one row group", 1, reader.getRowGroups().size());    BlockMetaData rowGroup = reader.getRowGroups().get(0);    ColumnChunkMetaData dictColumn = rowGroup.getColumns().get(0);    EncodingStats dictStats = dictColumn.getEncodingStats();    assertNotNull("Dict column should have non-null encoding stats", dictStats);    assertTrue("Dict column should have a dict page", dictStats.hasDictionaryPages());    assertTrue("Dict column should have dict-encoded pages", dictStats.hasDictionaryEncodedPages());    assertFalse("Dict column should not have non-dict pages", dictStats.hasNonDictionaryEncodedPages());    ColumnChunkMetaData plainColumn = rowGroup.getColumns().get(1);    EncodingStats plainStats = plainColumn.getEncodingStats();    assertNotNull("Plain column should have non-null encoding stats", plainStats);    assertFalse("Plain column should not have a dict page", plainStats.hasDictionaryPages());    assertFalse("Plain column should not have dict-encoded pages", plainStats.hasDictionaryEncodedPages());    assertTrue("Plain column should have non-dict pages", plainStats.hasNonDictionaryEncodedPages());    ColumnChunkMetaData fallbackColumn = rowGroup.getColumns().get(2);    EncodingStats fallbackStats = fallbackColumn.getEncodingStats();    assertNotNull("Fallback column should have non-null encoding stats", fallbackStats);    assertTrue("Fallback column should have a dict page", fallbackStats.hasDictionaryPages());    assertTrue("Fallback column should have dict-encoded pages", fallbackStats.hasDictionaryEncodedPages());    assertTrue("Fallback column should have non-dict pages", fallbackStats.hasNonDictionaryEncodedPages());}
ab719ddd2eda89621e69a69b6440735cdbeca63a9383c5681a9cb7f4c66dea86
TestSnappy
public void TestSnappy() throws IOException
{        SnappyCompressor compressor = new SnappyCompressor();    SnappyDecompressor decompressor = new SnappyDecompressor();    TestSnappy(compressor, decompressor, "");    TestSnappy(compressor, decompressor, "FooBar");    TestSnappy(compressor, decompressor, "FooBar1", "FooBar2");    TestSnappy(compressor, decompressor, "FooBar");    TestSnappy(compressor, decompressor, "a", "blahblahblah", "abcdef");    TestSnappy(compressor, decompressor, "");    TestSnappy(compressor, decompressor, "FooBar");}
7e12b5dc5c496b92d01852c38c4bc0cdfc13b6da9d9ffbd5bdfd8fe13140a620
TestSnappyStream
public void TestSnappyStream() throws IOException
{    SnappyCodec codec = new SnappyCodec();    codec.setConf(new Configuration());    int blockSize = 1024;    int inputSize = blockSize * 1024;    byte[] input = new byte[inputSize];    for (int i = 0; i < inputSize; ++i) {        input[i] = (byte) i;    }    ByteArrayOutputStream compressedStream = new ByteArrayOutputStream();    CompressionOutputStream compressor = codec.createOutputStream(compressedStream);    int bytesCompressed = 0;    while (bytesCompressed < inputSize) {        int len = Math.min(inputSize - bytesCompressed, blockSize);        compressor.write(input, bytesCompressed, len);        bytesCompressed += len;    }    compressor.finish();    byte[] rawCompressed = Snappy.compress(input);    byte[] codecCompressed = compressedStream.toByteArray();            assertArrayEquals(rawCompressed, codecCompressed);    ByteArrayInputStream inputStream = new ByteArrayInputStream(codecCompressed);    CompressionInputStream decompressor = codec.createInputStream(inputStream);    byte[] codecDecompressed = new byte[inputSize];    int bytesDecompressed = 0;    int numBytes;    while ((numBytes = decompressor.read(codecDecompressed, bytesDecompressed, blockSize)) != 0) {        bytesDecompressed += numBytes;        if (bytesDecompressed == inputSize)            break;    }    byte[] rawDecompressed = Snappy.uncompress(rawCompressed);    assertArrayEquals(input, rawDecompressed);    assertArrayEquals(input, codecDecompressed);}
263e8209383783ddcfec7e100e8b3dbde4abcdf90e540aa9316993e93d7a2367
TestSnappy
private void TestSnappy(SnappyCompressor compressor, SnappyDecompressor decompressor, String... strings) throws IOException
{    compressor.reset();    decompressor.reset();    int uncompressedSize = 0;    for (String s : strings) {        uncompressedSize += s.length();    }    byte[] uncompressedData = new byte[uncompressedSize];    int len = 0;    for (String s : strings) {        byte[] tmp = s.getBytes();        System.arraycopy(tmp, 0, uncompressedData, len, s.length());        len += s.length();    }    assert (compressor.needsInput());    compressor.setInput(uncompressedData, 0, len);    assert (compressor.needsInput());    compressor.finish();    assert (!compressor.needsInput());    assert (!compressor.finished() || uncompressedSize == 0);    byte[] compressedData = new byte[1000];    int compressedSize = compressor.compress(compressedData, 0, 1000);    assert (compressor.finished());    assert (!decompressor.finished());    assert (decompressor.needsInput());    decompressor.setInput(compressedData, 0, compressedSize);    assert (!decompressor.finished());    byte[] decompressedData = new byte[uncompressedSize];    int decompressedSize = decompressor.decompress(decompressedData, 0, uncompressedSize);    assert (decompressor.finished());    assertEquals(uncompressedSize, decompressedSize);    assertArrayEquals(uncompressedData, decompressedData);}
fd7027b6c124dca41a3968e81ff97170d375e992441a85d94f2ef241c0d3f398
enforceEmptyDir
public static void enforceEmptyDir(Configuration conf, Path path) throws IOException
{    FileSystem fs = path.getFileSystem(conf);    if (fs.exists(path)) {        if (!fs.delete(path, true)) {            throw new IOException("can not delete path " + path);        }    }    if (!fs.mkdirs(path)) {        throw new IOException("can not create path " + path);    }}
d54ae37b15047137d77db38fa1b84620ac079ebc22c52523675be58707583c68
assertThrows
public static void assertThrows(String message, Class<? extends Exception> expected, Callable callable)
{    try {        callable.call();        Assert.fail("No exception was thrown (" + message + "), expected: " + expected.getName());    } catch (Exception actual) {        try {            Assert.assertEquals(message, expected, actual.getClass());        } catch (AssertionError e) {            e.addSuppressed(actual);            throw e;        }    }}
c5c40295bd3aa421d004c5a1d7408327916add7765d91e9a92d10cfc9b36f8af
assertStatsValuesEqual
public static void assertStatsValuesEqual(Statistics<?> stats1, Statistics<?> stats2)
{    assertStatsValuesEqual(null, stats1, stats2);}
b59253dc012397ec54e6fea29a3f4e4589f78d8453c92f3c8b56489117a4ee4c
assertStatsValuesEqual
public static void assertStatsValuesEqual(String message, Statistics<?> expected, Statistics<?> actual)
{    if (expected == actual) {        return;    }    if (expected == null || actual == null) {        Assert.assertEquals(expected, actual);    }    Assert.assertThat(actual, CoreMatchers.instanceOf(expected.getClass()));    Assert.assertArrayEquals(message, expected.getMaxBytes(), actual.getMaxBytes());    Assert.assertArrayEquals(message, expected.getMinBytes(), actual.getMinBytes());    Assert.assertEquals(message, expected.getNumNulls(), actual.getNumNulls());}
aaeda8254d4079cb4f6456af28df58b3588d281ec86cadc8f3767ae9ef4d79e2
read
public synchronized int read(byte[] b, int off, int len)
{    if (current < lengths.length) {        if (len <= lengths[current]) {                        int bytesRead = super.read(b, off, len);            lengths[current] -= bytesRead;            return bytesRead;        } else {            int bytesRead = super.read(b, off, lengths[current]);            current += 1;            return bytesRead;        }    } else {        return super.read(b, off, len);    }}
5fe7ddec5706926b43c1d92e5ec17c7908f178383e17d5933ad75f105c9ceeaa
read
public int read(long position, byte[] buffer, int offset, int length) throws IOException
{    seek(position);    return read(buffer, offset, length);}
775265b5ff8cd306c088b08ce792917e8dd3cb9853605a3756e1eb71e2850a77
readFully
public void readFully(long position, byte[] buffer, int offset, int length) throws IOException
{    throw new UnsupportedOperationException("Not actually supported.");}
9c8941f6486ccfc61307a682b6a71bfa353f3e600ef43ccd6a7b17741671d5c0
readFully
public void readFully(long position, byte[] buffer) throws IOException
{    throw new UnsupportedOperationException("Not actually supported.");}
33fd6dc7f0122d1ea853289e89f326e43e6b1a703d1489d328b258f832973505
seek
public void seek(long pos) throws IOException
{    this.pos = (int) pos;}
5800a0f531c192e683ef74c0c5de6015daf6261d1f8e5c0ce6d8e043b01926c7
getPos
public long getPos() throws IOException
{    return this.pos;}
15ea2cc05196f4e748d2302f6e1528c6868bae81059fb66ac5d677d731fad0bc
seekToNewSource
public boolean seekToNewSource(long targetPos) throws IOException
{    seek(targetPos);    return true;}
f6cf5cebd4378bf21b6f722e4d539ff0fb218c112d1691f1f0bbd0eda4e34078
read
public int read(ByteBuffer buf) throws IOException
{            byte[] temp = new byte[buf.remaining()];    int bytesRead = stream.read(temp, 0, temp.length);    if (bytesRead > 0) {        buf.put(temp, 0, bytesRead);    }    return bytesRead;}
c65eccd80d60913b9af4737a02b5437e8ffcde595df160fb593b71c64952e062
testHeapReadFullySmallBuffer
public void testHeapReadFullySmallBuffer() throws Exception
{    ByteBuffer readBuffer = ByteBuffer.allocate(8);    FSDataInputStream hadoopStream = new FSDataInputStream(new MockHadoopInputStream());    MockBufferReader reader = new MockBufferReader(hadoopStream);    H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(8, readBuffer.position());    Assert.assertEquals(8, readBuffer.limit());    H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(8, readBuffer.position());    Assert.assertEquals(8, readBuffer.limit());    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 8), readBuffer);}
41e6ca3cc249b1bb3c352db00909d1427616b98aca0236c9df7aeb6d8e015123
testHeapReadFullyLargeBuffer
public void testHeapReadFullyLargeBuffer() throws Exception
{    final ByteBuffer readBuffer = ByteBuffer.allocate(20);    FSDataInputStream hadoopStream = new FSDataInputStream(new MockHadoopInputStream());    final MockBufferReader reader = new MockBufferReader(hadoopStream);    TestUtils.assertThrows("Should throw EOFException", EOFException.class, () -> {        H2SeekableInputStream.readFully(reader, readBuffer);        return null;    });                            Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(20, readBuffer.limit());}
4d52a409b2ad34c8d70807a09389353dfa47199d1e48522f1e3e1053bf0818f7
testHeapReadFullyJustRight
public void testHeapReadFullyJustRight() throws Exception
{    ByteBuffer readBuffer = ByteBuffer.allocate(10);    FSDataInputStream hadoopStream = new FSDataInputStream(new MockHadoopInputStream());    MockBufferReader reader = new MockBufferReader(hadoopStream);        H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());        H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY), readBuffer);}
a711af09e3f6f90a0be9f717314cb0dc917256392dca7f8d2eab45b13a433491
testHeapReadFullySmallReads
public void testHeapReadFullySmallReads() throws Exception
{    ByteBuffer readBuffer = ByteBuffer.allocate(10);    FSDataInputStream hadoopStream = new FSDataInputStream(new MockHadoopInputStream(2, 3, 3));    MockBufferReader reader = new MockBufferReader(hadoopStream);    H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY), readBuffer);}
cefcc109f2cab89d41cd1cf6b5a2d7a74c0f68cf3e698840f49c8f2f2e32be39
testHeapReadFullyPosition
public void testHeapReadFullyPosition() throws Exception
{    ByteBuffer readBuffer = ByteBuffer.allocate(10);    readBuffer.position(3);    readBuffer.mark();    FSDataInputStream hadoopStream = new FSDataInputStream(new MockHadoopInputStream(2, 3, 3));    MockBufferReader reader = new MockBufferReader(hadoopStream);    H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    readBuffer.reset();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 7), readBuffer);}
cbdaf0738b7e8de9ad79bcd557e5ff56c6017a95971a4a7c81125fd9b9fe0843
testHeapReadFullyLimit
public void testHeapReadFullyLimit() throws Exception
{    ByteBuffer readBuffer = ByteBuffer.allocate(10);    readBuffer.limit(7);    FSDataInputStream hadoopStream = new FSDataInputStream(new MockHadoopInputStream(2, 3, 3));    MockBufferReader reader = new MockBufferReader(hadoopStream);    H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(7, readBuffer.position());    Assert.assertEquals(7, readBuffer.limit());    H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(7, readBuffer.position());    Assert.assertEquals(7, readBuffer.limit());    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 7), readBuffer);    readBuffer.position(7);    readBuffer.limit(10);    H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY), readBuffer);}
d362858c0b3671c8fa9e97f4d862e5edbb8ece3147a246b375170ce9ecccb878
testHeapReadFullyPositionAndLimit
public void testHeapReadFullyPositionAndLimit() throws Exception
{    ByteBuffer readBuffer = ByteBuffer.allocate(10);    readBuffer.position(3);    readBuffer.limit(7);    readBuffer.mark();    FSDataInputStream hadoopStream = new FSDataInputStream(new MockHadoopInputStream(2, 3, 3));    MockBufferReader reader = new MockBufferReader(hadoopStream);    H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(7, readBuffer.position());    Assert.assertEquals(7, readBuffer.limit());    H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(7, readBuffer.position());    Assert.assertEquals(7, readBuffer.limit());    readBuffer.reset();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 4), readBuffer);    readBuffer.position(7);    readBuffer.limit(10);    H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    readBuffer.reset();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 7), readBuffer);}
946661e20d2edba41d5e99530609c0cd62745897c0494259c73f1ffa271facae
testDirectReadFullySmallBuffer
public void testDirectReadFullySmallBuffer() throws Exception
{    ByteBuffer readBuffer = ByteBuffer.allocateDirect(8);    FSDataInputStream hadoopStream = new FSDataInputStream(new MockHadoopInputStream());    MockBufferReader reader = new MockBufferReader(hadoopStream);    H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(8, readBuffer.position());    Assert.assertEquals(8, readBuffer.limit());    H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(8, readBuffer.position());    Assert.assertEquals(8, readBuffer.limit());    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 8), readBuffer);}
0705692717e56afd360c96351c9d6febf700150017b47841ec536db3b69464f6
testDirectReadFullyLargeBuffer
public void testDirectReadFullyLargeBuffer() throws Exception
{    final ByteBuffer readBuffer = ByteBuffer.allocateDirect(20);    FSDataInputStream hadoopStream = new FSDataInputStream(new MockHadoopInputStream());    final MockBufferReader reader = new MockBufferReader(hadoopStream);    TestUtils.assertThrows("Should throw EOFException", EOFException.class, () -> {        H2SeekableInputStream.readFully(reader, readBuffer);        return null;    });                            Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(20, readBuffer.limit());}
3a66deefdc4b8825e9024b494a5e5b5acb7a8dd8b811072603c83f17b4eb3315
testDirectReadFullyJustRight
public void testDirectReadFullyJustRight() throws Exception
{    ByteBuffer readBuffer = ByteBuffer.allocateDirect(10);    FSDataInputStream hadoopStream = new FSDataInputStream(new MockHadoopInputStream());    MockBufferReader reader = new MockBufferReader(hadoopStream);        H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());        H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY), readBuffer);}
f685f203175da0ea904aae08714ff1bf7677d70feea517fedce702d454d7ceac
testDirectReadFullySmallReads
public void testDirectReadFullySmallReads() throws Exception
{    ByteBuffer readBuffer = ByteBuffer.allocateDirect(10);    FSDataInputStream hadoopStream = new FSDataInputStream(new MockHadoopInputStream(2, 3, 3));    MockBufferReader reader = new MockBufferReader(hadoopStream);    H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY), readBuffer);}
6b9c889cf46ef04a31faf6eb8d40d2f578b25029eb1606673a951352b21b939d
testDirectReadFullyPosition
public void testDirectReadFullyPosition() throws Exception
{    ByteBuffer readBuffer = ByteBuffer.allocateDirect(10);    readBuffer.position(3);    readBuffer.mark();    FSDataInputStream hadoopStream = new FSDataInputStream(new MockHadoopInputStream(2, 3, 3));    MockBufferReader reader = new MockBufferReader(hadoopStream);    H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    readBuffer.reset();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 7), readBuffer);}
3c11953b863e4130c7030ea77003afdd3a6d333d60073719eac5966fa1d7ece8
testDirectReadFullyLimit
public void testDirectReadFullyLimit() throws Exception
{    ByteBuffer readBuffer = ByteBuffer.allocateDirect(10);    readBuffer.limit(7);    FSDataInputStream hadoopStream = new FSDataInputStream(new MockHadoopInputStream(2, 3, 3));    H2SeekableInputStream.Reader reader = new MockBufferReader(hadoopStream);    H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(7, readBuffer.position());    Assert.assertEquals(7, readBuffer.limit());    H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(7, readBuffer.position());    Assert.assertEquals(7, readBuffer.limit());    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 7), readBuffer);    readBuffer.position(7);    readBuffer.limit(10);    H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    readBuffer.flip();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY), readBuffer);}
e8968bbb7a8089c3d31be7e588a0553f66881583723847fec68b31b630760106
testDirectReadFullyPositionAndLimit
public void testDirectReadFullyPositionAndLimit() throws Exception
{    ByteBuffer readBuffer = ByteBuffer.allocateDirect(10);    readBuffer.position(3);    readBuffer.limit(7);    readBuffer.mark();    FSDataInputStream hadoopStream = new FSDataInputStream(new MockHadoopInputStream(2, 3, 3));    MockBufferReader reader = new MockBufferReader(hadoopStream);    H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(7, readBuffer.position());    Assert.assertEquals(7, readBuffer.limit());    H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(7, readBuffer.position());    Assert.assertEquals(7, readBuffer.limit());    readBuffer.reset();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 4), readBuffer);    readBuffer.position(7);    readBuffer.limit(10);    H2SeekableInputStream.readFully(reader, readBuffer);    Assert.assertEquals(10, readBuffer.position());    Assert.assertEquals(10, readBuffer.limit());    readBuffer.reset();    Assert.assertEquals("Buffer contents should match", ByteBuffer.wrap(TEST_ARRAY, 0, 7), readBuffer);}
7f41d5e8aafa2e3cd71f6f921463450b9cf95857390a2bc6aa4d632fa62dc1bf
testReadWriteObjectToConfAsBase64
public void testReadWriteObjectToConfAsBase64() throws Exception
{    Map<Integer, String> anObject = new HashMap<Integer, String>();    anObject.put(7, "seven");    anObject.put(8, "eight");    Configuration conf = new Configuration();    SerializationUtil.writeObjectToConfAsBase64("anobject", anObject, conf);    Map<Integer, String> copy = SerializationUtil.readObjectFromConfAsBase64("anobject", conf);    assertEquals(anObject, copy);    try {        Set<String> bad = SerializationUtil.readObjectFromConfAsBase64("anobject", conf);        fail("This should throw a ClassCastException");    } catch (ClassCastException e) {    }    conf = new Configuration();    Object nullObj = null;    SerializationUtil.writeObjectToConfAsBase64("anobject", null, conf);    Object copyObj = SerializationUtil.readObjectFromConfAsBase64("anobject", conf);    assertEquals(nullObj, copyObj);}
804cd411a554bd7892866281c43109abfa76d9196a8bad5f8e1502383c03877a
readObjectFromConfAsBase64UnsetKey
public void readObjectFromConfAsBase64UnsetKey() throws Exception
{    assertNull(SerializationUtil.readObjectFromConfAsBase64("non-existant-key", new Configuration()));}
6fdc444e1eb57c6af13a4c6aeb02b423455395851015bc05b215558f8c04ba4e
shouldGenerateNull
public boolean shouldGenerateNull()
{    return (random.nextInt(10) == 0);}
101c72b6926c61946d30466976eb7eb5e87b84e675f761e4473a7424815e2dc3
randomInt
public int randomInt()
{    return random.nextInt();}
dc321912a6fbfa634f0faba38aaf1a18544b149a7d25879414fee71ab12fb8c3
randomPositiveInt
public int randomPositiveInt(int maximum)
{        return random.nextInt(Math.abs(maximum) + 1);}
cefd273fa20d997452ba15222789e2d13672fa18bcb4a43a5e36fde013b7527a
randomLong
public long randomLong()
{    return random.nextLong();}
5489b4543db4c41dd80ae418d8bb2f1a0bee45b9762cf0f1daca7b0137909acb
randomLong
public long randomLong(long maximum)
{    return randomLong() % maximum;}
947b0801b398b0c39747d3d80557b05eaee36f6bdeb170c13d0780814315e2b8
randomFloat
public float randomFloat()
{    return random.nextFloat();}
ba374de24f9e4a7f75723eacc544b8d438a8ca869cef8b620385713f6e0b68ed
randomFloat
public float randomFloat(float maximum)
{    return random.nextFloat() % maximum;}
7730443399fef3dadd67b7e115cd315d782153e5834fd3a50159fd3fdb9bb490
randomDouble
public double randomDouble()
{    return random.nextDouble();}
2ae4d8fe094ddabc70e334c17f8b3d4fb1408ff72b0b087de4c512c8d5f8c100
randomDouble
public double randomDouble(double maximum)
{    return random.nextDouble() % maximum;}
735a573c498b003a3c04c2544f604f890982ccaf368df5e0407ba0dfb16cff27
randomInt96
public BigInteger randomInt96()
{    return new BigInteger(95, random);}
e3c0c91717858897755a56651b29ac55a65890bf9d010946c009e7713380cefd
randomInt96
public BigInteger randomInt96(BigInteger maximum)
{    BigInteger result;    while ((result = randomInt96()).compareTo(maximum) > 0) ;    return result;}
7a0a7a464f9b57c65a68e501ae45151e573f2b31f4747f7697d4e850e7a887ce
randomLetter
public char randomLetter()
{    return ALPHABET.charAt(randomPositiveInt(ALPHABET.length() - 1));}
29120f9106b53bdfb89c6a6e1ff4ad4cdae1f5cb4fa84bcb617b524c974fbe09
randomString
public String randomString(int maxLength)
{    return randomFixedLengthString(randomPositiveInt(maxLength));}
de609828f46193416bb2f179fd886402605579cafca78ecd0f60af364e36fcab
randomFixedLengthString
public String randomFixedLengthString(int length)
{    StringBuilder builder = new StringBuilder();    for (int index = 0; index < length; index++) {        builder.append(randomLetter());    }    return builder.toString();}
941f721dbdf91f5d06011605f0778bdde8889f00fd3d647471b4add8979765c0
asReusedBinary
public Binary asReusedBinary(byte[] data)
{    int length = Math.min(data.length, bufferLength);    System.arraycopy(data, 0, buffer, 0, length);    return Binary.fromReusedByteArray(data, 0, length);}
397b61011bce9cf77de964f16d70c54a470fef80d73f7f1880e282aa04c1aacf
nextValue
public Integer nextValue()
{    return (minimum + randomPositiveInt(range));}
397b61011bce9cf77de964f16d70c54a470fef80d73f7f1880e282aa04c1aacf
nextValue
public Integer nextValue()
{    return super.nextValue() & mask;}
397b61011bce9cf77de964f16d70c54a470fef80d73f7f1880e282aa04c1aacf
nextValue
public Integer nextValue()
{    return randomInt();}
6e2a2416454084aba3bd9980c52c903429b9fbf85a1c02e10958c8b301986997
nextValue
public Long nextValue()
{    return (minimum + randomLong(range));}
6e2a2416454084aba3bd9980c52c903429b9fbf85a1c02e10958c8b301986997
nextValue
public Long nextValue()
{    return randomLong();}
b2d6345a0ac8c98e1021930bcf787ab088fc2d2e0105111a379197c1c7369ccd
nextValue
public BigInteger nextValue()
{    return (minimum.add(randomInt96(range)));}
f96dcf92394572254272ced8f3c3e50e1f57acbb0f1ac18f0c79ab75ac840258
nextBinaryValue
public Binary nextBinaryValue()
{    return asReusedBinary(nextValue().toByteArray());}
604f2812646cf3c928a853fe0194fbb77b11ece472b4392755a5839d7b02cbf2
nextValue
public Float nextValue()
{    return (minimum + randomFloat(range));}
604f2812646cf3c928a853fe0194fbb77b11ece472b4392755a5839d7b02cbf2
nextValue
public Float nextValue()
{    return randomFloat();}
1095abc0a271a03e22f0831a993cf640cafa5daf56103d4e78473e5a401f0771
nextValue
public Double nextValue()
{    return (minimum + randomDouble(range));}
1095abc0a271a03e22f0831a993cf640cafa5daf56103d4e78473e5a401f0771
nextValue
public Double nextValue()
{    return randomDouble();}
d80729f35eef6db474657686439cbfc838310f7f5d0cd0c75b01816b1e1442c2
nextValue
public String nextValue()
{    int stringLength = randomPositiveInt(15) + 1;    return randomString(stringLength);}
f96dcf92394572254272ced8f3c3e50e1f57acbb0f1ac18f0c79ab75ac840258
nextBinaryValue
public Binary nextBinaryValue()
{    return asReusedBinary(nextValue().getBytes());}
06993f467a1c4cbdfb7519a54b91f37b9abf3b50a64c2c56052bd2ef220eb0e4
nextValue
public Binary nextValue()
{        int length = 5 + randomPositiveInt(buffer.length - 5);    for (int index = 0; index < length; index++) {        buffer[index] = (byte) randomInt();    }    return Binary.fromReusedByteArray(buffer, 0, length);}
f96dcf92394572254272ced8f3c3e50e1f57acbb0f1ac18f0c79ab75ac840258
nextBinaryValue
public Binary nextBinaryValue()
{    return nextValue();}
06993f467a1c4cbdfb7519a54b91f37b9abf3b50a64c2c56052bd2ef220eb0e4
nextValue
public Binary nextValue()
{    for (int index = 0; index < buffer.length; index++) {        buffer[index] = (byte) randomInt();    }    return Binary.fromReusedByteArray(buffer);}
f96dcf92394572254272ced8f3c3e50e1f57acbb0f1ac18f0c79ab75ac840258
nextBinaryValue
public Binary nextBinaryValue()
{    return nextValue();}
3efd614645bc0a60d7aaeb11fbb2b8a4576b0185cb77c816a403af3028491dfc
minimum
public T minimum()
{    return this.minimum;}
3b598dd51de60109e25dbd8ee8e14d48693e4cbb4a72878b441ad885655b0b2c
maximum
public T maximum()
{    return this.maximum;}
ef30685665c2aeb7d51d8db890bde201392eb46f6959f8a3d3deb6f54357cf79
writeAndTest
public static void writeAndTest(WriteContext context) throws IOException
{        Configuration configuration = new Configuration();    GroupWriteSupport.setSchema(context.schema, configuration);    GroupWriteSupport groupWriteSupport = new GroupWriteSupport();        final int blockSize = context.blockSize;    final int pageSize = context.pageSize;    final int dictionaryPageSize = pageSize;    final boolean enableDictionary = context.enableDictionary;    final boolean enableValidation = context.enableValidation;    ParquetProperties.WriterVersion writerVersion = context.version;    CompressionCodecName codec = CompressionCodecName.UNCOMPRESSED;    ParquetWriter<Group> writer = new ParquetWriter<Group>(context.fsPath, groupWriteSupport, codec, blockSize, pageSize, dictionaryPageSize, enableDictionary, enableValidation, writerVersion, configuration);    context.write(writer);    writer.close();    context.test();    context.path.delete();}
c912f40c38afde0ef75b8d08ab2c675551c383cef1763b349d2cf096213fb12d
readDictionaryPage
public DictionaryPage readDictionaryPage()
{    return dict;}
a44ab89ac1bd1c96a51dfa0d50dcc13fd7563de2e02c8e8f8722aff5468302dd
getTotalValueCount
public long getTotalValueCount()
{    return data.getValueCount();}
9cb4eeb0904f10d1d5e6bace639960ffa54293753cf81bf158838b756b0b9925
readPage
public DataPage readPage()
{    return data;}
49e577ceaea416b548c27c1959875188093b5c9b6728e72f40e9970cc16c65e5
getStatisticsFromPageHeader
private static Statistics<T> getStatisticsFromPageHeader(DataPage page)
{    return page.accept(new DataPage.Visitor<Statistics<T>>() {        @Override        @SuppressWarnings("unchecked")        public Statistics<T> visit(DataPageV1 dataPageV1) {            return (Statistics<T>) dataPageV1.getStatistics();        }        @Override        @SuppressWarnings("unchecked")        public Statistics<T> visit(DataPageV2 dataPageV2) {            return (Statistics<T>) dataPageV2.getStatistics();        }    });}
054c91d1112cbdc1a01b919993cabc9420694edc972f439893b181c4b083e943
visit
public Statistics<T> visit(DataPageV1 dataPageV1)
{    return (Statistics<T>) dataPageV1.getStatistics();}
5301e037091d435d1f1a8f9dfbcb4623bd0f3f55d04559b84f7a8816e424bb45
visit
public Statistics<T> visit(DataPageV2 dataPageV2)
{    return (Statistics<T>) dataPageV2.getStatistics();}
a79e32cfffb6c83314d317ebedaff33b9cbf2be1a00e9947fa87e54ecc2ea74f
validate
public void validate(T value)
{    if (hasNonNull) {        assertTrue("min should be <= all values", comparator.compare(min, value) <= 0);        assertTrue("min should be >= all values", comparator.compare(max, value) >= 0);    }}
93af093565230fe254553c7926102e0ab82f50b866495239b98340c07b7595b3
getValidatingConverter
private static PrimitiveConverter getValidatingConverter(final DataPage page, PrimitiveTypeName type)
{    return type.convert(new PrimitiveType.PrimitiveTypeNameConverter<PrimitiveConverter, RuntimeException>() {        @Override        public PrimitiveConverter convertFLOAT(PrimitiveTypeName primitiveTypeName) {            final StatsValidator<Float> validator = new StatsValidator<Float>(page);            return new PrimitiveConverter() {                @Override                public void addFloat(float value) {                    validator.validate(value);                }            };        }        @Override        public PrimitiveConverter convertDOUBLE(PrimitiveTypeName primitiveTypeName) {            final StatsValidator<Double> validator = new StatsValidator<Double>(page);            return new PrimitiveConverter() {                @Override                public void addDouble(double value) {                    validator.validate(value);                }            };        }        @Override        public PrimitiveConverter convertINT32(PrimitiveTypeName primitiveTypeName) {            final StatsValidator<Integer> validator = new StatsValidator<Integer>(page);            return new PrimitiveConverter() {                @Override                public void addInt(int value) {                    validator.validate(value);                }            };        }        @Override        public PrimitiveConverter convertINT64(PrimitiveTypeName primitiveTypeName) {            final StatsValidator<Long> validator = new StatsValidator<Long>(page);            return new PrimitiveConverter() {                @Override                public void addLong(long value) {                    validator.validate(value);                }            };        }        @Override        public PrimitiveConverter convertBOOLEAN(PrimitiveTypeName primitiveTypeName) {            final StatsValidator<Boolean> validator = new StatsValidator<Boolean>(page);            return new PrimitiveConverter() {                @Override                public void addBoolean(boolean value) {                    validator.validate(value);                }            };        }        @Override        public PrimitiveConverter convertINT96(PrimitiveTypeName primitiveTypeName) {            return convertBINARY(primitiveTypeName);        }        @Override        public PrimitiveConverter convertFIXED_LEN_BYTE_ARRAY(PrimitiveTypeName primitiveTypeName) {            return convertBINARY(primitiveTypeName);        }        @Override        public PrimitiveConverter convertBINARY(PrimitiveTypeName primitiveTypeName) {            final StatsValidator<Binary> validator = new StatsValidator<Binary>(page);            return new PrimitiveConverter() {                @Override                public void addBinary(Binary value) {                    validator.validate(value);                }            };        }    });}
226b5456fb2d26c1ce9e3c737dc056c251cf7e50cc558e85776cec6d2636ff54
convertFLOAT
public PrimitiveConverter convertFLOAT(PrimitiveTypeName primitiveTypeName)
{    final StatsValidator<Float> validator = new StatsValidator<Float>(page);    return new PrimitiveConverter() {        @Override        public void addFloat(float value) {            validator.validate(value);        }    };}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    validator.validate(value);}
4eab9f54472fb300242a626cb1bfa494c9507068630f657ec9d418f4aef1355e
convertDOUBLE
public PrimitiveConverter convertDOUBLE(PrimitiveTypeName primitiveTypeName)
{    final StatsValidator<Double> validator = new StatsValidator<Double>(page);    return new PrimitiveConverter() {        @Override        public void addDouble(double value) {            validator.validate(value);        }    };}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    validator.validate(value);}
5e7e6197a77ef8b0c204b55dd4cb247e34cda4628de1ee9e1ecf873bbcc97e71
convertINT32
public PrimitiveConverter convertINT32(PrimitiveTypeName primitiveTypeName)
{    final StatsValidator<Integer> validator = new StatsValidator<Integer>(page);    return new PrimitiveConverter() {        @Override        public void addInt(int value) {            validator.validate(value);        }    };}
a2ac1f40a6e220ec515710128c8baf77a725ad0b9f1767a998f776f27fff6cf6
addInt
public void addInt(int value)
{    validator.validate(value);}
d20b9b36dbc75e2020c3064708cbb0520f0f2b8c470e8db02accb4cbcb0005b6
convertINT64
public PrimitiveConverter convertINT64(PrimitiveTypeName primitiveTypeName)
{    final StatsValidator<Long> validator = new StatsValidator<Long>(page);    return new PrimitiveConverter() {        @Override        public void addLong(long value) {            validator.validate(value);        }    };}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    validator.validate(value);}
2ec17d66dfc871e660b0fb4c0b4cb0a849dc856b5c918fbe13d6ddc0d7bdadd5
convertBOOLEAN
public PrimitiveConverter convertBOOLEAN(PrimitiveTypeName primitiveTypeName)
{    final StatsValidator<Boolean> validator = new StatsValidator<Boolean>(page);    return new PrimitiveConverter() {        @Override        public void addBoolean(boolean value) {            validator.validate(value);        }    };}
23123f6657c241ab9b9f31f8efedc28a553ed91046d705121ce2667b065d6c17
addBoolean
public void addBoolean(boolean value)
{    validator.validate(value);}
df6cdccdcf78cbdcd55ae0927694bc70565035076282b875d4531e5afabf2f2d
convertINT96
public PrimitiveConverter convertINT96(PrimitiveTypeName primitiveTypeName)
{    return convertBINARY(primitiveTypeName);}
643456a237eb7fd4a33a2ab57acc0055d8a5dcfcd413abd3c0b4f67c298f93a7
convertFIXED_LEN_BYTE_ARRAY
public PrimitiveConverter convertFIXED_LEN_BYTE_ARRAY(PrimitiveTypeName primitiveTypeName)
{    return convertBINARY(primitiveTypeName);}
ef587a33a1e503d04d418eb33738423e02218e537b66d8d6415743f7d86ef048
convertBINARY
public PrimitiveConverter convertBINARY(PrimitiveTypeName primitiveTypeName)
{    final StatsValidator<Binary> validator = new StatsValidator<Binary>(page);    return new PrimitiveConverter() {        @Override        public void addBinary(Binary value) {            validator.validate(value);        }    };}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    validator.validate(value);}
51211b39bb21782aef46e9ad5ef9cf1d0419fcc0b1a05a9228d688f2eab31500
validate
public void validate(MessageType schema, PageReadStore store)
{    for (ColumnDescriptor desc : schema.getColumns()) {        PageReader reader = store.getPageReader(desc);        DictionaryPage dict = reader.readDictionaryPage();        DataPage page;        while ((page = reader.readPage()) != null) {            validateStatsForPage(page, dict, desc);        }    }}
0546c5baa9c5f7f44c19259f20691c6eccc497729b9de1e055b16f61fc6a40ba
validateStatsForPage
private void validateStatsForPage(DataPage page, DictionaryPage dict, ColumnDescriptor desc)
{    SingletonPageReader reader = new SingletonPageReader(dict, page);    PrimitiveConverter converter = getValidatingConverter(page, desc.getType());    Statistics<?> stats = getStatisticsFromPageHeader(page);    assertEquals("Statistics does not use the proper comparator", desc.getPrimitiveType().comparator().getClass(), stats.comparator().getClass());    if (stats.isEmpty()) {                        System.err.println(String.format("No stats written for page=%s col=%s", page, Arrays.toString(desc.getPath())));        return;    }    long numNulls = 0;    ColumnReaderImpl column = new ColumnReaderImpl(desc, reader, converter, null);    for (int i = 0; i < reader.getTotalValueCount(); i += 1) {        if (column.getCurrentDefinitionLevel() >= desc.getMaxDefinitionLevel()) {            column.writeCurrentValueToConverter();        } else {            numNulls += 1;        }        column.consume();    }    Assert.assertEquals(numNulls, stats.getNumNulls());    System.err.println(String.format("Validated stats min=%s max=%s nulls=%d for page=%s col=%s", stats.minAsString(), stats.maxAsString(), stats.getNumNulls(), page, Arrays.toString(desc.getPath())));}
6bcd63639b87d16af56a32272d9797dabb923af7b6f033e7cd046277d8cb2c69
buildSchema
private static MessageType buildSchema(long seed)
{    Random random = new Random(seed);    int fixedBinaryLength = random.nextInt(21) + 1;    int fixedPrecision = calculatePrecision(fixedBinaryLength);    int fixedScale = fixedPrecision / 4;    int binaryPrecision = calculatePrecision(16);    int binaryScale = binaryPrecision / 4;    return new MessageType("schema", new PrimitiveType(OPTIONAL, INT32, "i32"), new PrimitiveType(OPTIONAL, INT64, "i64"), new PrimitiveType(OPTIONAL, INT96, "i96"), new PrimitiveType(OPTIONAL, FLOAT, "sngl"), new PrimitiveType(OPTIONAL, DOUBLE, "dbl"), new PrimitiveType(OPTIONAL, BINARY, "strings"), new PrimitiveType(OPTIONAL, BINARY, "binary"), new PrimitiveType(OPTIONAL, FIXED_LEN_BYTE_ARRAY, fixedBinaryLength, "fixed-binary"), new PrimitiveType(REQUIRED, INT32, "unconstrained-i32"), new PrimitiveType(REQUIRED, INT64, "unconstrained-i64"), new PrimitiveType(REQUIRED, FLOAT, "unconstrained-sngl"), new PrimitiveType(REQUIRED, DOUBLE, "unconstrained-dbl"), Types.optional(INT32).as(OriginalType.INT_8).named("int8"), Types.optional(INT32).as(OriginalType.UINT_8).named("uint8"), Types.optional(INT32).as(OriginalType.INT_16).named("int16"), Types.optional(INT32).as(OriginalType.UINT_16).named("uint16"), Types.optional(INT32).as(OriginalType.INT_32).named("int32"), Types.optional(INT32).as(OriginalType.UINT_32).named("uint32"), Types.optional(INT64).as(OriginalType.INT_64).named("int64"), Types.optional(INT64).as(OriginalType.UINT_64).named("uint64"), Types.optional(INT32).as(OriginalType.DECIMAL).precision(9).scale(2).named("decimal-int32"), Types.optional(INT64).as(OriginalType.DECIMAL).precision(18).scale(4).named("decimal-int64"), Types.optional(FIXED_LEN_BYTE_ARRAY).length(fixedBinaryLength).as(OriginalType.DECIMAL).precision(fixedPrecision).scale(fixedScale).named("decimal-fixed"), Types.optional(BINARY).as(OriginalType.DECIMAL).precision(binaryPrecision).scale(binaryScale).named("decimal-binary"), Types.optional(BINARY).as(OriginalType.UTF8).named("utf8"), Types.optional(BINARY).as(OriginalType.ENUM).named("enum"), Types.optional(BINARY).as(OriginalType.JSON).named("json"), Types.optional(BINARY).as(OriginalType.BSON).named("bson"), Types.optional(INT32).as(OriginalType.DATE).named("date"), Types.optional(INT32).as(OriginalType.TIME_MILLIS).named("time-millis"), Types.optional(INT64).as(OriginalType.TIME_MICROS).named("time-micros"), Types.optional(INT64).as(OriginalType.TIMESTAMP_MILLIS).named("timestamp-millis"), Types.optional(INT64).as(OriginalType.TIMESTAMP_MICROS).named("timestamp-micros"), Types.optional(FIXED_LEN_BYTE_ARRAY).length(12).as(OriginalType.INTERVAL).named("interval"));}
bf569de1c39436f8a4897a4647dbc0ed57e95de2be48ebad47f6875a7d06aaf7
calculatePrecision
private static int calculatePrecision(int byteCnt)
{    String maxValue = BigInteger.valueOf(2L).pow(8 * byteCnt - 1).toString();    return maxValue.length() - 1;}
095ff3c0a21270ee93cdae98061f5278f17c50a7717b8d81b31640dc3f8d8187
write
public void write(ParquetWriter<Group> writer) throws IOException
{    for (int index = 0; index < recordCount; index++) {        Group group = new SimpleGroup(super.schema);        for (int column = 0, columnCnt = schema.getFieldCount(); column < columnCnt; ++column) {            Type type = schema.getType(column);            RandomValueGenerator<?> generator = randomGenerators.get(column);            if (type.isRepetition(OPTIONAL) && generator.shouldGenerateNull()) {                continue;            }            switch(type.asPrimitiveType().getPrimitiveTypeName()) {                case BINARY:                case FIXED_LEN_BYTE_ARRAY:                case INT96:                    group.append(type.getName(), ((RandomBinaryBase<?>) generator).nextBinaryValue());                    break;                case INT32:                    group.append(type.getName(), (Integer) generator.nextValue());                    break;                case INT64:                    group.append(type.getName(), (Long) generator.nextValue());                    break;                case FLOAT:                    group.append(type.getName(), (Float) generator.nextValue());                    break;                case DOUBLE:                    group.append(type.getName(), (Double) generator.nextValue());                    break;                case BOOLEAN:                    group.append(type.getName(), (Boolean) generator.nextValue());                    break;            }        }        writer.write(group);    }}
a2a314ef22554dd92e27423b4f2d7f98b9f605698c00bf86585d1f2c50b7ab22
test
public void test() throws IOException
{    Configuration configuration = new Configuration();    ParquetMetadata metadata = ParquetFileReader.readFooter(configuration, super.fsPath, ParquetMetadataConverter.NO_FILTER);    ParquetFileReader reader = new ParquetFileReader(configuration, metadata.getFileMetaData(), super.fsPath, metadata.getBlocks(), metadata.getFileMetaData().getSchema().getColumns());    PageStatsValidator validator = new PageStatsValidator();    PageReadStore pageReadStore;    while ((pageReadStore = reader.readNextRowGroup()) != null) {        validator.validate(metadata.getFileMetaData().getSchema(), pageReadStore);    }}
4619eda8b2ab381146e47276a68159b5ece63280ffda82d4eb85eb17b8068a0e
testStatistics
public void testStatistics() throws IOException
{    File file = folder.newFile("test_file.parquet");    file.delete();    System.out.println(String.format("RANDOM SEED: %s", RANDOM_SEED));    Random random = new Random(RANDOM_SEED);    int blockSize = (random.nextInt(54) + 10) * MEGABYTE;    int pageSize = (random.nextInt(10) + 1) * MEGABYTE;    List<DataContext> contexts = Arrays.asList(new DataContext(random.nextLong(), file, blockSize, pageSize, false, ParquetProperties.WriterVersion.PARQUET_1_0), new DataContext(random.nextLong(), file, blockSize, pageSize, true, ParquetProperties.WriterVersion.PARQUET_1_0), new DataContext(random.nextLong(), file, blockSize, pageSize, false, ParquetProperties.WriterVersion.PARQUET_2_0), new DataContext(random.nextLong(), file, blockSize, pageSize, true, ParquetProperties.WriterVersion.PARQUET_2_0));    for (DataContext test : contexts) {        DataGenerationContext.writeAndTest(test);    }}
60a3edace21edfae18d0d7093c9979848b748a42850b7211ba04bc4d2742ce7b
init
private void init(final JobConf job)
{    final String plan = HiveConf.getVar(job, HiveConf.ConfVars.PLAN);    if (mrwork == null && plan != null && plan.length() > 0) {        mrwork = Utilities.getMapRedWork(job);        pathToPartitionInfo.clear();        for (final Map.Entry<String, PartitionDesc> entry : mrwork.getPathToPartitionInfo().entrySet()) {            pathToPartitionInfo.put(new Path(entry.getKey()).toUri().getPath().toString(), entry.getValue());        }    }}
98cd1a0ea4811f27cb4154b20829bc35f825891cd3c1ee5cce6dabbdbf155978
pushProjectionsAndFilters
private void pushProjectionsAndFilters(final JobConf jobConf, final String splitPath, final String splitPathWithNoSchema)
{    if (mrwork == null) {        LOG.debug("Not pushing projections and filters because MapredWork is null");        return;    } else if (mrwork.getPathToAliases() == null) {        LOG.debug("Not pushing projections and filters because pathToAliases is null");        return;    }    final ArrayList<String> aliases = new ArrayList<String>();    final Iterator<Entry<String, ArrayList<String>>> iterator = mrwork.getPathToAliases().entrySet().iterator();    while (iterator.hasNext()) {        final Entry<String, ArrayList<String>> entry = iterator.next();        final String key = new Path(entry.getKey()).toUri().getPath();        if (splitPath.equals(key) || splitPathWithNoSchema.equals(key)) {            final ArrayList<String> list = entry.getValue();            for (final String val : list) {                aliases.add(val);            }        }    }    for (final String alias : aliases) {        final Operator<? extends Serializable> op = mrwork.getAliasToWork().get(alias);        if (op != null && op instanceof TableScanOperator) {            final TableScanOperator tableScan = (TableScanOperator) op;                        final ArrayList<Integer> list = tableScan.getNeededColumnIDs();            if (list != null) {                ColumnProjectionUtils.appendReadColumnIDs(jobConf, list);            } else {                ColumnProjectionUtils.setFullyReadColumns(jobConf);            }            pushFilters(jobConf, tableScan);        }    }}
a9283f183dbcf7e04b9e0c77464c56da6fd3260f4983694a21aa1212b953c6ba
pushFilters
private void pushFilters(final JobConf jobConf, final TableScanOperator tableScan)
{    final TableScanDesc scanDesc = tableScan.getConf();    if (scanDesc == null) {        LOG.debug("Not pushing filters because TableScanDesc is null");        return;    }        Utilities.setColumnNameList(jobConf, tableScan);        final ExprNodeDesc filterExpr = scanDesc.getFilterExpr();    if (filterExpr == null) {        LOG.debug("Not pushing filters because FilterExpr is null");        return;    }    final String filterText = filterExpr.getExprString();    final String filterExprSerialized = Utilities.serializeExpression(filterExpr);    jobConf.set(TableScanDesc.FILTER_TEXT_CONF_STR, filterText);    jobConf.set(TableScanDesc.FILTER_EXPR_CONF_STR, filterExprSerialized);}
16f387574eab5e8998e98b13b907e43b5b1968f504ac269fc947aec47c9af128
pushProjectionsAndFilters
public JobConf pushProjectionsAndFilters(JobConf jobConf, Path path) throws IOException
{    init(jobConf);    final JobConf cloneJobConf = new JobConf(jobConf);    final PartitionDesc part = pathToPartitionInfo.get(path.toString());    if ((part != null) && (part.getTableDesc() != null)) {        Utilities.copyTableJobPropertiesToConf(part.getTableDesc(), cloneJobConf);    }    pushProjectionsAndFilters(cloneJobConf, path.toString(), path.toUri().toString());    return cloneJobConf;}
60a3edace21edfae18d0d7093c9979848b748a42850b7211ba04bc4d2742ce7b
init
private void init(final JobConf job)
{    final String plan = HiveConf.getVar(job, HiveConf.ConfVars.PLAN);    if (mapWork == null && plan != null && plan.length() > 0) {        mapWork = Utilities.getMapWork(job);        pathToPartitionInfo.clear();        for (final Map.Entry<String, PartitionDesc> entry : mapWork.getPathToPartitionInfo().entrySet()) {            pathToPartitionInfo.put(new Path(entry.getKey()).toUri().getPath().toString(), entry.getValue());        }    }}
98cd1a0ea4811f27cb4154b20829bc35f825891cd3c1ee5cce6dabbdbf155978
pushProjectionsAndFilters
private void pushProjectionsAndFilters(final JobConf jobConf, final String splitPath, final String splitPathWithNoSchema)
{    if (mapWork == null) {        LOG.debug("Not pushing projections and filters because MapWork is null");        return;    } else if (mapWork.getPathToAliases() == null) {        LOG.debug("Not pushing projections and filters because pathToAliases is null");        return;    }    final ArrayList<String> aliases = new ArrayList<String>();    final Iterator<Entry<String, ArrayList<String>>> iterator = mapWork.getPathToAliases().entrySet().iterator();    while (iterator.hasNext()) {        final Entry<String, ArrayList<String>> entry = iterator.next();        final String key = new Path(entry.getKey()).toUri().getPath();        if (splitPath.equals(key) || splitPathWithNoSchema.equals(key)) {            final ArrayList<String> list = entry.getValue();            for (final String val : list) {                aliases.add(val);            }        }    }    for (final String alias : aliases) {        final Operator<? extends Serializable> op = mapWork.getAliasToWork().get(alias);        if (op != null && op instanceof TableScanOperator) {            final TableScanOperator tableScan = (TableScanOperator) op;                        final ArrayList<Integer> list = tableScan.getNeededColumnIDs();            if (list != null) {                ColumnProjectionUtils.appendReadColumnIDs(jobConf, list);            } else {                ColumnProjectionUtils.setFullyReadColumns(jobConf);            }            pushFilters(jobConf, tableScan);        }    }}
a9283f183dbcf7e04b9e0c77464c56da6fd3260f4983694a21aa1212b953c6ba
pushFilters
private void pushFilters(final JobConf jobConf, final TableScanOperator tableScan)
{    final TableScanDesc scanDesc = tableScan.getConf();    if (scanDesc == null) {        LOG.debug("Not pushing filters because TableScanDesc is null");        return;    }        Utilities.setColumnNameList(jobConf, tableScan);        final ExprNodeDesc filterExpr = scanDesc.getFilterExpr();    if (filterExpr == null) {        LOG.debug("Not pushing filters because FilterExpr is null");        return;    }    final String filterText = filterExpr.getExprString();    final String filterExprSerialized = Utilities.serializeExpression(filterExpr);    jobConf.set(TableScanDesc.FILTER_TEXT_CONF_STR, filterText);    jobConf.set(TableScanDesc.FILTER_EXPR_CONF_STR, filterExprSerialized);}
16f387574eab5e8998e98b13b907e43b5b1968f504ac269fc947aec47c9af128
pushProjectionsAndFilters
public JobConf pushProjectionsAndFilters(JobConf jobConf, Path path) throws IOException
{    init(jobConf);    final JobConf cloneJobConf = new JobConf(jobConf);    final PartitionDesc part = pathToPartitionInfo.get(path.toString());    if ((part != null) && (part.getTableDesc() != null)) {        Utilities.copyTableJobPropertiesToConf(part.getTableDesc(), cloneJobConf);    }    pushProjectionsAndFilters(cloneJobConf, path.toString(), path.toUri().toString());    return cloneJobConf;}
fbd77693bd9510335f1fa4d145fd9a756d4f1730b81929ae1fe7b433955c9142
create
public HiveBinding create()
{    Class<? extends HiveBinding> bindingClazz = create(HiveBindingFactory.class.getClassLoader());    try {        return bindingClazz.newInstance();    } catch (Exception e) {        throw new HiveBindingInstantiationError("Unexpected error creating instance" + " of " + bindingClazz.getCanonicalName(), e);    }}
3a69c01d826247c4daace1aa5a227051b9eb32fe06c8080dc1ee36d399e81706
create
 Class<? extends HiveBinding> create(ClassLoader classLoader)
{            Class hiveVersionInfo;    try {        hiveVersionInfo = Class.forName(HIVE_VERSION_CLASS_NAME, true, classLoader);    } catch (ClassNotFoundException e) {        LOG.debug("Class " + HIVE_VERSION_CLASS_NAME + ", not found, returning {}", Hive010Binding.class.getSimpleName());        return Hive010Binding.class;    }    return createInternal(hiveVersionInfo);}
f0d362b53f5fb409fa043a80e97cad1e9f2284f3e0c8757850fb40b25e1a3f2c
createInternal
 Class<? extends HiveBinding> createInternal(Class hiveVersionInfo)
{    String hiveVersion;    try {        Method getVersionMethod = hiveVersionInfo.getMethod(HIVE_VERSION_METHOD_NAME, (Class[]) null);        String rawVersion = (String) getVersionMethod.invoke(null, (Object[]) null);        LOG.debug("Raw Version from {} is '{}'", hiveVersionInfo.getSimpleName(), rawVersion);        hiveVersion = trimVersion(rawVersion);    } catch (Exception e) {        throw new UnexpectedHiveVersionProviderError("Unexpected error whilst " + "determining Hive version", e);    }    if (hiveVersion.equalsIgnoreCase(HIVE_VERSION_UNKNOWN)) {        LOG.debug("Unknown hive version, attempting to guess");        return createBindingForUnknownVersion();    }    if (hiveVersion.startsWith(HIVE_VERSION_010)) {        LOG.debug("Hive version {}, returning {}", hiveVersion, Hive010Binding.class.getSimpleName());        return Hive010Binding.class;    } else if (hiveVersion.startsWith(HIVE_VERSION_011)) {        LOG.debug("Hive version " + hiveVersion + ", returning " + Hive010Binding.class.getSimpleName() + " as it's expected the 0.10 " + "binding will work with 0.11");        return Hive010Binding.class;    } else if (hiveVersion.startsWith(HIVE_VERSION_013)) {        throw new HiveBindingInstantiationError("Hive 0.13 contains native Parquet support " + "and the parquet-hive jars from the parquet project should not be included " + "in Hive's classpath.");    }    LOG.debug("Hive version {}, returning {}", hiveVersion, Hive012Binding.class.getSimpleName());        return Hive012Binding.class;}
5079b8525fd55b3b112cdcb7111a1a99ff9b4e983c668e3b5b89bc6369280307
createBindingForUnknownVersion
private Class<? extends HiveBinding> createBindingForUnknownVersion()
{    try {        Class<?> utilitiesClass = Class.forName(HIVE_UTILITIES_CLASS_NAME);        for (Method method : utilitiesClass.getDeclaredMethods()) {            if (HIVE_012_INDICATOR_UTILITIES_GETMAPWORK.equals(method.getName())) {                LOG.debug("Found " + HIVE_UTILITIES_CLASS_NAME + "." + HIVE_012_INDICATOR_UTILITIES_GETMAPWORK + " returning 0.12 binding");                return Hive012Binding.class;            }        }                return Hive010Binding.class;    } catch (ClassNotFoundException e) {        LOG.debug("Could not find " + HIVE_UTILITIES_CLASS_NAME + ", returning" + " the latest binding since this class existed in 0.10, 0.11, and 0.12");        return LATEST_BINDING;    }}
1565344a6de396fbc2a17f1a16b707a8f064de12f82c05c8e575aea66e14668e
trimVersion
private static String trimVersion(String s)
{    if (s == null) {        return HIVE_VERSION_NULL;    }    return s.trim();}
5ff0b8f7d2b080bcc6214fa5f91be74727145ea81cacb63a99c8d0f3106c089f
setup
public void setup()
{    hiveBindingFactory = new HiveBindingFactory();}
1c3b21630442be72cf8138437d6544a324f65386885420da9f05b8a439730041
testMissingHiveVersionInfoClass
public void testMissingHiveVersionInfoClass()
{    Assert.assertEquals(Hive010Binding.class, hiveBindingFactory.create(new NoopClassLoader()));}
d4e09db2524512fef7fcac9dd647e088a80eaaee77491cf8bc85a40408129b64
testNoHiveVersion
public void testNoHiveVersion()
{    hiveBindingFactory.createInternal(NoHiveVersion.class);}
ef691819fd7417d125c38f36e4514f51f9f2e982d3d0f153f78b5a53c0912955
testBlankHiveVersion
public void testBlankHiveVersion()
{    hiveBindingFactory.createInternal(BlankHiveVersion.class);    Assert.assertEquals(Hive012Binding.class, hiveBindingFactory.createInternal(BlankHiveVersion.class));}
f0e07afff2f2bec6d831721202b8322266f852858ecd60bd3871649405fb2c5d
testUnknownHiveVersion
public void testUnknownHiveVersion()
{    hiveBindingFactory.createInternal(BlankHiveVersion.class);        Assert.assertEquals(Hive012Binding.class, hiveBindingFactory.createInternal(BlankHiveVersion.class));}
aa755c7184a8fb5d6978708c53892f898b7f319c07af09600700496b35029fc1
testNullHiveVersion
public void testNullHiveVersion()
{    hiveBindingFactory.createInternal(NullHiveVersion.class);    Assert.assertEquals(Hive012Binding.class, hiveBindingFactory.createInternal(NullHiveVersion.class));}
d539e8872ce933fba87ac4fe3fe025ab2f11a4f41b7b445ef7e50263e08f6071
testHive010
public void testHive010()
{    Assert.assertEquals(Hive010Binding.class, hiveBindingFactory.createInternal(Hive010Version.class));}
250ae67f917fc843656897f474cc5dbee72613f9906d98132e1aa719bab3a10e
testHive010WithSpaces
public void testHive010WithSpaces()
{    Assert.assertEquals(Hive010Binding.class, hiveBindingFactory.createInternal(Hive010VersionWithSpaces.class));}
366f562cb9cf362d9f287738662615d62cd84f2754f18f46b199232aec4e0c10
testHive011
public void testHive011()
{    Assert.assertEquals(Hive010Binding.class, hiveBindingFactory.createInternal(Hive011Version.class));}
5dbc214b255a6d7cd5f2594672df959044d2f89c82134dfa219b389cc47b1daf
testHive012
public void testHive012()
{    Assert.assertEquals(Hive012Binding.class, hiveBindingFactory.createInternal(Hive012Version.class));}
0ab3f3055c6091c16df1e74d4304b8f98c5c98b93fe41bd59ba02d66e3518d79
testHive013
public void testHive013()
{    hiveBindingFactory.createInternal(Hive013Version.class);}
1cf8d31b18814cf45ad6afad333b5205f83ccc60ecb85f4a486f90165859cf8f
loadClass
public Class<?> loadClass(String name) throws ClassNotFoundException
{    throw new ClassNotFoundException(name);}
09e2faf8b93816114e25a166e8a9df366645ed17d7b1f777d4604469c347b564
getVersion
public static String getVersion()
{    return "";}
09e2faf8b93816114e25a166e8a9df366645ed17d7b1f777d4604469c347b564
getVersion
public static String getVersion()
{    return HiveBindingFactory.HIVE_VERSION_UNKNOWN;}
09e2faf8b93816114e25a166e8a9df366645ed17d7b1f777d4604469c347b564
getVersion
public static String getVersion()
{    return null;}
09e2faf8b93816114e25a166e8a9df366645ed17d7b1f777d4604469c347b564
getVersion
public static String getVersion()
{    return HiveBindingFactory.HIVE_VERSION_010;}
09e2faf8b93816114e25a166e8a9df366645ed17d7b1f777d4604469c347b564
getVersion
public static String getVersion()
{    return " " + HiveBindingFactory.HIVE_VERSION_010 + " ";}
09e2faf8b93816114e25a166e8a9df366645ed17d7b1f777d4604469c347b564
getVersion
public static String getVersion()
{    return HiveBindingFactory.HIVE_VERSION_011;}
09e2faf8b93816114e25a166e8a9df366645ed17d7b1f777d4604469c347b564
getVersion
public static String getVersion()
{    return HiveBindingFactory.HIVE_VERSION_012;}
09e2faf8b93816114e25a166e8a9df366645ed17d7b1f777d4604469c347b564
getVersion
public static String getVersion()
{    return HiveBindingFactory.HIVE_VERSION_013;}
6f969d3ae3259adcb72ebba3b69fa75dd11119193fd1ef417cca2d4e9f2032fc
getColumns
public List<String> getColumns(final String columns)
{    final List<String> result = (List<String>) StringUtils.getStringCollection(columns);    result.removeAll(virtualColumns);    return result;}
19e1c8ef2992f7c9b48c8fd3685d8353daaeb54965be52b38d87adc7578c0a7d
getConverter
public Converter getConverter(final int fieldIndex)
{    return converters[fieldIndex];}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    if (isMap) {        mapPairContainer = new Writable[2];    }}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    if (isMap) {        currentValue = new ArrayWritable(Writable.class, mapPairContainer);    }    parent.add(index, currentValue);}
94b0d80561c742c2770de3cafc61853529d57c5af3491aac78d5803d363f008e
set
protected void set(final int index, final Writable value)
{    if (index != 0 && mapPairContainer == null || index > 1) {        throw new ParquetDecodingException("Repeated group can only have one or two fields for maps." + " Not allowed to set for the index : " + index);    }    if (isMap) {        mapPairContainer[index] = value;    } else {        currentValue = value;    }}
3b00f266c255dd24f552f6045e6ced32ebe83674d6671fc25b0d8bb7dabf50be
add
protected void add(final int index, final Writable value)
{    set(index, value);}
404075437747f7d413e5946eb934c95742ba463d1e2f9bad24ba60874950f201
getCurrentArray
public final ArrayWritable getCurrentArray()
{    final Writable[] writableArr;    if (this.rootMap != null) {                writableArr = this.rootMap;    } else {        writableArr = new Writable[currentArr.length];    }    for (int i = 0; i < currentArr.length; i++) {        final Object obj = currentArr[i];        if (obj instanceof List) {            final List<?> objList = (List<?>) obj;            final ArrayWritable arr = new ArrayWritable(Writable.class, objList.toArray(new Writable[objList.size()]));            writableArr[i] = arr;        } else {            writableArr[i] = (Writable) obj;        }    }    return new ArrayWritable(Writable.class, writableArr);}
e8073e7d531fdf97700a2f42643ae74280e0114492ada1ce28e80052be660644
set
protected final void set(final int index, final Writable value)
{    currentArr[index] = value;}
19e1c8ef2992f7c9b48c8fd3685d8353daaeb54965be52b38d87adc7578c0a7d
getConverter
public Converter getConverter(final int fieldIndex)
{    return converters[fieldIndex];}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    for (int i = 0; i < currentArr.length; i++) {        currentArr[i] = null;    }}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    if (parent != null) {        parent.set(index, getCurrentArray());    }}
3b00f266c255dd24f552f6045e6ced32ebe83674d6671fc25b0d8bb7dabf50be
add
protected void add(final int index, final Writable value)
{    if (currentArr[index] != null) {        final Object obj = currentArr[index];        if (obj instanceof List) {            final List<Writable> list = (List<Writable>) obj;            list.add(value);        } else {            throw new IllegalStateException("This should be a List: " + obj);        }    } else {                                        final List<Writable> buffer = new ArrayList<Writable>();        buffer.add(value);        currentArr[index] = (Object) buffer;    }}
d8bf1614a30361582aa09a9d51ac64e92e3db3011d8e8829523162739f8abcd4
getCurrentRecord
public ArrayWritable getCurrentRecord()
{    return root.getCurrentArray();}
92fd854c4aebb01be238d83e407159211ea5cf60b5efd6fc7db8904dba13699b
getRootConverter
public GroupConverter getRootConverter()
{    return root;}
45f2414f0fc4c4baea57e12383453767e2e54d2f8edd1aecbcd612d108069840
getType
private Class<?> getType()
{    return _type;}
3a4dfc62503500e175695b535acf07bdae379f3c9f7d20e780fd956d64f4f113
getNewConverter
public static Converter getNewConverter(final Class<?> type, final int index, final HiveGroupConverter parent)
{    for (final ETypeConverter eConverter : values()) {        if (eConverter.getType() == type) {            return eConverter.getConverter(type, index, parent);        }    }    throw new IllegalArgumentException("Converter not found ... for type : " + type);}
ca3086c494f00f0c22651803df41197591e654c043cfb077b1d81163b62f12e6
getConverter
 Converter getConverter(final Class<?> type, final int index, final HiveGroupConverter parent)
{    return new PrimitiveConverter() {        @Override        public void addDouble(final double value) {            parent.set(index, new DoubleWritable(value));        }    };}
2ca0a005d9d199b6c55dae31657f6695613fbabab00303ef12882d2d6bcca4a1
addDouble
public void addDouble(final double value)
{    parent.set(index, new DoubleWritable(value));}
ca3086c494f00f0c22651803df41197591e654c043cfb077b1d81163b62f12e6
getConverter
 Converter getConverter(final Class<?> type, final int index, final HiveGroupConverter parent)
{    return new PrimitiveConverter() {        @Override        public void addBoolean(final boolean value) {            parent.set(index, new BooleanWritable(value));        }    };}
b29fef1522da97c7f08339247b3ec6df8f38bcd64ecd099e6b87dfc57e7f05f1
addBoolean
public void addBoolean(final boolean value)
{    parent.set(index, new BooleanWritable(value));}
ca3086c494f00f0c22651803df41197591e654c043cfb077b1d81163b62f12e6
getConverter
 Converter getConverter(final Class<?> type, final int index, final HiveGroupConverter parent)
{    return new PrimitiveConverter() {        @Override        public void addFloat(final float value) {            parent.set(index, new FloatWritable(value));        }    };}
a6a96fd8908207ceb00be617cbf1ca3c86b469f7765bcc9e089fda462210467d
addFloat
public void addFloat(final float value)
{    parent.set(index, new FloatWritable(value));}
ca3086c494f00f0c22651803df41197591e654c043cfb077b1d81163b62f12e6
getConverter
 Converter getConverter(final Class<?> type, final int index, final HiveGroupConverter parent)
{    return new PrimitiveConverter() {        @Override        public void addInt(final int value) {            parent.set(index, new IntWritable(value));        }    };}
e102fd1f6a8c6044cfe6841f1c98f65acdda7515bf3f3ea360eafc314cfb6dea
addInt
public void addInt(final int value)
{    parent.set(index, new IntWritable(value));}
ca3086c494f00f0c22651803df41197591e654c043cfb077b1d81163b62f12e6
getConverter
 Converter getConverter(final Class<?> type, final int index, final HiveGroupConverter parent)
{    return new PrimitiveConverter() {        @Override        public void addLong(final long value) {            parent.set(index, new LongWritable(value));        }    };}
674e07818a2f843400429ee0117bd7c9d1cba353fc73c1627ef5a889aa96f46b
addLong
public void addLong(final long value)
{    parent.set(index, new LongWritable(value));}
ca3086c494f00f0c22651803df41197591e654c043cfb077b1d81163b62f12e6
getConverter
 Converter getConverter(final Class<?> type, final int index, final HiveGroupConverter parent)
{    return new PrimitiveConverter() {                @Override        public void addDouble(final double value) {            parent.set(index, new DoubleWritable(value));        }    };}
2ca0a005d9d199b6c55dae31657f6695613fbabab00303ef12882d2d6bcca4a1
addDouble
public void addDouble(final double value)
{    parent.set(index, new DoubleWritable(value));}
ca3086c494f00f0c22651803df41197591e654c043cfb077b1d81163b62f12e6
getConverter
 Converter getConverter(final Class<?> type, final int index, final HiveGroupConverter parent)
{    return new PrimitiveConverter() {        private Binary[] dictBinary;        private String[] dict;        @Override        public boolean hasDictionarySupport() {            return true;        }        @Override        public void setDictionary(Dictionary dictionary) {            dictBinary = new Binary[dictionary.getMaxId() + 1];            dict = new String[dictionary.getMaxId() + 1];            for (int i = 0; i <= dictionary.getMaxId(); i++) {                Binary binary = dictionary.decodeToBinary(i);                dictBinary[i] = binary;                dict[i] = binary.toStringUsingUTF8();            }        }        @Override        public void addValueFromDictionary(int dictionaryId) {            parent.set(index, new DicBinaryWritable(dictBinary[dictionaryId], dict[dictionaryId]));        }        @Override        public void addBinary(Binary value) {            parent.set(index, new BinaryWritable(value));        }    };}
7c3f73c96e69cb35837e756142746fd240f40ccf1d7d310c2436e6b135fe196b
hasDictionarySupport
public boolean hasDictionarySupport()
{    return true;}
5edde50d3cb88777a151a88dae34321ada39b284501a5295564b122126c5c393
setDictionary
public void setDictionary(Dictionary dictionary)
{    dictBinary = new Binary[dictionary.getMaxId() + 1];    dict = new String[dictionary.getMaxId() + 1];    for (int i = 0; i <= dictionary.getMaxId(); i++) {        Binary binary = dictionary.decodeToBinary(i);        dictBinary[i] = binary;        dict[i] = binary.toStringUsingUTF8();    }}
f1649786c3679c86c0157574e47953673714091cc71d598cedff963593010d98
addValueFromDictionary
public void addValueFromDictionary(int dictionaryId)
{    parent.set(index, new DicBinaryWritable(dictBinary[dictionaryId], dict[dictionaryId]));}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    parent.set(index, new BinaryWritable(value));}
838c67c03cc5780f7ada99423078d6491f5867a128adfddbea149508e64e2aa0
getConverterFromDescription
protected static Converter getConverterFromDescription(final Type type, final int index, final HiveGroupConverter parent)
{    if (type == null) {        return null;    }    if (type.isPrimitive()) {        return ETypeConverter.getNewConverter(type.asPrimitiveType().getPrimitiveTypeName().javaType, index, parent);    } else {        if (type.asGroupType().getRepetition() == Repetition.REPEATED) {            return new ArrayWritableGroupConverter(type.asGroupType(), parent, index);        } else {            return new DataWritableGroupConverter(type.asGroupType(), parent, index);        }    }}
f12ef4b0e8971d4faf7978ee377847b5dd082e63d3ae8aa3edf498237074c7c7
convert
public static MessageType convert(final List<String> columnNames, final List<TypeInfo> columnTypes)
{    final MessageType schema = new MessageType("hive_schema", convertTypes(columnNames, columnTypes));    return schema;}
3df98aed7051a64d9fbee1a8df227fb39aa6b935ed42c26d699577461c671447
convertTypes
private static Type[] convertTypes(final List<String> columnNames, final List<TypeInfo> columnTypes)
{    if (columnNames.size() != columnTypes.size()) {        throw new IllegalStateException("Mismatched Hive columns and types. Hive columns names" + " found : " + columnNames + " . And Hive types found : " + columnTypes);    }    final Type[] types = new Type[columnNames.size()];    for (int i = 0; i < columnNames.size(); ++i) {        types[i] = convertType(columnNames.get(i), columnTypes.get(i));    }    return types;}
f542e69d6bbb0a0e5b1c43dc8912f60797f97da309da7984227175174347e777
convertType
private static Type convertType(final String name, final TypeInfo typeInfo)
{    return convertType(name, typeInfo, Repetition.OPTIONAL);}
9ebe0ea0d1a14e0a15444fe2c2ce2ba65e4cb6498a28cd0a23fa955f9284de93
convertType
private static Type convertType(final String name, final TypeInfo typeInfo, final Repetition repetition)
{    if (typeInfo.getCategory().equals(Category.PRIMITIVE)) {        if (typeInfo.equals(TypeInfoFactory.stringTypeInfo)) {            return new PrimitiveType(repetition, PrimitiveTypeName.BINARY, name);        } else if (typeInfo.equals(TypeInfoFactory.intTypeInfo) || typeInfo.equals(TypeInfoFactory.shortTypeInfo) || typeInfo.equals(TypeInfoFactory.byteTypeInfo)) {            return new PrimitiveType(repetition, PrimitiveTypeName.INT32, name);        } else if (typeInfo.equals(TypeInfoFactory.longTypeInfo)) {            return new PrimitiveType(repetition, PrimitiveTypeName.INT64, name);        } else if (typeInfo.equals(TypeInfoFactory.doubleTypeInfo)) {            return new PrimitiveType(repetition, PrimitiveTypeName.DOUBLE, name);        } else if (typeInfo.equals(TypeInfoFactory.floatTypeInfo)) {            return new PrimitiveType(repetition, PrimitiveTypeName.FLOAT, name);        } else if (typeInfo.equals(TypeInfoFactory.booleanTypeInfo)) {            return new PrimitiveType(repetition, PrimitiveTypeName.BOOLEAN, name);        } else if (typeInfo.equals(TypeInfoFactory.binaryTypeInfo)) {                        throw new UnsupportedOperationException("Binary type not implemented");        } else if (typeInfo.equals(TypeInfoFactory.timestampTypeInfo)) {            throw new UnsupportedOperationException("Timestamp type not implemented");        } else if (typeInfo.equals(TypeInfoFactory.voidTypeInfo)) {            throw new UnsupportedOperationException("Void type not implemented");        } else if (typeInfo.equals(TypeInfoFactory.unknownTypeInfo)) {            throw new UnsupportedOperationException("Unknown type not implemented");        } else {            throw new IllegalArgumentException("Unknown type: " + typeInfo);        }    } else if (typeInfo.getCategory().equals(Category.LIST)) {        return convertArrayType(name, (ListTypeInfo) typeInfo);    } else if (typeInfo.getCategory().equals(Category.STRUCT)) {        return convertStructType(name, (StructTypeInfo) typeInfo);    } else if (typeInfo.getCategory().equals(Category.MAP)) {        return convertMapType(name, (MapTypeInfo) typeInfo);    } else if (typeInfo.getCategory().equals(Category.UNION)) {        throw new UnsupportedOperationException("Union type not implemented");    } else {        throw new IllegalArgumentException("Unknown type: " + typeInfo);    }}
cb6bf03bedc3e746ee51fcb4a53c7fc5b3f981d4d47a23ced741c5a5521dbdd8
convertArrayType
private static GroupType convertArrayType(final String name, final ListTypeInfo typeInfo)
{    final TypeInfo subType = typeInfo.getListElementTypeInfo();    return listWrapper(name, listType(), new GroupType(Repetition.REPEATED, ParquetHiveSerDe.ARRAY.toString(), convertType("array_element", subType)));}
da42bb71e2f8c2fc520b31e623e369a2a502e67cb2cbdaf09f3ef9cfa10afe74
convertStructType
private static GroupType convertStructType(final String name, final StructTypeInfo typeInfo)
{    final List<String> columnNames = typeInfo.getAllStructFieldNames();    final List<TypeInfo> columnTypes = typeInfo.getAllStructFieldTypeInfos();    return new GroupType(Repetition.OPTIONAL, name, convertTypes(columnNames, columnTypes));}
bb4da8392e127aa342fb7ae143905070c2babb5b94c51ae499c991afbe57e546
convertMapType
private static GroupType convertMapType(final String name, final MapTypeInfo typeInfo)
{    final Type keyType = convertType(ParquetHiveSerDe.MAP_KEY.toString(), typeInfo.getMapKeyTypeInfo(), Repetition.REQUIRED);    final Type valueType = convertType(ParquetHiveSerDe.MAP_VALUE.toString(), typeInfo.getMapValueTypeInfo());    return ConversionPatterns.mapType(Repetition.OPTIONAL, name, keyType, valueType);}
232b0e1744e462f3ab6108740bb52079c48b10d7149108cbab5d71ff600e1e15
listWrapper
private static GroupType listWrapper(final String name, final LogicalTypeAnnotation logicalTypeAnnotation, final GroupType groupType)
{    return Types.optionalGroup().addField(groupType).as(logicalTypeAnnotation).named(name);}
f1844a607ee4e941e9f081439ea8762477b7ca3843d906fc80ef69f99d9a4d05
getRecordReader
public org.apache.hadoop.mapred.RecordReader<Void, ArrayWritable> getRecordReader(final org.apache.hadoop.mapred.InputSplit split, final org.apache.hadoop.mapred.JobConf job, final org.apache.hadoop.mapred.Reporter reporter) throws IOException
{    try {        return (RecordReader<Void, ArrayWritable>) new ParquetRecordReaderWrapper(realInput, split, job, reporter);    } catch (final InterruptedException e) {        throw new RuntimeException("Cannot create a RecordReaderWrapper", e);    }}
5a2d2da6fb02e19e58b6a7d510d964ae589ac81d78eac35ecc342f1aaaffa772
checkOutputSpecs
public void checkOutputSpecs(final FileSystem ignored, final JobConf job) throws IOException
{    realOutputFormat.checkOutputSpecs(ShimLoader.getHadoopShims().getHCatShim().createJobContext(job, null));}
ac14ef1c3fe78936861d21f98300282970494ee37764a17b7664b41fcfaa07b0
getRecordWriter
public RecordWriter<Void, ArrayWritable> getRecordWriter(final FileSystem ignored, final JobConf job, final String name, final Progressable progress) throws IOException
{    throw new RuntimeException("Should never be used");}
2137c70ab43fe991187b563ff31bb8dfb4f3ef5a83bf5c4d85e79611ecde0de1
getHiveRecordWriter
public FileSinkOperator.RecordWriter getHiveRecordWriter(final JobConf jobConf, final Path finalOutPath, final Class<? extends Writable> valueClass, final boolean isCompressed, final Properties tableProperties, final Progressable progress) throws IOException
{    LOG.info("creating new record writer...{}", this);    final String columnNameProperty = tableProperties.getProperty(IOConstants.COLUMNS);    final String columnTypeProperty = tableProperties.getProperty(IOConstants.COLUMNS_TYPES);    List<String> columnNames;    List<TypeInfo> columnTypes;    if (columnNameProperty.length() == 0) {        columnNames = new ArrayList<String>();    } else {        columnNames = Arrays.asList(columnNameProperty.split(","));    }    if (columnTypeProperty.length() == 0) {        columnTypes = new ArrayList<TypeInfo>();    } else {        columnTypes = TypeInfoUtils.getTypeInfosFromTypeString(columnTypeProperty);    }    DataWritableWriteSupport.setSchema(HiveSchemaConverter.convert(columnNames, columnTypes), jobConf);    return getParquerRecordWriterWrapper(realOutputFormat, jobConf, finalOutPath.toString(), progress);}
5d0fce7302f2d0cdb3b41b1b89ea76aec35c5abcb29d45fd7ecdb2afa4f1143d
getParquerRecordWriterWrapper
protected ParquetRecordWriterWrapper getParquerRecordWriterWrapper(ParquetOutputFormat<ArrayWritable> realOutputFormat, JobConf jobConf, String finalOutPath, Progressable progress) throws IOException
{    return new ParquetRecordWriterWrapper(realOutputFormat, jobConf, finalOutPath.toString(), progress);}
7e8c26a3567c60d14ee1bfef34e70d5ee82753114c1e2b48accc67bb771348eb
getColumns
private static List<String> getColumns(final String columns)
{    return (new HiveBindingFactory()).create().getColumns(columns);}
66f454cc9469e2c520473efea1cd17fca98880f5bf43524379b7e8f0f5a6089e
init
public org.apache.parquet.hadoop.api.ReadSupport.ReadContext init(final Configuration configuration, final Map<String, String> keyValueMetaData, final MessageType fileSchema)
{    final String columns = configuration.get(IOConstants.COLUMNS);    final Map<String, String> contextMetadata = new HashMap<String, String>();    if (columns != null) {        final List<String> listColumns = getColumns(columns);        final List<Type> typeListTable = new ArrayList<Type>();        for (final String col : listColumns) {                        if (fileSchema.containsField(col)) {                typeListTable.add(fileSchema.getType(col));            } else {                                typeListTable.add(new PrimitiveType(Repetition.OPTIONAL, PrimitiveTypeName.BINARY, col));            }        }        MessageType tableSchema = new MessageType(TABLE_SCHEMA, typeListTable);        contextMetadata.put(HIVE_SCHEMA_KEY, tableSchema.toString());        MessageType requestedSchemaByUser = tableSchema;        final List<Integer> indexColumnsWanted = ColumnProjectionUtils.getReadColumnIDs(configuration);        final List<Type> typeListWanted = new ArrayList<Type>();        for (final Integer idx : indexColumnsWanted) {            typeListWanted.add(tableSchema.getType(listColumns.get(idx)));        }        requestedSchemaByUser = resolveSchemaAccess(new MessageType(fileSchema.getName(), typeListWanted), fileSchema, configuration);        return new ReadContext(requestedSchemaByUser, contextMetadata);    } else {        contextMetadata.put(HIVE_SCHEMA_KEY, fileSchema.toString());        return new ReadContext(fileSchema, contextMetadata);    }}
0a7f87e8477538a4393a888c8b09497b9192f1028a8be84099da54eef5dcdb23
prepareForRead
public RecordMaterializer<ArrayWritable> prepareForRead(final Configuration configuration, final Map<String, String> keyValueMetaData, final MessageType fileSchema, final org.apache.parquet.hadoop.api.ReadSupport.ReadContext readContext)
{    final Map<String, String> metadata = readContext.getReadSupportMetadata();    if (metadata == null) {        throw new IllegalStateException("ReadContext not initialized properly. " + "Don't know the Hive Schema.");    }    final MessageType tableSchema = resolveSchemaAccess(MessageTypeParser.parseMessageType(metadata.get(HIVE_SCHEMA_KEY)), fileSchema, configuration);    return new DataWritableRecordConverter(readContext.getRequestedSchema(), tableSchema);}
0d58b5e165fe75bfeb60e7b37169370ce9f363d6a0d42af200b9d234d69a7ee2
resolveSchemaAccess
private MessageType resolveSchemaAccess(MessageType requestedSchema, MessageType fileSchema, Configuration configuration)
{    if (configuration.getBoolean(PARQUET_COLUMN_INDEX_ACCESS, false)) {        final List<String> listColumns = getColumns(configuration.get(IOConstants.COLUMNS));        List<Type> requestedTypes = new ArrayList<Type>();        for (Type t : requestedSchema.getFields()) {            int index = listColumns.indexOf(t.getName());            requestedTypes.add(fileSchema.getType(index));        }        requestedSchema = new MessageType(requestedSchema.getName(), requestedTypes);    }    return requestedSchema;}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    if (realReader != null) {        realReader.close();    }}
ab17e9bb26eedecd2ccbaf58c7b672205c1e41f638f1cfe6f44a1bbdc8c3b2fe
createKey
public Void createKey()
{    return null;}
1666622207f0cc72d754e75311e06e9ebc46a23e5c86cf713a2a59225a4efa50
createValue
public ArrayWritable createValue()
{    return valueObj;}
5800a0f531c192e683ef74c0c5de6015daf6261d1f8e5c0ce6d8e043b01926c7
getPos
public long getPos() throws IOException
{    return (long) (splitLen * getProgress());}
46dc59cbf7e4d6aafe0869ef2726ed2c5c897b673d9e37f94ab9b0e962f65f7f
getProgress
public float getProgress() throws IOException
{    if (realReader == null) {        return 1f;    } else {        try {            return realReader.getProgress();        } catch (final InterruptedException e) {            throw new IOException(e);        }    }}
7d8f410e35467ed09a1be07e592726b6c6ec3835b121279569d0fb4d0c510a11
next
public boolean next(final Void key, final ArrayWritable value) throws IOException
{    if (eof) {        return false;    }    try {        if (firstRecord) {                        firstRecord = false;        } else if (!realReader.nextKeyValue()) {                        eof = true;            return false;        }        final ArrayWritable tmpCurValue = realReader.getCurrentValue();        if (value != tmpCurValue) {            final Writable[] arrValue = value.get();            final Writable[] arrCurrent = tmpCurValue.get();            if (value != null && arrValue.length == arrCurrent.length) {                System.arraycopy(arrCurrent, 0, arrValue, 0, arrCurrent.length);            } else {                if (arrValue.length != arrCurrent.length) {                    throw new IOException("DeprecatedParquetHiveInput : size of object differs. Value" + " size :  " + arrValue.length + ", Current Object size : " + arrCurrent.length);                } else {                    throw new IOException("DeprecatedParquetHiveInput can not support RecordReaders that" + " don't return same key & value & value is null");                }            }        }        return true;    } catch (final InterruptedException e) {        throw new IOException(e);    }}
22eab0564c85c5f918c5af07b3ba8b1f0337e3300827ddb6e395a50353d7039a
getSplit
protected ParquetInputSplit getSplit(final InputSplit oldSplit, final JobConf conf) throws IOException
{    if (oldSplit instanceof FileSplit) {        FileSplit fileSplit = (FileSplit) oldSplit;        final long splitStart = fileSplit.getStart();        final long splitLength = fileSplit.getLength();        final Path finalPath = fileSplit.getPath();        final JobConf cloneJob = hiveBinding.pushProjectionsAndFilters(conf, finalPath.getParent());        final ParquetMetadata parquetMetadata = ParquetFileReader.readFooter(cloneJob, finalPath, SKIP_ROW_GROUPS);        final FileMetaData fileMetaData = parquetMetadata.getFileMetaData();        final ReadContext readContext = new DataWritableReadSupport().init(cloneJob, fileMetaData.getKeyValueMetaData(), fileMetaData.getSchema());        schemaSize = MessageTypeParser.parseMessageType(readContext.getReadSupportMetadata().get(DataWritableReadSupport.HIVE_SCHEMA_KEY)).getFieldCount();        return new ParquetInputSplit(finalPath, splitStart, splitStart + splitLength, splitLength, fileSplit.getLocations(), null);    } else {        throw new IllegalArgumentException("Unknown split type: " + oldSplit);    }}
88a68a3ee6b234582e3edd2c4088ad7f37703bddadcb5316201b7c1414ffd7f7
getTypeName
public String getTypeName()
{    return "map<" + keyInspector.getTypeName() + "," + valueInspector.getTypeName() + ">";}
06e7276653655304077b7ce8888a73649f317a110fd344242b94409cc8a55357
getCategory
public Category getCategory()
{    return Category.MAP;}
a0d0241b90e48afa1714aa7c823a97c731b66885d0dbbfbb1c9d751165f448d7
getMapKeyObjectInspector
public ObjectInspector getMapKeyObjectInspector()
{    return keyInspector;}
962170f5b417721ad8a8c5c55396defc23a888cd94d2e4f8864d23b9a8c636b6
getMapValueObjectInspector
public ObjectInspector getMapValueObjectInspector()
{    return valueInspector;}
8a4cf65f840662590608635a8ada41b2d0f33f593ce57d5a586bde3aa64c22b1
getMap
public Map<?, ?> getMap(final Object data)
{    if (data == null) {        return null;    }    if (data instanceof ArrayWritable) {        final Writable[] mapContainer = ((ArrayWritable) data).get();        if (mapContainer == null || mapContainer.length == 0) {            return null;        }        final Writable[] mapArray = ((ArrayWritable) mapContainer[0]).get();        final Map<Writable, Writable> map = new HashMap<Writable, Writable>();        for (final Writable obj : mapArray) {            final ArrayWritable mapObj = (ArrayWritable) obj;            final Writable[] arr = mapObj.get();            map.put(arr[0], arr[1]);        }        return map;    }    if (data instanceof Map) {        return (Map) data;    }    throw new UnsupportedOperationException("Cannot inspect " + data.getClass().getCanonicalName());}
38d09f5deee8e4c60ec8c517b7b26063f642df4e8af6564dd695d15c0ad4dfd6
getMapSize
public int getMapSize(final Object data)
{    if (data == null) {        return -1;    }    if (data instanceof ArrayWritable) {        final Writable[] mapContainer = ((ArrayWritable) data).get();        if (mapContainer == null || mapContainer.length == 0) {            return -1;        } else {            return ((ArrayWritable) mapContainer[0]).get().length;        }    }    if (data instanceof Map) {        return ((Map) data).size();    }    throw new UnsupportedOperationException("Cannot inspect " + data.getClass().getCanonicalName());}
a2bbbd59ecc7577760513effeadb40a77a034ce66533f64f40068e70126620e0
create
public Object create()
{    Map<Object, Object> m = new HashMap<Object, Object>();    return m;}
a9594ea0a2506de109d96446ef6f432f177e8aa24fd17ad0336e5956d015a67c
put
public Object put(Object map, Object key, Object value)
{    Map<Object, Object> m = (HashMap<Object, Object>) map;    m.put(key, value);    return m;}
ed151d8933f27525623e1d84bf9e9b22656c37b830bfbb2f4c91d97af27e53e9
remove
public Object remove(Object map, Object key)
{    Map<Object, Object> m = (HashMap<Object, Object>) map;    m.remove(key);    return m;}
814a45d0a13b5d0a1da08f0fe436f5925a8ffdac7c16bccc5ded074b2dc89b26
clear
public Object clear(Object map)
{    Map<Object, Object> m = (HashMap<Object, Object>) map;    m.clear();    return m;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    final int prime = 31;    int result = 1;    result = prime * result + ((keyInspector == null) ? 0 : keyInspector.hashCode());    result = prime * result + ((valueInspector == null) ? 0 : valueInspector.hashCode());    return result;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (obj == null) {        return false;    }    if (getClass() != obj.getClass()) {        return false;    }    final AbstractParquetMapInspector other = (AbstractParquetMapInspector) obj;    if (keyInspector == null) {        if (other.keyInspector != null) {            return false;        }    } else if (!keyInspector.equals(other.keyInspector)) {        return false;    }    if (valueInspector == null) {        if (other.valueInspector != null) {            return false;        }    } else if (!valueInspector.equals(other.valueInspector)) {        return false;    }    return true;}
7f7c4947668847563a871f6a053d31b19d1f6b199a020b3b9dd4837ecc85497d
getObjectInspector
private ObjectInspector getObjectInspector(final TypeInfo typeInfo)
{    if (typeInfo.equals(TypeInfoFactory.doubleTypeInfo)) {        return PrimitiveObjectInspectorFactory.writableDoubleObjectInspector;    } else if (typeInfo.equals(TypeInfoFactory.booleanTypeInfo)) {        return PrimitiveObjectInspectorFactory.writableBooleanObjectInspector;    } else if (typeInfo.equals(TypeInfoFactory.floatTypeInfo)) {        return PrimitiveObjectInspectorFactory.writableFloatObjectInspector;    } else if (typeInfo.equals(TypeInfoFactory.intTypeInfo)) {        return PrimitiveObjectInspectorFactory.writableIntObjectInspector;    } else if (typeInfo.equals(TypeInfoFactory.longTypeInfo)) {        return PrimitiveObjectInspectorFactory.writableLongObjectInspector;    } else if (typeInfo.equals(TypeInfoFactory.stringTypeInfo)) {        return ParquetPrimitiveInspectorFactory.parquetStringInspector;    } else if (typeInfo.getCategory().equals(Category.STRUCT)) {        return new ArrayWritableObjectInspector((StructTypeInfo) typeInfo);    } else if (typeInfo.getCategory().equals(Category.LIST)) {        final TypeInfo subTypeInfo = ((ListTypeInfo) typeInfo).getListElementTypeInfo();        return new ParquetHiveArrayInspector(getObjectInspector(subTypeInfo));    } else if (typeInfo.getCategory().equals(Category.MAP)) {        final TypeInfo keyTypeInfo = ((MapTypeInfo) typeInfo).getMapKeyTypeInfo();        final TypeInfo valueTypeInfo = ((MapTypeInfo) typeInfo).getMapValueTypeInfo();        if (keyTypeInfo.equals(TypeInfoFactory.stringTypeInfo) || keyTypeInfo.equals(TypeInfoFactory.byteTypeInfo) || keyTypeInfo.equals(TypeInfoFactory.shortTypeInfo)) {            return new DeepParquetHiveMapInspector(getObjectInspector(keyTypeInfo), getObjectInspector(valueTypeInfo));        } else {            return new StandardParquetHiveMapInspector(getObjectInspector(keyTypeInfo), getObjectInspector(valueTypeInfo));        }    } else if (typeInfo.equals(TypeInfoFactory.timestampTypeInfo)) {        throw new UnsupportedOperationException("timestamp not implemented yet");    } else if (typeInfo.equals(TypeInfoFactory.byteTypeInfo)) {        return ParquetPrimitiveInspectorFactory.parquetByteInspector;    } else if (typeInfo.equals(TypeInfoFactory.shortTypeInfo)) {        return ParquetPrimitiveInspectorFactory.parquetShortInspector;    } else {        throw new IllegalArgumentException("Unknown field info: " + typeInfo);    }}
06e7276653655304077b7ce8888a73649f317a110fd344242b94409cc8a55357
getCategory
public Category getCategory()
{    return Category.STRUCT;}
88a68a3ee6b234582e3edd2c4088ad7f37703bddadcb5316201b7c1414ffd7f7
getTypeName
public String getTypeName()
{    return typeInfo.getTypeName();}
554c31d42d4551800fa973ece4281752275976a8f168bf1c814b1ffa6659034d
getAllStructFieldRefs
public List<? extends StructField> getAllStructFieldRefs()
{    return fields;}
42f4f7358cec66f8ea8385961ef9013a23c1a057bfe383ea248b34386106577f
getStructFieldData
public Object getStructFieldData(final Object data, final StructField fieldRef)
{    if (data == null) {        return null;    }    if (data instanceof ArrayWritable) {        final ArrayWritable arr = (ArrayWritable) data;        return arr.get()[((StructFieldImpl) fieldRef).getIndex()];    }        if (data instanceof List) {        return ((List) data).get(((StructFieldImpl) fieldRef).getIndex());    }    throw new UnsupportedOperationException("Cannot inspect " + data.getClass().getCanonicalName());}
d6177485278a381695e26a6193e2a77d76c8409b5d17311eae70e4df4db7e23e
getStructFieldRef
public StructField getStructFieldRef(final String name)
{    return fieldsByName.get(name);}
bc1facebed23fcb529a1e21dabc09457920c097bb04a118de7c3dfc5e4336da7
getStructFieldsDataAsList
public List<Object> getStructFieldsDataAsList(final Object data)
{    if (data == null) {        return null;    }    if (data instanceof ArrayWritable) {        final ArrayWritable arr = (ArrayWritable) data;        final Object[] arrWritable = arr.get();        return new ArrayList<Object>(Arrays.asList(arrWritable));    }    throw new UnsupportedOperationException("Cannot inspect " + data.getClass().getCanonicalName());}
a2bbbd59ecc7577760513effeadb40a77a034ce66533f64f40068e70126620e0
create
public Object create()
{    final ArrayList<Object> list = new ArrayList<Object>(fields.size());    for (int i = 0; i < fields.size(); ++i) {        list.add(null);    }    return list;}
e52167c2a0d4ba8bce26d7d65d27b21e61a0c9e139b66c818a9141939ff5e3b3
setStructFieldData
public Object setStructFieldData(Object struct, StructField field, Object fieldValue)
{    final ArrayList<Object> list = (ArrayList<Object>) struct;    list.set(((StructFieldImpl) field).getIndex(), fieldValue);    return list;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (obj == null) {        return false;    }    if (getClass() != obj.getClass()) {        return false;    }    final ArrayWritableObjectInspector other = (ArrayWritableObjectInspector) obj;    if (this.typeInfo != other.typeInfo && (this.typeInfo == null || !this.typeInfo.equals(other.typeInfo))) {        return false;    }    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int hash = 5;    hash = 29 * hash + (this.typeInfo != null ? this.typeInfo.hashCode() : 0);    return hash;}
20ac56fa624aaa95f761d887c5572a0274ee87fe468c24dcff0cbbc91a1f44ed
getFieldComment
public String getFieldComment()
{    return "";}
68f4afd0e3cff42097dd5b6508fea1f7952d6d93f52ded3c1deea7186fff780c
getFieldName
public String getFieldName()
{    return name;}
d4663f435afd6a88c00a18d16d8d8e2fe6c896dd995d5906395fd4ddbb8b7760
getIndex
public int getIndex()
{    return index;}
7c8678e90926acce917aaedefa34493c7c67e506c698ed46dfd8ed1264fd587f
getFieldObjectInspector
public ObjectInspector getFieldObjectInspector()
{    return inspector;}
f8eeaa9f30306e392cbbe93c82b126f5c58c1f749457f6eb8e51b81a38930c7f
getMapValueElement
public Object getMapValueElement(final Object data, final Object key)
{    if (data == null || key == null) {        return null;    }    if (data instanceof ArrayWritable) {        final Writable[] mapContainer = ((ArrayWritable) data).get();        if (mapContainer == null || mapContainer.length == 0) {            return null;        }        final Writable[] mapArray = ((ArrayWritable) mapContainer[0]).get();        for (final Writable obj : mapArray) {            final ArrayWritable mapObj = (ArrayWritable) obj;            final Writable[] arr = mapObj.get();            if (key.equals(arr[0]) || key.equals(((PrimitiveObjectInspector) keyInspector).getPrimitiveJavaObject(arr[0])) || key.equals(((PrimitiveObjectInspector) keyInspector).getPrimitiveWritableObject(arr[0]))) {                return arr[1];            }        }        return null;    }    if (data instanceof Map) {        final Map<?, ?> map = (Map<?, ?>) data;        if (map.containsKey(key)) {            return map.get(key);        }        for (final Map.Entry<?, ?> entry : map.entrySet()) {            if (key.equals(((PrimitiveObjectInspector) keyInspector).getPrimitiveJavaObject(entry.getKey())) || key.equals(((PrimitiveObjectInspector) keyInspector).getPrimitiveWritableObject(entry.getKey()))) {                return entry.getValue();            }        }        return null;    }    throw new UnsupportedOperationException("Cannot inspect " + data.getClass().getCanonicalName());}
88a68a3ee6b234582e3edd2c4088ad7f37703bddadcb5316201b7c1414ffd7f7
getTypeName
public String getTypeName()
{    return "array<" + arrayElementInspector.getTypeName() + ">";}
06e7276653655304077b7ce8888a73649f317a110fd344242b94409cc8a55357
getCategory
public Category getCategory()
{    return Category.LIST;}
bb85bd95e2a331983c346a36bad1c805de12de4a04aadee80d0b30f517f6a935
getListElementObjectInspector
public ObjectInspector getListElementObjectInspector()
{    return arrayElementInspector;}
026ca5393d1f9c69dde683428d4c0dfb46a3c0b5df08fd2ca725ebe31c9ef1dd
getListElement
public Object getListElement(final Object data, final int index)
{    if (data == null) {        return null;    }    if (data instanceof ArrayWritable) {        final Writable[] listContainer = ((ArrayWritable) data).get();        if (listContainer == null || listContainer.length == 0) {            return null;        }        final Writable subObj = listContainer[0];        if (subObj == null) {            return null;        }        if (index >= 0 && index < ((ArrayWritable) subObj).get().length) {            return ((ArrayWritable) subObj).get()[index];        } else {            return null;        }    }    throw new UnsupportedOperationException("Cannot inspect " + data.getClass().getCanonicalName());}
0c2effd1b03cd1a026bc189b5ab8d1bc24e9fbb7a033085c6be44bbe782a01df
getListLength
public int getListLength(final Object data)
{    if (data == null) {        return -1;    }    if (data instanceof ArrayWritable) {        final Writable[] listContainer = ((ArrayWritable) data).get();        if (listContainer == null || listContainer.length == 0) {            return -1;        }        final Writable subObj = listContainer[0];        if (subObj == null) {            return 0;        }        return ((ArrayWritable) subObj).get().length;    }    throw new UnsupportedOperationException("Cannot inspect " + data.getClass().getCanonicalName());}
9d461958592d3970d8536b5b2a09ab77268384c22818a9da9b6a43354e2c31c1
getList
public List<?> getList(final Object data)
{    if (data == null) {        return null;    }    if (data instanceof ArrayWritable) {        final Writable[] listContainer = ((ArrayWritable) data).get();        if (listContainer == null || listContainer.length == 0) {            return null;        }        final Writable subObj = listContainer[0];        if (subObj == null) {            return null;        }        final Writable[] array = ((ArrayWritable) subObj).get();        final List<Writable> list = new ArrayList<Writable>();        for (final Writable obj : array) {            list.add(obj);        }        return list;    }    throw new UnsupportedOperationException("Cannot inspect " + data.getClass().getCanonicalName());}
5b53735eaf75691b7a6d672085ee36ac74213ece6c3dc589fa4f54a28fadd97d
create
public Object create(final int size)
{    final ArrayList<Object> result = new ArrayList<Object>(size);    for (int i = 0; i < size; ++i) {        result.add(null);    }    return result;}
26a77c9f85414773a0e96ec66fc8f11fbf6271dbbf5e4c4903959a6b354047e3
set
public Object set(final Object list, final int index, final Object element)
{    final ArrayList l = (ArrayList) list;    l.set(index, element);    return list;}
9eb1badbac5f40131033502e28622e8994f260d884b88535d669c5cc7d76caa2
resize
public Object resize(final Object list, final int newSize)
{    final ArrayList l = (ArrayList) list;    l.ensureCapacity(newSize);    while (l.size() < newSize) {        l.add(null);    }    while (l.size() > newSize) {        l.remove(l.size() - 1);    }    return list;}
f6a4bc9c984f0974eb85f8f8ad8feca482baa4c4354a8f102e02381f2bd0fd7c
equals
public boolean equals(final Object o)
{    if (o == null || o.getClass() != getClass()) {        return false;    } else if (o == this) {        return true;    } else {        final ObjectInspector other = ((ParquetHiveArrayInspector) o).arrayElementInspector;        return other.equals(arrayElementInspector);    }}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int hash = 3;    hash = 29 * hash + (this.arrayElementInspector != null ? this.arrayElementInspector.hashCode() : 0);    return hash;}
971cf4880bb68477ec13c9b49cd6a748be4a9f7c1a5eaaf5066ec184fbeb0771
initialize
public final void initialize(final Configuration conf, final Properties tbl) throws SerDeException
{    final TypeInfo rowTypeInfo;    final List<String> columnNames;    final List<TypeInfo> columnTypes;        final String columnNameProperty = tbl.getProperty(IOConstants.COLUMNS);    final String columnTypeProperty = tbl.getProperty(IOConstants.COLUMNS_TYPES);    if (columnNameProperty.length() == 0) {        columnNames = new ArrayList<String>();    } else {        columnNames = Arrays.asList(columnNameProperty.split(","));    }    if (columnTypeProperty.length() == 0) {        columnTypes = new ArrayList<TypeInfo>();    } else {        columnTypes = TypeInfoUtils.getTypeInfosFromTypeString(columnTypeProperty);    }    if (columnNames.size() != columnTypes.size()) {        throw new IllegalArgumentException("ParquetHiveSerde initialization failed. Number of column " + "name and column type differs. columnNames = " + columnNames + ", columnTypes = " + columnTypes);    }        rowTypeInfo = TypeInfoFactory.getStructTypeInfo(columnNames, columnTypes);    this.objInspector = new ArrayWritableObjectInspector((StructTypeInfo) rowTypeInfo);        stats = new SerDeStats();    serializedSize = 0;    deserializedSize = 0;    status = LAST_OPERATION.UNKNOWN;}
c78f4bca2eae11a5cb1ac02e2db98dfdf61b964e45db494faea8b98ab3989d87
deserialize
public Object deserialize(final Writable blob) throws SerDeException
{    status = LAST_OPERATION.DESERIALIZE;    deserializedSize = 0;    if (blob instanceof ArrayWritable) {        deserializedSize = ((ArrayWritable) blob).get().length;        return blob;    } else {        return null;    }}
501e731fa4abd794b84dd93779ab54049516b55930d26555beddb262d86f3ca6
getObjectInspector
public ObjectInspector getObjectInspector() throws SerDeException
{    return objInspector;}
535ef2008a05750ead78d9ffc860358255fa72c311b57eb161ab85edd4bc3f68
getSerializedClass
public Class<? extends Writable> getSerializedClass()
{    return ArrayWritable.class;}
b2da9b246685e72f824a5149bcc15e006ab744a8d145e6785fbac64a81764e9a
serialize
public Writable serialize(final Object obj, final ObjectInspector objInspector) throws SerDeException
{    if (!objInspector.getCategory().equals(Category.STRUCT)) {        throw new SerDeException("Cannot serialize " + objInspector.getCategory() + ". Can only serialize a struct");    }    final ArrayWritable serializeData = createStruct(obj, (StructObjectInspector) objInspector);    serializedSize = serializeData.get().length;    status = LAST_OPERATION.SERIALIZE;    return serializeData;}
075a85c9a3a0635a8d268f51a328836ff615a77e943807f543a5daffddd535e1
createStruct
private ArrayWritable createStruct(final Object obj, final StructObjectInspector inspector) throws SerDeException
{    final List<? extends StructField> fields = inspector.getAllStructFieldRefs();    final Writable[] arr = new Writable[fields.size()];    for (int i = 0; i < fields.size(); i++) {        final StructField field = fields.get(i);        final Object subObj = inspector.getStructFieldData(obj, field);        final ObjectInspector subInspector = field.getFieldObjectInspector();        arr[i] = createObject(subObj, subInspector);    }    return new ArrayWritable(Writable.class, arr);}
3c87e1979fcd1268dc137eb7c6f0316600d4bdb42ce9cdbceaf4f6dc0594bb58
createMap
private Writable createMap(final Object obj, final MapObjectInspector inspector) throws SerDeException
{    final Map<?, ?> sourceMap = inspector.getMap(obj);    final ObjectInspector keyInspector = inspector.getMapKeyObjectInspector();    final ObjectInspector valueInspector = inspector.getMapValueObjectInspector();    final List<ArrayWritable> array = new ArrayList<ArrayWritable>();    if (sourceMap != null) {        for (final Entry<?, ?> keyValue : sourceMap.entrySet()) {            final Writable key = createObject(keyValue.getKey(), keyInspector);            final Writable value = createObject(keyValue.getValue(), valueInspector);            if (key != null) {                Writable[] arr = new Writable[2];                arr[0] = key;                arr[1] = value;                array.add(new ArrayWritable(Writable.class, arr));            }        }    }    if (array.size() > 0) {        final ArrayWritable subArray = new ArrayWritable(ArrayWritable.class, array.toArray(new ArrayWritable[array.size()]));        return new ArrayWritable(Writable.class, new Writable[] { subArray });    } else {        return null;    }}
2efd377e180b7e67c86f9db5bea3aa6a0f1d2e4303e0157fb56972c524967fd6
createArray
private ArrayWritable createArray(final Object obj, final ListObjectInspector inspector) throws SerDeException
{    final List<?> sourceArray = inspector.getList(obj);    final ObjectInspector subInspector = inspector.getListElementObjectInspector();    final List<Writable> array = new ArrayList<Writable>();    if (sourceArray != null) {        for (final Object curObj : sourceArray) {            final Writable newObj = createObject(curObj, subInspector);            if (newObj != null) {                array.add(newObj);            }        }    }    if (array.size() > 0) {        final ArrayWritable subArray = new ArrayWritable(array.get(0).getClass(), array.toArray(new Writable[array.size()]));        return new ArrayWritable(Writable.class, new Writable[] { subArray });    } else {        return null;    }}
699b31877570c7ee093805540b19c995a500b2e6428996c29e8c90f78b0201c9
createPrimitive
private Writable createPrimitive(final Object obj, final PrimitiveObjectInspector inspector) throws SerDeException
{    if (obj == null) {        return null;    }    switch(inspector.getPrimitiveCategory()) {        case VOID:            return null;        case BOOLEAN:            return new BooleanWritable(((BooleanObjectInspector) inspector).get(obj) ? Boolean.TRUE : Boolean.FALSE);        case BYTE:            return new ByteWritable((byte) ((ByteObjectInspector) inspector).get(obj));        case DOUBLE:            return new DoubleWritable(((DoubleObjectInspector) inspector).get(obj));        case FLOAT:            return new FloatWritable(((FloatObjectInspector) inspector).get(obj));        case INT:            return new IntWritable(((IntObjectInspector) inspector).get(obj));        case LONG:            return new LongWritable(((LongObjectInspector) inspector).get(obj));        case SHORT:            return new ShortWritable((short) ((ShortObjectInspector) inspector).get(obj));        case STRING:            return new BinaryWritable(Binary.fromString(((StringObjectInspector) inspector).getPrimitiveJavaObject(obj)));        default:            throw new SerDeException("Unknown primitive : " + inspector.getPrimitiveCategory());    }}
a61f6dced1d757c58cf5404bef0d909dcf71aa02444cc06d9a35fb2fa3f211c1
createObject
private Writable createObject(final Object obj, final ObjectInspector inspector) throws SerDeException
{    switch(inspector.getCategory()) {        case STRUCT:            return createStruct(obj, (StructObjectInspector) inspector);        case LIST:            return createArray(obj, (ListObjectInspector) inspector);        case MAP:            return createMap(obj, (MapObjectInspector) inspector);        case PRIMITIVE:            return createPrimitive(obj, (PrimitiveObjectInspector) inspector);        default:            throw new SerDeException("Unknown data type" + inspector.getCategory());    }}
b8fdc1157b39a7c5c514dc015bccde3e8299966b9d2a2a3ff314c563dda00f49
getSerDeStats
public SerDeStats getSerDeStats()
{        assert (status != LAST_OPERATION.UNKNOWN);    if (status == LAST_OPERATION.SERIALIZE) {        stats.setRawDataSize(serializedSize);    } else {        stats.setRawDataSize(deserializedSize);    }    return stats;}
1b958954700c71eb837d9189f86a265f944834fe85686181bafbd02c067c0274
getPrimitiveWritableObject
public Object getPrimitiveWritableObject(final Object o)
{    return o == null ? null : new ByteWritable(get(o));}
46cf4611bf37a303318bebade844eb81e7eb15c4b9c2eabd34009016eea94fed
create
public Object create(final byte val)
{    return new ByteWritable(val);}
c1e41d2416c18ad463aab75feb3ca9579f3ecc9bc6859d6f61ac9a64fd5447fc
set
public Object set(final Object o, final byte val)
{    ((ByteWritable) o).set(val);    return o;}
a2fb81c4ee014524372439a7a425f3b64718aa002a21a51744f7f2b9fd8eaac1
get
public byte get(Object o)
{        if (o instanceof IntWritable) {        return (byte) ((IntWritable) o).get();    }    return ((ByteWritable) o).get();}
1b958954700c71eb837d9189f86a265f944834fe85686181bafbd02c067c0274
getPrimitiveWritableObject
public Object getPrimitiveWritableObject(final Object o)
{    return o == null ? null : new ShortWritable(get(o));}
e179e2db912af9992f734fb8fb45b54f40662bca519e5c2ae8c619d57b920791
create
public Object create(final short val)
{    return new ShortWritable(val);}
c8f72ef64a89c4bcef858cf4e821df69537aaa1b2b5aed47a945b467f404d37f
set
public Object set(final Object o, final short val)
{    ((ShortWritable) o).set(val);    return o;}
8868694cb4fa31ff9a546c59f5ea17182a69ddf9ee0e3e32214b6d12a1385346
get
public short get(Object o)
{        if (o instanceof IntWritable) {        return (short) ((IntWritable) o).get();    }    return ((ShortWritable) o).get();}
f8eeaa9f30306e392cbbe93c82b126f5c58c1f749457f6eb8e51b81a38930c7f
getMapValueElement
public Object getMapValueElement(final Object data, final Object key)
{    if (data == null || key == null) {        return null;    }    if (data instanceof ArrayWritable) {        final Writable[] mapContainer = ((ArrayWritable) data).get();        if (mapContainer == null || mapContainer.length == 0) {            return null;        }        final Writable[] mapArray = ((ArrayWritable) mapContainer[0]).get();        for (final Writable obj : mapArray) {            final ArrayWritable mapObj = (ArrayWritable) obj;            final Writable[] arr = mapObj.get();            if (key.equals(arr[0])) {                return arr[1];            }        }        return null;    }    if (data instanceof Map) {        return ((Map) data).get(key);    }    throw new UnsupportedOperationException("Cannot inspect " + data.getClass().getCanonicalName());}
95414c0e52d8aed4d67212d21957d8cff1b9151117aaf9d6295ff73142ff3ba1
set
public void set(BigDecimal value)
{    value = value.stripTrailingZeros();    if (value.compareTo(BigDecimal.ZERO) == 0) {                        value = BigDecimal.ZERO;    }    set(value.unscaledValue().toByteArray(), value.scale());}
d247cc9ad628431339f0a68cb1aad46b7dea82f1970f81630f7c9912f3d14c72
set
public void set(final BigDecimalWritable writable)
{    set(writable.getBigDecimal());}
fa96bc95c7798cad8131486615c738bb237c05d5856fdb58c42e6c73eff64a7b
set
public void set(final byte[] bytes, final int scale)
{    this.internalStorage = bytes;    this.scale = scale;}
a5a724b477da9f93a3e585ea267890c7256b44a1c63bd28286952ad3aa68c250
setFromBytes
public void setFromBytes(final byte[] bytes, int offset, final int length)
{    LazyBinaryUtils.readVInt(bytes, offset, vInt);    scale = vInt.value;    offset += vInt.length;    LazyBinaryUtils.readVInt(bytes, offset, vInt);    offset += vInt.length;    if (internalStorage.length != vInt.value) {        internalStorage = new byte[vInt.value];    }    System.arraycopy(bytes, offset, internalStorage, 0, vInt.value);}
d6b0a2c488618595e4d1490c3f91732e51dbabd1134b016abcf9accf1ad1f6b6
getBigDecimal
public BigDecimal getBigDecimal()
{    return new BigDecimal(new BigInteger(internalStorage), scale);}
b1b129371f52e7c9cd4d05aed188b457e5c7e162c919f9e62cbb322585a6fed4
readFields
public void readFields(final DataInput in) throws IOException
{    scale = WritableUtils.readVInt(in);    final int byteArrayLen = WritableUtils.readVInt(in);    if (internalStorage.length != byteArrayLen) {        internalStorage = new byte[byteArrayLen];    }    in.readFully(internalStorage);}
a0810a9f65201a0b2c30f7266ea9e2c972607b6d747fc6655ab1dc9c9dfdd781
write
public void write(final DataOutput out) throws IOException
{    WritableUtils.writeVInt(out, scale);    WritableUtils.writeVInt(out, internalStorage.length);    out.write(internalStorage);}
8e7cc51a12e7e33ab4aab17fa3b1c890724146a2f2cce7ee1c26b9afce7b0c8f
compareTo
public int compareTo(final BigDecimalWritable that)
{    return getBigDecimal().compareTo(that.getBigDecimal());}
1b7117646a030b4cff2ebc32336c0e50b3c1c51fda0236b91b78f5edefce90e4
writeToByteStream
public void writeToByteStream(final Output byteStream)
{    LazyBinaryUtils.writeVInt(byteStream, scale);    LazyBinaryUtils.writeVInt(byteStream, internalStorage.length);    byteStream.write(internalStorage, 0, internalStorage.length);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return getBigDecimal().toString();}
aac209241a52602b8c2f9d3c4aeb82deb854aab8d6e671420bfbeea53a0462ed
equals
public boolean equals(final Object other)
{    if (other == null || !(other instanceof BigDecimalWritable)) {        return false;    }    final BigDecimalWritable bdw = (BigDecimalWritable) other;        return getBigDecimal().compareTo(bdw.getBigDecimal()) == 0;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return getBigDecimal().hashCode();}
fd68727d3aeb8910ee68424dda540731d6f823400b40902c0535e9527a64331d
getBinary
public Binary getBinary()
{    return binary;}
c159a0fb57e2ba9a7fb373b47eabbc552079ef89a4a50bbca7903b879542d25a
getBytes
public byte[] getBytes()
{    return binary.getBytes();}
6f98cfba8fd1113c0670baa214bd66d71beaef8f7140e311bc823c3ff4e19591
getString
public String getString()
{    return binary.toStringUsingUTF8();}
4529dacced0bb2cd63ef71d2039f49f0abb0523ab627a4bd0828ea7a38fadaf8
readFields
public void readFields(DataInput input) throws IOException
{    byte[] bytes = new byte[input.readInt()];    input.readFully(bytes);    binary = Binary.fromConstantByteArray(bytes);}
95fa8d142e8a9940c6c397725df7ff64917bd7d54e7b616d8d83cf7cdd02ac27
write
public void write(DataOutput output) throws IOException
{    output.writeInt(binary.length());    binary.writeTo(output);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return binary == null ? 0 : binary.hashCode();}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (obj instanceof BinaryWritable) {        final BinaryWritable other = (BinaryWritable) obj;        return binary.equals(other.binary);    }    return false;}
6f98cfba8fd1113c0670baa214bd66d71beaef8f7140e311bc823c3ff4e19591
getString
public String getString()
{    return string;}
bd49d9e51def3bc462544b34609cd4b10c5a97d1b10445837ce11ae273b9bf48
write
public void write(final ArrayWritable arr)
{    if (arr == null) {        return;    }    recordConsumer.startMessage();    writeData(arr, schema);    recordConsumer.endMessage();}
86d6c667b7aa1e380b5e018572e90cd0fc8a0fbfc4721f9f55fd08676b350e23
writeData
private void writeData(final ArrayWritable arr, final GroupType type)
{    if (arr == null) {        return;    }    final int fieldCount = type.getFieldCount();    Writable[] values = arr.get();    for (int field = 0; field < fieldCount; ++field) {        final Type fieldType = type.getType(field);        final String fieldName = fieldType.getName();        final Writable value = values[field];        if (value == null) {            continue;        }        recordConsumer.startField(fieldName, field);        if (fieldType.isPrimitive()) {            writePrimitive(value);        } else {            recordConsumer.startGroup();            if (value instanceof ArrayWritable) {                if (fieldType.asGroupType().getRepetition().equals(Type.Repetition.REPEATED)) {                    writeArray((ArrayWritable) value, fieldType.asGroupType());                } else {                    writeData((ArrayWritable) value, fieldType.asGroupType());                }            } else if (value != null) {                throw new ParquetEncodingException("This should be an ArrayWritable or MapWritable: " + value);            }            recordConsumer.endGroup();        }        recordConsumer.endField(fieldName, field);    }}
55f3fbd2b38465c30d957d5fad28ef4af3eb3b83c20816d36014569b939bab2d
writeArray
private void writeArray(final ArrayWritable array, final GroupType type)
{    if (array == null) {        return;    }    final Writable[] subValues = array.get();    final int fieldCount = type.getFieldCount();    for (int field = 0; field < fieldCount; ++field) {        final Type subType = type.getType(field);        recordConsumer.startField(subType.getName(), field);        for (int i = 0; i < subValues.length; ++i) {            final Writable subValue = subValues[i];            if (subValue != null) {                if (subType.isPrimitive()) {                    if (subValue instanceof ArrayWritable) {                                                writePrimitive(((ArrayWritable) subValue).get()[field]);                    } else {                        writePrimitive(subValue);                    }                } else {                    if (!(subValue instanceof ArrayWritable)) {                        throw new RuntimeException("This should be a ArrayWritable: " + subValue);                    } else {                        recordConsumer.startGroup();                        writeData((ArrayWritable) subValue, subType.asGroupType());                        recordConsumer.endGroup();                    }                }            }        }        recordConsumer.endField(subType.getName(), field);    }}
1cc9849c2797b46dc30e4d399a18f9dcb9411b4e9b63d0cce7a8554da6f03e4a
writePrimitive
private void writePrimitive(final Writable value)
{    if (value == null) {        return;    }    if (value instanceof DoubleWritable) {        recordConsumer.addDouble(((DoubleWritable) value).get());    } else if (value instanceof BooleanWritable) {        recordConsumer.addBoolean(((BooleanWritable) value).get());    } else if (value instanceof FloatWritable) {        recordConsumer.addFloat(((FloatWritable) value).get());    } else if (value instanceof IntWritable) {        recordConsumer.addInteger(((IntWritable) value).get());    } else if (value instanceof LongWritable) {        recordConsumer.addLong(((LongWritable) value).get());    } else if (value instanceof ShortWritable) {        recordConsumer.addInteger(((ShortWritable) value).get());    } else if (value instanceof ByteWritable) {        recordConsumer.addInteger(((ByteWritable) value).get());    } else if (value instanceof BigDecimalWritable) {        throw new UnsupportedOperationException("BigDecimal writing not implemented");    } else if (value instanceof BinaryWritable) {        recordConsumer.addBinary(((BinaryWritable) value).getBinary());    } else {        throw new IllegalArgumentException("Unknown value type: " + value + " " + value.getClass());    }}
0bbe9020380184b9ca1bb03845bcc0a41ddca39536bd56dae4704835083f87a1
setSchema
public static void setSchema(final MessageType schema, final Configuration configuration)
{    configuration.set(PARQUET_HIVE_SCHEMA, schema.toString());}
0f4c13c765e70555f06860feec4e53f31c25ce70f8cbc8c2e79dd5e30054be9c
getSchema
public static MessageType getSchema(final Configuration configuration)
{    return MessageTypeParser.parseMessageType(configuration.get(PARQUET_HIVE_SCHEMA));}
a012630dbcec2eb0bda0061aedd7486e5f985e11e832bc3c2296e6c6e254ec93
init
public WriteContext init(final Configuration configuration)
{    schema = getSchema(configuration);    return new WriteContext(schema, new HashMap<String, String>());}
59f856f46521acf36578c31e9e8165cec29393e2fefc54d1a3c07a6575c6fcda
prepareForWrite
public void prepareForWrite(final RecordConsumer recordConsumer)
{    writer = new DataWritableWriter(recordConsumer, schema);}
405ab1145e1c36da6facc8f7f4ace9847b46673cca624cba2a45aaac7057a07d
write
public void write(final ArrayWritable record)
{    writer.write(record);}
a5c4e13377783ef5c1ecd45418398deff0a20f5a80307234a3bdb8ba30e48d9a
close
public void close(final Reporter reporter) throws IOException
{    try {        realWriter.close(taskContext);    } catch (final InterruptedException e) {        throw new IOException(e);    }}
5dcb493c129242f57818a80bf561a20e857c9eb0e0a571630e5cca438f569de2
write
public void write(final Void key, final ArrayWritable value) throws IOException
{    try {        realWriter.write(key, value);    } catch (final InterruptedException e) {        throw new IOException(e);    }}
2b7e3238528513204f2b22e38d55c4b95e3353ab20ba6eae2b119e38ab13df96
close
public void close(final boolean abort) throws IOException
{    close(null);}
67fca454e3b94b93cfa349b0b22a99887580469fcdefede0156c919042eaa1f4
write
public void write(final Writable w) throws IOException
{    write(null, (ArrayWritable) w);}
f120c35daa235735d069bdb0823ed4a3db7f7295c5fca3784288e88aa4a7c1b1
getPrimitiveWritableObject
public Text getPrimitiveWritableObject(final Object o)
{    if (o == null) {        return null;    }    if (o instanceof BinaryWritable) {        return new Text(((BinaryWritable) o).getBytes());    }    if (o instanceof Text) {        return (Text) o;    }    if (o instanceof String) {        return new Text((String) o);    }    throw new UnsupportedOperationException("Cannot inspect " + o.getClass().getCanonicalName());}
e54fd304b3b1823a8249248b527b15f421061e325a10a9caf99bf6c12283d641
getPrimitiveJavaObject
public String getPrimitiveJavaObject(final Object o)
{    if (o == null) {        return null;    }    if (o instanceof BinaryWritable) {        return ((BinaryWritable) o).getString();    }    if (o instanceof Text) {        return ((Text) o).toString();    }    if (o instanceof String) {        return (String) o;    }    throw new UnsupportedOperationException("Cannot inspect " + o.getClass().getCanonicalName());}
16a479d4468ca94bd9a3728e626029e995756c8d0913580067d2b7b6856b2e8d
set
public Object set(final Object o, final Text text)
{    return new BinaryWritable(text == null ? null : Binary.fromReusedByteArray(text.getBytes()));}
18c7378179ef60346ac6319f618bee115db62ea2982892550cf0f23693064d3d
set
public Object set(final Object o, final String string)
{    return new BinaryWritable(string == null ? null : Binary.fromString(string));}
2dfbb0d745e0a1a21f48d920a7fd5ac5f353e365c040aee54f4dba3b718ce49a
create
public Object create(final Text text)
{    if (text == null) {        return null;    }    return text.toString();}
7d6ed36516dd44fdee9109b18ea00832049e0e4ab12bf457b744101abbc0bb8f
create
public Object create(final String string)
{    return string;}
717664a2ea31014c82bbb4b0d8d144f89e7f07453b74b83cabc6951b1bbba12c
getMapValueElement
public Object getMapValueElement(Object o, Object o1)
{    throw new UnsupportedOperationException("Should not be called");}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    inspector = new TestableAbstractParquetMapInspector(PrimitiveObjectInspectorFactory.javaIntObjectInspector, PrimitiveObjectInspectorFactory.javaIntObjectInspector);}
213e3c2a00a3ccc30df6acd573368186a413ea68a3e3279fae7e9a53ecdb5d7f
testNullMap
public void testNullMap()
{    assertEquals("Wrong size", -1, inspector.getMapSize(null));    assertNull("Should be null", inspector.getMap(null));}
b16259b27bb75d6a0403a0a958159bb84f334dc9d5169e082c67fafdd7bd3613
testNullContainer
public void testNullContainer()
{    final ArrayWritable map = new ArrayWritable(ArrayWritable.class, null);    assertEquals("Wrong size", -1, inspector.getMapSize(map));    assertNull("Should be null", inspector.getMap(map));}
3357c57d3856740bc265675cf04bdb5460ee3e1b79c9891e5a9618ad8aff729f
testEmptyContainer
public void testEmptyContainer()
{    final ArrayWritable map = new ArrayWritable(ArrayWritable.class, new ArrayWritable[0]);    assertEquals("Wrong size", -1, inspector.getMapSize(map));    assertNull("Should be null", inspector.getMap(map));}
f54bd57b21b7b9b32e6d4a4399d83825d72d8ee6336bf648a7129e7f6c4c977b
testRegularMap
public void testRegularMap()
{    final Writable[] entry1 = new Writable[] { new IntWritable(0), new IntWritable(1) };    final Writable[] entry2 = new Writable[] { new IntWritable(2), new IntWritable(3) };    final ArrayWritable internalMap = new ArrayWritable(ArrayWritable.class, new Writable[] { new ArrayWritable(Writable.class, entry1), new ArrayWritable(Writable.class, entry2) });    final ArrayWritable map = new ArrayWritable(ArrayWritable.class, new Writable[] { internalMap });    final Map<Writable, Writable> expected = new HashMap<Writable, Writable>();    expected.put(new IntWritable(0), new IntWritable(1));    expected.put(new IntWritable(2), new IntWritable(3));    assertEquals("Wrong size", 2, inspector.getMapSize(map));    assertEquals("Wrong result of inspection", expected, inspector.getMap(map));}
19354c9da451927a4318fdc953da4779b2f30c6893de20b65ed6f502894fd44d
testHashMap
public void testHashMap()
{    final Map<Writable, Writable> map = new HashMap<Writable, Writable>();    map.put(new IntWritable(0), new IntWritable(1));    map.put(new IntWritable(2), new IntWritable(3));    map.put(new IntWritable(4), new IntWritable(5));    map.put(new IntWritable(6), new IntWritable(7));    assertEquals("Wrong size", 4, inspector.getMapSize(map));    assertEquals("Wrong result of inspection", map, inspector.getMap(map));}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    inspector = new DeepParquetHiveMapInspector(ParquetPrimitiveInspectorFactory.parquetShortInspector, PrimitiveObjectInspectorFactory.javaIntObjectInspector);}
213e3c2a00a3ccc30df6acd573368186a413ea68a3e3279fae7e9a53ecdb5d7f
testNullMap
public void testNullMap()
{    assertNull("Should be null", inspector.getMapValueElement(null, new ShortWritable((short) 0)));}
b16259b27bb75d6a0403a0a958159bb84f334dc9d5169e082c67fafdd7bd3613
testNullContainer
public void testNullContainer()
{    final ArrayWritable map = new ArrayWritable(ArrayWritable.class, null);    assertNull("Should be null", inspector.getMapValueElement(map, new ShortWritable((short) 0)));}
3357c57d3856740bc265675cf04bdb5460ee3e1b79c9891e5a9618ad8aff729f
testEmptyContainer
public void testEmptyContainer()
{    final ArrayWritable map = new ArrayWritable(ArrayWritable.class, new ArrayWritable[0]);    assertNull("Should be null", inspector.getMapValueElement(map, new ShortWritable((short) 0)));}
f54bd57b21b7b9b32e6d4a4399d83825d72d8ee6336bf648a7129e7f6c4c977b
testRegularMap
public void testRegularMap()
{    final Writable[] entry1 = new Writable[] { new IntWritable(0), new IntWritable(1) };    final Writable[] entry2 = new Writable[] { new IntWritable(2), new IntWritable(3) };    final ArrayWritable internalMap = new ArrayWritable(ArrayWritable.class, new Writable[] { new ArrayWritable(Writable.class, entry1), new ArrayWritable(Writable.class, entry2) });    final ArrayWritable map = new ArrayWritable(ArrayWritable.class, new Writable[] { internalMap });    assertEquals("Wrong result of inspection", new IntWritable(1), inspector.getMapValueElement(map, new IntWritable(0)));    assertEquals("Wrong result of inspection", new IntWritable(3), inspector.getMapValueElement(map, new IntWritable(2)));    assertEquals("Wrong result of inspection", new IntWritable(1), inspector.getMapValueElement(map, new ShortWritable((short) 0)));    assertEquals("Wrong result of inspection", new IntWritable(3), inspector.getMapValueElement(map, new ShortWritable((short) 2)));}
19354c9da451927a4318fdc953da4779b2f30c6893de20b65ed6f502894fd44d
testHashMap
public void testHashMap()
{    final Map<Writable, Writable> map = new HashMap<Writable, Writable>();    map.put(new IntWritable(0), new IntWritable(1));    map.put(new IntWritable(2), new IntWritable(3));    map.put(new IntWritable(4), new IntWritable(5));    map.put(new IntWritable(6), new IntWritable(7));    assertEquals("Wrong result of inspection", new IntWritable(1), inspector.getMapValueElement(map, new IntWritable(0)));    assertEquals("Wrong result of inspection", new IntWritable(3), inspector.getMapValueElement(map, new IntWritable(2)));    assertEquals("Wrong result of inspection", new IntWritable(5), inspector.getMapValueElement(map, new IntWritable(4)));    assertEquals("Wrong result of inspection", new IntWritable(7), inspector.getMapValueElement(map, new IntWritable(6)));    assertEquals("Wrong result of inspection", new IntWritable(1), inspector.getMapValueElement(map, new ShortWritable((short) 0)));    assertEquals("Wrong result of inspection", new IntWritable(3), inspector.getMapValueElement(map, new ShortWritable((short) 2)));    assertEquals("Wrong result of inspection", new IntWritable(5), inspector.getMapValueElement(map, new ShortWritable((short) 4)));    assertEquals("Wrong result of inspection", new IntWritable(7), inspector.getMapValueElement(map, new ShortWritable((short) 6)));}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    inspector = new ParquetHiveArrayInspector(PrimitiveObjectInspectorFactory.javaIntObjectInspector);}
abc87b26817ff67c3721022623e55ac6be58c9f6516856001ff0d1e867bfa1bd
testNullArray
public void testNullArray()
{    assertEquals("Wrong size", -1, inspector.getListLength(null));    assertNull("Should be null", inspector.getList(null));    assertNull("Should be null", inspector.getListElement(null, 0));}
b16259b27bb75d6a0403a0a958159bb84f334dc9d5169e082c67fafdd7bd3613
testNullContainer
public void testNullContainer()
{    final ArrayWritable list = new ArrayWritable(ArrayWritable.class, null);    assertEquals("Wrong size", -1, inspector.getListLength(list));    assertNull("Should be null", inspector.getList(list));    assertNull("Should be null", inspector.getListElement(list, 0));}
3357c57d3856740bc265675cf04bdb5460ee3e1b79c9891e5a9618ad8aff729f
testEmptyContainer
public void testEmptyContainer()
{    final ArrayWritable list = new ArrayWritable(ArrayWritable.class, new ArrayWritable[0]);    assertEquals("Wrong size", -1, inspector.getListLength(list));    assertNull("Should be null", inspector.getList(list));    assertNull("Should be null", inspector.getListElement(list, 0));}
a287e52db355f79cb50457c96a71cb4c17061232f4f60ad02b2a6d87b1472468
testRegularList
public void testRegularList()
{    final ArrayWritable internalList = new ArrayWritable(Writable.class, new Writable[] { new IntWritable(3), new IntWritable(5), new IntWritable(1) });    final ArrayWritable list = new ArrayWritable(ArrayWritable.class, new ArrayWritable[] { internalList });    final List<Writable> expected = new ArrayList<Writable>();    expected.add(new IntWritable(3));    expected.add(new IntWritable(5));    expected.add(new IntWritable(1));    assertEquals("Wrong size", 3, inspector.getListLength(list));    assertEquals("Wrong result of inspection", expected, inspector.getList(list));    for (int i = 0; i < expected.size(); ++i) {        assertEquals("Wrong result of inspection", expected.get(i), inspector.getListElement(list, i));    }    assertNull("Should be null", inspector.getListElement(list, 3));}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    inspector = new StandardParquetHiveMapInspector(PrimitiveObjectInspectorFactory.javaIntObjectInspector, PrimitiveObjectInspectorFactory.javaIntObjectInspector);}
213e3c2a00a3ccc30df6acd573368186a413ea68a3e3279fae7e9a53ecdb5d7f
testNullMap
public void testNullMap()
{    assertNull("Should be null", inspector.getMapValueElement(null, new IntWritable(0)));}
b16259b27bb75d6a0403a0a958159bb84f334dc9d5169e082c67fafdd7bd3613
testNullContainer
public void testNullContainer()
{    final ArrayWritable map = new ArrayWritable(ArrayWritable.class, null);    assertNull("Should be null", inspector.getMapValueElement(map, new IntWritable(0)));}
3357c57d3856740bc265675cf04bdb5460ee3e1b79c9891e5a9618ad8aff729f
testEmptyContainer
public void testEmptyContainer()
{    final ArrayWritable map = new ArrayWritable(ArrayWritable.class, new ArrayWritable[0]);    assertNull("Should be null", inspector.getMapValueElement(map, new IntWritable(0)));}
f54bd57b21b7b9b32e6d4a4399d83825d72d8ee6336bf648a7129e7f6c4c977b
testRegularMap
public void testRegularMap()
{    final Writable[] entry1 = new Writable[] { new IntWritable(0), new IntWritable(1) };    final Writable[] entry2 = new Writable[] { new IntWritable(2), new IntWritable(3) };    final ArrayWritable internalMap = new ArrayWritable(ArrayWritable.class, new Writable[] { new ArrayWritable(Writable.class, entry1), new ArrayWritable(Writable.class, entry2) });    final ArrayWritable map = new ArrayWritable(ArrayWritable.class, new Writable[] { internalMap });    assertEquals("Wrong result of inspection", new IntWritable(1), inspector.getMapValueElement(map, new IntWritable(0)));    assertEquals("Wrong result of inspection", new IntWritable(3), inspector.getMapValueElement(map, new IntWritable(2)));    assertNull("Wrong result of inspection", inspector.getMapValueElement(map, new ShortWritable((short) 0)));    assertNull("Wrong result of inspection", inspector.getMapValueElement(map, new ShortWritable((short) 2)));}
19354c9da451927a4318fdc953da4779b2f30c6893de20b65ed6f502894fd44d
testHashMap
public void testHashMap()
{    final Map<Writable, Writable> map = new HashMap<Writable, Writable>();    map.put(new IntWritable(0), new IntWritable(1));    map.put(new IntWritable(2), new IntWritable(3));    map.put(new IntWritable(4), new IntWritable(5));    map.put(new IntWritable(6), new IntWritable(7));    assertEquals("Wrong result of inspection", new IntWritable(1), inspector.getMapValueElement(map, new IntWritable(0)));    assertEquals("Wrong result of inspection", new IntWritable(3), inspector.getMapValueElement(map, new IntWritable(2)));    assertEquals("Wrong result of inspection", new IntWritable(5), inspector.getMapValueElement(map, new IntWritable(4)));    assertEquals("Wrong result of inspection", new IntWritable(7), inspector.getMapValueElement(map, new IntWritable(6)));    assertNull("Wrong result of inspection", inspector.getMapValueElement(map, new ShortWritable((short) 0)));    assertNull("Wrong result of inspection", inspector.getMapValueElement(map, new ShortWritable((short) 2)));    assertNull("Wrong result of inspection", inspector.getMapValueElement(map, new ShortWritable((short) 4)));    assertNull("Wrong result of inspection", inspector.getMapValueElement(map, new ShortWritable((short) 6)));}
74d1d6fbe6500d5953808fc85dedfd9ee61ca39c1e1212e33bc4155ba53911a9
createHiveColumnsFrom
private List<String> createHiveColumnsFrom(final String columnNamesStr)
{    List<String> columnNames;    if (columnNamesStr.length() == 0) {        columnNames = new ArrayList<String>();    } else {        columnNames = Arrays.asList(columnNamesStr.split(","));    }    return columnNames;}
3bcd889ccfe6bbb821a16a27ed77c3ce631594a7d967b8b3495dcd94e795370b
createHiveTypeInfoFrom
private List<TypeInfo> createHiveTypeInfoFrom(final String columnsTypeStr)
{    List<TypeInfo> columnTypes;    if (columnsTypeStr.length() == 0) {        columnTypes = new ArrayList<TypeInfo>();    } else {        columnTypes = TypeInfoUtils.getTypeInfosFromTypeString(columnsTypeStr);    }    return columnTypes;}
3720d0fa9529d799b2706c76452babd8044e6ce010fd42859376586ebad981b5
testConversion
private void testConversion(final String columnNamesStr, final String columnsTypeStr, final String expectedSchema) throws Exception
{    final List<String> columnNames = createHiveColumnsFrom(columnNamesStr);    final List<TypeInfo> columnTypes = createHiveTypeInfoFrom(columnsTypeStr);    final MessageType messageTypeFound = HiveSchemaConverter.convert(columnNames, columnTypes);    final MessageType expectedMT = MessageTypeParser.parseMessageType(expectedSchema);    assertEquals("converting " + columnNamesStr + ": " + columnsTypeStr + " to " + expectedSchema, expectedMT, messageTypeFound);}
a7a0c3c18bc4ecbd73981c10eaee445e19e8f34da7b3ad9c1abdb1f26a651074
testSimpleType
public void testSimpleType() throws Exception
{    testConversion("a,b,c", "int,double,boolean", "message hive_schema {\n" + "  optional int32 a;\n" + "  optional double b;\n" + "  optional boolean c;\n" + "}\n");}
7749ea47bc1c162d12a2c024fc5b3f5a5ed16bb6c8cb8dfaf741cc6e5cc57239
testArray
public void testArray() throws Exception
{    testConversion("arrayCol", "array<int>", "message hive_schema {\n" + "  optional group arrayCol (LIST) {\n" + "    repeated group bag {\n" + "      optional int32 array_element;\n" + "    }\n" + "  }\n" + "}\n");}
a2f56ac58e56505985a5d8a48232117c81b58f28d88363744f6d80f9586c2c52
testStruct
public void testStruct() throws Exception
{    testConversion("structCol", "struct<a:int,b:double,c:boolean>", "message hive_schema {\n" + "  optional group structCol {\n" + "    optional int32 a;\n" + "    optional double b;\n" + "    optional boolean c;\n" + "  }\n" + "}\n");}
7e3f62689a52f5cfc8f5889d1068814d43f1f4feaa85df375762f0f9cb0ab82c
testMap
public void testMap() throws Exception
{    testConversion("mapCol", "map<string,string>", "message hive_schema {\n" + "  optional group mapCol (MAP) {\n" + "    repeated group map (MAP_KEY_VALUE) {\n" + "      required binary key;\n" + "      optional binary value;\n" + "    }\n" + "  }\n" + "}\n");}
685d9f909fa078b866ed253b4d678439a84b97156b29d0a9e00f711685fd932d
testMapOriginalType
public void testMapOriginalType() throws Exception
{    final String hiveColumnTypes = "map<string,string>";    final String hiveColumnNames = "mapCol";    final List<String> columnNames = createHiveColumnsFrom(hiveColumnNames);    final List<TypeInfo> columnTypes = createHiveTypeInfoFrom(hiveColumnTypes);    final MessageType messageTypeFound = HiveSchemaConverter.convert(columnNames, columnTypes);        assertEquals(1, messageTypeFound.getFieldCount());    org.apache.parquet.schema.Type topLevel = messageTypeFound.getFields().get(0);    assertEquals("mapCol", topLevel.getName());    assertEquals(OriginalType.MAP, topLevel.getOriginalType());    assertEquals(Repetition.OPTIONAL, topLevel.getRepetition());    assertEquals(1, topLevel.asGroupType().getFieldCount());    org.apache.parquet.schema.Type secondLevel = topLevel.asGroupType().getFields().get(0);        assertEquals("map", secondLevel.getName());    assertEquals(OriginalType.MAP_KEY_VALUE, secondLevel.getOriginalType());    assertEquals(Repetition.REPEATED, secondLevel.getRepetition());}
af894f720cdc8ca50cf7142867f10f522e55490e092894b986b1092ba79300fe
testDefaultConstructor
public void testDefaultConstructor()
{    new MapredParquetInputFormat();}
c56d27b21a79d20e2708dde6aaee7d58308bd080c26ec691585d192f0a3e17a9
testConstructorWithParquetInputFormat
public void testConstructorWithParquetInputFormat()
{    new MapredParquetInputFormat((ParquetInputFormat<ArrayWritable>) mock(ParquetInputFormat.class));}
b7b21d24e32e4f868979d3cde8815b02ce5665794ec7983f0b9cfd9954331bff
testConstructor
public void testConstructor()
{    new MapredParquetOutputFormat();}
b88bd3a28b72115bf0166463484d32aad1485174520228d2da4e85b52f33cd51
testConstructorWithFormat
public void testConstructorWithFormat()
{    new MapredParquetOutputFormat((ParquetOutputFormat<ArrayWritable>) mock(ParquetOutputFormat.class));}
2303f777d2ccacce3a85848eef5d196321a732bf2c67c4b07b7457a19d921dfe
testGetRecordWriterThrowsException
public void testGetRecordWriterThrowsException()
{    try {        new MapredParquetOutputFormat().getRecordWriter(null, null, null, null);        fail("should throw runtime exception.");    } catch (Exception e) {        assertEquals("Should never be used", e.getMessage());    }}
694f265ce059b1c390fa588fd8c61b782a8a5bf5b995db2aab4d198f6c27e981
testGetHiveRecordWriter
public void testGetHiveRecordWriter() throws IOException
{    Properties tableProps = new Properties();    tableProps.setProperty("columns", "foo,bar");    tableProps.setProperty("columns.types", "int:int");    final Progressable mockProgress = mock(Progressable.class);    final ParquetOutputFormat<ArrayWritable> outputFormat = (ParquetOutputFormat<ArrayWritable>) mock(ParquetOutputFormat.class);    JobConf jobConf = new JobConf();    try {        new MapredParquetOutputFormat(outputFormat) {            @Override            protected ParquetRecordWriterWrapper getParquerRecordWriterWrapper(ParquetOutputFormat<ArrayWritable> realOutputFormat, JobConf jobConf, String finalOutPath, Progressable progress) throws IOException {                assertEquals(outputFormat, realOutputFormat);                assertNotNull(jobConf.get(DataWritableWriteSupport.PARQUET_HIVE_SCHEMA));                assertEquals("/foo", finalOutPath.toString());                assertEquals(mockProgress, progress);                throw new RuntimeException("passed tests");            }        }.getHiveRecordWriter(jobConf, new Path("/foo"), null, false, tableProps, mockProgress);        fail("should throw runtime exception.");    } catch (RuntimeException e) {        assertEquals("passed tests", e.getMessage());    }}
5d0fce7302f2d0cdb3b41b1b89ea76aec35c5abcb29d45fd7ecdb2afa4f1143d
getParquerRecordWriterWrapper
protected ParquetRecordWriterWrapper getParquerRecordWriterWrapper(ParquetOutputFormat<ArrayWritable> realOutputFormat, JobConf jobConf, String finalOutPath, Progressable progress) throws IOException
{    assertEquals(outputFormat, realOutputFormat);    assertNotNull(jobConf.get(DataWritableWriteSupport.PARQUET_HIVE_SCHEMA));    assertEquals("/foo", finalOutPath.toString());    assertEquals(mockProgress, progress);    throw new RuntimeException("passed tests");}
16257da7fc8dead73463f8e08bd210923942658e1077b24152dd804201ce2a0c
testParquetHiveSerDe
public void testParquetHiveSerDe() throws Throwable
{    try {                System.out.println("test: testParquetHiveSerDe");        final ParquetHiveSerDe serDe = new ParquetHiveSerDe();        final Configuration conf = new Configuration();        final Properties tbl = createProperties();        serDe.initialize(conf, tbl);                final Writable[] arr = new Writable[8];        arr[0] = new ByteWritable((byte) 123);        arr[1] = new ShortWritable((short) 456);        arr[2] = new IntWritable(789);        arr[3] = new LongWritable(1000l);        arr[4] = new DoubleWritable((double) 5.3);        arr[5] = new BinaryWritable(Binary.fromString("hive and hadoop and parquet. Big family."));        final Writable[] mapContainer = new Writable[1];        final Writable[] map = new Writable[3];        for (int i = 0; i < 3; ++i) {            final Writable[] pair = new Writable[2];            pair[0] = new BinaryWritable(Binary.fromString("key_" + i));            pair[1] = new IntWritable(i);            map[i] = new ArrayWritable(Writable.class, pair);        }        mapContainer[0] = new ArrayWritable(Writable.class, map);        arr[6] = new ArrayWritable(Writable.class, mapContainer);        final Writable[] arrayContainer = new Writable[1];        final Writable[] array = new Writable[5];        for (int i = 0; i < 5; ++i) {            array[i] = new BinaryWritable(Binary.fromString("elem_" + i));        }        arrayContainer[0] = new ArrayWritable(Writable.class, array);        arr[7] = new ArrayWritable(Writable.class, arrayContainer);        final ArrayWritable arrWritable = new ArrayWritable(Writable.class, arr);                deserializeAndSerializeLazySimple(serDe, arrWritable);        System.out.println("test: testParquetHiveSerDe - OK");    } catch (final Throwable e) {        e.printStackTrace();        throw e;    }}
5302b8b072cee999542efc40f81446547b16005e0551b895b2dbb40870d894bd
deserializeAndSerializeLazySimple
private void deserializeAndSerializeLazySimple(final ParquetHiveSerDe serDe, final ArrayWritable t) throws SerDeException
{        final StructObjectInspector oi = (StructObjectInspector) serDe.getObjectInspector();        final Object row = serDe.deserialize(t);    assertEquals("deserialization gives the wrong object class", row.getClass(), ArrayWritable.class);    assertEquals("size correct after deserialization", serDe.getSerDeStats().getRawDataSize(), t.get().length);    assertEquals("deserialization gives the wrong object", t, row);        final ArrayWritable serializedArr = (ArrayWritable) serDe.serialize(row, oi);    assertEquals("size correct after serialization", serDe.getSerDeStats().getRawDataSize(), serializedArr.get().length);    assertTrue("serialized object should be equal to starting object", arrayWritableEquals(t, serializedArr));}
754063181110d1a7fb3204bc2e4286691a8fcfb4b37c30f372497dfceb6c694d
createProperties
private Properties createProperties()
{    final Properties tbl = new Properties();        tbl.setProperty("columns", "abyte,ashort,aint,along,adouble,astring,amap,alist");    tbl.setProperty("columns.types", "tinyint:smallint:int:bigint:double:string:map<string,int>:array<string>");    tbl.setProperty(org.apache.hadoop.hive.serde.serdeConstants.SERIALIZATION_NULL_FORMAT, "NULL");    return tbl;}
f89d8c68999f0653b1701a246b7480bfcb46e5af9e4ee3fb5e3565a8a30749b1
arrayWritableEquals
public static boolean arrayWritableEquals(final ArrayWritable a1, final ArrayWritable a2)
{    final Writable[] a1Arr = a1.get();    final Writable[] a2Arr = a2.get();    if (a1Arr.length != a2Arr.length) {        return false;    }    for (int i = 0; i < a1Arr.length; ++i) {        if (a1Arr[i] instanceof ArrayWritable) {            if (!(a2Arr[i] instanceof ArrayWritable)) {                return false;            }            if (!arrayWritableEquals((ArrayWritable) a1Arr[i], (ArrayWritable) a2Arr[i])) {                return false;            }        } else {            if (!a1Arr[i].equals(a2Arr[i])) {                return false;            }        }    }    return true;}
f1995c952fd474d5d14a943af67cb899adde9771207403e6c9335d72fa2b283b
binaryToDecimal
public static BigDecimal binaryToDecimal(Binary value, int precision, int scale)
{    /*     * Precision <= 18 checks for the max number of digits for an unscaled long,     * else treat with big integer conversion     */    if (precision <= 18) {        ByteBuffer buffer = value.toByteBuffer();        byte[] bytes = buffer.array();        int start = buffer.arrayOffset() + buffer.position();        int end = buffer.arrayOffset() + buffer.limit();        long unscaled = 0L;        int i = start;        while (i < end) {            unscaled = (unscaled << 8 | bytes[i] & 0xff);            i++;        }        int bits = 8 * (end - start);        long unscaledNew = (unscaled << (64 - bits)) >> (64 - bits);        if (unscaledNew <= -pow(10, 18) || unscaledNew >= pow(10, 18)) {            return new BigDecimal(unscaledNew);        } else {            return BigDecimal.valueOf(unscaledNew / pow(10, scale));        }    } else {        return new BigDecimal(new BigInteger(value.getBytes()), scale);    }}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    if (fieldIndex != 0) {        throw new IllegalArgumentException("maps have only one field. can't reach " + fieldIndex);    }    return keyValue;}
016bac278a8f60aec7a89722089f1c9f9f835485f6ec65fc52d0e84186d25458
start
public final void start()
{    buffer.clear();}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    parent.add(new LinkedHashMap<String, Object>(buffer));}
c9f605bb217d530335c5c4da4f45ae78dbd65569a39a839adaeda8e8688529ed
iterator
public Iterator<java.util.Map.Entry<String, Object>> iterator()
{    return entries.iterator();}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return entries.size();}
6d405f446049ae9a8891ae0c4532592ec4023980ebb24507d10a8dfb07656b25
put
public Tuple put(String key, Object value)
{    entries.add(new SimpleImmutableEntry<String, Object>(key, value));    return null;}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    entries.clear();}
aed6288aaf44c802a976b90a18367efe2d984c3b293de3e0ba0b5a9f0a306aa4
entrySet
public Set<java.util.Map.Entry<String, Object>> entrySet()
{    return entrySet;}
029c1f9eaaf445359d12bb3b24b8fc3c65d19b6d286c49565a8ee2da85aea4d5
add
 void add(Object value)
{    currentKey = value;}
029c1f9eaaf445359d12bb3b24b8fc3c65d19b6d286c49565a8ee2da85aea4d5
add
 void add(Object value)
{    currentValue = value;}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    if (fieldIndex == 0) {        return keyConverter;    } else if (fieldIndex == 1) {        return valueConverter;    }    throw new IllegalArgumentException("only the key (0) and value (1) fields expected: " + fieldIndex);}
016bac278a8f60aec7a89722089f1c9f9f835485f6ec65fc52d0e84186d25458
start
public final void start()
{    currentKey = null;    currentValue = null;}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    buffer.put(currentKey.toString(), currentValue);    currentKey = null;    currentValue = null;}
b405f8029e1a0f0248ddb1e2a1e3f991bc030596be8f73cd2d250ff9b1a7c795
addBinary
public final void addBinary(Binary value)
{    currentKey = value.toStringUsingUTF8();}
029c1f9eaaf445359d12bb3b24b8fc3c65d19b6d286c49565a8ee2da85aea4d5
add
 void add(Object value)
{    TupleConverter.this.set(index, value);}
7ec0174c8523decbd7643941b4aa9ccdea665e17a3fe8f912928e1fbc1db414e
getType
private Type getType(boolean columnIndexAccess, String alias, int index)
{    if (columnIndexAccess) {        if (index < parquetSchema.getFieldCount()) {            return parquetSchema.getType(index);        }    } else {        return parquetSchema.getType(parquetSchema.getFieldIndex(alias));    }    return null;}
d07b9a6475e7c517c1dbcb7a9ecad15dbff7bf83da19e1b84eab472a8df36c72
newConverter
 static Converter newConverter(FieldSchema pigField, Type type, final ParentValueContainer parent, boolean elephantBirdCompatible, boolean columnIndexAccess)
{    try {        switch(pigField.type) {            case DataType.BAG:                return new BagConverter(type.asGroupType(), pigField, parent, elephantBirdCompatible, columnIndexAccess);            case DataType.MAP:                return new MapConverter(type.asGroupType(), pigField, parent, elephantBirdCompatible, columnIndexAccess);            case DataType.TUPLE:                return new TupleConverter(type.asGroupType(), pigField.schema, elephantBirdCompatible, columnIndexAccess) {                    @Override                    public void end() {                        super.end();                        parent.add(this.currentTuple);                    }                };            case DataType.CHARARRAY:                                return new FieldStringConverter(parent, type.getLogicalTypeAnnotation() instanceof LogicalTypeAnnotation.StringLogicalTypeAnnotation);            case DataType.BYTEARRAY:                return new FieldByteArrayConverter(parent);            case DataType.INTEGER:                return new FieldIntegerConverter(parent);            case DataType.BOOLEAN:                if (elephantBirdCompatible) {                    return new FieldIntegerConverter(parent);                } else {                    return new FieldBooleanConverter(parent);                }            case DataType.FLOAT:                return new FieldFloatConverter(parent);            case DataType.DOUBLE:                return new FieldDoubleConverter(parent);            case DataType.LONG:                return new FieldLongConverter(parent);            case DataType.BIGDECIMAL:                return new FieldBigDecimalConverter(type, parent);            default:                throw new TupleConversionException("unsupported pig type: " + pigField);        }    } catch (FrontendException e) {        throw new TupleConversionException("error while preparing converter for:\n" + pigField + "\n" + type, e);    } catch (RuntimeException e) {        throw new TupleConversionException("error while preparing converter for:\n" + pigField + "\n" + type, e);    }}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    super.end();    parent.add(this.currentTuple);}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    return converters[fieldIndex];}
016bac278a8f60aec7a89722089f1c9f9f835485f6ec65fc52d0e84186d25458
start
public final void start()
{    currentTuple = TF.newTuple(schemaSize);    if (elephantBirdCompatible) {        try {            int i = 0;            for (Type field : parquetSchema.getFields()) {                if (field.isPrimitive() && field.isRepetition(Repetition.OPTIONAL)) {                    PrimitiveType primitiveType = field.asPrimitiveType();                    switch(primitiveType.getPrimitiveTypeName()) {                        case INT32:                            currentTuple.set(i, I32_ZERO);                            break;                        case INT64:                            currentTuple.set(i, I64_ZERO);                            break;                        case FLOAT:                            currentTuple.set(i, FLOAT_ZERO);                            break;                        case DOUBLE:                            currentTuple.set(i, DOUBLE_ZERO);                            break;                        case BOOLEAN:                            currentTuple.set(i, I32_ZERO);                            break;                    }                }                ++i;            }        } catch (ExecException e) {            throw new RuntimeException(e);        }    }}
872e79a66850d672ac0d8ed72e297c3deefb97bdaab12c24232028a4ae51e7d8
set
 final void set(int fieldIndex, Object value)
{    try {        currentTuple.set(fieldIndex, value);    } catch (ExecException e) {        throw new TupleConversionException("Could not set " + value + " to current tuple " + currentTuple + " at " + fieldIndex, e);    }}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{}
c7f3e4931c4b68e44c3c90e99aef712be371bba8a4d1809a20e1a803a9fce16f
getCurrentTuple
public final Tuple getCurrentTuple()
{    return currentTuple;}
b405f8029e1a0f0248ddb1e2a1e3f991bc030596be8f73cd2d250ff9b1a7c795
addBinary
public final void addBinary(Binary value)
{    parent.add(value.toStringUsingUTF8());}
7c3f73c96e69cb35837e756142746fd240f40ccf1d7d310c2436e6b135fe196b
hasDictionarySupport
public boolean hasDictionarySupport()
{    return dictionarySupport;}
5edde50d3cb88777a151a88dae34321ada39b284501a5295564b122126c5c393
setDictionary
public void setDictionary(Dictionary dictionary)
{    dict = new String[dictionary.getMaxId() + 1];    for (int i = 0; i <= dictionary.getMaxId(); i++) {        dict[i] = dictionary.decodeToBinary(i).toStringUsingUTF8();    }}
f1649786c3679c86c0157574e47953673714091cc71d598cedff963593010d98
addValueFromDictionary
public void addValueFromDictionary(int dictionaryId)
{    parent.add(dict[dictionaryId]);}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    parent.add(Long.toString(value));}
a2ac1f40a6e220ec515710128c8baf77a725ad0b9f1767a998f776f27fff6cf6
addInt
public void addInt(int value)
{    parent.add(Integer.toString(value));}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    parent.add(Float.toString(value));}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    parent.add(Double.toString(value));}
23123f6657c241ab9b9f31f8efedc28a553ed91046d705121ce2667b065d6c17
addBoolean
public void addBoolean(boolean value)
{    parent.add(Boolean.toString(value));}
b405f8029e1a0f0248ddb1e2a1e3f991bc030596be8f73cd2d250ff9b1a7c795
addBinary
public final void addBinary(Binary value)
{    parent.add(new DataByteArray(value.getBytes()));}
59339a237854c0bcf5065099cd6420a719dcdf94fb2eafa4f7b3e980488340f0
addDouble
public final void addDouble(double value)
{    parent.add(value);}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    parent.add((double) value);}
a2ac1f40a6e220ec515710128c8baf77a725ad0b9f1767a998f776f27fff6cf6
addInt
public void addInt(int value)
{    parent.add((double) value);}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    parent.add((double) value);}
23123f6657c241ab9b9f31f8efedc28a553ed91046d705121ce2667b065d6c17
addBoolean
public void addBoolean(boolean value)
{    parent.add(value ? 1.0d : 0.0d);}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    parent.add(Double.parseDouble(value.toStringUsingUTF8()));}
1a85d501dbca087ef815eaec751801b42fc0a5ac95f7d2226cb9b9a1fabfa923
addFloat
public final void addFloat(float value)
{    parent.add(value);}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    parent.add((float) value);}
a2ac1f40a6e220ec515710128c8baf77a725ad0b9f1767a998f776f27fff6cf6
addInt
public void addInt(int value)
{    parent.add((float) value);}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    parent.add((float) value);}
23123f6657c241ab9b9f31f8efedc28a553ed91046d705121ce2667b065d6c17
addBoolean
public void addBoolean(boolean value)
{    parent.add(value ? 1.0f : 0.0f);}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    parent.add(Float.parseFloat(value.toStringUsingUTF8()));}
f2540bfd2e5df5e69c6f90cf0607e0a9ce71860bcaa52d1fd7d61e8e4842d97b
addLong
public final void addLong(long value)
{    parent.add(value);}
a2ac1f40a6e220ec515710128c8baf77a725ad0b9f1767a998f776f27fff6cf6
addInt
public void addInt(int value)
{    parent.add((long) value);}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    parent.add((long) value);}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    parent.add((long) value);}
23123f6657c241ab9b9f31f8efedc28a553ed91046d705121ce2667b065d6c17
addBoolean
public void addBoolean(boolean value)
{    parent.add(value ? 1L : 0L);}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    parent.add(Long.parseLong(value.toStringUsingUTF8()));}
954195d234288c19e659aa55edc4121b87eef181d6d86d58a96eaeb2fd0f77ba
addBoolean
public final void addBoolean(boolean value)
{    parent.add(value ? 1 : 0);}
b0b35a6cee9e7ab2c621c392008bd654c3d9e63c57dc04786380ffaf46d00efc
addInt
public final void addInt(int value)
{    parent.add(value);}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    parent.add((int) value);}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    parent.add((int) value);}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    parent.add((int) value);}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    parent.add(Integer.parseInt(value.toStringUsingUTF8()));}
954195d234288c19e659aa55edc4121b87eef181d6d86d58a96eaeb2fd0f77ba
addBoolean
public final void addBoolean(boolean value)
{    parent.add(value);}
b0b35a6cee9e7ab2c621c392008bd654c3d9e63c57dc04786380ffaf46d00efc
addInt
public final void addInt(int value)
{    parent.add(value != 0);}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    parent.add(value != 0);}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    parent.add(value != 0);}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    parent.add(value != 0);}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    parent.add(Boolean.parseBoolean(value.toStringUsingUTF8()));}
b405f8029e1a0f0248ddb1e2a1e3f991bc030596be8f73cd2d250ff9b1a7c795
addBinary
public final void addBinary(Binary value)
{    int precision = primitiveType.asPrimitiveType().getDecimalMetadata().getPrecision();    int scale = primitiveType.asPrimitiveType().getDecimalMetadata().getScale();    BigDecimal finaldecimal = DecimalUtils.binaryToDecimal(value, precision, scale);    parent.add(finaldecimal);}
029c1f9eaaf445359d12bb3b24b8fc3c65d19b6d286c49565a8ee2da85aea4d5
add
 void add(Object value)
{    buffer.add(TF.newTuple(value));}
029c1f9eaaf445359d12bb3b24b8fc3c65d19b6d286c49565a8ee2da85aea4d5
add
 void add(Object value)
{    buffer.add((Tuple) value);}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    if (fieldIndex != 0) {        throw new IllegalArgumentException("bags have only one field. can't reach " + fieldIndex);    }    return child;}
016bac278a8f60aec7a89722089f1c9f9f835485f6ec65fc52d0e84186d25458
start
public final void start()
{    buffer.clear();}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    parent.add(new NonSpillableDataBag(new ArrayList<Tuple>(buffer)));}
f217af5a4bd0d4c550c05f4593198974a2891c9655de266166cf37177252324b
getCurrentRecord
public Tuple getCurrentRecord()
{    return root.getCurrentTuple();}
92fd854c4aebb01be238d83e407159211ea5cf60b5efd6fc7db8904dba13699b
getRootConverter
public GroupConverter getRootConverter()
{    return root;}
58d3d1250cb63e4e61d7e325c7119205523848d80f7aa5acd580bbfc41a2bc28
setLocation
public void setLocation(String location, Job job) throws IOException
{    if (LOG.isDebugEnabled()) {        String jobToString = String.format("job[id=%s, name=%s]", job.getJobID(), job.getJobName());        LOG.debug("LoadFunc.setLocation({}, {})", location, jobToString);    }    setInput(location, job);}
691b16da0b44c2141e685c2c85d24b7b0bf226057326f9d4a598f7dca6131d34
setInput
private void setInput(String location, Job job) throws IOException
{    this.setLocationHasBeenCalled = true;    this.location = location;    setInputPaths(job, location);        if (UDFContext.getUDFContext().isFrontend()) {        storeInUDFContext(PARQUET_COLUMN_INDEX_ACCESS, Boolean.toString(columnIndexAccess));    }    schema = PigSchemaConverter.parsePigSchema(getPropertyFromUDFContext(PARQUET_PIG_SCHEMA));    requiredFieldList = PigSchemaConverter.deserializeRequiredFieldList(getPropertyFromUDFContext(PARQUET_PIG_REQUIRED_FIELDS));    columnIndexAccess = Boolean.parseBoolean(getPropertyFromUDFContext(PARQUET_COLUMN_INDEX_ACCESS));    initSchema(job);    if (UDFContext.getUDFContext().isFrontend()) {                storeInUDFContext(PARQUET_PIG_SCHEMA, pigSchemaToString(schema));        storeInUDFContext(PARQUET_PIG_REQUIRED_FIELDS, serializeRequiredFieldList(requiredFieldList));    }        getConfiguration(job).set(PARQUET_PIG_SCHEMA, pigSchemaToString(schema));    getConfiguration(job).set(PARQUET_PIG_REQUIRED_FIELDS, serializeRequiredFieldList(requiredFieldList));    getConfiguration(job).set(PARQUET_COLUMN_INDEX_ACCESS, Boolean.toString(columnIndexAccess));    FilterPredicate filterPredicate = (FilterPredicate) getFromUDFContext(ParquetInputFormat.FILTER_PREDICATE);    if (filterPredicate != null) {        ParquetInputFormat.setFilterPredicate(getConfiguration(job), filterPredicate);    }}
9fafebe861e8847cc3ff408f728716681a672d15b7c6bf83d4fe03a0d0cc1a5e
getInputFormat
public InputFormat<Void, Tuple> getInputFormat() throws IOException
{    LOG.debug("LoadFunc.getInputFormat()");    return getParquetInputFormat();}
a1afaba2f77a68950a15c8445cc1aec3ed6ec333a2d5158e5f2903a10cac3a70
checkSetLocationHasBeenCalled
private void checkSetLocationHasBeenCalled()
{    if (!setLocationHasBeenCalled) {        throw new IllegalStateException("setLocation() must be called first");    }}
a7873cb5d47b75484a4d786022d0131e934c07ebdeef27c3819f93b51a8bfb0c
createRecordReader
public RecordReader<Void, Tuple> createRecordReader(InputSplit inputSplit, TaskAttemptContext taskAttemptContext) throws IOException, InterruptedException
{        inputFormatCache.remove(location);    return super.createRecordReader(inputSplit, taskAttemptContext);}
ff2bb3a2b1f46ab6b2746555017e48ea494239e60a6d99e21310b737c84df269
getParquetInputFormat
private ParquetInputFormat<Tuple> getParquetInputFormat() throws ParserException
{    checkSetLocationHasBeenCalled();    if (parquetInputFormat == null) {                Reference<ParquetInputFormat<Tuple>> ref = inputFormatCache.get(location);        parquetInputFormat = ref == null ? null : ref.get();        if (parquetInputFormat == null) {            parquetInputFormat = new UnregisteringParquetInputFormat(location);            inputFormatCache.put(location, new SoftReference<ParquetInputFormat<Tuple>>(parquetInputFormat));        }    }    return parquetInputFormat;}
826f7cb3f441284dd94bfd18adb9f743ac75db410187419d518d3e0e92968b89
prepareToRead
public void prepareToRead(@SuppressWarnings("rawtypes") RecordReader reader, PigSplit split) throws IOException
{    LOG.debug("LoadFunc.prepareToRead({}, {})", reader, split);    this.reader = reader;}
fe36b89a2b73e4fc44a293f511824416189ada85bea702c23121ada948d2ad2c
getNext
public Tuple getNext() throws IOException
{    try {        if (reader.nextKeyValue()) {            return (Tuple) reader.getCurrentValue();        } else {            return null;        }    } catch (InterruptedException e) {        Thread.interrupted();        throw new ParquetDecodingException("Interrupted", e);    }}
151e533dca60fd44f9968e23304f5ca59e2b30e4c0beb18dbe2a5cca040993d6
getPartitionKeys
public String[] getPartitionKeys(String location, Job job) throws IOException
{    if (LOG.isDebugEnabled()) {        String jobToString = String.format("job[id=%s, name=%s]", job.getJobID(), job.getJobName());        LOG.debug("LoadMetadata.getPartitionKeys({}, {})", location, jobToString);    }    setInput(location, job);    return null;}
c173dad9f6c21fbff0f05c19b1a2a6ad4217496a679e68b6edc0e4fe2a0eb351
getSchema
public ResourceSchema getSchema(String location, Job job) throws IOException
{    if (LOG.isDebugEnabled()) {        String jobToString = String.format("job[id=%s, name=%s]", job.getJobID(), job.getJobName());        LOG.debug("LoadMetadata.getSchema({}, {})", location, jobToString);    }    setInput(location, job);    return new ResourceSchema(schema);}
98ed9e3dbbbdbda6c1c0429e87180cd708568db11460a2a008927d596cbe353d
initSchema
private void initSchema(Job job) throws IOException
{    if (schema != null) {        return;    }    if (schema == null && requestedSchema != null) {                schema = requestedSchema;    }    if (schema == null) {                final GlobalMetaData globalMetaData = getParquetInputFormat().getGlobalMetaData(job);        schema = getPigSchemaFromMultipleFiles(globalMetaData.getSchema(), globalMetaData.getKeyValueMetaData());    }    if (isElephantBirdCompatible(job)) {        convertToElephantBirdCompatibleSchema(schema);    }}
9f14f402ec7b73acf224a9e57a58515e795c7ca93d409d33a4976b601064dcdb
convertToElephantBirdCompatibleSchema
private void convertToElephantBirdCompatibleSchema(Schema schema)
{    if (schema == null) {        return;    }    for (FieldSchema fieldSchema : schema.getFields()) {        if (fieldSchema.type == DataType.BOOLEAN) {            fieldSchema.type = DataType.INTEGER;        }        convertToElephantBirdCompatibleSchema(fieldSchema.schema);    }}
93c501c3074790b54ba30abc8ea87ecd9da379b5337873c5cbfd81fd395232cb
isElephantBirdCompatible
private boolean isElephantBirdCompatible(Job job)
{    return getConfiguration(job).getBoolean(TupleReadSupport.PARQUET_PIG_ELEPHANT_BIRD_COMPATIBLE, false);}
84d5fa7f979dd3922d39ea06301501f0acb4660afdd0bdfabf550eff38e5bccf
getStatistics
public ResourceStatistics getStatistics(String location, Job job) throws IOException
{    if (LOG.isDebugEnabled()) {        String jobToString = String.format("job[id=%s, name=%s]", job.getJobID(), job.getJobName());        LOG.debug("LoadMetadata.getStatistics({}, {})", location, jobToString);    }    /* We need to call setInput since setLocation is not       guaranteed to be called before this */    setInput(location, job);    long length = 0;    try {        for (InputSplit split : getParquetInputFormat().getSplits(job)) {            length += split.getLength();        }    } catch (InterruptedException e) {        LOG.warn("Interrupted: ", e);        return null;    }    ResourceStatistics stats = new ResourceStatistics();        stats.setmBytes(length / 1024 / 1024);    return stats;}
baec6a8bc4290192aa517e801355d949bac3048db699ac3a1f7d85d074733279
setPartitionFilter
public void setPartitionFilter(Expression expression) throws IOException
{    LOG.debug("LoadMetadata.setPartitionFilter({})", expression);}
7f145d907d5b9daf5d2e5408a68cb11c2cc5d13ed5db903dda0e8d1436cb96c6
getFeatures
public List<OperatorSet> getFeatures()
{    return asList(LoadPushDown.OperatorSet.PROJECTION);}
c0b656e1f53c868e052e843743dacf0e6ea1e8edc6e75b75102336df67507ebd
getPropertyFromUDFContext
protected String getPropertyFromUDFContext(String key)
{    UDFContext udfContext = UDFContext.getUDFContext();    return udfContext.getUDFProperties(this.getClass(), new String[] { signature }).getProperty(key);}
2b7f11d76579752b1deb1185799e94f193f93c78d2b280ecd835c383682cfdb4
getFromUDFContext
protected Object getFromUDFContext(String key)
{    UDFContext udfContext = UDFContext.getUDFContext();    return udfContext.getUDFProperties(this.getClass(), new String[] { signature }).get(key);}
f6e402888f1eafeac55103dc60f1df8c8e70d0ff27d0fc0c23174e1f29b09672
storeInUDFContext
protected void storeInUDFContext(String key, Object value)
{    UDFContext udfContext = UDFContext.getUDFContext();    java.util.Properties props = udfContext.getUDFProperties(this.getClass(), new String[] { signature });    props.put(key, value);}
f1e8989655ba930fcd239a0270d1fd029ced6d3f5ae7da076bd4867f0e7d9a7c
pushProjection
public RequiredFieldResponse pushProjection(RequiredFieldList requiredFieldList) throws FrontendException
{    this.requiredFieldList = requiredFieldList;    if (requiredFieldList == null)        return null;    schema = getSchemaFromRequiredFieldList(schema, requiredFieldList.getFields());    storeInUDFContext(PARQUET_PIG_SCHEMA, pigSchemaToString(schema));    storeInUDFContext(PARQUET_PIG_REQUIRED_FIELDS, serializeRequiredFieldList(requiredFieldList));    return new RequiredFieldResponse(true);}
7ffce029b5cff3c3d0fb5039b539302edd05e57b1e961119415d6f5680727376
setUDFContextSignature
public void setUDFContextSignature(String signature)
{    this.signature = signature;}
4d0d1f92161599296bd245ac25a27ca482ca937e6db69055880abea6246b65ac
getSchemaFromRequiredFieldList
private Schema getSchemaFromRequiredFieldList(Schema schema, List<RequiredField> fieldList) throws FrontendException
{    Schema s = new Schema();    for (RequiredField rf : fieldList) {        FieldSchema f;        try {            f = schema.getField(rf.getAlias()).clone();        } catch (CloneNotSupportedException e) {            throw new FrontendException("Clone not supported for the fieldschema", e);        }        if (rf.getSubFields() == null) {            s.add(f);        } else {            Schema innerSchema = getSchemaFromRequiredFieldList(f.schema, rf.getSubFields());            if (innerSchema == null) {                return null;            } else {                f.schema = innerSchema;                s.add(f);            }        }    }    return s;}
90a571db8a34533e89ec9a8097664f6a2a8f50fb6b6ae9f32da6e2b51c9afe7e
getPredicateFields
public List<String> getPredicateFields(String s, Job job) throws IOException
{    if (!job.getConfiguration().getBoolean(ENABLE_PREDICATE_FILTER_PUSHDOWN, DEFAULT_PREDICATE_PUSHDOWN_ENABLED)) {        return null;    }    List<String> fields = new ArrayList<String>();    for (FieldSchema field : schema.getFields()) {        switch(field.type) {            case DataType.BOOLEAN:            case DataType.INTEGER:            case DataType.LONG:            case DataType.FLOAT:            case DataType.DOUBLE:            case DataType.CHARARRAY:                fields.add(field.alias);                break;            default:                                break;        }    }    return fields;}
f2173730aa639d6bf84b6e5525634ada319c9bcaa1169421699bfb695ef14233
getSupportedExpressionTypes
public List<Expression.OpType> getSupportedExpressionTypes()
{    OpType[] supportedTypes = { OpType.OP_EQ, OpType.OP_NE, OpType.OP_GT, OpType.OP_GE, OpType.OP_LT, OpType.OP_LE, OpType.OP_AND, OpType.OP_OR,     OpType.OP_NOT };    return Arrays.asList(supportedTypes);}
43b9536bc9c94f455beb7818f495f9eb0995bf1365622b31be5f94dbf5a33615
setPushdownPredicate
public void setPushdownPredicate(Expression e) throws IOException
{    LOG.info("Pig pushdown expression: {}", e);    FilterPredicate pred = buildFilter(e);    LOG.info("Parquet filter predicate expression: {}", pred);    storeInUDFContext(ParquetInputFormat.FILTER_PREDICATE, pred);}
38c94b1129185dc0395e5d792165ba4e1f311d4f0f46689a7ed0317de2e7a390
buildFilter
private FilterPredicate buildFilter(Expression e)
{    OpType op = e.getOpType();    if (e instanceof BinaryExpression) {        Expression lhs = ((BinaryExpression) e).getLhs();        Expression rhs = ((BinaryExpression) e).getRhs();        switch(op) {            case OP_AND:                return and(buildFilter(lhs), buildFilter(rhs));            case OP_OR:                return or(buildFilter(lhs), buildFilter(rhs));            case OP_BETWEEN:                BetweenExpression between = (BetweenExpression) rhs;                return and(buildFilter(OpType.OP_GE, (Column) lhs, (Const) between.getLower()), buildFilter(OpType.OP_LE, (Column) lhs, (Const) between.getUpper()));            case OP_IN:                FilterPredicate current = null;                for (Object value : ((InExpression) rhs).getValues()) {                    FilterPredicate next = buildFilter(OpType.OP_EQ, (Column) lhs, (Const) value);                    if (current != null) {                        current = or(current, next);                    } else {                        current = next;                    }                }                return current;        }        if (lhs instanceof Column && rhs instanceof Const) {            return buildFilter(op, (Column) lhs, (Const) rhs);        } else if (lhs instanceof Const && rhs instanceof Column) {            return buildFilter(op, (Column) rhs, (Const) lhs);        }    } else if (e instanceof UnaryExpression && op == OpType.OP_NOT) {        return LogicalInverseRewriter.rewrite(not(buildFilter(((UnaryExpression) e).getExpression())));    }    throw new RuntimeException("Could not build filter for expression: " + e);}
1afbd7a41b578ec87a8d0846833d2f574ea60e0e69c31e7fcb50032ca2aa296f
buildFilter
private FilterPredicate buildFilter(OpType op, Column col, Const value)
{    String name = col.getName();    try {        FieldSchema f = schema.getField(name);        switch(f.type) {            case DataType.BOOLEAN:                Operators.BooleanColumn boolCol = booleanColumn(name);                switch(op) {                    case OP_EQ:                        return eq(boolCol, getValue(value, boolCol.getColumnType()));                    case OP_NE:                        return notEq(boolCol, getValue(value, boolCol.getColumnType()));                    default:                        throw new RuntimeException("Operation " + op + " not supported for boolean column: " + name);                }            case DataType.INTEGER:                Operators.IntColumn intCol = intColumn(name);                return op(op, intCol, value);            case DataType.LONG:                Operators.LongColumn longCol = longColumn(name);                return op(op, longCol, value);            case DataType.FLOAT:                Operators.FloatColumn floatCol = floatColumn(name);                return op(op, floatCol, value);            case DataType.DOUBLE:                Operators.DoubleColumn doubleCol = doubleColumn(name);                return op(op, doubleCol, value);            case DataType.CHARARRAY:                Operators.BinaryColumn binaryCol = binaryColumn(name);                return op(op, binaryCol, value);            default:                throw new RuntimeException("Unsupported type " + f.type + " for field: " + name);        }    } catch (FrontendException e) {        throw new RuntimeException("Error processing pushdown for column:" + col, e);    }}
e4c6f9e1782fe1fe020b83d8696a00d34fad70bf891d02018d5a8b005859c6c9
op
private static FilterPredicate op(Expression.OpType op, COL col, Const valueExpr)
{    C value = getValue(valueExpr, col.getColumnType());    switch(op) {        case OP_EQ:            return eq(col, value);        case OP_NE:            return notEq(col, value);        case OP_GT:            return gt(col, value);        case OP_GE:            return gtEq(col, value);        case OP_LT:            return lt(col, value);        case OP_LE:            return ltEq(col, value);    }    return null;}
44488f5b594c23e3247404a59b57dcf774d15cded57655a0fdb2ec8489cdcfb9
getValue
private static C getValue(Const valueExpr, Class<C> type)
{    Object value = valueExpr.getValue();    if (value instanceof String) {        value = Binary.fromString((String) value);    }    return type.cast(value);}
dfa9058f41d48bf485020f1bd401e6c7093b590dacf9240a003bda155334c2ca
getProperties
private Properties getProperties()
{    UDFContext udfc = UDFContext.getUDFContext();    Properties p = udfc.getUDFProperties(this.getClass(), new String[] { signature });    return p;}
c7555df95ca269578fc04d45759d255450971e07ac085f9bb26af8e6701270d6
getSchema
private Schema getSchema()
{    try {        final String schemaString = getProperties().getProperty(SCHEMA);        if (schemaString == null) {            throw new ParquetEncodingException("Can not store relation in Parquet as the schema is unknown");        }        return Utils.getSchemaFromString(schemaString);    } catch (ParserException e) {        throw new ParquetEncodingException("can not get schema from context", e);    }}
eabbb3955d1e88ea651da8c1b860ec077a66df40916a5322305c2fb9aa0b6001
setStoreFuncUDFContextSignature
public void setStoreFuncUDFContextSignature(String signature)
{    super.setStoreFuncUDFContextSignature(signature);    this.signature = signature;}
85c7009e0b838a5865ce242809a70c8ba557c3aea63d2b2abf875ff0048f8249
checkSchema
public void checkSchema(ResourceSchema s) throws IOException
{    getProperties().setProperty(SCHEMA, s.toString());}
7a3859e63ac72e65278bd44434c3244562c40b5f4f5b94ae3a437fff6a931204
getOutputFormat
public OutputFormat<Void, Tuple> getOutputFormat() throws IOException
{    Schema pigSchema = getSchema();    return new ParquetOutputFormat<Tuple>(new TupleWriteSupport(pigSchema));}
9d1865e4f31137471036b0b8f88689037236deebc8f0fa3c17614ce220ef4172
prepareToWrite
public void prepareToWrite(RecordWriter recordWriter) throws IOException
{    this.recordWriter = recordWriter;}
4dd235f692106bcee0d0f464ac37c8eb963acd4c93c7bc3bb8d00eeaee0b1d91
putNext
public void putNext(Tuple tuple) throws IOException
{    try {        this.recordWriter.write(null, tuple);    } catch (InterruptedException e) {        Thread.interrupted();        throw new ParquetEncodingException("Interrupted while writing", e);    }}
22fbb46c1ec3a62ec68e4fbe084b178c4fb1498cae03fa71b3dacf1a16d4e15a
setStoreLocation
public void setStoreLocation(String location, Job job) throws IOException
{    FileOutputFormat.setOutputPath(job, new Path(location));}
ee5089314d9613829cad4e6b0631d3938bb7995a6318853363b4f4ebeb1a885a
storeSchema
public void storeSchema(ResourceSchema schema, String location, Job job) throws IOException
{}
432f78c4548d58ccd8de1d2dcc97ef9a778aaa615c1340b313b77f14d45c1f7b
storeStatistics
public void storeStatistics(ResourceStatistics resourceStatistics, String location, Job job) throws IOException
{}
1d7776c52f2c8326078550ed6f73241059793adcf55370251a21cb74f1710647
fromMetaData
public static PigMetaData fromMetaData(Map<String, String> keyValueMetaData)
{    if (keyValueMetaData.containsKey(PIG_SCHEMA)) {        return new PigMetaData(keyValueMetaData.get(PIG_SCHEMA));    }    return null;}
e265ee12a8099f287d25cededc75cf9260791b2ab4b61318a8008ae14875cf01
getPigSchemas
public static Set<String> getPigSchemas(Map<String, Set<String>> keyValueMetaData)
{    return keyValueMetaData.get(PIG_SCHEMA);}
0f601e89cad75977dd05f3c7a72fb16601cbe96361c1710f9b1c98ec57945b3c
setPigSchema
public void setPigSchema(String pigSchema)
{    this.pigSchema = pigSchema;}
428e986dded80b7f5ed6d57f98746d5b938ffca1a975fc7d8caec9a3b8ee529b
getPigSchema
public String getPigSchema()
{    return pigSchema;}
26e5f30ebd0fa05cf74328c9becb24109ff4b360d75236c009bd189f4c0182a3
addToMetaData
public void addToMetaData(Map<String, String> map)
{    map.put(PIG_SCHEMA, pigSchema);}
70c9af462dd980090620cae853e216892f50e25010665f98aadf796ef4ff081e
parsePigSchema
public static Schema parsePigSchema(String pigSchemaString)
{    try {        return pigSchemaString == null ? null : Utils.getSchemaFromString(pigSchemaString);    } catch (ParserException e) {        throw new SchemaConversionException("could not parse Pig schema: " + pigSchemaString, e);    }}
b37d8f41877af7fd95f82224f002737f198bc74332b6a1412725f847c17d6d1b
filterTupleSchema
public List<Type> filterTupleSchema(GroupType schemaToFilter, Schema pigSchema, RequiredFieldList requiredFieldsList)
{    List<Type> newFields = new ArrayList<Type>();    List<Pair<FieldSchema, Integer>> indexedFields = new ArrayList<Pair<FieldSchema, Integer>>();    try {        if (requiredFieldsList == null) {            int index = 0;            for (FieldSchema fs : pigSchema.getFields()) {                indexedFields.add(new Pair<FieldSchema, Integer>(fs, index++));            }        } else {            for (RequiredField rf : requiredFieldsList.getFields()) {                indexedFields.add(new Pair<FieldSchema, Integer>(pigSchema.getField(rf.getAlias()), rf.getIndex()));            }        }        for (Pair<FieldSchema, Integer> p : indexedFields) {            FieldSchema fieldSchema = pigSchema.getField(p.first.alias);            if (p.second < schemaToFilter.getFieldCount()) {                Type type = schemaToFilter.getFields().get(p.second);                newFields.add(filter(type, fieldSchema));            }        }    } catch (FrontendException e) {        throw new RuntimeException("Failed to filter requested fields", e);    }    return newFields;}
9d15643818cd3780b6ba1274553d3f966ff4eb99e6e18067e6f4194d9c3041ec
filterTupleSchema
public List<Type> filterTupleSchema(GroupType schemaToFilter, Schema requestedPigSchema, RequiredFieldList requiredFieldsList)
{    List<FieldSchema> fields = requestedPigSchema.getFields();    List<Type> newFields = new ArrayList<Type>();    for (int i = 0; i < fields.size(); i++) {        FieldSchema fieldSchema = fields.get(i);        String name = name(fieldSchema.alias, "field_" + i);        if (schemaToFilter.containsField(name)) {            newFields.add(filter(schemaToFilter.getType(name), fieldSchema));        }    }    return newFields;}
7b8a3d9286434be96d3f65178aa811805c5cd50924824f4469ff26631b445683
pigSchemaToString
 static String pigSchemaToString(Schema pigSchema)
{    final String pigSchemaString = pigSchema.toString();    return pigSchemaString.substring(1, pigSchemaString.length() - 1);}
1a41a9926615875e253823c1111630df78bc1fa244c18d72d319a69e96e86c97
deserializeRequiredFieldList
public static RequiredFieldList deserializeRequiredFieldList(String requiredFieldString)
{    if (requiredFieldString == null) {        return null;    }    try {        return (RequiredFieldList) ObjectSerializer.deserialize(requiredFieldString);    } catch (IOException e) {        throw new RuntimeException("Failed to deserialize pushProjection", e);    }}
203e0ce7df4fecbaf2bca50d6488beff03165e7146ce67f2e1a39d71b478f28d
serializeRequiredFieldList
 static String serializeRequiredFieldList(RequiredFieldList requiredFieldList)
{    try {        return ObjectSerializer.serialize(requiredFieldList);    } catch (IOException e) {        throw new RuntimeException("Failed to searlize required fields.", e);    }}
38ace24c9bd153a8567c7188c299bf16c4a4aa264c03c6b973580a452d006bc8
convert
public Schema convert(MessageType parquetSchema)
{    return convertFields(parquetSchema.getFields());}
6c0300389bcbe783a79e4d22ee3abfdbc9242b4bd590e87a4ea91f1421442504
convertField
public Schema convertField(Type parquetType)
{    return convertFields(Arrays.asList(parquetType));}
5ad711976c9c715b0879967e7d247259c8e7e2d5ced94e807ffa1f0fa937e205
convertFields
private Schema convertFields(List<Type> parquetFields)
{    List<FieldSchema> fields = new ArrayList<Schema.FieldSchema>();    for (Type parquetType : parquetFields) {        try {            FieldSchema innerfieldSchema = getFieldSchema(parquetType);            if (parquetType.isRepetition(Repetition.REPEATED)) {                Schema bagSchema = new Schema(Arrays.asList(innerfieldSchema));                fields.add(new FieldSchema(null, bagSchema, DataType.BAG));            } else {                fields.add(innerfieldSchema);            }        } catch (FrontendException fe) {            throw new SchemaConversionException("can't convert " + parquetType, fe);        }    }    return new Schema(fields);}
a7c596494e9186177a107a33a3c57a8d4d195e7c56835a62b561082dc580e9ba
getSimpleFieldSchema
private FieldSchema getSimpleFieldSchema(final String fieldName, Type parquetType) throws FrontendException
{    final PrimitiveTypeName parquetPrimitiveTypeName = parquetType.asPrimitiveType().getPrimitiveTypeName();    final LogicalTypeAnnotation logicalTypeAnnotation = parquetType.getLogicalTypeAnnotation();    return parquetPrimitiveTypeName.convert(new PrimitiveTypeNameConverter<Schema.FieldSchema, FrontendException>() {        @Override        public FieldSchema convertFLOAT(PrimitiveTypeName primitiveTypeName) throws FrontendException {            return new FieldSchema(fieldName, null, DataType.FLOAT);        }        @Override        public FieldSchema convertDOUBLE(PrimitiveTypeName primitiveTypeName) throws FrontendException {            return new FieldSchema(fieldName, null, DataType.DOUBLE);        }        @Override        public FieldSchema convertINT32(PrimitiveTypeName primitiveTypeName) throws FrontendException {            return new FieldSchema(fieldName, null, DataType.INTEGER);        }        @Override        public FieldSchema convertINT64(PrimitiveTypeName primitiveTypeName) throws FrontendException {            return new FieldSchema(fieldName, null, DataType.LONG);        }        @Override        public FieldSchema convertINT96(PrimitiveTypeName primitiveTypeName) throws FrontendException {            LOG.warn("Converting type " + primitiveTypeName + " to bytearray");            return new FieldSchema(fieldName, null, DataType.BYTEARRAY);        }        @Override        public FieldSchema convertFIXED_LEN_BYTE_ARRAY(PrimitiveTypeName primitiveTypeName) throws FrontendException {            if (logicalTypeAnnotation instanceof LogicalTypeAnnotation.DecimalLogicalTypeAnnotation) {                return new FieldSchema(fieldName, null, DataType.BIGDECIMAL);            } else {                return new FieldSchema(fieldName, null, DataType.BYTEARRAY);            }        }        @Override        public FieldSchema convertBOOLEAN(PrimitiveTypeName primitiveTypeName) throws FrontendException {            return new FieldSchema(fieldName, null, DataType.BOOLEAN);        }        @Override        public FieldSchema convertBINARY(PrimitiveTypeName primitiveTypeName) throws FrontendException {            if (logicalTypeAnnotation instanceof LogicalTypeAnnotation.StringLogicalTypeAnnotation) {                return new FieldSchema(fieldName, null, DataType.CHARARRAY);            } else {                return new FieldSchema(fieldName, null, DataType.BYTEARRAY);            }        }    });}
55af01cd32f47a1b310488503b5bd306e92394f5b286ad68e013c717d657534c
convertFLOAT
public FieldSchema convertFLOAT(PrimitiveTypeName primitiveTypeName) throws FrontendException
{    return new FieldSchema(fieldName, null, DataType.FLOAT);}
30af12ec9c354deba50b04862a7331997f9a97855ba84e0d6bc98ca14051eb9c
convertDOUBLE
public FieldSchema convertDOUBLE(PrimitiveTypeName primitiveTypeName) throws FrontendException
{    return new FieldSchema(fieldName, null, DataType.DOUBLE);}
7fd919fd6be72578d4989c16a9574df8380143f502fa040fe3b4fa965674fa93
convertINT32
public FieldSchema convertINT32(PrimitiveTypeName primitiveTypeName) throws FrontendException
{    return new FieldSchema(fieldName, null, DataType.INTEGER);}
1c91d9bd57205d0906f083a69d4c7175a4aabec440063d6634767179485731b6
convertINT64
public FieldSchema convertINT64(PrimitiveTypeName primitiveTypeName) throws FrontendException
{    return new FieldSchema(fieldName, null, DataType.LONG);}
38b97f507c57f42f1f6f451796d9ecde52051097a9d2a048b62d912c3cc1e711
convertINT96
public FieldSchema convertINT96(PrimitiveTypeName primitiveTypeName) throws FrontendException
{    LOG.warn("Converting type " + primitiveTypeName + " to bytearray");    return new FieldSchema(fieldName, null, DataType.BYTEARRAY);}
92c179433228628ec69932331cdf4b2583d22baef26c20a235272e736f646d19
convertFIXED_LEN_BYTE_ARRAY
public FieldSchema convertFIXED_LEN_BYTE_ARRAY(PrimitiveTypeName primitiveTypeName) throws FrontendException
{    if (logicalTypeAnnotation instanceof LogicalTypeAnnotation.DecimalLogicalTypeAnnotation) {        return new FieldSchema(fieldName, null, DataType.BIGDECIMAL);    } else {        return new FieldSchema(fieldName, null, DataType.BYTEARRAY);    }}
4474cd53a60ed4f7cba0f7956a7db86262852c516880c02a69ac228649171634
convertBOOLEAN
public FieldSchema convertBOOLEAN(PrimitiveTypeName primitiveTypeName) throws FrontendException
{    return new FieldSchema(fieldName, null, DataType.BOOLEAN);}
18f795195372a8c338fd27292ca045ee404de7e0b0d8b4d64b52c1016f569677
convertBINARY
public FieldSchema convertBINARY(PrimitiveTypeName primitiveTypeName) throws FrontendException
{    if (logicalTypeAnnotation instanceof LogicalTypeAnnotation.StringLogicalTypeAnnotation) {        return new FieldSchema(fieldName, null, DataType.CHARARRAY);    } else {        return new FieldSchema(fieldName, null, DataType.BYTEARRAY);    }}
0a0d16ee30501e54e99e7c32ea903c7b6f10f6d5d0c92ba960a3459a345926fa
getComplexFieldSchema
private FieldSchema getComplexFieldSchema(String fieldName, Type parquetType) throws FrontendException
{    GroupType parquetGroupType = parquetType.asGroupType();    LogicalTypeAnnotation logicalTypeAnnotation = parquetGroupType.getLogicalTypeAnnotation();    if (logicalTypeAnnotation != null) {        try {            return logicalTypeAnnotation.accept(new LogicalTypeAnnotation.LogicalTypeAnnotationVisitor<FieldSchema>() {                @Override                public Optional<FieldSchema> visit(LogicalTypeAnnotation.MapLogicalTypeAnnotation mapLogicalType) {                    try {                                                if (parquetGroupType.getFieldCount() != 1 || parquetGroupType.getType(0).isPrimitive()) {                            throw new SchemaConversionException("Invalid map type " + parquetGroupType);                        }                        GroupType mapKeyValType = parquetGroupType.getType(0).asGroupType();                        if (!mapKeyValType.isRepetition(Repetition.REPEATED) || (mapKeyValType.getLogicalTypeAnnotation() != null && !mapKeyValType.getLogicalTypeAnnotation().equals(LogicalTypeAnnotation.MapKeyValueTypeAnnotation.getInstance())) || mapKeyValType.getFieldCount() != 2) {                            throw new SchemaConversionException("Invalid map type " + parquetGroupType);                        }                                                Type valueType = mapKeyValType.getType(1);                        Schema s = convertField(valueType);                        s.getField(0).alias = null;                        return of(new FieldSchema(fieldName, s, DataType.MAP));                    } catch (FrontendException e) {                        throw new FrontendExceptionWrapper(e);                    }                }                @Override                public Optional<FieldSchema> visit(LogicalTypeAnnotation.ListLogicalTypeAnnotation listLogicalType) {                    try {                        Type type = parquetGroupType.getType(0);                        if (parquetGroupType.getFieldCount() != 1 || type.isPrimitive()) {                                                        Schema primitiveSchema = new Schema(getSimpleFieldSchema(parquetGroupType.getFieldName(0), type));                            Schema tupleSchema = new Schema(new FieldSchema(ARRAY_VALUE_NAME, primitiveSchema, DataType.TUPLE));                            return of(new FieldSchema(fieldName, tupleSchema, DataType.BAG));                        }                        GroupType tupleType = parquetGroupType.getType(0).asGroupType();                        if (!tupleType.isRepetition(Repetition.REPEATED)) {                            throw new SchemaConversionException("Invalid list type " + parquetGroupType);                        }                        Schema tupleSchema = new Schema(new FieldSchema(tupleType.getName(), convertFields(tupleType.getFields()), DataType.TUPLE));                        return of(new FieldSchema(fieldName, tupleSchema, DataType.BAG));                    } catch (FrontendException e) {                        throw new FrontendExceptionWrapper(e);                    }                }            }).orElseThrow(() -> new SchemaConversionException("Unexpected original type for " + parquetType + ": " + logicalTypeAnnotation));        } catch (FrontendExceptionWrapper e) {            throw e.frontendException;        }    } else {                return new FieldSchema(fieldName, convertFields(parquetGroupType.getFields()), DataType.TUPLE);    }}
06d4e01d0fd49f0d8ab527d3423cdcbc8a4d3458edab8ce3f2cf2c021d82a4d2
visit
public Optional<FieldSchema> visit(LogicalTypeAnnotation.MapLogicalTypeAnnotation mapLogicalType)
{    try {                if (parquetGroupType.getFieldCount() != 1 || parquetGroupType.getType(0).isPrimitive()) {            throw new SchemaConversionException("Invalid map type " + parquetGroupType);        }        GroupType mapKeyValType = parquetGroupType.getType(0).asGroupType();        if (!mapKeyValType.isRepetition(Repetition.REPEATED) || (mapKeyValType.getLogicalTypeAnnotation() != null && !mapKeyValType.getLogicalTypeAnnotation().equals(LogicalTypeAnnotation.MapKeyValueTypeAnnotation.getInstance())) || mapKeyValType.getFieldCount() != 2) {            throw new SchemaConversionException("Invalid map type " + parquetGroupType);        }                Type valueType = mapKeyValType.getType(1);        Schema s = convertField(valueType);        s.getField(0).alias = null;        return of(new FieldSchema(fieldName, s, DataType.MAP));    } catch (FrontendException e) {        throw new FrontendExceptionWrapper(e);    }}
daa42a9f4723cd6ae9cafb4e85ceccef6eef3da6e558fc2ebd44a3f68355883d
visit
public Optional<FieldSchema> visit(LogicalTypeAnnotation.ListLogicalTypeAnnotation listLogicalType)
{    try {        Type type = parquetGroupType.getType(0);        if (parquetGroupType.getFieldCount() != 1 || type.isPrimitive()) {                        Schema primitiveSchema = new Schema(getSimpleFieldSchema(parquetGroupType.getFieldName(0), type));            Schema tupleSchema = new Schema(new FieldSchema(ARRAY_VALUE_NAME, primitiveSchema, DataType.TUPLE));            return of(new FieldSchema(fieldName, tupleSchema, DataType.BAG));        }        GroupType tupleType = parquetGroupType.getType(0).asGroupType();        if (!tupleType.isRepetition(Repetition.REPEATED)) {            throw new SchemaConversionException("Invalid list type " + parquetGroupType);        }        Schema tupleSchema = new Schema(new FieldSchema(tupleType.getName(), convertFields(tupleType.getFields()), DataType.TUPLE));        return of(new FieldSchema(fieldName, tupleSchema, DataType.BAG));    } catch (FrontendException e) {        throw new FrontendExceptionWrapper(e);    }}
82f9036f3518f468a4d7af2f813917bcd9a8c42f8bc00c19ace36205d4b57a54
getFieldSchema
private FieldSchema getFieldSchema(Type parquetType) throws FrontendException
{    final String fieldName = parquetType.getName();    if (parquetType.isPrimitive()) {        return getSimpleFieldSchema(fieldName, parquetType);    } else {        return getComplexFieldSchema(fieldName, parquetType);    }}
8b748be87750a84c5faf83a38aab51b76ce03ebb1976a5b8ddba17d4b25c8b45
convert
public MessageType convert(Schema pigSchema)
{    return new MessageType("pig_schema", convertTypes(pigSchema));}
f62196a52df4db7bb2c739ec84eac3c0bee4812904239f17aa613a28b98fed6c
convertTypes
private Type[] convertTypes(Schema pigSchema)
{    List<FieldSchema> fields = pigSchema.getFields();    Type[] types = new Type[fields.size()];    for (int i = 0; i < types.length; i++) {        types[i] = convert(fields.get(i), i);    }    return types;}
caa84b191e318efab2fe5b839445bc07ac39b745160ae464f38e32e6e1a9a1fa
convert
private Type convert(FieldSchema fieldSchema, String defaultAlias)
{    String name = name(fieldSchema.alias, defaultAlias);    return convertWithName(fieldSchema, name);}
011e77b20a91291af8d16efdcdf1a0db1b78bbb9cf59d2856e306b82b1f586bb
convertWithName
private Type convertWithName(FieldSchema fieldSchema, String name)
{    try {        switch(fieldSchema.type) {            case DataType.BAG:                return convertBag(name, fieldSchema);            case DataType.TUPLE:                return convertTuple(name, fieldSchema, Repetition.OPTIONAL);            case DataType.MAP:                return convertMap(name, fieldSchema);            case DataType.BOOLEAN:                return primitive(name, PrimitiveTypeName.BOOLEAN);            case DataType.CHARARRAY:                return primitive(name, PrimitiveTypeName.BINARY, stringType());            case DataType.INTEGER:                return primitive(name, PrimitiveTypeName.INT32);            case DataType.LONG:                return primitive(name, PrimitiveTypeName.INT64);            case DataType.FLOAT:                return primitive(name, PrimitiveTypeName.FLOAT);            case DataType.DOUBLE:                return primitive(name, PrimitiveTypeName.DOUBLE);            case DataType.DATETIME:                throw new UnsupportedOperationException();            case DataType.BYTEARRAY:                return primitive(name, PrimitiveTypeName.BINARY);            default:                throw new SchemaConversionException("Unknown type " + fieldSchema.type + " " + DataType.findTypeName(fieldSchema.type));        }    } catch (FrontendException e) {        throw new SchemaConversionException("can't convert " + fieldSchema, e);    }}
684014e459a4cd7ab0cf87de5e0bb48b09c3f1081da7cb7903515f54c7305c7a
convert
private Type convert(FieldSchema fieldSchema, int index)
{    return convert(fieldSchema, "field_" + index);}
edff663451b8fc555e441240e1a937eafa4af9b0849d306debb0461508527988
convertBag
private GroupType convertBag(String name, FieldSchema fieldSchema) throws FrontendException
{    FieldSchema innerField = fieldSchema.schema.getField(0);    return ConversionPatterns.listType(Repetition.OPTIONAL, name, convertTuple(name(innerField.alias, "bag"), innerField, Repetition.REPEATED));}
c7c74f3993323738e1bc44791988dba670e14bad80129d7f8e6e8aae324e84b0
name
private String name(String fieldAlias, String defaultName)
{    return fieldAlias == null ? defaultName : fieldAlias;}
1b82d09e3a68fb5ec03069c6f27c63c092921faa4abcd8ee7d3f16fd19562937
primitive
private Type primitive(String name, PrimitiveTypeName primitive, LogicalTypeAnnotation logicalTypeAnnotation)
{    return Types.primitive(primitive, Repetition.OPTIONAL).as(logicalTypeAnnotation).named(name);}
493ca28a0627b1371a8d2b25d143fc1f0097864edfef33393c1da550cc2f59e7
primitive
private PrimitiveType primitive(String name, PrimitiveTypeName primitive)
{    return Types.primitive(primitive, Repetition.OPTIONAL).named(name);}
a83db565dcd6c083e4433916ebcf5609f9bd0503040b4ac534398ec8e20291ec
convertMap
private GroupType convertMap(String alias, FieldSchema fieldSchema)
{    Schema innerSchema = fieldSchema.schema;    if (innerSchema == null || innerSchema.size() != 1) {        throw new SchemaConversionException("Invalid map Schema, schema should contain exactly one field: " + fieldSchema);    }    FieldSchema innerField = null;    try {        innerField = innerSchema.getField(0);    } catch (FrontendException fe) {        throw new SchemaConversionException("Invalid map schema, cannot infer innerschema: ", fe);    }    Type convertedValue = convertWithName(innerField, "value");    return ConversionPatterns.stringKeyMapType(Repetition.OPTIONAL, alias, name(innerField.alias, "map"), convertedValue);}
d06cdf2cb6281a0a07da51b546f9efce95674b35cac7b06200f7d463ad481865
convertTuple
private GroupType convertTuple(String alias, FieldSchema field, Repetition repetition)
{    return new GroupType(repetition, alias, convertTypes(field.schema));}
05803d97565ad6ed6d4e682f18572437991bfa2b2b9327f12b2d7819f008849f
filter
public MessageType filter(MessageType schemaToFilter, Schema requestedPigSchema)
{    return filter(schemaToFilter, requestedPigSchema, null);}
dc099137b6320559fe0fc558665e5eefc9460eb40c9d89551ecd78f5ae063871
filter
public MessageType filter(MessageType schemaToFilter, Schema requestedPigSchema, RequiredFieldList requiredFieldList)
{    try {        if (LOG.isDebugEnabled())            LOG.debug("filtering schema:\n" + schemaToFilter + "\nwith requested pig schema:\n " + requestedPigSchema);        List<Type> result = columnAccess.filterTupleSchema(schemaToFilter, requestedPigSchema, requiredFieldList);        if (LOG.isDebugEnabled())            LOG.debug("schema:\n" + schemaToFilter + "\nfiltered to:\n" + result);        return new MessageType(schemaToFilter.getName(), result);    } catch (RuntimeException e) {        throw new RuntimeException("can't filter " + schemaToFilter + " with " + requestedPigSchema, e);    }}
f1e7a99d9993447733e0694d7bdb3d1b9d5f3ece227f771aa06f5534c69bd5b0
filter
private Type filter(Type type, FieldSchema fieldSchema)
{    if (LOG.isDebugEnabled())        LOG.debug("filtering type:\n" + type + "\nwith:\n " + fieldSchema);    try {        switch(fieldSchema.type) {            case DataType.BAG:                return filterBag(type.asGroupType(), fieldSchema);            case DataType.MAP:                return filterMap(type.asGroupType(), fieldSchema);            case DataType.TUPLE:                return filterTuple(type.asGroupType(), fieldSchema);            default:                return type;        }    } catch (FrontendException e) {        throw new SchemaConversionException("can't filter " + type + " with " + fieldSchema, e);    } catch (RuntimeException e) {        throw new RuntimeException("can't filter " + type + " with " + fieldSchema, e);    }}
45634db64fe8fe9da974480b15b305aaba811c53362df5eb5f93e6bb88eb78d2
filterTuple
private Type filterTuple(GroupType tupleType, FieldSchema tupleFieldSchema) throws FrontendException
{    if (LOG.isDebugEnabled())        LOG.debug("filtering TUPLE schema:\n" + tupleType + "\nwith:\n " + tupleFieldSchema);    return tupleType.withNewFields(columnAccess.filterTupleSchema(tupleType, tupleFieldSchema.schema, null));}
2c8d34b461a8d7dbfb9eecce15d1c09f4541b87f959da07f6dd1d5a8434ff077
filterMap
private Type filterMap(GroupType mapType, FieldSchema mapFieldSchema) throws FrontendException
{    if (LOG.isDebugEnabled())        LOG.debug("filtering MAP schema:\n" + mapType + "\nwith:\n " + mapFieldSchema);    if (mapType.getFieldCount() != 1) {        throw new RuntimeException("not unwrapping the right type, this should be a Map: " + mapType);    }    GroupType nested = mapType.getType(0).asGroupType();    if (nested.getFieldCount() != 2) {        throw new RuntimeException("this should be a Map Key/Value: " + mapType);    }    FieldSchema innerField = mapFieldSchema.schema.getField(0);    return mapType.withNewFields(nested.withNewFields(nested.getType(0), filter(nested.getType(1), innerField)));}
2ee671902a25e41d5cd2397412bf011a43eb6d62f11541e7c7bfc5c3b1fd6f1f
filterBag
private Type filterBag(GroupType bagType, FieldSchema bagFieldSchema) throws FrontendException
{    if (LOG.isDebugEnabled())        LOG.debug("filtering BAG schema:\n" + bagType + "\nwith:\n " + bagFieldSchema);    if (bagType.getFieldCount() != 1) {        throw new RuntimeException("not unwrapping the right type, this should be a Bag: " + bagType);    }    Type nested = bagType.getType(0);    FieldSchema innerField = bagFieldSchema.schema.getField(0);    if (nested.isPrimitive() || nested.getLogicalTypeAnnotation() instanceof LogicalTypeAnnotation.MapLogicalTypeAnnotation || nested.getLogicalTypeAnnotation() instanceof LogicalTypeAnnotation.ListLogicalTypeAnnotation) {                innerField = innerField.schema.getField(0);    }    return bagType.withNewFields(filter(nested, innerField));}
b7ec52063b1318f54b09e3c9f2fc2411d81ceecc34d73cd925e0a78cca40b909
add
public void add(Schema schema, DataBag bag)
{    super.add(bag);    size.add(bag.size());    FieldSchema field = getField(schema, 0);    if (bag.size() > 0 && content == null) {        content = new FieldSummaryData();        content.setName(getName(field));    }    for (Tuple tuple : bag) {        content.add(getSchema(field), tuple);    }}
d11b54d112f048a4832e72c3244d326ee3ebc44ce056a2fbb72ed9c37fd60dc7
merge
public void merge(SummaryData other)
{    super.merge(other);    BagSummaryData otherBagSummary = (BagSummaryData) other;    size.merge(otherBagSummary.size);    content = merge(content, otherBagSummary.content);}
b9cbce9603fd9e6c1bb622eabe51efc1007b0d2cda9749a5700e10077007c27b
getContent
public FieldSummaryData getContent()
{    return content;}
d5633fba12e7b484260eed60440a82c302cace506a0bdf8f8c81a9bee2e4399e
setContent
public void setContent(FieldSummaryData content)
{    this.content = content;}
8c2e9693125f8070f83402101b71b6017957221fbfc3238502c69b4338187f29
getSize
public ValueStat getSize()
{    return size;}
a0670ae56488e95069d2ffa81b55f09c7ceceaa574d31542fa89578986709618
setSize
public void setSize(ValueStat size)
{    this.size = size;}
41cb0c8c2f7f08040f2100be00b422b2e260f4d203be6064832bf46078f3e213
add
public void add()
{    ++count;}
3ffb3c74afa5355644c1f0bfdb5098954de2d3a057f971596bdb7110ccb67b1b
getValue
public String getValue()
{    return value;}
e711c8f2effc698edc71bd6b3e96530dc7034c8c55d38ce9f9541bf3f17925af
setValue
public void setValue(String value)
{    this.value = value;}
29fa59e92e8a9fa433fd7b38ebb21e8ece484149bc8e4a2726bba6f5dab39acf
getCount
public int getCount()
{    return count;}
252b9f86c92f6b1c8a0c8f316498fec361f0c1c4e7aabab47583f0d4590afe5b
setCount
public void setCount(int count)
{    this.count = count;}
2d5397caa7ba0848dbeff6f143125e9cdd92677750be80904d57df5029c1c44d
add
public void add(int countToAdd)
{    this.count += countToAdd;}
e2c970cba55efc3fff59d3e274d3187bc04cc64fb5e1f64c63932311c9369384
add
public void add(String value)
{    if (values != null) {        EnumValueCount enumValueCount = values.get(value);        if (enumValueCount == null) {            enumValueCount = new EnumValueCount(value);            values.put(value, enumValueCount);        }        enumValueCount.add();        checkValues();    }}
338033b1a0961ab6f8345c588633b62754ed1eb761dadfd87e1feb49f905c0bf
merge
public void merge(EnumStat other)
{    if (values != null) {        if (other.values == null) {            values = null;            return;        }        for (EnumValueCount otherValue : other.getValues()) {            EnumValueCount myValue = values.get(otherValue.value);            if (myValue == null) {                values.put(otherValue.value, otherValue);            } else {                myValue.add(otherValue.count);            }        }        checkValues();    }}
6ace127c59ce50d444d073d20e7ffae27189a1fe9bc3657976877e8970590d9e
checkValues
private void checkValues()
{    if (values.size() > MAX_COUNT) {        values = null;    }}
9bfadac203adf14129643baf2469b68ddc5e216355d93bdd4b53dbfc226f3de2
getValues
public Collection<EnumValueCount> getValues()
{    return values == null ? null : values.values();}
7fd4c136c8a6ae3f71a412d0e72536e319f3479814d63b19c14b83d9992af4b8
setValues
public void setValues(Collection<EnumValueCount> values)
{    if (values == null) {        this.values = null;    } else if (this.values != null) {        for (EnumValueCount value : values) {            this.values.put(value.getValue(), value);        }    }}
d11b54d112f048a4832e72c3244d326ee3ebc44ce056a2fbb72ed9c37fd60dc7
merge
public void merge(SummaryData other)
{    super.merge(other);    FieldSummaryData otherFieldSummaryData = (FieldSummaryData) other;    if (otherFieldSummaryData.name != null) {        setName(otherFieldSummaryData.name);    }    bag = merge(bag, otherFieldSummaryData.bag);    tuple = merge(tuple, otherFieldSummaryData.tuple);    map = merge(map, otherFieldSummaryData.map);    string = merge(string, otherFieldSummaryData.string);    number = merge(number, otherFieldSummaryData.number);    nullCount += otherFieldSummaryData.nullCount;    unknown += otherFieldSummaryData.unknown;    error += otherFieldSummaryData.error;}
56eb1ce6a0d8bd239d147b544fc9aff35ab3d5efc874684477e09a87e6726678
add
public void add(Schema schema, Object o)
{    super.add(o);    if (o == null) {        ++nullCount;    } else if (o instanceof DataBag) {        if (bag == null) {            bag = new BagSummaryData();        }        bag.add(schema, (DataBag) o);    } else if (o instanceof Tuple) {        if (tuple == null) {            tuple = new TupleSummaryData();        }        tuple.addTuple(schema, (Tuple) o);    } else if (o instanceof Map<?, ?>) {        if (map == null) {            map = new MapSummaryData();        }        map.add(schema, (Map<?, ?>) o);    } else if (o instanceof String) {        if (string == null) {            string = new StringSummaryData();        }        string.add((String) o);    } else if (o instanceof Number) {        if (number == null) {            number = new NumberSummaryData();        }        number.add((Number) o);    } else {        ++unknown;    }}
a0a4b545f72f8834d9001286644e529fd6bd5b305b46ac6da625f5f969c70709
addError
public void addError()
{    ++error;}
a710828413bb3e31993f9c91875d6b5a896e2b4bec3151a4624800cc3729ca2e
getBag
public BagSummaryData getBag()
{    return bag;}
7d707e5db6ffb4a0a82ba4d826d74d30b9c25a827b5f552d2b0b93fb8d33928e
setBag
public void setBag(BagSummaryData bag)
{    this.bag = bag;}
5dd4ca3ade32792ea3e4fe96ad646020db87032c7c25aefe08c0fc9ae93bcda4
getTuple
public TupleSummaryData getTuple()
{    return tuple;}
a225f8b78c229540099e4ca0926f9c61ca55bb9277ac840e4a476a2a17e73acc
setTuple
public void setTuple(TupleSummaryData tuple)
{    this.tuple = tuple;}
31278ba37edea5477c35758a3b02a4f1effa064c2f901a87e5922e0bf42e81c9
getMap
public MapSummaryData getMap()
{    return map;}
582d9070ad13958c6f2ef995b0bad0a4e669ce8b7b330fac85ca184abfcf8dcc
setMap
public void setMap(MapSummaryData map)
{    this.map = map;}
149705379e833ce4f0423a65180dc8278c93b66b77518f593a65538f8e00d7e4
getString
public StringSummaryData getString()
{    return string;}
396991fa30e6636420119c47a27df75ada2a7ef60a6565b3cb73aef5bb8ccfba
setString
public void setString(StringSummaryData string)
{    this.string = string;}
2768b77ed5f678cd026c236d4c49fca6ca25ac6722a0e2415ded619235ac51df
getNumber
public NumberSummaryData getNumber()
{    return number;}
90b0fa37ba86d8d5dc12cbd79958c7480c9351f839251a5dc895f82384e5ece8
setNumber
public void setNumber(NumberSummaryData number)
{    this.number = number;}
2045a0f55a5005b43f6f63a423622e295f382f8894928a924b3a2d2411558127
getNull
public Long getNull()
{    return nullCount == 0 ? null : nullCount;}
e30f6ea4ad00d9bc974c3a6c8485c3248b476f9d6010d8864f27851e8b1540e3
setNull
public void setNull(long nullCnt)
{    this.nullCount = nullCnt;}
82287b21ce06c071f17b2ca144664497dba02aec3b0daf44be505fa68d001b83
getUnknown
public Long getUnknown()
{    return unknown == 0 ? null : unknown;}
37defeb9a7be8fe592a919f8241efc43d35717ca19530563df1cd647c2b3899e
setUnknown
public void setUnknown(long unknown)
{    this.unknown = unknown;}
ab7b795bb21e97b9eaf6a88d12ad25cd7e4559b042ebd972e74753085c5949b3
getError
public Long getError()
{    return error == 0 ? null : error;}
46026e537b64586b060198a6b7e5aa7081a43ec0fb0666e5b1d9f7c68fc9d205
setError
public void setError(long error)
{    this.error = error;}
f498f22eaf0816bf385a43365651d1b6d0455905fdd2d6be01ceefeb84e8f432
setName
public void setName(String name)
{    if (this.name != null && !this.name.equals(name)) {        throw new IllegalStateException("name mismatch " + this.name + " expected, got " + name);    }    this.name = name;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
1a71e0ff18a637f5cf84b7a5f35cc1402fae757682cd606fc8bf65cd55170d4e
add
public void add(Schema schema, Map<?, ?> m)
{    super.add(m);    size.add(m.size());    FieldSchema field = getField(schema, 0);    if (m.size() > 0 && key == null) {        key = new FieldSummaryData();        key.setName(getName(field));        value = new FieldSummaryData();        value.setName(getName(field));    }    for (Map.Entry<?, ?> entry : m.entrySet()) {        key.add(null, entry.getKey());        value.add(getSchema(field), entry.getValue());    }}
d11b54d112f048a4832e72c3244d326ee3ebc44ce056a2fbb72ed9c37fd60dc7
merge
public void merge(SummaryData other)
{    super.merge(other);    MapSummaryData otherMapSummaryData = (MapSummaryData) other;    size.merge(otherMapSummaryData.size);    key = merge(key, otherMapSummaryData.key);    value = merge(value, otherMapSummaryData.value);}
f1e34adaddfb6bbe973793bf0d1ba20928afe0dbc6ff08d21b4ba65a0baef8a7
getKey
public FieldSummaryData getKey()
{    return key;}
dcd61470129b4f18bbcee02e0290874dea75a0f56df01d62262c773c56113e45
setKey
public void setKey(FieldSummaryData key)
{    this.key = key;}
2594cc066f570e9b0d8a7a4dcccc1ca600e0529b6c25539ffaa8ee61c7793a46
getValue
public FieldSummaryData getValue()
{    return value;}
f4cd2dc17d7ca93098b8b37674ea76fdadd0b0e5b6145c48de9a357cd7fcc5c3
setValue
public void setValue(FieldSummaryData value)
{    this.value = value;}
8c2e9693125f8070f83402101b71b6017957221fbfc3238502c69b4338187f29
getSize
public ValueStat getSize()
{    return size;}
a0670ae56488e95069d2ffa81b55f09c7ceceaa574d31542fa89578986709618
setSize
public void setSize(ValueStat size)
{    this.size = size;}
2b8c4fc91dcbb7baa3817b8fa6b1dad64c4f03c1f118f93af710cf9cc24230e5
add
public void add(Number n)
{    super.add(n);    value.add(n.doubleValue());}
d11b54d112f048a4832e72c3244d326ee3ebc44ce056a2fbb72ed9c37fd60dc7
merge
public void merge(SummaryData other)
{    super.merge(other);    value.merge(((NumberSummaryData) other).value);}
8ceef6de81cbab0d5cd0c894fed970c6123afa6f709ef936b3bc06157541a2f4
getValue
public ValueStat getValue()
{    return value;}
1d39b914812dc750af12ab9a51f554ac014246886b39fbfe6b8a4e7171a1b681
setValue
public void setValue(ValueStat value)
{    this.value = value;}
29558b4b888f8c2b5922c52c8d7ee8158579f1ac0f55b640ccde0e379f337c00
add
public void add(String s)
{    super.add(s);    size.add(s.length());    values.add(s);}
d11b54d112f048a4832e72c3244d326ee3ebc44ce056a2fbb72ed9c37fd60dc7
merge
public void merge(SummaryData other)
{    super.merge(other);    StringSummaryData stringSummaryData = (StringSummaryData) other;    size.merge(stringSummaryData.size);    values.merge(stringSummaryData.values);}
8c2e9693125f8070f83402101b71b6017957221fbfc3238502c69b4338187f29
getSize
public ValueStat getSize()
{    return size;}
a0670ae56488e95069d2ffa81b55f09c7ceceaa574d31542fa89578986709618
setSize
public void setSize(ValueStat size)
{    this.size = size;}
9bfadac203adf14129643baf2469b68ddc5e216355d93bdd4b53dbfc226f3de2
getValues
public Collection<EnumValueCount> getValues()
{    Collection<EnumValueCount> values2 = values.getValues();    if (values2 == null) {        return null;    }    List<EnumValueCount> list = new ArrayList<EnumValueCount>(values2);    Collections.sort(list, new Comparator<EnumValueCount>() {        @Override        public int compare(EnumValueCount o1, EnumValueCount o2) {            return o2.getCount() - o1.getCount();        }    });    return list;}
deb52ce80891ace8a99763d57a57f6773ba1d9ae8a9b57658811636a65d87a03
compare
public int compare(EnumValueCount o1, EnumValueCount o2)
{    return o2.getCount() - o1.getCount();}
7fd4c136c8a6ae3f71a412d0e72536e319f3479814d63b19c14b83d9992af4b8
setValues
public void setValues(Collection<EnumValueCount> values)
{    this.values.setValues(values);}
4aa8201a0046147d7c2c7a312a9bafc25ae69e3602285efb4f4920f6eb163f20
exec
public Tuple exec(Tuple t) throws IOException
{    return new JSONTuple(sumUp(getInputSchema(), t));}
4aa8201a0046147d7c2c7a312a9bafc25ae69e3602285efb4f4920f6eb163f20
exec
public Tuple exec(Tuple t) throws IOException
{    return new JSONTuple(merge(t));}
d136a59c79335a541ed2727ecb8c62968d82bd1661d6bf08e32c6c72abeb5dad
exec
public String exec(Tuple t) throws IOException
{    return SummaryData.toPrettyJSON(merge(t));}
c5821d086e99763a45e1e272070fb489eff057889b3aac47dfd41f118d6aecf6
readFields
public void readFields(DataInput dataInput) throws IOException
{    throw new UnsupportedOperationException();}
5493eeee7f85bd6fb70c717b366e2363863946d32d71ebd52274dfb03a86cae5
write
public void write(DataOutput dataOutput) throws IOException
{    Tuple t = TF.newTuple(json());    t.write(dataOutput);}
b2157c07dc6fb4a64fa62a31c6a9e6b1b71280f63d43dcb8b93501e7dddcbbf7
compareTo
public int compareTo(Object o)
{    throw new UnsupportedOperationException();}
12f84fabd752c7c3a2ee4c7aac44a29c020370b70bbed2a0192a667a938bbfe5
append
public void append(Object o)
{    throw new UnsupportedOperationException();}
1c96d7df9f91125d415abeb23dded41a807e83df87e4cc06d41a6f09ed5897d8
get
public Object get(int i) throws ExecException
{    if (i == 0) {        return json();    }    throw new ExecException();}
fbc3cf4eb4f9433d353109ff3d2b41d7bd7d3941b8b544335caf387c95280c86
json
private String json()
{    return SummaryData.toJSON(data);}
c04ca3f1d8306700df0e72a06c0aa79fae2d6082b1bc2255225d6d897f5b9fe6
getAll
public List<Object> getAll()
{    return new ArrayList<Object>(Arrays.asList(json()));}
2013bbeca8f33c421cb6077facf5cba7804fe7d0e5ddcfdf51951883c74e8ca8
getMemorySize
public long getMemorySize()
{        return 100;}
c88921bbf8533d0ffeeeda6dc8c7c4561123823f4ff74147bf09e38ee2e1f8a7
getType
public byte getType(int i) throws ExecException
{    if (i == 0) {        return DataType.CHARARRAY;    }    throw new ExecException("size is 1");}
0ae172310ca7e880b03fbef5d0b931573a135037a0eebe593956432bfded2ef1
isNull
public boolean isNull(int i) throws ExecException
{    if (i == 0) {        return false;    }    throw new ExecException("size is 1");}
458ddc763c761e0f53d2861435bab5883323474c21361e0324fea7860b6566a4
reference
public void reference(Tuple t)
{    throw new UnsupportedOperationException();}
e8c7c21bc697dd4982855181e332998e24c5c612623c2c6dbacbddef92504a17
set
public void set(int i, Object o) throws ExecException
{    throw new UnsupportedOperationException();}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return 1;}
56b9cf3ca79483e6b39257f413d787cebb6a9cf1240b4c832309eafaf13ba2a7
toDelimitedString
public String toDelimitedString(String delim) throws ExecException
{    return json();}
9b6f1738b73576e5dd727082e75be93d01a1de9cbbbfe3775e151380b303762a
iterator
public Iterator<Object> iterator()
{    return getAll().iterator();}
a2dec216002648bf4249dadd7e8fd9378cd1dfc83289560c5a589e5bdefded36
getData
private static TupleSummaryData getData(Tuple tuple) throws ExecException
{    if (tuple instanceof JSONTuple) {        return ((JSONTuple) tuple).data;    } else {        return SummaryData.fromJSON((String) tuple.get(0), TupleSummaryData.class);    }}
dee04554c0ccf3af3d8dd2810ddad0b7bc6ad513ebc6dcd52c9531235267c2c6
merge
private static TupleSummaryData merge(Tuple t) throws IOException
{    TupleSummaryData summaryData = new TupleSummaryData();    DataBag bag = (DataBag) t.get(0);    for (Tuple tuple : bag) {        summaryData.merge(getData(tuple));    }    return summaryData;}
c6d25bbe749d0ca10b60a350fe16c79fcf379232c3bee67b8572ceae3af4f950
sumUp
private static TupleSummaryData sumUp(Schema schema, Tuple t) throws ExecException
{    TupleSummaryData summaryData = new TupleSummaryData();    DataBag bag = (DataBag) t.get(0);    for (Tuple tuple : bag) {        summaryData.addTuple(schema, tuple);    }    return summaryData;}
d136a59c79335a541ed2727ecb8c62968d82bd1661d6bf08e32c6c72abeb5dad
exec
public String exec(Tuple t) throws IOException
{    return SummaryData.toPrettyJSON(sumUp(getInputSchema(), t));}
01e483a427827daad0b14b2c1f49f688f3690a9ad7cd1dc4d1c486c4e5d92fb6
getInitial
public String getInitial()
{    return Initial.class.getName();}
5c69f7c5b3e0cb8359c50114a52367ed04deb81cf8b1c2613dd3d6ae4497c187
getIntermed
public String getIntermed()
{    return Intermediate.class.getName();}
df0ed8a8a48aadf75436930b9ffaec8ba4a3efd72fd69719b0299d5ef2b27dc5
getFinal
public String getFinal()
{    return Final.class.getName();}
370cbeea170997e254f855c177342748c5c68c7b1a47c0d96bc0b5eeb3c00912
toJSON
public static String toJSON(SummaryData summaryData)
{    return toJSON(summaryData, objectMapper);}
8f495541f9c157b63d16be1d1876dcf4d3d8de69565781c861997dec3ac64b83
toPrettyJSON
public static String toPrettyJSON(SummaryData summaryData)
{    return toJSON(summaryData, prettyObjectMapper);}
6b2d64d927fdc5eff5d12a72dc101bd31e4f5c5b661c827b5fd39f321ec4ceba
toJSON
private static String toJSON(SummaryData summaryData, ObjectMapper mapper)
{    StringWriter stringWriter = new StringWriter();    try {        mapper.writeValue(stringWriter, summaryData);    } catch (JsonGenerationException e) {        throw new RuntimeException(e);    } catch (JsonMappingException e) {        throw new RuntimeException(e);    } catch (IOException e) {        throw new RuntimeException(e);    }    return stringWriter.toString();}
5aa310dd07be9104eb0573f4e857d2b58d7feaa90011d406e00d2b3d2e83776c
fromJSON
public static T fromJSON(String json, Class<T> clazz)
{    try {        return objectMapper.readValue(new StringReader(json), clazz);    } catch (JsonParseException e) {        throw new RuntimeException(e);    } catch (JsonMappingException e) {        throw new RuntimeException(e);    } catch (IOException e) {        throw new RuntimeException(e);    }}
c938385261ee64bec55e2c3566ca588ec092738c22d572f89281c29bca68c71a
merge
public static T merge(T s1, T s2)
{    if (s1 == null) {        return s2;    } else if (s2 == null) {        return s1;    } else {        s1.merge(s2);        return s1;    }}
f161d159463266afc7d1507be7a68b5f244068f709d711528fc5f15e199e2eab
getField
protected FieldSchema getField(Schema schema, int i)
{    try {        if (schema == null || i >= schema.size()) {            return null;        }        FieldSchema field = schema.getField(i);        return field;    } catch (FrontendException e) {        throw new RuntimeException(e);    }}
20d5747f9427382da48e046d1ed1e2516e17885087bfd41cc921c534c2daad1d
getSchema
protected Schema getSchema(FieldSchema field)
{    return field == null ? null : field.schema;}
9e21d2ad389807129776e822f7435a075f4a28b19c8132b6e8df8cc5507ba23b
getName
protected String getName(FieldSchema field)
{    return field == null ? null : field.alias;}
066c384104408c232bd3230882be13302da1620eee84cc612437bc6ccef5f7b5
add
public void add(Object o)
{    ++count;}
d11b54d112f048a4832e72c3244d326ee3ebc44ce056a2fbb72ed9c37fd60dc7
merge
public void merge(SummaryData other)
{    this.count += other.count;}
4bf990342727536109cd77a29149345256f33b328f596b96f11cb4f2c9906922
getCount
public long getCount()
{    return count;}
25abd6e59a06f477e2012ef9de7a6c2053cb117f004e28ef2f133c1aff1103f0
setCount
public void setCount(long count)
{    this.count = count;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return toJSON(this);}
900c269d27b03ffc249876305993bd3e1ac7cb053575de8ddfcad795ca555fa3
addTuple
public void addTuple(Schema schema, Tuple tuple)
{    super.add(tuple);    int tupleSize = tuple.size();    size.add(tupleSize);    ensureSize(tupleSize);    for (int i = 0; i < tupleSize; i++) {        FieldSummaryData fieldSummaryData = fields.get(i);        try {            FieldSchema field = getField(schema, i);            fieldSummaryData.setName(getName(field));            Object o = tuple.get(i);            fieldSummaryData.add(getSchema(field), o);        } catch (ExecException e) {            LOG.log(Level.WARNING, "Can't get value from tuple", e);            fieldSummaryData.addError();        }    }}
2a2e44d2d7d9d42929683a3ec8913dd44f6600fa97cbe82b1622b9803b2135f2
ensureSize
private void ensureSize(int sizeToEnsure)
{    while (fields.size() < sizeToEnsure) {        fields.add(new FieldSummaryData());    }}
d11b54d112f048a4832e72c3244d326ee3ebc44ce056a2fbb72ed9c37fd60dc7
merge
public void merge(SummaryData other)
{    super.merge(other);    TupleSummaryData otherTupleSummaryData = (TupleSummaryData) other;    size.merge(otherTupleSummaryData.size);    ensureSize(otherTupleSummaryData.fields.size());    for (int i = 0; i < otherTupleSummaryData.fields.size(); i++) {        fields.get(i).merge(otherTupleSummaryData.fields.get(i));    }}
40225140da125d0d2b4a89a885c34ab860ed0ac5b771c3e5f073e44f3902139e
getFields
public List<FieldSummaryData> getFields()
{    return fields;}
1042487ba8fe038fe849204405b60b4d8e9832f356c6a2cc5fd5483a78a27269
setFields
public void setFields(List<FieldSummaryData> fields)
{    this.fields = fields;}
8c2e9693125f8070f83402101b71b6017957221fbfc3238502c69b4338187f29
getSize
public ValueStat getSize()
{    return size;}
a0670ae56488e95069d2ffa81b55f09c7ceceaa574d31542fa89578986709618
setSize
public void setSize(ValueStat size)
{    this.size = size;}
03a2ba080ca00424a0ab833f80b2598d048ca83a283f759933a47b5c4faa612f
add
public void add(double v)
{    total += v;    min = Math.min(min, v);    max = Math.max(max, v);}
3c97f77598b1ad49ea1caaa64b6797938a14ef75ddf03b4ca0620067c935a35b
merge
public void merge(ValueStat other)
{    total += other.total;    min = Math.min(min, other.min);    max = Math.max(max, other.max);}
b52a50ca760d26710ec4de4e396ee6dc7c471d05dbf3e545d57d281cff9c2b02
getTotal
public double getTotal()
{    return total;}
01afd71cc797aa4a9abffb03c712f67e6dc0800ce33abd2842e3551e0633057f
setTotal
public void setTotal(double total)
{    this.total = total;}
028aeafab053f5bceceab90c3393687fa7a23c1f765b70af7a1a78527c825869
getMin
public double getMin()
{    return min;}
1a2f0bda5e0f2f0a3a35bf854bd6c27169dcac8fc85843499303df0b273250a1
setMin
public void setMin(double min)
{    this.min = min;}
344768211b8524396497604faa40c0faf07104b2ac1129fe45998a40221da827
getMax
public double getMax()
{    return max;}
ddcaebf8e067da8732d67f41052ab2e8aeafb3a0be059e47de720d315f9c229a
setMax
public void setMax(double max)
{    this.max = max;}
291948ede9d3ada7042686f039c72c6d56e51b28a3f34844b5749706d496b444
getPigSchema
 static Schema getPigSchema(Configuration configuration)
{    return parsePigSchema(configuration.get(PARQUET_PIG_SCHEMA));}
db337421464a140e069decb5c7ccfbacd893127f06346610662ba9bd307ca5f0
getRequiredFields
 static RequiredFieldList getRequiredFields(Configuration configuration)
{    String requiredFieldString = configuration.get(PARQUET_PIG_REQUIRED_FIELDS);    if (requiredFieldString == null) {        return null;    }    try {        return (RequiredFieldList) ObjectSerializer.deserialize(requiredFieldString);    } catch (IOException iOException) {        throw new RuntimeException("Failed to deserialize pushProjection");    }}
47e05fa30e4f6a0fdd9e18a6924ad1735c6dc1e8ac9bae9b3c6ac48c750d843f
getPigSchemaFromMultipleFiles
 static Schema getPigSchemaFromMultipleFiles(MessageType fileSchema, Map<String, Set<String>> keyValueMetaData)
{    Set<String> pigSchemas = PigMetaData.getPigSchemas(keyValueMetaData);    if (pigSchemas == null) {        return pigSchemaConverter.convert(fileSchema);    }    Schema mergedPigSchema = null;    for (String pigSchemaString : pigSchemas) {        try {            mergedPigSchema = union(mergedPigSchema, parsePigSchema(pigSchemaString));        } catch (FrontendException e) {            throw new ParquetDecodingException("can not merge " + pigSchemaString + " into " + mergedPigSchema, e);        }    }    return mergedPigSchema;}
04c0c2fe76474ba85f6ba72ba8757f7bcc8e9409a55aba441e2b6e6740aaee13
getPigSchemaFromFile
 static Schema getPigSchemaFromFile(MessageType fileSchema, Map<String, String> keyValueMetaData)
{    PigMetaData pigMetaData = PigMetaData.fromMetaData(keyValueMetaData);    if (pigMetaData == null) {        return pigSchemaConverter.convert(fileSchema);    }    return parsePigSchema(pigMetaData.getPigSchema());}
fe35c63a1b1fa0d0a0de8137ff50dca7bbc829180a3ee6e959ed97e3c7d03a2f
union
private static Schema union(Schema merged, Schema pigSchema) throws FrontendException
{    List<FieldSchema> fields = new ArrayList<Schema.FieldSchema>();    if (merged == null) {        return pigSchema;    }        for (FieldSchema fieldSchema : merged.getFields()) {        FieldSchema newFieldSchema = pigSchema.getField(fieldSchema.alias);        if (newFieldSchema == null) {            fields.add(fieldSchema);        } else {            fields.add(union(fieldSchema, newFieldSchema));        }    }        for (FieldSchema newFieldSchema : pigSchema.getFields()) {        FieldSchema oldFieldSchema = merged.getField(newFieldSchema.alias);        if (oldFieldSchema == null) {            fields.add(newFieldSchema);        }    }    return new Schema(fields);}
82c86a48a65d6fa5a95f9d2e6e7d62cbe2edd65e1d90b622d626b8e60d740126
union
private static FieldSchema union(FieldSchema mergedFieldSchema, FieldSchema newFieldSchema)
{    if (!mergedFieldSchema.alias.equals(newFieldSchema.alias) || mergedFieldSchema.type != newFieldSchema.type) {        throw new IncompatibleSchemaModificationException("Incompatible Pig schema change: " + mergedFieldSchema + " can not accept");    }    try {        return new FieldSchema(mergedFieldSchema.alias, union(mergedFieldSchema.schema, newFieldSchema.schema), mergedFieldSchema.type);    } catch (FrontendException e) {        throw new SchemaConversionException(e);    }}
bad940abad6e88ea6899619a020634d29009b4350fed1b0eaacdc6f7d4eee05e
init
public ReadContext init(InitContext initContext)
{    Schema pigSchema = getPigSchema(initContext.getConfiguration());    RequiredFieldList requiredFields = getRequiredFields(initContext.getConfiguration());    boolean columnIndexAccess = initContext.getConfiguration().getBoolean(PARQUET_COLUMN_INDEX_ACCESS, false);    if (pigSchema == null) {        return new ReadContext(initContext.getFileSchema());    } else {                MessageType parquetRequestedSchema = new PigSchemaConverter(columnIndexAccess).filter(initContext.getFileSchema(), pigSchema, requiredFields);        return new ReadContext(parquetRequestedSchema);    }}
2ccc017acce6dd815e6be342b8fcd102a893ed79a7d490b11b70a9c7e1ca3783
prepareForRead
public RecordMaterializer<Tuple> prepareForRead(Configuration configuration, Map<String, String> keyValueMetaData, MessageType fileSchema, ReadContext readContext)
{    MessageType requestedSchema = readContext.getRequestedSchema();    Schema requestedPigSchema = getPigSchema(configuration);    if (requestedPigSchema == null) {        throw new ParquetDecodingException("Missing Pig schema: ParquetLoader sets the schema in the job conf");    }    boolean elephantBirdCompatible = configuration.getBoolean(PARQUET_PIG_ELEPHANT_BIRD_COMPATIBLE, false);    boolean columnIndexAccess = configuration.getBoolean(PARQUET_COLUMN_INDEX_ACCESS, false);    if (elephantBirdCompatible) {        LOG.info("Numbers will default to 0 instead of NULL; Boolean will be converted to Int");    }    return new TupleRecordMaterializer(requestedSchema, requestedPigSchema, elephantBirdCompatible, columnIndexAccess);}
7ae1ceee54c15f98a8ddf00419222fcc3301231eef989a1fbf4f48eebf5a4a9e
fromPigSchema
public static TupleWriteSupport fromPigSchema(String pigSchemaString) throws ParserException
{    return new TupleWriteSupport(Utils.getSchemaFromString(pigSchemaString));}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "pig";}
c011ea84092c6e7f046225ccb4399c143e7715ef845e5851953c4b44614315d9
getPigSchema
public Schema getPigSchema()
{    return rootPigSchema;}
402985b743b3df9324cd38caa927e2b35d4bad5c597416ef77e1b95ca697c822
getParquetSchema
public MessageType getParquetSchema()
{    return rootSchema;}
89835da140a91d5cb5181a85b8db073a92d794e99966f7422502dbb7d5467b7c
init
public WriteContext init(Configuration configuration)
{    Map<String, String> extraMetaData = new HashMap<String, String>();    new PigMetaData(rootPigSchema).addToMetaData(extraMetaData);    return new WriteContext(rootSchema, extraMetaData);}
da9aef78cf181856102b820ffa7d5248e8581747b3f0670a7b049c4649b962ef
prepareForWrite
public void prepareForWrite(RecordConsumer recordConsumer)
{    this.recordConsumer = recordConsumer;}
1a245295cca086796377661dbb49e97c83e96dde3c08303ff16317854ecb70d2
write
public void write(Tuple t)
{    try {        recordConsumer.startMessage();        writeTuple(rootSchema, rootPigSchema, t);        recordConsumer.endMessage();    } catch (ExecException e) {        throw new RuntimeException(e);    } catch (FrontendException e) {        throw new RuntimeException(e);    }}
d58393de3755260e9a2f2a6b438ed830dae386cf2f6ec196b76bf233bfd23d01
writeTuple
private void writeTuple(GroupType schema, Schema pigSchema, Tuple t) throws ExecException, FrontendException
{    List<Type> fields = schema.getFields();    List<FieldSchema> pigFields = pigSchema.getFields();    assert fields.size() == pigFields.size();    for (int i = 0; i < fields.size(); i++) {        if (t.isNull(i)) {            continue;        }        Type fieldType = fields.get(i);        recordConsumer.startField(fieldType.getName(), i);        FieldSchema pigType = pigFields.get(i);        switch(pigType.type) {            case DataType.BAG:                Type bagType = fieldType.asGroupType().getType(0);                FieldSchema pigBagInnerType = pigType.schema.getField(0);                DataBag bag = (DataBag) t.get(i);                recordConsumer.startGroup();                if (bag.size() > 0) {                    recordConsumer.startField(bagType.getName(), 0);                    for (Tuple tuple : bag) {                        if (bagType.isPrimitive()) {                            writeValue(bagType, pigBagInnerType, tuple, 0);                        } else {                            recordConsumer.startGroup();                            writeTuple(bagType.asGroupType(), pigBagInnerType.schema, tuple);                            recordConsumer.endGroup();                        }                    }                    recordConsumer.endField(bagType.getName(), 0);                }                recordConsumer.endGroup();                break;            case DataType.MAP:                Type mapType = fieldType.asGroupType().getType(0);                FieldSchema pigMapInnerType = pigType.schema.getField(0);                                @SuppressWarnings("unchecked")                Map<String, Object> map = (Map<String, Object>) t.get(i);                recordConsumer.startGroup();                if (map.size() > 0) {                    recordConsumer.startField(mapType.getName(), 0);                    Set<Entry<String, Object>> entrySet = map.entrySet();                    for (Entry<String, Object> entry : entrySet) {                        recordConsumer.startGroup();                        Schema keyValueSchema = new Schema(Arrays.asList(new FieldSchema("key", DataType.CHARARRAY), new FieldSchema("value", pigMapInnerType.schema, pigMapInnerType.type)));                        writeTuple(mapType.asGroupType(), keyValueSchema, TF.newTuple(Arrays.asList(entry.getKey(), entry.getValue())));                        recordConsumer.endGroup();                    }                    recordConsumer.endField(mapType.getName(), 0);                }                recordConsumer.endGroup();                break;            default:                writeValue(fieldType, pigType, t, i);                break;        }        recordConsumer.endField(fieldType.getName(), i);    }}
477164081d4c39f4ed147b6834d0622e7b4e8702d1b4cdc100ce5384b4a634b9
writeValue
private void writeValue(Type type, FieldSchema pigType, Tuple t, int i)
{    try {        if (type.isPrimitive()) {            switch(type.asPrimitiveType().getPrimitiveTypeName()) {                                case BINARY:                    byte[] bytes;                    if (pigType.type == DataType.BYTEARRAY) {                        bytes = ((DataByteArray) t.get(i)).get();                    } else if (pigType.type == DataType.CHARARRAY) {                        bytes = ((String) t.get(i)).getBytes("UTF-8");                    } else {                        throw new UnsupportedOperationException("can not convert from " + DataType.findTypeName(pigType.type) + " to BINARY ");                    }                    recordConsumer.addBinary(Binary.fromReusedByteArray(bytes));                    break;                case BOOLEAN:                    recordConsumer.addBoolean((Boolean) t.get(i));                    break;                case INT32:                    recordConsumer.addInteger(((Number) t.get(i)).intValue());                    break;                case INT64:                    recordConsumer.addLong(((Number) t.get(i)).longValue());                    break;                case DOUBLE:                    recordConsumer.addDouble(((Number) t.get(i)).doubleValue());                    break;                case FLOAT:                    recordConsumer.addFloat(((Number) t.get(i)).floatValue());                    break;                default:                    throw new UnsupportedOperationException(type.asPrimitiveType().getPrimitiveTypeName().name());            }        } else {            assert pigType.type == DataType.TUPLE;            recordConsumer.startGroup();            writeTuple(type.asGroupType(), pigType.schema, (Tuple) t.get(i));            recordConsumer.endGroup();        }    } catch (Exception e) {        throw new ParquetEncodingException("can not write value at " + i + " in tuple " + t + " from type '" + pigType + "' to type '" + type + "'", e);    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    StringBuilder schemaString = new StringBuilder("a0: chararray");    for (int i = 1; i < COLUMN_COUNT; i++) {        schemaString.append(", a" + i + ": chararray");    }    String out = "target/PerfTest";    {        PigServer pigServer = new PigServer(ExecType.LOCAL);        Data data = Storage.resetData(pigServer);        Collection<Tuple> list = new ArrayList<Tuple>();        for (int i = 0; i < ROW_COUNT; i++) {            Tuple tuple = TupleFactory.getInstance().newTuple(COLUMN_COUNT);            for (int j = 0; j < COLUMN_COUNT; j++) {                tuple.set(j, "a" + i + "_" + j);            }            list.add(tuple);        }        data.set("in", schemaString.toString(), list);        pigServer.setBatchOn();        pigServer.registerQuery("A = LOAD 'in' USING mock.Storage();");        pigServer.deleteFile(out);        pigServer.registerQuery("Store A into '" + out + "' using " + ParquetStorer.class.getName() + "();");        if (pigServer.executeBatch().get(0).getStatus() != JOB_STATUS.COMPLETED) {            throw new RuntimeException("Job failed", pigServer.executeBatch().get(0).getException());        }    }    load(out, 1);    load(out, 2);    load(out, 3);    load(out, 4);    load(out, 5);    load(out, 10);    load(out, 20);    load(out, 50);    System.out.println(results);}
967685e094a56c47c54069b9284a5dbe6ff07c5f976e3724ef571616001d602d
load
private static void load(String out, int colsToLoad) throws ExecException, IOException
{    long t0 = System.currentTimeMillis();    StringBuilder schemaString = new StringBuilder("a0: chararray");    for (int i = 1; i < colsToLoad; i++) {        schemaString.append(", a" + i + ": chararray");    }    PigServer pigServer = new PigServer(ExecType.LOCAL);    pigServer.registerQuery("B = LOAD '" + out + "' USING " + ParquetLoader.class.getName() + "('" + schemaString + "');");    pigServer.registerQuery("C = FOREACH (GROUP B ALL) GENERATE COUNT(B);");    Iterator<Tuple> it = pigServer.openIterator("C");    if (!it.hasNext()) {        throw new RuntimeException("Job failed: no tuple to read");    }    Long count = (Long) it.next().get(0);    assertEquals(ROW_COUNT, count.longValue());    long t1 = System.currentTimeMillis();    results.append((t1 - t0) + " ms to read " + colsToLoad + " columns\n");}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    StringBuilder results = new StringBuilder();    String out = "target/PerfTest2";    File outDir = new File(out);    if (outDir.exists()) {        clean(outDir);    }    write(out);    for (int i = 0; i < 2; i++) {        load(out, 1, results);        load(out, 2, results);        load(out, 3, results);        load(out, 4, results);        load(out, 5, results);        load(out, 10, results);        load(out, 20, results);        load(out, 50, results);        results.append("\n");    }    System.out.println(results);}
ad9e79267ff88291ad3efcdd59047b6b6a41479e243ed739d67dd840e6b7dc07
write
public static void write(String out) throws IOException, ParserException, InterruptedException, ExecException
{    {        StringBuilder schemaString = new StringBuilder("a0: chararray");        for (int i = 1; i < COLUMN_COUNT; i++) {            schemaString.append(", a" + i + ": chararray");        }        String location = out;        String schema = schemaString.toString();        StoreFuncInterface storer = new ParquetStorer();        Job job = new Job(conf);        storer.setStoreFuncUDFContextSignature("sig");        String absPath = storer.relToAbsPathForStoreLocation(location, new Path(new File(".").getAbsoluteFile().toURI()));        storer.setStoreLocation(absPath, job);        storer.checkSchema(new ResourceSchema(Utils.getSchemaFromString(schema)));                @SuppressWarnings("unchecked")        OutputFormat<Void, Tuple> outputFormat = storer.getOutputFormat();                JobContext jobContext = ContextUtil.newJobContext(ContextUtil.getConfiguration(job), new JobID("jt", jobid++));        outputFormat.checkOutputSpecs(jobContext);        if (schema != null) {            ResourceSchema resourceSchema = new ResourceSchema(Utils.getSchemaFromString(schema));            storer.checkSchema(resourceSchema);            if (storer instanceof StoreMetadata) {                ((StoreMetadata) storer).storeSchema(resourceSchema, absPath, job);            }        }        TaskAttemptContext taskAttemptContext = ContextUtil.newTaskAttemptContext(ContextUtil.getConfiguration(job), new TaskAttemptID("jt", jobid, true, 1, 0));        RecordWriter<Void, Tuple> recordWriter = outputFormat.getRecordWriter(taskAttemptContext);        storer.prepareToWrite(recordWriter);        for (int i = 0; i < ROW_COUNT; i++) {            Tuple tuple = TupleFactory.getInstance().newTuple(COLUMN_COUNT);            for (int j = 0; j < COLUMN_COUNT; j++) {                tuple.set(j, "a" + i + "_" + j);            }            storer.putNext(tuple);        }        recordWriter.close(taskAttemptContext);        OutputCommitter outputCommitter = outputFormat.getOutputCommitter(taskAttemptContext);        outputCommitter.commitTask(taskAttemptContext);        outputCommitter.commitJob(jobContext);    }}
d1476af5851d48024ea91ae31c489294e72c80326330150a1bd455a9ebbff3ed
clean
 static void clean(File outDir)
{    if (outDir.isDirectory()) {        File[] listFiles = outDir.listFiles();        for (File file : listFiles) {            clean(file);        }    }    outDir.delete();}
caaa926d99800ee233b4bc77282ae8cfd0e6351db21c2e140d481e5be000fedd
load
 static void load(String out, int colsToLoad, StringBuilder results) throws Exception
{    StringBuilder schemaString = new StringBuilder("a0: chararray");    for (int i = 1; i < colsToLoad; i++) {        schemaString.append(", a" + i + ": chararray");    }    long t0 = System.currentTimeMillis();    Job job = new Job(conf);    int loadjobId = jobid++;    LoadFunc loadFunc = new ParquetLoader(schemaString.toString());    loadFunc.setUDFContextSignature("sigLoader" + loadjobId);    String absPath = loadFunc.relativeToAbsolutePath(out, new Path(new File(".").getAbsoluteFile().toURI()));    loadFunc.setLocation(absPath, job);        @SuppressWarnings("unchecked")    InputFormat<Void, Tuple> inputFormat = loadFunc.getInputFormat();    JobContext jobContext = ContextUtil.newJobContext(ContextUtil.getConfiguration(job), new JobID("jt", loadjobId));    List<InputSplit> splits = inputFormat.getSplits(jobContext);    int i = 0;    int taskid = 0;    for (InputSplit split : splits) {        TaskAttemptContext taskAttemptContext = ContextUtil.newTaskAttemptContext(ContextUtil.getConfiguration(job), new TaskAttemptID("jt", loadjobId, true, taskid++, 0));        RecordReader<Void, Tuple> recordReader = inputFormat.createRecordReader(split, taskAttemptContext);        loadFunc.prepareToRead(recordReader, null);        recordReader.initialize(split, taskAttemptContext);        Tuple t;        while ((t = loadFunc.getNext()) != null) {            if (DEBUG)                System.out.println(t);            ++i;        }    }    assertEquals(ROW_COUNT, i);    long t1 = System.currentTimeMillis();    results.append((t1 - t0) + " ms to read " + colsToLoad + " columns\n");}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    StringBuilder results = new StringBuilder();    String out = "target/PerfTestReadAllCols";    File outDir = new File(out);    if (outDir.exists()) {        PerfTest2.clean(outDir);    }    PerfTest2.write(out);    for (int i = 0; i < 5; i++) {        PerfTest2.load(out, PerfTest2.COLUMN_COUNT, results);        results.append("\n");    }    System.out.println(results);}
b3f65446462935f6431731450633560d58b0e994aaa9f3c7d9b4cbbcc04d103b
t
public static Tuple t(Object... objects)
{    return tf.newTuple(Arrays.asList(objects));}
bec431e14fd692b5d3e7ffd18d9da2aa0c90cd9a3fb98e4611711b560f82ac5b
b
public static DataBag b(Tuple... tuples)
{    return bf.newDefaultBag(Arrays.asList(tuples));}
796e2ddd04a59eaed9736efbad517c41d8e6eab58732ac3e0fc98dba1d926ae6
m
public static Map<String, Object> m(Object... objects)
{    Map<String, Object> m = new HashMap<String, Object>();    for (int i = 0; i < objects.length; i += 2) {        m.put((String) objects[i], objects[i + 1]);    }    return m;}
3cda579e3356900c022b283c839dcb38281ec7d29ce0c79395db4ab18f6c924e
testEvalFunc
public void testEvalFunc() throws IOException
{    Summary summary = new Summary();    String result = summary.exec(t(TEST_BAG));    validate(result, 1);}
76f68304d92161bb773d840ab49b028e25cb959226ea9c4a5897edbece75bc74
testAlgebraic
public void testAlgebraic() throws IOException
{    Summary.Initial initial = new Summary.Initial();    Summary.Intermediate intermediate1 = new Summary.Intermediate();    Summary.Intermediate intermediate2 = new Summary.Intermediate();    Summary.Final finall = new Summary.Final();    DataBag combinedRedIn = bf.newDefaultBag();    for (int r = 0; r < 5; r++) {        DataBag combinedMapOut = bf.newDefaultBag();        for (int m = 0; m < 5; m++) {            DataBag mapOut = bf.newDefaultBag();            for (Tuple t : TEST_BAG) {                Tuple exec = initial.exec(t(b(t)));                mapOut.add(exec);            }            Tuple exec = intermediate1.exec(t(mapOut));            validate((String) exec.get(0), 1);            combinedMapOut.add(exec);        }        combinedRedIn.add(intermediate2.exec(t(combinedMapOut)));    }    String result = finall.exec(t(combinedRedIn));    validate(result, 5 * 5);}
0697d336270f7e46109c6307a38ba853dd80183b1908407b7c93d7e3a8b0295e
validate
private void validate(String result, int factor) throws IOException
{    TupleSummaryData s = SummaryData.fromJSON(result, TupleSummaryData.class);        assertEquals(9 * factor, s.getCount());    assertEquals(1 * factor, s.getFields().get(0).getNull().longValue());    assertEquals(7 * factor, s.getFields().get(0).getBag().getCount());    assertEquals(18 * factor, s.getFields().get(0).getBag().getContent().getTuple().getFields().get(0).getCount());    MapSummaryData map = s.getFields().get(0).getBag().getContent().getTuple().getFields().get(1).getMap();    assertEquals(2 * factor, map.getCount());    assertEquals(3 * factor, map.getKey().getCount());}
acc79e1ad5423329ef7f2540cb51765acf7e77c1877509340323967ff86d3bcc
testPigScript
public void testPigScript() throws Exception
{    PigServer pigServer = new PigServer(ExecType.LOCAL);    Data data = Storage.resetData(pigServer);    List<Tuple> list = new ArrayList<Tuple>();    for (int i = 0; i < 1002; i++) {        list.add(t("a", "b" + i, 1l, b(t("a", m("foo", "bar")))));    }    data.set("in", "a:chararray, a1:chararray, b:int, c:{t:(a2:chararray, b2:[])}", list);    pigServer.registerQuery("A = LOAD 'in' USING mock.Storage();");    pigServer.registerQuery("B = FOREACH (GROUP A ALL) GENERATE " + Summary.class.getName() + "(A);");    pigServer.registerQuery("STORE B INTO 'out' USING mock.Storage();");    System.out.println(data.get("out").get(0).get(0));    TupleSummaryData s = SummaryData.fromJSON((String) data.get("out").get(0).get(0), TupleSummaryData.class);    System.out.println(s);}
c6e08c6a8bdf75a6cb68bda1d9e5254308a6d6a326029a203332013ee1ac37b0
testMaxIsZero
public void testMaxIsZero() throws Exception
{    PigServer pigServer = new PigServer(ExecType.LOCAL);    Data data = Storage.resetData(pigServer);    List<Tuple> list = new ArrayList<Tuple>();    for (int i = 0; i < 10; i++) {        list.add(t("a", i - 9));    }    data.set("in", "a:chararray, b:int", list);    pigServer.registerQuery("A = LOAD 'in' USING mock.Storage();");    pigServer.registerQuery("B = FOREACH (GROUP A ALL) GENERATE " + Summary.class.getName() + "(A);");    pigServer.registerQuery("STORE B INTO 'out' USING mock.Storage();");    TupleSummaryData s = SummaryData.fromJSON((String) data.get("out").get(0).get(0), TupleSummaryData.class);    System.out.println(s);    assertEquals(0, s.getFields().get(1).getNumber().getValue().getMax(), 0);}
2a451bf56ea28be690421fd386c0ab7baaa7dca36bddf1bfeef2cf59f3c2c15b
testDecimalConversion
private void testDecimalConversion(double value, int precision, int scale, String stringValue)
{    String originalString = Double.toString(value);    BigDecimal originalValue = new BigDecimal(originalString);    BigDecimal convertedValue = DecimalUtils.binaryToDecimal(Binary.fromByteArray(originalValue.unscaledValue().toByteArray()), precision, scale);    assertEquals(stringValue, convertedValue.toString());}
203b5f7b0d20f75b8424741b33f628142b3899babfc8b2042346b5fb53a76049
testDecimalConversion
private void testDecimalConversion(int value, int precision, int scale, String stringValue)
{    String originalString = Integer.toString(value);    BigDecimal originalValue = new BigDecimal(originalString);    BigDecimal convertedValue = DecimalUtils.binaryToDecimal(Binary.fromByteArray(originalValue.unscaledValue().toByteArray()), precision, scale);    assertEquals(stringValue, convertedValue.toString());}
62f895f20524ae8e1304c56a6bf41c1b12cf3b11e45c93298e0e3f9542b96c57
testDecimalConversion
private void testDecimalConversion(long value, int precision, int scale, String stringValue)
{    String originalString = Long.toString(value);    BigDecimal originalValue = new BigDecimal(originalString);    BigDecimal convertedValue = DecimalUtils.binaryToDecimal(Binary.fromByteArray(originalValue.unscaledValue().toByteArray()), precision, scale);    assertEquals(stringValue, convertedValue.toString());}
c55d753c7a82a45250b3bbccfd21eaef4e67d79e203f411142a88c34ab0a085c
testBinaryToDecimal
public void testBinaryToDecimal() throws Exception
{                testDecimalConversion(Long.MAX_VALUE, 19, 0, "9223372036854775807");    testDecimalConversion(Long.MIN_VALUE, 19, 0, "-9223372036854775808");    testDecimalConversion(0L, 0, 0, "0.0");        testDecimalConversion(Integer.MAX_VALUE, 10, 0, "2147483647");    testDecimalConversion(Integer.MIN_VALUE, 10, 0, "-2147483648");    testDecimalConversion(0, 0, 0, "0.0");        testDecimalConversion(12345678912345678d, 17, 0, "12345678912345678");    testDecimalConversion(123456789123456.78, 17, 2, "123456789123456.78");    testDecimalConversion(0.12345678912345678, 17, 17, "0.12345678912345678");    testDecimalConversion(-0.000102, 6, 6, "-0.000102");}
5120131afe63ee665544c15b0b36cdf6d81341b69c6516740426e0b1d157f762
testSchema
public void testSchema() throws Exception
{    String location = "garbage";    ParquetLoader pLoader = new ParquetLoader("a:chararray, " + "b:{t:(c:chararray, d:chararray)}, " + "p:[(q:chararray, r:chararray)]");    Job job = new Job();    pLoader.getSchema(location, job);    RequiredFieldList list = new RequiredFieldList();    RequiredField field = new RequiredField("a", 0, null, DataType.CHARARRAY);    list.add(field);    field = new RequiredField("b", 0, Arrays.asList(new RequiredField("t", 0, Arrays.asList(new RequiredField("d", 1, null, DataType.CHARARRAY)), DataType.TUPLE)), DataType.BAG);    list.add(field);    pLoader.pushProjection(list);    pLoader.setLocation(location, job);    assertEquals("{a: chararray,b: {t: (d: chararray)}}", TupleReadSupport.getPigSchema(job.getConfiguration()).toString());}
b20b0faab65050f7691eea68f53126717b2c877d5bc816efc5f2f643a9402d8e
testProjectionPushdown
public void testProjectionPushdown() throws Exception
{    PigServer pigServer = new PigServer(ExecType.LOCAL);    pigServer.setValidateEachStatement(true);    String out = "target/out";    int rows = 10;    Data data = Storage.resetData(pigServer);    List<Tuple> list = new ArrayList<Tuple>();    for (int i = 0; i < rows; i++) {        list.add(Storage.tuple(i, "a" + i, i * 2));    }    data.set("in", "i:int, a:chararray, b:int", list);    pigServer.setBatchOn();    pigServer.registerQuery("A = LOAD 'in' USING mock.Storage();");    pigServer.deleteFile(out);    pigServer.registerQuery("Store A into '" + out + "' using " + ParquetStorer.class.getName() + "();");    pigServer.executeBatch();    List<Tuple> expectedList = new ArrayList<Tuple>();    for (int i = 0; i < rows; i++) {        expectedList.add(Storage.tuple("a" + i));    }    pigServer.registerQuery("C = LOAD '" + out + "' using " + ParquetLoader.class.getName() + "();");    pigServer.registerQuery("D = foreach C generate a;");    pigServer.registerQuery("Store D into 'out' using mock.Storage();");    pigServer.executeBatch();    List<Tuple> actualList = data.get("out");    pigServer.registerQuery("C = LOAD '" + out + "' using " + ParquetLoader.class.getName() + "('a:chararray, b:int');");    Assert.assertEquals("{a: chararray,b: int}", pigServer.dumpSchema("C").toString());    try {        pigServer.registerQuery("D = foreach C generate i;");        Assert.fail("Frontend Exception expected");    } catch (FrontendException fe) {    }                pigServer = new PigServer(ExecType.LOCAL);    data = Storage.resetData(pigServer);    pigServer.setBatchOn();    pigServer.registerQuery("C = LOAD '" + out + "' using " + ParquetLoader.class.getName() + "('a:chararray, b:int');");    pigServer.registerQuery("D = foreach C generate a;");    pigServer.registerQuery("Store D into 'out' using mock.Storage();");    pigServer.executeBatch();    actualList = data.get("out");    Assert.assertEquals(expectedList, actualList);}
82d305bd995f8c82b11c1de84490615d3d1fb0edd18e2227d7973f870e90684b
testNullPadding
public void testNullPadding() throws Exception
{    PigServer pigServer = new PigServer(ExecType.LOCAL);    pigServer.setValidateEachStatement(true);    String out = "target/out";    int rows = 10;    Data data = Storage.resetData(pigServer);    List<Tuple> list = new ArrayList<Tuple>();    for (int i = 0; i < rows; i++) {        list.add(Storage.tuple(i, "a" + i, i * 2));    }    data.set("in", "i:int, a:chararray, b:int", list);    pigServer.setBatchOn();    pigServer.registerQuery("A = LOAD 'in' USING mock.Storage();");    pigServer.deleteFile(out);    pigServer.registerQuery("Store A into '" + out + "' using " + ParquetStorer.class.getName() + "();");    pigServer.executeBatch();        pigServer.registerQuery("C = LOAD '" + out + "' using " + ParquetLoader.class.getName() + "('i:int, a:chararray, b:int, n1:int, n2:chararray');");    pigServer.registerQuery("STORE C into 'out' using mock.Storage();");    pigServer.executeBatch();    List<Tuple> actualList = data.get("out");    assertEquals(rows, actualList.size());    for (Tuple t : actualList) {        assertTrue(t.isNull(3));        assertTrue(t.isNull(4));    }        pigServer.registerQuery("D = LOAD '" + out + "' using " + ParquetLoader.class.getName() + "('n1:int, a:chararray, n2:chararray, b:int');");    pigServer.registerQuery("STORE D into 'out2' using mock.Storage();");    pigServer.executeBatch();    actualList = data.get("out2");    assertEquals(rows, actualList.size());    for (Tuple t : actualList) {        assertTrue(t.isNull(0));        assertTrue(t.isNull(2));    }}
13f144361fe54997876dcd8d04d0347755a906fbccfda5bbf40c569bd7ff6318
testReqestedSchemaColumnPruning
public void testReqestedSchemaColumnPruning() throws Exception
{    PigServer pigServer = new PigServer(ExecType.LOCAL);    pigServer.setValidateEachStatement(true);    String out = "target/out";    int rows = 10;    Data data = Storage.resetData(pigServer);    List<Tuple> list = new ArrayList<Tuple>();    for (int i = 0; i < rows; i++) {        list.add(Storage.tuple(i, "a" + i, i * 2));    }    data.set("in", "i:int, a:chararray, b:int", list);    pigServer.setBatchOn();    pigServer.registerQuery("A = LOAD 'in' USING mock.Storage();");    pigServer.deleteFile(out);    pigServer.registerQuery("Store A into '" + out + "' using " + ParquetStorer.class.getName() + "();");    pigServer.executeBatch();        pigServer.registerQuery("C = LOAD '" + out + "' using " + ParquetLoader.class.getName() + "('i:int, a:chararray, b:int, n1:int, n2:chararray');");    pigServer.registerQuery("G = foreach C generate n1,b,n2,i;");    pigServer.registerQuery("STORE G into 'out' using mock.Storage();");    pigServer.executeBatch();    List<Tuple> actualList = data.get("out");    assertEquals(rows, actualList.size());    for (Tuple t : actualList) {        assertEquals(4, t.size());        assertTrue(t.isNull(0));        assertTrue(t.isNull(2));    }}
4e3686eb1c3f60fb60c5e01bfde2c429641a9c0dd2dd240c5a3232c870b73ef6
testTypePersuasion
public void testTypePersuasion() throws Exception
{    Properties p = new Properties();    p.setProperty(STRICT_TYPE_CHECKING, Boolean.FALSE.toString());    PigServer pigServer = new PigServer(ExecType.LOCAL, p);    pigServer.setValidateEachStatement(true);    String out = "target/out";    int rows = 10;    Data data = Storage.resetData(pigServer);    List<Tuple> list = new ArrayList<Tuple>();    for (int i = 0; i < rows; i++) {        list.add(Storage.tuple(i, (long) i, (float) i, (double) i, Integer.toString(i), Boolean.TRUE));    }    data.set("in", "i:int, l:long, f:float, d:double, s:chararray, b:boolean", list);    pigServer.setBatchOn();    pigServer.registerQuery("A = LOAD 'in' USING mock.Storage();");    pigServer.deleteFile(out);    pigServer.registerQuery("Store A into '" + out + "' using " + ParquetStorer.class.getName() + "();");    pigServer.executeBatch();    List<Tuple> actualList = null;    byte[] types = { INTEGER, LONG, FLOAT, DOUBLE, CHARARRAY, BOOLEAN };        for (int i = 0; i < types.length; i++) {        String query = "B = LOAD '" + out + "' using " + ParquetLoader.class.getName() + "('i:" + DataType.findTypeName(types[i % types.length]) + "," + "  l:" + DataType.findTypeName(types[(i + 1) % types.length]) + "," + "  f:" + DataType.findTypeName(types[(i + 2) % types.length]) + "," + "  d:" + DataType.findTypeName(types[(i + 3) % types.length]) + "," + "  s:" + DataType.findTypeName(types[(i + 4) % types.length]) + "," + "  b:" + DataType.findTypeName(types[(i + 5) % types.length]) + "');";        System.out.println("Query: " + query);        pigServer.registerQuery(query);        pigServer.registerQuery("STORE B into 'out" + i + "' using mock.Storage();");        pigServer.executeBatch();        actualList = data.get("out" + i);        assertEquals(rows, actualList.size());        for (Tuple t : actualList) {            assertTrue(t.getType(0) == types[i % types.length]);            assertTrue(t.getType(1) == types[(i + 1) % types.length]);            assertTrue(t.getType(2) == types[(i + 2) % types.length]);            assertTrue(t.getType(3) == types[(i + 3) % types.length]);            assertTrue(t.getType(4) == types[(i + 4) % types.length]);            assertTrue(t.getType(5) == types[(i + 5) % types.length]);        }    }}
632f392ac3aabadf3ca9168e42f957b1c33984023144069be37d01bf591c441d
testColumnIndexAccess
public void testColumnIndexAccess() throws Exception
{    PigServer pigServer = new PigServer(ExecType.LOCAL);    pigServer.setValidateEachStatement(true);    String out = "target/out";    int rows = 10;    Data data = Storage.resetData(pigServer);    List<Tuple> list = new ArrayList<Tuple>();    for (int i = 0; i < rows; i++) {        list.add(Storage.tuple(i, i * 1.0, i * 2L, "v" + i));    }    data.set("in", "c1:int, c2:double, c3:long, c4:chararray", list);    pigServer.setBatchOn();    pigServer.registerQuery("A = LOAD 'in' USING mock.Storage();");    pigServer.deleteFile(out);    pigServer.registerQuery("Store A into '" + out + "' using " + ParquetStorer.class.getName() + "();");    pigServer.executeBatch();        pigServer.registerQuery("B = LOAD '" + out + "' using " + ParquetLoader.class.getName() + "('n1:int, n2:double, n3:long, n4:chararray', 'true');");    pigServer.registerQuery("STORE B into 'out' using mock.Storage();");    pigServer.executeBatch();    List<Tuple> actualList = data.get("out");    assertEquals(rows, actualList.size());    for (int i = 0; i < rows; i++) {        Tuple t = actualList.get(i);        assertEquals(4, t.size());        assertEquals(i, t.get(0));        assertEquals(i * 1.0, t.get(1));        assertEquals(i * 2L, t.get(2));        assertEquals("v" + i, t.get(3));    }}
c5186f311b2a415541e2c0b19519fe06494a489b32df11a51010cc9ab533371b
testColumnIndexAccessProjection
public void testColumnIndexAccessProjection() throws Exception
{    PigServer pigServer = new PigServer(ExecType.LOCAL);    pigServer.setValidateEachStatement(true);    String out = "target/out";    int rows = 10;    Data data = Storage.resetData(pigServer);    List<Tuple> list = new ArrayList<Tuple>();    for (int i = 0; i < rows; i++) {        list.add(Storage.tuple(i, i * 1.0, i * 2L, "v" + i));    }    data.set("in", "c1:int, c2:double, c3:long, c4:chararray", list);    pigServer.setBatchOn();    pigServer.registerQuery("A = LOAD 'in' USING mock.Storage();");    pigServer.deleteFile(out);    pigServer.registerQuery("Store A into '" + out + "' using " + ParquetStorer.class.getName() + "();");    pigServer.executeBatch();    pigServer.registerQuery("B = LOAD '" + out + "' using " + ParquetLoader.class.getName() + "('n1:int, n2:double, n3:long, n4:chararray', 'true');");    pigServer.registerQuery("C = foreach B generate n1, n3;");    pigServer.registerQuery("STORE C into 'out' using mock.Storage();");    pigServer.executeBatch();    List<Tuple> actualList = data.get("out");    assertEquals(rows, actualList.size());    for (int i = 0; i < rows; i++) {        Tuple t = actualList.get(i);        assertEquals(2, t.size());        assertEquals(i, t.get(0));        assertEquals(i * 2L, t.get(1));    }}
bcd7ea2514964ca67255edaae86e8549c4dd437dc87780e8a9afef28ceb2858f
testPredicatePushdown
public void testPredicatePushdown() throws Exception
{    Configuration conf = new Configuration();    conf.setBoolean(ParquetLoader.ENABLE_PREDICATE_FILTER_PUSHDOWN, true);    PigServer pigServer = new PigServer(ExecType.LOCAL, conf);    pigServer.setValidateEachStatement(true);    String out = "target/out";    String out2 = "target/out2";    int rows = 10;    Data data = Storage.resetData(pigServer);    List<Tuple> list = new ArrayList<Tuple>();    for (int i = 0; i < rows; i++) {        list.add(Storage.tuple(i, i * 1.0, i * 2L, "v" + i));    }    data.set("in", "c1:int, c2:double, c3:long, c4:chararray", list);    pigServer.setBatchOn();    pigServer.registerQuery("A = LOAD 'in' USING mock.Storage();");    pigServer.deleteFile(out);    pigServer.registerQuery("Store A into '" + out + "' using " + ParquetStorer.class.getName() + "();");    pigServer.executeBatch();    pigServer.deleteFile(out2);    pigServer.registerQuery("B = LOAD '" + out + "' using " + ParquetLoader.class.getName() + "('c1:int, c2:double, c3:long, c4:chararray');");    pigServer.registerQuery("C = FILTER B by c1 == 1 or c1 == 5;");    pigServer.registerQuery("STORE C into '" + out2 + "' using mock.Storage();");    List<ExecJob> jobs = pigServer.executeBatch();    long recordsRead = jobs.get(0).getStatistics().getInputStats().get(0).getNumberRecords();    assertEquals(2, recordsRead);}
ff4852e2a090cace40f3f43a2fbfdb8de58d7f14a93fb3e4ffc68c126b5dfeef
testStorer
public void testStorer() throws ExecException, Exception
{    String out = "target/out";    int rows = 1000;    Properties props = new Properties();    props.setProperty("parquet.compression", "uncompressed");    props.setProperty("parquet.page.size", "1000");    PigServer pigServer = new PigServer(ExecType.LOCAL, props);    Data data = Storage.resetData(pigServer);    Collection<Tuple> list = new ArrayList<Tuple>();    for (int i = 0; i < rows; i++) {        list.add(tuple("a" + i));    }    data.set("in", "a:chararray", list);    pigServer.setBatchOn();    pigServer.registerQuery("A = LOAD 'in' USING mock.Storage();");    pigServer.deleteFile(out);    pigServer.registerQuery("Store A into '" + out + "' using " + ParquetStorer.class.getName() + "();");    if (pigServer.executeBatch().get(0).getStatus() != JOB_STATUS.COMPLETED) {        throw new RuntimeException("Job failed", pigServer.executeBatch().get(0).getException());    }    pigServer.registerQuery("B = LOAD '" + out + "' USING " + ParquetLoader.class.getName() + "();");    pigServer.registerQuery("Store B into 'out' using mock.Storage();");    if (pigServer.executeBatch().get(0).getStatus() != JOB_STATUS.COMPLETED) {        throw new RuntimeException("Job failed", pigServer.executeBatch().get(0).getException());    }    List<Tuple> result = data.get("out");    assertEquals(rows, result.size());    int i = 0;    for (Tuple tuple : result) {        assertEquals("a" + i, tuple.get(0));        ++i;    }}
833fefe57f9f4fba091277b0794694ccc1d9fc24ee7a12101d39f06517e52983
testMultipleSchema
public void testMultipleSchema() throws ExecException, Exception
{    String out = "target/out";    int rows = 1000;    Properties props = new Properties();    props.setProperty("parquet.compression", "uncompressed");    props.setProperty("parquet.page.size", "1000");    PigServer pigServer = new PigServer(ExecType.LOCAL, props);    Data data = Storage.resetData(pigServer);    Collection<Tuple> list1 = new ArrayList<Tuple>();    for (int i = 0; i < rows; i++) {        list1.add(tuple("a" + i));    }    Collection<Tuple> list2 = new ArrayList<Tuple>();    for (int i = 0; i < rows; i++) {        list2.add(tuple("b" + i));    }    data.set("a", "a:chararray", list1);    data.set("b", "b:chararray", list2);    pigServer.setBatchOn();    pigServer.registerQuery("A = LOAD 'a' USING mock.Storage();");    pigServer.registerQuery("B = LOAD 'b' USING mock.Storage();");    pigServer.deleteFile(out);    pigServer.registerQuery("Store A into '" + out + "/a' using " + ParquetStorer.class.getName() + "();");    pigServer.registerQuery("Store B into '" + out + "/b' using " + ParquetStorer.class.getName() + "();");    if (pigServer.executeBatch().get(0).getStatus() != JOB_STATUS.COMPLETED) {        throw new RuntimeException("Job failed", pigServer.executeBatch().get(0).getException());    }    pigServer.registerQuery("B = LOAD '" + out + "/*' USING " + ParquetLoader.class.getName() + "();");    pigServer.registerQuery("Store B into 'out' using mock.Storage();");    if (pigServer.executeBatch().get(0).getStatus() != JOB_STATUS.COMPLETED) {        throw new RuntimeException("Job failed", pigServer.executeBatch().get(0).getException());    }    List<Tuple> result = data.get("out");    final Schema schema = data.getSchema("out");    assertEquals(2, schema.size());        int ai;    int bi;    if ("a".equals(schema.getField(0).alias)) {        ai = 0;        bi = 1;        assertEquals("a", schema.getField(0).alias);        assertEquals("b", schema.getField(1).alias);    } else {        ai = 1;        bi = 0;        assertEquals("b", schema.getField(0).alias);        assertEquals("a", schema.getField(1).alias);    }    assertEquals(rows * 2, result.size());    int a = 0;    int b = 0;    for (Tuple tuple : result) {        String fa = (String) tuple.get(ai);        String fb = (String) tuple.get(bi);        if (fa != null) {            assertEquals("a" + a, fa);            ++a;        }        if (fb != null) {            assertEquals("b" + b, fb);            ++b;        }    }}
f300b46bf742ec6cfa098b1f91f5c12621dc6b60284d36d77084daafbead5ca5
testStorerCompressed
public void testStorerCompressed() throws ExecException, Exception
{    String out = "target/out";    int rows = 1000;    Properties props = new Properties();    props.setProperty("parquet.compression", "gzip");    props.setProperty("parquet.page.size", "1000");    PigServer pigServer = new PigServer(ExecType.LOCAL, props);    Data data = Storage.resetData(pigServer);    Collection<Tuple> list = new ArrayList<Tuple>();    for (int i = 0; i < rows; i++) {        list.add(Storage.tuple("a" + i));    }    data.set("in", "a:chararray", list);    pigServer.setBatchOn();    pigServer.registerQuery("A = LOAD 'in' USING mock.Storage();");    pigServer.deleteFile(out);    pigServer.registerQuery("Store A into '" + out + "' using " + ParquetStorer.class.getName() + "();");    if (pigServer.executeBatch().get(0).getStatus() != JOB_STATUS.COMPLETED) {        throw new RuntimeException("Job failed", pigServer.executeBatch().get(0).getException());    }    pigServer.registerQuery("B = LOAD '" + out + "' USING " + ParquetLoader.class.getName() + "();");    pigServer.registerQuery("Store B into 'out' using mock.Storage();");    if (pigServer.executeBatch().get(0).getStatus() != JOB_STATUS.COMPLETED) {        throw new RuntimeException("Job failed", pigServer.executeBatch().get(0).getException());    }    List<Tuple> result = data.get("out");    assertEquals(rows, result.size());    int i = 0;    for (Tuple tuple : result) {        assertEquals("a" + i, tuple.get(0));        ++i;    }}
b9a732b4f536a609eaad76a2239402632d7f2215f94e9da4175db890689c9b30
testComplexSchema
public void testComplexSchema() throws ExecException, Exception
{    String out = "target/out";    PigServer pigServer = new PigServer(ExecType.LOCAL);    Data data = Storage.resetData(pigServer);    Collection<Tuple> list = new ArrayList<Tuple>();    for (int i = 0; i < 1000; i++) {        list.add(tuple("a" + i, bag(tuple("o", "b"))));    }    for (int i = 10; i < 2000; i++) {        list.add(tuple("a" + i, bag(tuple("o", "b"), tuple("o", "b"), tuple("o", "b"), tuple("o", "b"))));    }    for (int i = 20; i < 3000; i++) {        list.add(tuple("a" + i, bag(tuple("o", "b"), tuple("o", null), tuple(null, "b"), tuple(null, null))));    }    for (int i = 30; i < 4000; i++) {        list.add(tuple("a" + i, null));    }    Collections.shuffle((List<?>) list);    data.set("in", "a:chararray, b:{t:(c:chararray, d:chararray)}", list);    pigServer.setBatchOn();    pigServer.registerQuery("A = LOAD 'in' USING mock.Storage();");    pigServer.deleteFile(out);    pigServer.registerQuery("Store A into '" + out + "' using " + ParquetStorer.class.getName() + "();");    if (pigServer.executeBatch().get(0).getStatus() != JOB_STATUS.COMPLETED) {        throw new RuntimeException("Job failed", pigServer.executeBatch().get(0).getException());    }    {        pigServer.registerQuery("B = LOAD '" + out + "' USING " + ParquetLoader.class.getName() + "();");        pigServer.registerQuery("Store B into 'out' using mock.Storage();");        if (pigServer.executeBatch().get(0).getStatus() != JOB_STATUS.COMPLETED) {            throw new RuntimeException("Job failed", pigServer.executeBatch().get(0).getException());        }        List<Tuple> result = data.get("out");        assertEquals(list, result);        final Schema schema = data.getSchema("out");        assertEquals("{a:chararray, b:{t:(c:chararray, d:chararray)}}".replaceAll(" ", ""), schema.toString().replaceAll(" ", ""));    }    {        pigServer.registerQuery("C = LOAD '" + out + "' USING " + ParquetLoader.class.getName() + "('a:chararray');");        pigServer.registerQuery("Store C into 'out2' using mock.Storage();");        if (pigServer.executeBatch().get(0).getStatus() != JOB_STATUS.COMPLETED) {            throw new RuntimeException("Job failed", pigServer.executeBatch().get(0).getException());        }        final Function<Tuple, Object> grabFirstColumn = new Function<Tuple, Object>() {            @Override            public Object apply(Tuple input) {                try {                    return input.get(0);                } catch (ExecException e) {                    throw new RuntimeException(e);                }            }        };        List<Tuple> result2 = data.get("out2");                Object[] result2int = Collections2.transform(result2, grabFirstColumn).toArray();        Object[] input2int = Collections2.transform(list, grabFirstColumn).toArray();        assertArrayEquals(input2int, result2int);    }}
a1e632b224c2637af898cfb3f7d43a57ea1ab2254dc4978fbc8c97f80047a767
apply
public Object apply(Tuple input)
{    try {        return input.get(0);    } catch (ExecException e) {        throw new RuntimeException(e);    }}
94e618a4c0b223a74bd54791cbdb91e279ca61d1914cbcb0c24ad5578208781e
testPigConversion
private void testPigConversion(String pigSchemaString) throws Exception
{    Schema pigSchema = Utils.getSchemaFromString(pigSchemaString);    MessageType parquetSchema = pigSchemaConverter.convert(pigSchema);    Schema convertedSchema = pigSchemaConverter.convert(parquetSchema);    assertEquals(pigSchema, convertedSchema);}
437d3e59c84b15c60ee33899558502b0e05a69a9c5fef89f98d9042448fb0b7d
testSimpleBag
public void testSimpleBag() throws Exception
{    testPigConversion("b:{t:(a:int)}");}
23991518fa16073346e658c2270eda36dd5d8711d84b0d7603446af224a463fe
testMultiBag
public void testMultiBag() throws Exception
{    testPigConversion("x:int, b:{t:(a:int,b:chararray)}");}
7cf0da08535c46ba153cdae0011d7bd5e042b14ccd5989eb35957b3f9bb19083
testMapSimple
public void testMapSimple() throws Exception
{    testPigConversion("b:[(c:int)]");}
5e8205b777d16374063cd3d0858e12b2eff3a337c2e8a2a3f9c986c857390951
testMapTuple
public void testMapTuple() throws Exception
{    testPigConversion("a:chararray, b:[(c:chararray, d:chararray)]");}
12c3c763a85b6466f998acc62fee19723078ff3aba5f5a994ddf2a55738bf2d4
testMapOfList
public void testMapOfList() throws Exception
{    testPigConversion("a:map[{bag: (a:int)}]");}
cc6c24d67c65f5ca869dc08ae4e8c75b36a54b43e03d485bebc0ff9d37da4ab6
testListsOfPrimitive
public void testListsOfPrimitive() throws Exception
{    for (Type.Repetition repetition : Type.Repetition.values()) {        for (Type.Repetition valueRepetition : Type.Repetition.values()) {            for (PrimitiveType.PrimitiveTypeName primitiveTypeName : PrimitiveType.PrimitiveTypeName.values()) {                if (primitiveTypeName != PrimitiveType.PrimitiveTypeName.INT96) {                                        Types.PrimitiveBuilder<PrimitiveType> value = Types.primitive(primitiveTypeName, valueRepetition);                    if (primitiveTypeName == PrimitiveType.PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY)                        value.length(1);                    GroupType type = Types.buildGroup(repetition).addField(value.named("b")).as(OriginalType.LIST).named("a");                                        pigSchemaConverter.convertField(type);                }            }        }    }}
7392445d9feeada9f8ca76042103d106ce191aad9ba5ef73392bcd03ef06ec88
testConversion
private void testConversion(String pigSchemaString, String schemaString) throws Exception
{    Schema pigSchema = Utils.getSchemaFromString(pigSchemaString);    MessageType schema = pigSchemaConverter.convert(pigSchema);    MessageType expectedMT = MessageTypeParser.parseMessageType(schemaString);    assertEquals("converting " + pigSchemaString + " to " + schemaString, expectedMT, schema);    MessageType filtered = pigSchemaConverter.filter(schema, pigSchema, null);    assertEquals("converting " + pigSchemaString + " to " + schemaString + " and filtering", schema.toString(), filtered.toString());}
555f6c11bf48d90aaee4e562b8c4d13d6cbc2c0cab6c59f85c37b4625f3e55ac
testTupleBag
public void testTupleBag() throws Exception
{    testConversion("a:chararray, b:{t:(c:chararray, d:chararray)}", "message pig_schema {\n" + "  optional binary a (UTF8);\n" + "  optional group b (LIST) {\n" + "    repeated group t {\n" + "      optional binary c (UTF8);\n" + "      optional binary d (UTF8);\n" + "    }\n" + "  }\n" + "}\n");}
d0d27b65526bac2bde51a25fe599ebf371f9d68eac377e0496f9de8a17197b82
testTupleBagWithAnonymousInnerField
public void testTupleBagWithAnonymousInnerField() throws Exception
{    testConversion("a:chararray, b:{(c:chararray, d:chararray)}", "message pig_schema {\n" + "  optional binary a (UTF8);\n" + "  optional group b (LIST) {\n" +     "    repeated group bag {\n" + "      optional binary c (UTF8);\n" + "      optional binary d (UTF8);\n" + "    }\n" + "  }\n" + "}\n");}
7e3f62689a52f5cfc8f5889d1068814d43f1f4feaa85df375762f0f9cb0ab82c
testMap
public void testMap() throws Exception
{    testConversion("a:chararray, b:[(c:chararray, d:chararray)]", "message pig_schema {\n" + "  optional binary a (UTF8);\n" + "  optional group b (MAP) {\n" + "    repeated group map (MAP_KEY_VALUE) {\n" + "      required binary key (UTF8);\n" + "      optional group value {\n" + "        optional binary c (UTF8);\n" + "        optional binary d (UTF8);\n" + "      }\n" + "    }\n" + "  }\n" + "}\n");}
94c61e13622ec463b1e4c582fde0913993f20af0c736d2e1cd73553f72f3ac39
testMap2
public void testMap2() throws Exception
{    testConversion("a:map[int]", "message pig_schema {\n" + "  optional group a (MAP) {\n" + "    repeated group map (MAP_KEY_VALUE) {\n" + "      required binary key (UTF8);\n" + "      optional int32 value;" + "    }\n" + "  }\n" + "}\n");}
9e7c54930f1635d4afb9de8fa7b37feae1aebedd187f059a401d662dfbb73575
testMap3
public void testMap3() throws Exception
{    testConversion("a:map[map[int]]", "message pig_schema {\n" + "  optional group a (MAP) {\n" + "    repeated group map (MAP_KEY_VALUE) {\n" + "      required binary key (UTF8);\n" + "      optional group value (MAP) {\n" + "        repeated group map (MAP_KEY_VALUE) {\n" + "          required binary key (UTF8);\n" + "          optional int32 value;\n" + "        }\n" + "      }\n" + "    }\n" + "  }\n" + "}\n");}
a919debaeec388380445c2c5dd8cf90b514edf0437bdf03a2d8bd51cb5bd1999
testMap4
public void testMap4() throws Exception
{    testConversion("a:map[bag{(a:int)}]", "message pig_schema {\n" + "  optional group a (MAP) {\n" + "    repeated group map (MAP_KEY_VALUE) {\n" + "      required binary key (UTF8);\n" + "      optional group value (LIST) {\n" + "        repeated group bag {\n" + "          optional int32 a;\n" + "        }\n" + "      }\n" + "    }\n" + "  }\n" + "}\n");}
259b32f8414e63e017197f63d2813561b72acc0fc9a30033c6b715757a846c87
testListOfPrimitiveIsABag
public void testListOfPrimitiveIsABag() throws Exception
{    testFixedConversion("message pig_schema {\n" + "  optional group a (LIST) {\n" + "    repeated binary b (UTF8);\n" + "  }\n" + "}\n", "a:{" + PigSchemaConverter.ARRAY_VALUE_NAME + ":(b: chararray)}");}
cf18097bd53ffa72f88ea3fa1dd5767982c5d5747f459ad71b493aead69fbcf7
testFixedConversion
private void testFixedConversion(String schemaString, String pigSchemaString) throws Exception
{    Schema expectedPigSchema = Utils.getSchemaFromString(pigSchemaString);    MessageType parquetSchema = MessageTypeParser.parseMessageType(schemaString);    Schema pigSchema = pigSchemaConverter.convert(parquetSchema);    assertEquals("converting " + schemaString + " to " + pigSchemaString, expectedPigSchema, pigSchema);}
3bc04c8b3b50ebb8561d291bce1d3bf18b8257e4e902017ad04f31b920d6fc14
testMapWithFixed
public void testMapWithFixed() throws Exception
{    testFixedConversion("message pig_schema {\n" + "  optional binary a;\n" + "  optional group b (MAP) {\n" + "    repeated group map (MAP_KEY_VALUE) {\n" + "      required binary key;\n" + "      optional group value {\n" + "        optional fixed_len_byte_array(5) c;\n" + "        optional fixed_len_byte_array(7) d;\n" + "      }\n" + "    }\n" + "  }\n" + "}\n", "a:bytearray, b:[(c:bytearray, d:bytearray)]");}
e54df8017553806cfa10d35c9520da63aa4acc4b8bd62f1288b7e4befffbd669
testMapWithFixedWithoutOriginalType
public void testMapWithFixedWithoutOriginalType() throws Exception
{    testFixedConversion("message spark_schema {\n" + "  optional binary a;\n" + "  optional group b (MAP) {\n" + "    repeated group map {\n" + "      required binary key;\n" + "      optional group value {\n" + "        optional fixed_len_byte_array(5) c;\n" + "        optional fixed_len_byte_array(7) d;\n" + "      }\n" + "    }\n" + "  }\n" + "}\n", "a:bytearray, b:[(c:bytearray, d:bytearray)]");}
6ed4051c63bac91231ae1ce71abbe3175cca131b5262dadcd8a7b41f9c3bab00
testInt96
public void testInt96() throws Exception
{    testFixedConversion("message spark_schema {\n" + "  optional int96 datetime;\n" + "}", "datetime:bytearray");}
249a6180028a68227ff04f8d0a8764a93c776d3dea5a5904cc4b243f00d36d69
testAnonymousField
public void testAnonymousField() throws Exception
{    testConversion("a:chararray, int", "message pig_schema {\n" + "  optional binary a (UTF8);\n" + "  optional int32 val_0;\n" + "}\n");}
ea79a10f50837a8d7eb28832441543d24f3356e9303d993b48450de16036eabe
testSchemaEvolution
public void testSchemaEvolution()
{    Map<String, Set<String>> map = new LinkedHashMap<String, Set<String>>();    map.put("pig.schema", new LinkedHashSet<String>(Arrays.asList("a:int, b:int, c:int, d:int, e:int, f:int", "aa:int, aaa:int, b:int, c:int, ee:int")));    Schema result = getPigSchemaFromMultipleFiles(new MessageType("file_schema", new PrimitiveType(OPTIONAL, INT32, "a")), map);    assertEquals("a: int,b: int,c: int,d: int,e: int,f: int,aa: int,aaa: int,ee: int", pigSchemaToString(result));}
848c4129e1f4e8a08006a1364e3bd30ae130825e942d66d5fe157219ce26ced6
testArtSchema
public void testArtSchema() throws ExecException, ParserException
{    String pigSchemaString = "DocId:long, " + "Links:(Backward:{(long)}, Forward:{(long)}), " + "Name:{(Language:{(Code:chararray,Country:chararray)}, Url:chararray)}";    SimpleGroup g = new SimpleGroup(getMessageType(pigSchemaString));    g.add("DocId", 1l);    Group links = g.addGroup("Links");    links.addGroup("Backward").addGroup("bag").add(0, 1l);    links.addGroup("Forward").addGroup("bag").add(0, 1l);    Group name = g.addGroup("Name").addGroup("bag");    name.addGroup("Language").addGroup("bag").append("Code", "en").append("Country", "US");    name.add("Url", "http://foo/bar");    testFromGroups(pigSchemaString, Arrays.<Group>asList(g));}
d3bd311f80d6d2c49231fb36631d6337e0678d46c651b32d9b258382bf784eb6
testBags
public void testBags() throws ExecException, ParserException
{    String pigSchemaString = "a: {(b: chararray)}";    SimpleGroup g = new SimpleGroup(getMessageType(pigSchemaString));    Group addGroup = g.addGroup("a");    addGroup.addGroup("bag").append("b", "foo");    addGroup.addGroup("bag").append("b", "bar");    testFromGroups(pigSchemaString, Arrays.<Group>asList(g));}
81f101a546e5baaa86e42d4bfbdec818874dc5103c40acb18c34750719645214
testMaps
public void testMaps() throws ExecException, ParserException
{    String pigSchemaString = "a: [(b: chararray)]";    SimpleGroup g = new SimpleGroup(getMessageType(pigSchemaString));    Group map = g.addGroup("a");    map.addGroup("map").append("key", "foo").addGroup("value").append("b", "foo");    map.addGroup("map").append("key", "bar").addGroup("value").append("b", "bar");    testFromGroups(pigSchemaString, Arrays.<Group>asList(g));}
8b68d7dbefedd2799c6c88b6bece37ee20aa8792a028da3fcda6087d6bfb1864
testComplexSchema
public void testComplexSchema() throws Exception
{    String pigSchemaString = "a:chararray, b:{t:(c:chararray, d:chararray)}";    Tuple t0 = tuple("a" + 0, bag(tuple("o", "b"), tuple("o1", "b1")));    Tuple t1 = tuple("a" + 1, bag(tuple("o", "b"), tuple("o", "b"), tuple("o", "b"), tuple("o", "b")));    Tuple t2 = tuple("a" + 2, bag(tuple("o", "b"), tuple("o", null), tuple(null, "b"), tuple(null, null)));    Tuple t3 = tuple("a" + 3, null);    testFromTuple(pigSchemaString, Arrays.asList(t0, t1, t2, t3));}
9c3c9bcf34ce33ce29b7888c46f99eae715494b56a2d14f030aff64740d98fd2
testMapSchema
public void testMapSchema() throws Exception
{    String pigSchemaString = "a:chararray, b:[(c:chararray, d:chararray)]";    Tuple t0 = tuple("a" + 0, new HashMap() {        {            put("foo", tuple("o", "b"));        }    });    Tuple t1 = tuple("a" + 1, new HashMap() {        {            put("foo", tuple("o", "b"));            put("foo", tuple("o", "b"));            put("foo", tuple("o", "b"));            put("foo", tuple("o", "b"));        }    });    Tuple t2 = tuple("a" + 2, new HashMap() {        {            put("foo", tuple("o", "b"));            put("foo", tuple("o", null));            put("foo", tuple(null, "b"));            put("foo", tuple(null, null));        }    });    Tuple t3 = tuple("a" + 3, null);    testFromTuple(pigSchemaString, Arrays.asList(t0, t1, t2, t3));}
8f466b6a80e3a0acf4e41ba731c62fe68c5dbbdafa9dcb27edfe8bd299a65358
testFromTuple
private void testFromTuple(String pigSchemaString, List<Tuple> input) throws Exception
{    List<Tuple> tuples = new ArrayList<Tuple>();    RecordMaterializer<Tuple> recordConsumer = newPigRecordConsumer(pigSchemaString);    TupleWriteSupport tupleWriter = newTupleWriter(pigSchemaString, recordConsumer);    for (Tuple tuple : input) {        LOG.debug("{}", tuple);        tupleWriter.write(tuple);        tuples.add(recordConsumer.getCurrentRecord());    }    assertEquals(input.size(), tuples.size());    for (int i = 0; i < input.size(); i++) {        Tuple in = input.get(i);        Tuple out = tuples.get(i);        assertEquals(in.toString(), out.toString());    }}
3484ba0a61bc86e29bab66705b58fe3ee895c3c412cf08faba5b7fb776fa0fef
testFromGroups
private void testFromGroups(String pigSchemaString, List<Group> input) throws ParserException
{    List<Tuple> tuples = new ArrayList<Tuple>();    MessageType schema = getMessageType(pigSchemaString);    RecordMaterializer<Tuple> pigRecordConsumer = newPigRecordConsumer(pigSchemaString);    GroupWriter groupWriter = new GroupWriter(new RecordConsumerLoggingWrapper(new ConverterConsumer(pigRecordConsumer.getRootConverter(), schema)), schema);    for (Group group : input) {        groupWriter.write(group);        final Tuple tuple = pigRecordConsumer.getCurrentRecord();        tuples.add(tuple);        LOG.debug("in: {}\nout:{}", group, tuple);    }    List<Group> groups = new ArrayList<Group>();    GroupRecordConverter recordConsumer = new GroupRecordConverter(schema);    TupleWriteSupport tupleWriter = newTupleWriter(pigSchemaString, recordConsumer);    for (Tuple t : tuples) {        LOG.debug("{}", t);        tupleWriter.write(t);        groups.add(recordConsumer.getCurrentRecord());    }    assertEquals(input.size(), groups.size());    for (int i = 0; i < input.size(); i++) {        Group in = input.get(i);        LOG.debug("{}", in);        Group out = groups.get(i);        assertEquals(in.toString(), out.toString());    }}
6af28c9d8266001a0e43bc366a33ffed1c5bc974edb8c45e07b31a5fab96d3cb
newTupleWriter
private TupleWriteSupport newTupleWriter(String pigSchemaString, RecordMaterializer<T> recordConsumer) throws ParserException
{    TupleWriteSupport tupleWriter = TupleWriteSupport.fromPigSchema(pigSchemaString);    tupleWriter.init(null);    tupleWriter.prepareForWrite(new ConverterConsumer(recordConsumer.getRootConverter(), tupleWriter.getParquetSchema()));    return tupleWriter;}
5e06e6f62b09072b16e5d9911aaac1ab234c225ac50e1886918a22352bb10227
pigMetaData
private Map<String, String> pigMetaData(String pigSchemaString)
{    Map<String, String> map = new HashMap<String, String>();    new PigMetaData(pigSchemaString).addToMetaData(map);    return map;}
1ac50207b597c11f35dad47f509b5f53f3581d042c045d0a826c530bba0dce6e
newPigRecordConsumer
private RecordMaterializer<Tuple> newPigRecordConsumer(String pigSchemaString) throws ParserException
{    TupleReadSupport tupleReadSupport = new TupleReadSupport();    final Configuration configuration = new Configuration(false);    MessageType parquetSchema = getMessageType(pigSchemaString);    final Map<String, String> pigMetaData = pigMetaData(pigSchemaString);    Map<String, Set<String>> globalMetaData = new HashMap<String, Set<String>>();    for (Entry<String, String> entry : pigMetaData.entrySet()) {        globalMetaData.put(entry.getKey(), new HashSet<String>(Arrays.asList(entry.getValue())));    }    configuration.set(PARQUET_PIG_SCHEMA, pigSchemaString);    final ReadContext init = tupleReadSupport.init(new InitContext(configuration, globalMetaData, parquetSchema));    return tupleReadSupport.prepareForRead(configuration, pigMetaData, parquetSchema, init);}
31df80140d84c346319edd3eeb9bc1ace53ed1e5083d84ad886e458c87c58ddc
getMessageType
private MessageType getMessageType(String pigSchemaString) throws ParserException
{    Schema pigSchema = Utils.getSchemaFromString(pigSchemaString);    return new PigSchemaConverter().convert(pigSchema);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    String pigSchema = pigSchema(false, false);    String pigSchemaProjected = pigSchema(true, false);    String pigSchemaNoString = pigSchema(true, true);    MessageType schema = new PigSchemaConverter().convert(Utils.getSchemaFromString(pigSchema));    MemPageStore memPageStore = new MemPageStore(0);    ColumnWriteStoreV1 columns = new ColumnWriteStoreV1(memPageStore, ParquetProperties.builder().withPageSize(50 * 1024 * 1024).withDictionaryEncoding(false).build());    write(memPageStore, columns, schema, pigSchema);    columns.flush();    read(memPageStore, pigSchema, pigSchemaProjected, pigSchemaNoString);    System.out.println(columns.getBufferedSize() + " bytes used total");    System.out.println("max col size: " + columns.maxColMemSize() + " bytes");}
02cf346c44ae9656c040161189b4e2028ea5f883e8ec118837ce606480328ce3
pigSchema
private static String pigSchema(boolean projected, boolean noStrings)
{    StringBuilder sb = new StringBuilder();    for (int i = 0; i < TOP_LEVEL_COLS; i++) {        if (i != 0) {            sb.append(", ");        }        sb.append("i" + i + ":(");        if (!noStrings) {            for (int j = 0; j < (projected ? 2 : 4); j++) {                if (j != 0) {                    sb.append(", ");                }                sb.append("j" + j + ":chararray");            }            sb.append(", ");        }        for (int k = 0; k < (projected ? 2 : 4); k++) {            if (k != 0) {                sb.append(", ");            }            sb.append("k" + k + ":long");        }        for (int l = 0; l < (projected ? 1 : 2); l++) {            sb.append(", ");            sb.append("l" + l + ":{t:(v:int)}");        }        sb.append(")");    }    return sb.toString();}
857834eb7b61cac05c9912d1e04eb7c25f4af722ab86d826a1c66010b06d72d5
tuple
private static Tuple tuple() throws ExecException
{    TupleFactory tf = TupleFactory.getInstance();    Tuple t = tf.newTuple(TOP_LEVEL_COLS);    for (int i = 0; i < TOP_LEVEL_COLS; i++) {        Tuple ti = tf.newTuple(10);        for (int j = 0; j < 4; j++) {            ti.set(j, "foo" + i + "," + j);        }        for (int k = 0; k < 4; k++) {            ti.set(4 + k, (long) k);        }        for (int l = 0; l < 2; l++) {            DataBag bag = new NonSpillableDataBag();            for (int m = 0; m < 10; m++) {                bag.add(tf.newTuple((Object) new Integer(m)));            }            ti.set(8 + l, bag);        }        t.set(i, ti);    }    return t;}
f0f0a3b618950ea2e72e0d96c273bd765fdae7472bef06de7fb33698f4655119
read
private static void read(PageReadStore columns, String pigSchemaString, String pigSchemaProjected, String pigSchemaProjectedNoStrings) throws ParserException
{    read(columns, pigSchemaString, "read all");    read(columns, pigSchemaProjected, "read projected");    read(columns, pigSchemaProjectedNoStrings, "read projected no Strings");}
39edc71bcaa444e64f759e322ff7a76fd8de820904663710e2bc3189e8eb21aa
read
private static void read(PageReadStore columns, String pigSchemaString, String message) throws ParserException
{    System.out.println(message);    MessageColumnIO columnIO = newColumnFactory(pigSchemaString);    TupleReadSupport tupleReadSupport = new TupleReadSupport();    Map<String, String> pigMetaData = pigMetaData(pigSchemaString);    MessageType schema = new PigSchemaConverter().convert(Utils.getSchemaFromString(pigSchemaString));    ReadContext init = tupleReadSupport.init(null, pigMetaData, schema);    RecordMaterializer<Tuple> recordConsumer = tupleReadSupport.prepareForRead(null, pigMetaData, schema, init);    RecordReader<Tuple> recordReader = columnIO.getRecordReader(columns, recordConsumer);                    read(recordReader, 10000, pigSchemaString);    read(recordReader, 10000, pigSchemaString);    read(recordReader, 10000, pigSchemaString);    read(recordReader, 10000, pigSchemaString);    read(recordReader, 10000, pigSchemaString);    read(recordReader, 100000, pigSchemaString);    read(recordReader, 1000000, pigSchemaString);    System.out.println();}
5a084f4a040d9732a05819e3fb0525157edbd0ee50d090f0ff018c1714d89219
pigMetaData
private static Map<String, String> pigMetaData(String pigSchemaString)
{    Map<String, String> map = new HashMap<String, String>();    new PigMetaData(pigSchemaString).addToMetaData(map);    return map;}
0739fdee6f5adbf73d8d23720632d2743829b0aeca2a1623fd8242f51148843c
write
private static void write(MemPageStore memPageStore, ColumnWriteStoreV1 columns, MessageType schema, String pigSchemaString) throws ExecException, ParserException
{    MessageColumnIO columnIO = newColumnFactory(pigSchemaString);    TupleWriteSupport tupleWriter = TupleWriteSupport.fromPigSchema(pigSchemaString);    tupleWriter.init(null);    tupleWriter.prepareForWrite(columnIO.getRecordWriter(columns));    write(memPageStore, tupleWriter, 10000);    write(memPageStore, tupleWriter, 10000);    write(memPageStore, tupleWriter, 10000);    write(memPageStore, tupleWriter, 10000);    write(memPageStore, tupleWriter, 10000);    write(memPageStore, tupleWriter, 100000);    write(memPageStore, tupleWriter, 1000000);    System.out.println();}
c4f2422ec7f1730a8639d8873ef27f7e157bf58f61b875dcf1dfb68321152f70
newColumnFactory
private static MessageColumnIO newColumnFactory(String pigSchemaString) throws ParserException
{    MessageType schema = new PigSchemaConverter().convert(Utils.getSchemaFromString(pigSchemaString));    return new ColumnIOFactory().getColumnIO(schema);}
c515ff9f940a7aecf895e891c46900088169f6f30d7a5b99e4206f862a9a76e0
read
private static void read(RecordReader<Tuple> recordReader, int count, String pigSchemaString) throws ParserException
{    long t0 = System.currentTimeMillis();    Tuple tuple = null;    for (int i = 0; i < count; i++) {        tuple = recordReader.read();    }    if (tuple == null) {        throw new RuntimeException();    }    long t1 = System.currentTimeMillis();    long t = t1 - t0;        float err = (float) 100 * 2 / t;    System.out.printf("read %,9d recs in %,5d ms at %,9d rec/s err: %3.2f%%\n", count, t, t == 0 ? 0 : count * 1000 / t, err);}
c8e344832aca6f541f6d067cbcf6dff22f16a852dee51becf0931cb6b475b499
write
private static void write(MemPageStore memPageStore, TupleWriteSupport tupleWriter, int count) throws ExecException
{    Tuple tu = tuple();    long t0 = System.currentTimeMillis();    for (int i = 0; i < count; i++) {        tupleWriter.write(tu);    }    long t1 = System.currentTimeMillis();    long t = t1 - t0;    memPageStore.addRowCount(count);    System.out.printf("written %,9d recs in %,5d ms at %,9d rec/s\n", count, t, t == 0 ? 0 : count * 1000 / t);}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    return converters[fieldIndex];}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    parent.add(myBuilder.build());    myBuilder.clear();}
b47e455960730e98e37ace2184e2bbedced253d845894240274a2ad9dafc32c3
newMessageConverter
private Converter newMessageConverter(final Message.Builder parentBuilder, final Descriptors.FieldDescriptor fieldDescriptor, Type parquetType)
{    boolean isRepeated = fieldDescriptor.isRepeated();    ParentValueContainer parent;    if (isRepeated) {        parent = new ParentValueContainer() {            @Override            public void add(Object value) {                parentBuilder.addRepeatedField(fieldDescriptor, value);            }        };    } else {        parent = new ParentValueContainer() {            @Override            public void add(Object value) {                parentBuilder.setField(fieldDescriptor, value);            }        };    }    LogicalTypeAnnotation logicalTypeAnnotation = parquetType.getLogicalTypeAnnotation();    if (logicalTypeAnnotation == null) {        return newScalarConverter(parent, parentBuilder, fieldDescriptor, parquetType);    }    return logicalTypeAnnotation.accept(new LogicalTypeAnnotation.LogicalTypeAnnotationVisitor<Converter>() {        @Override        public Optional<Converter> visit(LogicalTypeAnnotation.ListLogicalTypeAnnotation listLogicalType) {            return of(new ListConverter(parentBuilder, fieldDescriptor, parquetType));        }        @Override        public Optional<Converter> visit(LogicalTypeAnnotation.MapLogicalTypeAnnotation mapLogicalType) {            return of(new MapConverter(parentBuilder, fieldDescriptor, parquetType));        }    }).orElseGet(() -> newScalarConverter(parent, parentBuilder, fieldDescriptor, parquetType));}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    parentBuilder.addRepeatedField(fieldDescriptor, value);}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    parentBuilder.setField(fieldDescriptor, value);}
93098f48380894d526768d686271a1c356b48a95dbec1d8c430aa13a2ff05bba
visit
public Optional<Converter> visit(LogicalTypeAnnotation.ListLogicalTypeAnnotation listLogicalType)
{    return of(new ListConverter(parentBuilder, fieldDescriptor, parquetType));}
7dd05dabd0339b792f8e70cd8ce25c85e06d2fcfe7cc9dc21a68b53302ea60ed
visit
public Optional<Converter> visit(LogicalTypeAnnotation.MapLogicalTypeAnnotation mapLogicalType)
{    return of(new MapConverter(parentBuilder, fieldDescriptor, parquetType));}
6662f140d68e8555580ebb04c8ebca252d7f206881101d7cbef131c4a54aa72b
newScalarConverter
private Converter newScalarConverter(ParentValueContainer pvc, Message.Builder parentBuilder, Descriptors.FieldDescriptor fieldDescriptor, Type parquetType)
{    JavaType javaType = fieldDescriptor.getJavaType();    switch(javaType) {        case STRING:            return new ProtoStringConverter(pvc);        case FLOAT:            return new ProtoFloatConverter(pvc);        case DOUBLE:            return new ProtoDoubleConverter(pvc);        case BOOLEAN:            return new ProtoBooleanConverter(pvc);        case BYTE_STRING:            return new ProtoBinaryConverter(pvc);        case ENUM:            return new ProtoEnumConverter(pvc, fieldDescriptor);        case INT:            return new ProtoIntConverter(pvc);        case LONG:            return new ProtoLongConverter(pvc);        case MESSAGE:            {                Message.Builder subBuilder = parentBuilder.newBuilderForField(fieldDescriptor);                return new ProtoMessageConverter(pvc, subBuilder, parquetType.asGroupType());            }    }    throw new UnsupportedOperationException(String.format("Cannot convert type: %s" + " (Parquet type: %s) ", javaType, parquetType));}
579b18ac70ddcb0a3776c5b46323c621908b1e3a1e7a94e86a205fd1d6aaffad
getBuilder
public Message.Builder getBuilder()
{    return myBuilder;}
273b3e93056f131c9ed5d66df3602f4f540540e4aed546f127f6557063027c97
makeLookupStructure
private Map<Binary, Descriptors.EnumValueDescriptor> makeLookupStructure(Descriptors.FieldDescriptor enumFieldType)
{    Descriptors.EnumDescriptor enumType = enumFieldType.getEnumType();    Map<Binary, Descriptors.EnumValueDescriptor> lookupStructure = new HashMap<Binary, Descriptors.EnumValueDescriptor>();    List<Descriptors.EnumValueDescriptor> enumValues = enumType.getValues();    for (Descriptors.EnumValueDescriptor value : enumValues) {        String name = value.getName();        lookupStructure.put(Binary.fromString(name), enumType.findValueByName(name));    }    return lookupStructure;}
4a5fca63216ad12094ebb72815b1bacf349bd842f6472c88bb165c14ba046250
translateEnumValue
private Descriptors.EnumValueDescriptor translateEnumValue(Binary binaryValue)
{    Descriptors.EnumValueDescriptor protoValue = enumLookup.get(binaryValue);    if (protoValue == null) {        Set<Binary> knownValues = enumLookup.keySet();        String msg = "Illegal enum value \"" + binaryValue + "\"" + " in protocol buffer \"" + fieldType.getFullName() + "\"" + " legal values are: \"" + knownValues + "\"";        throw new InvalidRecordException(msg);    }    return protoValue;}
b6abf0f2052a5bd43728e7f777e171112aa7ab62fbb44a30fbf8cba89907b2c5
addBinary
public final void addBinary(Binary binaryValue)
{    Descriptors.EnumValueDescriptor protoValue = translateEnumValue(binaryValue);    parent.add(protoValue);}
f1649786c3679c86c0157574e47953673714091cc71d598cedff963593010d98
addValueFromDictionary
public void addValueFromDictionary(int dictionaryId)
{    parent.add(dict[dictionaryId]);}
7c3f73c96e69cb35837e756142746fd240f40ccf1d7d310c2436e6b135fe196b
hasDictionarySupport
public boolean hasDictionarySupport()
{    return true;}
5edde50d3cb88777a151a88dae34321ada39b284501a5295564b122126c5c393
setDictionary
public void setDictionary(Dictionary dictionary)
{    dict = new Descriptors.EnumValueDescriptor[dictionary.getMaxId() + 1];    for (int i = 0; i <= dictionary.getMaxId(); i++) {        Binary binaryValue = dictionary.decodeToBinary(i);        dict[i] = translateEnumValue(binaryValue);    }}
362f9657196731e23b5a6a6475ef6bcce25e719ff4646e6181190b60b011b5cd
addBinary
public void addBinary(Binary binary)
{    ByteString byteString = ByteString.copyFrom(binary.toByteBuffer());    parent.add(byteString);}
954195d234288c19e659aa55edc4121b87eef181d6d86d58a96eaeb2fd0f77ba
addBoolean
public final void addBoolean(boolean value)
{    parent.add(value);}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    parent.add(value);}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    parent.add(value);}
a2ac1f40a6e220ec515710128c8baf77a725ad0b9f1767a998f776f27fff6cf6
addInt
public void addInt(int value)
{    parent.add(value);}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    parent.add(value);}
362f9657196731e23b5a6a6475ef6bcce25e719ff4646e6181190b60b011b5cd
addBinary
public void addBinary(Binary binary)
{    String str = binary.toStringUsingUTF8();    parent.add(str);}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    if (fieldIndex > 0) {        throw new ParquetDecodingException("Unexpected multiple fields in the LIST wrapper");    }    return new GroupConverter() {        @Override        public Converter getConverter(int fieldIndex) {            return converter;        }        @Override        public void start() {        }        @Override        public void end() {        }    };}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    return converter;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    if (fieldIndex > 0) {        throw new ParquetDecodingException("Unexpected multiple fields in the MAP wrapper");    }    return converter;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{}
e7c9269c59f522d69ae789b8454df52627abbb721155aee434e9ab6ca8a6f4d9
setRequestedProjection
public static void setRequestedProjection(Job job, String requestedProjection)
{    ProtoReadSupport.setRequestedProjection(ContextUtil.getConfiguration(job), requestedProjection);}
9b31887af319466b6c51a9d23353cd51ad22b3514c7c2ff9332e893455e754c3
setProtobufClass
public static void setProtobufClass(Job job, Class<? extends Message> protoClass)
{    ProtoWriteSupport.setSchema(ContextUtil.getConfiguration(job), protoClass);}
b0d50e3a2a70c0d0628f9227d52b8cbdce33d303401113d24a28c344e1d93a74
builder
public static Builder<T> builder(Path file)
{    return ParquetReader.builder(new ProtoReadSupport(), file);}
2209265430065f8b250a41566287c455ee00b9d66d0b654145e612551d919385
setRequestedProjection
public static void setRequestedProjection(Configuration configuration, String requestedProjection)
{    configuration.set(PB_REQUESTED_PROJECTION, requestedProjection);}
8fba545b3a9837befa59a2bdb4b2f2c303f5c66d7bd14a2e43af2686dda01ae1
setProtobufClass
public static void setProtobufClass(Configuration configuration, String protobufClass)
{    configuration.set(PB_CLASS, protobufClass);}
179fb3d7a903b204c2b4bf2b8050f64585c9b7e332f5069356f97fbb27f885e3
init
public ReadContext init(InitContext context)
{    String requestedProjectionString = context.getConfiguration().get(PB_REQUESTED_PROJECTION);    if (requestedProjectionString != null && !requestedProjectionString.trim().isEmpty()) {        MessageType requestedProjection = getSchemaForRead(context.getFileSchema(), requestedProjectionString);        LOG.debug("Reading data with projection {}", requestedProjection);        return new ReadContext(requestedProjection);    } else {        MessageType fileSchema = context.getFileSchema();        LOG.debug("Reading data with schema {}", fileSchema);        return new ReadContext(fileSchema);    }}
dcbc14ec02a60473c194a6ca67b9e82533789c178ba248e7971115229f645054
prepareForRead
public RecordMaterializer<T> prepareForRead(Configuration configuration, Map<String, String> keyValueMetaData, MessageType fileSchema, ReadContext readContext)
{    String headerProtoClass = keyValueMetaData.get(PB_CLASS);    String configuredProtoClass = configuration.get(PB_CLASS);    if (configuredProtoClass != null) {        LOG.debug("Replacing class " + headerProtoClass + " by " + configuredProtoClass);        headerProtoClass = configuredProtoClass;    }    if (headerProtoClass == null) {        throw new RuntimeException("I Need parameter " + PB_CLASS + " with Protocol Buffer class");    }    LOG.debug("Reading data with Protocol Buffer class {}", headerProtoClass);    MessageType requestedSchema = readContext.getRequestedSchema();    Class<? extends Message> protobufClass = Protobufs.getProtobufClass(headerProtoClass);    return new ProtoRecordMaterializer(requestedSchema, protobufClass);}
cd3e1ddecddf457d598ed0ad2f9926a128192e14ec227989d3b10a1b5d4a473b
add
public void add(Object a)
{    throw new RuntimeException("Should never happen");}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    reusedBuilder.clear();    super.start();}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{}
4da3915efeb45bd522ec756d13523540a507279d9a0b787efd2cafb4356363d1
getCurrentRecord
public T getCurrentRecord()
{    if (buildBefore) {        return (T) this.reusedBuilder.build();    } else {        return (T) this.reusedBuilder;    }}
541970d25ce9fe68bcaf2d517ba9d3c367e781031a8f08727bcb46cbfe1b3655
setBuildBefore
public void setBuildBefore(boolean buildBefore)
{    this.buildBefore = buildBefore;}
4da3915efeb45bd522ec756d13523540a507279d9a0b787efd2cafb4356363d1
getCurrentRecord
public T getCurrentRecord()
{    return root.getCurrentRecord();}
92fd854c4aebb01be238d83e407159211ea5cf60b5efd6fc7db8904dba13699b
getRootConverter
public GroupConverter getRootConverter()
{    return root;}
b8c5c8738e74eb779502d35da5c03a08866c915ea25265210d47af035eb65d74
convert
public MessageType convert(Class<? extends Message> protobufClass)
{    LOG.debug("Converting protocol buffer class \"" + protobufClass + "\" to parquet schema.");    Descriptors.Descriptor descriptor = Protobufs.getMessageDescriptor(protobufClass);    MessageType messageType = convertFields(Types.buildMessage(), descriptor.getFields()).named(descriptor.getFullName());    LOG.debug("Converter info:\n " + descriptor.toProto() + " was converted to \n" + messageType);    return messageType;}
7383db47fcb068d083ff915f21b772b23e651110ba8b4a1e0e6ef1c2213c6108
convertFields
private GroupBuilder<T> convertFields(GroupBuilder<T> groupBuilder, List<FieldDescriptor> fieldDescriptors)
{    for (FieldDescriptor fieldDescriptor : fieldDescriptors) {        groupBuilder = addField(fieldDescriptor, groupBuilder).id(fieldDescriptor.getNumber()).named(fieldDescriptor.getName());    }    return groupBuilder;}
2a4e5af1de51606277dc2c7a9b4f7cbf26dde57f28c00c98b114965589b5e3a3
getRepetition
private Type.Repetition getRepetition(FieldDescriptor descriptor)
{    if (descriptor.isRequired()) {        return Type.Repetition.REQUIRED;    } else if (descriptor.isRepeated()) {        return Type.Repetition.REPEATED;    } else {        return Type.Repetition.OPTIONAL;    }}
d1591d1ebf7a4c950f8e5ec5a43859cf0de5ae9444cb0073295b05c4ed5bae77
addField
private Builder<? extends Builder<?, GroupBuilder<T>>, GroupBuilder<T>> addField(FieldDescriptor descriptor, final GroupBuilder<T> builder)
{    if (descriptor.getJavaType() == JavaType.MESSAGE) {        return addMessageField(descriptor, builder);    }    ParquetType parquetType = getParquetType(descriptor);    if (descriptor.isRepeated() && parquetSpecsCompliant) {                return addRepeatedPrimitive(parquetType.primitiveType, parquetType.logicalTypeAnnotation, builder);    }    return builder.primitive(parquetType.primitiveType, getRepetition(descriptor)).as(parquetType.logicalTypeAnnotation);}
66335e8a223a576a2b949a639bc3336960300f76ef49193f7245d5cd9289f99b
addRepeatedPrimitive
private Builder<? extends Builder<?, GroupBuilder<T>>, GroupBuilder<T>> addRepeatedPrimitive(PrimitiveTypeName primitiveType, LogicalTypeAnnotation logicalTypeAnnotation, final GroupBuilder<T> builder)
{    return builder.group(Type.Repetition.OPTIONAL).as(listType()).group(Type.Repetition.REPEATED).primitive(primitiveType, Type.Repetition.REQUIRED).as(logicalTypeAnnotation).named("element").named("list");}
0ad9645833d1641d7806b8d1550a4c9e9d597efcb3d0fedea2665fbe67510a50
addRepeatedMessage
private GroupBuilder<GroupBuilder<T>> addRepeatedMessage(FieldDescriptor descriptor, GroupBuilder<T> builder)
{    GroupBuilder<GroupBuilder<GroupBuilder<GroupBuilder<T>>>> result = builder.group(Type.Repetition.OPTIONAL).as(listType()).group(Type.Repetition.REPEATED).group(Type.Repetition.OPTIONAL);    convertFields(result, descriptor.getMessageType().getFields());    return result.named("element").named("list");}
903ce633f0c6e719ac6852fbb6cfdf4b5fa07e9b45f06260b0f5ae68cc0d8e2a
addMessageField
private GroupBuilder<GroupBuilder<T>> addMessageField(FieldDescriptor descriptor, final GroupBuilder<T> builder)
{    if (descriptor.isMapField() && parquetSpecsCompliant) {                return addMapField(descriptor, builder);    }    if (descriptor.isRepeated() && parquetSpecsCompliant) {                return addRepeatedMessage(descriptor, builder);    }        GroupBuilder<GroupBuilder<T>> group = builder.group(getRepetition(descriptor));    convertFields(group, descriptor.getMessageType().getFields());    return group;}
0cbb468b7d3a2590f65759ab2d84e147d91fa2e41aa99513f507d698eccf0866
addMapField
private GroupBuilder<GroupBuilder<T>> addMapField(FieldDescriptor descriptor, final GroupBuilder<T> builder)
{    List<FieldDescriptor> fields = descriptor.getMessageType().getFields();    if (fields.size() != 2) {        throw new UnsupportedOperationException("Expected two fields for the map (key/value), but got: " + fields);    }    ParquetType mapKeyParquetType = getParquetType(fields.get(0));    GroupBuilder<GroupBuilder<GroupBuilder<T>>> group = builder.group(Type.Repetition.OPTIONAL).as(    mapType()).group(    Type.Repetition.REPEATED).primitive(mapKeyParquetType.primitiveType, Type.Repetition.REQUIRED).as(mapKeyParquetType.logicalTypeAnnotation).named("key");    return addField(fields.get(1), group).named("value").named("key_value");}
2ff3aa0e37816ad3faca073090b8bf12c7605096b955f383b30410e43db63a98
getParquetType
private ParquetType getParquetType(FieldDescriptor fieldDescriptor)
{    JavaType javaType = fieldDescriptor.getJavaType();    switch(javaType) {        case INT:            return ParquetType.of(INT32);        case LONG:            return ParquetType.of(INT64);        case DOUBLE:            return ParquetType.of(DOUBLE);        case BOOLEAN:            return ParquetType.of(BOOLEAN);        case FLOAT:            return ParquetType.of(FLOAT);        case STRING:            return ParquetType.of(BINARY, stringType());        case ENUM:            return ParquetType.of(BINARY, enumType());        case BYTE_STRING:            return ParquetType.of(BINARY);        default:            throw new UnsupportedOperationException("Cannot convert Protocol Buffer: unknown type " + javaType);    }}
cd1d2e7651636cee83488bc3bef077c243393f0ef88024159659313ea89ab26e
of
public static ParquetType of(PrimitiveTypeName primitiveType, LogicalTypeAnnotation logicalTypeAnnotation)
{    return new ParquetType(primitiveType, logicalTypeAnnotation);}
41ab5e8b5d98ca57a80240b127dd1909f9d1da03c20716cc6603ad725bebc4d4
of
public static ParquetType of(PrimitiveTypeName primitiveType)
{    return of(primitiveType, null);}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "protobuf";}
5ced4cabcc4685937fc9b234e75b80bb238dc3d17a3c99f9e0b60556c2a1ccef
setSchema
public static void setSchema(Configuration configuration, Class<? extends Message> protoClass)
{    configuration.setClass(PB_CLASS_WRITE, protoClass, Message.class);}
8792f87efa68a86a0bde7f8a329a6d8e5095816ba97d79a14240c6a7f48ade0a
setWriteSpecsCompliant
public static void setWriteSpecsCompliant(Configuration configuration, boolean writeSpecsCompliant)
{    configuration.setBoolean(PB_SPECS_COMPLIANT_WRITE, writeSpecsCompliant);}
e1dbc5a450a06f22ce2d7d2253403253153e3053cbf43f22851c97af786390af
write
public void write(T record)
{    recordConsumer.startMessage();    try {        messageWriter.writeTopLevelMessage(record);    } catch (RuntimeException e) {        Message m = (record instanceof Message.Builder) ? ((Message.Builder) record).build() : (Message) record;        LOG.error("Cannot write message " + e.getMessage() + " : " + m);        throw e;    }    recordConsumer.endMessage();}
da9aef78cf181856102b820ffa7d5248e8581747b3f0670a7b049c4649b962ef
prepareForWrite
public void prepareForWrite(RecordConsumer recordConsumer)
{    this.recordConsumer = recordConsumer;}
89835da140a91d5cb5181a85b8db073a92d794e99966f7422502dbb7d5467b7c
init
public WriteContext init(Configuration configuration)
{        if (protoMessage == null) {        Class<? extends Message> pbClass = configuration.getClass(PB_CLASS_WRITE, null, Message.class);        if (pbClass != null) {            protoMessage = pbClass;        } else {            String msg = "Protocol buffer class not specified.";            String hint = " Please use method ProtoParquetOutputFormat.setProtobufClass(...) or other similar method.";            throw new BadConfigurationException(msg + hint);        }    }    writeSpecsCompliant = configuration.getBoolean(PB_SPECS_COMPLIANT_WRITE, writeSpecsCompliant);    MessageType rootSchema = new ProtoSchemaConverter(writeSpecsCompliant).convert(protoMessage);    Descriptor messageDescriptor = Protobufs.getMessageDescriptor(protoMessage);    validatedMapping(messageDescriptor, rootSchema);    this.messageWriter = new MessageWriter(messageDescriptor, rootSchema);    Map<String, String> extraMetaData = new HashMap<String, String>();    extraMetaData.put(ProtoReadSupport.PB_CLASS, protoMessage.getName());    extraMetaData.put(ProtoReadSupport.PB_DESCRIPTOR, serializeDescriptor(protoMessage));    extraMetaData.put(PB_SPECS_COMPLIANT_WRITE, String.valueOf(writeSpecsCompliant));    return new WriteContext(rootSchema, extraMetaData);}
446a872a4a57553e9c8901ed80afce8bc197dde29ba7e44c201d8c984b8bd25d
setFieldName
 void setFieldName(String fieldName)
{    this.fieldName = fieldName;}
3752b5f397680429fb306974828e40939d0bb8db31dd25af327c44b93e60e278
setIndex
 void setIndex(int index)
{    this.index = index;}
5557669f3378bb131ed2d03f84a253a19cd6d62331ce3d3339ecc66cc31bf00c
writeRawValue
 void writeRawValue(Object value)
{}
a07a58961bee61411223eb0e384ebfe0653d49a1e26217be42347eb34e8fd731
writeField
 void writeField(Object value)
{    recordConsumer.startField(fieldName, index);    writeRawValue(value);    recordConsumer.endField(fieldName, index);}
fbbc951f02d19ebac41ba6c77906353e928c5393fa1d6ed665e7499185cf77b2
createWriter
private FieldWriter createWriter(FieldDescriptor fieldDescriptor, Type type)
{    switch(fieldDescriptor.getJavaType()) {        case STRING:            return new StringWriter();        case MESSAGE:            return createMessageWriter(fieldDescriptor, type);        case INT:            return new IntWriter();        case LONG:            return new LongWriter();        case FLOAT:            return new FloatWriter();        case DOUBLE:            return new DoubleWriter();        case ENUM:            return new EnumWriter();        case BOOLEAN:            return new BooleanWriter();        case BYTE_STRING:            return new BinaryWriter();    }        return unknownType(fieldDescriptor);}
54cde61c9d438789c9e6ca0d66558d5e6a850a910be6e04f6a6f391a2b5ca8ef
createMessageWriter
private FieldWriter createMessageWriter(FieldDescriptor fieldDescriptor, Type type)
{    if (fieldDescriptor.isMapField() && writeSpecsCompliant) {        return createMapWriter(fieldDescriptor, type);    }    return new MessageWriter(fieldDescriptor.getMessageType(), getGroupType(type));}
9a559bd467fa4e5d9a3aad2b71e70f444ad47d0ebf0d64c6facf1a429b436c36
getGroupType
private GroupType getGroupType(Type type)
{    LogicalTypeAnnotation logicalTypeAnnotation = type.getLogicalTypeAnnotation();    if (logicalTypeAnnotation == null) {        return type.asGroupType();    }    return logicalTypeAnnotation.accept(new LogicalTypeAnnotation.LogicalTypeAnnotationVisitor<GroupType>() {        @Override        public Optional<GroupType> visit(LogicalTypeAnnotation.ListLogicalTypeAnnotation listLogicalType) {            return ofNullable(type.asGroupType().getType("list").asGroupType().getType("element").asGroupType());        }        @Override        public Optional<GroupType> visit(LogicalTypeAnnotation.MapLogicalTypeAnnotation mapLogicalType) {            return ofNullable(type.asGroupType().getType("key_value").asGroupType().getType("value").asGroupType());        }    }).orElse(type.asGroupType());}
cdcfa4e151802ad3e1c1a5a011955c9748847a7805ed0b9959ee08a79ad9ef56
visit
public Optional<GroupType> visit(LogicalTypeAnnotation.ListLogicalTypeAnnotation listLogicalType)
{    return ofNullable(type.asGroupType().getType("list").asGroupType().getType("element").asGroupType());}
5c29cc96cbc5d5a234d83f6fa144d2d6a548c2b50057c968f63f5064400e9ffb
visit
public Optional<GroupType> visit(LogicalTypeAnnotation.MapLogicalTypeAnnotation mapLogicalType)
{    return ofNullable(type.asGroupType().getType("key_value").asGroupType().getType("value").asGroupType());}
69412d3ad234a84f4dea3a91ed066e453795e8bb0af5d2936b00cddb6626b15c
createMapWriter
private MapWriter createMapWriter(FieldDescriptor fieldDescriptor, Type type)
{    List<FieldDescriptor> fields = fieldDescriptor.getMessageType().getFields();    if (fields.size() != 2) {        throw new UnsupportedOperationException("Expected two fields for the map (key/value), but got: " + fields);    }        FieldDescriptor keyProtoField = fields.get(0);    FieldWriter keyWriter = createWriter(keyProtoField, type);    keyWriter.setFieldName(keyProtoField.getName());    keyWriter.setIndex(0);        FieldDescriptor valueProtoField = fields.get(1);    FieldWriter valueWriter = createWriter(valueProtoField, type);    valueWriter.setFieldName(valueProtoField.getName());    valueWriter.setIndex(1);    return new MapWriter(keyWriter, valueWriter);}
d49ddbe5c4bb504cb46d221fcfe4f4ddca41fae694dab14da8f4c90f8b9b7dc5
writeTopLevelMessage
 void writeTopLevelMessage(Object value)
{    writeAllFields((MessageOrBuilder) value);}
2eebe21c671004129a1e548a76969f59624d93e8ac8a6dd4f21886c49394f45c
writeRawValue
 final void writeRawValue(Object value)
{    recordConsumer.startGroup();    writeAllFields((MessageOrBuilder) value);    recordConsumer.endGroup();}
bb239cbbb797231ee45c0b35d5cd3abd4d561ec2677a316aee14bf2d08386acf
writeField
 final void writeField(Object value)
{    recordConsumer.startField(fieldName, index);    writeRawValue(value);    recordConsumer.endField(fieldName, index);}
c7a3d9faee264a1b320ee7fedb9585603e1dd379de069021e919c44eacc9e08f
writeAllFields
private void writeAllFields(MessageOrBuilder pb)
{        Map<FieldDescriptor, Object> changedPbFields = pb.getAllFields();    for (Map.Entry<FieldDescriptor, Object> entry : changedPbFields.entrySet()) {        FieldDescriptor fieldDescriptor = entry.getKey();        if (fieldDescriptor.isExtension()) {                        throw new UnsupportedOperationException("Cannot convert Protobuf message with extension field(s)");        }        int fieldIndex = fieldDescriptor.getIndex();        fieldWriters[fieldIndex].writeField(entry.getValue());    }}
2eebe21c671004129a1e548a76969f59624d93e8ac8a6dd4f21886c49394f45c
writeRawValue
 final void writeRawValue(Object value)
{    throw new UnsupportedOperationException("Array has no raw value");}
bb239cbbb797231ee45c0b35d5cd3abd4d561ec2677a316aee14bf2d08386acf
writeField
 final void writeField(Object value)
{    recordConsumer.startField(fieldName, index);    recordConsumer.startGroup();    List<?> list = (List<?>) value;        recordConsumer.startField("list", 0);    for (Object listEntry : list) {        recordConsumer.startGroup();                recordConsumer.startField("element", 0);        fieldWriter.writeRawValue(listEntry);        recordConsumer.endField("element", 0);        recordConsumer.endGroup();    }    recordConsumer.endField("list", 0);    recordConsumer.endGroup();    recordConsumer.endField(fieldName, index);}
2eebe21c671004129a1e548a76969f59624d93e8ac8a6dd4f21886c49394f45c
writeRawValue
 final void writeRawValue(Object value)
{    throw new UnsupportedOperationException("Array has no raw value");}
bb239cbbb797231ee45c0b35d5cd3abd4d561ec2677a316aee14bf2d08386acf
writeField
 final void writeField(Object value)
{    recordConsumer.startField(fieldName, index);    List<?> list = (List<?>) value;    for (Object listEntry : list) {        fieldWriter.writeRawValue(listEntry);    }    recordConsumer.endField(fieldName, index);}
58029451c8be9bf8e6663e8b925a505841854aa397a01c7ac7ab862dbc7af7de
validatedMapping
private void validatedMapping(Descriptor descriptor, GroupType parquetSchema)
{    List<FieldDescriptor> allFields = descriptor.getFields();    for (FieldDescriptor fieldDescriptor : allFields) {        String fieldName = fieldDescriptor.getName();        int fieldIndex = fieldDescriptor.getIndex();        int parquetIndex = parquetSchema.getFieldIndex(fieldName);        if (fieldIndex != parquetIndex) {            String message = "FieldIndex mismatch name=" + fieldName + ": " + fieldIndex + " != " + parquetIndex;            throw new IncompatibleSchemaModificationException(message);        }    }}
2eebe21c671004129a1e548a76969f59624d93e8ac8a6dd4f21886c49394f45c
writeRawValue
 final void writeRawValue(Object value)
{    Binary binaryString = Binary.fromString((String) value);    recordConsumer.addBinary(binaryString);}
2eebe21c671004129a1e548a76969f59624d93e8ac8a6dd4f21886c49394f45c
writeRawValue
 final void writeRawValue(Object value)
{    recordConsumer.addInteger((Integer) value);}
2eebe21c671004129a1e548a76969f59624d93e8ac8a6dd4f21886c49394f45c
writeRawValue
 final void writeRawValue(Object value)
{    recordConsumer.addLong((Long) value);}
2eebe21c671004129a1e548a76969f59624d93e8ac8a6dd4f21886c49394f45c
writeRawValue
 final void writeRawValue(Object value)
{    recordConsumer.startGroup();        recordConsumer.startField("key_value", 0);    for (Message msg : (Collection<Message>) value) {        recordConsumer.startGroup();        final Descriptor descriptorForType = msg.getDescriptorForType();        final FieldDescriptor keyDesc = descriptorForType.findFieldByName("key");        final FieldDescriptor valueDesc = descriptorForType.findFieldByName("value");        keyWriter.writeField(msg.getField(keyDesc));        valueWriter.writeField(msg.getField(valueDesc));        recordConsumer.endGroup();    }    recordConsumer.endField("key_value", 0);    recordConsumer.endGroup();}
2eebe21c671004129a1e548a76969f59624d93e8ac8a6dd4f21886c49394f45c
writeRawValue
 final void writeRawValue(Object value)
{    recordConsumer.addFloat((Float) value);}
2eebe21c671004129a1e548a76969f59624d93e8ac8a6dd4f21886c49394f45c
writeRawValue
 final void writeRawValue(Object value)
{    recordConsumer.addDouble((Double) value);}
2eebe21c671004129a1e548a76969f59624d93e8ac8a6dd4f21886c49394f45c
writeRawValue
 final void writeRawValue(Object value)
{    Binary binary = Binary.fromString(((Descriptors.EnumValueDescriptor) value).getName());    recordConsumer.addBinary(binary);}
2eebe21c671004129a1e548a76969f59624d93e8ac8a6dd4f21886c49394f45c
writeRawValue
 final void writeRawValue(Object value)
{    recordConsumer.addBoolean((Boolean) value);}
2eebe21c671004129a1e548a76969f59624d93e8ac8a6dd4f21886c49394f45c
writeRawValue
 final void writeRawValue(Object value)
{    ByteString byteString = (ByteString) value;    Binary binary = Binary.fromConstantByteArray(byteString.toByteArray());    recordConsumer.addBinary(binary);}
f421ed6620839745a0de0a0f35938b337084dae2782d241fa80b44dccad9d998
unknownType
private FieldWriter unknownType(FieldDescriptor fieldDescriptor)
{    String exceptionMsg = "Unknown type with descriptor \"" + fieldDescriptor + "\" and type \"" + fieldDescriptor.getJavaType() + "\".";    throw new InvalidRecordException(exceptionMsg);}
a779a1baa38ded1dc4ced02f70001364d2963244e42f1362fe77b14dd5911afc
serializeDescriptor
private String serializeDescriptor(Class<? extends Message> protoClass)
{    Descriptor descriptor = Protobufs.getMessageDescriptor(protoClass);    DescriptorProtos.DescriptorProto asProto = descriptor.toProto();    return TextFormat.printToString(asProto);}
4413d08048fe42e03c14402dc2a130370dfac8649e1214d97ec61873c5034559
testInputOutput
public void testInputOutput() throws Exception
{    TestProtobuf.IOFormatMessage input;    {        TestProtobuf.IOFormatMessage.Builder msg = TestProtobuf.IOFormatMessage.newBuilder();        msg.setOptionalDouble(666);        msg.addRepeatedString("Msg1");        msg.addRepeatedString("Msg2");        msg.getMsgBuilder().setSomeId(323);        input = msg.build();    }    List<Message> result = runMRJobs(input);    assertEquals(1, result.size());    TestProtobuf.IOFormatMessage output = (TestProtobuf.IOFormatMessage) result.get(0);    assertEquals(666, output.getOptionalDouble(), 0.00001);    assertEquals(323, output.getMsg().getSomeId());    assertEquals("Msg1", output.getRepeatedString(0));    assertEquals("Msg2", output.getRepeatedString(1));    assertEquals(input, output);}
88d30bd7cccdbe3007ca185b59f45204809752e87d2c8f59a9a19f40fc5f11d3
testProto3InputOutput
public void testProto3InputOutput() throws Exception
{    TestProto3.IOFormatMessage input;    {        TestProto3.IOFormatMessage.Builder msg = TestProto3.IOFormatMessage.newBuilder();        msg.setOptionalDouble(666);        msg.addRepeatedString("Msg1");        msg.addRepeatedString("Msg2");        msg.getMsgBuilder().setSomeId(323);        input = msg.build();    }    List<Message> result = runMRJobs(input);    assertEquals(1, result.size());    TestProto3.IOFormatMessage output = (TestProto3.IOFormatMessage) result.get(0);    assertEquals(666, output.getOptionalDouble(), 0.00001);    assertEquals(323, output.getMsg().getSomeId());    assertEquals("Msg1", output.getRepeatedString(0));    assertEquals("Msg2", output.getRepeatedString(1));    assertEquals(input, output);}
13d2cf1d3e5b307343f7ca76a2c5299e25fd4739172332fafb37a67e27d08553
testProjection
public void testProjection() throws Exception
{    TestProtobuf.Document.Builder writtenDocument = TestProtobuf.Document.newBuilder();    writtenDocument.setDocId(12345);    writtenDocument.addNameBuilder().setUrl("http://goout.cz/");    Path outputPath = new WriteUsingMR().write(writtenDocument.build());        ReadUsingMR reader = new ReadUsingMR();    String projection = "message Document {required int64 DocId; }";    reader.setRequestedProjection(projection);    List<Message> output = reader.read(outputPath);    TestProtobuf.Document readDocument = (TestProtobuf.Document) output.get(0);        assertTrue(readDocument.hasDocId());    assertTrue("Found data outside projection.", readDocument.getNameCount() == 0);}
d7924f47e1b9841cc9b85e4b6174e8e4cb0325ee849edb8e4c0b393959ef2bd4
testProto3Projection
public void testProto3Projection() throws Exception
{    TestProto3.Document.Builder writtenDocument = TestProto3.Document.newBuilder();    writtenDocument.setDocId(12345);    writtenDocument.addNameBuilder().setUrl("http://goout.cz/");    Path outputPath = new WriteUsingMR().write(writtenDocument.build());        ReadUsingMR reader = new ReadUsingMR();    String projection = "message Document {optional int64 DocId; }";    reader.setRequestedProjection(projection);    List<Message> output = reader.read(outputPath);    TestProto3.Document readDocument = (TestProto3.Document) output.get(0);        assertTrue(readDocument.getDocId() == 12345);    assertTrue(readDocument.getNameCount() == 0);    assertTrue("Found data outside projection.", readDocument.getNameCount() == 0);}
fcb214413ccf9ef297cc70a564ea0c7f78ac3931654b29f0e6b291b090a2e9fa
testCustomProtoClass
public void testCustomProtoClass() throws Exception
{    FirstCustomClassMessage.Builder inputMessage;    inputMessage = FirstCustomClassMessage.newBuilder();    inputMessage.setString("writtenString");    Path outputPath = new WriteUsingMR().write(new Message[] { inputMessage.build() });    ReadUsingMR readUsingMR = new ReadUsingMR();    String customClass = SecondCustomClassMessage.class.getName();    ProtoReadSupport.setProtobufClass(readUsingMR.getConfiguration(), customClass);    List<Message> result = readUsingMR.read(outputPath);    assertEquals(1, result.size());    Message msg = result.get(0);    assertFalse("Class from header returned.", msg instanceof FirstCustomClassMessage);    assertTrue("Custom class was not used", msg instanceof SecondCustomClassMessage);    String stringValue;    stringValue = ((SecondCustomClassMessage) msg).getString();    assertEquals("writtenString", stringValue);}
6725859521217a95e564e7fe62f12f88153810c1faea9e083eb793af5411d653
testProto3CustomProtoClass
public void testProto3CustomProtoClass() throws Exception
{    TestProto3.FirstCustomClassMessage.Builder inputMessage;    inputMessage = TestProto3.FirstCustomClassMessage.newBuilder();    inputMessage.setString("writtenString");    Path outputPath = new WriteUsingMR().write(new Message[] { inputMessage.build() });    ReadUsingMR readUsingMR = new ReadUsingMR();    String customClass = TestProto3.SecondCustomClassMessage.class.getName();    ProtoReadSupport.setProtobufClass(readUsingMR.getConfiguration(), customClass);    List<Message> result = readUsingMR.read(outputPath);    assertEquals(1, result.size());    Message msg = result.get(0);    assertFalse("Class from header returned.", msg instanceof TestProto3.FirstCustomClassMessage);    assertTrue("Custom class was not used", msg instanceof TestProto3.SecondCustomClassMessage);    String stringValue;    stringValue = ((TestProto3.SecondCustomClassMessage) msg).getString();    assertEquals("writtenString", stringValue);}
603923e400da59f62a73377f341ce06ecdff0293bb39e2dca02fef9bb0e6dd82
testRepeatedIntMessageClass
public void testRepeatedIntMessageClass() throws Exception
{    TestProtobuf.RepeatedIntMessage msgEmpty = TestProtobuf.RepeatedIntMessage.newBuilder().build();    TestProtobuf.RepeatedIntMessage msgNonEmpty = TestProtobuf.RepeatedIntMessage.newBuilder().addRepeatedInt(1).addRepeatedInt(2).build();    Path outputPath = new WriteUsingMR().write(msgEmpty, msgNonEmpty);    ReadUsingMR readUsingMR = new ReadUsingMR();    String customClass = TestProtobuf.RepeatedIntMessage.class.getName();    ProtoReadSupport.setProtobufClass(readUsingMR.getConfiguration(), customClass);    List<Message> result = readUsingMR.read(outputPath);    assertEquals(2, result.size());    assertEquals(msgEmpty, result.get(0));    assertEquals(msgNonEmpty, result.get(1));}
413895e0e997850780ed0b3f1b8b3933762dd8ed904e524848a652044ac48bc7
testRepeatedIntMessageClassSchemaCompliant
public void testRepeatedIntMessageClassSchemaCompliant() throws Exception
{    TestProtobuf.RepeatedIntMessage msgEmpty = TestProtobuf.RepeatedIntMessage.newBuilder().build();    TestProtobuf.RepeatedIntMessage msgNonEmpty = TestProtobuf.RepeatedIntMessage.newBuilder().addRepeatedInt(1).addRepeatedInt(2).build();    Configuration conf = new Configuration();    ProtoWriteSupport.setWriteSpecsCompliant(conf, true);    Path outputPath = new WriteUsingMR(conf).write(msgEmpty, msgNonEmpty);    ReadUsingMR readUsingMR = new ReadUsingMR();    String customClass = TestProtobuf.RepeatedIntMessage.class.getName();    ProtoReadSupport.setProtobufClass(readUsingMR.getConfiguration(), customClass);    List<Message> result = readUsingMR.read(outputPath);    assertEquals(2, result.size());    assertEquals(msgEmpty, result.get(0));    assertEquals(msgNonEmpty, result.get(1));}
7de37ba8365420a45ea4d780579736002fac8fc72e27fdc8639be1b4fe95cc21
testMapIntMessageClass
public void testMapIntMessageClass() throws Exception
{    TestProtobuf.MapIntMessage msgEmpty = TestProtobuf.MapIntMessage.newBuilder().build();    TestProtobuf.MapIntMessage msgNonEmpty = TestProtobuf.MapIntMessage.newBuilder().putMapInt(1, 123).putMapInt(2, 234).build();    Path outputPath = new WriteUsingMR().write(msgEmpty, msgNonEmpty);    ReadUsingMR readUsingMR = new ReadUsingMR();    String customClass = TestProtobuf.MapIntMessage.class.getName();    ProtoReadSupport.setProtobufClass(readUsingMR.getConfiguration(), customClass);    List<Message> result = readUsingMR.read(outputPath);    assertEquals(2, result.size());    assertEquals(msgEmpty, result.get(0));    assertEquals(msgNonEmpty, result.get(1));}
d4a66a20b4391607744f447a5e741399621dea30becf7b3e5d46b86e640e8f4a
testMapIntMessageClassSchemaCompliant
public void testMapIntMessageClassSchemaCompliant() throws Exception
{    TestProtobuf.MapIntMessage msgEmpty = TestProtobuf.MapIntMessage.newBuilder().build();    TestProtobuf.MapIntMessage msgNonEmpty = TestProtobuf.MapIntMessage.newBuilder().putMapInt(1, 123).putMapInt(2, 234).build();    Configuration conf = new Configuration();    ProtoWriteSupport.setWriteSpecsCompliant(conf, true);    Path outputPath = new WriteUsingMR(conf).write(msgEmpty, msgNonEmpty);    ReadUsingMR readUsingMR = new ReadUsingMR(conf);    String customClass = TestProtobuf.MapIntMessage.class.getName();    ProtoReadSupport.setProtobufClass(readUsingMR.getConfiguration(), customClass);    List<Message> result = readUsingMR.read(outputPath);    assertEquals(2, result.size());    assertEquals(msgEmpty, result.get(0));    assertEquals(msgNonEmpty, result.get(1));}
f3446fad613a93cec54501395c687637dd514400d6c5a520f8e23f68cc9f1670
testRepeatedInnerMessageClass
public void testRepeatedInnerMessageClass() throws Exception
{    TestProtobuf.RepeatedInnerMessage msgEmpty = TestProtobuf.RepeatedInnerMessage.newBuilder().build();    TestProtobuf.RepeatedInnerMessage msgNonEmpty = TestProtobuf.RepeatedInnerMessage.newBuilder().addRepeatedInnerMessage(TestProtobuf.InnerMessage.newBuilder().setOne("one").build()).addRepeatedInnerMessage(TestProtobuf.InnerMessage.newBuilder().setTwo("two").build()).build();    Path outputPath = new WriteUsingMR().write(msgEmpty, msgNonEmpty);    ReadUsingMR readUsingMR = new ReadUsingMR();    String customClass = TestProtobuf.RepeatedInnerMessage.class.getName();    ProtoReadSupport.setProtobufClass(readUsingMR.getConfiguration(), customClass);    List<Message> result = readUsingMR.read(outputPath);    assertEquals(2, result.size());    assertEquals(msgEmpty, result.get(0));    assertEquals(msgNonEmpty, result.get(1));}
bd688270fc3cc8429d543bbbb29df491f7cc379b594d1b50c88bcdd55b952bfc
testRepeatedInnerMessageClassSchemaCompliant
public void testRepeatedInnerMessageClassSchemaCompliant() throws Exception
{    TestProtobuf.RepeatedInnerMessage msgEmpty = TestProtobuf.RepeatedInnerMessage.newBuilder().build();    TestProtobuf.RepeatedInnerMessage msgNonEmpty = TestProtobuf.RepeatedInnerMessage.newBuilder().addRepeatedInnerMessage(TestProtobuf.InnerMessage.newBuilder().setOne("one").build()).addRepeatedInnerMessage(TestProtobuf.InnerMessage.newBuilder().setTwo("two").build()).build();    Configuration conf = new Configuration();    ProtoWriteSupport.setWriteSpecsCompliant(conf, true);    Path outputPath = new WriteUsingMR(conf).write(msgEmpty, msgNonEmpty);    ReadUsingMR readUsingMR = new ReadUsingMR(conf);    String customClass = TestProtobuf.RepeatedInnerMessage.class.getName();    ProtoReadSupport.setProtobufClass(readUsingMR.getConfiguration(), customClass);    List<Message> result = readUsingMR.read(outputPath);    assertEquals(2, result.size());    assertEquals(msgEmpty, result.get(0));    assertEquals(msgNonEmpty, result.get(1));}
288c98e31af7fe32395a6ce2ec0882f96cfdcf4c521f5e9a6d7326de2b9f5f0e
runMRJobs
public static List<Message> runMRJobs(Message... messages) throws Exception
{    Path outputPath = new WriteUsingMR().write(messages);    List<Message> result = new ReadUsingMR().read(outputPath);    return result;}
c717b6ac97344f5da0133974970b8f753098a5890d650bb2c6ae2b713a92d8c0
testAllTypes
public void testAllTypes() throws Exception
{    SchemaConverterAllDatatypes.Builder data;    data = SchemaConverterAllDatatypes.newBuilder();    data.setOptionalBool(true);    data.setOptionalBytes(ByteString.copyFrom("someText", "UTF-8"));    data.setOptionalDouble(0.577);    data.setOptionalFloat(3.1415f);    data.setOptionalEnum(SchemaConverterAllDatatypes.TestEnum.FIRST);    data.setOptionalFixed32(1000 * 1000 * 1);    data.setOptionalFixed64(1000 * 1000 * 1000 * 2);    data.setOptionalInt32(1000 * 1000 * 3);    data.setOptionalInt64(1000L * 1000 * 1000 * 4);    data.setOptionalSFixed32(1000 * 1000 * 5);    data.setOptionalSFixed64(1000L * 1000 * 1000 * 6);    data.setOptionalSInt32(1000 * 1000 * 56);    data.setOptionalSInt64(1000L * 1000 * 1000 * 7);    data.setOptionalString("Good Will Hunting");    data.setOptionalUInt32(1000 * 1000 * 8);    data.setOptionalUInt64(1000L * 1000 * 1000 * 9);    data.getOptionalMessageBuilder().setSomeId(1984);    data.getPbGroupBuilder().setGroupInt(1492);    SchemaConverterAllDatatypes dataBuilt = data.build();    data.clear();    List<TestProtobuf.SchemaConverterAllDatatypes> result;    result = testData(dataBuilt);        SchemaConverterAllDatatypes o = result.get(0);    assertEquals("Good Will Hunting", o.getOptionalString());    assertEquals(true, o.getOptionalBool());    assertEquals(ByteString.copyFrom("someText", "UTF-8"), o.getOptionalBytes());    assertEquals(0.577, o.getOptionalDouble(), 0.00001);    assertEquals(3.1415f, o.getOptionalFloat(), 0.00001);    assertEquals(SchemaConverterAllDatatypes.TestEnum.FIRST, o.getOptionalEnum());    assertEquals(1000 * 1000 * 1, o.getOptionalFixed32());    assertEquals(1000 * 1000 * 1000 * 2, o.getOptionalFixed64());    assertEquals(1000 * 1000 * 3, o.getOptionalInt32());    assertEquals(1000L * 1000 * 1000 * 4, o.getOptionalInt64());    assertEquals(1000 * 1000 * 5, o.getOptionalSFixed32());    assertEquals(1000L * 1000 * 1000 * 6, o.getOptionalSFixed64());    assertEquals(1000 * 1000 * 56, o.getOptionalSInt32());    assertEquals(1000L * 1000 * 1000 * 7, o.getOptionalSInt64());    assertEquals(1000 * 1000 * 8, o.getOptionalUInt32());    assertEquals(1000L * 1000 * 1000 * 9, o.getOptionalUInt64());    assertEquals(1984, o.getOptionalMessage().getSomeId());    assertEquals(1492, o.getPbGroup().getGroupInt());}
fda055c2e88891be5a00843b6e270171106c4df2c014aff83e64884c796b108e
testProto3AllTypes
public void testProto3AllTypes() throws Exception
{    TestProto3.SchemaConverterAllDatatypes.Builder data;    data = TestProto3.SchemaConverterAllDatatypes.newBuilder();    data.setOptionalBool(true);    data.setOptionalBytes(ByteString.copyFrom("someText", "UTF-8"));    data.setOptionalDouble(0.577);    data.setOptionalFloat(3.1415f);    data.setOptionalEnum(TestProto3.SchemaConverterAllDatatypes.TestEnum.FIRST);    data.setOptionalFixed32(1000 * 1000 * 1);    data.setOptionalFixed64(1000 * 1000 * 1000 * 2);    data.setOptionalInt32(1000 * 1000 * 3);    data.setOptionalInt64(1000L * 1000 * 1000 * 4);    data.setOptionalSFixed32(1000 * 1000 * 5);    data.setOptionalSFixed64(1000L * 1000 * 1000 * 6);    data.setOptionalSInt32(1000 * 1000 * 56);    data.setOptionalSInt64(1000L * 1000 * 1000 * 7);    data.setOptionalString("Good Will Hunting");    data.setOptionalUInt32(1000 * 1000 * 8);    data.setOptionalUInt64(1000L * 1000 * 1000 * 9);    data.getOptionalMessageBuilder().setSomeId(1984);    TestProto3.SchemaConverterAllDatatypes dataBuilt = data.build();    data.clear();    List<TestProto3.SchemaConverterAllDatatypes> result;    result = testData(dataBuilt);        TestProto3.SchemaConverterAllDatatypes o = result.get(0);    assertEquals("Good Will Hunting", o.getOptionalString());    assertEquals(true, o.getOptionalBool());    assertEquals(ByteString.copyFrom("someText", "UTF-8"), o.getOptionalBytes());    assertEquals(0.577, o.getOptionalDouble(), 0.00001);    assertEquals(3.1415f, o.getOptionalFloat(), 0.00001);    assertEquals(TestProto3.SchemaConverterAllDatatypes.TestEnum.FIRST, o.getOptionalEnum());    assertEquals(1000 * 1000 * 1, o.getOptionalFixed32());    assertEquals(1000 * 1000 * 1000 * 2, o.getOptionalFixed64());    assertEquals(1000 * 1000 * 3, o.getOptionalInt32());    assertEquals(1000L * 1000 * 1000 * 4, o.getOptionalInt64());    assertEquals(1000 * 1000 * 5, o.getOptionalSFixed32());    assertEquals(1000L * 1000 * 1000 * 6, o.getOptionalSFixed64());    assertEquals(1000 * 1000 * 56, o.getOptionalSInt32());    assertEquals(1000L * 1000 * 1000 * 7, o.getOptionalSInt64());    assertEquals(1000 * 1000 * 8, o.getOptionalUInt32());    assertEquals(1000L * 1000 * 1000 * 9, o.getOptionalUInt64());    assertEquals(1984, o.getOptionalMessage().getSomeId());}
d402555f4aa438ee7bf5bd6e6f4ef5e13bea2e8ce0ddf9bf41c89d25992aebb5
testAllTypesMultiple
public void testAllTypesMultiple() throws Exception
{    int count = 100;    SchemaConverterAllDatatypes[] input = new SchemaConverterAllDatatypes[count];    for (int i = 0; i < count; i++) {        SchemaConverterAllDatatypes.Builder d = SchemaConverterAllDatatypes.newBuilder();        if (i % 2 != 0)            d.setOptionalBool(true);        if (i % 3 != 0)            d.setOptionalBytes(ByteString.copyFrom("someText " + i, "UTF-8"));        if (i % 4 != 0)            d.setOptionalDouble(0.577 * i);        if (i % 5 != 0)            d.setOptionalFloat(3.1415f * i);        if (i % 6 != 0)            d.setOptionalEnum(SchemaConverterAllDatatypes.TestEnum.FIRST);        if (i % 7 != 0)            d.setOptionalFixed32(1000 * i * 1);        if (i % 8 != 0)            d.setOptionalFixed64(1000 * i * 1000 * 2);        if (i % 9 != 0)            d.setOptionalInt32(1000 * i * 3);        if (i % 2 != 1)            d.setOptionalSFixed32(1000 * i * 5);        if (i % 3 != 1)            d.setOptionalSFixed64(1000 * i * 1000 * 6);        if (i % 4 != 1)            d.setOptionalSInt32(1000 * i * 56);        if (i % 5 != 1)            d.setOptionalSInt64(1000 * i * 1000 * 7);        if (i % 6 != 1)            d.setOptionalString("Good Will Hunting " + i);        if (i % 7 != 1)            d.setOptionalUInt32(1000 * i * 8);        if (i % 8 != 1)            d.setOptionalUInt64(1000 * i * 1000 * 9);        if (i % 9 != 1)            d.getOptionalMessageBuilder().setSomeId(1984 * i);        if (i % 2 != 1)            d.getPbGroupBuilder().setGroupInt(1492 * i);        if (i % 3 != 1)            d.setOptionalInt64(1000 * i * 1000 * 4);        input[i] = d.build();    }    List<TestProtobuf.SchemaConverterAllDatatypes> result;    result = testData(input);        assertEquals("Good Will Hunting 0", result.get(0).getOptionalString());    assertEquals("Good Will Hunting 90", result.get(90).getOptionalString());}
0421d8cebc596f90b38a6607797de74d34eed054216f46b5accac7acd354bfb1
testProto3AllTypesMultiple
public void testProto3AllTypesMultiple() throws Exception
{    int count = 100;    TestProto3.SchemaConverterAllDatatypes[] input = new TestProto3.SchemaConverterAllDatatypes[count];    for (int i = 0; i < count; i++) {        TestProto3.SchemaConverterAllDatatypes.Builder d = TestProto3.SchemaConverterAllDatatypes.newBuilder();        if (i % 2 != 0)            d.setOptionalBool(true);        if (i % 3 != 0)            d.setOptionalBytes(ByteString.copyFrom("someText " + i, "UTF-8"));        if (i % 4 != 0)            d.setOptionalDouble(0.577 * i);        if (i % 5 != 0)            d.setOptionalFloat(3.1415f * i);        if (i % 6 != 0)            d.setOptionalEnum(TestProto3.SchemaConverterAllDatatypes.TestEnum.FIRST);        if (i % 7 != 0)            d.setOptionalFixed32(1000 * i * 1);        if (i % 8 != 0)            d.setOptionalFixed64(1000 * i * 1000 * 2);        if (i % 9 != 0)            d.setOptionalInt32(1000 * i * 3);        if (i % 2 != 1)            d.setOptionalSFixed32(1000 * i * 5);        if (i % 3 != 1)            d.setOptionalSFixed64(1000 * i * 1000 * 6);        if (i % 4 != 1)            d.setOptionalSInt32(1000 * i * 56);        if (i % 5 != 1)            d.setOptionalSInt64(1000 * i * 1000 * 7);        if (i % 6 != 1)            d.setOptionalString("Good Will Hunting " + i);        if (i % 7 != 1)            d.setOptionalUInt32(1000 * i * 8);        if (i % 8 != 1)            d.setOptionalUInt64(1000 * i * 1000 * 9);        if (i % 9 != 1)            d.getOptionalMessageBuilder().setSomeId(1984 * i);        if (i % 3 != 1)            d.setOptionalInt64(1000 * i * 1000 * 4);        input[i] = d.build();    }    List<TestProto3.SchemaConverterAllDatatypes> result;    result = testData(input);        assertEquals("Good Will Hunting 0", result.get(0).getOptionalString());    assertEquals("Good Will Hunting 90", result.get(90).getOptionalString());}
c3c66abd1e4bf655f45ed1338f72bbf502d2d0e2c5cf7711257c7666d4cafe56
testDefaults
public void testDefaults() throws Exception
{    SchemaConverterAllDatatypes.Builder data;    data = SchemaConverterAllDatatypes.newBuilder();    List<SchemaConverterAllDatatypes> result = testData(data.build());    SchemaConverterAllDatatypes message = result.get(0);    assertEquals("", message.getOptionalString());    assertEquals(false, message.getOptionalBool());    assertEquals(0, message.getOptionalFixed32());}
075041afb1a04bad691f43a3d37d678533f1f9f915bd75e9fc247b5da851d670
testProto3Defaults
public void testProto3Defaults() throws Exception
{    TestProto3.SchemaConverterAllDatatypes.Builder data;    data = TestProto3.SchemaConverterAllDatatypes.newBuilder();    List<TestProto3.SchemaConverterAllDatatypes> result = testData(data.build());    TestProto3.SchemaConverterAllDatatypes message = result.get(0);    assertEquals("", message.getOptionalString());    assertEquals(false, message.getOptionalBool());    assertEquals(0, message.getOptionalFixed32());}
3e6c95354158dde00adaac8270b9bf0d337b12e09dcccb5551db1e72cceeb129
testRepeatedMessages
public void testRepeatedMessages() throws Exception
{    TestProtobuf.TopMessage.Builder top = TestProtobuf.TopMessage.newBuilder();    top.addInnerBuilder().setOne("First inner");    top.addInnerBuilder().setTwo("Second inner");    top.addInnerBuilder().setThree("Third inner");    TestProtobuf.TopMessage result = testData(top.build()).get(0);    assertEquals(3, result.getInnerCount());    TestProtobuf.InnerMessage first = result.getInner(0);    TestProtobuf.InnerMessage second = result.getInner(1);    TestProtobuf.InnerMessage third = result.getInner(2);    assertEquals("First inner", first.getOne());    assertFalse(first.hasTwo());    assertFalse(first.hasThree());    assertEquals("Second inner", second.getTwo());    assertFalse(second.hasOne());    assertFalse(second.hasThree());    assertEquals("Third inner", third.getThree());    assertFalse(third.hasOne());    assertFalse(third.hasTwo());}
ef5703287646cf90237ddab5a93d3452be391f8709848ab1802bd098187ec569
testProto3RepeatedMessages
public void testProto3RepeatedMessages() throws Exception
{    TestProto3.TopMessage.Builder top = TestProto3.TopMessage.newBuilder();    top.addInnerBuilder().setOne("First inner");    top.addInnerBuilder().setTwo("Second inner");    top.addInnerBuilder().setThree("Third inner");    TestProto3.TopMessage result = testData(top.build()).get(0);    assertEquals(3, result.getInnerCount());    TestProto3.InnerMessage first = result.getInner(0);    TestProto3.InnerMessage second = result.getInner(1);    TestProto3.InnerMessage third = result.getInner(2);    assertEquals("First inner", first.getOne());    assertTrue(first.getTwo().isEmpty());    assertTrue(first.getThree().isEmpty());    assertEquals("Second inner", second.getTwo());    assertTrue(second.getOne().isEmpty());    assertTrue(second.getThree().isEmpty());    assertEquals("Third inner", third.getThree());    assertTrue(third.getOne().isEmpty());    assertTrue(third.getTwo().isEmpty());}
05b9883db91644eb96d4e21d845a2aa219a324e0e47ecdf6440070ad9185199c
testRepeatedInt
public void testRepeatedInt() throws Exception
{    TestProtobuf.RepeatedIntMessage.Builder top = TestProtobuf.RepeatedIntMessage.newBuilder();    top.addRepeatedInt(1);    top.addRepeatedInt(2);    top.addRepeatedInt(3);    TestProtobuf.RepeatedIntMessage result = testData(top.build()).get(0);    assertEquals(3, result.getRepeatedIntCount());    assertEquals(1, result.getRepeatedInt(0));    assertEquals(2, result.getRepeatedInt(1));    assertEquals(3, result.getRepeatedInt(2));}
5dd14c100afa743b2ed9589b9360ef54140cf64175aabe44548f721ca059a3f9
testProto3RepeatedInt
public void testProto3RepeatedInt() throws Exception
{    TestProto3.RepeatedIntMessage.Builder top = TestProto3.RepeatedIntMessage.newBuilder();    top.addRepeatedInt(1);    top.addRepeatedInt(2);    top.addRepeatedInt(3);    TestProto3.RepeatedIntMessage result = testData(top.build()).get(0);    assertEquals(3, result.getRepeatedIntCount());    assertEquals(1, result.getRepeatedInt(0));    assertEquals(2, result.getRepeatedInt(1));    assertEquals(3, result.getRepeatedInt(2));}
3ea2bf4ab6acf918705058e79bc17337562c5f8573895e43bf42bcd79ad98808
testLargeProtobufferFieldId
public void testLargeProtobufferFieldId() throws Exception
{    TestProtobuf.HighIndexMessage.Builder builder = TestProtobuf.HighIndexMessage.newBuilder();    builder.addRepeatedInt(1);    builder.addRepeatedInt(2);    testData(builder.build());}
7d98ae3a5d169330133ac7f5f234ae34df32d3f86f8c46b93586dec314ee9341
testProto3LargeProtobufferFieldId
public void testProto3LargeProtobufferFieldId() throws Exception
{    TestProto3.HighIndexMessage.Builder builder = TestProto3.HighIndexMessage.newBuilder();    builder.addRepeatedInt(1);    builder.addRepeatedInt(2);    testData(builder.build());}
2bb1d2d0f5124197c68d1944a65d8fae36a1eb33dea0be0f58ed7c7c1edd28ce
testConversion
private void testConversion(Class<? extends Message> pbClass, String parquetSchemaString, boolean parquetSpecsCompliant) throws Exception
{    ProtoSchemaConverter protoSchemaConverter = new ProtoSchemaConverter(parquetSpecsCompliant);    MessageType schema = protoSchemaConverter.convert(pbClass);    MessageType expectedMT = MessageTypeParser.parseMessageType(parquetSchemaString);    assertEquals(expectedMT.toString(), schema.toString());}
a54f10dd2f914d71f8b0d4b63ff01c181bdf48dd0e1e04d8a7146788a781b9e9
testConversion
private void testConversion(Class<? extends Message> pbClass, String parquetSchemaString) throws Exception
{    testConversion(pbClass, parquetSchemaString, true);}
d5196dc213b31c40aa9b83c30e07a7e05ee952ffd360643f3f8907eab921bb50
testConvertAllDatatypes
public void testConvertAllDatatypes() throws Exception
{    String expectedSchema = "message TestProtobuf.SchemaConverterAllDatatypes {\n" + "  optional double optionalDouble = 1;\n" + "  optional float optionalFloat = 2;\n" + "  optional int32 optionalInt32 = 3;\n" + "  optional int64 optionalInt64 = 4;\n" + "  optional int32 optionalUInt32 = 5;\n" + "  optional int64 optionalUInt64 = 6;\n" + "  optional int32 optionalSInt32 = 7;\n" + "  optional int64 optionalSInt64 = 8;\n" + "  optional int32 optionalFixed32 = 9;\n" + "  optional int64 optionalFixed64 = 10;\n" + "  optional int32 optionalSFixed32 = 11;\n" + "  optional int64 optionalSFixed64 = 12;\n" + "  optional boolean optionalBool = 13;\n" + "  optional binary optionalString (UTF8) = 14;\n" + "  optional binary optionalBytes = 15;\n" + "  optional group optionalMessage = 16 {\n" + "    optional int32 someId = 3;\n" + "  }\n" + "  optional group pbgroup = 17 {\n" + "    optional int32 groupInt = 2;\n" + "  }\n" + " optional binary optionalEnum (ENUM)  = 18;" + "}";    testConversion(TestProtobuf.SchemaConverterAllDatatypes.class, expectedSchema);}
d238946117fde51c4ad6cde0afe722f50f3b1a734a2cfbced8e86aa68044ceb2
testProto3ConvertAllDatatypes
public void testProto3ConvertAllDatatypes() throws Exception
{    String expectedSchema = "message TestProto3.SchemaConverterAllDatatypes {\n" + "  optional double optionalDouble = 1;\n" + "  optional float optionalFloat = 2;\n" + "  optional int32 optionalInt32 = 3;\n" + "  optional int64 optionalInt64 = 4;\n" + "  optional int32 optionalUInt32 = 5;\n" + "  optional int64 optionalUInt64 = 6;\n" + "  optional int32 optionalSInt32 = 7;\n" + "  optional int64 optionalSInt64 = 8;\n" + "  optional int32 optionalFixed32 = 9;\n" + "  optional int64 optionalFixed64 = 10;\n" + "  optional int32 optionalSFixed32 = 11;\n" + "  optional int64 optionalSFixed64 = 12;\n" + "  optional boolean optionalBool = 13;\n" + "  optional binary optionalString (UTF8) = 14;\n" + "  optional binary optionalBytes = 15;\n" + "  optional group optionalMessage = 16 {\n" + "    optional int32 someId = 3;\n" + "  }\n" + "  optional binary optionalEnum (ENUM) = 18;" + "  optional int32 someInt32 = 19;" + "  optional binary someString (UTF8) = 20;" + "  optional group optionalMap (MAP) = 21 {\n" + "    repeated group key_value {\n" + "      required int64 key;\n" + "      optional group value {\n" + "        optional int32 someId = 3;\n" + "      }\n" + "    }\n" + "  }\n" + "}";    testConversion(TestProto3.SchemaConverterAllDatatypes.class, expectedSchema);}
055aae8ae6e043b261a07433a8cda939bb2648a575b61746c9cfb328bad73c6c
testConvertRepetition
public void testConvertRepetition() throws Exception
{    String expectedSchema = "message TestProtobuf.SchemaConverterRepetition {\n" + "  optional int32 optionalPrimitive = 1;\n" + "  required int32 requiredPrimitive = 2;\n" + "  optional group repeatedPrimitive (LIST) = 3 {\n" + "    repeated group list {\n" + "      required int32 element;\n" + "    }\n" + "  }\n" + "  optional group optionalMessage = 7 {\n" + "    optional int32 someId = 3;\n" + "  }\n" + "  required group requiredMessage = 8 {\n" + "    optional int32 someId= 3;\n" + "  }\n" + "  optional group repeatedMessage (LIST) = 9 {\n" + "    repeated group list {\n" + "      optional group element {\n" + "        optional int32 someId = 3;\n" + "      }\n" + "    }\n" + "  }" + "}";    testConversion(TestProtobuf.SchemaConverterRepetition.class, expectedSchema);}
10563b8e9be3c4e2a03fbb8810ec3edb49863df485382e42bdbeb29a7f416046
testProto3ConvertRepetition
public void testProto3ConvertRepetition() throws Exception
{    String expectedSchema = "message TestProto3.SchemaConverterRepetition {\n" + "  optional int32 optionalPrimitive = 1;\n" + "  optional group repeatedPrimitive (LIST) = 3 {\n" + "    repeated group list {\n" + "      required int32 element;\n" + "    }\n" + "  }\n" + "  optional group optionalMessage = 7 {\n" + "    optional int32 someId = 3;\n" + "  }\n" + "  optional group repeatedMessage (LIST) = 9 {\n" + "    repeated group list {\n" + "      optional group element {\n" + "        optional int32 someId = 3;\n" + "      }\n" + "    }\n" + "  }\n" + "}";    testConversion(TestProto3.SchemaConverterRepetition.class, expectedSchema);}
fb76aef1ba43836992ad57e0f5fb96c35fab916d4b07281f9a622ab16a7bbf11
testConvertRepeatedIntMessage
public void testConvertRepeatedIntMessage() throws Exception
{    String expectedSchema = "message TestProtobuf.RepeatedIntMessage {\n" + "  optional group repeatedInt (LIST) = 1 {\n" + "    repeated group list {\n" + "      required int32 element;\n" + "      }\n" + "    }\n" + "  }\n" + "}";    testConversion(TestProtobuf.RepeatedIntMessage.class, expectedSchema);}
4663fa330b06ab28ff163f4bd14ab29868303ec02c56d8257233ecf0de80e1cd
testConvertRepeatedIntMessageNonSpecsCompliant
public void testConvertRepeatedIntMessageNonSpecsCompliant() throws Exception
{    String expectedSchema = "message TestProtobuf.RepeatedIntMessage {\n" + "  repeated int32 repeatedInt = 1;\n" + "}";    testConversion(TestProtobuf.RepeatedIntMessage.class, expectedSchema, false);}
b932d63265e608bea1e26e3c15ac8bf7dead967b61469d4c589b68cd4992fc65
testProto3ConvertRepeatedIntMessage
public void testProto3ConvertRepeatedIntMessage() throws Exception
{    String expectedSchema = "message TestProto3.RepeatedIntMessage {\n" + "  optional group repeatedInt (LIST) = 1 {\n" + "    repeated group list {\n" + "      required int32 element;\n" + "      }\n" + "    }\n" + "  }\n" + "}";    testConversion(TestProto3.RepeatedIntMessage.class, expectedSchema);}
ab736d68e25f0e3c05d66b3dc336affed6c9e85f448d15751af45110f9376ce6
testProto3ConvertRepeatedIntMessageNonSpecsCompliant
public void testProto3ConvertRepeatedIntMessageNonSpecsCompliant() throws Exception
{    String expectedSchema = "message TestProto3.RepeatedIntMessage {\n" + "  repeated int32 repeatedInt = 1;\n" + "}";    testConversion(TestProto3.RepeatedIntMessage.class, expectedSchema, false);}
d438cedc3ffde2d94e9346e2ef57fa89dffa85a2d749837805792ce2ad53a83d
testConvertRepeatedInnerMessage
public void testConvertRepeatedInnerMessage() throws Exception
{    String expectedSchema = "message TestProtobuf.RepeatedInnerMessage {\n" + "  optional group repeatedInnerMessage (LIST) = 1 {\n" + "    repeated group list {\n" + "      optional group element {\n" + "        optional binary one (UTF8) = 1;\n" + "        optional binary two (UTF8) = 2;\n" + "        optional binary three (UTF8) = 3;\n" + "      }\n" + "    }\n" + "  }\n" + "}";    testConversion(TestProtobuf.RepeatedInnerMessage.class, expectedSchema);}
c43ccd83b984fb30b52febd0268d107144e0909d682a504a65a5d261adee65fb
testConvertRepeatedInnerMessageNonSpecsCompliant
public void testConvertRepeatedInnerMessageNonSpecsCompliant() throws Exception
{    String expectedSchema = "message TestProtobuf.RepeatedInnerMessage {\n" + "  repeated group repeatedInnerMessage = 1 {\n" + "    optional binary one (UTF8) = 1;\n" + "    optional binary two (UTF8) = 2;\n" + "    optional binary three (UTF8) = 3;\n" + "  }\n" + "}";    testConversion(TestProtobuf.RepeatedInnerMessage.class, expectedSchema, false);}
8c3bc0088ac9d5c37236b2c56ef6365e38cb587ffb9a9db4f49c6c18ab3ed24f
testProto3ConvertRepeatedInnerMessage
public void testProto3ConvertRepeatedInnerMessage() throws Exception
{    String expectedSchema = "message TestProto3.RepeatedInnerMessage {\n" + "  optional group repeatedInnerMessage (LIST) = 1 {\n" + "    repeated group list {\n" + "      optional group element {\n" + "        optional binary one (UTF8) = 1;\n" + "        optional binary two (UTF8) = 2;\n" + "        optional binary three (UTF8) = 3;\n" + "      }\n" + "    }\n" + "  }\n" + "}";    testConversion(TestProto3.RepeatedInnerMessage.class, expectedSchema);}
37d3050be009299eec63bebed948850e24f02ee5fd7076183b97d06ed85d65da
testProto3ConvertRepeatedInnerMessageNonSpecsCompliant
public void testProto3ConvertRepeatedInnerMessageNonSpecsCompliant() throws Exception
{    String expectedSchema = "message TestProto3.RepeatedInnerMessage {\n" + "  repeated group repeatedInnerMessage = 1 {\n" + "    optional binary one (UTF8) = 1;\n" + "    optional binary two (UTF8) = 2;\n" + "    optional binary three (UTF8) = 3;\n" + "  }\n" + "}";    testConversion(TestProto3.RepeatedInnerMessage.class, expectedSchema, false);}
c99bdf089dd355e6ad2e1c715113b2364ab90b63255cd9d4c7416c1c46bd62e3
testConvertMapIntMessage
public void testConvertMapIntMessage() throws Exception
{    String expectedSchema = "message TestProtobuf.MapIntMessage {\n" + "  optional group mapInt (MAP) = 1 {\n" + "    repeated group key_value {\n" + "      required int32 key;\n" + "      optional int32 value;\n" + "    }\n" + "  }\n" + "}";    testConversion(TestProtobuf.MapIntMessage.class, expectedSchema);}
acada72f9a547c5c4524be99b450ae5b51ea025d004771ce5089caf50d6b4894
testConvertMapIntMessageNonSpecsCompliant
public void testConvertMapIntMessageNonSpecsCompliant() throws Exception
{    String expectedSchema = "message TestProtobuf.MapIntMessage {\n" + "  repeated group mapInt = 1 {\n" + "    optional int32 key = 1;\n" + "    optional int32 value = 2;\n" + "  }\n" + "}";    testConversion(TestProtobuf.MapIntMessage.class, expectedSchema, false);}
c31f58d6f5d449e9b61659e30067e1472605a723877f553603810ce1cbeb9764
testProto3ConvertMapIntMessage
public void testProto3ConvertMapIntMessage() throws Exception
{    String expectedSchema = "message TestProto3.MapIntMessage {\n" + "  optional group mapInt (MAP) = 1 {\n" + "    repeated group key_value {\n" + "      required int32 key;\n" + "      optional int32 value;\n" + "    }\n" + "  }\n" + "}";    testConversion(TestProto3.MapIntMessage.class, expectedSchema);}
3a4ba64dfc82ba211a34b41a6d54a37c51396aa5b6c4deb56485c8e41b6ff3eb
testProto3ConvertMapIntMessageNonSpecsCompliant
public void testProto3ConvertMapIntMessageNonSpecsCompliant() throws Exception
{    String expectedSchema = "message TestProto3.MapIntMessage {\n" + "  repeated group mapInt = 1 {\n" + "    optional int32 key = 1;\n" + "    optional int32 value = 2;\n" + "  }\n" + "}";    testConversion(TestProto3.MapIntMessage.class, expectedSchema, false);}
4d225f02be9edb261f54aa566c2d38f31cdfbcf5db6530368d2bb662a64717ee
createReadConsumerInstance
private ProtoWriteSupport<T> createReadConsumerInstance(Class<T> cls, RecordConsumer readConsumerMock)
{    return createReadConsumerInstance(cls, readConsumerMock, new Configuration());}
496bc4db55e070f0267d690af31b24b6492dd80be817ebe0872d5f1a8540fbc5
createReadConsumerInstance
private ProtoWriteSupport<T> createReadConsumerInstance(Class<T> cls, RecordConsumer readConsumerMock, Configuration conf)
{    ProtoWriteSupport support = new ProtoWriteSupport(cls);    support.init(conf);    support.prepareForWrite(readConsumerMock);    return support;}
d7b42dd73a61240e20e25df9995e796eec079d9a3a79cfc092650dc5cc9a4c1f
testSimplestMessage
public void testSimplestMessage() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    ProtoWriteSupport instance = createReadConsumerInstance(TestProtobuf.InnerMessage.class, readConsumerMock);    TestProtobuf.InnerMessage.Builder msg = TestProtobuf.InnerMessage.newBuilder();    msg.setOne("oneValue");    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).startField("one", 0);    inOrder.verify(readConsumerMock).addBinary(Binary.fromString("oneValue"));    inOrder.verify(readConsumerMock).endField("one", 0);    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
c4aa74b21765770eb62d98da2f610691a08f31acf699d00620f084cf03834dfd
testProto3SimplestMessage
public void testProto3SimplestMessage() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    ProtoWriteSupport instance = createReadConsumerInstance(TestProto3.InnerMessage.class, readConsumerMock);    TestProto3.InnerMessage.Builder msg = TestProto3.InnerMessage.newBuilder();    msg.setOne("oneValue");    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).startField("one", 0);    inOrder.verify(readConsumerMock).addBinary(Binary.fromString("oneValue"));    inOrder.verify(readConsumerMock).endField("one", 0);    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
bb9a0d772f2e81ee24513751746497a4446b89596fd8ef67ba32ed2c005a5b0a
testRepeatedIntMessageSpecsCompliant
public void testRepeatedIntMessageSpecsCompliant() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    Configuration conf = new Configuration();    ProtoWriteSupport.setWriteSpecsCompliant(conf, true);    ProtoWriteSupport instance = createReadConsumerInstance(TestProtobuf.RepeatedIntMessage.class, readConsumerMock, conf);    TestProtobuf.RepeatedIntMessage.Builder msg = TestProtobuf.RepeatedIntMessage.newBuilder();    msg.addRepeatedInt(1323);    msg.addRepeatedInt(54469);    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).startField("repeatedInt", 0);    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("list", 0);    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("element", 0);    inOrder.verify(readConsumerMock).addInteger(1323);    inOrder.verify(readConsumerMock).endField("element", 0);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("element", 0);    inOrder.verify(readConsumerMock).addInteger(54469);    inOrder.verify(readConsumerMock).endField("element", 0);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("list", 0);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("repeatedInt", 0);    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
55a2c94e1be53078219a0b266a763e259db034a87edbec9c3237ce5613cceb7e
testRepeatedIntMessage
public void testRepeatedIntMessage() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    ProtoWriteSupport instance = createReadConsumerInstance(TestProtobuf.RepeatedIntMessage.class, readConsumerMock);    TestProtobuf.RepeatedIntMessage.Builder msg = TestProtobuf.RepeatedIntMessage.newBuilder();    msg.addRepeatedInt(1323);    msg.addRepeatedInt(54469);    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).startField("repeatedInt", 0);    inOrder.verify(readConsumerMock).addInteger(1323);    inOrder.verify(readConsumerMock).addInteger(54469);    inOrder.verify(readConsumerMock).endField("repeatedInt", 0);    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
818a1722c0a49049c3aff5e010150ff61ea197ffb6497a45bd553a910554cade
testRepeatedIntMessageEmptySpecsCompliant
public void testRepeatedIntMessageEmptySpecsCompliant() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    Configuration conf = new Configuration();    ProtoWriteSupport.setWriteSpecsCompliant(conf, true);    ProtoWriteSupport instance = createReadConsumerInstance(TestProtobuf.RepeatedIntMessage.class, readConsumerMock, conf);    TestProtobuf.RepeatedIntMessage.Builder msg = TestProtobuf.RepeatedIntMessage.newBuilder();    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
47e2c33cd5f29d926e6618730f2d973b28fa2fd1a6575ff207ca2b124aed05ba
testRepeatedIntMessageEmpty
public void testRepeatedIntMessageEmpty() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    ProtoWriteSupport instance = createReadConsumerInstance(TestProtobuf.RepeatedIntMessage.class, readConsumerMock);    TestProtobuf.RepeatedIntMessage.Builder msg = TestProtobuf.RepeatedIntMessage.newBuilder();    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
ccdaaec60f1b7ec18bbda18c009d83becd9e86b29a0bc2bd77ff8cb65f00b066
testProto3RepeatedIntMessageSpecsCompliant
public void testProto3RepeatedIntMessageSpecsCompliant() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    Configuration conf = new Configuration();    ProtoWriteSupport.setWriteSpecsCompliant(conf, true);    ProtoWriteSupport instance = createReadConsumerInstance(TestProto3.RepeatedIntMessage.class, readConsumerMock, conf);    TestProto3.RepeatedIntMessage.Builder msg = TestProto3.RepeatedIntMessage.newBuilder();    msg.addRepeatedInt(1323);    msg.addRepeatedInt(54469);    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).startField("repeatedInt", 0);    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("list", 0);    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("element", 0);    inOrder.verify(readConsumerMock).addInteger(1323);    inOrder.verify(readConsumerMock).endField("element", 0);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("element", 0);    inOrder.verify(readConsumerMock).addInteger(54469);    inOrder.verify(readConsumerMock).endField("element", 0);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("list", 0);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("repeatedInt", 0);    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
4bd6cb45a98af58f0a9ee57df5495d9856e7dca1842cce6fe88fe62fc82f02e4
testProto3RepeatedIntMessage
public void testProto3RepeatedIntMessage() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    ProtoWriteSupport instance = createReadConsumerInstance(TestProto3.RepeatedIntMessage.class, readConsumerMock);    TestProto3.RepeatedIntMessage.Builder msg = TestProto3.RepeatedIntMessage.newBuilder();    msg.addRepeatedInt(1323);    msg.addRepeatedInt(54469);    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).startField("repeatedInt", 0);    inOrder.verify(readConsumerMock).addInteger(1323);    inOrder.verify(readConsumerMock).addInteger(54469);    inOrder.verify(readConsumerMock).endField("repeatedInt", 0);    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
becbc2d34fa2a19b9d85a5f446ccbdd77f75fff85b58089b7a0b163ca82c3752
testProto3RepeatedIntMessageEmptySpecsCompliant
public void testProto3RepeatedIntMessageEmptySpecsCompliant() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    Configuration conf = new Configuration();    ProtoWriteSupport.setWriteSpecsCompliant(conf, true);    ProtoWriteSupport instance = createReadConsumerInstance(TestProtobuf.RepeatedIntMessage.class, readConsumerMock, conf);    TestProtobuf.RepeatedIntMessage.Builder msg = TestProtobuf.RepeatedIntMessage.newBuilder();    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
e4a3597e1761e6c5ee48c7d7e94d17e33e0a7bd821d73e754f1b39012bb34ada
testProto3RepeatedIntMessageEmpty
public void testProto3RepeatedIntMessageEmpty() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    ProtoWriteSupport instance = createReadConsumerInstance(TestProtobuf.RepeatedIntMessage.class, readConsumerMock);    TestProtobuf.RepeatedIntMessage.Builder msg = TestProtobuf.RepeatedIntMessage.newBuilder();    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
d66b8782e6a932d0da8227bd97dcc8048111bcdae4bca0e22cae9c484df1059e
testMapIntMessageSpecsCompliant
public void testMapIntMessageSpecsCompliant() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    Configuration conf = new Configuration();    ProtoWriteSupport.setWriteSpecsCompliant(conf, true);    ProtoWriteSupport instance = createReadConsumerInstance(TestProtobuf.MapIntMessage.class, readConsumerMock, conf);    TestProtobuf.MapIntMessage.Builder msg = TestProtobuf.MapIntMessage.newBuilder();    msg.putMapInt(123, 1);    msg.putMapInt(234, 2);    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).startField("mapInt", 0);    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("key_value", 0);    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("key", 0);    inOrder.verify(readConsumerMock).addInteger(123);    inOrder.verify(readConsumerMock).endField("key", 0);    inOrder.verify(readConsumerMock).startField("value", 1);    inOrder.verify(readConsumerMock).addInteger(1);    inOrder.verify(readConsumerMock).endField("value", 1);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("key", 0);    inOrder.verify(readConsumerMock).addInteger(234);    inOrder.verify(readConsumerMock).endField("key", 0);    inOrder.verify(readConsumerMock).startField("value", 1);    inOrder.verify(readConsumerMock).addInteger(2);    inOrder.verify(readConsumerMock).endField("value", 1);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("key_value", 0);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("mapInt", 0);    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
379fa3f6ee93bcb0f4da351f7a716df44deadd042e5ceb2e6c4e30a9c6da139d
testMapIntMessage
public void testMapIntMessage() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    ProtoWriteSupport instance = createReadConsumerInstance(TestProtobuf.MapIntMessage.class, readConsumerMock);    TestProtobuf.MapIntMessage.Builder msg = TestProtobuf.MapIntMessage.newBuilder();    msg.putMapInt(123, 1);    msg.putMapInt(234, 2);    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).startField("mapInt", 0);    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("key", 0);    inOrder.verify(readConsumerMock).addInteger(123);    inOrder.verify(readConsumerMock).endField("key", 0);    inOrder.verify(readConsumerMock).startField("value", 1);    inOrder.verify(readConsumerMock).addInteger(1);    inOrder.verify(readConsumerMock).endField("value", 1);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("key", 0);    inOrder.verify(readConsumerMock).addInteger(234);    inOrder.verify(readConsumerMock).endField("key", 0);    inOrder.verify(readConsumerMock).startField("value", 1);    inOrder.verify(readConsumerMock).addInteger(2);    inOrder.verify(readConsumerMock).endField("value", 1);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("mapInt", 0);    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
71a8ae464d73ac51dad097afc9c140fe3bafd85f30938fa4a810042373b6f237
testMapIntMessageEmptySpecsCompliant
public void testMapIntMessageEmptySpecsCompliant() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    Configuration conf = new Configuration();    ProtoWriteSupport.setWriteSpecsCompliant(conf, true);    ProtoWriteSupport instance = createReadConsumerInstance(TestProtobuf.MapIntMessage.class, readConsumerMock, conf);    TestProtobuf.MapIntMessage.Builder msg = TestProtobuf.MapIntMessage.newBuilder();    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
8f5e1901bd932473af341b0b25e9ecf43674bd0987feafdcb4961199b474e49e
testMapIntMessageEmpty
public void testMapIntMessageEmpty() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    ProtoWriteSupport instance = createReadConsumerInstance(TestProtobuf.MapIntMessage.class, readConsumerMock);    TestProtobuf.MapIntMessage.Builder msg = TestProtobuf.MapIntMessage.newBuilder();    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
a2c9ad36710973ab7277c35e302ff560c94bf99fbad64c1cd338dc72716aa2d8
testProto3MapIntMessageSpecsCompliant
public void testProto3MapIntMessageSpecsCompliant() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    Configuration conf = new Configuration();    ProtoWriteSupport.setWriteSpecsCompliant(conf, true);    ProtoWriteSupport instance = createReadConsumerInstance(TestProto3.MapIntMessage.class, readConsumerMock, conf);    TestProto3.MapIntMessage.Builder msg = TestProto3.MapIntMessage.newBuilder();    msg.putMapInt(123, 1);    msg.putMapInt(234, 2);    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).startField("mapInt", 0);    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("key_value", 0);    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("key", 0);    inOrder.verify(readConsumerMock).addInteger(123);    inOrder.verify(readConsumerMock).endField("key", 0);    inOrder.verify(readConsumerMock).startField("value", 1);    inOrder.verify(readConsumerMock).addInteger(1);    inOrder.verify(readConsumerMock).endField("value", 1);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("key", 0);    inOrder.verify(readConsumerMock).addInteger(234);    inOrder.verify(readConsumerMock).endField("key", 0);    inOrder.verify(readConsumerMock).startField("value", 1);    inOrder.verify(readConsumerMock).addInteger(2);    inOrder.verify(readConsumerMock).endField("value", 1);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("key_value", 0);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("mapInt", 0);    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
adc23260354cd8304d09d6d0018186ad8b6e0185f02dd7ef7abf02834dac6408
testProto3MapIntMessage
public void testProto3MapIntMessage() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    ProtoWriteSupport instance = createReadConsumerInstance(TestProto3.MapIntMessage.class, readConsumerMock);    TestProto3.MapIntMessage.Builder msg = TestProto3.MapIntMessage.newBuilder();    msg.putMapInt(123, 1);    msg.putMapInt(234, 2);    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).startField("mapInt", 0);    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("key", 0);    inOrder.verify(readConsumerMock).addInteger(123);    inOrder.verify(readConsumerMock).endField("key", 0);    inOrder.verify(readConsumerMock).startField("value", 1);    inOrder.verify(readConsumerMock).addInteger(1);    inOrder.verify(readConsumerMock).endField("value", 1);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("key", 0);    inOrder.verify(readConsumerMock).addInteger(234);    inOrder.verify(readConsumerMock).endField("key", 0);    inOrder.verify(readConsumerMock).startField("value", 1);    inOrder.verify(readConsumerMock).addInteger(2);    inOrder.verify(readConsumerMock).endField("value", 1);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("mapInt", 0);    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
37994dfe1fda0647e146046a200ca605aff74bd89ef101ce5b58ba38ed53a09e
testProto3MapIntMessageEmptySpecsCompliant
public void testProto3MapIntMessageEmptySpecsCompliant() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    Configuration conf = new Configuration();    ProtoWriteSupport.setWriteSpecsCompliant(conf, true);    ProtoWriteSupport instance = createReadConsumerInstance(TestProto3.MapIntMessage.class, readConsumerMock, conf);    TestProto3.MapIntMessage.Builder msg = TestProto3.MapIntMessage.newBuilder();    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
c9f65789ab50c8109f98fd2456c93e55a211fd093888386fc66231c8457070f6
testProto3MapIntMessageEmpty
public void testProto3MapIntMessageEmpty() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    ProtoWriteSupport instance = createReadConsumerInstance(TestProto3.MapIntMessage.class, readConsumerMock);    TestProto3.MapIntMessage.Builder msg = TestProto3.MapIntMessage.newBuilder();    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
6bc91a6fd27a1c98c7e571e69fe7bc4ef27f3e83514d8c83ff94d7193dc70a96
testRepeatedInnerMessageMessage_message
public void testRepeatedInnerMessageMessage_message() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    ProtoWriteSupport instance = createReadConsumerInstance(TestProtobuf.TopMessage.class, readConsumerMock);    TestProtobuf.TopMessage.Builder msg = TestProtobuf.TopMessage.newBuilder();    msg.addInnerBuilder().setOne("one").setTwo("two");    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).startField("inner", 0);    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("one", 0);    inOrder.verify(readConsumerMock).addBinary(Binary.fromConstantByteArray("one".getBytes()));    inOrder.verify(readConsumerMock).endField("one", 0);    inOrder.verify(readConsumerMock).startField("two", 1);    inOrder.verify(readConsumerMock).addBinary(Binary.fromConstantByteArray("two".getBytes()));    inOrder.verify(readConsumerMock).endField("two", 1);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("inner", 0);    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
84655a8e1c22d0550ea2e466e0cc0a135797ecd487db7dbf0d22cd3f516ee33c
testRepeatedInnerMessageSpecsCompliantMessage_message
public void testRepeatedInnerMessageSpecsCompliantMessage_message() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    Configuration conf = new Configuration();    ProtoWriteSupport.setWriteSpecsCompliant(conf, true);    ProtoWriteSupport instance = createReadConsumerInstance(TestProtobuf.TopMessage.class, readConsumerMock, conf);    TestProtobuf.TopMessage.Builder msg = TestProtobuf.TopMessage.newBuilder();    msg.addInnerBuilder().setOne("one").setTwo("two");    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).startField("inner", 0);    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("list", 0);    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("element", 0);    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("one", 0);    inOrder.verify(readConsumerMock).addBinary(Binary.fromConstantByteArray("one".getBytes()));    inOrder.verify(readConsumerMock).endField("one", 0);    inOrder.verify(readConsumerMock).startField("two", 1);    inOrder.verify(readConsumerMock).addBinary(Binary.fromConstantByteArray("two".getBytes()));    inOrder.verify(readConsumerMock).endField("two", 1);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("element", 0);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("list", 0);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("inner", 0);    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
f85f3d32f8046f941ebc9d016b5ef36f265ef7165d7ba71bcdac843066e6731c
testProto3RepeatedInnerMessageMessage_message
public void testProto3RepeatedInnerMessageMessage_message() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    ;    ProtoWriteSupport instance = createReadConsumerInstance(TestProto3.TopMessage.class, readConsumerMock);    TestProto3.TopMessage.Builder msg = TestProto3.TopMessage.newBuilder();    msg.addInnerBuilder().setOne("one").setTwo("two");    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).startField("inner", 0);    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("one", 0);    inOrder.verify(readConsumerMock).addBinary(Binary.fromConstantByteArray("one".getBytes()));    inOrder.verify(readConsumerMock).endField("one", 0);    inOrder.verify(readConsumerMock).startField("two", 1);    inOrder.verify(readConsumerMock).addBinary(Binary.fromConstantByteArray("two".getBytes()));    inOrder.verify(readConsumerMock).endField("two", 1);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("inner", 0);    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
320bd4da10b1280173c64b5a48358883b6a1a0e2da5f4821d945700fa9569e95
testProto3RepeatedInnerMessageSpecsCompliantMessage_message
public void testProto3RepeatedInnerMessageSpecsCompliantMessage_message() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    Configuration conf = new Configuration();    ProtoWriteSupport.setWriteSpecsCompliant(conf, true);    ProtoWriteSupport instance = createReadConsumerInstance(TestProto3.TopMessage.class, readConsumerMock, conf);    TestProto3.TopMessage.Builder msg = TestProto3.TopMessage.newBuilder();    msg.addInnerBuilder().setOne("one").setTwo("two");    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).startField("inner", 0);    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("list", 0);    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("element", 0);    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("one", 0);    inOrder.verify(readConsumerMock).addBinary(Binary.fromConstantByteArray("one".getBytes()));    inOrder.verify(readConsumerMock).endField("one", 0);    inOrder.verify(readConsumerMock).startField("two", 1);    inOrder.verify(readConsumerMock).addBinary(Binary.fromConstantByteArray("two".getBytes()));    inOrder.verify(readConsumerMock).endField("two", 1);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("element", 0);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("list", 0);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("inner", 0);    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
f1bb9ee6a1971c2c3ef716128b160347ca4e4632ae64cc2f3dcb8922ac3c9a4d
testRepeatedInnerMessageSpecsCompliantMessage_scalar
public void testRepeatedInnerMessageSpecsCompliantMessage_scalar() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    Configuration conf = new Configuration();    ProtoWriteSupport.setWriteSpecsCompliant(conf, true);    ProtoWriteSupport instance = createReadConsumerInstance(TestProtobuf.TopMessage.class, readConsumerMock, conf);    TestProtobuf.TopMessage.Builder msg = TestProtobuf.TopMessage.newBuilder();    msg.addInnerBuilder().setOne("one");    msg.addInnerBuilder().setTwo("two");    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).startField("inner", 0);    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("list", 0);        inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("element", 0);    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("one", 0);    inOrder.verify(readConsumerMock).addBinary(Binary.fromConstantByteArray("one".getBytes()));    inOrder.verify(readConsumerMock).endField("one", 0);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("element", 0);    inOrder.verify(readConsumerMock).endGroup();        inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("element", 0);    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("two", 1);    inOrder.verify(readConsumerMock).addBinary(Binary.fromConstantByteArray("two".getBytes()));    inOrder.verify(readConsumerMock).endField("two", 1);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("element", 0);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("list", 0);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("inner", 0);    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
282ca4111fc72d269c861159c2b016d1547129776571666751dbca1a5fe3387b
testRepeatedInnerMessageMessage_scalar
public void testRepeatedInnerMessageMessage_scalar() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    ProtoWriteSupport instance = createReadConsumerInstance(TestProtobuf.TopMessage.class, readConsumerMock);    TestProtobuf.TopMessage.Builder msg = TestProtobuf.TopMessage.newBuilder();    msg.addInnerBuilder().setOne("one");    msg.addInnerBuilder().setTwo("two");    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).startField("inner", 0);        inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("one", 0);    inOrder.verify(readConsumerMock).addBinary(Binary.fromConstantByteArray("one".getBytes()));    inOrder.verify(readConsumerMock).endField("one", 0);    inOrder.verify(readConsumerMock).endGroup();        inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("two", 1);    inOrder.verify(readConsumerMock).addBinary(Binary.fromConstantByteArray("two".getBytes()));    inOrder.verify(readConsumerMock).endField("two", 1);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("inner", 0);    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
2888558b1d7a8be88d3b9fb1d95d2060c0cb59c6d72c2a6fe453aa51424ed2db
testProto3RepeatedInnerMessageMessage_scalar
public void testProto3RepeatedInnerMessageMessage_scalar() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    ProtoWriteSupport instance = createReadConsumerInstance(TestProto3.TopMessage.class, readConsumerMock);    TestProto3.TopMessage.Builder msg = TestProto3.TopMessage.newBuilder();    msg.addInnerBuilder().setOne("one");    msg.addInnerBuilder().setTwo("two");    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).startField("inner", 0);        inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("one", 0);    inOrder.verify(readConsumerMock).addBinary(Binary.fromConstantByteArray("one".getBytes()));    inOrder.verify(readConsumerMock).endField("one", 0);    inOrder.verify(readConsumerMock).endGroup();        inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("two", 1);    inOrder.verify(readConsumerMock).addBinary(Binary.fromConstantByteArray("two".getBytes()));    inOrder.verify(readConsumerMock).endField("two", 1);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("inner", 0);    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
2502836776737f823e9913bff3445242c3d649a3a4b46dc7d0ad26e60722d09e
testProto3RepeatedInnerMessageSpecsCompliantMessage_scalar
public void testProto3RepeatedInnerMessageSpecsCompliantMessage_scalar() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    Configuration conf = new Configuration();    ProtoWriteSupport.setWriteSpecsCompliant(conf, true);    ProtoWriteSupport instance = createReadConsumerInstance(TestProto3.TopMessage.class, readConsumerMock, conf);    TestProto3.TopMessage.Builder msg = TestProto3.TopMessage.newBuilder();    msg.addInnerBuilder().setOne("one");    msg.addInnerBuilder().setTwo("two");    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).startField("inner", 0);    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("list", 0);        inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("element", 0);    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("one", 0);    inOrder.verify(readConsumerMock).addBinary(Binary.fromConstantByteArray("one".getBytes()));    inOrder.verify(readConsumerMock).endField("one", 0);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("element", 0);    inOrder.verify(readConsumerMock).endGroup();        inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("element", 0);    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("two", 1);    inOrder.verify(readConsumerMock).addBinary(Binary.fromConstantByteArray("two".getBytes()));    inOrder.verify(readConsumerMock).endField("two", 1);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("element", 0);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("list", 0);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("inner", 0);    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
574763807055d5518320a0b1db2ff2b4a1c8d8100f5a36170501de47457a91ba
testOptionalInnerMessage
public void testOptionalInnerMessage() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    ProtoWriteSupport instance = createReadConsumerInstance(TestProtobuf.MessageA.class, readConsumerMock);    TestProtobuf.MessageA.Builder msg = TestProtobuf.MessageA.newBuilder();    msg.getInnerBuilder().setOne("one");    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).startField("inner", 0);    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("one", 0);    inOrder.verify(readConsumerMock).addBinary(Binary.fromConstantByteArray("one".getBytes()));    inOrder.verify(readConsumerMock).endField("one", 0);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("inner", 0);    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
4a5ce5d067f5c962be8a8ed6da17632fa0773096947a2b37a0179e636490f583
testProto3OptionalInnerMessage
public void testProto3OptionalInnerMessage() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    ProtoWriteSupport instance = createReadConsumerInstance(TestProto3.MessageA.class, readConsumerMock);    TestProto3.MessageA.Builder msg = TestProto3.MessageA.newBuilder();    msg.getInnerBuilder().setOne("one");    instance.write(msg.build());    InOrder inOrder = Mockito.inOrder(readConsumerMock);    inOrder.verify(readConsumerMock).startMessage();    inOrder.verify(readConsumerMock).startField("inner", 0);    inOrder.verify(readConsumerMock).startGroup();    inOrder.verify(readConsumerMock).startField("one", 0);    inOrder.verify(readConsumerMock).addBinary(Binary.fromConstantByteArray("one".getBytes()));    inOrder.verify(readConsumerMock).endField("one", 0);    inOrder.verify(readConsumerMock).endGroup();    inOrder.verify(readConsumerMock).endField("inner", 0);    inOrder.verify(readConsumerMock).endMessage();    Mockito.verifyNoMoreInteractions(readConsumerMock);}
90d982b31645eb4a2b0e7edb0a01bdf7d0df920c881ee210fa4f374589a9ae22
testMessageWithExtensions
public void testMessageWithExtensions() throws Exception
{    RecordConsumer readConsumerMock = Mockito.mock(RecordConsumer.class);    ProtoWriteSupport instance = createReadConsumerInstance(TestProtobuf.Vehicle.class, readConsumerMock);    TestProtobuf.Vehicle.Builder msg = TestProtobuf.Vehicle.newBuilder();    msg.setHorsePower(300);            msg.setExtension(TestProtobuf.Airplane.wingSpan, 50);    instance.write(msg.build());}
6717a0ca7f06c3556ba7786665e08b738293725b855c782128dfad48b03619db
someTemporaryFilePath
public static Path someTemporaryFilePath() throws IOException
{    File tmp = File.createTempFile("ParquetProtobuf_unitTest", ".tmp");    tmp.deleteOnExit();    tmp.delete();    return new Path(tmp.getPath());}
57298b5dcedbea1381cf07c170cea530d0e7d9ce8199d274137a1d8c629ff925
writeAndRead
public static List<T> writeAndRead(T... records) throws IOException
{    Class<? extends Message> cls = inferRecordsClass(records);    Path file = writeMessages(cls, records);    return readMessages(file);}
3f49333959010e9236973fc07600144060f3d072951f4f562deed81bf5093a05
inferRecordsClass
public static Class<? extends Message> inferRecordsClass(MessageOrBuilder[] records)
{    Class<? extends Message> cls = null;    for (MessageOrBuilder record : records) {        Class<? extends Message> recordClass;        if (record instanceof Message.Builder) {            recordClass = ((Message.Builder) record).build().getClass();        } else if (record instanceof Message) {            recordClass = ((Message) record).getClass();        } else {            throw new RuntimeException("Illegal class " + record);        }        if (cls == null) {            cls = recordClass;        } else if (!cls.equals(recordClass)) {            throw new RuntimeException("Class mismatch :" + cls + " and " + recordClass);        }    }    return cls;}
961ebc579f2408f36f8bc571c5a35d455f0f54e7d07728d83204f12875354220
testData
public static List<T> testData(T... messages) throws IOException
{    checkSameBuilderInstance(messages);    List<MessageOrBuilder> input = cloneList(messages);    List<MessageOrBuilder> output = (List<MessageOrBuilder>) writeAndRead(messages);    List<Message> outputAsMessages = asMessages(output);    assertEquals("The protocol buffers are not same:\n", asMessages(input), outputAsMessages);    return (List<T>) outputAsMessages;}
ab3dfd6d4120261c34382c9ee570c5127ff7523ba22589d91f0bf02a114a4e62
cloneList
private static List<MessageOrBuilder> cloneList(MessageOrBuilder[] messages)
{    List<MessageOrBuilder> result = new ArrayList<MessageOrBuilder>();    for (MessageOrBuilder mob : messages) {        result.add(asMessage(mob));    }    return result;}
52991aa9a4317faba6a4e18db171cbf6f7c8b485bbf8f2f81ca57289c9b9e966
asMessages
public static List<Message> asMessages(List<MessageOrBuilder> mobs)
{    List<Message> result = new ArrayList<Message>();    for (MessageOrBuilder messageOrBuilder : mobs) {        result.add(asMessage(messageOrBuilder));    }    return result;}
e49859409b646a4cd2ca0f3d5c9bef28020cdd3da608f65453cd3160dd5e81b3
asMessage
public static Message asMessage(MessageOrBuilder mob)
{    Message message;    if (mob instanceof Message.Builder) {        message = ((Message.Builder) mob).build();    } else {        message = (Message) mob;    }    return message;}
84cf1e01b028763c69ab9373c8ff672932fa0b49cd813ff1d3ce261cea260c50
checkSameBuilderInstance
private static void checkSameBuilderInstance(MessageOrBuilder[] messages)
{    for (int i = 0; i < messages.length; i++) {        MessageOrBuilder firstMessage = messages[i];        boolean isBuilder = firstMessage instanceof Message.Builder;        if (isBuilder) {            for (int j = 0; j < messages.length; j++) {                MessageOrBuilder secondMessage = messages[j];                if (i != j) {                    boolean isSame = secondMessage == firstMessage;                    if (isSame) {                        fail("Data contains two references to same instance." + secondMessage);                    }                }            }        }    }}
c1f037ca27e500220880e79c3a6ea31b3713ec10db19198b7e58651266d58da2
readMessages
public static List<T> readMessages(Path file) throws IOException
{    ProtoParquetReader<T> reader = new ProtoParquetReader<T>(file);    List<T> result = new ArrayList<T>();    boolean hasNext = true;    while (hasNext) {        T item = reader.read();        if (item == null) {            hasNext = false;        } else {            assertNotNull(item);                        result.add((T) asMessage(item).toBuilder());        }    }    reader.close();    return result;}
2e8c134b125da482b2ff71126879283f0a1253cbfbfff2596695d767ba597c6e
writeMessages
public static Path writeMessages(MessageOrBuilder... records) throws IOException
{    return writeMessages(inferRecordsClass(records), records);}
953e36c7afd125a272ccef1cc37a7e22f7ea120a6fafa586b44172a0e9bae6c7
writeMessages
public static Path writeMessages(Class<? extends Message> cls, MessageOrBuilder... records) throws IOException
{    Path file = someTemporaryFilePath();    ProtoParquetWriter<MessageOrBuilder> writer = new ProtoParquetWriter<MessageOrBuilder>(file, cls);    for (MessageOrBuilder record : records) {        writer.write(record);    }    writer.close();    return file;}
24145601f292a598b4cebd96d39c3c4bbe7ae9906e89b9e78b56e7864c6b554e
setRequestedProjection
public void setRequestedProjection(String projection)
{    this.projection = projection;}
4ab32fd1c0fc8b7e0975a577f547cc7a82d509b4844a391bcce9e94e9bd47854
getConfiguration
public Configuration getConfiguration()
{    return conf;}
ac73434b23d6b5ff0d99e096ad4a95865e8d3027c2cb2a220fa11691fe450adc
map
protected void map(Void key, MessageOrBuilder value, Context context)
{    Message clone = ((Message.Builder) value).build();    outputMessages.add(clone);}
ce2836b6a43a57f09049467b39727a44a175f8f8f7ccf8e688638852b6391a03
read
public List<Message> read(Path parquetPath) throws Exception
{    synchronized (ReadUsingMR.class) {        outputMessages = new ArrayList<Message>();        final Job job = new Job(conf, "read");        job.setInputFormatClass(ProtoParquetInputFormat.class);        ProtoParquetInputFormat.setInputPaths(job, parquetPath);        if (projection != null) {            ProtoParquetInputFormat.setRequestedProjection(job, projection);        }        job.setMapperClass(ReadingMapper.class);        job.setNumReduceTasks(0);        job.setOutputFormatClass(NullOutputFormat.class);        WriteUsingMR.waitForJob(job);        List<Message> result = Collections.unmodifiableList(outputMessages);        outputMessages = null;        return result;    }}
4ab32fd1c0fc8b7e0975a577f547cc7a82d509b4844a391bcce9e94e9bd47854
getConfiguration
public Configuration getConfiguration()
{    return conf;}
f1b79cd73081803aac4d597efe66cc1e35d6cdcd7d3d407951eb90b869e57624
run
public void run(Context context) throws IOException, InterruptedException
{    if (inputMessages == null || inputMessages.size() == 0) {        throw new RuntimeException("No mock data given");    } else {        for (Message msg : inputMessages) {            context.write(null, msg);            LOG.debug("Reading msg from mock writing mapper {}", msg);        }    }}
a8121984c16599567eb02155bc2655df4ae35dd9723faf1bc2302ccea514776f
write
public Path write(Message... messages) throws Exception
{    synchronized (WriteUsingMR.class) {        outputPath = TestUtils.someTemporaryFilePath();        Path inputPath = TestUtils.someTemporaryFilePath();        FileSystem fileSystem = inputPath.getFileSystem(conf);        fileSystem.create(inputPath);        inputMessages = Collections.unmodifiableList(Arrays.asList(messages));        final Job job = new Job(conf, "write");                TextInputFormat.addInputPath(job, inputPath);        job.setInputFormatClass(TextInputFormat.class);        job.setMapperClass(WritingMapper.class);        job.setNumReduceTasks(0);        job.setOutputFormatClass(ProtoParquetOutputFormat.class);        ProtoParquetOutputFormat.setOutputPath(job, outputPath);        ProtoParquetOutputFormat.setProtobufClass(job, TestUtils.inferRecordsClass(messages));        waitForJob(job);        inputMessages = null;        return outputPath;    }}
410b4dcd375375d2333f81090dcbf4b0306e67954a707931cd60489e4fb60d39
waitForJob
 static void waitForJob(Job job) throws Exception
{    job.submit();    while (!job.isComplete()) {        LOG.debug("waiting for job {}", job.getJobName());        sleep(50);    }    LOG.debug("status for job " + job.getJobName() + ": " + (job.isSuccessful() ? "SUCCESS" : "FAILURE"));    if (!job.isSuccessful()) {        throw new RuntimeException("job failed " + job.getJobName());    }}
97ee69e163bfe03a70639153115e36ba742b5d9543ac3a4464b34494571baff9
setScroogeClass
public static void setScroogeClass(Configuration configuration, Class<? extends ThriftStruct> thriftClass)
{    ScroogeWriteSupport.setScroogeClass(configuration, thriftClass);}
d9cd8c1497746cf444d869f7d8338608b4d02e7d097fe6c532c22c313ce80293
getScroogeClass
public static Class<? extends ThriftStruct> getScroogeClass(Configuration configuration)
{    return ScroogeWriteSupport.getScroogeClass(configuration);}
37cca28adcf19bb5011e6fa98d732b7078bc9ac65004a26651c50c2a48cbc811
sinkConfInit
public void sinkConfInit(FlowProcess<JobConf> fp, Tap<JobConf, RecordReader, OutputCollector> tap, JobConf jobConf)
{    DeprecatedParquetOutputFormat.setAsOutputFormat(jobConf);    ParquetOutputFormat.setWriteSupportClass(jobConf, ScroogeWriteSupport.class);    ScroogeWriteSupport.setScroogeClass(jobConf, this.config.getKlass());}
6542d259002d40e003f1c00e209397cdc8f1a747d4b2f7eca66c4e0eb42e4b5d
sourceConfInit
public void sourceConfInit(FlowProcess<JobConf> fp, Tap<JobConf, RecordReader, OutputCollector> tap, JobConf jobConf)
{    super.sourceConfInit(fp, tap, jobConf);    jobConf.setInputFormat(DeprecatedParquetInputFormat.class);    ParquetInputFormat.setReadSupportClass(jobConf, ScroogeReadSupport.class);    ThriftReadSupport.setRecordConverterClass(jobConf, ScroogeRecordConverter.class);}
90d9f35895bd8e24af114b4a4ecc7ce923185f2985c8d7e588f4cea537da81a7
getProjectedSchema
protected MessageType getProjectedSchema(FieldProjectionFilter fieldProjectionFilter)
{    ThriftType.StructType thriftStruct = new ScroogeStructConverter().convert(thriftClass);    return new ThriftSchemaConverter(fieldProjectionFilter).convert(thriftStruct);}
8182d44973372d035be1c8b728138b846911e548c213bb95b4abaf7683e1fc73
readOneRecord
public T readOneRecord(TProtocol protocol) throws TException
{    return codec.decode(protocol);}
09c1c1e4278e1930dc7fb9d9031f50f9494a17f75e276871b44bdc2ae1f7b09e
getCodec
private static ThriftStructCodec<?> getCodec(Class<?> klass)
{    Class<?> companionClass;    try {        companionClass = Class.forName(klass.getName() + "$");        Object companionObject = companionClass.getField("MODULE$").get(null);        return (ThriftStructCodec<?>) companionObject;    } catch (Exception t) {        if (t instanceof InterruptedException)            Thread.currentThread().interrupt();        throw new RuntimeException("Unable to create ThriftStructCodec", t);    }}
16efa1eb91c56dc9b57c1fa59365ae45f9adb1cf00159477ff63a56a99b47813
convert
public ThriftType.StructType convert(Class scroogeClass)
{    return convertStructFromClass(scroogeClass);}
4943c81c7a981947a498a38adb7edce5134e85c7376e758ce32fa22ff07dc3b6
mapKeyName
private static String mapKeyName(String fieldName)
{    return fieldName + "_map_key";}
6d5936ecf5a2e147201815394bddabe199379968ba98f91cde9516d0cfea431e
mapValueName
private static String mapValueName(String fieldName)
{    return fieldName + "_map_value";}
2704a481c59fc097031ae5b88dfd22e13e0bdf03fd292c05e01adf65a178c0c2
listElemName
private static String listElemName(String fieldName)
{    return fieldName + "_list_elem";}
f19f6fa468cd24b5e4468fc0408ddd2b35c21721d3b2ff00bfb65e1231dcef32
setElemName
private static String setElemName(String fieldName)
{    return fieldName + "_set_elem";}
bddababbb1040f89b4e42031d2b4a06a0e5bca485523e1f39fdf67c6120c0226
getCompanionClass
private Class getCompanionClass(Class klass)
{    try {        return Class.forName(klass.getName() + "$");    } catch (ClassNotFoundException e) {        throw new ScroogeSchemaConversionException("Can not find companion object for scrooge class " + klass, e);    }}
95a3dfd29a7482da3ce9cefe4c1a5d1b538665ba969b1a3dcd66c1eafb73650f
convertStructFromClass
private ThriftType.StructType convertStructFromClass(Class klass)
{    return convertCompanionClassToStruct(getCompanionClass(klass));}
48a56f690cf23986d6a12d539b1b48ca189a8649d0853043469f55863d1d3c5c
convertCompanionClassToStruct
private ThriftType.StructType convertCompanionClassToStruct(Class<?> companionClass)
{    ThriftStructCodec<?> companionObject;    try {        companionObject = (ThriftStructCodec<?>) companionClass.getField("MODULE$").get(null);    } catch (NoSuchFieldException e) {        throw new ScroogeSchemaConversionException("Can not get ThriftStructCodec from companion object of " + companionClass.getName(), e);    } catch (IllegalAccessException e) {        throw new ScroogeSchemaConversionException("Can not get ThriftStructCodec from companion object of " + companionClass.getName(), e);    }        List<ThriftField> children = new LinkedList<ThriftField>();    Iterable<ThriftStructFieldInfo> scroogeFields = getFieldInfos(companionObject);    for (ThriftStructFieldInfo field : scroogeFields) {        children.add(toThriftField(field));    }    StructOrUnionType structOrUnionType = isUnion(companionObject.getClass()) ? StructOrUnionType.UNION : StructOrUnionType.STRUCT;    return new ThriftType.StructType(children, structOrUnionType);}
773d5afac7f3f85b880c01cb2016708e120c3abc2d212173e56d5da5b81aead6
getFieldInfos
private Iterable<ThriftStructFieldInfo> getFieldInfos(ThriftStructCodec<?> c)
{    Class<? extends ThriftStructCodec> klass = c.getClass();    if (isUnion(klass)) {                return getFieldInfosForUnion(klass);    } else {                try {            Object r = klass.getMethod("fieldInfos").invoke(c);            return JavaConversions$.MODULE$.asJavaIterable((scala.collection.Iterable<ThriftStructFieldInfo>) r);        } catch (ClassCastException e) {            throw new ScroogeSchemaConversionException("can not get field Info from: " + c.toString(), e);        } catch (InvocationTargetException e) {            throw new ScroogeSchemaConversionException("can not get field Info from: " + c.toString(), e);        } catch (NoSuchMethodException e) {            throw new ScroogeSchemaConversionException("can not get field Info from: " + c.toString(), e);        } catch (IllegalAccessException e) {            throw new ScroogeSchemaConversionException("can not get field Info from: " + c.toString(), e);        }    }}
3deae0d0fbb507936f50a64d42b718cc3f17332d2bcd9380c53d674eac3f89d8
getFieldInfosForUnion
private Iterable<ThriftStructFieldInfo> getFieldInfosForUnion(Class klass)
{    ArrayList<ThriftStructFieldInfo> fields = new ArrayList<ThriftStructFieldInfo>();    for (Field f : klass.getDeclaredFields()) {        if (f.getType().equals(Manifest.class)) {            Class unionClass = (Class) ((ParameterizedType) f.getGenericType()).getActualTypeArguments()[0];            Class companionUnionClass = getCompanionClass(unionClass);            try {                Object companionUnionObj = companionUnionClass.getField("MODULE$").get(null);                ThriftStructFieldInfo info = (ThriftStructFieldInfo) companionUnionClass.getMethod("fieldInfo").invoke(companionUnionObj);                fields.add(info);            } catch (NoSuchFieldException e) {                throw new ScroogeSchemaConversionException("can not find fieldInfo for " + unionClass, e);            } catch (InvocationTargetException e) {                throw new ScroogeSchemaConversionException("can not find fieldInfo for " + unionClass, e);            } catch (NoSuchMethodException e) {                throw new ScroogeSchemaConversionException("can not find fieldInfo for " + unionClass, e);            } catch (IllegalAccessException e) {                throw new ScroogeSchemaConversionException("can not find fieldInfo for " + unionClass, e);            }        }    }    return fields;}
38ba8d63d0f1f4a7943cfa58dc87f00f9f643b291b7b7756cd35e213adaba98e
toThriftField
public ThriftField toThriftField(ThriftStructFieldInfo scroogeField)
{    Requirement requirement = getRequirementType(scroogeField);    String fieldName = scroogeField.tfield().name;    short fieldId = scroogeField.tfield().id;    byte thriftTypeByte = scroogeField.tfield().type;    ThriftTypeID typeId = ThriftTypeID.fromByte(thriftTypeByte);    ThriftType thriftType;    switch(typeId) {        case BOOL:            thriftType = new ThriftType.BoolType();            break;        case BYTE:            thriftType = new ThriftType.ByteType();            break;        case DOUBLE:            thriftType = new ThriftType.DoubleType();            break;        case I16:            thriftType = new ThriftType.I16Type();            break;        case I32:            thriftType = new ThriftType.I32Type();            break;        case I64:            thriftType = new ThriftType.I64Type();            break;        case STRING:            ThriftType.StringType stringType = new ThriftType.StringType();                        if (!String.class.equals(scroogeField.manifest().runtimeClass())) {                stringType.setBinary(true);            }            thriftType = stringType;            break;        case STRUCT:            thriftType = convertStructTypeField(scroogeField);            break;        case MAP:            thriftType = convertMapTypeField(scroogeField, requirement);            break;        case SET:            thriftType = convertSetTypeField(scroogeField, requirement);            break;        case LIST:            thriftType = convertListTypeField(scroogeField, requirement);            break;        case ENUM:            thriftType = convertEnumTypeField(scroogeField);            break;        case STOP:        case VOID:        default:            throw new IllegalArgumentException("can't convert type " + typeId);    }    return new ThriftField(fieldName, fieldId, requirement, thriftType);}
6408eecd4b63e6d41648f5fe8d07a8fdcd09623aec2bdb227275dbc0ab2e8aa4
convertSetTypeField
private ThriftType convertSetTypeField(ThriftStructFieldInfo f, Requirement requirement)
{    return convertSetTypeField(f.tfield().name, f.valueManifest().get(), requirement);}
f17baddead60d3afc3a1b37d6f8c0e531ef5cd57e007215ef23a4b75565ed568
convertSetTypeField
private ThriftType convertSetTypeField(String fieldName, Manifest<?> valueManifest, Requirement requirement)
{    String elemName = setElemName(fieldName);    ThriftType elementType = convertClassToThriftType(elemName, requirement, valueManifest);            ThriftField elementField = generateFieldWithoutId(elemName, requirement, elementType);    return new ThriftType.SetType(elementField);}
5bebab4960c55d7577e8193327fdd15cb3976f5befb93171eb63ed7195443e5b
convertListTypeField
private ThriftType convertListTypeField(ThriftStructFieldInfo f, Requirement requirement)
{    return convertListTypeField(f.tfield().name, f.valueManifest().get(), requirement);}
458468fdff6e18c512135bc0d23458703059424f4298cca4a0936764ce816d21
convertListTypeField
private ThriftType convertListTypeField(String fieldName, Manifest<?> valueManifest, Requirement requirement)
{    String elemName = listElemName(fieldName);    ThriftType elementType = convertClassToThriftType(elemName, requirement, valueManifest);    ThriftField elementField = generateFieldWithoutId(elemName, requirement, elementType);    return new ThriftType.ListType(elementField);}
174065c33718158c2e747b3f47d94708b6e707c4304247cc3231d94cea41bb4c
convertMapTypeField
private ThriftType convertMapTypeField(ThriftStructFieldInfo f, Requirement requirement)
{    return convertMapTypeField(f.tfield().name, f.keyManifest().get(), f.valueManifest().get(), requirement);}
06a73617895b674a269250dc163dbc82e514f5444aad2c8682aa8030090527cb
convertMapTypeField
private ThriftType convertMapTypeField(String fieldName, Manifest<?> keyManifest, Manifest<?> valueManifest, Requirement requirement)
{    String keyName = mapKeyName(fieldName);    String valueName = mapValueName(fieldName);    ThriftType keyType = convertClassToThriftType(keyName, requirement, keyManifest);    ThriftField keyField = generateFieldWithoutId(keyName, requirement, keyType);    ThriftType valueType = convertClassToThriftType(valueName, requirement, valueManifest);    ThriftField valueField = generateFieldWithoutId(valueName, requirement, valueType);    return new ThriftType.MapType(keyField, valueField);}
7d318432ab2927107fecba536bec0f6a1fccdddc3f5eed5cc6204efc6ac2297a
generateFieldWithoutId
private ThriftField generateFieldWithoutId(String fieldName, Requirement requirement, ThriftType thriftType)
{    return new ThriftField(fieldName, (short) 1, requirement, thriftType);}
81d63763d58c66b1ee7fc67568e88b1655ad51c9b8239ed6edd45d3f5925e7b8
convertClassToThriftType
private ThriftType convertClassToThriftType(String name, Requirement requirement, Manifest<?> typeManifest)
{    Class typeClass = typeManifest.runtimeClass();    if (typeManifest.runtimeClass() == boolean.class) {        return new ThriftType.BoolType();    } else if (typeClass == byte.class) {        return new ThriftType.ByteType();    } else if (typeClass == double.class) {        return new ThriftType.DoubleType();    } else if (typeClass == short.class) {        return new ThriftType.I16Type();    } else if (typeClass == int.class) {        return new ThriftType.I32Type();    } else if (typeClass == long.class) {        return new ThriftType.I64Type();    } else if (typeClass == String.class) {        return new ThriftType.StringType();    } else if (typeClass == ByteBuffer.class) {        return new ThriftType.StringType();    } else if (typeClass == scala.collection.Seq.class) {        Manifest<?> a = typeManifest.typeArguments().apply(0);        return convertListTypeField(name, a, requirement);    } else if (typeClass == scala.collection.Set.class) {        Manifest<?> setElementManifest = typeManifest.typeArguments().apply(0);        return convertSetTypeField(name, setElementManifest, requirement);    } else if (typeClass == scala.collection.Map.class) {        List<Manifest<?>> ms = JavaConversions.seqAsJavaList(typeManifest.typeArguments());        Manifest keyManifest = ms.get(0);        Manifest valueManifest = ms.get(1);        return convertMapTypeField(name, keyManifest, valueManifest, requirement);    } else if (com.twitter.scrooge.ThriftEnum.class.isAssignableFrom(typeClass)) {        return convertEnumTypeField(typeClass, name);    } else {        return convertStructFromClass(typeClass);    }}
78497d07b681c3819966b9c52ddf8c20b2406d577dea789da30f5cd43c030aaa
convertStructTypeField
private ThriftType convertStructTypeField(ThriftStructFieldInfo f)
{    return convertStructFromClass(f.manifest().runtimeClass());}
ec50a9079596c1db7dca9e8fb7f3361a6ad20b126007dbb35b217891cb758db4
getEnumList
private List getEnumList(String enumName) throws ClassNotFoundException, IllegalAccessException, NoSuchFieldException, NoSuchMethodException, InvocationTargetException
{        enumName += "$";    Class companionObjectClass = Class.forName(enumName);    Object cObject = companionObjectClass.getField("MODULE$").get(null);    Method listMethod = companionObjectClass.getMethod("list", new Class[] {});    Object result = listMethod.invoke(cObject, null);    return JavaConversions.seqAsJavaList((Seq) result);}
f2c4d9c7a3bfcdb2eedabfccc7b28b4adddad4a9cb60117db3cbb0cd07b3df54
convertEnumTypeField
public ThriftType convertEnumTypeField(ThriftStructFieldInfo f)
{    return convertEnumTypeField(f.manifest().runtimeClass(), f.tfield().name);}
c36d02151a7001d2fd5002cc166b299895a9d0c8855f2831cc930675caece10a
convertEnumTypeField
private ThriftType convertEnumTypeField(Class enumClass, String fieldName)
{    List<ThriftType.EnumValue> enumValues = new ArrayList<ThriftType.EnumValue>();    String enumName = enumClass.getName();    try {        List enumCollection = getEnumList(enumName);        for (Object enumObj : enumCollection) {            ScroogeEnumDesc enumDesc = ScroogeEnumDesc.fromEnum(enumObj);            enumValues.add(new ThriftType.EnumValue(enumDesc.id, enumDesc.originalName));        }        return new ThriftType.EnumType(enumValues);    } catch (RuntimeException e) {        throw new ScroogeSchemaConversionException("Can not convert enum field " + fieldName, e);    } catch (NoSuchMethodException e) {        throw new ScroogeSchemaConversionException("Can not convert enum field " + fieldName, e);    } catch (IllegalAccessException e) {        throw new ScroogeSchemaConversionException("Can not convert enum field " + fieldName, e);    } catch (NoSuchFieldException e) {        throw new ScroogeSchemaConversionException("Can not convert enum field " + fieldName, e);    } catch (InvocationTargetException e) {        throw new ScroogeSchemaConversionException("Can not convert enum field " + fieldName, e);    } catch (ClassNotFoundException e) {        throw new ScroogeSchemaConversionException("Can not convert enum field " + fieldName, e);    }}
fb954af8edc67baf613526fa0b960919e886d7b282eff2a3a048ccfa822ea197
isUnion
private boolean isUnion(Class klass)
{    for (Field f : klass.getDeclaredFields()) {        if (f.getName().equals("Union"))            return true;    }    return false;}
b28eb96dab2a3baeda3878b81af5977df1c13828a581e99b664566a4b4af34bb
getRequirementType
private Requirement getRequirementType(ThriftStructFieldInfo f)
{    if (f.isOptional() && !f.isRequired()) {        return OPTIONAL;    } else if (f.isRequired() && !f.isOptional()) {        return REQUIRED;    } else if (!f.isOptional() && !f.isRequired()) {        return DEFAULT;    } else {        throw new ScroogeSchemaConversionException("can not determine requirement type for : " + f.toString() + ", isOptional=" + f.isOptional() + ", isRequired=" + f.isRequired());    }}
5a983551796aae6497fe0277f899e575437ffa57d701f04813ed36e320ac783f
fromEnum
public static ScroogeEnumDesc fromEnum(Object rawScroogeEnum) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException
{    Class enumClass = rawScroogeEnum.getClass();    Method valueMethod = enumClass.getMethod("value", new Class[] {});    Method originalNameMethod = enumClass.getMethod("originalName", new Class[] {});    ScroogeEnumDesc result = new ScroogeEnumDesc();    result.id = (Integer) valueMethod.invoke(rawScroogeEnum, null);    result.originalName = (String) originalNameMethod.invoke(rawScroogeEnum, null);    return result;}
97ee69e163bfe03a70639153115e36ba742b5d9543ac3a4464b34494571baff9
setScroogeClass
public static void setScroogeClass(Configuration configuration, Class<? extends ThriftStruct> thriftClass)
{    AbstractThriftWriteSupport.setGenericThriftClass(configuration, thriftClass);}
d9cd8c1497746cf444d869f7d8338608b4d02e7d097fe6c532c22c313ce80293
getScroogeClass
public static Class<? extends ThriftStruct> getScroogeClass(Configuration configuration)
{    return (Class<? extends ThriftStruct>) AbstractThriftWriteSupport.getGenericThriftClass(configuration);}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "scrooge";}
46da48587fee2569e1997ae14209179a9bbf2b3bedc353505eab6fb2ea6d4ea8
getThriftStruct
protected StructType getThriftStruct()
{    ScroogeStructConverter schemaConverter = new ScroogeStructConverter();    return schemaConverter.convert(thriftClass);}
e1dbc5a450a06f22ce2d7d2253403253153e3053cbf43f22851c97af786390af
write
public void write(T record)
{    try {        record.write(parquetWriteProtocol);    } catch (TException e) {        throw new ParquetEncodingException(e);    }}
5f30f22696450cd3058f604560b3c217895eb98a7182a2f81e2ed619b0bcadf1
testWritePrimitveThriftReadScrooge
public void testWritePrimitveThriftReadScrooge() throws Exception
{    RequiredPrimitiveFixture toWrite = new RequiredPrimitiveFixture(true, (byte) 2, (short) 3, 4, (long) 5, 6.0, "7");    toWrite.setInfo_string("it's info");    verifyScroogeRead(thriftRecords(toWrite), org.apache.parquet.scrooge.test.RequiredPrimitiveFixture.class, "RequiredPrimitiveFixture(true,2,3,4,5,6.0,7,Some(it's info))\n", "**");}
c55ecf99f78b4961b40f12d690e874fa38f8b27ecd8be18e1e7cb218d82bfad1
testNestedReadingInScrooge
public void testNestedReadingInScrooge() throws Exception
{    Map<String, org.apache.parquet.thrift.test.Phone> phoneMap = new HashMap<String, Phone>();    phoneMap.put("key1", new org.apache.parquet.thrift.test.Phone("111", "222"));    org.apache.parquet.thrift.test.TestPersonWithAllInformation toWrite = new org.apache.parquet.thrift.test.TestPersonWithAllInformation(new org.apache.parquet.thrift.test.Name("first"), new Address("my_street", "my_zip"), phoneMap);    toWrite.setInfo("my_info");    String expected = "TestPersonWithAllInformation(Name(first,None),None,Address(my_street,my_zip),None,Some(my_info),Map(key1 -> Phone(111,222)),None,None)\n";    verifyScroogeRead(thriftRecords(toWrite), TestPersonWithAllInformation.class, expected, "**");    String expectedProjected = "TestPersonWithAllInformation(Name(first,None),None,Address(my_street,my_zip),None,Some(my_info),Map(),None,None)\n";    verifyScroogeRead(thriftRecords(toWrite), TestPersonWithAllInformation.class, expectedProjected, "address/*;info;name/first_name");}
249a384a8ce00b5a43e2eaae043a0c519fb43142ee17436c249f156bdecde0cf
operate
public void operate(FlowProcess flowProcess, FunctionCall functionCall)
{    Object record = functionCall.getArguments().getObject(0);    Tuple result = new Tuple();    result.add(record.toString());    functionCall.getOutputCollector().add(result);}
e08919687f3b7352b3fed784ad0e7b70d9d9e4f5a09716fc4a53fffb14899a75
verifyScroogeRead
public void verifyScroogeRead(List<TBase> recordsToWrite, Class<T> readClass, String expectedStr, String projectionFilter) throws Exception
{    Configuration conf = new Configuration();    deleteIfExist(PARQUET_PATH);    deleteIfExist(TXT_OUTPUT_PATH);    final Path parquetFile = new Path(PARQUET_PATH);    writeParquetFile(recordsToWrite, conf, parquetFile);    Scheme sourceScheme = new ParquetScroogeScheme(new Config().withRecordClass(readClass).withProjectionString(projectionFilter));    Tap source = new Hfs(sourceScheme, PARQUET_PATH);    Scheme sinkScheme = new TextLine(new Fields("first", "last"));    Tap sink = new Hfs(sinkScheme, TXT_OUTPUT_PATH);    Pipe assembly = new Pipe("namecp");    assembly = new Each(assembly, new ObjectToStringFunction());    Flow flow = new HadoopFlowConnector().connect("namecp", source, sink, assembly);    flow.complete();    String result = FileUtils.readFileToString(new File(TXT_OUTPUT_PATH + "/part-00000"));    assertEquals(expectedStr, result);}
4fd3aa7897ef92758de4c0f89d2d1f6992cb908adda7d5598efd28084934c4f4
writeParquetFile
private void writeParquetFile(List<TBase> recordsToWrite, Configuration conf, Path parquetFile) throws IOException, InterruptedException, org.apache.thrift.TException
{        final TProtocolFactory protocolFactory = new TCompactProtocol.Factory();    final TaskAttemptID taskId = new TaskAttemptID("local", 0, true, 0, 0);    Class writeClass = recordsToWrite.get(0).getClass();    final ThriftToParquetFileWriter w = new ThriftToParquetFileWriter(parquetFile, ContextUtil.newTaskAttemptContext(conf, taskId), protocolFactory, writeClass);    final ByteArrayOutputStream baos = new ByteArrayOutputStream();    final TProtocol protocol = protocolFactory.getProtocol(new TIOStreamTransport(baos));    for (TBase recordToWrite : recordsToWrite) {        recordToWrite.write(protocol);    }    w.write(new BytesWritable(baos.toByteArray()));    w.close();}
20bc44825e553edca6b0b904e65a71a8383d5cf6b14aea011a217a6009f74f8d
thriftRecords
private List<TBase> thriftRecords(TBase... records)
{    List<TBase> result = new ArrayList<TBase>();    for (TBase record : records) {        result.add(record);    }    return result;}
d24fd3bd6efc23915d40da405d1a52ecef7650f6fcf3667d3d608605b90dd00d
deleteIfExist
private void deleteIfExist(String path) throws IOException
{    Path p = new Path(path);    Configuration conf = new Configuration();    final FileSystem fs = p.getFileSystem(conf);    if (fs.exists(p)) {        fs.delete(p, true);    }}
720c8f668ae3010ec1aefd58fa700fcdb3686809771e080bd6f7645d35c14546
testWriteThenRead
public void testWriteThenRead() throws Exception
{    doWrite();    doRead();}
5136ab8a6118d7a3a8a987bc17f401b5e1946588bed3f56532c981445e5fc07c
doWrite
private void doWrite() throws Exception
{    Path path = new Path(parquetOutputPath);    final FileSystem fs = path.getFileSystem(new Configuration());    if (fs.exists(path))        fs.delete(path, true);    Scheme sourceScheme = new TextLine(new Fields("first", "last"));    Tap source = new Hfs(sourceScheme, txtInputPath);    Scheme sinkScheme = new ParquetScroogeScheme<Name>(Name.class);    Tap sink = new Hfs(sinkScheme, parquetOutputPath);    Pipe assembly = new Pipe("namecp");    assembly = new Each(assembly, new PackThriftFunction());    Flow flow = new HadoopFlowConnector().connect("namecp", source, sink, assembly);    flow.complete();}
2759b9953906632a275686a57da8660f9a84701415c1e2850461633d22c6d95b
doRead
private void doRead() throws Exception
{    Path path = new Path(txtOutputPath);    final FileSystem fs = path.getFileSystem(new Configuration());    if (fs.exists(path))        fs.delete(path, true);    Scheme sourceScheme = new ParquetScroogeScheme<Name>(Name.class);    Tap source = new Hfs(sourceScheme, parquetOutputPath);    Scheme sinkScheme = new TextLine(new Fields("first", "last"));    Tap sink = new Hfs(sinkScheme, txtOutputPath);    Pipe assembly = new Pipe("namecp");    assembly = new Each(assembly, new UnpackThriftFunction());    Flow flow = new HadoopFlowConnector().connect("namecp", source, sink, assembly);    flow.complete();    String result = FileUtils.readFileToString(new File(txtOutputPath + "/part-00000"));    assertEquals("0\tAlice\tPractice\n15\tBob\tHope\n24\tCharlie\tHorse\n", result);}
249a384a8ce00b5a43e2eaae043a0c519fb43142ee17436c249f156bdecde0cf
operate
public void operate(FlowProcess flowProcess, FunctionCall functionCall)
{    TupleEntry arguments = functionCall.getArguments();    Tuple result = new Tuple();    Name name = Name$.MODULE$.apply(arguments.getString(0), Option.apply(arguments.getString(1)));    result.add(name);    functionCall.getOutputCollector().add(result);}
249a384a8ce00b5a43e2eaae043a0c519fb43142ee17436c249f156bdecde0cf
operate
public void operate(FlowProcess flowProcess, FunctionCall functionCall)
{    TupleEntry arguments = functionCall.getArguments();    Tuple result = new Tuple();    Name name = (Name) arguments.getObject(0);    result.add(name.firstName());    result.add(name.lastName().get());    functionCall.getOutputCollector().add(result);}
ae79d287c55da07731712281537b103c1c948ce130ff74aa5aab5fea734857f7
testScroogeBinaryEncoding
public void testScroogeBinaryEncoding() throws Exception
{    StringAndBinary expected = new StringAndBinary.Immutable("test", ByteBuffer.wrap(new byte[] { -123, 20, 33 }));    File temp = tempDir.newFile(UUID.randomUUID().toString());    temp.deleteOnExit();    temp.delete();    Path path = new Path(temp.getPath());    ParquetWriter<StringAndBinary> writer = new ParquetWriter<StringAndBinary>(path, new Configuration(), new ScroogeWriteSupport<StringAndBinary>(StringAndBinary.class));    writer.write(expected);    writer.close();        ParquetReader<org.apache.parquet.thrift.test.binary.StringAndBinary> reader = ThriftParquetReader.<org.apache.parquet.thrift.test.binary.StringAndBinary>build(path).withThriftClass(org.apache.parquet.thrift.test.binary.StringAndBinary.class).build();    org.apache.parquet.thrift.test.binary.StringAndBinary record = reader.read();    reader.close();    Assert.assertEquals("String should match after serialization round trip", "test", record.s);    Assert.assertEquals("ByteBuffer should match after serialization round trip", ByteBuffer.wrap(new byte[] { -123, 20, 33 }), record.b);}
385395b92ec1a3b8fe9e6269b0dd2687a802f986d7e77da7c703cf60306962cc
testScroogeBinaryDecoding
public void testScroogeBinaryDecoding() throws Exception
{    StringAndBinary expected = new StringAndBinary.Immutable("test", ByteBuffer.wrap(new byte[] { -123, 20, 33 }));    File temp = tempDir.newFile(UUID.randomUUID().toString());    temp.deleteOnExit();    temp.delete();    Path path = new Path(temp.getPath());    ParquetWriter<StringAndBinary> writer = new ParquetWriter<StringAndBinary>(path, new Configuration(), new ScroogeWriteSupport<StringAndBinary>(StringAndBinary.class));    writer.write(expected);    writer.close();    Configuration conf = new Configuration();    conf.set("parquet.thrift.converter.class", ScroogeRecordConverter.class.getName());    ParquetReader<StringAndBinary> reader = ParquetReader.<StringAndBinary>builder(new ScroogeReadSupport(), path).withConf(conf).build();    StringAndBinary record = reader.read();    reader.close();    Assert.assertEquals("String should match after serialization round trip", "test", record.s());    Assert.assertEquals("ByteBuffer should match after serialization round trip", ByteBuffer.wrap(new byte[] { -123, 20, 33 }), record.b());}
bf2af5105ba8e299554f93b7cfc907a784fa84815da52a1cb7eb5f6844ed6368
shouldConvertConsistentlyWithThriftStructConverter
private void shouldConvertConsistentlyWithThriftStructConverter(Class scroogeClass) throws ClassNotFoundException
{    Class<? extends TBase<?, ?>> thriftClass = (Class<? extends TBase<?, ?>>) Class.forName(scroogeClass.getName().replaceFirst("org.apache.parquet.scrooge.test", "org.apache.parquet.thrift.test"));    ThriftType.StructType structFromThriftSchemaConverter = ThriftSchemaConverter.toStructType(thriftClass);    ThriftType.StructType structFromScroogeSchemaConverter = new ScroogeStructConverter().convert(scroogeClass);    assertEquals(toParquetSchema(structFromThriftSchemaConverter), toParquetSchema(structFromScroogeSchemaConverter));}
40d5a4892fd26e2611f743eaf3d1a53378d5fdface3900a0e11b9d0c2a20b487
toParquetSchema
private MessageType toParquetSchema(ThriftType.StructType struct)
{    return ThriftSchemaConverter.convertWithoutProjection(struct);}
af499cf652628e31193b54eefad3d2ed23240c1f44f9807b06e7a5517c853746
testConvertPrimitiveMapKey
public void testConvertPrimitiveMapKey() throws Exception
{    shouldConvertConsistentlyWithThriftStructConverter(TestMapPrimitiveKey.class);}
33fbf24bee5517ef43540c2f071bfe27020a2307a5e7347ea567c078ba0b79c2
testBinary
public void testBinary() throws Exception
{    shouldConvertConsistentlyWithThriftStructConverter(StringAndBinary.class);}
885adce170ee8976432efbf14891fef8562a01c79e29888906018818c2983c1a
testUnion
public void testUnion() throws Exception
{    shouldConvertConsistentlyWithThriftStructConverter(TestUnion.class);}
5f2561bc12a2b63b3761a1f7484dc96645703e8e5e88b3719a7ee3e201cdd966
testConvertPrimitiveMapValue
public void testConvertPrimitiveMapValue() throws Exception
{    shouldConvertConsistentlyWithThriftStructConverter(TestMapPrimitiveValue.class);}
94ef04c610ada07aea2b612d8c9823e8ebb34cbc5d9d728ee83a1b9b28c04eee
testConvertPrimitiveList
public void testConvertPrimitiveList() throws Exception
{    shouldConvertConsistentlyWithThriftStructConverter(TestListPrimitive.class);}
97aefc7f0ac56e781a4566dc954c79f7676e019457179719c3e85d976aa157a1
testConvertPrimitiveSet
public void testConvertPrimitiveSet() throws Exception
{    shouldConvertConsistentlyWithThriftStructConverter(TestSetPrimitive.class);}
82b468d6b371a466276f1ff5763bc51f8344335fe4c137f41eecd3cef3189f55
testConvertEnum
public void testConvertEnum() throws Exception
{    shouldConvertConsistentlyWithThriftStructConverter(TestFieldOfEnum.class);}
b4deb5b55adc15477751ae75a2ddf879dda7ff7d3e27bac6aec2b52951a15452
testMapBinary
public void testMapBinary() throws Exception
{    shouldConvertConsistentlyWithThriftStructConverter(TestMapBinary.class);}
23aac95970ccea1d9fee6337ff12bfa88cbbe2d78e3edbeb9e1fe26c63b6a3bf
testMapComplex
public void testMapComplex() throws Exception
{    shouldConvertConsistentlyWithThriftStructConverter(TestMapComplex.class);}
850de5046246152844a53c6186a74e12be0fd12fcaf9251aa786bb6c190c734c
testConvertStruct
public void testConvertStruct() throws Exception
{    shouldConvertConsistentlyWithThriftStructConverter(TestPersonWithAllInformation.class);}
29a3a3c5b94fd0feeebc88e1eb04fc9af8f43ceb13bde940b64048f022f90553
testDefaultFields
public void testDefaultFields() throws Exception
{    shouldConvertConsistentlyWithThriftStructConverter(AddressWithStreetWithDefaultRequirement.class);}
21902c0729deaaada60e83f2f4bcdeaab332b339bc812b48c4ca353660a2ead3
testConvertOptionalPrimitiveMap
public void testConvertOptionalPrimitiveMap() throws Exception
{    shouldConvertConsistentlyWithThriftStructConverter(TestOptionalMap.class);}
7f9c89eb2527d8e0b8d41adf0d31e8705e946d59e3412940a44150eed9fa5344
testConvertNestedList
public void testConvertNestedList() throws Exception
{    shouldConvertConsistentlyWithThriftStructConverter(NestedList.class);}
3c78261e3f167f8ae73209d106c1c4b7fed14f6ad48fc44077080bf635823236
testConvertListNestMap
public void testConvertListNestMap() throws Exception
{    shouldConvertConsistentlyWithThriftStructConverter(ListNestMap.class);}
d11138fd12dff032bc98ae011908b55accac1eefc1de3aa99db962d08af24705
testConvertListNestEnum
public void testConvertListNestEnum() throws Exception
{    shouldConvertConsistentlyWithThriftStructConverter(ListNestEnum.class);}
7c253256b7a9e421554c6cad637cb12328d4ff1e91cc3e44b8a016587036bf7f
testConvertMapNestList
public void testConvertMapNestList() throws Exception
{    shouldConvertConsistentlyWithThriftStructConverter(MapNestList.class);}
4d684bb597c81a1250fb2926465572049b0f3e26cb7b215252996fccb0d0c1b3
testConvertMapNestMap
public void testConvertMapNestMap() throws Exception
{    shouldConvertConsistentlyWithThriftStructConverter(MapNestMap.class);}
2032672e4515accc43c7e8aafe078f05f6f7f61d2d450afc198ad300c0fbaa36
testConvertMapNestSet
public void testConvertMapNestSet() throws Exception
{    shouldConvertConsistentlyWithThriftStructConverter(MapNestSet.class);}
76797fcc0b6de980c3b3afa3e75afb93aa8784cf822c348467e99c2fa847f4df
testConvertListNestSet
public void testConvertListNestSet() throws Exception
{    shouldConvertConsistentlyWithThriftStructConverter(ListNestSet.class);}
ae0a99f626df460d3035e0cfe83994c2922bb6c0adab2b8ca4b570f76206772b
testConvertSetNestSet
public void testConvertSetNestSet() throws Exception
{    shouldConvertConsistentlyWithThriftStructConverter(SetNestSet.class);}
04a0b97f56300f9e06843adef0a6f33d7f84c382b53ef2e9970084806daeae73
testConvertSetNestList
public void testConvertSetNestList() throws Exception
{    shouldConvertConsistentlyWithThriftStructConverter(SetNestList.class);}
2c21d011d953fab81890232f8df214a28d3d28c5a62472bd618606fe7b860897
testConvertSetNestMap
public void testConvertSetNestMap() throws Exception
{    shouldConvertConsistentlyWithThriftStructConverter(SetNestMap.class);}
7268a767365d7d9d2a27cc5c016bc3ad70d02aed990e6887bc793928a31f7c07
setupJob
public void setupJob(Job job, Path path) throws Exception
{    job.setInputFormatClass(ParquetScroogeInputFormat.class);    ParquetScroogeInputFormat.setInputPaths(job, path);    ParquetScroogeInputFormat.setThriftClass(job.getConfiguration(), StructWithUnionV2.class);    ThriftReadSupport.setRecordConverterClass(job.getConfiguration(), ScroogeRecordConverter.class);    job.setMapperClass(ReadMapper.class);    job.setNumReduceTasks(0);    job.setOutputFormatClass(NullOutputFormat.class);}
88d0fd9cac126a8b2301ae512bd3c22d91a8a952bd75072fc38e647b86aead8b
assertEqualsExcepted
protected void assertEqualsExcepted(List<org.apache.parquet.thrift.test.compat.StructWithUnionV2> expected, List<Object> found) throws Exception
{    List<StructWithUnionV2> scroogeExpected = new ArrayList<StructWithUnionV2>();    for (org.apache.parquet.thrift.test.compat.StructWithUnionV2 tbase : expected) {        ByteArrayOutputStream baos = new ByteArrayOutputStream();        TProtocol out = new Factory().getProtocol(new TIOStreamTransport(baos));        tbase.write(out);        TProtocol in = new Factory().getProtocol(new TIOStreamTransport(new ByteArrayInputStream(baos.toByteArray())));        scroogeExpected.add(StructWithUnionV2$.MODULE$.decode(in));    }    assertEquals(scroogeExpected, found);}
ecd19e7adcc2c90a1ac9346a91f8c9c933b9dbada8726747356c5963faffeb95
setGenericThriftClass
public static void setGenericThriftClass(Configuration configuration, Class<?> thriftClass)
{    configuration.set(PARQUET_THRIFT_CLASS, thriftClass.getName());}
e4e2f08fca014320632f259d19849ccc22520bdefeabe974a30778367cfb17db
getGenericThriftClass
public static Class getGenericThriftClass(Configuration configuration)
{    final String thriftClassName = configuration.get(PARQUET_THRIFT_CLASS);    if (thriftClassName == null) {        throw new BadConfigurationException("the thrift class conf is missing in job conf at " + PARQUET_THRIFT_CLASS);    }    try {        @SuppressWarnings("unchecked")        Class thriftClass = Class.forName(thriftClassName);        return thriftClass;    } catch (ClassNotFoundException e) {        throw new BadConfigurationException("the class " + thriftClassName + " in job conf at " + PARQUET_THRIFT_CLASS + " could not be found", e);    }}
142287ad462822136ad218bf8417db20b967bb9159e8a442a686b99c75c9d777
init
protected void init(Class<T> thriftClass)
{    this.thriftClass = thriftClass;    this.thriftStruct = getThriftStruct();    this.schema = ThriftSchemaConverter.convertWithoutProjection(thriftStruct);    final Map<String, String> extraMetaData = new ThriftMetaData(thriftClass.getName(), thriftStruct).toExtraMetaData();        if (isPigLoaded() && TBase.class.isAssignableFrom(thriftClass)) {        new PigMetaData(new ThriftToPig((Class<? extends TBase<?, ?>>) thriftClass).toSchema()).addToMetaData(extraMetaData);    }    this.writeContext = new WriteContext(schema, extraMetaData);}
0bb242251d0820ea7ff8c4812e026334294b62ba6ba3780038cb464ac80bda55
isPigLoaded
protected boolean isPigLoaded()
{    try {        Class.forName("org.apache.pig.impl.logicalLayer.schema.Schema");        return true;    } catch (ClassNotFoundException e) {        LOG.info("Pig is not loaded, pig metadata will not be written");        return false;    }}
89835da140a91d5cb5181a85b8db073a92d794e99966f7422502dbb7d5467b7c
init
public WriteContext init(Configuration configuration)
{    if (writeContext == null) {        init(getGenericThriftClass(configuration));    }    return writeContext;}
da9aef78cf181856102b820ffa7d5248e8581747b3f0670a7b049c4649b962ef
prepareForWrite
public void prepareForWrite(RecordConsumer recordConsumer)
{    final MessageColumnIO columnIO = new ColumnIOFactory().getColumnIO(schema);    this.parquetWriteProtocol = new ParquetWriteProtocol(recordConsumer, columnIO, thriftStruct);}
71da4acb744112059f3e7cfec79c48e1c69c79ef80e0a01d81e82b3b9a1f7c47
setThriftClass
public static void setThriftClass(Job job, Class<? extends TBase<?, ?>> thriftClass)
{    TBaseWriteSupport.setThriftClass(ContextUtil.getConfiguration(job), thriftClass);}
7023c59d2febaf58e60cc9e35bc313d116ddf33ca6a3b4f62905dfc431feadc7
getThriftClass
public static Class<? extends TBase<?, ?>> getThriftClass(Job job)
{    return TBaseWriteSupport.getThriftClass(ContextUtil.getConfiguration(job));}
45c4c294c73ff7df8173927b89d3a24c8ac485c7e349f5c7e9053db161f8a549
setTProtocolClass
public static void setTProtocolClass(Job job, Class<U> tProtocolClass)
{    ThriftBytesWriteSupport.setTProtocolClass(ContextUtil.getConfiguration(job), tProtocolClass);}
4777a09af73156504a1461958bd1213e660b4b8393416fe61cbf1e7f009f13c3
setThriftClass
public static void setThriftClass(JobConf conf, Class<T> klass)
{    conf.set(ThriftReadSupport.THRIFT_READ_CLASS_KEY, klass.getName());}
e52c7ea54526b4c07c834f9f0483acc8a0cef575cafb43c4c6e942223902723c
setThriftClass
public static void setThriftClass(Configuration conf, Class<T> klass)
{    conf.set(ThriftReadSupport.THRIFT_READ_CLASS_KEY, klass.getName());}
71da4acb744112059f3e7cfec79c48e1c69c79ef80e0a01d81e82b3b9a1f7c47
setThriftClass
public static void setThriftClass(Job job, Class<? extends TBase<?, ?>> thriftClass)
{    ThriftWriteSupport.setThriftClass(ContextUtil.getConfiguration(job), thriftClass);}
7023c59d2febaf58e60cc9e35bc313d116ddf33ca6a3b4f62905dfc431feadc7
getThriftClass
public static Class<? extends TBase<?, ?>> getThriftClass(Job job)
{    return ThriftWriteSupport.getThriftClass(ContextUtil.getConfiguration(job));}
b7c65f98901d545b2373473d2b714003bd8e1a19d5741c5571817588c32eee69
setThriftClass
public static void setThriftClass(Configuration configuration, Class<U> thriftClass)
{    AbstractThriftWriteSupport.setGenericThriftClass(configuration, thriftClass);}
6ae3c1a13d99a2ec5e9cffa18946f8b2c92d2674726864c9a9b1d777dcd620a7
getThriftClass
public static Class<? extends TBase<?, ?>> getThriftClass(Configuration configuration)
{    return (Class<? extends TBase<?, ?>>) AbstractThriftWriteSupport.getGenericThriftClass(configuration);}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "thrift";}
46da48587fee2569e1997ae14209179a9bbf2b3bedc353505eab6fb2ea6d4ea8
getThriftStruct
protected StructType getThriftStruct()
{    return ThriftSchemaConverter.toStructType(thriftClass);}
e1dbc5a450a06f22ce2d7d2253403253153e3053cbf43f22851c97af786390af
write
public void write(T record)
{    try {        record.write(parquetWriteProtocol);    } catch (TException e) {        throw new ParquetEncodingException(e);    }}
7394852dd6404e326cd8d86a800678b0bfe01685e246f2ef2c6e9dcf5937e5c2
setTProtocolClass
public static void setTProtocolClass(Configuration conf, Class<U> tProtocolClass)
{    conf.set(PARQUET_PROTOCOL_CLASS, tProtocolClass.getName());}
098be088f586e60ac7ec08ad7fecb776445eb8b98bce754a6ecd765e39910a4e
getTProtocolFactoryClass
public static Class<TProtocolFactory> getTProtocolFactoryClass(Configuration conf)
{    final String tProtocolClassName = conf.get(PARQUET_PROTOCOL_CLASS);    if (tProtocolClassName == null) {        throw new BadConfigurationException("the protocol class conf is missing in job conf at " + PARQUET_PROTOCOL_CLASS);    }    try {        @SuppressWarnings("unchecked")        Class<TProtocolFactory> tProtocolFactoryClass = (Class<TProtocolFactory>) Class.forName(tProtocolClassName + "$Factory");        return tProtocolFactoryClass;    } catch (ClassNotFoundException e) {        throw new BadConfigurationException("the Factory for class " + tProtocolClassName + " in job conf at " + PARQUET_PROTOCOL_CLASS + " could not be found", e);    }}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "thrift";}
89835da140a91d5cb5181a85b8db073a92d794e99966f7422502dbb7d5467b7c
init
public WriteContext init(Configuration configuration)
{    if (this.protocolFactory == null) {        try {            this.protocolFactory = getTProtocolFactoryClass(configuration).newInstance();        } catch (InstantiationException e) {            throw new RuntimeException(e);        } catch (IllegalAccessException e) {            throw new RuntimeException(e);        }    }    if (thriftClass != null) {        TBaseWriteSupport.setThriftClass(configuration, thriftClass);    } else {        thriftClass = TBaseWriteSupport.getThriftClass(configuration);    }    this.thriftStruct = ThriftSchemaConverter.toStructType(thriftClass);    this.schema = ThriftSchemaConverter.convertWithoutProjection(thriftStruct);    if (buffered) {        readToWrite = new BufferedProtocolReadToWrite(thriftStruct, errorHandler);    } else {        readToWrite = new ProtocolReadToWrite();    }    return thriftWriteSupport.init(configuration);}
1ba7cfac52850c711844692cf9794a5a4788b54f54c9cf84c32ca8d9f388024e
protocol
private TProtocol protocol(BytesWritable record)
{    TProtocol protocol = protocolFactory.getProtocol(new TIOStreamTransport(new ByteArrayInputStream(record.getBytes())));    /* Reduce the chance of OOM when data is corrupted. When readBinary is called on TBinaryProtocol, it reads the length of the binary first,     so if the data is corrupted, it could read a big integer as the length of the binary and therefore causes OOM to happen.     Currently this fix only applies to TBinaryProtocol which has the setReadLength defined (thrift 0.7).      */    if (SET_READ_LENGTH != null && protocol instanceof TBinaryProtocol) {        try {            SET_READ_LENGTH.invoke(protocol, new Object[] { record.getLength() });        } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {            LOG.warn("setReadLength should not throw an exception", e);            SET_READ_LENGTH = null;        }    }    return protocol;}
da9aef78cf181856102b820ffa7d5248e8581747b3f0670a7b049c4649b962ef
prepareForWrite
public void prepareForWrite(RecordConsumer recordConsumer)
{    final MessageColumnIO columnIO = new ColumnIOFactory().getColumnIO(schema);    this.parquetWriteProtocol = new ParquetWriteProtocol(recordConsumer, columnIO, thriftStruct);    thriftWriteSupport.prepareForWrite(recordConsumer);}
cc9192ad0557e861c102340cd96983601c50c882bf7f1d5a8aaa2c94290fd724
write
public void write(BytesWritable record)
{    try {        readToWrite.readOne(protocol(record), parquetWriteProtocol);    } catch (TException e) {        throw new ParquetEncodingException(e);    }}
466184c305be810464e729cc854ca8b0b376f50ed055ba1f65fb94fda0d24609
setRecordConverterClass
public static void setRecordConverterClass(JobConf conf, Class<?> klass)
{    setRecordConverterClass((Configuration) conf, klass);}
d31cdbe3d123b58762f28472ea829ec2e973e324f30195624162fce7f789fc3d
setRecordConverterClass
public static void setRecordConverterClass(Configuration conf, Class<?> klass)
{    conf.set(RECORD_CONVERTER_CLASS_KEY, klass.getName());}
b797cc7eb426116c972e326ef66fdc28fd2eccd24c734ea29f319e3856b1517e
setProjectionPushdown
public static void setProjectionPushdown(JobConf jobConf, String projectionString)
{    jobConf.set(THRIFT_COLUMN_FILTER_KEY, projectionString);}
8788e67a36ea89502835aef3dcebf65e326ffbd83f4512238874150f6fecf6ce
setStrictFieldProjectionFilter
public static void setStrictFieldProjectionFilter(Configuration conf, String semicolonDelimitedGlobs)
{    conf.set(STRICT_THRIFT_COLUMN_FILTER_KEY, semicolonDelimitedGlobs);}
2c04a215a892daa76d714b4abce1ce115af871644e35c09185b793854ec976f2
getFieldProjectionFilter
public static FieldProjectionFilter getFieldProjectionFilter(Configuration conf)
{    String deprecated = conf.get(THRIFT_COLUMN_FILTER_KEY);    String strict = conf.get(STRICT_THRIFT_COLUMN_FILTER_KEY);    if (Strings.isNullOrEmpty(deprecated) && Strings.isNullOrEmpty(strict)) {        return null;    }    if (!Strings.isNullOrEmpty(deprecated) && !Strings.isNullOrEmpty(strict)) {        throw new ThriftProjectionException("You cannot provide both " + THRIFT_COLUMN_FILTER_KEY + " and " + STRICT_THRIFT_COLUMN_FILTER_KEY + "! " + THRIFT_COLUMN_FILTER_KEY + " is deprecated.");    }    if (!Strings.isNullOrEmpty(deprecated)) {        LOG.warn("Using {} is deprecated. Please see the docs for {}!", THRIFT_COLUMN_FILTER_KEY, STRICT_THRIFT_COLUMN_FILTER_KEY);        return new DeprecatedFieldProjectionFilter(deprecated);    }    return StrictFieldProjectionFilter.fromSemicolonDelimitedString(strict);}
2f61bf478c8f6fb4c9e685ae0c4f7abf2adb09bb251de804b2d202fe37548f36
init
public org.apache.parquet.hadoop.api.ReadSupport.ReadContext init(InitContext context)
{    final Configuration configuration = context.getConfiguration();    final MessageType fileMessageType = context.getFileSchema();    MessageType requestedProjection = fileMessageType;    String partialSchemaString = configuration.get(ReadSupport.PARQUET_READ_SCHEMA);    FieldProjectionFilter projectionFilter = getFieldProjectionFilter(configuration);    if (partialSchemaString != null && projectionFilter != null) {        throw new ThriftProjectionException(String.format("You cannot provide both a partial schema and field projection filter." + "Only one of (%s, %s, %s) should be set.", PARQUET_READ_SCHEMA, STRICT_THRIFT_COLUMN_FILTER_KEY, THRIFT_COLUMN_FILTER_KEY));    }        if (partialSchemaString != null) {        requestedProjection = getSchemaForRead(fileMessageType, partialSchemaString);    } else if (projectionFilter != null) {        try {            initThriftClassFromMultipleFiles(context.getKeyValueMetadata(), configuration);            requestedProjection = getProjectedSchema(projectionFilter);        } catch (ClassNotFoundException e) {            throw new ThriftProjectionException("can not find thriftClass from configuration", e);        }    }    MessageType schemaForRead = getSchemaForRead(fileMessageType, requestedProjection);    return new ReadContext(schemaForRead);}
90d9f35895bd8e24af114b4a4ecc7ce923185f2985c8d7e588f4cea537da81a7
getProjectedSchema
protected MessageType getProjectedSchema(FieldProjectionFilter fieldProjectionFilter)
{    return new ThriftSchemaConverter(fieldProjectionFilter).convert((Class<TBase<?, ?>>) thriftClass);}
5342ce0351b626fde1d30dc239e454523f887c3ec083622df819776a018597c5
initThriftClassFromMultipleFiles
private void initThriftClassFromMultipleFiles(Map<String, Set<String>> fileMetadata, Configuration conf) throws ClassNotFoundException
{    if (thriftClass != null) {        return;    }    String className = conf.get(THRIFT_READ_CLASS_KEY, null);    if (className == null) {        Set<String> names = ThriftMetaData.getThriftClassNames(fileMetadata);        if (names == null || names.size() != 1) {            throw new ParquetDecodingException("Could not read file as the Thrift class is not provided and could not be resolved from the file: " + names);        }        className = names.iterator().next();    }    thriftClass = (Class<T>) Class.forName(className);}
7a2c171259ed7a49d472373dea62f467355fbf8d95ee946ac9e8f9039be47ddb
initThriftClass
private void initThriftClass(ThriftMetaData metadata, Configuration conf) throws ClassNotFoundException
{    if (thriftClass != null) {        return;    }    String className = conf.get(THRIFT_READ_CLASS_KEY, null);    if (className == null) {        if (metadata == null) {            throw new ParquetDecodingException("Could not read file as the Thrift class is not provided and could not be resolved from the file");        }        thriftClass = (Class<T>) metadata.getThriftClass();    } else {        thriftClass = (Class<T>) Class.forName(className);    }}
3e0e309da82648ff8c00cd910df7bd66227644f74296a7c4d61a98c6b892980f
prepareForRead
public RecordMaterializer<T> prepareForRead(Configuration configuration, Map<String, String> keyValueMetaData, MessageType fileSchema, org.apache.parquet.hadoop.api.ReadSupport.ReadContext readContext)
{    ThriftMetaData thriftMetaData = ThriftMetaData.fromExtraMetaData(keyValueMetaData);    try {        initThriftClass(thriftMetaData, configuration);    } catch (ClassNotFoundException e) {        throw new RuntimeException("Cannot find Thrift object class for metadata: " + thriftMetaData, e);    }        if (thriftMetaData == null) {        thriftMetaData = ThriftMetaData.fromThriftClass(thriftClass);    }    String converterClassName = configuration.get(RECORD_CONVERTER_CLASS_KEY, RECORD_CONVERTER_DEFAULT);    return getRecordConverterInstance(converterClassName, thriftClass, readContext.getRequestedSchema(), thriftMetaData.getDescriptor(), configuration);}
a1f439820ad291a2b5342487572e81c6b0c2d2cac1bb6735c8fd5f5b039c0aac
getRecordConverterInstance
private static ThriftRecordConverter<T> getRecordConverterInstance(String converterClassName, Class<T> thriftClass, MessageType requestedSchema, StructType descriptor, Configuration conf)
{    Class<ThriftRecordConverter<T>> converterClass;    try {        converterClass = (Class<ThriftRecordConverter<T>>) Class.forName(converterClassName);    } catch (ClassNotFoundException e) {        throw new RuntimeException("Cannot find Thrift converter class: " + converterClassName, e);    }    try {                try {            Constructor<ThriftRecordConverter<T>> constructor = converterClass.getConstructor(Class.class, MessageType.class, StructType.class, Configuration.class);            return constructor.newInstance(thriftClass, requestedSchema, descriptor, conf);        } catch (IllegalAccessException e) {                } catch (NoSuchMethodException e) {                }        Constructor<ThriftRecordConverter<T>> constructor = converterClass.getConstructor(Class.class, MessageType.class, StructType.class);        return constructor.newInstance(thriftClass, requestedSchema, descriptor);    } catch (InstantiationException e) {        throw new RuntimeException("Failed to construct Thrift converter class: " + converterClassName, e);    } catch (InvocationTargetException e) {        throw new RuntimeException("Failed to construct Thrift converter class: " + converterClassName, e);    } catch (IllegalAccessException e) {        throw new RuntimeException("Cannot access constructor for Thrift converter class: " + converterClassName, e);    } catch (NoSuchMethodException e) {        throw new RuntimeException("Cannot find constructor for Thrift converter class: " + converterClassName, e);    }}
d6ab214b2a8e903b32056d9db22234cc000eee5a1872d60e5bb48b08a28d4293
write
public void write(BytesWritable bytes) throws IOException, InterruptedException
{    recordWriter.write(null, bytes);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    try {        recordWriter.close(taskAttemptContext);    } catch (InterruptedException e) {        Thread.interrupted();        throw new IOException("The thread was interrupted", e);    }}
b7c65f98901d545b2373473d2b714003bd8e1a19d5741c5571817588c32eee69
setThriftClass
public static void setThriftClass(Configuration configuration, Class<U> thriftClass)
{    TBaseWriteSupport.setThriftClass(configuration, thriftClass);}
6ae3c1a13d99a2ec5e9cffa18946f8b2c92d2674726864c9a9b1d777dcd620a7
getThriftClass
public static Class<? extends TBase<?, ?>> getThriftClass(Configuration configuration)
{    return TBaseWriteSupport.getThriftClass(configuration);}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return writeSupport.getName();}
89835da140a91d5cb5181a85b8db073a92d794e99966f7422502dbb7d5467b7c
init
public WriteContext init(Configuration configuration)
{    return this.writeSupport.init(configuration);}
da9aef78cf181856102b820ffa7d5248e8581747b3f0670a7b049c4649b962ef
prepareForWrite
public void prepareForWrite(RecordConsumer recordConsumer)
{    this.writeSupport.prepareForWrite(recordConsumer);}
e1dbc5a450a06f22ce2d7d2253403253153e3053cbf43f22851c97af786390af
write
public void write(T record)
{    this.writeSupport.write(record);}
cfbe67b070603fd1ce7103794cde32d42151c860eed5f3b056f5895ea381ba8a
write
public void write(TProtocol out) throws TException
{    out.writeFieldStop();    out.writeStructEnd();}
6cb78d1dfb9d9e4dc5785009730b403d190d6b55ac688b94d6714b823187846e
toDebugString
public String toDebugString()
{    return ")";}
cfbe67b070603fd1ce7103794cde32d42151c860eed5f3b056f5895ea381ba8a
write
public void write(TProtocol out) throws TException
{    out.writeFieldEnd();}
6cb78d1dfb9d9e4dc5785009730b403d190d6b55ac688b94d6714b823187846e
toDebugString
public String toDebugString()
{    return ";";}
cfbe67b070603fd1ce7103794cde32d42151c860eed5f3b056f5895ea381ba8a
write
public void write(TProtocol out) throws TException
{    out.writeMapEnd();}
6cb78d1dfb9d9e4dc5785009730b403d190d6b55ac688b94d6714b823187846e
toDebugString
public String toDebugString()
{    return "]";}
cfbe67b070603fd1ce7103794cde32d42151c860eed5f3b056f5895ea381ba8a
write
public void write(TProtocol out) throws TException
{    out.writeListEnd();}
6cb78d1dfb9d9e4dc5785009730b403d190d6b55ac688b94d6714b823187846e
toDebugString
public String toDebugString()
{    return "}";}
cfbe67b070603fd1ce7103794cde32d42151c860eed5f3b056f5895ea381ba8a
write
public void write(TProtocol out) throws TException
{    out.writeSetEnd();}
6cb78d1dfb9d9e4dc5785009730b403d190d6b55ac688b94d6714b823187846e
toDebugString
public String toDebugString()
{    return "*}";}
b5cdaa282cff05c4697eb9b587f10a05b99fda9422ceb86b999d7a8c4b9e56df
readOne
public void readOne(TProtocol in, TProtocol out) throws TException
{    List<Action> buffer = new LinkedList<Action>();    try {        boolean hasFieldsIgnored = readOneStruct(in, buffer, thriftType);        if (hasFieldsIgnored) {            notifyRecordHasFieldIgnored();        }    } catch (Exception e) {        throw new SkippableException(error("Error while reading", buffer), e);    }    try {        for (Action a : buffer) {            a.write(out);        }    } catch (Exception e) {        throw new TException(error("Can not write record", buffer), e);    }}
001e204e78f81c549fd768c512b48e2a4bd165398441c0753ccb96dbad1aefee
notifyRecordHasFieldIgnored
private void notifyRecordHasFieldIgnored()
{    if (errorHandler != null) {        errorHandler.handleRecordHasFieldIgnored();    }}
f29418781debbad39e63b6710b78552dc2dc10a34a544ec1b45d23fc7a2eb4cb
notifyIgnoredFieldsOfRecord
private void notifyIgnoredFieldsOfRecord(TField field)
{    if (errorHandler != null) {        errorHandler.handleFieldIgnored(field);    }}
c59314589beaac392ab30494e643bb4d36adb3a6d8a557fecf6e90b28fe1526e
error
private String error(String message, List<Action> buffer)
{    StringBuilder sb = new StringBuilder(message).append(": ");    for (Action action : buffer) {        sb.append(action.toDebugString());    }    return sb.toString();}
0836890e2b88a53e44a28317e518275cbac0eca14f5e1eb33885c56e4a0451dd
readOneValue
private boolean readOneValue(TProtocol in, byte type, List<Action> buffer, ThriftType expectedType) throws TException
{    if (expectedType != null && expectedType.getType().getSerializedThriftType() != type) {        throw new DecodingSchemaMismatchException("the data type does not match the expected thrift structure: expected " + expectedType + " got " + typeName(type));    }    boolean hasFieldsIgnored = false;    switch(type) {        case TType.LIST:            hasFieldsIgnored = readOneList(in, buffer, (ListType) expectedType);            break;        case TType.MAP:            hasFieldsIgnored = readOneMap(in, buffer, (MapType) expectedType);            break;        case TType.SET:            hasFieldsIgnored = readOneSet(in, buffer, (SetType) expectedType);            break;        case TType.STRUCT:            hasFieldsIgnored = readOneStruct(in, buffer, (StructType) expectedType);            break;        case TType.STOP:            break;        case TType.BOOL:            final boolean bool = in.readBool();            writeBoolAction(buffer, bool);            break;        case TType.BYTE:            final byte b = in.readByte();            writeByteAction(buffer, b);            break;        case TType.DOUBLE:            final double d = in.readDouble();            writeDoubleAction(buffer, d);            break;        case TType.I16:            final short s = in.readI16();            writeShortAction(buffer, s);            break;                case TType.ENUM:        case TType.I32:            final int i = in.readI32();            checkEnum(expectedType, i);            writeIntAction(buffer, i);            break;        case TType.I64:            final long l = in.readI64();            writeLongAction(buffer, l);            break;        case TType.STRING:            final ByteBuffer bin = in.readBinary();            writeStringAction(buffer, bin);            break;        case TType.VOID:            break;        default:            throw new TException("Unknown type: " + type);    }    return hasFieldsIgnored;}
af0c3eca7b5dedd1a504c4e4ee84e430b5b39a8f42860426afd961f50980dddf
writeStringAction
private void writeStringAction(List<Action> buffer, final ByteBuffer bin)
{    buffer.add(new Action() {        @Override        public void write(TProtocol out) throws TException {            out.writeBinary(bin);        }        @Override        public String toDebugString() {            return String.valueOf(bin);        }    });}
cfbe67b070603fd1ce7103794cde32d42151c860eed5f3b056f5895ea381ba8a
write
public void write(TProtocol out) throws TException
{    out.writeBinary(bin);}
6cb78d1dfb9d9e4dc5785009730b403d190d6b55ac688b94d6714b823187846e
toDebugString
public String toDebugString()
{    return String.valueOf(bin);}
a2a7a032948ee38b28bb04cb804dd1907e3eaa14a362f032df15ce0a85fed04b
writeLongAction
private void writeLongAction(List<Action> buffer, final long l)
{    buffer.add(new Action() {        @Override        public void write(TProtocol out) throws TException {            out.writeI64(l);        }        @Override        public String toDebugString() {            return String.valueOf(l);        }    });}
cfbe67b070603fd1ce7103794cde32d42151c860eed5f3b056f5895ea381ba8a
write
public void write(TProtocol out) throws TException
{    out.writeI64(l);}
6cb78d1dfb9d9e4dc5785009730b403d190d6b55ac688b94d6714b823187846e
toDebugString
public String toDebugString()
{    return String.valueOf(l);}
e315bf4146da0c1862d841466d82351d33c89d86d31f69f234a9c2cb3c083bf3
writeIntAction
private void writeIntAction(List<Action> buffer, final int i)
{    buffer.add(new Action() {        @Override        public void write(TProtocol out) throws TException {            out.writeI32(i);        }        @Override        public String toDebugString() {            return String.valueOf(i);        }    });}
cfbe67b070603fd1ce7103794cde32d42151c860eed5f3b056f5895ea381ba8a
write
public void write(TProtocol out) throws TException
{    out.writeI32(i);}
6cb78d1dfb9d9e4dc5785009730b403d190d6b55ac688b94d6714b823187846e
toDebugString
public String toDebugString()
{    return String.valueOf(i);}
55aef0b7908bd451d93123d692461021f853dee17e6c776843dc85421d019144
writeShortAction
private void writeShortAction(List<Action> buffer, final short s)
{    buffer.add(new Action() {        @Override        public void write(TProtocol out) throws TException {            out.writeI16(s);        }        @Override        public String toDebugString() {            return String.valueOf(s);        }    });}
cfbe67b070603fd1ce7103794cde32d42151c860eed5f3b056f5895ea381ba8a
write
public void write(TProtocol out) throws TException
{    out.writeI16(s);}
6cb78d1dfb9d9e4dc5785009730b403d190d6b55ac688b94d6714b823187846e
toDebugString
public String toDebugString()
{    return String.valueOf(s);}
726b19ddfdd059d31888c800f76b39604bd1546cb2aa33552f2deda1241f1622
writeDoubleAction
private void writeDoubleAction(List<Action> buffer, final double d)
{    buffer.add(new Action() {        @Override        public void write(TProtocol out) throws TException {            out.writeDouble(d);        }        @Override        public String toDebugString() {            return String.valueOf(d);        }    });}
cfbe67b070603fd1ce7103794cde32d42151c860eed5f3b056f5895ea381ba8a
write
public void write(TProtocol out) throws TException
{    out.writeDouble(d);}
6cb78d1dfb9d9e4dc5785009730b403d190d6b55ac688b94d6714b823187846e
toDebugString
public String toDebugString()
{    return String.valueOf(d);}
7a6ebeee90434fef4363d15a12edc8aeda9293054409a87cfc23aa6791cfd0f0
writeByteAction
private void writeByteAction(List<Action> buffer, final byte b)
{    buffer.add(new Action() {        @Override        public void write(TProtocol out) throws TException {            out.writeByte(b);        }        @Override        public String toDebugString() {            return String.valueOf(b);        }    });}
cfbe67b070603fd1ce7103794cde32d42151c860eed5f3b056f5895ea381ba8a
write
public void write(TProtocol out) throws TException
{    out.writeByte(b);}
6cb78d1dfb9d9e4dc5785009730b403d190d6b55ac688b94d6714b823187846e
toDebugString
public String toDebugString()
{    return String.valueOf(b);}
a0fce774c356fae73ce9b72d7245815fd3793d44e09421db005af0b608ea63ad
writeBoolAction
private void writeBoolAction(List<Action> buffer, final boolean bool)
{    buffer.add(new Action() {        @Override        public void write(TProtocol out) throws TException {            out.writeBool(bool);        }        @Override        public String toDebugString() {            return String.valueOf(bool);        }    });}
cfbe67b070603fd1ce7103794cde32d42151c860eed5f3b056f5895ea381ba8a
write
public void write(TProtocol out) throws TException
{    out.writeBool(bool);}
6cb78d1dfb9d9e4dc5785009730b403d190d6b55ac688b94d6714b823187846e
toDebugString
public String toDebugString()
{    return String.valueOf(bool);}
c82b1b3097f1c6cfaa21cedabaae472565ef73b1619b2c82102e38d783281093
typeName
private String typeName(byte type)
{    try {        return ThriftTypeID.fromByte(type).name();    } catch (RuntimeException e) {        return String.valueOf(type);    }}
a1315d124451ea4b77d21935517cbd01dcd99ea4710ea22298ac7aa5ec9f1c6e
readOneStruct
private boolean readOneStruct(TProtocol in, List<Action> buffer, StructType type) throws TException
{    final TStruct struct = in.readStructBegin();    buffer.add(new Action() {        @Override        public void write(TProtocol out) throws TException {            out.writeStructBegin(struct);        }        @Override        public String toDebugString() {            return "(";        }    });    TField field;    boolean hasFieldsIgnored = false;    int childFieldsPresent = 0;    while ((field = in.readFieldBegin()).type != TType.STOP) {        final TField currentField = field;        ThriftField expectedField;        if ((expectedField = type.getChildById(field.id)) == null) {            handleUnrecognizedField(field, type, in);            hasFieldsIgnored |= true;            continue;        }        childFieldsPresent++;        buffer.add(new Action() {            @Override            public void write(TProtocol out) throws TException {                out.writeFieldBegin(currentField);            }            @Override            public String toDebugString() {                return "f=" + currentField.id + "<t=" + typeName(currentField.type) + ">: ";            }        });        hasFieldsIgnored |= readOneValue(in, field.type, buffer, expectedField.getType());        in.readFieldEnd();        buffer.add(FIELD_END);    }        assertUnionHasExactlyOneChild(type, childFieldsPresent);    in.readStructEnd();    buffer.add(STRUCT_END);    return hasFieldsIgnored;}
cfbe67b070603fd1ce7103794cde32d42151c860eed5f3b056f5895ea381ba8a
write
public void write(TProtocol out) throws TException
{    out.writeStructBegin(struct);}
6cb78d1dfb9d9e4dc5785009730b403d190d6b55ac688b94d6714b823187846e
toDebugString
public String toDebugString()
{    return "(";}
cfbe67b070603fd1ce7103794cde32d42151c860eed5f3b056f5895ea381ba8a
write
public void write(TProtocol out) throws TException
{    out.writeFieldBegin(currentField);}
6cb78d1dfb9d9e4dc5785009730b403d190d6b55ac688b94d6714b823187846e
toDebugString
public String toDebugString()
{    return "f=" + currentField.id + "<t=" + typeName(currentField.type) + ">: ";}
5343597569077130ee7644b979228f888fb94ecb0de2bf60011394f1e428bcf1
handleUnrecognizedField
private void handleUnrecognizedField(TField field, StructType type, TProtocol in) throws TException
{    switch(type.getStructOrUnionType()) {        case STRUCT:                        notifyIgnoredFieldsOfRecord(field);                        new ProtocolReadToWrite().readOneValue(in, new NullProtocol(), field.type);            break;        case UNION:                        throw new DecodingSchemaMismatchException("Unrecognized union member with id: " + field.id + " for struct:\n" + type);        case UNKNOWN:            throw unknownStructOrUnion(type);        default:            throw unrecognizedStructOrUnion(type.getStructOrUnionType());    }}
8377e943eec3a109c838eaf5368c80fb9121f5f15f1491b6661d26151f92d603
assertUnionHasExactlyOneChild
private void assertUnionHasExactlyOneChild(StructType type, int childFieldsPresent)
{    switch(type.getStructOrUnionType()) {        case STRUCT:                        break;        case UNION:                        if (childFieldsPresent != 1) {                if (childFieldsPresent == 0) {                    throw new DecodingSchemaMismatchException("Cannot write a TUnion with no set value in :\n" + type);                } else {                    throw new DecodingSchemaMismatchException("Cannot write a TUnion with more than 1 set value in :\n" + type);                }            }            break;        case UNKNOWN:            throw unknownStructOrUnion(type);        default:            throw unrecognizedStructOrUnion(type.getStructOrUnionType());    }}
d15e73c48f9cc7a8c7eaa36952f86016deeeac8ba80c8cf47b73a83ef0f1e665
unrecognizedStructOrUnion
private static ShouldNeverHappenException unrecognizedStructOrUnion(StructOrUnionType type)
{    return new ShouldNeverHappenException("Unrecognized StructOrUnionType: " + type);}
b3dc71f2230b3db12c28b08a943c0ea1a58d64f8353e77611e2de06d964b6720
unknownStructOrUnion
private static ShouldNeverHappenException unknownStructOrUnion(StructType type)
{    return new ShouldNeverHappenException("This should never happen! " + "Don't know if this field is a union, was the deprecated constructor of StructType used?\n" + type);}
1a3e6997676fc20f1296aa747b12f160f8e845b47d1c6fe7e523968a5a4121e2
readOneMap
private boolean readOneMap(TProtocol in, List<Action> buffer, MapType mapType) throws TException
{    final TMap map = in.readMapBegin();    buffer.add(new Action() {        @Override        public void write(TProtocol out) throws TException {            out.writeMapBegin(map);        }        @Override        public String toDebugString() {            return "<k=" + map.keyType + ", v=" + map.valueType + ", s=" + map.size + ">[";        }    });    boolean hasFieldIgnored = false;    for (int i = 0; i < map.size; i++) {        hasFieldIgnored |= readOneValue(in, map.keyType, buffer, mapType.getKey().getType());        hasFieldIgnored |= readOneValue(in, map.valueType, buffer, mapType.getValue().getType());    }    in.readMapEnd();    buffer.add(MAP_END);    return hasFieldIgnored;}
cfbe67b070603fd1ce7103794cde32d42151c860eed5f3b056f5895ea381ba8a
write
public void write(TProtocol out) throws TException
{    out.writeMapBegin(map);}
6cb78d1dfb9d9e4dc5785009730b403d190d6b55ac688b94d6714b823187846e
toDebugString
public String toDebugString()
{    return "<k=" + map.keyType + ", v=" + map.valueType + ", s=" + map.size + ">[";}
2577ab59ac651fedaabcc8454a53bbed1baeb648c51771c7acf57a260116ac30
readOneSet
private boolean readOneSet(TProtocol in, List<Action> buffer, SetType expectedType) throws TException
{    final TSet set = in.readSetBegin();    buffer.add(new Action() {        @Override        public void write(TProtocol out) throws TException {            out.writeSetBegin(set);        }        @Override        public String toDebugString() {            return "<e=" + set.elemType + ", s=" + set.size + ">{*";        }    });    boolean hasFieldsIgnored = readCollectionElements(in, set.size, set.elemType, buffer, expectedType.getValues().getType());    in.readSetEnd();    buffer.add(SET_END);    return hasFieldsIgnored;}
cfbe67b070603fd1ce7103794cde32d42151c860eed5f3b056f5895ea381ba8a
write
public void write(TProtocol out) throws TException
{    out.writeSetBegin(set);}
6cb78d1dfb9d9e4dc5785009730b403d190d6b55ac688b94d6714b823187846e
toDebugString
public String toDebugString()
{    return "<e=" + set.elemType + ", s=" + set.size + ">{*";}
795d47a21e75a7f198177a100be141f6e91cd17943925c09364d452658949714
readOneList
private boolean readOneList(TProtocol in, List<Action> buffer, ListType expectedType) throws TException
{    final TList list = in.readListBegin();    buffer.add(new Action() {        @Override        public void write(TProtocol out) throws TException {            out.writeListBegin(list);        }        @Override        public String toDebugString() {            return "<e=" + list.elemType + ", s=" + list.size + ">{";        }    });    boolean hasFieldsIgnored = readCollectionElements(in, list.size, list.elemType, buffer, expectedType.getValues().getType());    in.readListEnd();    buffer.add(LIST_END);    return hasFieldsIgnored;}
cfbe67b070603fd1ce7103794cde32d42151c860eed5f3b056f5895ea381ba8a
write
public void write(TProtocol out) throws TException
{    out.writeListBegin(list);}
6cb78d1dfb9d9e4dc5785009730b403d190d6b55ac688b94d6714b823187846e
toDebugString
public String toDebugString()
{    return "<e=" + list.elemType + ", s=" + list.size + ">{";}
f8b79a973c17d3669fb8f2e6674f999efa4976deb3272c7fcfcf7cffc22ef931
readCollectionElements
private boolean readCollectionElements(TProtocol in, final int size, final byte elemType, List<Action> buffer, ThriftType expectedType) throws TException
{    boolean hasFieldIgnored = false;    for (int i = 0; i < size; i++) {        hasFieldIgnored |= readOneValue(in, elemType, buffer, expectedType);    }    return hasFieldIgnored;}
bc85c0b605a5b3135f55343b96d0c928551401c6fc7f082955cc48b0da36b194
checkEnum
private void checkEnum(ThriftType expectedType, int i)
{    if (expectedType.getType() == ThriftTypeID.ENUM) {        ThriftType.EnumType expectedEnumType = (ThriftType.EnumType) expectedType;        if (expectedEnumType.getEnumValueById(i) == null) {            throw new DecodingSchemaMismatchException("can not find index " + i + " in enum " + expectedType);        }    }}
ee4220646f39072fb075362a365f2c9cd100e13deca8c3494b6b5eccd34b39fe
writeMessageBegin
public void writeMessageBegin(TMessage tMessage) throws TException
{}
ade94bcb84429ca34b3ac1ffccc0acc87510cd06267edc8ad0ed40cef78b39be
writeMessageEnd
public void writeMessageEnd() throws TException
{}
8c7e3a8554475fcb354a64f12f51e5781045eaeb0e6323a3f632afe348116035
writeStructBegin
public void writeStructBegin(TStruct tStruct) throws TException
{}
5010522f36971f2f24e6875669da519eedd379b8640ddb4a0af7cde61d7658f1
writeStructEnd
public void writeStructEnd() throws TException
{}
5b035e4be4e1fabf272a19aa88d88a2e3ce48a87fc0485dfadd1b65561ba72ee
writeFieldBegin
public void writeFieldBegin(TField tField) throws TException
{}
b0a830717a657c899097e3e736493aef0faf6dfb430e313b020bb0bc8b19e69d
writeFieldEnd
public void writeFieldEnd() throws TException
{}
63fb9d3a4e5cbe6779cc99e3ffabfbdd3e3e28004f4746a682d3adbc8c35c688
writeFieldStop
public void writeFieldStop() throws TException
{}
0a4e75c13828ef2957b610a84b37612b26ce942eb8c342115a5f1ad8f072f2b5
writeMapBegin
public void writeMapBegin(TMap tMap) throws TException
{}
67f363c30f9232259c0c23dfa790d0a3f2e19a688b3722f5022b7740792babc3
writeMapEnd
public void writeMapEnd() throws TException
{}
84b46171041ad883fc1a7b8f56bc7ff9c48106513a1c8b1bd342320c5479eed4
writeListBegin
public void writeListBegin(TList tList) throws TException
{}
da56dbd294fd9e9d40f80049f21ed2188c3c2af2f491f4891f69bcbe9db1a4f5
writeListEnd
public void writeListEnd() throws TException
{}
e63d2611c376f27cb48e8eda2d499feed0d564581763aec418c2c23d5803080d
writeSetBegin
public void writeSetBegin(TSet tSet) throws TException
{}
28c6e88e95a0808e952fbe67452962d4a597da72aa56238d97a567ddd1869239
writeSetEnd
public void writeSetEnd() throws TException
{}
8d51211e99f12413f17007de4e371cf8d247ef1e73702baa074d51179537a9af
writeBool
public void writeBool(boolean b) throws TException
{}
be49bceacc378be83521557b99caf10bf06185e2eef7a78a1152a3694a4d6b2c
writeByte
public void writeByte(byte b) throws TException
{}
fbb2f47610f6b15a4261469db5575327ed3e000c6348d069b37248acee4560fb
writeI16
public void writeI16(short i) throws TException
{}
9235d5d3ce1a899ab16335e9b81c5e1cc26184d259c21e8f3510016ff1045d48
writeI32
public void writeI32(int i) throws TException
{}
6871a6a2ca1878e74f82c3bd7a11ec96483886397e79eb8cc82b38e80da6c2c7
writeI64
public void writeI64(long l) throws TException
{}
c13deb4c6e44a50f3ac2261ca282ea1255cc538d93505cbd47870ceb1b6ea163
writeDouble
public void writeDouble(double v) throws TException
{}
fe2417195337be5784f8025cf8d5cd3fd03dd675da7018b80fd0ade6a9f8fa35
writeString
public void writeString(String s) throws TException
{}
3206ddd42da2b335078fd4f2774c96debdf05ae3294b379660e008f300f0cf8e
writeBinary
public void writeBinary(ByteBuffer byteBuffer) throws TException
{}
c6ab4f5d84fcab78958bee81390e6ada7da59b5847e76b5d129f058f70e05975
readMessageBegin
public TMessage readMessageBegin() throws TException
{    return null;}
49dda8daa7cd38d4ed0a88e9d4e712e102114876e873a30f58897265526217e0
readMessageEnd
public void readMessageEnd() throws TException
{}
4581ce92c1c14390774b3334899b0792f18429a4fa86e1eab50f00a0c8e87c3b
readStructBegin
public TStruct readStructBegin() throws TException
{    return null;}
313291383bc799a61a64fd536cdb66162569f48a255366c7cc2e937412433b56
readStructEnd
public void readStructEnd() throws TException
{}
6771498943d82d6987ae6cbbe2274166a2ff9ce14f84ac60f6a13d9df78f9b26
readFieldBegin
public TField readFieldBegin() throws TException
{    return null;}
0ba8e2da944ada1e2b2f96d56fd37a118dc4e3ae0abe06e5d3269bb901ff0383
readFieldEnd
public void readFieldEnd() throws TException
{}
ccef29d31156242180b2595fbe4f2e8f11ecb097f7eb5013f5cfbcbadb7d3f2b
readMapBegin
public TMap readMapBegin() throws TException
{    return null;}
2a5867240c482ae3a61d58bbbb1c1b7e42b363a1f64c6cd3524c0470d749c9a0
readMapEnd
public void readMapEnd() throws TException
{}
f11327b40a2aa7489a812533ff4e918785c8373aaf59343add9f4bbcdcfd11f0
readListBegin
public TList readListBegin() throws TException
{    return null;}
751f723cedbf7b8de4f12a4df7d3afebe4ff7079c529f2086892ae666fc1bf34
readListEnd
public void readListEnd() throws TException
{}
5b0265bf5be1a6ae8196064eb3a9728c746c5a31b8da6f6e24655b5b965b45dc
readSetBegin
public TSet readSetBegin() throws TException
{    return null;}
6d0d71f10658b2a33eefe039338687f1c171606506f807722885f53093eb40ca
readSetEnd
public void readSetEnd() throws TException
{}
e3ae4a5d2127da24daf3630c1e497e9da2943770af69da55e3286e71d1fc6e10
readBool
public boolean readBool() throws TException
{    return false;}
d0afc620362c8c05d0f9d6409f34df154f23b95cbd7164d4d31708bf01bfc254
readByte
public byte readByte() throws TException
{    return 0;}
ba19a1b6b27a9d1241b1532c49518058e1c6aae1b2fce864cac33b0323b4e9ed
readI16
public short readI16() throws TException
{    return 0;}
9cdce61957c527c2da4806031bffb0b62837efdf684b720ac095ddc794ad3be4
readI32
public int readI32() throws TException
{    return 0;}
effebad19b862ab3187f7a56079de27779133ee1979be7276c1ea72d6bec8a0b
readI64
public long readI64() throws TException
{    return 0;}
13e5eb98c42fdbefd38e11fed60126ad859699a84615bbae60805a0c45f03126
readDouble
public double readDouble() throws TException
{    return 0;}
00b5d4f7589ed91042175c05b813cc60c9649f639b471d6be729691cd5b52bd7
readString
public String readString() throws TException
{    return null;}
a4bf98b9a9e380c02f650aea16d41e5140ec75fdfa57c19ba07e0787d5cb43b9
readBinary
public ByteBuffer readBinary() throws TException
{    return null;}
acbde9e30e0ecf64632312ba11e51947dbad2a7baa37aff93b63032f3be006da
isKeep
public boolean isKeep()
{    return false;}
f0a267503ab2a7aec89a1b3ceebaaf8874d4c0f61dacd2e7c154812a25331dd8
asKeep
public Keep asKeep()
{    throw new ShouldNeverHappenException("asKeep called on " + this);}
356cc18088b399e9367cd74df09c80273703ec4f8144ac59c4f30c8bf16904ca
isDrop
public boolean isDrop()
{    return false;}
e782d63f3a745c17921f49be932b9b8c9c9eba8c7d7e057ce7bb754042851402
asDrop
public Drop asDrop()
{    throw new ShouldNeverHappenException("asDrop called on " + this);}
71eb8f963537c6b7c30ad2132d7df9507ffc2aeb385f958340970257d7940b17
isSentinelUnion
public boolean isSentinelUnion()
{    return false;}
ec41fbe9a55ccf31a473666201b259e11ff4f41bf508b10cfc07e2e8649e11b3
asSentinelUnion
public SentinelUnion asSentinelUnion()
{    throw new ShouldNeverHappenException("asSentinelUnion called on " + this);}
2c34918b8491b542843ad044178d528f1980f0fd420a6a10c95bac4e8dc65553
path
public FieldsPath path()
{    return path;}
acbde9e30e0ecf64632312ba11e51947dbad2a7baa37aff93b63032f3be006da
isKeep
public boolean isKeep()
{    return true;}
f0a267503ab2a7aec89a1b3ceebaaf8874d4c0f61dacd2e7c154812a25331dd8
asKeep
public Keep asKeep()
{    return this;}
b36c0cb78d388571653840506cba5d90e12b262c755658912fc2224c314bcbf6
getType
public Type getType()
{    return type;}
71eb8f963537c6b7c30ad2132d7df9507ffc2aeb385f958340970257d7940b17
isSentinelUnion
public boolean isSentinelUnion()
{    return true;}
ec41fbe9a55ccf31a473666201b259e11ff4f41bf508b10cfc07e2e8649e11b3
asSentinelUnion
public SentinelUnion asSentinelUnion()
{    return this;}
b36c0cb78d388571653840506cba5d90e12b262c755658912fc2224c314bcbf6
getType
public Type getType()
{    return type;}
356cc18088b399e9367cd74df09c80273703ec4f8144ac59c4f30c8bf16904ca
isDrop
public boolean isDrop()
{    return true;}
e782d63f3a745c17921f49be932b9b8c9c9eba8c7d7e057ce7bb754042851402
asDrop
public Drop asDrop()
{    return this;}
5e86374aed53ae808a885d12660b78da54852dbaf984433526574816342cacb9
handleRecordHasFieldIgnored
public void handleRecordHasFieldIgnored()
{}
c6d4c026a5d7600a6f6997c9acf2b33ef7ec477daefd17a7d1cea2eeef239341
handleFieldIgnored
public void handleFieldIgnored(TField field)
{}
667b47c71439086e0a74774e9c35ca5cf2078072eb62cff550d1b898003b19d1
keep
public boolean keep(FieldsPath path)
{    if (found) {        return false;    }    found = true;    return true;}
8e4f2a3c268396796f03960e703603a701a7cc875d51fd4fccbed9a65cbe7526
assertNoUnmatchedPatterns
public void assertNoUnmatchedPatterns() throws ThriftProjectionException
{}
2013d4d074215f3e0f1ec0149fd5a515ea868b552b8490ea6186109e7deba24b
getClassInfo
private String getClassInfo()
{    final Class<? extends ParquetProtocol> clazz = getClass();    final Method enclosingMethod = clazz.getEnclosingMethod();    if (enclosingMethod != null) {        return clazz.getName() + " in " + enclosingMethod.toGenericString();    }    return clazz.getName();}
cf787e1cd8b1f98c1738e8caf657964088b78cf2aeebd646bbcf8a242747b792
exception
private TException exception()
{    String message = name == null ? "in " + getClassInfo() : "when we expected " + name + " in " + getClassInfo();    return new TException(new UnsupportedOperationException(new Exception().getStackTrace()[1].getMethodName() + " was called " + message));}
6e40e5cf513a809dc50dcdd328059e0c91563b4e305762fe100219b231c6dc54
writeMessageBegin
public void writeMessageBegin(TMessage message) throws TException
{    throw exception();}
ade94bcb84429ca34b3ac1ffccc0acc87510cd06267edc8ad0ed40cef78b39be
writeMessageEnd
public void writeMessageEnd() throws TException
{    throw exception();}
20dc992c59eb5c65b7b90e25660bfc1481e15b20d117fe08ace652816e9c445b
writeStructBegin
public void writeStructBegin(TStruct struct) throws TException
{    throw exception();}
5010522f36971f2f24e6875669da519eedd379b8640ddb4a0af7cde61d7658f1
writeStructEnd
public void writeStructEnd() throws TException
{    throw exception();}
64d9ca4acffc3a8699f25fc5f94ade23da81b62bc424b46c1653856d57271ac9
writeFieldBegin
public void writeFieldBegin(TField field) throws TException
{    throw exception();}
b0a830717a657c899097e3e736493aef0faf6dfb430e313b020bb0bc8b19e69d
writeFieldEnd
public void writeFieldEnd() throws TException
{    throw exception();}
63fb9d3a4e5cbe6779cc99e3ffabfbdd3e3e28004f4746a682d3adbc8c35c688
writeFieldStop
public void writeFieldStop() throws TException
{    throw exception();}
dcde37228f607b0b7e2604909079cdb3ac5768c8a4652c8047c51f97e2b72923
writeMapBegin
public void writeMapBegin(TMap map) throws TException
{    throw exception();}
67f363c30f9232259c0c23dfa790d0a3f2e19a688b3722f5022b7740792babc3
writeMapEnd
public void writeMapEnd() throws TException
{    throw exception();}
d9a67025b8f7c6c7661007c24445a49d4c582691acc753ead1143988200f3564
writeListBegin
public void writeListBegin(TList list) throws TException
{    throw exception();}
da56dbd294fd9e9d40f80049f21ed2188c3c2af2f491f4891f69bcbe9db1a4f5
writeListEnd
public void writeListEnd() throws TException
{    throw exception();}
0e77a5eb1b9addd6787ba2d53261ea79f7759d3e93c3802ae83789d183e0069d
writeSetBegin
public void writeSetBegin(TSet set) throws TException
{    throw exception();}
28c6e88e95a0808e952fbe67452962d4a597da72aa56238d97a567ddd1869239
writeSetEnd
public void writeSetEnd() throws TException
{    throw exception();}
8d51211e99f12413f17007de4e371cf8d247ef1e73702baa074d51179537a9af
writeBool
public void writeBool(boolean b) throws TException
{    throw exception();}
be49bceacc378be83521557b99caf10bf06185e2eef7a78a1152a3694a4d6b2c
writeByte
public void writeByte(byte b) throws TException
{    throw exception();}
6011ebac32f1841cc3594f03ba466ef0a3224ba6b2dca594fe9e54e69b12dcd1
writeI16
public void writeI16(short i16) throws TException
{    throw exception();}
09c4dd32fada8b5897257a4f8bc3ac37dddaa946b64adc9e0d81fa15184ecf91
writeI32
public void writeI32(int i32) throws TException
{    throw exception();}
9debc22382676ead907181f78b9352e9216b0614ca4d72b5651b9c5dace5974c
writeI64
public void writeI64(long i64) throws TException
{    throw exception();}
625514537dfb535a0c170483331a32cc17a9536725dc2c4a8435b99c8c74e37a
writeDouble
public void writeDouble(double dub) throws TException
{    throw exception();}
577a22fa000fa7c1262c7a2e6b6c5d943d78e9c16e7e2f302e1379873c98897c
writeString
public void writeString(String str) throws TException
{    throw exception();}
9353686a74c9a338b24da7a843112e9ea342b14072ee2373f57ca35d7a8fb3fb
writeBinary
public void writeBinary(ByteBuffer buf) throws TException
{    throw exception();}
c6ab4f5d84fcab78958bee81390e6ada7da59b5847e76b5d129f058f70e05975
readMessageBegin
public TMessage readMessageBegin() throws TException
{    throw exception();}
49dda8daa7cd38d4ed0a88e9d4e712e102114876e873a30f58897265526217e0
readMessageEnd
public void readMessageEnd() throws TException
{    throw exception();}
4581ce92c1c14390774b3334899b0792f18429a4fa86e1eab50f00a0c8e87c3b
readStructBegin
public TStruct readStructBegin() throws TException
{    throw exception();}
313291383bc799a61a64fd536cdb66162569f48a255366c7cc2e937412433b56
readStructEnd
public void readStructEnd() throws TException
{    throw exception();}
6771498943d82d6987ae6cbbe2274166a2ff9ce14f84ac60f6a13d9df78f9b26
readFieldBegin
public TField readFieldBegin() throws TException
{    throw exception();}
0ba8e2da944ada1e2b2f96d56fd37a118dc4e3ae0abe06e5d3269bb901ff0383
readFieldEnd
public void readFieldEnd() throws TException
{    throw exception();}
ccef29d31156242180b2595fbe4f2e8f11ecb097f7eb5013f5cfbcbadb7d3f2b
readMapBegin
public TMap readMapBegin() throws TException
{    throw exception();}
2a5867240c482ae3a61d58bbbb1c1b7e42b363a1f64c6cd3524c0470d749c9a0
readMapEnd
public void readMapEnd() throws TException
{    throw exception();}
f11327b40a2aa7489a812533ff4e918785c8373aaf59343add9f4bbcdcfd11f0
readListBegin
public TList readListBegin() throws TException
{    throw exception();}
751f723cedbf7b8de4f12a4df7d3afebe4ff7079c529f2086892ae666fc1bf34
readListEnd
public void readListEnd() throws TException
{    throw exception();}
5b0265bf5be1a6ae8196064eb3a9728c746c5a31b8da6f6e24655b5b965b45dc
readSetBegin
public TSet readSetBegin() throws TException
{    throw exception();}
6d0d71f10658b2a33eefe039338687f1c171606506f807722885f53093eb40ca
readSetEnd
public void readSetEnd() throws TException
{    throw exception();}
e3ae4a5d2127da24daf3630c1e497e9da2943770af69da55e3286e71d1fc6e10
readBool
public boolean readBool() throws TException
{    throw exception();}
d0afc620362c8c05d0f9d6409f34df154f23b95cbd7164d4d31708bf01bfc254
readByte
public byte readByte() throws TException
{    throw exception();}
ba19a1b6b27a9d1241b1532c49518058e1c6aae1b2fce864cac33b0323b4e9ed
readI16
public short readI16() throws TException
{    throw exception();}
9cdce61957c527c2da4806031bffb0b62837efdf684b720ac095ddc794ad3be4
readI32
public int readI32() throws TException
{    throw exception();}
effebad19b862ab3187f7a56079de27779133ee1979be7276c1ea72d6bec8a0b
readI64
public long readI64() throws TException
{    throw exception();}
13e5eb98c42fdbefd38e11fed60126ad859699a84615bbae60805a0c45f03126
readDouble
public double readDouble() throws TException
{    throw exception();}
00b5d4f7589ed91042175c05b813cc60c9649f639b471d6be729691cd5b52bd7
readString
public String readString() throws TException
{    throw exception();}
a4bf98b9a9e380c02f650aea16d41e5140ec75fdfa57c19ba07e0787d5cb43b9
readBinary
public ByteBuffer readBinary() throws TException
{    throw exception();}
f0f2a257ce8a84d89c0c55cb055a944b05680d9f819663fc4efddfa7a84cfd74
add
public void add(TProtocol p)
{    events.addLast(p);}
ac5b852fdda46dd72f92883687bd5f80f9e71b0163dfd0d056b3be7199bd2826
addAll
public void addAll(Collection<TProtocol> events)
{    this.events.addAll(events);}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    this.events.clear();}
e766d91060477632ca7f19043c6d992fbf734b9274b84ba78706550be2dd35a9
next
private TProtocol next()
{    return events.removeFirst();}
c6ab4f5d84fcab78958bee81390e6ada7da59b5847e76b5d129f058f70e05975
readMessageBegin
public TMessage readMessageBegin() throws TException
{    LOG.debug("readMessageBegin()");    return next().readMessageBegin();}
49dda8daa7cd38d4ed0a88e9d4e712e102114876e873a30f58897265526217e0
readMessageEnd
public void readMessageEnd() throws TException
{    LOG.debug("readMessageEnd()");    next().readMessageEnd();}
4581ce92c1c14390774b3334899b0792f18429a4fa86e1eab50f00a0c8e87c3b
readStructBegin
public TStruct readStructBegin() throws TException
{    LOG.debug("readStructBegin()");    return next().readStructBegin();}
313291383bc799a61a64fd536cdb66162569f48a255366c7cc2e937412433b56
readStructEnd
public void readStructEnd() throws TException
{    LOG.debug("readStructEnd()");    next().readStructEnd();}
6771498943d82d6987ae6cbbe2274166a2ff9ce14f84ac60f6a13d9df78f9b26
readFieldBegin
public TField readFieldBegin() throws TException
{    LOG.debug("readFieldBegin()");    return next().readFieldBegin();}
0ba8e2da944ada1e2b2f96d56fd37a118dc4e3ae0abe06e5d3269bb901ff0383
readFieldEnd
public void readFieldEnd() throws TException
{    LOG.debug("readFieldEnd()");    next().readFieldEnd();}
ccef29d31156242180b2595fbe4f2e8f11ecb097f7eb5013f5cfbcbadb7d3f2b
readMapBegin
public TMap readMapBegin() throws TException
{    LOG.debug("readMapBegin()");    return next().readMapBegin();}
2a5867240c482ae3a61d58bbbb1c1b7e42b363a1f64c6cd3524c0470d749c9a0
readMapEnd
public void readMapEnd() throws TException
{    LOG.debug("readMapEnd()");    next().readMapEnd();}
f11327b40a2aa7489a812533ff4e918785c8373aaf59343add9f4bbcdcfd11f0
readListBegin
public TList readListBegin() throws TException
{    LOG.debug("readListBegin()");    return next().readListBegin();}
751f723cedbf7b8de4f12a4df7d3afebe4ff7079c529f2086892ae666fc1bf34
readListEnd
public void readListEnd() throws TException
{    LOG.debug("readListEnd()");    next().readListEnd();}
5b0265bf5be1a6ae8196064eb3a9728c746c5a31b8da6f6e24655b5b965b45dc
readSetBegin
public TSet readSetBegin() throws TException
{    LOG.debug("readSetBegin()");    return next().readSetBegin();}
6d0d71f10658b2a33eefe039338687f1c171606506f807722885f53093eb40ca
readSetEnd
public void readSetEnd() throws TException
{    LOG.debug("readSetEnd()");    next().readSetEnd();}
e3ae4a5d2127da24daf3630c1e497e9da2943770af69da55e3286e71d1fc6e10
readBool
public boolean readBool() throws TException
{    LOG.debug("readBool()");    return next().readBool();}
d0afc620362c8c05d0f9d6409f34df154f23b95cbd7164d4d31708bf01bfc254
readByte
public byte readByte() throws TException
{    LOG.debug("readByte()");    return next().readByte();}
ba19a1b6b27a9d1241b1532c49518058e1c6aae1b2fce864cac33b0323b4e9ed
readI16
public short readI16() throws TException
{    LOG.debug("readI16()");    return next().readI16();}
9cdce61957c527c2da4806031bffb0b62837efdf684b720ac095ddc794ad3be4
readI32
public int readI32() throws TException
{    LOG.debug("readI32()");    return next().readI32();}
effebad19b862ab3187f7a56079de27779133ee1979be7276c1ea72d6bec8a0b
readI64
public long readI64() throws TException
{    LOG.debug("readI64()");    return next().readI64();}
13e5eb98c42fdbefd38e11fed60126ad859699a84615bbae60805a0c45f03126
readDouble
public double readDouble() throws TException
{    LOG.debug("readDouble()");    return next().readDouble();}
00b5d4f7589ed91042175c05b813cc60c9649f639b471d6be729691cd5b52bd7
readString
public String readString() throws TException
{    LOG.debug("readString()");    return next().readString();}
a4bf98b9a9e380c02f650aea16d41e5140ec75fdfa57c19ba07e0787d5cb43b9
readBinary
public ByteBuffer readBinary() throws TException
{    LOG.debug("readBinary()");    return next().readBinary();}
45d085a61b0d7f7c587e5b8b449b868ebc6772c33e5957892ccde283d250ae87
start
 void start()
{    this.returnClause.start();}
798618ef94f4fe6e9e47e7cb28c70c76733abe95657fc0b38b2916747d79c908
end
 void end()
{    this.returnClause.end();}
09c4dd32fada8b5897257a4f8bc3ac37dddaa946b64adc9e0d81fa15184ecf91
writeI32
public void writeI32(int i32) throws TException
{    start();    EnumValue value = type.getEnumValueById(i32);    if (value == null) {        throw new ParquetEncodingException("Can not find enum value of index " + i32 + " for field:" + columnIO.toString());    }    recordConsumer.addBinary(Binary.fromString(value.getName()));    end();}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    ++consumedRecords;    if (consumedRecords == size) {        currentProtocol = ListWriteProtocol.this;        consumedRecords = 0;    }}
d49a7cccd8c5af88a3395efa7b30fda088da96ff30b2ee50638e63171fcc9566
startListWrapper
private void startListWrapper()
{    start();    recordConsumer.startGroup();    if (size > 0) {        recordConsumer.startField(listContent.getType().getName(), 0);        currentProtocol = contentProtocol;    }}
cbcece150f17e6bd154d8d1807218aed5d6bed501731f64f3923d2afa14edaf3
endListWrapper
private void endListWrapper()
{    if (size > 0) {        recordConsumer.endField(listContent.getType().getName(), 0);    }    recordConsumer.endGroup();    end();}
d9a67025b8f7c6c7661007c24445a49d4c582691acc753ead1143988200f3564
writeListBegin
public void writeListBegin(TList list) throws TException
{    size = list.size;    startListWrapper();}
da56dbd294fd9e9d40f80049f21ed2188c3c2af2f491f4891f69bcbe9db1a4f5
writeListEnd
public void writeListEnd() throws TException
{    endListWrapper();}
0e77a5eb1b9addd6787ba2d53261ea79f7759d3e93c3802ae83789d183e0069d
writeSetBegin
public void writeSetBegin(TSet set) throws TException
{    size = set.size;    startListWrapper();}
28c6e88e95a0808e952fbe67452962d4a597da72aa56238d97a567ddd1869239
writeSetEnd
public void writeSetEnd() throws TException
{    endListWrapper();}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    recordConsumer.startGroup();    recordConsumer.startField(key.getName(), key.getIndex());}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    recordConsumer.endField(key.getName(), key.getIndex());    currentProtocol = valueProtocol;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    recordConsumer.startField(value.getName(), value.getIndex());}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    consumed++;    recordConsumer.endField(value.getName(), value.getIndex());    recordConsumer.endGroup();    if (consumed == countToConsume) {        currentProtocol = MapWriteProtocol.this;        consumed = 0;    } else {        currentProtocol = keyProtocol;    }}
dcde37228f607b0b7e2604909079cdb3ac5768c8a4652c8047c51f97e2b72923
writeMapBegin
public void writeMapBegin(TMap map) throws TException
{    start();    recordConsumer.startGroup();    countToConsume = map.size;    if (countToConsume > 0) {        recordConsumer.startField(mapContent.getType().getName(), 0);        currentProtocol = keyProtocol;    }}
67f363c30f9232259c0c23dfa790d0a3f2e19a688b3722f5022b7740792babc3
writeMapEnd
public void writeMapEnd() throws TException
{    if (countToConsume > 0) {        recordConsumer.endField(mapContent.getType().getName(), 0);    }    recordConsumer.endGroup();    end();}
8d51211e99f12413f17007de4e371cf8d247ef1e73702baa074d51179537a9af
writeBool
public void writeBool(boolean b) throws TException
{    start();    recordConsumer.addBoolean(b);    end();}
be49bceacc378be83521557b99caf10bf06185e2eef7a78a1152a3694a4d6b2c
writeByte
public void writeByte(byte b) throws TException
{    start();    recordConsumer.addInteger(b);    end();}
6011ebac32f1841cc3594f03ba466ef0a3224ba6b2dca594fe9e54e69b12dcd1
writeI16
public void writeI16(short i16) throws TException
{    start();    recordConsumer.addInteger(i16);    end();}
09c4dd32fada8b5897257a4f8bc3ac37dddaa946b64adc9e0d81fa15184ecf91
writeI32
public void writeI32(int i32) throws TException
{    start();    recordConsumer.addInteger(i32);    end();}
9debc22382676ead907181f78b9352e9216b0614ca4d72b5651b9c5dace5974c
writeI64
public void writeI64(long i64) throws TException
{    start();    recordConsumer.addLong(i64);    end();}
625514537dfb535a0c170483331a32cc17a9536725dc2c4a8435b99c8c74e37a
writeDouble
public void writeDouble(double dub) throws TException
{    start();    recordConsumer.addDouble(dub);    end();}
577a22fa000fa7c1262c7a2e6b6c5d943d78e9c16e7e2f302e1379873c98897c
writeString
public void writeString(String str) throws TException
{    start();    writeStringToRecordConsumer(str);    end();}
9353686a74c9a338b24da7a843112e9ea342b14072ee2373f57ca35d7a8fb3fb
writeBinary
public void writeBinary(ByteBuffer buf) throws TException
{    start();    writeBinaryToRecordConsumer(buf);    end();}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    currentProtocol = StructWriteProtocol.this;}
20dc992c59eb5c65b7b90e25660bfc1481e15b20d117fe08ace652816e9c445b
writeStructBegin
public void writeStructBegin(TStruct struct) throws TException
{    start();    recordConsumer.startGroup();}
5010522f36971f2f24e6875669da519eedd379b8640ddb4a0af7cde61d7658f1
writeStructEnd
public void writeStructEnd() throws TException
{    recordConsumer.endGroup();    end();}
64d9ca4acffc3a8699f25fc5f94ade23da81b62bc424b46c1653856d57271ac9
writeFieldBegin
public void writeFieldBegin(TField field) throws TException
{    if (field.type == TType.STOP) {        return;    }    try {        currentType = thriftFieldIdToParquetField[field.id];        if (currentType == null) {            throw new ParquetEncodingException("field " + field.id + " was not found in " + thriftType + " and " + schema.getType());        }        final int index = currentType.getIndex();        recordConsumer.startField(currentType.getName(), index);        currentProtocol = children[index];    } catch (ArrayIndexOutOfBoundsException e) {        throw new ParquetEncodingException("field " + field.id + " was not found in " + thriftType + " and " + schema.getType());    }}
63fb9d3a4e5cbe6779cc99e3ffabfbdd3e3e28004f4746a682d3adbc8c35c688
writeFieldStop
public void writeFieldStop() throws TException
{}
b0a830717a657c899097e3e736493aef0faf6dfb430e313b020bb0bc8b19e69d
writeFieldEnd
public void writeFieldEnd() throws TException
{    recordConsumer.endField(currentType.getName(), currentType.getIndex());}
20dc992c59eb5c65b7b90e25660bfc1481e15b20d117fe08ace652816e9c445b
writeStructBegin
public void writeStructBegin(TStruct struct) throws TException
{    recordConsumer.startMessage();}
5010522f36971f2f24e6875669da519eedd379b8640ddb4a0af7cde61d7658f1
writeStructEnd
public void writeStructEnd() throws TException
{    recordConsumer.endMessage();}
d0992f1393b22f76f4899eec6d0ecd68ffad332ba47e9fb61f53a71b2744320f
toString
private String toString(TStruct struct)
{    return "<TStruct name:" + struct.name + ">";}
aeafbfa078d97e7d1d27fb47953f0775c5eea8ee007b09247a2d45898782f6e4
toString
private String toString(TList list)
{    return "<TList elemType:" + list.elemType + " size:" + list.size + ">";}
be6cdb0b3f47d0093df6678fcb008319ab344585a27656c674e0c38173b0628b
toString
private String toString(TMap map)
{    return "<TMap keyType:" + map.keyType + " valueType:" + map.valueType + " size:" + map.size + ">";}
6e40e5cf513a809dc50dcdd328059e0c91563b4e305762fe100219b231c6dc54
writeMessageBegin
public void writeMessageBegin(TMessage message) throws TException
{    LOG.debug("writeMessageBegin({})", message);    currentProtocol.writeMessageBegin(message);}
ade94bcb84429ca34b3ac1ffccc0acc87510cd06267edc8ad0ed40cef78b39be
writeMessageEnd
public void writeMessageEnd() throws TException
{    LOG.debug("writeMessageEnd()");    currentProtocol.writeMessageEnd();}
20dc992c59eb5c65b7b90e25660bfc1481e15b20d117fe08ace652816e9c445b
writeStructBegin
public void writeStructBegin(TStruct struct) throws TException
{    if (LOG.isDebugEnabled())        LOG.debug("writeStructBegin(" + toString(struct) + ")");    currentProtocol.writeStructBegin(struct);}
5010522f36971f2f24e6875669da519eedd379b8640ddb4a0af7cde61d7658f1
writeStructEnd
public void writeStructEnd() throws TException
{    LOG.debug("writeStructEnd()");    currentProtocol.writeStructEnd();}
64d9ca4acffc3a8699f25fc5f94ade23da81b62bc424b46c1653856d57271ac9
writeFieldBegin
public void writeFieldBegin(TField field) throws TException
{    LOG.debug("writeFieldBegin({})", field);    currentProtocol.writeFieldBegin(field);}
b0a830717a657c899097e3e736493aef0faf6dfb430e313b020bb0bc8b19e69d
writeFieldEnd
public void writeFieldEnd() throws TException
{    LOG.debug("writeFieldEnd()");    currentProtocol.writeFieldEnd();}
63fb9d3a4e5cbe6779cc99e3ffabfbdd3e3e28004f4746a682d3adbc8c35c688
writeFieldStop
public void writeFieldStop() throws TException
{    LOG.debug("writeFieldStop()");    currentProtocol.writeFieldStop();}
dcde37228f607b0b7e2604909079cdb3ac5768c8a4652c8047c51f97e2b72923
writeMapBegin
public void writeMapBegin(TMap map) throws TException
{    if (LOG.isDebugEnabled())        LOG.debug("writeMapBegin(" + toString(map) + ")");    currentProtocol.writeMapBegin(map);}
67f363c30f9232259c0c23dfa790d0a3f2e19a688b3722f5022b7740792babc3
writeMapEnd
public void writeMapEnd() throws TException
{    LOG.debug("writeMapEnd()");    currentProtocol.writeMapEnd();}
d9a67025b8f7c6c7661007c24445a49d4c582691acc753ead1143988200f3564
writeListBegin
public void writeListBegin(TList list) throws TException
{    if (LOG.isDebugEnabled())        LOG.debug("writeListBegin(" + toString(list) + ")");    currentProtocol.writeListBegin(list);}
da56dbd294fd9e9d40f80049f21ed2188c3c2af2f491f4891f69bcbe9db1a4f5
writeListEnd
public void writeListEnd() throws TException
{    LOG.debug("writeListEnd()");    currentProtocol.writeListEnd();}
0e77a5eb1b9addd6787ba2d53261ea79f7759d3e93c3802ae83789d183e0069d
writeSetBegin
public void writeSetBegin(TSet set) throws TException
{    LOG.debug("writeSetBegin({})", set);    currentProtocol.writeSetBegin(set);}
28c6e88e95a0808e952fbe67452962d4a597da72aa56238d97a567ddd1869239
writeSetEnd
public void writeSetEnd() throws TException
{    LOG.debug("writeSetEnd()");    currentProtocol.writeSetEnd();}
8d51211e99f12413f17007de4e371cf8d247ef1e73702baa074d51179537a9af
writeBool
public void writeBool(boolean b) throws TException
{    LOG.debug("writeBool({})", b);    currentProtocol.writeBool(b);}
be49bceacc378be83521557b99caf10bf06185e2eef7a78a1152a3694a4d6b2c
writeByte
public void writeByte(byte b) throws TException
{    LOG.debug("writeByte({})", b);    currentProtocol.writeByte(b);}
6011ebac32f1841cc3594f03ba466ef0a3224ba6b2dca594fe9e54e69b12dcd1
writeI16
public void writeI16(short i16) throws TException
{    LOG.debug("writeI16({})", i16);    currentProtocol.writeI16(i16);}
09c4dd32fada8b5897257a4f8bc3ac37dddaa946b64adc9e0d81fa15184ecf91
writeI32
public void writeI32(int i32) throws TException
{    LOG.debug("writeI32({})", i32);    currentProtocol.writeI32(i32);}
9debc22382676ead907181f78b9352e9216b0614ca4d72b5651b9c5dace5974c
writeI64
public void writeI64(long i64) throws TException
{    LOG.debug("writeI64({})", i64);    currentProtocol.writeI64(i64);}
625514537dfb535a0c170483331a32cc17a9536725dc2c4a8435b99c8c74e37a
writeDouble
public void writeDouble(double dub) throws TException
{    LOG.debug("writeDouble({})", dub);    currentProtocol.writeDouble(dub);}
577a22fa000fa7c1262c7a2e6b6c5d943d78e9c16e7e2f302e1379873c98897c
writeString
public void writeString(String str) throws TException
{    LOG.debug("writeString({})", str);    currentProtocol.writeString(str);}
9353686a74c9a338b24da7a843112e9ea342b14072ee2373f57ca35d7a8fb3fb
writeBinary
public void writeBinary(ByteBuffer buf) throws TException
{    LOG.debug("writeBinary({})", buf);    currentProtocol.writeBinary(buf);}
fdd2526e0897c1902300d21e65cdf87cf68c06ce156e45f13bffbc1fd7b51175
writeBinaryToRecordConsumer
private void writeBinaryToRecordConsumer(ByteBuffer buf)
{    recordConsumer.addBinary(Binary.fromReusedByteArray(buf.array(), buf.position(), buf.limit() - buf.position()));}
b4df2ca1b7de65b60b74c4b2dbd2975812fee50998bc76a47864e982d57e2894
writeStringToRecordConsumer
private void writeStringToRecordConsumer(String str)
{    recordConsumer.addBinary(Binary.fromString(str));}
4a25a4bbf86b34d5470465a19cfac81689c696b913ed573ae826d0d4027c70b3
getProtocol
private TProtocol getProtocol(ThriftField field, ColumnIO columnIO, Events returnClause)
{    TProtocol p;    final ThriftType type = field.getType();    switch(type.getType()) {        case STOP:        case VOID:        default:            throw new UnsupportedOperationException("can't convert type of " + field);        case BOOL:        case BYTE:        case DOUBLE:        case I16:        case I32:        case I64:        case STRING:            p = new PrimitiveWriteProtocol((PrimitiveColumnIO) columnIO, returnClause);            break;        case STRUCT:            p = new StructWriteProtocol((GroupColumnIO) columnIO, (StructType) type, returnClause);            break;        case MAP:            p = new MapWriteProtocol((GroupColumnIO) columnIO, (MapType) type, returnClause);            break;        case SET:            p = new ListWriteProtocol((GroupColumnIO) columnIO, ((SetType) type).getValues(), returnClause);            break;        case LIST:            p = new ListWriteProtocol((GroupColumnIO) columnIO, ((ListType) type).getValues(), returnClause);            break;        case ENUM:            p = new EnumWriteProtocol((PrimitiveColumnIO) columnIO, (EnumType) type, returnClause);            break;    }    return p;}
7a3859e63ac72e65278bd44434c3244562c40b5f4f5b94ae3a437fff6a931204
getOutputFormat
public OutputFormat<Void, Tuple> getOutputFormat() throws IOException
{    return new ParquetOutputFormat<Tuple>(new TupleToThriftWriteSupport(className));}
9d1865e4f31137471036b0b8f88689037236deebc8f0fa3c17614ce220ef4172
prepareToWrite
public void prepareToWrite(RecordWriter recordWriter) throws IOException
{    this.recordWriter = recordWriter;}
4dd235f692106bcee0d0f464ac37c8eb963acd4c93c7bc3bb8d00eeaee0b1d91
putNext
public void putNext(Tuple tuple) throws IOException
{    try {        this.recordWriter.write(null, tuple);    } catch (InterruptedException e) {        throw new ParquetEncodingException("Interrupted while writing", e);    }}
22fbb46c1ec3a62ec68e4fbe084b178c4fb1498cae03fa71b3dacf1a16d4e15a
setStoreLocation
public void setStoreLocation(String location, Job job) throws IOException
{    FileOutputFormat.setOutputPath(job, new Path(location));}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "thrift";}
89835da140a91d5cb5181a85b8db073a92d794e99966f7422502dbb7d5467b7c
init
public WriteContext init(Configuration configuration)
{    try {        Class<?> clazz = configuration.getClassByName(className).asSubclass(TBase.class);        thriftWriteSupport = new ThriftWriteSupport(clazz);        pigToThrift = new PigToThrift(clazz);        return thriftWriteSupport.init(configuration);    } catch (ClassNotFoundException e) {        throw new BadConfigurationException("The thrift class name was not found: " + className, e);    } catch (ClassCastException e) {        throw new BadConfigurationException("The thrift class name should extend TBase: " + className, e);    }}
da9aef78cf181856102b820ffa7d5248e8581747b3f0670a7b049c4649b962ef
prepareForWrite
public void prepareForWrite(RecordConsumer recordConsumer)
{    thriftWriteSupport.prepareForWrite(recordConsumer);}
1a245295cca086796377661dbb49e97c83e96dde3c08303ff16317854ecb70d2
write
public void write(Tuple t)
{    thriftWriteSupport.write(pigToThrift.getThriftObject(t));}
4d9820e53657ed786836f1c4e0eeb56365960a0f48809e39f143472d3c7c4776
visit
public Void visit(ThriftType.MapType mapType, Void v)
{    dummyEvents.add(new ParquetProtocol("readMapBegin()") {        @Override        public TMap readMapBegin() throws TException {            return new TMap();        }    });    dummyEvents.add(new ParquetProtocol("readMapEnd()") {        @Override        public void readMapEnd() throws TException {        }    });    return null;}
ccef29d31156242180b2595fbe4f2e8f11ecb097f7eb5013f5cfbcbadb7d3f2b
readMapBegin
public TMap readMapBegin() throws TException
{    return new TMap();}
2a5867240c482ae3a61d58bbbb1c1b7e42b363a1f64c6cd3524c0470d749c9a0
readMapEnd
public void readMapEnd() throws TException
{}
1260e41156fedacd566f69dc1461217db5bddd27230137457b4e6f673edf4a6c
visit
public Void visit(final ThriftType.SetType setType, Void v)
{    dummyEvents.add(new ParquetProtocol("readSetBegin()") {        @Override        public TSet readSetBegin() throws TException {            return new TSet();        }    });    dummyEvents.add(new ParquetProtocol("readSetEnd()") {        @Override        public void readSetEnd() throws TException {        }    });    return null;}
5b0265bf5be1a6ae8196064eb3a9728c746c5a31b8da6f6e24655b5b965b45dc
readSetBegin
public TSet readSetBegin() throws TException
{    return new TSet();}
6d0d71f10658b2a33eefe039338687f1c171606506f807722885f53093eb40ca
readSetEnd
public void readSetEnd() throws TException
{}
b30be6de1befb982e1f0464802727dc44de7ee72d4e7499d8b1b1edf122af0db
visit
public Void visit(final ThriftType.ListType listType, Void v)
{    dummyEvents.add(new ParquetProtocol("readListBegin()") {        @Override        public TList readListBegin() throws TException {            return new TList();        }    });    dummyEvents.add(new ParquetProtocol("readListEnd()") {        @Override        public void readListEnd() throws TException {        }    });    return null;}
f11327b40a2aa7489a812533ff4e918785c8373aaf59343add9f4bbcdcfd11f0
readListBegin
public TList readListBegin() throws TException
{    return new TList();}
751f723cedbf7b8de4f12a4df7d3afebe4ff7079c529f2086892ae666fc1bf34
readListEnd
public void readListEnd() throws TException
{}
4c44f95b0816067655ba23aad27630bce34f8e08fb41086d4357da02268df5fd
visit
public Void visit(ThriftType.StructType structType, Void v)
{    dummyEvents.add(new StructBeginProtocol("struct"));    List<ThriftField> children = structType.getChildren();    for (ThriftField child : children) {        dummyEvents.add(new ReadFieldBeginProtocol(child));                child.getType().accept(this, null);        dummyEvents.add(DefaultProtocolEventsGenerator.READ_FIELD_END);    }    dummyEvents.add(DefaultProtocolEventsGenerator.READ_FIELD_STOP);    dummyEvents.add(DefaultProtocolEventsGenerator.READ_STRUCT_END);    return null;}
65466875246ed19de23aff486b128f3f50d67870f3693f7c67c7a843a8849040
visit
public Void visit(ThriftType.EnumType enumType, Void v)
{    dummyEvents.add(new ParquetProtocol("readI32() enum") {        @Override        public int readI32() throws TException {            return 0;        }    });    return null;}
9cdce61957c527c2da4806031bffb0b62837efdf684b720ac095ddc794ad3be4
readI32
public int readI32() throws TException
{    return 0;}
0ba958def74fa844f11d9263b8be6f56331178c00657bbddbaf29bfa2e245304
visit
public Void visit(ThriftType.BoolType boolType, Void v)
{    dummyEvents.add(new ParquetProtocol("readBool()") {        @Override        public boolean readBool() throws TException {            return false;        }    });    return null;}
e3ae4a5d2127da24daf3630c1e497e9da2943770af69da55e3286e71d1fc6e10
readBool
public boolean readBool() throws TException
{    return false;}
4e2f86afcaa01ced7e2c3e28ba2773e576950cf0c4e622e6716b9c4f3bd238f3
visit
public Void visit(ThriftType.ByteType byteType, Void v)
{    dummyEvents.add(new ParquetProtocol("readByte() int") {        @Override        public byte readByte() throws TException {            return (byte) 0;        }    });    return null;}
d0afc620362c8c05d0f9d6409f34df154f23b95cbd7164d4d31708bf01bfc254
readByte
public byte readByte() throws TException
{    return (byte) 0;}
4b4bddd35f86273dbdd3041c921e68ead10ccf6693ebaf9f399d4d6015983d5e
visit
public Void visit(ThriftType.DoubleType doubleType, Void v)
{    dummyEvents.add(new ParquetProtocol("readDouble()") {        @Override        public double readDouble() throws TException {            return 0.0;        }    });    return null;}
13e5eb98c42fdbefd38e11fed60126ad859699a84615bbae60805a0c45f03126
readDouble
public double readDouble() throws TException
{    return 0.0;}
dff1eeebafcc5f99aa9cb09c6ef3d2772f3517fd19d074d52bca75aef76747d5
visit
public Void visit(ThriftType.I16Type i16Type, Void v)
{    dummyEvents.add(new ParquetProtocol("readI16()") {        @Override        public short readI16() throws TException {            return (short) 0;        }    });    return null;}
ba19a1b6b27a9d1241b1532c49518058e1c6aae1b2fce864cac33b0323b4e9ed
readI16
public short readI16() throws TException
{    return (short) 0;}
f6f66f58389b3b3440de75ea9ccf886aaa1f671f9c2d73cbfeb4deb6d4dd8b41
visit
public Void visit(ThriftType.I32Type i32Type, Void v)
{    dummyEvents.add(new ParquetProtocol("readI32()") {        @Override        public int readI32() throws TException {            return 0;        }    });    return null;}
9cdce61957c527c2da4806031bffb0b62837efdf684b720ac095ddc794ad3be4
readI32
public int readI32() throws TException
{    return 0;}
cee43e59d806790ad086189cd4c9c0995e0b90b70d171e4d9a5ac3ee7c5d8eaa
visit
public Void visit(ThriftType.I64Type i64Type, Void v)
{    dummyEvents.add(new ParquetProtocol("readI64()") {        @Override        public long readI64() throws TException {            return 0;        }    });    return null;}
effebad19b862ab3187f7a56079de27779133ee1979be7276c1ea72d6bec8a0b
readI64
public long readI64() throws TException
{    return 0;}
641d80ee1d17093979bc7c8d8ccf0f656de714b3f2e30f9ab7dbb0b3bdb30f54
visit
public Void visit(ThriftType.StringType stringType, Void v)
{    dummyEvents.add(new StringProtocol(""));    return null;}
8ea095495adc388fcd02e5be78068398df8b5ffe2b5c6b54ca238652314f12ff
getEvents
public List<ParquetProtocol> getEvents()
{    return dummyEvents;}
4581ce92c1c14390774b3334899b0792f18429a4fa86e1eab50f00a0c8e87c3b
readStructBegin
public TStruct readStructBegin() throws TException
{    return new TStruct(structName);}
00b5d4f7589ed91042175c05b813cc60c9649f639b471d6be729691cd5b52bd7
readString
public String readString() throws TException
{    return str;}
a4bf98b9a9e380c02f650aea16d41e5140ec75fdfa57c19ba07e0787d5cb43b9
readBinary
public ByteBuffer readBinary() throws TException
{    return ByteBuffer.wrap("str".getBytes());}
6771498943d82d6987ae6cbbe2274166a2ff9ce14f84ac60f6a13d9df78f9b26
readFieldBegin
public TField readFieldBegin() throws TException
{    return stop;}
313291383bc799a61a64fd536cdb66162569f48a255366c7cc2e937412433b56
readStructEnd
public void readStructEnd() throws TException
{}
0ba8e2da944ada1e2b2f96d56fd37a118dc4e3ae0abe06e5d3269bb901ff0383
readFieldEnd
public void readFieldEnd() throws TException
{}
04a8af8662d2f375a8477524a9dc02e417545c0854295b404f72322ffd0e32a0
createProtocolEventsForField
public List<TProtocol> createProtocolEventsForField(ThriftField missingField)
{    TProtocol fieldBegin = new ReadFieldBeginProtocol(missingField);    createdEvents.add(fieldBegin);    DefaultEventsVisitor dummyCreatorvisitor = new DefaultEventsVisitor();    missingField.getType().accept(dummyCreatorvisitor, null);    createdEvents.addAll(dummyCreatorvisitor.getEvents());    createdEvents.add(READ_FIELD_END);    return createdEvents;}
2b62af3e3a42ded790310c0d4a9a4622d2a98b1f2c2545a122d6aaa5e12f67f9
amendMissingRequiredFields
public List<TProtocol> amendMissingRequiredFields(StructType recordThriftType) throws TException
{    Iterator<TProtocol> protocolIter = rootEvents.iterator();    checkStruct(protocolIter, recordThriftType);    return fixedEvents;}
4a54761c6fc42f7027c686ebf8dcf7cda4740ee2799a728897cfe45f21bf25c9
acceptProtocol
private TProtocol acceptProtocol(TProtocol p)
{    this.fixedEvents.add(p);    return p;}
92658c27d9cf7ac0f8e2633ad22a8ca10727a1d2363c20145a0ecbd88f2409a2
checkStruct
private void checkStruct(Iterator<TProtocol> eventIter, ThriftType.StructType thriftStructType) throws TException
{    TStruct tStruct = acceptProtocol(eventIter.next()).readStructBegin();    List<ThriftField> childrenFields = thriftStructType.getChildren();    Set<Short> includedFieldsIds = new HashSet<Short>();    while (true) {        TProtocol next = eventIter.next();        TField field = next.readFieldBegin();        if (isStopField(field))            break;        acceptProtocol(next);        includedFieldsIds.add(field.id);        ThriftField fieldDefinition = thriftStructType.getChildById(field.id);        checkField(field.type, eventIter, fieldDefinition);        acceptProtocol(eventIter.next()).readFieldEnd();    }    for (ThriftField requiredField : childrenFields) {        if (!isRequired(requiredField)) {            continue;        }        if (!includedFieldsIds.contains(requiredField.getFieldId())) {            fixedEvents.addAll(new DefaultProtocolEventsGenerator().createProtocolEventsForField(requiredField));        }    }    acceptProtocol(DefaultProtocolEventsGenerator.READ_FIELD_STOP);    acceptProtocol(eventIter.next()).readStructEnd();}
4dded8ed251dbff6ce97ce944fab34ad30f1cb18b38cf217195a9ea07b0ba43a
checkField
private void checkField(byte type, Iterator<TProtocol> eventIter, ThriftField fieldDefinition) throws TException
{    switch(type) {        case TType.STRUCT:            checkStruct(eventIter, (ThriftType.StructType) fieldDefinition.getType());            return;        case TType.LIST:            checkList(eventIter, fieldDefinition);            return;        case TType.MAP:            checkMap(eventIter, fieldDefinition);            return;        case TType.SET:            checkSet(eventIter, fieldDefinition);            return;    }    checkPrimitiveField(type, eventIter);}
312d55359e8d9f18d0d93c89e3266105da3795bdf03b38bb5b6b6f3565d74fc0
checkSet
private void checkSet(Iterator<TProtocol> eventIter, ThriftField setFieldDefinition) throws TException
{    TSet thriftSet = acceptProtocol(eventIter.next()).readSetBegin();    ThriftField elementFieldDefinition = ((ThriftType.SetType) setFieldDefinition.getType()).getValues();    int setSize = thriftSet.size;    for (int i = 0; i < setSize; i++) {        checkField(thriftSet.elemType, eventIter, elementFieldDefinition);    }    acceptProtocol(eventIter.next()).readSetEnd();}
99b6a2d2d4fed91909431b5812d370b8d83f86193b3a42b0548bee1b8c365249
checkMap
private void checkMap(Iterator<TProtocol> eventIter, ThriftField mapFieldForWriting) throws TException
{    TMap thriftMap = acceptProtocol(eventIter.next()).readMapBegin();    ThriftField keyFieldForWriting = ((ThriftType.MapType) mapFieldForWriting.getType()).getKey();    ThriftField valueFieldForWriting = ((ThriftType.MapType) mapFieldForWriting.getType()).getValue();    int mapSize = thriftMap.size;    for (int i = 0; i < mapSize; i++) {                checkField(thriftMap.keyType, eventIter, keyFieldForWriting);                checkField(thriftMap.valueType, eventIter, valueFieldForWriting);    }    acceptProtocol(eventIter.next()).readMapEnd();}
234d9b35b05660ac0a6e4b406e8cd8a70b7dc4bcb2020342bc46d09921909985
checkList
private void checkList(Iterator<TProtocol> eventIter, ThriftField listFieldUsedForWriting) throws TException
{    ThriftField valueFieldForWriting = ((ThriftType.ListType) listFieldUsedForWriting.getType()).getValues();    TList thriftList = acceptProtocol(eventIter.next()).readListBegin();    int listSize = thriftList.size;    for (int i = 0; i < listSize; i++) {        checkField(thriftList.elemType, eventIter, valueFieldForWriting);    }    acceptProtocol(eventIter.next()).readListEnd();}
c2b09459ce49332237e9e52797992081ac258ea244bfd5add7742e7299027918
checkPrimitiveField
private void checkPrimitiveField(byte type, Iterator<TProtocol> eventIter) throws TException
{    acceptProtocol(eventIter.next());}
2102bda8063e68986b9d06749ab79468ba9f8f6f8055770e484e70692aa407ab
isStopField
private boolean isStopField(TField field)
{    return field.type == TType.STOP;}
065a478f496a842630685f8e6bd5d4f65f922f89f63d942c979301c8dfd48a39
isRequired
private boolean isRequired(ThriftField requiredField)
{    return requiredField.getRequirement() == ThriftField.Requirement.REQUIRED;}
6771498943d82d6987ae6cbbe2274166a2ff9ce14f84ac60f6a13d9df78f9b26
readFieldBegin
public TField readFieldBegin() throws TException
{    return new TField(field.getName(), thriftType, field.getFieldId());}
fdad0512b698c9e294276c51d323c6081de5de4b13621ff2366da55dc4d6d59e
matches
public boolean matches(String path)
{    if (this.pattern.matches(path)) {        this.hasMatchingPath = true;        return true;    } else {        return false;    }}
667b47c71439086e0a74774e9c35ca5cf2078072eb62cff550d1b898003b19d1
keep
public boolean keep(FieldsPath path)
{    if (filterPatterns.size() == 0)        return true;    for (PathGlobPatternStatus pattern : filterPatterns) {        if (pattern.matches(path.toDelimitedString("/")))            return true;    }    return false;}
8e4f2a3c268396796f03960e703603a701a7cc875d51fd4fccbed9a65cbe7526
assertNoUnmatchedPatterns
public void assertNoUnmatchedPatterns() throws ThriftProjectionException
{    List<PathGlobPattern> unmatched = new LinkedList<PathGlobPattern>();    for (PathGlobPatternStatus p : filterPatterns) {        if (!p.hasMatchingPath) {            unmatched.add(p.pattern);        }    }    if (!unmatched.isEmpty()) {        StringBuilder message = new StringBuilder("The following projection patterns did not match any columns in this schema:\n");        for (PathGlobPattern p : unmatched) {            message.append(p);            message.append('\n');        }        throw new ThriftProjectionException(message.toString());    }}
252002f55348ec3b03b4be837ea9a6d95c3ad05590349491cb5ea9e35ec51a33
compile
public static Pattern compile(String globPattern)
{    return new GlobPattern(globPattern).compiled();}
0be9ce57719242f00aaa93f88972f7b0b1d728e949e7cea8b6749b35b044c715
error
private static void error(String message, String pattern, int pos)
{    throw new PatternSyntaxException(message, pattern, pos);}
e34d9816bbbd90c9601eb9611e820fe58299b4f4eee2ad719a5ed815ac4bc97a
compiled
public Pattern compiled()
{    return compiled;}
4d2bc7626eeb9c679276d488ddb777b5d9c8a734167e13389953d1236238636a
matches
public boolean matches(CharSequence s)
{    return compiled.matcher(s).matches();}
d941bf5b4af59fe99a79110e066d794adad23026de8c514c7314b3351b99665a
set
public void set(String glob)
{    StringBuilder regex = new StringBuilder();    int setOpen = 0;    int curlyOpen = 0;    int len = glob.length();    hasWildcard = false;    for (int i = 0; i < len; i++) {        char c = glob.charAt(i);        switch(c) {            case BACKSLASH:                if (++i >= len) {                    error("Missing escaped character", glob, i);                }                regex.append(c).append(glob.charAt(i));                continue;            case '.':            case '$':            case '(':            case ')':            case '|':            case '+':                                regex.append(BACKSLASH);                break;            case '*':                if (i + 1 < len && glob.charAt(i + 1) == '*') {                    regex.append('.');                    i++;                    break;                }                regex.append("[^" + PATH_SEPARATOR + "]");                hasWildcard = true;                break;            case '?':                regex.append('.');                hasWildcard = true;                continue;            case             '{':                                regex.append("(?:");                curlyOpen++;                hasWildcard = true;                continue;            case ',':                regex.append(curlyOpen > 0 ? '|' : c);                continue;            case '}':                if (curlyOpen > 0) {                                        curlyOpen--;                    regex.append(")");                    continue;                }                break;            case '[':                if (setOpen > 0) {                    error("Unclosed character class", glob, i);                }                setOpen++;                hasWildcard = true;                break;            case             '^':                if (setOpen == 0) {                    regex.append(BACKSLASH);                }                break;            case             '!':                regex.append(setOpen > 0 && '[' == glob.charAt(i - 1) ? '^' : '!');                continue;            case ']':                                                                setOpen = 0;                break;            default:        }        regex.append(c);    }    if (setOpen > 0) {        error("Unclosed character class", glob, len);    }    if (curlyOpen > 0) {        error("Unclosed group", glob, len);    }    compiled = Pattern.compile(regex.toString());}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return compiled.toString();}
bf2f6cde8d29625180b24f598e31845abe417bda0eff8bacaf2d990fc8e1d482
hasWildcard
public boolean hasWildcard()
{    return hasWildcard;}
667b47c71439086e0a74774e9c35ca5cf2078072eb62cff550d1b898003b19d1
keep
public boolean keep(FieldsPath path)
{    return true;}
8e4f2a3c268396796f03960e703603a701a7cc875d51fd4fccbed9a65cbe7526
assertNoUnmatchedPatterns
public void assertNoUnmatchedPatterns() throws ThriftProjectionException
{}
e31bb8960fdd98d62154b0172206e6bb4141fbb7775c765d5dca891f371bdb73
push
public FieldsPath push(ThriftField f)
{    ArrayList<ThriftField> copy = new ArrayList<ThriftField>(fields);    copy.add(f);    return new FieldsPath(copy);}
cc5ac401e75afd1424ec628bb2424b3d8dd542a2761fbfdee42cee76f32ccc5e
toDelimitedString
public String toDelimitedString(String delim)
{    StringBuilder delimited = new StringBuilder();    for (int i = 0; i < fields.size(); i++) {        ThriftField currentField = fields.get(i);        if (i > 0) {            ThriftField previousField = fields.get(i - 1);            if (FieldsPath.isKeyFieldOfMap(currentField, previousField)) {                delimited.append("key");                delimited.append(delim);                continue;            } else if (FieldsPath.isValueFieldOfMap(currentField, previousField)) {                delimited.append("value");                delimited.append(delim);                continue;            }        }        delimited.append(currentField.getName()).append(delim);    }    if (delimited.length() == 0) {        return "";    } else {        return delimited.substring(0, delimited.length() - 1);    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return toDelimitedString(".");}
6bda2e9f758e3e894048eedff1fd8e513e20cc53296e209b0149b9019d476c7d
isValueFieldOfMap
private static boolean isValueFieldOfMap(ThriftField currentField, ThriftField previousField)
{    ThriftType previousType = previousField.getType();    return previousType instanceof ThriftType.MapType && ((ThriftType.MapType) previousType).getValue() == currentField;}
c57d0918bfba13724283e4f6c9498e172f46c5f883666a517c717a297365ad7c
isKeyFieldOfMap
private static boolean isKeyFieldOfMap(ThriftField currentField, ThriftField previousField)
{    ThriftType previousType = previousField.getType();    return previousType instanceof ThriftType.MapType && ((ThriftType.MapType) previousType).getKey() == currentField;}
d1da507d19cec372c5e07d4d09f5b90d2461f0944647e2499b7d6b8681e476e5
parseSemicolonDelimitedString
 static List<String> parseSemicolonDelimitedString(String columnsToKeepGlobs)
{    String[] splits = columnsToKeepGlobs.split(GLOB_SEPARATOR);    List<String> globs = new ArrayList<String>();    for (String s : splits) {        if (!s.isEmpty()) {            globs.add(s);        }    }    if (globs.isEmpty()) {        throw new ThriftProjectionException(String.format("Semicolon delimited string '%s' contains 0 glob strings", columnsToKeepGlobs));    }    return globs;}
892e68f96a174733ff2bfafc4261b48b3281c3e986622b0cd100c3553fb75324
fromSemicolonDelimitedString
public static StrictFieldProjectionFilter fromSemicolonDelimitedString(String columnsToKeepGlobs)
{    return new StrictFieldProjectionFilter(parseSemicolonDelimitedString(columnsToKeepGlobs));}
667b47c71439086e0a74774e9c35ca5cf2078072eb62cff550d1b898003b19d1
keep
public boolean keep(FieldsPath path)
{    return keep(path.toDelimitedString("."));}
37e8e11a99c18e8076d6d59c86a6b1ec857cde5223ccabca6cfd7a9989406e61
keep
 boolean keep(String path)
{    WildcardPath match = null;        for (WildcardPathStatus wp : columnsToKeep) {        if (wp.matches(path)) {            if (match != null && !match.getParentGlobPath().equals(wp.getWildcardPath().getParentGlobPath())) {                String message = "Field path: '%s' matched more than one glob path pattern. First match: " + "'%s' (when expanded to '%s') second match:'%s' (when expanded to '%s')";                warn(String.format(message, path, match.getParentGlobPath(), match.getOriginalPattern(), wp.getWildcardPath().getParentGlobPath(), wp.getWildcardPath().getOriginalPattern()));            } else {                match = wp.getWildcardPath();            }        }    }    return match != null;}
9ab3e9ed659612023750d8aa5932ac2a589d097f665b0e562661bbc2b9288359
warn
protected void warn(String warning)
{    LOG.warn(warning);}
b0d52afb13c18d403729430e740d940f1f7872d8922384c2b627455e444f85a4
getUnmatchedPatterns
private List<WildcardPath> getUnmatchedPatterns()
{    List<WildcardPath> unmatched = new ArrayList<WildcardPath>();    for (WildcardPathStatus wp : columnsToKeep) {        if (!wp.hasMatched()) {            unmatched.add(wp.getWildcardPath());        }    }    return unmatched;}
8e4f2a3c268396796f03960e703603a701a7cc875d51fd4fccbed9a65cbe7526
assertNoUnmatchedPatterns
public void assertNoUnmatchedPatterns() throws ThriftProjectionException
{    List<WildcardPath> unmatched = getUnmatchedPatterns();    if (!unmatched.isEmpty()) {        StringBuilder message = new StringBuilder("The following projection patterns did not match any columns in this schema:\n");        for (WildcardPath wp : unmatched) {            message.append(String.format("Pattern: '%s' (when expanded to '%s')", wp.getParentGlobPath(), wp.getOriginalPattern()));            message.append('\n');        }        throw new ThriftProjectionException(message.toString());    }}
fdad0512b698c9e294276c51d323c6081de5de4b13621ff2366da55dc4d6d59e
matches
public boolean matches(String path)
{    boolean matches = wildcardPath.matches(path);    this.hasMatched = hasMatched || matches;    return matches;}
fc9484954587feaed35f94d4eb51f7a4bc7bdb5e5ed2e760c70397df9bbdd7d3
getWildcardPath
public WildcardPath getWildcardPath()
{    return wildcardPath;}
75559795983ff9f4cbb9514f41ea24f683f9960fedf50117678a6694d435254d
hasMatched
public boolean hasMatched()
{    return hasMatched;}
b5cdaa282cff05c4697eb9b587f10a05b99fda9422ceb86b999d7a8c4b9e56df
readOne
public void readOne(TProtocol in, TProtocol out) throws TException
{    readOneStruct(in, out);}
16663d170a82deceb8e30869868fce630c24cc2254b265bd4d6ad7436176ce50
readOneValue
 void readOneValue(TProtocol in, TProtocol out, byte type) throws TException
{    switch(type) {        case TType.LIST:            readOneList(in, out);            break;        case TType.MAP:            readOneMap(in, out);            break;        case TType.SET:            readOneSet(in, out);            break;        case TType.STRUCT:            readOneStruct(in, out);            break;        case TType.STOP:            break;        case TType.BOOL:            out.writeBool(in.readBool());            break;        case TType.BYTE:            out.writeByte(in.readByte());            break;        case TType.DOUBLE:            out.writeDouble(in.readDouble());            break;        case TType.I16:            out.writeI16(in.readI16());            break;                case TType.ENUM:        case TType.I32:            out.writeI32(in.readI32());            break;        case TType.I64:            out.writeI64(in.readI64());            break;        case TType.STRING:            out.writeBinary(in.readBinary());            break;        case TType.VOID:            break;        default:            throw new TException("Unknown type: " + type);    }}
cda9669cc8375f35a7efa8d9eab80014c47727d026f435f0a95d2bd04d8b85b5
readOneStruct
private void readOneStruct(TProtocol in, TProtocol out) throws TException
{    final TStruct struct = in.readStructBegin();    out.writeStructBegin(struct);    TField field;    while ((field = in.readFieldBegin()).type != TType.STOP) {        out.writeFieldBegin(field);        readOneValue(in, out, field.type);        in.readFieldEnd();        out.writeFieldEnd();    }    out.writeFieldStop();    in.readStructEnd();    out.writeStructEnd();}
dfa81ea7f336cae810bca5b8e2133efd206920c0c953d9ae7f81da414cc41f86
readOneMap
private void readOneMap(TProtocol in, TProtocol out) throws TException
{    final TMap map = in.readMapBegin();    out.writeMapBegin(map);    for (int i = 0; i < map.size; i++) {        readOneValue(in, out, map.keyType);        readOneValue(in, out, map.valueType);    }    in.readMapEnd();    out.writeMapEnd();}
26830a2f219126840370b4592ba7493959b6b6ab9efa101f0c2c8e09062ef9da
readOneSet
private void readOneSet(TProtocol in, TProtocol out) throws TException
{    final TSet set = in.readSetBegin();    out.writeSetBegin(set);    readCollectionElements(in, out, set.size, set.elemType);    in.readSetEnd();    out.writeSetEnd();}
e696f53fad4c99b5c654b9266641b1c0d29f3e05844de839fb1339e3bf61fa7a
readOneList
private void readOneList(TProtocol in, TProtocol out) throws TException
{    final TList list = in.readListBegin();    out.writeListBegin(list);    readCollectionElements(in, out, list.size, list.elemType);    in.readListEnd();    out.writeListEnd();}
0341973090335c97fa20522b631140bbe5c3237744d32a9be9ed067e915c96b0
readCollectionElements
private void readCollectionElements(TProtocol in, TProtocol out, final int size, final byte elemType) throws TException
{    for (int i = 0; i < size; i++) {        readOneValue(in, out, elemType);    }}
45d8e26f3ae3ee993a2d07d3b7b0a45c0733ce759eab4ee87ec46b40385b9e21
checkCompatibility
public CompatibilityReport checkCompatibility(ThriftType.StructType oldStruct, ThriftType.StructType newStruct)
{    CompatibleCheckerVisitor visitor = new CompatibleCheckerVisitor();    newStruct.accept(visitor, new State(oldStruct, new FieldsPath()));    return visitor.getReport();}
c05457f1d12bb772acfd5c2012f9f1bfdb8e20a014e424c91e4436cfe942c43a
isCompatible
public boolean isCompatible()
{    return isCompatible;}
0481b65fbc7302cc1b7bde36a22375b050e62343c2c01590507bfeab80543803
hasEmptyStruct
public boolean hasEmptyStruct()
{    return hasEmptyStruct;}
4e3c33d16b0b44f52cf533a2c210149926814f3a8dde2c533955a7e2b3af5e88
fail
public void fail(String message)
{    messages.add(message);    isCompatible = false;}
8d9c82a88d945d05a92d32900222021fd418d58c015c63b5721168d23fab5029
emptyStruct
public void emptyStruct(String message)
{    messages.add(message);    hasEmptyStruct = true;}
1b224fd783156845b0248b2e66d47ad6352462255c64eeb3ba955f3f21767022
getMessages
public List<String> getMessages()
{    return messages;}
d824684a26fabd48b9201061cd649539e50899bbda370a4087733ca00095a20d
prettyMessages
public String prettyMessages()
{    return Strings.join(messages, "\n");}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "CompatibilityReport{" + "isCompatible=" + isCompatible + ", hasEmptyStruct=" + hasEmptyStruct + ", messages=\n" + prettyMessages() + '}';}
d670db3a8c971c930fb486d914060c346bc435d442a93c83dfa208eeb7e859fd
getReport
public CompatibilityReport getReport()
{    return report;}
e7f79c6e93bd0f169122c9790187f2a27a9a17bf7e579cb039796cdb284fccf8
visit
public Void visit(ThriftType.MapType mapType, State state)
{    ThriftType.MapType oldMapType = ((ThriftType.MapType) state.oldType);    ThriftField oldKeyField = oldMapType.getKey();    ThriftField newKeyField = mapType.getKey();    ThriftField newValueField = mapType.getValue();    ThriftField oldValueField = oldMapType.getValue();    checkField(oldKeyField, newKeyField, state.path);    checkField(oldValueField, newValueField, state.path);    return null;}
0056130d072c871c581d69ccd0930e0bd71019814a5524d60c416f8f5e36dff2
visit
public Void visit(ThriftType.SetType setType, State state)
{    ThriftType.SetType oldSetType = ((ThriftType.SetType) state.oldType);    ThriftField oldField = oldSetType.getValues();    ThriftField newField = setType.getValues();    checkField(oldField, newField, state.path);    return null;}
598f2c10f4ae116e01780f6cad27728017ab0c253e78ad23f148df3c08d683d8
visit
public Void visit(ThriftType.ListType listType, State state)
{    ThriftType.ListType currentOldType = ((ThriftType.ListType) state.oldType);    ThriftField oldField = currentOldType.getValues();    ThriftField newField = listType.getValues();    checkField(oldField, newField, state.path);    return null;}
ea37f3b00c325ee5f194cc963e5b0d27efdfc2ba8689a85c4176d360c756e0f3
incompatible
public void incompatible(String message, FieldsPath path)
{    report.fail("at " + path + ":" + message);}
9d1991991fb57cdbcc9064a41c5901939dea55e3112b1ce408c6d50b77e148b3
checkField
private void checkField(ThriftField oldField, ThriftField newField, FieldsPath path)
{    if (!newField.getType().getType().equals(oldField.getType().getType())) {        incompatible("type is not compatible: " + oldField.getType().getType() + " vs " + newField.getType().getType(), path);        return;    }    if (!newField.getName().equals(oldField.getName())) {        incompatible("field names are different: " + oldField.getName() + " vs " + newField.getName(), path);        return;    }    if (firstIsMoreRestirctive(newField.getRequirement(), oldField.getRequirement())) {        incompatible("new field is more restrictive: " + newField.getName(), path);        return;    }    newField.getType().accept(this, new State(oldField.getType(), path.push(newField)));}
7aa053254c87e3b135b45297ba69ece615809b9da56194f4aeabb2abcc698691
firstIsMoreRestirctive
private boolean firstIsMoreRestirctive(ThriftField.Requirement firstReq, ThriftField.Requirement secReq)
{    if (firstReq == ThriftField.Requirement.REQUIRED && secReq != ThriftField.Requirement.REQUIRED) {        return true;    } else {        return false;    }}
67ae5b7c52beda50a4f2825764026448e6c20bb660b705638373a4558a9efada
visit
public Void visit(ThriftType.StructType newStruct, State state)
{    ThriftType.StructType oldStructType = ((ThriftType.StructType) state.oldType);    short oldMaxId = 0;    if (newStruct.getChildren().isEmpty()) {        report.emptyStruct("encountered an empty struct: " + state.path);    }    for (ThriftField oldField : oldStructType.getChildren()) {        short fieldId = oldField.getFieldId();        if (fieldId > oldMaxId) {            oldMaxId = fieldId;        }        ThriftField newField = newStruct.getChildById(fieldId);        if (newField == null) {            incompatible("can not find index in new Struct: " + fieldId + " in " + newStruct, state.path);            return null;        }        checkField(oldField, newField, state.path);    }        for (ThriftField newField : newStruct.getChildren()) {                if (newField.getRequirement() != ThriftField.Requirement.REQUIRED)                        continue;        short newFieldId = newField.getFieldId();        if (newFieldId > oldMaxId) {            incompatible("new required field " + newField.getName() + " is added", state.path);            return null;        }        if (newFieldId < oldMaxId && oldStructType.getChildById(newFieldId) == null) {            incompatible("new required field " + newField.getName() + " is added", state.path);            return null;        }    }    return null;}
c6cbe97c6e8e2dc431a2a24cdcfac558bf273fd1e132db068631188656579b67
visit
public Void visit(EnumType enumType, State state)
{    return null;}
afed630eafcb603e2a8a763c62a93df0cb0c0e80874f69f80abe00f59a518025
visit
public Void visit(BoolType boolType, State state)
{    return null;}
7ef25add15ce4770fdf288d098061c9eca9c8d3c9e31dff9df988e928b48d640
visit
public Void visit(ByteType byteType, State state)
{    return null;}
662083fbcde00faf2fa09557064455f6b8ed20634268b8ae546500a4b317bc8d
visit
public Void visit(DoubleType doubleType, State state)
{    return null;}
3d7c34cfcfba12f0da54353c08ee1d50c79d2726d63c6cc9b521ee818b1bd9bc
visit
public Void visit(I16Type i16Type, State state)
{    return null;}
0c3f9288a925fcbe3cc3f2f8780562ea37dc49827237e56e819a711b7664f6bb
visit
public Void visit(I32Type i32Type, State state)
{    return null;}
bfbf1e9dd91e7153de9ab35af0a84cb49048e2ffd6d1b062ffee6385c9d34f26
visit
public Void visit(I64Type i64Type, State state)
{    return null;}
06019f0409916d82d8cf8b08bdd77513c0b40fb55888da232240a6b15cc95d49
visit
public Void visit(StringType stringType, State state)
{    return null;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    LinkedList<String> arguments = new LinkedList<String>(Arrays.asList(args));    String operator = arguments.pollFirst();    if (operator.equals("generate-json")) {                generateJson(arguments);    }    if (operator.equals("compare-json")) {        compareJson(arguments);    }}
4fc7be0e85411c7b3a8770625b4457ab8eb28d66d69f4e6b04c5eded8a34898e
compareJson
private static void compareJson(LinkedList<String> arguments) throws IOException
{    String oldJsonPath = arguments.pollFirst();    String newJsonPath = arguments.pollFirst();    File oldJsonFile = new File(oldJsonPath);    checkExist(oldJsonFile);    File newJsonFile = new File(newJsonPath);    checkExist(newJsonFile);    ObjectMapper mapper = new ObjectMapper();    ThriftType.StructType oldStruct = mapper.readValue(oldJsonFile, ThriftType.StructType.class);    ThriftType.StructType newStruct = mapper.readValue(newJsonFile, ThriftType.StructType.class);    CompatibilityReport report = new CompatibilityChecker().checkCompatibility(oldStruct, newStruct);    if (!report.isCompatible) {        System.err.println("schema not compatible");        System.err.println(report.getMessages());        System.exit(1);    }    if (report.hasEmptyStruct()) {        System.err.println("schema contains empty struct");        System.err.println(report.getMessages());        System.exit(1);    }    System.out.println("[success] schema is compatible");}
a4241e306ebe1207924db7139fa6316eec564d9fa7249ef1e941b341655e734b
checkExist
private static void checkExist(File f)
{    if (!f.exists())        throw new RuntimeException("can not find file " + f);}
5f3fc15b7eaac4fceb36d57f2ef64bb25741d589f66c349c5a5371e292039f92
generateJson
private static void generateJson(LinkedList<String> arguments) throws ClassNotFoundException, IOException
{    String catName = arguments.pollFirst();    String className = arguments.pollFirst();    String storedPath = arguments.pollFirst();    File storeDir = new File(storedPath);    ThriftType.StructType structType = ThriftSchemaConverter.toStructType((Class<? extends TBase<?, ?>>) Class.forName(className));    ObjectMapper mapper = new ObjectMapper();    String fileName = catName + ".json";    mapper.writerWithDefaultPrettyPrinter().writeValue(new File(storeDir, fileName), structType);}
4df1f43791a874189a163b302d5a6b6bc2e086ee2303218d9ced1be234d82c4b
fromJSON
 static T fromJSON(String json, Class<T> clzz)
{    try {        return om.readValue(json, clzz);    } catch (IOException e) {        throw new RuntimeException(e);    }}
b3da69ff2548699fdc53d258207531e021ef3f3dc3f4fa80478a54ed38ab166b
toJSON
 static String toJSON(Object o)
{    try (final StringWriter sw = new StringWriter()) {        om.writeValue(sw, o);        return sw.toString();    } catch (IOException e) {        throw new RuntimeException(e);    }}
29044557b52af56120faf7d2df6501b70faa945673e801fe4b8614e4901d2825
getRequirement
public byte getRequirement()
{    return requirement;}
a561897b0548c449a7580bd26389d3026fb0faa4c1d0a4d68623553a8624205f
fromType
public static Requirement fromType(byte fieldRequirementType)
{    for (Requirement req : Requirement.values()) {        if (req.requirement == fieldRequirementType) {            return req;        }    }    throw new RuntimeException("Unknown requirement " + fieldRequirementType);}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
2bdce7d66abcc759e4217087e724cd35b84d3de431b0d9c9967a725c4c3d893e
getFieldId
public short getFieldId()
{    return fieldId;}
2e27080f8477fc51d856a4f1292fddd9e84a2aadebd688f44e29b58000a6dd23
getType
public ThriftType getType()
{    return type;}
f9a0bb49fc0728c6d110ee6d4a517369106f706a375e0ba64c1123225d5ab8b0
getRequirement
public Requirement getRequirement()
{    return requirement;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return JSON.toJSON(this);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (!(o instanceof ThriftField))        return false;    ThriftField that = (ThriftField) o;    if (fieldId != that.fieldId)        return false;    if (!name.equals(that.name))        return false;    if (requirement != that.requirement)        return false;    if (!type.equals(that.type))        return false;    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = name.hashCode();    result = 31 * result + (int) fieldId;    result = 31 * result + requirement.hashCode();    result = 31 * result + type.hashCode();    return result;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (!(o instanceof ThriftType))        return false;    ThriftType that = (ThriftType) o;    if (type != that.type)        return false;    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return type != null ? type.hashCode() : 0;}
20da88fda02637366906a60999ce84d82e2297c01fbe2ca4cc2724cc0737472d
fromJSON
public static ThriftType fromJSON(String json)
{    return JSON.fromJSON(json, ThriftType.class);}
94abe7c6bc71ae47746d713a70d792fba0d5c6565030c65f1292c4fe06398fc6
toJSON
public String toJSON()
{    return JSON.toJSON(this);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return toJSON();}
8685bd51f6e75b5a88d1496fd809353d2a26b60bef0d9de8ccc8abee5cc5ae68
visit
public final void visit(EnumType enumType)
{    throw new IllegalArgumentException("Expected complex type");}
c3a51df7afb4e331ee2c8f5e9cbb817f013786a22af50d03bf3fd849a2c01f78
visit
public final void visit(BoolType boolType)
{    throw new IllegalArgumentException("Expected complex type");}
008c6933e1ef6db503dc73f6ed7adc7ab0000bac22d87b0d8f437de0f4858578
visit
public final void visit(ByteType byteType)
{    throw new IllegalArgumentException("Expected complex type");}
1afa2b8991072ffc3c5a02db2b35e0e584a0896b8ee58f8b18d54623478e7177
visit
public final void visit(DoubleType doubleType)
{    throw new IllegalArgumentException("Expected complex type");}
d825cbef823a10dd1ccaa015fbd7250b7af399831115227fdc3274d2c693d395
visit
public final void visit(I16Type i16Type)
{    throw new IllegalArgumentException("Expected complex type");}
e72c93822cc82956175acd6f82124dcb30d2e00f0e1ada07f457f2ce3d0fdabb
visit
public final void visit(I32Type i32Type)
{    throw new IllegalArgumentException("Expected complex type");}
f3e5bd1a66c4fff6bac93b292b79abe7e92532e2251688572a0ff75002817d7e
visit
public final void visit(I64Type i64Type)
{    throw new IllegalArgumentException("Expected complex type");}
c9c4b3e541d26b9b626cdc93a6ed93a00acd6b794a0de2308fb50129be3a4d70
visit
public final void visit(StringType stringType)
{    throw new IllegalArgumentException("Expected complex type");}
9f898e81e2696b3ba97242528227bf95b4a0337d59ea2a6f96bc19ea22c52768
getChildren
public List<ThriftField> getChildren()
{    return children;}
25811e05196afb085043a32ab2d235ff541213bd4a5d4b1b7905aa8e53c68d9a
getChildById
public ThriftField getChildById(short id)
{    if (id >= childById.length) {        return null;    } else {        return childById[id];    }}
5e432cfc29343889f55188a985e9fdd950e09c11e614444a52d4444d1ff074f2
getStructOrUnionType
public StructOrUnionType getStructOrUnionType()
{    return structOrUnionType;}
8fdfc23916ab3ab1498d453cd8d67e4f6cb48bf6f6ab7747ee94a699513b6573
accept
public R accept(StateVisitor<R, S> visitor, S state)
{    return visitor.visit(this, state);}
2ad4b24ef83d8afa81e2d7b1e6065156660a84c40b37119571edf7a59e7a5faa
accept
public void accept(TypeVisitor visitor)
{    visitor.visit(this);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    StructType that = (StructType) o;    if (!Arrays.equals(childById, that.childById))        return false;    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = childById != null ? Arrays.hashCode(childById) : 0;    return result;}
0d0a0d0d7d6593b353ff999d4060ba1188f65343789ac433757492311dec9ab7
getKey
public ThriftField getKey()
{    return key;}
aa206d535ccae0f231a10e00fed3feca16a3e328ecd42c951e82ffdabdc3d92f
getValue
public ThriftField getValue()
{    return value;}
8fdfc23916ab3ab1498d453cd8d67e4f6cb48bf6f6ab7747ee94a699513b6573
accept
public R accept(StateVisitor<R, S> visitor, S state)
{    return visitor.visit(this, state);}
2ad4b24ef83d8afa81e2d7b1e6065156660a84c40b37119571edf7a59e7a5faa
accept
public void accept(TypeVisitor visitor)
{    visitor.visit(this);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (!(o instanceof MapType))        return false;    if (!super.equals(o))        return false;    MapType mapType = (MapType) o;    if (!key.equals(mapType.key))        return false;    if (!value.equals(mapType.value))        return false;    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = super.hashCode();    result = 31 * result + key.hashCode();    result = 31 * result + value.hashCode();    return result;}
1b23f9f941d254071aa9b5b9ec32531e1db27a934bba6c90061bed61e8371076
getValues
public ThriftField getValues()
{    return values;}
8fdfc23916ab3ab1498d453cd8d67e4f6cb48bf6f6ab7747ee94a699513b6573
accept
public R accept(StateVisitor<R, S> visitor, S state)
{    return visitor.visit(this, state);}
2ad4b24ef83d8afa81e2d7b1e6065156660a84c40b37119571edf7a59e7a5faa
accept
public void accept(TypeVisitor visitor)
{    visitor.visit(this);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (!(o instanceof SetType))        return false;    if (!super.equals(o))        return false;    SetType setType = (SetType) o;    if (!values.equals(setType.values))        return false;    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = super.hashCode();    result = 31 * result + values.hashCode();    return result;}
1b23f9f941d254071aa9b5b9ec32531e1db27a934bba6c90061bed61e8371076
getValues
public ThriftField getValues()
{    return values;}
8fdfc23916ab3ab1498d453cd8d67e4f6cb48bf6f6ab7747ee94a699513b6573
accept
public R accept(StateVisitor<R, S> visitor, S state)
{    return visitor.visit(this, state);}
2ad4b24ef83d8afa81e2d7b1e6065156660a84c40b37119571edf7a59e7a5faa
accept
public void accept(TypeVisitor visitor)
{    visitor.visit(this);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (!(o instanceof ListType))        return false;    if (!super.equals(o))        return false;    ListType listType = (ListType) o;    if (!values.equals(listType.values))        return false;    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = super.hashCode();    result = 31 * result + values.hashCode();    return result;}
cea1c2c1f10d4b97004da212612fc3f2159fe44d7c7e24cd3c5e70653f0143a5
getId
public int getId()
{    return id;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (!(o instanceof EnumValue))        return false;    EnumValue enumValue = (EnumValue) o;    if (id != enumValue.id)        return false;    if (name != null ? !name.equals(enumValue.name) : enumValue.name != null)        return false;    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = id;    result = 31 * result + (name != null ? name.hashCode() : 0);    return result;}
6023ebfa0fa1ae44fde28c75a2c547e94230e86cca8982bd06afadcaf9a3ca07
getValues
public Iterable<EnumValue> getValues()
{    return new Iterable<EnumValue>() {        @Override        public Iterator<EnumValue> iterator() {            return values.iterator();        }    };}
0671d1944c70b95beed8fa6d0b85d1637d28c9ce55512fff3f79ae60cc15ffe2
iterator
public Iterator<EnumValue> iterator()
{    return values.iterator();}
e50ae120a10ba512f5d04785080dd397a9d15b06bcc7b349e648c40572cda16a
getEnumValueById
public EnumValue getEnumValueById(int id)
{    prepareEnumLookUp();    return idEnumLookup.get(id);}
4ac2859c76435b0a4270e864cef7d86a39213c38ae73c2469f206b1f3d5002f6
prepareEnumLookUp
private void prepareEnumLookUp()
{    if (idEnumLookup == null) {        idEnumLookup = new HashMap<Integer, EnumValue>();        for (EnumValue value : values) {            idEnumLookup.put(value.getId(), value);        }    }}
8fdfc23916ab3ab1498d453cd8d67e4f6cb48bf6f6ab7747ee94a699513b6573
accept
public R accept(StateVisitor<R, S> visitor, S state)
{    return visitor.visit(this, state);}
2ad4b24ef83d8afa81e2d7b1e6065156660a84c40b37119571edf7a59e7a5faa
accept
public void accept(TypeVisitor visitor)
{    visitor.visit(this);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (!(o instanceof EnumType))        return false;    if (!super.equals(o))        return false;    EnumType enumType = (EnumType) o;    if (!values.equals(enumType.values))        return false;    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = super.hashCode();    result = 31 * result + values.hashCode();    return result;}
8fdfc23916ab3ab1498d453cd8d67e4f6cb48bf6f6ab7747ee94a699513b6573
accept
public R accept(StateVisitor<R, S> visitor, S state)
{    return visitor.visit(this, state);}
2ad4b24ef83d8afa81e2d7b1e6065156660a84c40b37119571edf7a59e7a5faa
accept
public void accept(TypeVisitor visitor)
{    visitor.visit(this);}
8fdfc23916ab3ab1498d453cd8d67e4f6cb48bf6f6ab7747ee94a699513b6573
accept
public R accept(StateVisitor<R, S> visitor, S state)
{    return visitor.visit(this, state);}
2ad4b24ef83d8afa81e2d7b1e6065156660a84c40b37119571edf7a59e7a5faa
accept
public void accept(TypeVisitor visitor)
{    visitor.visit(this);}
8fdfc23916ab3ab1498d453cd8d67e4f6cb48bf6f6ab7747ee94a699513b6573
accept
public R accept(StateVisitor<R, S> visitor, S state)
{    return visitor.visit(this, state);}
2ad4b24ef83d8afa81e2d7b1e6065156660a84c40b37119571edf7a59e7a5faa
accept
public void accept(TypeVisitor visitor)
{    visitor.visit(this);}
8fdfc23916ab3ab1498d453cd8d67e4f6cb48bf6f6ab7747ee94a699513b6573
accept
public R accept(StateVisitor<R, S> visitor, S state)
{    return visitor.visit(this, state);}
2ad4b24ef83d8afa81e2d7b1e6065156660a84c40b37119571edf7a59e7a5faa
accept
public void accept(TypeVisitor visitor)
{    visitor.visit(this);}
8fdfc23916ab3ab1498d453cd8d67e4f6cb48bf6f6ab7747ee94a699513b6573
accept
public R accept(StateVisitor<R, S> visitor, S state)
{    return visitor.visit(this, state);}
2ad4b24ef83d8afa81e2d7b1e6065156660a84c40b37119571edf7a59e7a5faa
accept
public void accept(TypeVisitor visitor)
{    visitor.visit(this);}
8fdfc23916ab3ab1498d453cd8d67e4f6cb48bf6f6ab7747ee94a699513b6573
accept
public R accept(StateVisitor<R, S> visitor, S state)
{    return visitor.visit(this, state);}
2ad4b24ef83d8afa81e2d7b1e6065156660a84c40b37119571edf7a59e7a5faa
accept
public void accept(TypeVisitor visitor)
{    visitor.visit(this);}
e8ad5f65cfee45feda6d692a82c43f604d820655035fa813a985c26e513f26c3
isBinary
public boolean isBinary()
{    return binary;}
462b60754121ba95ef5ca39a679ef1935649d0055b8e5f1269ae0e806d7793c0
setBinary
public void setBinary(boolean binary)
{    this.binary = binary;}
8fdfc23916ab3ab1498d453cd8d67e4f6cb48bf6f6ab7747ee94a699513b6573
accept
public R accept(StateVisitor<R, S> visitor, S state)
{    return visitor.visit(this, state);}
2ad4b24ef83d8afa81e2d7b1e6065156660a84c40b37119571edf7a59e7a5faa
accept
public void accept(TypeVisitor visitor)
{    visitor.visit(this);}
cf1f56f19a30f8a793eaa7dc98f34d227aa537c66645d2f56d20047ec76d7a4c
getType
public ThriftTypeID getType()
{    return this.type;}
90aaf48c4358a4e34e276404371fa17efd357c479e88574379e069c45390c75a
getThriftType
public byte getThriftType()
{    return thriftType;}
0be6c68fb149b6ea17db28d67ac7418c69fae9778e71558b6076a8a291e19868
isComplex
public boolean isComplex()
{    return complex;}
0f89e2526c821df5cc71e7d56fae7e06bfb50dc2537afec10d7ff3bb7617c27f
getType
public Class<? extends ThriftType> getType()
{    return clss;}
dab01a9e9dd6600445d82a16053d66fabe0eb5d0239b3876488eb5efdf88b72d
fromByte
public static ThriftTypeID fromByte(byte type)
{    return types[type];}
ab772d738a1e62048f2fa0f144d447f795103d5526b57f199cf48ff0ab1ec8c5
getSerializedThriftType
public byte getSerializedThriftType()
{    return serializedThriftType;}
8182d44973372d035be1c8b728138b846911e548c213bb95b4abaf7683e1fc73
readOneRecord
public T readOneRecord(TProtocol protocol) throws TException
{    try {        T thriftObject = thriftClass.newInstance();        thriftObject.read(protocol);        return thriftObject;    } catch (InstantiationException e) {        throw new ParquetDecodingException("Could not instantiate Thrift " + thriftClass, e);    } catch (IllegalAccessException e) {        throw new ParquetDecodingException("Thrift class or constructor not public " + thriftClass, e);    }}
33187f0fb90ba990fbae4f7abae694a6ac60b19c756576a645915595bb224f86
getThriftClass
public Class<?> getThriftClass()
{    if (thriftClass == null) {        thriftClass = getThriftClass(thriftClassName);    }    return thriftClass;}
79657b6bf78dc88b1a7a5d8702fea3376ac13bfd455b0e15b499338e69bbca02
getThriftClass
public static Class<?> getThriftClass(String thriftClassName)
{    try {        Class<?> thriftClass = Class.forName(thriftClassName);        return thriftClass;    } catch (ClassNotFoundException e) {        throw new BadConfigurationException("Could not instantiate thrift class " + thriftClassName, e);    }}
52bf56f0bcc8c199be0a023cf6ef2dfc4ba9f7fee3748a1330ad3ce5e12ad660
getDescriptor
public StructType getDescriptor()
{    return descriptor;}
1d8bdf26b9d0598504e57122ec22f8c097c1b6f16fab2a45611a3e5b61cb225b
fromExtraMetaData
public static ThriftMetaData fromExtraMetaData(Map<String, String> extraMetaData)
{    final String thriftClassName = extraMetaData.get(THRIFT_CLASS);    final String thriftDescriptorString = extraMetaData.get(THRIFT_DESCRIPTOR);    if (thriftClassName == null || thriftDescriptorString == null) {        return null;    }    final StructType descriptor = parseDescriptor(thriftDescriptorString);    return new ThriftMetaData(thriftClassName, descriptor);}
9cd9f227c27ba060d6c9ac45cb701aff998e071f170441da92152516d0e4a1e2
fromThriftClass
public static ThriftMetaData fromThriftClass(Class<?> thriftClass)
{    if (thriftClass != null && TBase.class.isAssignableFrom(thriftClass)) {        Class<? extends TBase<?, ?>> tClass = (Class<? extends TBase<?, ?>>) thriftClass;        StructType descriptor = new ThriftSchemaConverter().toStructType(tClass);        return new ThriftMetaData(thriftClass.getName(), descriptor);    }    return null;}
32f55ea0ee786b90fcc7558d10d806d5c7dcb709cb62aa1e95fe59d936ba7303
parseDescriptor
private static StructType parseDescriptor(String json)
{    try {        return (StructType) ThriftType.fromJSON(json);    } catch (RuntimeException e) {        throw new BadConfigurationException("Could not read the thrift descriptor " + json, e);    }}
adbfc69d8e91a27b3bedacff3e228bb11ac7e0ee511245d86e69e2a644f39e19
toExtraMetaData
public Map<String, String> toExtraMetaData()
{    final Map<String, String> map = new HashMap<String, String>();    map.put(THRIFT_CLASS, getThriftClass().getName());    map.put(THRIFT_DESCRIPTOR, descriptor.toJSON());    return map;}
3a0100552ee1e78bc1ab7f24416e96197c5830d232373b092fcaf29473e3d3b5
getThriftClassNames
public static Set<String> getThriftClassNames(Map<String, Set<String>> fileMetadata)
{    return fileMetadata.get(THRIFT_CLASS);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.format("ThriftMetaData(thriftClassName: %s, descriptor: %s)", thriftClassName, descriptor);}
57001f648bc8aced5ed99037b776e3debe51cd4117d311aea4e87e0a53939ff3
build
public static Builder<T> build(Path file)
{    return new Builder<T>(file);}
8c27984731e7aafa29fa0e94d76f30f54135fb6339635cd387e0b4bf22471921
withConf
public Builder<T> withConf(Configuration conf)
{    this.conf = checkNotNull(conf, "conf");    return this;}
212146f38d84bb5aabda5af0be103d25fd491483cabd6574497b6268bbeae4bb
withFilter
public Builder<T> withFilter(Filter filter)
{    this.filter = checkNotNull(filter, "filter");    return this;}
b4d29d9b3e724168b30f44c3d3ac85212c35b42ba2e905a63b482d1b37cc262b
withThriftClass
public Builder<T> withThriftClass(Class<T> thriftClass)
{    this.thriftClass = checkNotNull(thriftClass, "thriftClass");    return this;}
5ba3fa8b872885bd028793dbf81abbd4aa4e9d621155577b0d40696579de46ba
build
public ParquetReader<T> build() throws IOException
{    ReadSupport<T> readSupport;    if (thriftClass != null) {        readSupport = new ThriftReadSupport<T>(thriftClass);    } else {        readSupport = new ThriftReadSupport<T>();    }    return ParquetReader.builder(readSupport, file).withConf(conf).withFilter(filter).build();}
0ba8e2da944ada1e2b2f96d56fd37a118dc4e3ae0abe06e5d3269bb901ff0383
readFieldEnd
public void readFieldEnd() throws TException
{}
b71a881dc8c3c91a23a10a15f78f399d19a13ac5a9e0262cce9cdce0a3e74a8c
startField
private void startField()
{    events.add(readFieldBegin);}
2bde43e3fa3fb06486e690ce31c7ffeec0d13f02790868d1cb6bfd9ed5e0904f
endField
private void endField()
{    events.add(readFieldEnd);}
6771498943d82d6987ae6cbbe2274166a2ff9ce14f84ac60f6a13d9df78f9b26
readFieldBegin
public TField readFieldBegin() throws TException
{    return new TField(field.getName(), thriftType, field.getFieldId());}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    startField();    delegate.addBinary(value);    endField();}
23123f6657c241ab9b9f31f8efedc28a553ed91046d705121ce2667b065d6c17
addBoolean
public void addBoolean(boolean value)
{    startField();    delegate.addBoolean(value);    endField();}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    startField();    delegate.addDouble(value);    endField();}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    startField();    delegate.addFloat(value);    endField();}
a2ac1f40a6e220ec515710128c8baf77a725ad0b9f1767a998f776f27fff6cf6
addInt
public void addInt(int value)
{    startField();    delegate.addInt(value);    endField();}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    startField();    delegate.addLong(value);    endField();}
6771498943d82d6987ae6cbbe2274166a2ff9ce14f84ac60f6a13d9df78f9b26
readFieldBegin
public TField readFieldBegin() throws TException
{    return new TField(field.getName(), field.getType().getType().getThriftType(), field.getFieldId());}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    return delegate.getConverter(fieldIndex);}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    events.add(readFieldBegin);    delegate.start();}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    delegate.end();    events.add(readFieldEnd);}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    return delegate.getConverter(fieldIndex);}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    delegate.start();}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    delegate.end();    ++count;}
8e60bfa809a042c55d308f910bd3076d8a7754a38afd3db40f05ab64bf49341f
startCounting
public void startCounting()
{    count = 0;}
29fa59e92e8a9fa433fd7b38ebb21e8ece484149bc8e4a2726bba6f5dab39acf
getCount
public int getCount()
{    return count;}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    delegate.addBinary(value);    ++count;}
23123f6657c241ab9b9f31f8efedc28a553ed91046d705121ce2667b065d6c17
addBoolean
public void addBoolean(boolean value)
{    delegate.addBoolean(value);    ++count;}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    delegate.addDouble(value);    ++count;}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    delegate.addFloat(value);    ++count;}
a2ac1f40a6e220ec515710128c8baf77a725ad0b9f1767a998f776f27fff6cf6
addInt
public void addInt(int value)
{    delegate.addInt(value);    ++count;}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    delegate.addLong(value);    ++count;}
8e60bfa809a042c55d308f910bd3076d8a7754a38afd3db40f05ab64bf49341f
startCounting
public void startCounting()
{    count = 0;}
29fa59e92e8a9fa433fd7b38ebb21e8ece484149bc8e4a2726bba6f5dab39acf
getCount
public int getCount()
{    return count;}
b29fef1522da97c7f08339247b3ec6df8f38bcd64ecd099e6b87dfc57e7f05f1
addBoolean
public void addBoolean(final boolean value)
{    events.add(new ParquetProtocol("readBool()") {        @Override        public boolean readBool() throws TException {            return value;        }    });}
e3ae4a5d2127da24daf3630c1e497e9da2943770af69da55e3286e71d1fc6e10
readBool
public boolean readBool() throws TException
{    return value;}
2ca0a005d9d199b6c55dae31657f6695613fbabab00303ef12882d2d6bcca4a1
addDouble
public void addDouble(final double value)
{    events.add(new ParquetProtocol("readDouble()") {        @Override        public double readDouble() throws TException {            return value;        }    });}
13e5eb98c42fdbefd38e11fed60126ad859699a84615bbae60805a0c45f03126
readDouble
public double readDouble() throws TException
{    return value;}
a6a96fd8908207ceb00be617cbf1ca3c86b469f7765bcc9e089fda462210467d
addFloat
public void addFloat(final float value)
{        events.add(new ParquetProtocol("readDouble() float") {        @Override        public double readDouble() throws TException {            return value;        }    });}
13e5eb98c42fdbefd38e11fed60126ad859699a84615bbae60805a0c45f03126
readDouble
public double readDouble() throws TException
{    return value;}
e102fd1f6a8c6044cfe6841f1c98f65acdda7515bf3f3ea360eafc314cfb6dea
addInt
public void addInt(final int value)
{        switch(type) {        case BYTE:            events.add(new ParquetProtocol("readByte() int") {                @Override                public byte readByte() throws TException {                    return (byte) value;                }            });            break;        case I16:            events.add(new ParquetProtocol("readI16()") {                @Override                public short readI16() throws TException {                    return (short) value;                }            });            break;        case I32:            events.add(new ParquetProtocol("readI32()") {                @Override                public int readI32() throws TException {                    return value;                }            });            break;        default:            throw new UnsupportedOperationException("not convertible type " + type);    }}
d0afc620362c8c05d0f9d6409f34df154f23b95cbd7164d4d31708bf01bfc254
readByte
public byte readByte() throws TException
{    return (byte) value;}
ba19a1b6b27a9d1241b1532c49518058e1c6aae1b2fce864cac33b0323b4e9ed
readI16
public short readI16() throws TException
{    return (short) value;}
9cdce61957c527c2da4806031bffb0b62837efdf684b720ac095ddc794ad3be4
readI32
public int readI32() throws TException
{    return value;}
674e07818a2f843400429ee0117bd7c9d1cba353fc73c1627ef5a889aa96f46b
addLong
public void addLong(final long value)
{    events.add(new ParquetProtocol("readI64()") {        @Override        public long readI64() throws TException {            return value;        }    });}
effebad19b862ab3187f7a56079de27779133ee1979be7276c1ea72d6bec8a0b
readI64
public long readI64() throws TException
{    return value;}
5ec62381be4a5a062daacccebf023e014176b055e13f5be449c355e8679086e6
addBinary
public void addBinary(final Binary value)
{    events.add(new ParquetProtocol("readString() binary") {        @Override        public String readString() throws TException {            return value.toStringUsingUTF8();        }        @Override        public ByteBuffer readBinary() throws TException {            return value.toByteBuffer();        }    });}
00b5d4f7589ed91042175c05b813cc60c9649f639b471d6be729691cd5b52bd7
readString
public String readString() throws TException
{    return value.toStringUsingUTF8();}
a4bf98b9a9e380c02f650aea16d41e5140ec75fdfa57c19ba07e0787d5cb43b9
readBinary
public ByteBuffer readBinary() throws TException
{    return value.toByteBuffer();}
5ec62381be4a5a062daacccebf023e014176b055e13f5be449c355e8679086e6
addBinary
public void addBinary(final Binary value)
{    final Integer id = enumLookup.get(value);    if (id == null) {        throw new ParquetDecodingException("Unrecognized enum value: " + value.toStringUsingUTF8() + " known values: " + enumLookup + " in " + this.field);    }    events.add(new ParquetProtocol("readI32() enum") {        @Override        public int readI32() throws TException {            return id;        }    });}
9cdce61957c527c2da4806031bffb0b62837efdf684b720ac095ddc794ad3be4
readI32
public int readI32() throws TException
{    return id;}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    if (fieldIndex != 0) {        throw new IllegalArgumentException("lists have only one field. can't reach " + fieldIndex);    }    return child;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    child.startCounting();}
2a5867240c482ae3a61d58bbbb1c1b7e42b363a1f64c6cd3524c0470d749c9a0
readMapEnd
public void readMapEnd() throws TException
{}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    final int count = child.getCount();    parentEvents.add(new ParquetProtocol("readMapBegin()") {        @Override        public TMap readMapBegin() throws TException {            return new TMap(keyType, valueType, count);        }    });    parentEvents.addAll(mapEvents);    mapEvents.clear();    parentEvents.add(readMapEnd);}
ccef29d31156242180b2595fbe4f2e8f11ecb097f7eb5013f5cfbcbadb7d3f2b
readMapBegin
public TMap readMapBegin() throws TException
{    return new TMap(keyType, valueType, count);}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    switch(fieldIndex) {        case 0:            return keyConverter;        case 1:            return valueConverter;        default:            throw new IllegalArgumentException("only key (0) and value (1) are supported. got " + fieldIndex);    }}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{}
6d0d71f10658b2a33eefe039338687f1c171606506f807722885f53093eb40ca
readSetEnd
public void readSetEnd() throws TException
{}
7666f92f45c23ca2fa0490326aacfde83b2de23ee511aa870e59d2b9e816350e
collectionStart
 void collectionStart(final int count, final byte type)
{    parentEvents.add(new ParquetProtocol("readSetBegin()") {        @Override        public TSet readSetBegin() throws TException {            return new TSet(type, count);        }    });}
5b0265bf5be1a6ae8196064eb3a9728c746c5a31b8da6f6e24655b5b965b45dc
readSetBegin
public TSet readSetBegin() throws TException
{    return new TSet(type, count);}
7b074901c4b2aa8de125aac5b14f9efd25ce2d2581cee3014fa519a84765d849
collectionEnd
 void collectionEnd()
{    parentEvents.add(readSetEnd);}
751f723cedbf7b8de4f12a4df7d3afebe4ff7079c529f2086892ae666fc1bf34
readListEnd
public void readListEnd() throws TException
{}
7666f92f45c23ca2fa0490326aacfde83b2de23ee511aa870e59d2b9e816350e
collectionStart
 void collectionStart(final int count, final byte type)
{    parentEvents.add(new ParquetProtocol("readListBegin()") {        @Override        public TList readListBegin() throws TException {            return new TList(type, count);        }    });}
f11327b40a2aa7489a812533ff4e918785c8373aaf59343add9f4bbcdcfd11f0
readListBegin
public TList readListBegin() throws TException
{    return new TList(type, count);}
7b074901c4b2aa8de125aac5b14f9efd25ce2d2581cee3014fa519a84765d849
collectionEnd
 void collectionEnd()
{    parentEvents.add(readListEnd);}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    if (fieldIndex != 0) {        throw new IllegalArgumentException("lists have only one field. can't reach " + fieldIndex);    }    return child;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    childCounter.startCounting();}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    int count = childCounter.getCount();    if (elementConverter != null) {        count -= elementConverter.getNullElementCount();    }    collectionStart(count, valuesType.getThriftType());    parentEvents.addAll(listEvents);    listEvents.clear();    collectionEnd();}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    Preconditions.checkArgument(fieldIndex == 0, "Illegal field index: %s", fieldIndex);    return elementConverter;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    elementEvents.clear();}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    if (elementEvents.size() > 0) {        listEvents.addAll(elementEvents);    } else {        nullElementCount += 1;    }}
ab3aa1bb2ac2873c3b7deda975ec69c22f05505272208a35d29c1f9958294d2d
getNullElementCount
public int getNullElementCount()
{    return nullElementCount;}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    return converters[fieldIndex];}
4581ce92c1c14390774b3334899b0792f18429a4fa86e1eab50f00a0c8e87c3b
readStructBegin
public TStruct readStructBegin() throws TException
{    return tStruct;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    events.add(readStructBegin);}
6771498943d82d6987ae6cbbe2274166a2ff9ce14f84ac60f6a13d9df78f9b26
readFieldBegin
public TField readFieldBegin() throws TException
{    return stop;}
313291383bc799a61a64fd536cdb66162569f48a255366c7cc2e937412433b56
readStructEnd
public void readStructEnd() throws TException
{}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    events.add(readFieldStop);    events.add(readStructEnd);}
98e927cdc3a822e8ee6aab04b0f81610877c942b02320e5f4dbb5b3fa615a7f9
hasMissingRequiredFieldInGroupType
private boolean hasMissingRequiredFieldInGroupType(GroupType requested, GroupType fullSchema)
{    for (Type field : fullSchema.getFields()) {        if (requested.containsField(field.getName())) {            Type requestedType = requested.getType(field.getName());                        if (!field.isPrimitive()) {                if (hasMissingRequiredFieldInGroupType(requestedType.asGroupType(), field.asGroupType())) {                    return true;                } else {                                        continue;                }            }        } else {            if (field.getRepetition() == Type.Repetition.REQUIRED) {                                return true;            } else {                                continue;            }        }    }    return false;}
4da3915efeb45bd522ec756d13523540a507279d9a0b787efd2cafb4356363d1
getCurrentRecord
public T getCurrentRecord()
{    try {        if (missingRequiredFieldsInProjection) {            List<TProtocol> fixedEvents = new ProtocolEventsAmender(rootEvents).amendMissingRequiredFields(thriftType);            protocol.addAll(fixedEvents);        } else {            protocol.addAll(rootEvents);        }        rootEvents.clear();        return thriftReader.readOneRecord(protocol);    } catch (TException e) {        protocol.clear();        rootEvents.clear();        throw new RecordMaterializationException("Could not read thrift object from protocol", e);    }}
52337910a1f4ce802e2fe6041829534330913357c00d4735ce0fa742f5c3df17
skipCurrentRecord
public void skipCurrentRecord()
{    rootEvents.clear();}
92fd854c4aebb01be238d83e407159211ea5cf60b5efd6fc7db8904dba13699b
getRootConverter
public GroupConverter getRootConverter()
{    return structConverter;}
1c9423d5ad8fefef55f3a84ed331de710fed8d1068f156cb78a8b2eac6415bf8
newConverter
private Converter newConverter(List<TProtocol> events, Type type, ThriftField field)
{    switch(field.getType().getType()) {        case LIST:            return new ListConverter(events, type.asGroupType(), field);        case SET:            return new SetConverter(events, type.asGroupType(), field);        case MAP:            return new MapConverter(events, type.asGroupType(), field);        case STRUCT:            return new StructConverter(events, type.asGroupType(), field);        case STRING:            return new FieldStringConverter(events, field);        case ENUM:            return new FieldEnumConverter(events, field);        default:            return new FieldPrimitiveConverter(events, field);    }}
2e06b69eda7352a84869241be5c02671c39ca679e75e2fc895903c7ef5d0cbb7
convert
public MessageType convert(Class<? extends TBase<?, ?>> thriftClass)
{    return convert(toStructType(thriftClass));}
aef82f6a30cfb0f9e439ea43dffada9325a41b5edc4a55361e4704dc1aed90ef
convert
public MessageType convert(StructType struct)
{    MessageType messageType = ThriftSchemaConvertVisitor.convert(struct, fieldProjectionFilter, true);    fieldProjectionFilter.assertNoUnmatchedPatterns();    return messageType;}
16626d107020a0a832dcb0e337c4e43cb23eb85f624a95eea1dfd0f40e24f421
convertWithoutProjection
public static MessageType convertWithoutProjection(StructType struct)
{    return ThriftSchemaConvertVisitor.convert(struct, FieldProjectionFilter.ALL_COLUMNS, false);}
fb4a9f66b61498e0d6a5c7ee525d5d023f8ccc158e746b6c57264ccb80bbe8c5
structOrUnionType
public static StructOrUnionType structOrUnionType(Class<T> klass)
{    return TUnion.class.isAssignableFrom(klass) ? StructOrUnionType.UNION : StructOrUnionType.STRUCT;}
eb46cb1aca6e1681c65dc6dd67ef17f18df02b667d2d25c696a2be920fccc3e8
toStructType
public static ThriftType.StructType toStructType(Class<? extends TBase<?, ?>> thriftClass)
{    final TStructDescriptor struct = TStructDescriptor.getInstance(thriftClass);    return toStructType(struct);}
88cbb8b519acb05ed305f3c5a8efb7a75a6e06b96de24aa1f9f577117008e744
toStructType
private static StructType toStructType(TStructDescriptor struct)
{    List<Field> fields = struct.getFields();    List<ThriftField> children = new ArrayList<ThriftField>(fields.size());    for (Field field : fields) {        Requirement req = field.getFieldMetaData() == null ? Requirement.OPTIONAL : Requirement.fromType(field.getFieldMetaData().requirementType);        children.add(toThriftField(field.getName(), field, req));    }    return new StructType(children, structOrUnionType(struct.getThriftClass()));}
b4c5d16e452126863e61c3afafe285137206429c7fe3e44363cb48c12516e256
isListElementType
 static boolean isListElementType(Type repeatedType, ThriftField thriftElement)
{    if (repeatedType.isPrimitive() || (repeatedType.asGroupType().getFieldCount() != 1) || (repeatedType.asGroupType().getType(0).isRepetition(REPEATED))) {                return true;    } else if (thriftElement != null && thriftElement.getType() instanceof StructType) {        Set<String> fieldNames = new HashSet<String>();        for (ThriftField field : ((StructType) thriftElement.getType()).getChildren()) {            fieldNames.add(field.getName());        }                return fieldNames.contains(repeatedType.asGroupType().getFieldName(0));    }    return false;}
2bb6609540228c2a80149d1710ad7ad9521fe1ccc7c7cbd56446da2c7564728f
toThriftField
private static ThriftField toThriftField(String name, Field field, ThriftField.Requirement requirement)
{    ThriftType type;    switch(ThriftTypeID.fromByte(field.getType())) {        case STOP:        case VOID:        default:            throw new UnsupportedOperationException("can't convert type of " + field);        case BOOL:            type = new BoolType();            break;        case BYTE:            type = new ByteType();            break;        case DOUBLE:            type = new DoubleType();            break;        case I16:            type = new I16Type();            break;        case I32:            type = new I32Type();            break;        case I64:            type = new I64Type();            break;        case STRING:            StringType stringType = new StringType();            FieldMetaData fieldMetaData = field.getFieldMetaData();                        if (fieldMetaData != null && fieldMetaData.valueMetaData.isBinary()) {                stringType.setBinary(true);            }            type = stringType;            break;        case STRUCT:            type = toStructType(field.gettStructDescriptor());            break;        case MAP:            final Field mapKeyField = field.getMapKeyField();            final Field mapValueField = field.getMapValueField();            type = new ThriftType.MapType(toThriftField(mapKeyField.getName(), mapKeyField, requirement), toThriftField(mapValueField.getName(), mapValueField, requirement));            break;        case SET:            final Field setElemField = field.getSetElemField();            type = new ThriftType.SetType(toThriftField(setElemField.getName(), setElemField, requirement));            break;        case LIST:            final Field listElemField = field.getListElemField();            type = new ThriftType.ListType(toThriftField(listElemField.getName(), listElemField, requirement));            break;        case ENUM:            Collection<TEnum> enumValues = field.getEnumValues();            List<EnumValue> values = new ArrayList<ThriftType.EnumValue>();            for (TEnum tEnum : enumValues) {                values.add(new EnumValue(tEnum.getValue(), tEnum.toString()));            }            type = new EnumType(values);            break;    }    return new ThriftField(name, field.getId(), requirement, type);}
544d841ad33c86952abc5552398eaddd50eabb321bcbae3383a4616037d68311
convert
public static MessageType convert(StructType struct, FieldProjectionFilter filter)
{    return convert(struct, filter, true);}
e6921c1aa1845e723cb843781a35da9453c7ccad8c0ca9c6bcff5552fee0485f
convert
public static MessageType convert(StructType struct, FieldProjectionFilter filter, boolean keepOneOfEachUnion)
{    State state = new State(new FieldsPath(), REPEATED, "ParquetSchema");    ConvertedField converted = struct.accept(new ThriftSchemaConvertVisitor(filter, true, keepOneOfEachUnion), state);    if (!converted.isKeep()) {        throw new ThriftProjectionException("No columns have been selected");    }    return new MessageType(state.name, converted.asKeep().getType().asGroupType().getFields());}
95e202afaf234f3ad39bc2753bd2e2bd5aa5b73cf5df621c6653ff2a6575dff7
getFieldProjectionFilter
public FieldProjectionFilter getFieldProjectionFilter()
{    return fieldProjectionFilter;}
6f17b42cb4834b47db2bb9f3c4d269aa510da450bd566cb668ae166cee56ae01
visit
public ConvertedField visit(MapType mapType, State state)
{    ThriftField keyField = mapType.getKey();    ThriftField valueField = mapType.getValue();    State keyState = new State(state.path.push(keyField), REQUIRED, "key");                State valueState = new State(state.path.push(valueField), OPTIONAL, "value");    ConvertedField convertedKey = keyField.getType().accept(this, keyState);    ConvertedField convertedValue = valueField.getType().accept(this, valueState);    if (!convertedKey.isKeep()) {        if (convertedValue.isKeep()) {            throw new ThriftProjectionException("Cannot select only the values of a map, you must keep the keys as well: " + state.path);        }                return new Drop(state.path);    }        if (doProjection) {        ConvertedField fullConvKey = keyField.getType().accept(new ThriftSchemaConvertVisitor(FieldProjectionFilter.ALL_COLUMNS, false, keepOneOfEachUnion), keyState);        if (!fullConvKey.asKeep().getType().equals(convertedKey.asKeep().getType())) {            throw new ThriftProjectionException("Cannot select only a subset of the fields in a map key, " + "for path " + state.path);        }    }    if (convertedValue.isKeep()) {                Type mapField = mapType(state.repetition, state.name, convertedKey.asKeep().getType(), convertedValue.asKeep().getType());        return new Keep(state.path, mapField);    }        ConvertedField sentinelValue = valueField.getType().accept(new ThriftSchemaConvertVisitor(new KeepOnlyFirstPrimitiveFilter(), true, keepOneOfEachUnion), valueState);    Type mapField = mapType(state.repetition, state.name, convertedKey.asKeep().getType(),     sentinelValue.asKeep().getType());    return new Keep(state.path, mapField);}
13c631ea59e0608da69cc02a768a5d75046244fe2a9a7fe5a02014bc4f065bb1
visitListLike
private ConvertedField visitListLike(ThriftField listLike, State state, boolean isSet)
{    State childState = new State(state.path, REPEATED, state.name + "_tuple");    ConvertedField converted = listLike.getType().accept(this, childState);    if (converted.isKeep()) {                if (isSet && doProjection) {            ConvertedField fullConv = listLike.getType().accept(new ThriftSchemaConvertVisitor(FieldProjectionFilter.ALL_COLUMNS, false, keepOneOfEachUnion), childState);            if (!converted.asKeep().getType().equals(fullConv.asKeep().getType())) {                throw new ThriftProjectionException("Cannot select only a subset of the fields in a set, " + "for path " + state.path);            }        }        return new Keep(state.path, listType(state.repetition, state.name, converted.asKeep().getType()));    }    return new Drop(state.path);}
a892a2ad3471797c908af172d5be97127a0986b4a476742bfa59e3325931b872
visit
public ConvertedField visit(SetType setType, State state)
{    return visitListLike(setType.getValues(), state, true);}
4cfcc3260ef9381039174348d83bc735f7c9006aaaa3f88d4622d17dde535f84
visit
public ConvertedField visit(ListType listType, State state)
{    return visitListLike(listType.getValues(), state, false);}
47d480ea6b39699803f4622070a7a7df5140c89980b722f00a82778bf993cda0
visit
public ConvertedField visit(StructType structType, State state)
{                final boolean needsToKeepOneOfEachUnion = keepOneOfEachUnion && isUnion(structType.getStructOrUnionType());    boolean hasSentinelUnionColumns = false;    boolean hasNonSentinelUnionColumns = false;    List<Type> convertedChildren = new ArrayList<Type>();    for (ThriftField child : structType.getChildren()) {        State childState = new State(state.path.push(child), getRepetition(child), child.getName());        ConvertedField converted = child.getType().accept(this, childState);        if (!converted.isKeep() && needsToKeepOneOfEachUnion) {                                                                                    ConvertedField firstPrimitive = child.getType().accept(new ThriftSchemaConvertVisitor(new KeepOnlyFirstPrimitiveFilter(), true, keepOneOfEachUnion), childState);            convertedChildren.add(firstPrimitive.asKeep().getType().withId(child.getFieldId()));            hasSentinelUnionColumns = true;        }        if (converted.isSentinelUnion()) {                        if (childState.repetition == REQUIRED) {                                convertedChildren.add(converted.asSentinelUnion().getType().withId(child.getFieldId()));                hasSentinelUnionColumns = true;            }        } else if (converted.isKeep()) {                        convertedChildren.add(converted.asKeep().getType().withId(child.getFieldId()));            hasNonSentinelUnionColumns = true;        }    }    if (!hasNonSentinelUnionColumns && hasSentinelUnionColumns) {                return new SentinelUnion(state.path, new GroupType(state.repetition, state.name, convertedChildren));    }    if (hasNonSentinelUnionColumns) {                return new Keep(state.path, new GroupType(state.repetition, state.name, convertedChildren));    } else {                return new Drop(state.path);    }}
a2a800f44418380fe027489d017b884aa4fccfe4ae742d5f18525b7508145a50
visitPrimitiveType
private ConvertedField visitPrimitiveType(PrimitiveTypeName type, State state)
{    return visitPrimitiveType(type, null, state);}
1a3d84df8a15a9fb7b781736728ea8860861202dc1dad765db5e2e89e59caaa6
visitPrimitiveType
private ConvertedField visitPrimitiveType(PrimitiveTypeName type, LogicalTypeAnnotation orig, State state)
{    PrimitiveBuilder<PrimitiveType> b = primitive(type, state.repetition);    if (orig != null) {        b = b.as(orig);    }    if (fieldProjectionFilter.keep(state.path)) {        return new Keep(state.path, b.named(state.name));    } else {        return new Drop(state.path);    }}
b6368df148cc2b611811289e7d95a33dd308ef22c132b3c68aef6b801cabef2b
visit
public ConvertedField visit(EnumType enumType, State state)
{    return visitPrimitiveType(BINARY, enumType(), state);}
c36e4005262f759ff2d56b8b200202ad2f394dd9a49326623b4f00475b36f20c
visit
public ConvertedField visit(BoolType boolType, State state)
{    return visitPrimitiveType(BOOLEAN, state);}
cb9a761a34dfe4379a51d98d3871fdd1bbcc1567e2188e0eee28ed0dce378b23
visit
public ConvertedField visit(ByteType byteType, State state)
{    return visitPrimitiveType(INT32, state);}
71dedfd8f4556c1e4883190e0b992cafc815ae87c13f80135a6beac32ebc1268
visit
public ConvertedField visit(DoubleType doubleType, State state)
{    return visitPrimitiveType(DOUBLE, state);}
b54c8afa663a1a7f3f211bb2da58d70a719d7c7010a07f7e5e2d84c2b1d08f25
visit
public ConvertedField visit(I16Type i16Type, State state)
{    return visitPrimitiveType(INT32, state);}
f3928957f9cf12dab9748e3294ba4d78f1ba4976cf5d5a3722d0ed6b931f3ce6
visit
public ConvertedField visit(I32Type i32Type, State state)
{    return visitPrimitiveType(INT32, state);}
3d4e12e55dc931471b62fafb421939cd4451fa48f49613c11e1769a74d5344a3
visit
public ConvertedField visit(I64Type i64Type, State state)
{    return visitPrimitiveType(INT64, state);}
01ca1708c3a9eca023de483d937053d25fb130fadd0b3c3d4d4486c0950ba5d1
visit
public ConvertedField visit(StringType stringType, State state)
{    return stringType.isBinary() ? visitPrimitiveType(BINARY, state) : visitPrimitiveType(BINARY, stringType(), state);}
8f9909f6cbde3426978a7daeff117bc730b45a1d4110208d06755457ee7c02e3
isUnion
private static boolean isUnion(StructOrUnionType s)
{    switch(s) {        case STRUCT:            return false;        case UNION:            return true;        case UNKNOWN:            throw new ShouldNeverHappenException("Encountered UNKNOWN StructOrUnionType");        default:            throw new ShouldNeverHappenException("Unrecognized type: " + s);    }}
86bf50042ce7ff0dcf8f8cc71690322e27f8bb08e6d849d73a139fdb3604c66d
getRepetition
private Type.Repetition getRepetition(ThriftField thriftField)
{    switch(thriftField.getRequirement()) {        case REQUIRED:            return REQUIRED;        case OPTIONAL:            return OPTIONAL;        case DEFAULT:            return OPTIONAL;        default:            throw new IllegalArgumentException("unknown requirement type: " + thriftField.getRequirement());    }}
b84ba1f9425b71b19fb7376d244eea4c319d144ae6238234341d80aba9da5302
testUnannotatedListOfPrimitives
public void testUnannotatedListOfPrimitives() throws Exception
{    Path test = writeDirect("message UnannotatedListOfPrimitives {" + "  repeated int32 list_of_ints;" + "}", new DirectWriter() {        @Override        public void write(RecordConsumer rc) {            rc.startMessage();            rc.startField("list_of_ints", 0);            rc.addInteger(34);            rc.addInteger(35);            rc.addInteger(36);            rc.endField("list_of_ints", 0);            rc.endMessage();        }    });}
81d5de5a9061acf3ac8a15a58be211196e4ac40d5ec37a0375883fc85458f64b
write
public void write(RecordConsumer rc)
{    rc.startMessage();    rc.startField("list_of_ints", 0);    rc.addInteger(34);    rc.addInteger(35);    rc.addInteger(36);    rc.endField("list_of_ints", 0);    rc.endMessage();}
5a4baebacbd4874fdec760dafc68dba24c886301fb3991c61b4ec2abe60edce9
testUnannotatedListOfGroups
public void testUnannotatedListOfGroups() throws Exception
{    Path test = writeDirect("message UnannotatedListOfGroups {" + "  repeated group list_of_points {" + "    required float x;" + "    required float y;" + "  }" + "}", new DirectWriter() {        @Override        public void write(RecordConsumer rc) {            rc.startMessage();            rc.startField("list_of_points", 0);            rc.startGroup();            rc.startField("x", 0);            rc.addFloat(1.0f);            rc.endField("x", 0);            rc.startField("y", 1);            rc.addFloat(1.0f);            rc.endField("y", 1);            rc.endGroup();            rc.startGroup();            rc.startField("x", 0);            rc.addFloat(2.0f);            rc.endField("x", 0);            rc.startField("y", 1);            rc.addFloat(2.0f);            rc.endField("y", 1);            rc.endGroup();            rc.endField("list_of_points", 0);            rc.endMessage();        }    });}
81d5de5a9061acf3ac8a15a58be211196e4ac40d5ec37a0375883fc85458f64b
write
public void write(RecordConsumer rc)
{    rc.startMessage();    rc.startField("list_of_points", 0);    rc.startGroup();    rc.startField("x", 0);    rc.addFloat(1.0f);    rc.endField("x", 0);    rc.startField("y", 1);    rc.addFloat(1.0f);    rc.endField("y", 1);    rc.endGroup();    rc.startGroup();    rc.startField("x", 0);    rc.addFloat(2.0f);    rc.endField("x", 0);    rc.startField("y", 1);    rc.addFloat(2.0f);    rc.endField("y", 1);    rc.endGroup();    rc.endField("list_of_points", 0);    rc.endMessage();}
ae247d14d731916bf43b1eb580350f39cbb8856c00aa6df59bb6a274aa3973e0
testRepeatedPrimitiveInList
public void testRepeatedPrimitiveInList() throws Exception
{    Path test = writeDirect("message RepeatedPrimitiveInList {" + "  required group list_of_ints (LIST) {" + "    repeated int32 array;" + "  }" + "}", new DirectWriter() {        @Override        public void write(RecordConsumer rc) {            rc.startMessage();            rc.startField("list_of_ints", 0);            rc.startGroup();            rc.startField("array", 0);            rc.addInteger(34);            rc.addInteger(35);            rc.addInteger(36);            rc.endField("array", 0);            rc.endGroup();            rc.endField("list_of_ints", 0);            rc.endMessage();        }    });    ListOfInts expected = new ListOfInts(Lists.newArrayList(34, 35, 36));    ListOfInts actual = reader(test, ListOfInts.class).read();    Assert.assertEquals("Should read record correctly", expected, actual);}
81d5de5a9061acf3ac8a15a58be211196e4ac40d5ec37a0375883fc85458f64b
write
public void write(RecordConsumer rc)
{    rc.startMessage();    rc.startField("list_of_ints", 0);    rc.startGroup();    rc.startField("array", 0);    rc.addInteger(34);    rc.addInteger(35);    rc.addInteger(36);    rc.endField("array", 0);    rc.endGroup();    rc.endField("list_of_ints", 0);    rc.endMessage();}
9683c96afd0fa837c2487e739090fbe99c0943a3b54dcb5d6267f554b31ea0ba
testMultiFieldGroupInList
public void testMultiFieldGroupInList() throws Exception
{        Path test = writeDirect("message MultiFieldGroupInList {" + "  optional group locations (LIST) {" + "    repeated group element {" + "      required double latitude;" + "      required double longitude;" + "    }" + "  }" + "}", new DirectWriter() {        @Override        public void write(RecordConsumer rc) {            rc.startMessage();            rc.startField("locations", 0);            rc.startGroup();            rc.startField("element", 0);            rc.startGroup();            rc.startField("latitude", 0);            rc.addDouble(0.0);            rc.endField("latitude", 0);            rc.startField("longitude", 1);            rc.addDouble(0.0);            rc.endField("longitude", 1);            rc.endGroup();            rc.startGroup();            rc.startField("latitude", 0);            rc.addDouble(0.0);            rc.endField("latitude", 0);            rc.startField("longitude", 1);            rc.addDouble(180.0);            rc.endField("longitude", 1);            rc.endGroup();            rc.endField("element", 0);            rc.endGroup();            rc.endField("locations", 0);            rc.endMessage();        }    });    ListOfLocations expected = new ListOfLocations();    expected.addToLocations(new Location(0.0, 0.0));    expected.addToLocations(new Location(0.0, 180.0));    assertReaderContains(reader(test, ListOfLocations.class), expected);}
81d5de5a9061acf3ac8a15a58be211196e4ac40d5ec37a0375883fc85458f64b
write
public void write(RecordConsumer rc)
{    rc.startMessage();    rc.startField("locations", 0);    rc.startGroup();    rc.startField("element", 0);    rc.startGroup();    rc.startField("latitude", 0);    rc.addDouble(0.0);    rc.endField("latitude", 0);    rc.startField("longitude", 1);    rc.addDouble(0.0);    rc.endField("longitude", 1);    rc.endGroup();    rc.startGroup();    rc.startField("latitude", 0);    rc.addDouble(0.0);    rc.endField("latitude", 0);    rc.startField("longitude", 1);    rc.addDouble(180.0);    rc.endField("longitude", 1);    rc.endGroup();    rc.endField("element", 0);    rc.endGroup();    rc.endField("locations", 0);    rc.endMessage();}
7661fdb267d3ffb786c4aaaf78468e570aaa3f081547a61db12abaed6c764431
testSingleFieldGroupInList
public void testSingleFieldGroupInList() throws Exception
{            Path test = writeDirect("message SingleFieldGroupInList {" + "  optional group single_element_groups (LIST) {" + "    repeated group single_element_group {" + "      required int64 count;" + "    }" + "  }" + "}", new DirectWriter() {        @Override        public void write(RecordConsumer rc) {            rc.startMessage();            rc.startField("single_element_groups", 0);            rc.startGroup();                        rc.startField("single_element_group", 0);            rc.startGroup();            rc.startField("count", 0);            rc.addLong(1234L);            rc.endField("count", 0);            rc.endGroup();            rc.startGroup();            rc.startField("count", 0);            rc.addLong(2345L);            rc.endField("count", 0);            rc.endGroup();                        rc.endField("single_element_group", 0);            rc.endGroup();            rc.endField("single_element_groups", 0);            rc.endMessage();        }    });            ListOfSingleElementGroups expectedOldBehavior = new ListOfSingleElementGroups();    expectedOldBehavior.addToSingle_element_groups(new SingleElementGroup(1234L));    expectedOldBehavior.addToSingle_element_groups(new SingleElementGroup(2345L));    assertReaderContains(reader(test, ListOfSingleElementGroups.class), expectedOldBehavior);        ListOfCounts expectedNewBehavior = new ListOfCounts();    expectedNewBehavior.addToSingle_element_groups(1234L);    expectedNewBehavior.addToSingle_element_groups(2345L);    assertReaderContains(reader(test, ListOfCounts.class), expectedNewBehavior);}
81d5de5a9061acf3ac8a15a58be211196e4ac40d5ec37a0375883fc85458f64b
write
public void write(RecordConsumer rc)
{    rc.startMessage();    rc.startField("single_element_groups", 0);    rc.startGroup();        rc.startField("single_element_group", 0);    rc.startGroup();    rc.startField("count", 0);    rc.addLong(1234L);    rc.endField("count", 0);    rc.endGroup();    rc.startGroup();    rc.startField("count", 0);    rc.addLong(2345L);    rc.endField("count", 0);    rc.endGroup();        rc.endField("single_element_group", 0);    rc.endGroup();    rc.endField("single_element_groups", 0);    rc.endMessage();}
3a3a31b1888e62287391186f67d9124844f06223abfb349935f59c47a4b895e9
testNewOptionalGroupInList
public void testNewOptionalGroupInList() throws Exception
{    Path test = writeDirect("message NewOptionalGroupInList {" + "  optional group locations (LIST) {" + "    repeated group list {" + "      optional group element {" + "        required double latitude;" + "        required double longitude;" + "      }" + "    }" + "  }" + "}", new DirectWriter() {        @Override        public void write(RecordConsumer rc) {            rc.startMessage();            rc.startField("locations", 0);            rc.startGroup();                        rc.startField("list", 0);                                    rc.startGroup();            rc.startField("element", 0);            rc.startGroup();            rc.startField("latitude", 0);            rc.addDouble(0.0);            rc.endField("latitude", 0);            rc.startField("longitude", 1);            rc.addDouble(0.0);            rc.endField("longitude", 1);            rc.endGroup();            rc.endField("element", 0);                        rc.endGroup();                                    rc.startGroup();                        rc.endGroup();                                    rc.startGroup();            rc.startField("element", 0);            rc.startGroup();            rc.startField("latitude", 0);            rc.addDouble(0.0);            rc.endField("latitude", 0);            rc.startField("longitude", 1);            rc.addDouble(180.0);            rc.endField("longitude", 1);            rc.endGroup();            rc.endField("element", 0);                        rc.endGroup();                        rc.endField("list", 0);            rc.endGroup();            rc.endField("locations", 0);            rc.endMessage();        }    });    ListOfLocations expected = new ListOfLocations();    expected.addToLocations(new Location(0.0, 0.0));            expected.addToLocations(new Location(0.0, 180.0));    try {        assertReaderContains(reader(test, ListOfLocations.class), expected);        fail("Should fail: locations are optional and not ignored");    } catch (RuntimeException e) {                assertTrue(e.getCause().getCause().getMessage().contains("locations"));    }    assertReaderContains(readerIgnoreNulls(test, ListOfLocations.class), expected);}
81d5de5a9061acf3ac8a15a58be211196e4ac40d5ec37a0375883fc85458f64b
write
public void write(RecordConsumer rc)
{    rc.startMessage();    rc.startField("locations", 0);    rc.startGroup();        rc.startField("list", 0);            rc.startGroup();    rc.startField("element", 0);    rc.startGroup();    rc.startField("latitude", 0);    rc.addDouble(0.0);    rc.endField("latitude", 0);    rc.startField("longitude", 1);    rc.addDouble(0.0);    rc.endField("longitude", 1);    rc.endGroup();    rc.endField("element", 0);        rc.endGroup();            rc.startGroup();        rc.endGroup();            rc.startGroup();    rc.startField("element", 0);    rc.startGroup();    rc.startField("latitude", 0);    rc.addDouble(0.0);    rc.endField("latitude", 0);    rc.startField("longitude", 1);    rc.addDouble(180.0);    rc.endField("longitude", 1);    rc.endGroup();    rc.endField("element", 0);        rc.endGroup();        rc.endField("list", 0);    rc.endGroup();    rc.endField("locations", 0);    rc.endMessage();}
53d979a675586bbb9135b8b6a0eebf188ac9aca7389bf934dc0a01b609d2a809
testNewRequiredGroupInList
public void testNewRequiredGroupInList() throws Exception
{    Path test = writeDirect("message NewRequiredGroupInList {" + "  optional group locations (LIST) {" + "    repeated group list {" + "      required group element {" + "        required double latitude;" + "        required double longitude;" + "      }" + "    }" + "  }" + "}", new DirectWriter() {        @Override        public void write(RecordConsumer rc) {            rc.startMessage();            rc.startField("locations", 0);            rc.startGroup();                        rc.startField("list", 0);                                    rc.startGroup();            rc.startField("element", 0);            rc.startGroup();            rc.startField("latitude", 0);            rc.addDouble(0.0);            rc.endField("latitude", 0);            rc.startField("longitude", 1);            rc.addDouble(180.0);            rc.endField("longitude", 1);            rc.endGroup();            rc.endField("element", 0);                        rc.endGroup();                                    rc.startGroup();            rc.startField("element", 0);            rc.startGroup();            rc.startField("latitude", 0);            rc.addDouble(0.0);            rc.endField("latitude", 0);            rc.startField("longitude", 1);            rc.addDouble(0.0);            rc.endField("longitude", 1);            rc.endGroup();            rc.endField("element", 0);                        rc.endGroup();                        rc.endField("list", 0);            rc.endGroup();            rc.endField("locations", 0);            rc.endMessage();        }    });    ListOfLocations expected = new ListOfLocations();    expected.addToLocations(new Location(0.0, 180.0));    expected.addToLocations(new Location(0.0, 0.0));    assertReaderContains(reader(test, ListOfLocations.class), expected);}
81d5de5a9061acf3ac8a15a58be211196e4ac40d5ec37a0375883fc85458f64b
write
public void write(RecordConsumer rc)
{    rc.startMessage();    rc.startField("locations", 0);    rc.startGroup();        rc.startField("list", 0);            rc.startGroup();    rc.startField("element", 0);    rc.startGroup();    rc.startField("latitude", 0);    rc.addDouble(0.0);    rc.endField("latitude", 0);    rc.startField("longitude", 1);    rc.addDouble(180.0);    rc.endField("longitude", 1);    rc.endGroup();    rc.endField("element", 0);        rc.endGroup();            rc.startGroup();    rc.startField("element", 0);    rc.startGroup();    rc.startField("latitude", 0);    rc.addDouble(0.0);    rc.endField("latitude", 0);    rc.startField("longitude", 1);    rc.addDouble(0.0);    rc.endField("longitude", 1);    rc.endGroup();    rc.endField("element", 0);        rc.endGroup();        rc.endField("list", 0);    rc.endGroup();    rc.endField("locations", 0);    rc.endMessage();}
370ddddc46d49ba942ff37848aed93966ad87ba950cdcb9307f5221cdfd49097
testAvroCompatRequiredGroupInList
public void testAvroCompatRequiredGroupInList() throws Exception
{    Path test = writeDirect("message AvroCompatRequiredGroupInList {" + "  optional group locations (LIST) {" + "    repeated group array {" + "      required group element {" + "        required double latitude;" + "        required double longitude;" + "      }" + "    }" + "  }" + "}", new DirectWriter() {        @Override        public void write(RecordConsumer rc) {            rc.startMessage();            rc.startField("locations", 0);            rc.startGroup();                        rc.startField("array", 0);                                    rc.startGroup();            rc.startField("element", 0);            rc.startGroup();            rc.startField("latitude", 0);            rc.addDouble(90.0);            rc.endField("latitude", 0);            rc.startField("longitude", 1);            rc.addDouble(180.0);            rc.endField("longitude", 1);            rc.endGroup();            rc.endField("element", 0);                        rc.endGroup();                                    rc.startGroup();            rc.startField("element", 0);            rc.startGroup();            rc.startField("latitude", 0);            rc.addDouble(-90.0);            rc.endField("latitude", 0);            rc.startField("longitude", 1);            rc.addDouble(0.0);            rc.endField("longitude", 1);            rc.endGroup();            rc.endField("element", 0);                        rc.endGroup();                        rc.endField("array", 0);            rc.endGroup();            rc.endField("locations", 0);            rc.endMessage();        }    });    ListOfLocations expected = new ListOfLocations();    expected.addToLocations(new Location(90.0, 180.0));    expected.addToLocations(new Location(-90.0, 0.0));    assertReaderContains(reader(test, ListOfLocations.class), expected);}
81d5de5a9061acf3ac8a15a58be211196e4ac40d5ec37a0375883fc85458f64b
write
public void write(RecordConsumer rc)
{    rc.startMessage();    rc.startField("locations", 0);    rc.startGroup();        rc.startField("array", 0);            rc.startGroup();    rc.startField("element", 0);    rc.startGroup();    rc.startField("latitude", 0);    rc.addDouble(90.0);    rc.endField("latitude", 0);    rc.startField("longitude", 1);    rc.addDouble(180.0);    rc.endField("longitude", 1);    rc.endGroup();    rc.endField("element", 0);        rc.endGroup();            rc.startGroup();    rc.startField("element", 0);    rc.startGroup();    rc.startField("latitude", 0);    rc.addDouble(-90.0);    rc.endField("latitude", 0);    rc.startField("longitude", 1);    rc.addDouble(0.0);    rc.endField("longitude", 1);    rc.endGroup();    rc.endField("element", 0);        rc.endGroup();        rc.endField("array", 0);    rc.endGroup();    rc.endField("locations", 0);    rc.endMessage();}
9a2a5458406b514c2e60fc76cb763e411078c178f20a615a91d139e9fe114748
testAvroCompatListInList
public void testAvroCompatListInList() throws Exception
{    Path test = writeDirect("message AvroCompatListInList {" + "  optional group listOfLists (LIST) {" + "    repeated group array (LIST) {" + "      repeated int32 array;" + "    }" + "  }" + "}", new DirectWriter() {        @Override        public void write(RecordConsumer rc) {            rc.startMessage();            rc.startField("locations", 0);            rc.startGroup();                        rc.startField("array", 0);            rc.startGroup();                        rc.startField("array", 0);                        rc.addInteger(34);            rc.addInteger(35);            rc.addInteger(36);                        rc.endField("array", 0);            rc.endGroup();                        rc.startGroup();            rc.endGroup();            rc.startGroup();                        rc.startField("array", 0);                        rc.addInteger(32);            rc.addInteger(33);            rc.addInteger(34);                        rc.endField("array", 0);            rc.endGroup();                        rc.endField("array", 0);            rc.endGroup();            rc.endField("locations", 0);            rc.endMessage();        }    });    ListOfLists expected = new ListOfLists();    expected.addToListOfLists(Arrays.asList(34, 35, 36));    expected.addToListOfLists(Arrays.<Integer>asList());    expected.addToListOfLists(Arrays.asList(32, 33, 34));        assertReaderContains(reader(test, ListOfLists.class), expected);}
81d5de5a9061acf3ac8a15a58be211196e4ac40d5ec37a0375883fc85458f64b
write
public void write(RecordConsumer rc)
{    rc.startMessage();    rc.startField("locations", 0);    rc.startGroup();        rc.startField("array", 0);    rc.startGroup();        rc.startField("array", 0);        rc.addInteger(34);    rc.addInteger(35);    rc.addInteger(36);        rc.endField("array", 0);    rc.endGroup();        rc.startGroup();    rc.endGroup();    rc.startGroup();        rc.startField("array", 0);        rc.addInteger(32);    rc.addInteger(33);    rc.addInteger(34);        rc.endField("array", 0);    rc.endGroup();        rc.endField("array", 0);    rc.endGroup();    rc.endField("locations", 0);    rc.endMessage();}
0964274048380c008e2f618d79188c8d77ab9f73a6c6d4e172e5d2cfac1ef6a9
testThriftCompatListInList
public void testThriftCompatListInList() throws Exception
{    Path test = writeDirect("message ThriftCompatListInList {" + "  optional group listOfLists (LIST) {" + "    repeated group listOfLists_tuple (LIST) {" + "      repeated int32 listOfLists_tuple_tuple;" + "    }" + "  }" + "}", new DirectWriter() {        @Override        public void write(RecordConsumer rc) {            rc.startMessage();            rc.startField("locations", 0);            rc.startGroup();                        rc.startField("listOfLists_tuple", 0);            rc.startGroup();                        rc.startField("listOfLists_tuple_tuple", 0);                        rc.addInteger(34);            rc.addInteger(35);            rc.addInteger(36);                        rc.endField("listOfLists_tuple_tuple", 0);            rc.endGroup();                        rc.startGroup();            rc.endGroup();            rc.startGroup();                        rc.startField("listOfLists_tuple_tuple", 0);                        rc.addInteger(32);            rc.addInteger(33);            rc.addInteger(34);                        rc.endField("listOfLists_tuple_tuple", 0);            rc.endGroup();                        rc.endField("listOfLists_tuple", 0);            rc.endGroup();            rc.endField("locations", 0);            rc.endMessage();        }    });    ListOfLists expected = new ListOfLists();    expected.addToListOfLists(Arrays.asList(34, 35, 36));    expected.addToListOfLists(Arrays.<Integer>asList());    expected.addToListOfLists(Arrays.asList(32, 33, 34));        assertReaderContains(reader(test, ListOfLists.class), expected);}
81d5de5a9061acf3ac8a15a58be211196e4ac40d5ec37a0375883fc85458f64b
write
public void write(RecordConsumer rc)
{    rc.startMessage();    rc.startField("locations", 0);    rc.startGroup();        rc.startField("listOfLists_tuple", 0);    rc.startGroup();        rc.startField("listOfLists_tuple_tuple", 0);        rc.addInteger(34);    rc.addInteger(35);    rc.addInteger(36);        rc.endField("listOfLists_tuple_tuple", 0);    rc.endGroup();        rc.startGroup();    rc.endGroup();    rc.startGroup();        rc.startField("listOfLists_tuple_tuple", 0);        rc.addInteger(32);    rc.addInteger(33);    rc.addInteger(34);        rc.endField("listOfLists_tuple_tuple", 0);    rc.endGroup();        rc.endField("listOfLists_tuple", 0);    rc.endGroup();    rc.endField("locations", 0);    rc.endMessage();}
19066cca87c525c182aae4c48b303a6994e02ba40e3e1216b239894d0cf9b9e3
testOldThriftCompatRequiredGroupInList
public void testOldThriftCompatRequiredGroupInList() throws Exception
{    Path test = writeDirect("message OldThriftCompatRequiredGroupInList {" + "  optional group locations (LIST) {" + "    repeated group locations_tuple {" + "      required group element {" + "        required double latitude;" + "        required double longitude;" + "      }" + "    }" + "  }" + "}", new DirectWriter() {        @Override        public void write(RecordConsumer rc) {            rc.startMessage();            rc.startField("locations", 0);            rc.startGroup();                        rc.startField("locations_tuple", 0);                                    rc.startGroup();            rc.startField("element", 0);            rc.startGroup();            rc.startField("latitude", 0);            rc.addDouble(0.0);            rc.endField("latitude", 0);            rc.startField("longitude", 1);            rc.addDouble(180.0);            rc.endField("longitude", 1);            rc.endGroup();            rc.endField("element", 0);                        rc.endGroup();                                    rc.startGroup();            rc.startField("element", 0);            rc.startGroup();            rc.startField("latitude", 0);            rc.addDouble(0.0);            rc.endField("latitude", 0);            rc.startField("longitude", 1);            rc.addDouble(0.0);            rc.endField("longitude", 1);            rc.endGroup();            rc.endField("element", 0);                        rc.endGroup();                        rc.endField("locations_tuple", 0);            rc.endGroup();            rc.endField("locations", 0);            rc.endMessage();        }    });    ListOfLocations expected = new ListOfLocations();    expected.addToLocations(new Location(0.0, 180.0));    expected.addToLocations(new Location(0.0, 0.0));    assertReaderContains(reader(test, ListOfLocations.class), expected);}
81d5de5a9061acf3ac8a15a58be211196e4ac40d5ec37a0375883fc85458f64b
write
public void write(RecordConsumer rc)
{    rc.startMessage();    rc.startField("locations", 0);    rc.startGroup();        rc.startField("locations_tuple", 0);            rc.startGroup();    rc.startField("element", 0);    rc.startGroup();    rc.startField("latitude", 0);    rc.addDouble(0.0);    rc.endField("latitude", 0);    rc.startField("longitude", 1);    rc.addDouble(180.0);    rc.endField("longitude", 1);    rc.endGroup();    rc.endField("element", 0);        rc.endGroup();            rc.startGroup();    rc.startField("element", 0);    rc.startGroup();    rc.startField("latitude", 0);    rc.addDouble(0.0);    rc.endField("latitude", 0);    rc.startField("longitude", 1);    rc.addDouble(0.0);    rc.endField("longitude", 1);    rc.endGroup();    rc.endField("element", 0);        rc.endGroup();        rc.endField("locations_tuple", 0);    rc.endGroup();    rc.endField("locations", 0);    rc.endMessage();}
612ce79043fe8ba47d76da6c8fc1404597b5539dbd50d6da2fb560695125777a
testHiveCompatOptionalGroupInList
public void testHiveCompatOptionalGroupInList() throws Exception
{    Path test = writeDirect("message HiveCompatOptionalGroupInList {" + "  optional group locations (LIST) {" + "    repeated group bag {" + "      optional group element {" + "        required double latitude;" + "        required double longitude;" + "      }" + "    }" + "  }" + "}", new DirectWriter() {        @Override        public void write(RecordConsumer rc) {            rc.startMessage();            rc.startField("locations", 0);            rc.startGroup();                        rc.startField("bag", 0);                                    rc.startGroup();            rc.startField("element", 0);            rc.startGroup();            rc.startField("latitude", 0);            rc.addDouble(0.0);            rc.endField("latitude", 0);            rc.startField("longitude", 1);            rc.addDouble(180.0);            rc.endField("longitude", 1);            rc.endGroup();            rc.endField("element", 0);                        rc.endGroup();                                    rc.startGroup();            rc.startField("element", 0);            rc.startGroup();            rc.startField("latitude", 0);            rc.addDouble(0.0);            rc.endField("latitude", 0);            rc.startField("longitude", 1);            rc.addDouble(0.0);            rc.endField("longitude", 1);            rc.endGroup();            rc.endField("element", 0);                        rc.endGroup();                        rc.endField("bag", 0);            rc.endGroup();            rc.endField("locations", 0);            rc.endMessage();        }    });    ListOfLocations expected = new ListOfLocations();    expected.addToLocations(new Location(0.0, 180.0));    expected.addToLocations(new Location(0.0, 0.0));    try {        assertReaderContains(reader(test, ListOfLocations.class), expected);        fail("Should fail: locations are optional and not ignored");    } catch (RuntimeException e) {                assertTrue(e.getCause().getCause().getMessage().contains("locations"));    }    assertReaderContains(readerIgnoreNulls(test, ListOfLocations.class), expected);}
81d5de5a9061acf3ac8a15a58be211196e4ac40d5ec37a0375883fc85458f64b
write
public void write(RecordConsumer rc)
{    rc.startMessage();    rc.startField("locations", 0);    rc.startGroup();        rc.startField("bag", 0);            rc.startGroup();    rc.startField("element", 0);    rc.startGroup();    rc.startField("latitude", 0);    rc.addDouble(0.0);    rc.endField("latitude", 0);    rc.startField("longitude", 1);    rc.addDouble(180.0);    rc.endField("longitude", 1);    rc.endGroup();    rc.endField("element", 0);        rc.endGroup();            rc.startGroup();    rc.startField("element", 0);    rc.startGroup();    rc.startField("latitude", 0);    rc.addDouble(0.0);    rc.endField("latitude", 0);    rc.startField("longitude", 1);    rc.addDouble(0.0);    rc.endField("longitude", 1);    rc.endGroup();    rc.endField("element", 0);        rc.endGroup();        rc.endField("bag", 0);    rc.endGroup();    rc.endField("locations", 0);    rc.endMessage();}
921af59ae82a9b4d158bb9b9bb2ce4aa2cf8da9ac7e8ae81a8af74fd73419387
reader
public ParquetReader<T> reader(Path file, Class<T> thriftClass) throws IOException
{    return ThriftParquetReader.<T>build(file).withThriftClass(thriftClass).build();}
f34f7cfaf5d4663a531aa6b9bdde884cc10d321d2d6300d57288c094db560405
readerIgnoreNulls
public ParquetReader<T> readerIgnoreNulls(Path file, Class<T> thriftClass) throws IOException
{    Configuration conf = new Configuration();    conf.setBoolean(ThriftRecordConverter.IGNORE_NULL_LIST_ELEMENTS, true);    return ThriftParquetReader.<T>build(file).withThriftClass(thriftClass).withConf(conf).build();}
581d58c0689fcc768329b96325bbf276d85eb27119dd730b201e7deffc337ef7
assertReaderContains
public void assertReaderContains(ParquetReader<T> reader, T... expected) throws IOException
{    T record;    List<T> actual = Lists.newArrayList();    while ((record = reader.read()) != null) {        actual.add(record);    }    Assert.assertEquals("Should match exepected records", Lists.newArrayList(expected), actual);}
6f1fac8f77908be307c1d654574dd560a9d461440756b3609eda626d687e093d
testBinary
public void testBinary() throws IOException
{    StringAndBinary expected = new StringAndBinary("test", ByteBuffer.wrap(new byte[] { -123, 20, 33 }));    File temp = tempDir.newFile(UUID.randomUUID().toString());    temp.deleteOnExit();    temp.delete();    Path path = new Path(temp.getPath());    ThriftParquetWriter<StringAndBinary> writer = new ThriftParquetWriter<StringAndBinary>(path, StringAndBinary.class, CompressionCodecName.SNAPPY);    writer.write(expected);    writer.close();    ParquetReader<StringAndBinary> reader = ThriftParquetReader.<StringAndBinary>build(path).withThriftClass(StringAndBinary.class).build();    StringAndBinary record = reader.read();    reader.close();    assertSchema(ParquetFileReader.readFooter(new Configuration(), path));    assertEquals("Should match after serialization round trip", expected, record);}
ba8805be2f42afe1ffc87f7b56a429f1c3140d1e7763f22f76baac3ba7e6256f
assertSchema
private void assertSchema(ParquetMetadata parquetMetadata)
{    List<Type> fields = parquetMetadata.getFileMetaData().getSchema().getFields();    assertEquals(2, fields.size());    assertEquals(Types.required(PrimitiveType.PrimitiveTypeName.BINARY).as(OriginalType.UTF8).id(1).named("s"), fields.get(0));    assertEquals(Types.required(PrimitiveType.PrimitiveTypeName.BINARY).id(2).named("b"), fields.get(1));}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    records = new ArrayList<Object>();}
415ed3498bc5771df92b1684afb1a3c72761b7d5a750a565ac3f8e04a31e91fc
map
protected void map(Void key, T value, Context context) throws IOException, InterruptedException
{    records.add(value);}
b063db629582b69f077c62323e4c69964f572ee474dbc45be1a1d2a3a3cc4826
makeValid
public static StructWithAStructThatLooksLikeUnionV2 makeValid(int i)
{    AStructThatLooksLikeUnionV2 validUnion = new AStructThatLooksLikeUnionV2();    switch(i % 3) {        case 0:            validUnion.setALong(new ALong(17L));            break;        case 1:            validUnion.setANewBool(new ABool(false));            break;        case 2:            validUnion.setAString(new AString("bar"));            break;    }    return new StructWithAStructThatLooksLikeUnionV2("foo" + i, validUnion);}
b38a9f60e6551203da405c5c65dbaa74ad5922a5ec44dbce83f3127b4b40684f
makeExpectedValid
public static StructWithUnionV2 makeExpectedValid(int i)
{    UnionV2 validUnion = new UnionV2();    switch(i % 3) {        case 0:            validUnion.setALong(new ALong(17L));            break;        case 1:            validUnion.setANewBool(new ABool(false));            break;        case 2:            validUnion.setAString(new AString("bar"));            break;    }    return new StructWithUnionV2("foo" + i, validUnion);}
7684876f3c19c68324b2d384b50d2f47d588c8695150db5852b4ccbeb1b7f39d
makeInvalid
public static StructWithAStructThatLooksLikeUnionV2 makeInvalid(int i)
{    AStructThatLooksLikeUnionV2 invalid = new AStructThatLooksLikeUnionV2();    if (i % 2 == 0) {                invalid.setALong(new ALong(18l));        invalid.setANewBool(new ABool(false));    } else {        }    return new StructWithAStructThatLooksLikeUnionV2("foo" + i, invalid);}
e99b0823b0715fd7c35beda191af1c089ef0e713cd002d303180978c7772baad
setupJob
protected void setupJob(Job job, Path path) throws Exception
{    job.setInputFormatClass(ParquetThriftInputFormat.class);    ParquetThriftInputFormat.setInputPaths(job, path);    ParquetThriftInputFormat.setThriftClass(job.getConfiguration(), StructWithUnionV2.class);    job.setMapperClass(ReadMapper.class);    job.setNumReduceTasks(0);    job.setOutputFormatClass(NullOutputFormat.class);}
e52d948da0ee582f97926ad06c69e0eba81f41e74126e8e37efbb95425fe8c6a
assertEqualsExcepted
protected void assertEqualsExcepted(List<StructWithUnionV2> expected, List<Object> found) throws Exception
{    assertEquals(expected, found);}
19a028e3714840b5d823ac1371f062051ff5c5849f52c36038b57f45dbd3e778
writeFileWithCorruptRecords
private Path writeFileWithCorruptRecords(int numCorrupt, List<StructWithUnionV2> collectExpectedRecords) throws Exception
{                Path outputPath = new Path(new File(tempDir.getRoot(), "corrupt_out").getAbsolutePath());    ParquetWriter<StructWithAStructThatLooksLikeUnionV2> writer = new ThriftParquetWriter<StructWithAStructThatLooksLikeUnionV2>(outputPath, StructWithAStructThatLooksLikeUnionV2.class, CompressionCodecName.UNCOMPRESSED);    int numRecords = 0;    for (int i = 0; i < 100; i++) {        StructWithAStructThatLooksLikeUnionV2 valid = makeValid(numRecords);        StructWithUnionV2 expected = makeExpectedValid(numRecords);        numRecords++;        collectExpectedRecords.add(expected);        writer.write(valid);    }    for (int i = 0; i < numCorrupt; i++) {        writer.write(makeInvalid(numRecords++));    }    for (int i = 0; i < 100; i++) {        StructWithAStructThatLooksLikeUnionV2 valid = makeValid(numRecords);        StructWithUnionV2 expected = makeExpectedValid(numRecords);        numRecords++;        collectExpectedRecords.add(expected);        writer.write(valid);    }    writer.close();    return outputPath;}
79c31563123c4cd89217821cc20979d8c1a8e11fc02f2f1e97e7feafcb405ba5
readFile
private void readFile(Path path, Configuration conf, String name) throws Exception
{    Job job = new Job(conf, name);    setupJob(job, path);    waitForJob(job);}
383a94d3fcb9fae63f0f6ad748ec7b5a0c972d9669860edb6236d11e31e12379
testDefaultsToNoTolerance
public void testDefaultsToNoTolerance() throws Exception
{    ArrayList<StructWithUnionV2> expected = new ArrayList<StructWithUnionV2>();    try {        readFile(writeFileWithCorruptRecords(1, expected), new Configuration(), "testDefaultsToNoTolerance");        fail("This should throw");    } catch (RuntimeException e) {                assertEquals(100, ReadMapper.records.size());        assertEqualsExcepted(expected.subList(0, 100), ReadMapper.records);    }}
5acc7154ebbb71e74944c11dbcf5d465795f9ff35dbeb8a3506dc47d45900f6c
testCanTolerateBadRecords
public void testCanTolerateBadRecords() throws Exception
{    Configuration conf = new Configuration();    conf.setFloat(UnmaterializableRecordCounter.BAD_RECORD_THRESHOLD_CONF_KEY, 0.1f);    List<StructWithUnionV2> expected = new ArrayList<StructWithUnionV2>();    readFile(writeFileWithCorruptRecords(4, expected), conf, "testCanTolerateBadRecords");    assertEquals(200, ReadMapper.records.size());    assertEqualsExcepted(expected, ReadMapper.records);}
c83d274cfdd37be39ccaaee629c97807192a077870aa701a537dd84ce0e55e8f
testThrowsWhenTooManyBadRecords
public void testThrowsWhenTooManyBadRecords() throws Exception
{    Configuration conf = new Configuration();    conf.setFloat(UnmaterializableRecordCounter.BAD_RECORD_THRESHOLD_CONF_KEY, 0.1f);    ArrayList<StructWithUnionV2> expected = new ArrayList<StructWithUnionV2>();    try {        readFile(writeFileWithCorruptRecords(300, expected), conf, "testThrowsWhenTooManyBadRecords");        fail("This should throw");    } catch (RuntimeException e) {                assertEquals(100, ReadMapper.records.size());        assertEqualsExcepted(expected.subList(0, 100), ReadMapper.records);    }}
a35efc0bcaa5afd98ce35e19fe920b489a650d301906bebb0b55a50a3ef5e245
nextAddressbook
public static AddressBook nextAddressbook(int i)
{    final ArrayList<Person> persons = new ArrayList<Person>();    for (int j = 0; j < i % 3; j++) {        final ArrayList<PhoneNumber> phones = new ArrayList<PhoneNumber>();        for (int k = 0; k < i % 4; k++) {            phones.add(new PhoneNumber("12345" + i));        }        persons.add(new Person(new Name("John" + i, "Roberts"), i, "John@example.com" + i, phones));    }    AddressBook a = new AddressBook(persons);    return a;}
de65de0d7956c9fb22fdc5be16b641b5c132312fbb43e1a9ead67b5d39df18c4
run
public void run(org.apache.hadoop.mapreduce.Mapper<LongWritable, Text, Void, AddressBook>.Context context) throws IOException, InterruptedException
{    for (int i = 0; i < 10; i++) {        AddressBook a = TestInputOutputFormat.nextAddressbook(i);        context.write(null, a);    }}
9b745da81332f0aefc46cee05823a8a426bcbb05869be3f591f1ad408891504b
map
protected void map(Void key, AddressBook value, Mapper<Void, Group, LongWritable, Text>.Context context) throws IOException, InterruptedException
{    context.write(null, new Text(value.toString()));}
c2c75b5eb5762dda20687d84e7565d4cf3b9de60742e0694a6cffba3f16ea18a
testReadWrite
public void testReadWrite() throws Exception
{    final Configuration conf = new Configuration();    final Path inputPath = new Path("src/test/java/org/apache/parquet/hadoop/thrift/TestInputOutputFormat.java");    final Path parquetPath = new Path("target/test/thrift/TestInputOutputFormat/parquet");    final Path outputPath = new Path("target/test/thrift/TestInputOutputFormat/out");    final FileSystem fileSystem = parquetPath.getFileSystem(conf);    fileSystem.delete(parquetPath, true);    fileSystem.delete(outputPath, true);    {        final Job job = new Job(conf, "write");                TextInputFormat.addInputPath(job, inputPath);        job.setInputFormatClass(TextInputFormat.class);        job.setMapperClass(TestInputOutputFormat.MyMapper.class);        job.setNumReduceTasks(0);        job.setOutputFormatClass(ParquetThriftOutputFormat.class);        ParquetThriftOutputFormat.setCompression(job, CompressionCodecName.GZIP);        ParquetThriftOutputFormat.setOutputPath(job, parquetPath);        ParquetThriftOutputFormat.setThriftClass(job, AddressBook.class);        waitForJob(job);    }    {        final Job job = new Job(conf, "read");        job.setInputFormatClass(ParquetThriftInputFormat.class);        ParquetThriftInputFormat.setInputPaths(job, parquetPath);        job.setMapperClass(TestInputOutputFormat.MyMapper2.class);        job.setNumReduceTasks(0);        job.setOutputFormatClass(TextOutputFormat.class);        TextOutputFormat.setOutputPath(job, outputPath);        waitForJob(job);    }    final BufferedReader out = new BufferedReader(new FileReader(new File(outputPath.toString(), "part-m-00000")));    String lineOut = null;    int lineNumber = 0;    while ((lineOut = out.readLine()) != null) {        lineOut = lineOut.substring(lineOut.indexOf("\t") + 1);        AddressBook a = nextAddressbook(lineNumber);        assertEquals("line " + lineNumber, a.toString(), lineOut);        ++lineNumber;    }    assertNull("line " + lineNumber, out.readLine());    out.close();}
4930575071fe136835de86f037c36d5dd64e7f51dcf9f630f25e324322de0ee8
map
protected void map(LongWritable key, Text value, org.apache.hadoop.mapreduce.Mapper<LongWritable, Text, Void, StructV1>.Context context) throws IOException, InterruptedException
{    context.write(null, new StructV1(value.toString() + 1));}
f0c8936a2902de4a4b8a80aa7069943139fc6d459a57586db0b096ffc7b965a2
map
protected void map(LongWritable key, Text value, org.apache.hadoop.mapreduce.Mapper<LongWritable, Text, Void, StructV2>.Context context) throws IOException, InterruptedException
{    final StructV2 s = new StructV2(value.toString() + 2);    s.setAge("undetermined");    context.write(null, s);}
a78d285eb8f2ed260cf048fcc9bbd0fef9f7f75ce8c8befdb1de848175880226
map
protected void map(LongWritable key, Text value, org.apache.hadoop.mapreduce.Mapper<LongWritable, Text, Void, StructV3>.Context context) throws IOException, InterruptedException
{    final StructV3 s = new StructV3(value.toString() + 3);    s.setAge("average");    s.setGender("unavailable");    context.write(null, s);}
6346ca07d156fda75d7ac9a1487b154290e8855d36e5dfe7dea0cfc7c773d7da
map
protected void map(LongWritable key, StructV3 value, org.apache.hadoop.mapreduce.Mapper<LongWritable, Text, Void, Text>.Context context) throws IOException, InterruptedException
{    context.write(null, new Text(value.toString()));}
8d0afd848123f90889fd1ed2998206698a9b0d2d93f6b0cd48f38c04def6c67c
testSchemaEvolution
public void testSchemaEvolution() throws Exception
{    final Configuration conf = new Configuration();    final Path inputPath = new Path("target/test/thrift/schema_evolution/in");    final Path parquetPath = new Path("target/test/thrift/schema_evolution/parquet");    final Path outputPath = new Path("target/test/thrift/schema_evolution/out");    final FileSystem fileSystem = parquetPath.getFileSystem(conf);    fileSystem.delete(inputPath, true);    final FSDataOutputStream in = fileSystem.create(inputPath);    in.writeUTF("Alice\nBob\nCharles\n");    in.close();    fileSystem.delete(parquetPath, true);    fileSystem.delete(outputPath, true);    {        write(conf, inputPath, new Path(parquetPath, "V1"), TestInputOutputFormat.SchemaEvolutionMapper1.class, StructV1.class);        write(conf, inputPath, new Path(parquetPath, "V2"), TestInputOutputFormat.SchemaEvolutionMapper2.class, StructV2.class);        write(conf, inputPath, new Path(parquetPath, "V3"), TestInputOutputFormat.SchemaEvolutionMapper3.class, StructV3.class);    }    {        final Job job = new Job(conf, "read");        job.setInputFormatClass(ParquetThriftInputFormat.class);        ParquetThriftInputFormat.setInputPaths(job, new Path(parquetPath, "*"));        ParquetThriftInputFormat.setThriftClass(job.getConfiguration(), StructV3.class);        job.setMapperClass(TestInputOutputFormat.SchemaEvolutionReadMapper.class);        job.setNumReduceTasks(0);        job.setOutputFormatClass(TextOutputFormat.class);        TextOutputFormat.setOutputPath(job, outputPath);        waitForJob(job);    }    read(outputPath + "/part-m-00000", 3);    read(outputPath + "/part-m-00001", 3);    read(outputPath + "/part-m-00002", 3);}
18c2477b0fc95165977c54e94b910a5adf545eaea11853e3538eaaf49be71fa7
read
private void read(String outputPath, int expected) throws FileNotFoundException, IOException
{    final BufferedReader out = new BufferedReader(new FileReader(new File(outputPath.toString())));    String lineOut = null;    int lineNumber = 0;    while ((lineOut = out.readLine()) != null) {        lineOut = lineOut.substring(lineOut.indexOf("\t") + 1);        System.out.println(lineOut);        ++lineNumber;    }    out.close();    Assert.assertEquals(expected, lineNumber);}
2477582c81e0d941132972f0fc4544d03e42c250cc877f2aea29adaaf73a48ff
write
private void write(final Configuration conf, final Path inputPath, final Path parquetPath, Class<? extends Mapper> mapperClass, Class<? extends TBase<?, ?>> outputClass) throws IOException, Exception
{    final Job job = new Job(conf, "write");        TextInputFormat.addInputPath(job, inputPath);    job.setInputFormatClass(TextInputFormat.class);    job.setMapperClass(mapperClass);    job.setNumReduceTasks(0);    job.setOutputFormatClass(ParquetThriftOutputFormat.class);    ParquetThriftOutputFormat.setCompression(job, CompressionCodecName.GZIP);    ParquetThriftOutputFormat.setOutputPath(job, parquetPath);    ParquetThriftOutputFormat.setThriftClass(job, outputClass);    waitForJob(job);}
1f7d9758df9b3e680cca31e9f6e91e70d834fd076bae25f0cb8be2ef13b5feaf
waitForJob
public static void waitForJob(Job job) throws Exception
{    job.submit();    while (!job.isComplete()) {        LOG.debug("waiting for job {}", job.getJobName());        sleep(100);    }    LOG.info("status for job {}: {}", job.getJobName(), (job.isSuccessful() ? "SUCCESS" : "FAILURE"));    if (!job.isSuccessful()) {        throw new RuntimeException("job failed " + job.getJobName());    }}
f383000cd3169e9962e2a656a0a5d6d7bcdceb81b785f3c728dc430b149ab447
testThriftOptionalFieldsWithReadProjectionUsingParquetSchema
public void testThriftOptionalFieldsWithReadProjectionUsingParquetSchema() throws Exception
{        Configuration conf = new Configuration();    final String readProjectionSchema = "message AddressBook {\n" + "  optional group persons {\n" + "    repeated group persons_tuple {\n" + "      required group name {\n" + "        optional binary first_name;\n" + "        optional binary last_name;\n" + "      }\n" + "      optional int32 id;\n" + "    }\n" + "  }\n" + "}";    conf.set(ReadSupport.PARQUET_READ_SCHEMA, readProjectionSchema);    TBase toWrite = new AddressBook(Arrays.asList(new Person(new Name("Bob", "Roberts"), 0, "bob.roberts@example.com", Arrays.asList(new PhoneNumber("1234567890")))));    TBase toRead = new AddressBook(Arrays.asList(new Person(new Name("Bob", "Roberts"), 0, null, null)));    shouldDoProjection(conf, toWrite, toRead, AddressBook.class);}
075cb5413ade727e21a85123f40290d7fbf220dc416565216e3274555c309e1e
testPullingInRequiredStructWithFilter
public void testPullingInRequiredStructWithFilter() throws Exception
{    final String projectionFilterDesc = "persons/{id};persons/email";    TBase toWrite = new AddressBook(Arrays.asList(new Person(new Name("Bob", "Roberts"), 0, "bob.roberts@example.com", Arrays.asList(new PhoneNumber("1234567890")))));            TBase toRead = new AddressBook(Arrays.asList(new Person(new Name("", ""), 0, "bob.roberts@example.com", null)));    shouldDoProjectionWithThriftColumnFilter(projectionFilterDesc, toWrite, toRead, AddressBook.class);}
4e52905d3d2a412d87b2dffac6e7e7093fc25c135282433dbb639bcb1f0deffe
testReorderdOptionalFields
public void testReorderdOptionalFields() throws Exception
{    final String projectionFilter = "**";    StructWithReorderedOptionalFields toWrite = new StructWithReorderedOptionalFields();    toWrite.setFieldOne(1);    toWrite.setFieldTwo(2);    toWrite.setFieldThree(3);    shouldDoProjectionWithThriftColumnFilter(projectionFilter, toWrite, toWrite, StructWithReorderedOptionalFields.class);}
86eceaac8d868ffe8f6d23bd6af4b395aebfaa0c71b272b3abee205a9630c7f2
testProjectOutOptionalFields
public void testProjectOutOptionalFields() throws Exception
{    final String projectionFilterDesc = "persons/name/*";    TBase toWrite = new AddressBook(Arrays.asList(new Person(new Name("Bob", "Roberts"), 0, "bob.roberts@example.com", Arrays.asList(new PhoneNumber("1234567890")))));        TBase toRead = new AddressBook(Arrays.asList(new Person(new Name("Bob", "Roberts"), 0, null, null)));    shouldDoProjectionWithThriftColumnFilter(projectionFilterDesc, toWrite, toRead, AddressBook.class);}
25d74156497ef0a6399aab6a7be303bd4cc585cb94349e84804c1d53e4dc23fb
testPullInRequiredMaps
public void testPullInRequiredMaps() throws Exception
{    String filter = "name";    Map<String, String> mapValue = new HashMap<String, String>();    mapValue.put("a", "1");    mapValue.put("b", "2");    RequiredMapFixture toWrite = new RequiredMapFixture(mapValue);    toWrite.setName("testName");    RequiredMapFixture toRead = new RequiredMapFixture(new HashMap<String, String>());    toRead.setName("testName");    shouldDoProjectionWithThriftColumnFilter(filter, toWrite, toRead, RequiredMapFixture.class);}
fca9aa8e0504d44020d55c1b4e5eece2a3766024529358121ac32056b4598d8d
testDropMapValuePrimitive
public void testDropMapValuePrimitive() throws Exception
{    String filter = "mavalue/key";    Map<String, String> mapValue = new HashMap<String, String>();    mapValue.put("a", "1");    mapValue.put("b", "2");    RequiredMapFixture toWrite = new RequiredMapFixture(mapValue);    toWrite.setName("testName");            Map<String, String> readValue = new HashMap<String, String>();    readValue.put("a", "1");    readValue.put("b", "2");    RequiredMapFixture toRead = new RequiredMapFixture(readValue);    shouldDoProjectionWithThriftColumnFilter(filter, toWrite, toRead, RequiredMapFixture.class);}
35551e2d7024a1044910ca95a538b0fac52ee214db43d8547c939ff0d48a11a9
makeStructV4WithExtracStructField
private StructV4WithExtracStructField makeStructV4WithExtracStructField(String id)
{    StructV4WithExtracStructField sv4 = new StructV4WithExtracStructField();    StructV3 sv3 = new StructV3();    sv3.setAge("age " + id);    sv3.setGender("gender" + id);    sv3.setName("inner name " + id);    sv4.setAge("outer age " + id);    sv4.setAddedStruct(sv3);    sv4.setGender("outer gender " + id);    sv4.setName("outer name " + id);    return sv4;}
c7bd717158e68eb47c630d1b449a0899f30f65e864456c7d19f2714dcab44805
testDropMapValueStruct
public void testDropMapValueStruct() throws Exception
{    String filter = "reqMap/key";    Map<String, StructV4WithExtracStructField> mapValue = new HashMap<String, StructV4WithExtracStructField>();    StructV4WithExtracStructField v1 = makeStructV4WithExtracStructField("1");    StructV4WithExtracStructField v2 = makeStructV4WithExtracStructField("2");    mapValue.put("key 1", v1);    mapValue.put("key 2", v2);    MapWithStructValue toWrite = new MapWithStructValue(mapValue);        HashMap<String, StructV4WithExtracStructField> readValue = new HashMap<String, StructV4WithExtracStructField>();    readValue.put("key 1", new StructV4WithExtracStructField("outer name 1"));    readValue.put("key 2", new StructV4WithExtracStructField("outer name 2"));    MapWithStructValue toRead = new MapWithStructValue(readValue);    shouldDoProjectionWithThriftColumnFilter(filter, toWrite, toRead, MapWithStructValue.class);}
e1708aa515f9527e51211ab9afa8e69d04c924c02510636ff4b109a494328931
testDropMapValueNestedPrim
public void testDropMapValueNestedPrim() throws Exception
{    String filter = "reqMap/key";    Map<String, Map<String, String>> mapValue = new HashMap<String, Map<String, String>>();    Map<String, String> innerValue1 = new HashMap<String, String>();    innerValue1.put("inner key (1, 1)", "inner (1, 1)");    innerValue1.put("inner key (1, 2)", "inner (1, 2)");    Map<String, String> innerValue2 = new HashMap<String, String>();    innerValue2.put("inner key (2, 1)", "inner (2, 1)");    innerValue2.put("inner key (2, 2)", "inner (2, 2)");    mapValue.put("outer key 1", innerValue1);    mapValue.put("outer key 2", innerValue2);    MapWithPrimMapValue toWrite = new MapWithPrimMapValue(mapValue);    Map<String, Map<String, String>> expected = new HashMap<String, Map<String, String>>();    Map<String, String> expectedInnerValue1 = new HashMap<String, String>();    expectedInnerValue1.put("inner key (1, 1)", "inner (1, 1)");    expectedInnerValue1.put("inner key (1, 2)", "inner (1, 2)");    Map<String, String> expectedInnerValue2 = new HashMap<String, String>();    expectedInnerValue2.put("inner key (2, 1)", "inner (2, 1)");    expectedInnerValue2.put("inner key (2, 2)", "inner (2, 2)");    expected.put("outer key 1", expectedInnerValue1);    expected.put("outer key 2", expectedInnerValue2);    MapWithPrimMapValue toRead = new MapWithPrimMapValue(expected);    shouldDoProjectionWithThriftColumnFilter(filter, toWrite, toRead, MapWithPrimMapValue.class);}
a398d8f87e2fc742ecd75ec394450daf94ba6f456844f8b8d441e62e2df879d6
testDropMapValueNestedStruct
public void testDropMapValueNestedStruct() throws Exception
{    String filter = "reqMap/key";    Map<String, Map<String, StructV4WithExtracStructField>> mapValue = new HashMap<String, Map<String, StructV4WithExtracStructField>>();    Map<String, StructV4WithExtracStructField> innerValue1 = new HashMap<String, StructV4WithExtracStructField>();    innerValue1.put("inner key (1, 1)", makeStructV4WithExtracStructField("inner (1, 1)"));    innerValue1.put("inner key (1, 2)", makeStructV4WithExtracStructField("inner (1, 2)"));    Map<String, StructV4WithExtracStructField> innerValue2 = new HashMap<String, StructV4WithExtracStructField>();    innerValue2.put("inner key (2, 1)", makeStructV4WithExtracStructField("inner (2, 1)"));    innerValue2.put("inner key (2, 2)", makeStructV4WithExtracStructField("inner (2, 2)"));    mapValue.put("outer key 1", innerValue1);    mapValue.put("outer key 2", innerValue2);    MapWithStructMapValue toWrite = new MapWithStructMapValue(mapValue);    Map<String, Map<String, StructV4WithExtracStructField>> expected = new HashMap<String, Map<String, StructV4WithExtracStructField>>();    Map<String, StructV4WithExtracStructField> expectedInnerValue1 = new HashMap<String, StructV4WithExtracStructField>();    expectedInnerValue1.put("inner key (1, 1)", new StructV4WithExtracStructField("outer name inner (1, 1)"));    expectedInnerValue1.put("inner key (1, 2)", new StructV4WithExtracStructField("outer name inner (1, 2)"));    Map<String, StructV4WithExtracStructField> expectedInnerValue2 = new HashMap<String, StructV4WithExtracStructField>();    expectedInnerValue2.put("inner key (2, 1)", new StructV4WithExtracStructField("outer name inner (2, 1)"));    expectedInnerValue2.put("inner key (2, 2)", new StructV4WithExtracStructField("outer name inner (2, 2)"));    expected.put("outer key 1", expectedInnerValue1);    expected.put("outer key 2", expectedInnerValue2);    MapWithStructMapValue toRead = new MapWithStructMapValue(expected);    shouldDoProjectionWithThriftColumnFilter(filter, toWrite, toRead, MapWithStructMapValue.class);}
c347f3fab68d26adfa84075579aa972ce9db3083665cd392c8107dc71fd20bd6
testPullInRequiredLists
public void testPullInRequiredLists() throws Exception
{    String filter = "info";    RequiredListFixture toWrite = new RequiredListFixture(Arrays.asList(new org.apache.parquet.thrift.test.Name("first_name")));    toWrite.setInfo("test_info");    RequiredListFixture toRead = new RequiredListFixture(new ArrayList<org.apache.parquet.thrift.test.Name>());    toRead.setInfo("test_info");    shouldDoProjectionWithThriftColumnFilter(filter, toWrite, toRead, RequiredListFixture.class);}
085a37d4e89e500dc993dd60c7fbb9b200b123bc3e4021a58d9a0e226d71bc4f
testPullInRequiredSets
public void testPullInRequiredSets() throws Exception
{    String filter = "info";    RequiredSetFixture toWrite = new RequiredSetFixture(new HashSet<org.apache.parquet.thrift.test.Name>(Arrays.asList(new org.apache.parquet.thrift.test.Name("first_name"))));    toWrite.setInfo("test_info");    RequiredSetFixture toRead = new RequiredSetFixture(new HashSet<org.apache.parquet.thrift.test.Name>());    toRead.setInfo("test_info");    shouldDoProjectionWithThriftColumnFilter(filter, toWrite, toRead, RequiredSetFixture.class);}
60221730da072bc3e76988ed9453fbd15348a359e485349961b6ad45e22b4094
testPullInPrimitiveValues
public void testPullInPrimitiveValues() throws Exception
{    String filter = "info_string";    RequiredPrimitiveFixture toWrite = new RequiredPrimitiveFixture(true, (byte) 2, (short) 3, 4, (long) 5, (double) 6.0, "7");    toWrite.setInfo_string("it's info");    RequiredPrimitiveFixture toRead = new RequiredPrimitiveFixture(false, (byte) 0, (short) 0, 0, (long) 0, (double) 0.0, "");    toRead.setInfo_string("it's info");    shouldDoProjectionWithThriftColumnFilter(filter, toWrite, toRead, RequiredPrimitiveFixture.class);}
be4d36231878f9f4f47be92545a65414834b69d3056b6699e2ae44c6557afb80
shouldDoProjectionWithThriftColumnFilter
private void shouldDoProjectionWithThriftColumnFilter(String filterDesc, TBase toWrite, TBase toRead, Class<? extends TBase<?, ?>> thriftClass) throws Exception
{    Configuration conf = new Configuration();    conf.set(ThriftReadSupport.THRIFT_COLUMN_FILTER_KEY, filterDesc);    shouldDoProjection(conf, toWrite, toRead, thriftClass);}
48a96816c6218e488ee8c3431b7c11fa1dd17c97816bba53139cbe3b1ed23fed
shouldDoProjection
private void shouldDoProjection(Configuration conf, T recordToWrite, T exptectedReadResult, Class<? extends TBase<?, ?>> thriftClass) throws Exception
{    final Path parquetFile = new Path("target/test/TestParquetToThriftReadWriteAndProjection/file.parquet");    final FileSystem fs = parquetFile.getFileSystem(conf);    if (fs.exists(parquetFile)) {        fs.delete(parquetFile, true);    }        final TProtocolFactory protocolFactory = new TCompactProtocol.Factory();    final TaskAttemptID taskId = new TaskAttemptID("local", 0, true, 0, 0);    final ThriftToParquetFileWriter w = new ThriftToParquetFileWriter(parquetFile, ContextUtil.newTaskAttemptContext(conf, taskId), protocolFactory, thriftClass);    final ByteArrayOutputStream baos = new ByteArrayOutputStream();    final TProtocol protocol = protocolFactory.getProtocol(new TIOStreamTransport(baos));    recordToWrite.write(protocol);    w.write(new BytesWritable(baos.toByteArray()));    w.close();    final ParquetThriftInputFormat<T> parquetThriftInputFormat = new ParquetThriftInputFormat<T>();    final Job job = new Job(conf, "read");    job.setInputFormatClass(ParquetThriftInputFormat.class);    ParquetThriftInputFormat.setInputPaths(job, parquetFile);    final JobID jobID = new JobID("local", 1);    List<InputSplit> splits = parquetThriftInputFormat.getSplits(ContextUtil.newJobContext(ContextUtil.getConfiguration(job), jobID));    T readValue = null;    for (InputSplit split : splits) {        TaskAttemptContext taskAttemptContext = ContextUtil.newTaskAttemptContext(ContextUtil.getConfiguration(job), new TaskAttemptID(new TaskID(jobID, true, 1), 0));        final RecordReader<Void, T> reader = parquetThriftInputFormat.createRecordReader(split, taskAttemptContext);        reader.initialize(split, taskAttemptContext);        if (reader.nextKeyValue()) {            readValue = reader.getCurrentValue();            LOG.info("{}", readValue);        }    }    assertEquals(exptectedReadResult, readValue);}
ac0006b4933d909d29d9bb488dd7b9147a2ee5ad384bfdde119e0f45a7833ab4
testWriteFile
public void testWriteFile() throws IOException, InterruptedException, TException
{    final AddressBook a = new AddressBook(Arrays.asList(new Person(new Name("Bob", "Roberts"), 0, "bob.roberts@example.com", Arrays.asList(new PhoneNumber("1234567890")))));    final Path fileToCreate = createFile(a);    ParquetReader<Group> reader = createRecordReader(fileToCreate);    Group g = null;    int i = 0;    while ((g = reader.read()) != null) {        assertEquals(a.persons.size(), g.getFieldRepetitionCount("persons"));        assertEquals(a.persons.get(0).email, g.getGroup("persons", 0).getGroup(0, 0).getString("email", 0));                ++i;    }    assertEquals("read 1 record", 1, i);}
979c2058b46847f25a10f996b1a9d333adfef6b8bd7b678dca94463bba888267
testWriteStatistics
public void testWriteStatistics() throws Exception
{        IntStatistics intStatsSmall = new IntStatistics();    intStatsSmall.setMinMax(2, 100);    LongStatistics longStatsSmall = new LongStatistics();    longStatsSmall.setMinMax(-17l, 287L);    DoubleStatistics doubleStatsSmall = new DoubleStatistics();    doubleStatsSmall.setMinMax(-15.55d, 9.63d);    BinaryStatistics binaryStatsSmall = new BinaryStatistics();    binaryStatsSmall.setMinMax(Binary.fromString("as"), Binary.fromString("world"));    BooleanStatistics boolStats = new BooleanStatistics();    boolStats.setMinMax(false, true);        Path p = createFile(new RequiredPrimitiveFixture(false, (byte) 32, (short) 32, 2, 90l, -15.55d, "as"), new RequiredPrimitiveFixture(false, (byte) 100, (short) 100, 100, 287l, -9.0d, "world"), new RequiredPrimitiveFixture(true, (byte) 2, (short) 2, 9, -17l, 9.63d, "hello"));    final Configuration configuration = new Configuration();    configuration.setBoolean("parquet.strings.signed-min-max.enabled", true);    final FileSystem fs = p.getFileSystem(configuration);    FileStatus fileStatus = fs.getFileStatus(p);    ParquetMetadata footer = ParquetFileReader.readFooter(configuration, p);    for (BlockMetaData bmd : footer.getBlocks()) {        for (ColumnChunkMetaData cmd : bmd.getColumns()) {            switch(cmd.getType()) {                case INT32:                    TestUtils.assertStatsValuesEqual(intStatsSmall, cmd.getStatistics());                    break;                case INT64:                    TestUtils.assertStatsValuesEqual(longStatsSmall, cmd.getStatistics());                    break;                case DOUBLE:                    TestUtils.assertStatsValuesEqual(doubleStatsSmall, cmd.getStatistics());                    break;                case BOOLEAN:                    TestUtils.assertStatsValuesEqual(boolStats, cmd.getStatistics());                    break;                case BINARY:                                        if (cmd.getPath().toString() == "[test_string]")                        TestUtils.assertStatsValuesEqual(binaryStatsSmall, cmd.getStatistics());                    break;            }        }    }        IntStatistics intStatsLarge = new IntStatistics();    intStatsLarge.setMinMax(-Integer.MAX_VALUE, Integer.MAX_VALUE);    LongStatistics longStatsLarge = new LongStatistics();    longStatsLarge.setMinMax(-Long.MAX_VALUE, Long.MAX_VALUE);    DoubleStatistics doubleStatsLarge = new DoubleStatistics();    doubleStatsLarge.setMinMax(-Double.MAX_VALUE, Double.MAX_VALUE);    BinaryStatistics binaryStatsLarge = new BinaryStatistics();    binaryStatsLarge.setMinMax(Binary.fromString("some small string"), Binary.fromString("some very large string here to test in this function"));        Path p_large = createFile(new RequiredPrimitiveFixture(false, (byte) 2, (short) 32, -Integer.MAX_VALUE, -Long.MAX_VALUE, -Double.MAX_VALUE, "some small string"), new RequiredPrimitiveFixture(false, (byte) 100, (short) 100, Integer.MAX_VALUE, Long.MAX_VALUE, Double.MAX_VALUE, "some very large string here to test in this function"), new RequiredPrimitiveFixture(true, (byte) 2, (short) 2, 9, -17l, 9.63d, "hello"));        final Configuration configuration_large = new Configuration();    configuration.setBoolean("parquet.strings.signed-min-max.enabled", true);    final FileSystem fs_large = p_large.getFileSystem(configuration_large);    FileStatus fileStatus_large = fs_large.getFileStatus(p_large);    ParquetMetadata footer_large = ParquetFileReader.readFooter(configuration_large, p_large);    for (BlockMetaData bmd : footer_large.getBlocks()) {        for (ColumnChunkMetaData cmd : bmd.getColumns()) {            switch(cmd.getType()) {                case INT32:                                        if (cmd.getPath().toString() == "[test_i32]")                        TestUtils.assertStatsValuesEqual(intStatsLarge, cmd.getStatistics());                    break;                case INT64:                    TestUtils.assertStatsValuesEqual(longStatsLarge, cmd.getStatistics());                    break;                case DOUBLE:                    TestUtils.assertStatsValuesEqual(doubleStatsLarge, cmd.getStatistics());                    break;                case BOOLEAN:                    TestUtils.assertStatsValuesEqual(boolStats, cmd.getStatistics());                    break;                case BINARY:                                        if (cmd.getPath().toString() == "[test_string]")                        TestUtils.assertStatsValuesEqual(binaryStatsLarge, cmd.getStatistics());                    break;            }        }    }}
3dd1932c78c4aca365010a4f9cf3223e5692d63cc96b2f7a6b9f40f37be3d5b4
testWriteFileListOfMap
public void testWriteFileListOfMap() throws IOException, InterruptedException, TException
{    Map<String, String> map1 = new HashMap<String, String>();    map1.put("key11", "value11");    map1.put("key12", "value12");    Map<String, String> map2 = new HashMap<String, String>();    map2.put("key21", "value21");    final TestMapInList listMap = new TestMapInList("listmap", Arrays.asList(map1, map2));    final Path fileToCreate = createFile(listMap);    ParquetReader<Group> reader = createRecordReader(fileToCreate);    Group g = null;    while ((g = reader.read()) != null) {        assertEquals(listMap.names.size(), g.getGroup("names", 0).getFieldRepetitionCount("names_tuple"));        assertEquals(listMap.names.get(0).size(), g.getGroup("names", 0).getGroup("names_tuple", 0).getFieldRepetitionCount("map"));        assertEquals(listMap.names.get(1).size(), g.getGroup("names", 0).getGroup("names_tuple", 1).getFieldRepetitionCount("map"));    }}
ea5211a36fa8362748c3875ac343ba8fac7cf02961970744869ee199e62b9612
testWriteFileMapOfList
public void testWriteFileMapOfList() throws IOException, InterruptedException, TException
{    Map<String, List<String>> map = new HashMap<String, List<String>>();    map.put("key", Arrays.asList("val1", "val2"));    final TestListInMap mapList = new TestListInMap("maplist", map);    final Path fileToCreate = createFile(mapList);    ParquetReader<Group> reader = createRecordReader(fileToCreate);    Group g = null;    while ((g = reader.read()) != null) {        assertEquals("key", g.getGroup("names", 0).getGroup("map", 0).getBinary("key", 0).toStringUsingUTF8());        assertEquals(map.get("key").size(), g.getGroup("names", 0).getGroup("map", 0).getGroup("value", 0).getFieldRepetitionCount(0));    }}
2a656723e4773f95d9bb1d72ff2e6cc23e246e8caeaae78d6b78271c1abf0221
testWriteFileMapOfLists
public void testWriteFileMapOfLists() throws IOException, InterruptedException, TException
{    Map<List<String>, List<String>> map = new HashMap<List<String>, List<String>>();    map.put(Arrays.asList("key1", "key2"), Arrays.asList("val1", "val2"));    final TestListsInMap mapList = new TestListsInMap("maplists", map);    final Path fileToCreate = createFile(mapList);    ParquetReader<Group> reader = createRecordReader(fileToCreate);    Group g = null;    while ((g = reader.read()) != null) {        assertEquals("key1", g.getGroup("names", 0).getGroup("map", 0).getGroup("key", 0).getBinary("key_tuple", 0).toStringUsingUTF8());        assertEquals("key2", g.getGroup("names", 0).getGroup("map", 0).getGroup("key", 0).getBinary("key_tuple", 1).toStringUsingUTF8());        assertEquals("val1", g.getGroup("names", 0).getGroup("map", 0).getGroup("value", 0).getBinary("value_tuple", 0).toStringUsingUTF8());        assertEquals("val2", g.getGroup("names", 0).getGroup("map", 0).getGroup("value", 0).getBinary("value_tuple", 1).toStringUsingUTF8());    }}
3dc056baca5c2838356783eb88a54de85c03649e4ea3927f7cbbe83032ae5f1b
createRecordReader
private ParquetReader<Group> createRecordReader(Path parquetFilePath) throws IOException
{    Configuration configuration = new Configuration(true);    GroupReadSupport readSupport = new GroupReadSupport();    ParquetMetadata readFooter = ParquetFileReader.readFooter(configuration, parquetFilePath);    MessageType schema = readFooter.getFileMetaData().getSchema();    readSupport.init(configuration, null, schema);    return new ParquetReader<Group>(parquetFilePath, readSupport);}
8db7c4fa3822729f7c3fe166719b77c09f57e1500fc62531c1729e4b2a2f2672
createFile
private Path createFile(T... tObjs) throws IOException, InterruptedException, TException
{    final Path fileToCreate = new Path("target/test/TestThriftToParquetFileWriter/" + tObjs[0].getClass() + ".parquet");    LOG.info("File created: {}", fileToCreate.toString());    Configuration conf = new Configuration();    final FileSystem fs = fileToCreate.getFileSystem(conf);    if (fs.exists(fileToCreate)) {        fs.delete(fileToCreate, true);    }    TProtocolFactory protocolFactory = new TCompactProtocol.Factory();    TaskAttemptID taskId = new TaskAttemptID("local", 0, true, 0, 0);    ThriftToParquetFileWriter w = new ThriftToParquetFileWriter(fileToCreate, ContextUtil.newTaskAttemptContext(conf, taskId), protocolFactory, (Class<? extends TBase<?, ?>>) tObjs[0].getClass());    for (T tObj : tObjs) {        final ByteArrayOutputStream baos = new ByteArrayOutputStream();        final TProtocol protocol = protocolFactory.getProtocol(new TIOStreamTransport(baos));        tObj.write(protocol);        w.write(new BytesWritable(baos.toByteArray()));    }    w.close();    return fileToCreate;}
ff4852e2a090cace40f3f43a2fbfdb8de58d7f14a93fb3e4ffc68c126b5dfeef
testStorer
public void testStorer() throws ExecException, Exception
{    String out = "target/out";    int rows = 1000;    Properties props = new Properties();    props.setProperty("parquet.compression", "uncompressed");    props.setProperty("parquet.page.size", "1000");    PigServer pigServer = new PigServer(ExecType.LOCAL, props);    Data data = Storage.resetData(pigServer);    Collection<Tuple> list = new ArrayList<Tuple>();    for (int i = 0; i < rows; i++) {        list.add(tuple("bob", "roberts" + i));    }    data.set("in", "fn:chararray, ln:chararray", list);    pigServer.deleteFile(out);    pigServer.setBatchOn();    pigServer.registerQuery("A = LOAD 'in' USING mock.Storage();");    pigServer.registerQuery("Store A into '" + out + "' using " + ParquetThriftStorer.class.getName() + "('" + Name.class.getName() + "');");    execBatch(pigServer);    pigServer.registerQuery("B = LOAD '" + out + "' USING " + ParquetLoader.class.getName() + "();");    pigServer.registerQuery("Store B into 'out' using mock.Storage();");    execBatch(pigServer);    List<Tuple> result = data.get("out");    assertEquals(rows, result.size());    int i = 0;    for (Tuple tuple : result) {        assertEquals(tuple("bob", "roberts" + i), tuple);        ++i;    }}
9abde90713fd091165c6e9b87d9b296f10ed70df938d7a4a6f545b76b6c97620
execBatch
private void execBatch(PigServer pigServer) throws IOException
{    if (pigServer.executeBatch().get(0).getStatus() != JOB_STATUS.COMPLETED) {        throw new RuntimeException("Job failed", pigServer.executeBatch().get(0).getException());    }}
9da1652a6f86f64b52fcd25b9a77a9afcbaa312a01785464c973d73c8e35a6cd
testRecursiveGlob
public void testRecursiveGlob()
{    PathGlobPattern g = new PathGlobPattern("a/**/b");    assertFalse(g.matches("a/b"));    assertTrue(g.matches("a/asd/b"));    assertTrue(g.matches("a/asd/ss/b"));    g = new PathGlobPattern("a/**");    assertTrue(g.matches("a/as"));    assertTrue(g.matches("a/asd/b"));    assertTrue(g.matches("a/asd/ss/b"));}
16a47b989dc61497b55ec885526f161e3c29832847873d8c775cfaf6480055a1
testStandardGlob
public void testStandardGlob()
{    PathGlobPattern g = new PathGlobPattern("a/*");    assertTrue(g.matches("a/as"));    assertFalse(g.matches("a/asd/b"));    assertFalse(g.matches("a/asd/ss/b"));    g = new PathGlobPattern("a/{bb,cc}/d");    assertTrue(g.matches("a/bb/d"));    assertTrue(g.matches("a/cc/d"));    assertFalse(g.matches("a/cc/bb/d"));    assertFalse(g.matches("a/d"));}
f4e399fa718e3a76cfeae33ae88fcb9b6142a8633de202dc3ccc86130bc82d9c
testFieldsPath
public void testFieldsPath()
{    StructType person = ThriftSchemaConverter.toStructType(Person.class);    List<String> paths = PrimitivePathVisitor.visit(person, ".");    assertEquals(Arrays.asList("name.first_name", "name.last_name", "id", "email", "phones.number", "phones.type"), paths);    paths = PrimitivePathVisitor.visit(person, "/");    assertEquals(Arrays.asList("name/first_name", "name/last_name", "id", "email", "phones/number", "phones/type"), paths);    StructType structInMap = ThriftSchemaConverter.toStructType(TestStructInMap.class);    paths = PrimitivePathVisitor.visit(structInMap, ".");    assertEquals(Arrays.asList("name", "names.key", "names.value.name.first_name", "names.value.name.last_name", "names.value.phones.key", "names.value.phones.value", "name_to_id.key", "name_to_id.value"), paths);    paths = PrimitivePathVisitor.visit(structInMap, "/");    assertEquals(Arrays.asList("name", "names/key", "names/value/name/first_name", "names/value/name/last_name", "names/value/phones/key", "names/value/phones/value", "name_to_id/key", "name_to_id/value"), paths);}
6df7595c4b33d35c98a9c8e9e67a3dfc52a56bcaa41ce0f12a80c83360978f49
visit
public static List<String> visit(StructType s, String delim)
{    PrimitivePathVisitor v = new PrimitivePathVisitor(delim);    return s.accept(v, new FieldsPath());}
c8aed6ab480e09503d0d6705cde71be51c5905da1bdaaebf5f07014df2cbca68
visit
public List<String> visit(MapType mapType, FieldsPath path)
{    List<String> ret = new ArrayList<String>();    ThriftField key = mapType.getKey();    ThriftField value = mapType.getValue();    ret.addAll(key.getType().accept(this, path.push(key)));    ret.addAll(value.getType().accept(this, path.push(value)));    return ret;}
4aac79b1015ec1db11f036728f9e7bdae285897a4fd86f13926ebb0cce86df30
visit
public List<String> visit(SetType setType, FieldsPath path)
{    return setType.getValues().getType().accept(this, path);}
ce9dc70212ed92a51f20776d4176776b5dd8756d2dfc5f671d4656139475ce18
visit
public List<String> visit(ListType listType, FieldsPath path)
{    return listType.getValues().getType().accept(this, path);}
b6b8c1db6ef4afa82ae631029ef592ba90472fcd71c12374d1761d16b08ba17d
visit
public List<String> visit(StructType structType, FieldsPath path)
{    List<String> ret = new ArrayList<String>();    for (ThriftField child : structType.getChildren()) {        ret.addAll(child.getType().accept(this, path.push(child)));    }    return ret;}
4ded3f25c5c738c6cd4d9bd8af0fa71ba320f4de7e2f6e69367531ff61846764
visitPrimitive
private List<String> visitPrimitive(FieldsPath path)
{    return Arrays.asList(path.toDelimitedString(delim));}
eb6e3c85e654a256da3e346615dbb41afce01d4c121b11dec8ad2afe15166878
visit
public List<String> visit(EnumType enumType, FieldsPath path)
{    return visitPrimitive(path);}
ccc349ba54aa7f5298f5708dea7a0764d91807e9b4acde5755b1e40a709d9fab
visit
public List<String> visit(BoolType boolType, FieldsPath path)
{    return visitPrimitive(path);}
faf0566c9bd794827730b72e8948c9a5d232d9a4b724535724cb53c36c008cff
visit
public List<String> visit(ByteType byteType, FieldsPath path)
{    return visitPrimitive(path);}
05b794a2a7bfc2ce8e2b2f0587a72b779f2f1e3d5d0fbb6d34a8639d7a350310
visit
public List<String> visit(DoubleType doubleType, FieldsPath path)
{    return visitPrimitive(path);}
d53ba59f021f88b68cae02cd1e34f3e728157ff6bb06159f64f0c2a296b45bb9
visit
public List<String> visit(I16Type i16Type, FieldsPath path)
{    return visitPrimitive(path);}
8c1e7a6ca281c4862cde0ec51a941cb98d998a45772e36725bb8e118621ac610
visit
public List<String> visit(I32Type i32Type, FieldsPath path)
{    return visitPrimitive(path);}
2b7421098368c695b41b66a78f6b316c900d48c1b22732a3a06daf08d652b76c
visit
public List<String> visit(I64Type i64Type, FieldsPath path)
{    return visitPrimitive(path);}
7823000280a099ca75323a3677a687ee9ba79f930e384064a9447b3526aa8d5b
visit
public List<String> visit(StringType stringType, FieldsPath path)
{    return visitPrimitive(path);}
438dc570208824fe67b486060f00d646d3d2c4df38a174c75256d053db9a56af
testFromSemicolonDelimitedString
public void testFromSemicolonDelimitedString()
{    List<String> globs = StrictFieldProjectionFilter.parseSemicolonDelimitedString(";x.y.z;*.a.b.c*;;foo;;;;bar;");    assertEquals(Arrays.asList("x.y.z", "*.a.b.c*", "foo", "bar"), globs);    try {        StrictFieldProjectionFilter.parseSemicolonDelimitedString(";;");        fail("this should throw");    } catch (ThriftProjectionException e) {        assertEquals("Semicolon delimited string ';;' contains 0 glob strings", e.getMessage());    }}
79726d08775b14f51a7c279eb6e22cb3c9165c712276658203066dcc974a83ba
assertMatches
private static void assertMatches(StrictFieldProjectionFilter filter, String... strings)
{    for (String s : strings) {        if (!filter.keep(s)) {            fail(String.format("String '%s' was expected to match", s));        }    }}
6657c046dd69e3cfd1e2e9963981c4c7c33dd3c37d922c64e7aade2ac608afd7
assertDoesNotMatch
private static void assertDoesNotMatch(StrictFieldProjectionFilter filter, String... strings)
{    for (String s : strings) {        if (filter.keep(s)) {            fail(String.format("String '%s' was not expected to match", s));        }    }}
f6aa0d5c7ed0557ada7320bb986d3a26a83ff2d5cac68773ca8e4cc94bf7b86f
testProjection
public void testProjection()
{    StrictFieldProjectionFilter filter = StrictFieldProjectionFilter.fromSemicolonDelimitedString("home.phone_number;home.address;work.address.zip;base_info;*.average;a.b.c.pre{x,y,z{a,b,c}}post");    assertMatches(filter, "home.phone_number", "home.address", "work.address.zip", "base_info", "foo.average", "bar.x.y.z.average", "base_info.nested.field", "a.b.c.prexpost", "a.b.c.prezapost");    assertDoesNotMatch(filter, "home2.phone_number", "home2.address", "work.address", "base_info2", "foo_average", "bar.x.y.z_average", "base_info_nested.field", "hi", "average", "a.b.c.pre{x,y,z{a,b,c}}post", "");}
0c7a68a2f7c09c6ef7a7ba4bea68897b4cd9ee160446f41951bf7c53fc18d266
testIsStrict
public void testIsStrict()
{    StrictFieldProjectionFilter filter = StrictFieldProjectionFilter.fromSemicolonDelimitedString("home.phone_number;a.b.c.pre{x,y,z{a,b,c}}post;bar.*.average");    assertMatches(filter, "home.phone_number", "bar.foo.average", "a.b.c.prexpost", "a.b.c.prezcpost");    assertDoesNotMatch(filter, "hello");    try {        filter.assertNoUnmatchedPatterns();        fail("this should throw");    } catch (ThriftProjectionException e) {        String expectedMessage = "The following projection patterns did not match any columns in this schema:\n" + "Pattern: 'a.b.c.pre{x,y,z{a,b,c}}post' (when expanded to 'a.b.c.preypost')\n" + "Pattern: 'a.b.c.pre{x,y,z{a,b,c}}post' (when expanded to 'a.b.c.prezapost')\n" + "Pattern: 'a.b.c.pre{x,y,z{a,b,c}}post' (when expanded to 'a.b.c.prezbpost')\n";        assertEquals(expectedMessage, e.getMessage());    }}
f7c2234989495ba328d1626a3a98722be64fde49eb72197e3fa381746dcc636e
testWarnWhenMultiplePatternsMatch
public void testWarnWhenMultiplePatternsMatch()
{    StrictFieldProjectionFilter filter = createMockBuilder(StrictFieldProjectionFilter.class).withConstructor(Arrays.asList("a.b.c.{x_average,z_average}", "a.*_average")).addMockedMethod("warn").createMock();        filter.warn("Field path: 'a.b.c.x_average' matched more than one glob path pattern. " + "First match: 'a.b.c.{x_average,z_average}' (when expanded to 'a.b.c.x_average') " + "second match:'a.*_average' (when expanded to 'a.*_average')");    filter.warn("Field path: 'a.b.c.z_average' matched more than one glob path pattern. " + "First match: 'a.b.c.{x_average,z_average}' (when expanded to 'a.b.c.z_average') " + "second match:'a.*_average' (when expanded to 'a.*_average')");    replay(filter);    assertMatches(filter, "a.b.c.x_average", "a.b.c.z_average", "a.other.w_average");    assertDoesNotMatch(filter, "hello");    verify(filter);}
27e90c52ffd8908e8ff8489011b0e650481f66898081a13fcaf0014be1cae6ec
testAddOptionalField
public void testAddOptionalField()
{    verifyCompatible(StructV1.class, StructV2.class, true);}
2d5bbd3d1e0167dbac0542928aed48c0e1a8f9e947e93802e23cc9b715295ec6
testRemoveOptionalField
public void testRemoveOptionalField()
{    verifyCompatible(StructV2.class, StructV1.class, false);}
8fb257d635fb46b85f59c35de0438466dc170d4d0c4cbfd6f7f17d94ad130bb8
testRenameField
public void testRenameField()
{    verifyCompatible(StructV1.class, RenameStructV1.class, false);}
3d9542f5ca792e883b592453895cd18c4931e20707d987da6f71ace2ff8bd788
testTypeChange
public void testTypeChange()
{    verifyCompatible(StructV1.class, TypeChangeStructV1.class, false);}
6b81e2cf8e2ceedfeff6ec927d1da3127cae3bde8d96f7f2f95c49a7bc87fa85
testReuirementChange
public void testReuirementChange()
{        verifyCompatible(StructV1.class, OptionalStructV1.class, true);    verifyCompatible(StructV1.class, DefaultStructV1.class, true);        verifyCompatible(OptionalStructV1.class, StructV1.class, false);    verifyCompatible(DefaultStructV1.class, StructV1.class, false);}
e55e47f323b98f0c3523bd868d22abbcf8b6bddd3ce1abe92b1709ccbfed8ae9
testAddRequiredField
public void testAddRequiredField()
{    verifyCompatible(StructV1.class, AddRequiredStructV1.class, false);}
2711789c51604791e3f1d9e60fd013245613e5695ae4ad755db102d34cdf3cb8
testMap
public void testMap()
{        verifyCompatible(MapStructV1.class, MapStructV2.class, true);    verifyCompatible(MapValueStructV1.class, MapValueStructV2.class, true);        verifyCompatible(MapStructV2.class, MapStructV1.class, false);    verifyCompatible(MapValueStructV2.class, MapValueStructV1.class, false);        verifyCompatible(MapStructV2.class, MapAddRequiredStructV1.class, false);}
ccc71e78604747a6c2ff387c36191673e2e448a9e206301aa6f8960c681f52d9
testSet
public void testSet()
{    verifyCompatible(SetStructV2.class, SetStructV1.class, false);    verifyCompatible(SetStructV1.class, SetStructV2.class, true);}
e87cc7fd6c55c214852e44e62a215ac2199391da1277cf787b7d4c229cbef5ea
testList
public void testList()
{    verifyCompatible(ListStructV2.class, ListStructV1.class, false);    verifyCompatible(ListStructV1.class, ListStructV2.class, true);}
fba2bc6fac251b595bdca78fb4c54cf3743830ba06d3b7884ef1aa8abf314d81
testEmptyStruct
public void testEmptyStruct()
{    CompatibilityReport report = getCompatibilityReport(NestedEmptyStruct.class, NestedEmptyStruct.class);    assertEquals("encountered an empty struct: required_empty\nencountered an empty struct: optional_empty", report.prettyMessages());    assertTrue(report.hasEmptyStruct());}
8d83f91dfd28291b49b18552e494b3dc56654a69f09aa02dda601b85c2fa5812
struct
private ThriftType.StructType struct(Class thriftClass)
{    return ThriftSchemaConverter.toStructType(thriftClass);}
9df4c102be8f1260492c09d93a4c01708e2a8c9b4772292e308a22c3be8788eb
getCompatibilityReport
private CompatibilityReport getCompatibilityReport(Class oldClass, Class newClass)
{    CompatibilityChecker checker = new CompatibilityChecker();    CompatibilityReport report = checker.checkCompatibility(struct(oldClass), struct(newClass));    return report;}
55c6613ee65975522947da50712a9b1f207f14652746e79478ffc2c1e3ffd6b1
verifyCompatible
private void verifyCompatible(Class oldClass, Class newClass, boolean expectCompatible)
{    CompatibilityReport report = getCompatibilityReport(oldClass, newClass);    assertEquals(expectCompatible, report.isCompatible());}
e1a64117500d778d8b7a42127760577e169852b5ebb794bd7edb5f1988eb73b5
testWriteUnionInfo
public void testWriteUnionInfo() throws Exception
{    StructType st = new StructType(new LinkedList<ThriftField>(), null);    assertEquals("{\n" + "  \"id\" : \"STRUCT\",\n" + "  \"children\" : [ ],\n" + "  \"structOrUnionType\" : \"STRUCT\"\n" + "}", st.toJSON());    st = new StructType(new LinkedList<ThriftField>(), StructOrUnionType.UNION);    assertEquals("{\n" + "  \"id\" : \"STRUCT\",\n" + "  \"children\" : [ ],\n" + "  \"structOrUnionType\" : \"UNION\"\n" + "}", st.toJSON());    st = new StructType(new LinkedList<ThriftField>(), StructOrUnionType.STRUCT);    assertEquals("{\n" + "  \"id\" : \"STRUCT\",\n" + "  \"children\" : [ ],\n" + "  \"structOrUnionType\" : \"STRUCT\"\n" + "}", st.toJSON());}
66ae699b25a8dcf0e0f3d8c81fa0194118f6fda55f032ccd6071841d5acce7fd
testParseUnionInfo
public void testParseUnionInfo() throws Exception
{    StructType st = (StructType) StructType.fromJSON("{\"id\": \"STRUCT\", \"children\":[], \"structOrUnionType\": \"UNION\"}");    assertEquals(st.getStructOrUnionType(), StructOrUnionType.UNION);    st = (StructType) StructType.fromJSON("{\"id\": \"STRUCT\", \"children\":[], \"structOrUnionType\": \"STRUCT\"}");    assertEquals(st.getStructOrUnionType(), StructOrUnionType.STRUCT);    st = (StructType) StructType.fromJSON("{\"id\": \"STRUCT\", \"children\":[]}");    assertEquals(st.getStructOrUnionType(), StructOrUnionType.STRUCT);    st = (StructType) StructType.fromJSON("{\"id\": \"STRUCT\", \"children\":[], \"structOrUnionType\": \"UNKNOWN\"}");    assertEquals(st.getStructOrUnionType(), StructOrUnionType.UNKNOWN);}
3d33e233a8a64f0abbd87a42bf609ab0cb364a208ef6c81297ef101fc920ddc7
testList
public void testList() throws TException
{    final List<String> names = new ArrayList<String>();    names.add("John");    names.add("Jack");    final TestNameList o = new TestNameList("name", names);    validate(o);}
4689e221fa8fbad92e8f2962126f9018d3f06326039cb28213a5944de7817081
testSet
public void testSet() throws TException
{    final Set<String> names = new HashSet<String>();    names.add("John");    names.add("Jack");    final TestNameSet o = new TestNameSet("name", names);    validate(o);}
de8f3e96639d5abda23a75a5982c23631ef6bd92417ff3b1adbf79383896e32d
testReadEmpty
public void testReadEmpty() throws Exception
{    AddressBook expected = new AddressBook();    validate(expected);}
e8a7eb2b6f5fc575346c8dadb1d877dd88b8d16b79b38f280be2c67f00881bb4
testOneOfEach
public void testOneOfEach() throws TException
{    final List<Byte> bytes = new ArrayList<Byte>();    bytes.add((byte) 1);    final List<Short> shorts = new ArrayList<Short>();    shorts.add((short) 1);    final List<Long> longs = new ArrayList<Long>();    longs.add((long) 1);    OneOfEach a = new OneOfEach(true, false, (byte) 8, (short) 16, (int) 32, (long) 64, (double) 1234, "string", "", false, ByteBuffer.wrap("a".getBytes()), bytes, shorts, longs);    validate(a);}
5fd4a313e76b4c72b8f04da6d40c8f3f451749f179b8171720d0f7bb15574d8f
testRead
public void testRead() throws Exception
{    final PhoneNumber phoneNumber = new PhoneNumber("5555555555");    phoneNumber.type = MOBILE;    List<Person> persons = Arrays.asList(new Person(new Name("john", "johson"), 1, "john@johnson.org", Arrays.asList(phoneNumber)), new Person(new Name("jack", "jackson"), 2, "jack@jackson.org", Arrays.asList(new PhoneNumber("5555555556"))));    AddressBook expected = new AddressBook(persons);    validate(expected);}
7e3f62689a52f5cfc8f5889d1068814d43f1f4feaa85df375762f0f9cb0ab82c
testMap
public void testMap() throws Exception
{    final Map<String, String> map = new HashMap<String, String>();    map.put("foo", "bar");    TestMap testMap = new TestMap("map_name", map);    validate(testMap);}
6a64abc82bed9075ee92449a7f1f42698adea155c4f8b809c5b80a67b55913a3
testStructInMap
public void testStructInMap() throws Exception
{    final Map<String, TestPerson> map = new HashMap<String, TestPerson>();    map.put("foo", new TestPerson(new TestName("john", "johnson"), new HashMap<TestPhoneType, String>()));    final Map<String, Integer> stringToIntMap = Collections.singletonMap("bar", 10);    TestStructInMap testMap = new TestStructInMap("map_name", map, stringToIntMap);    validate(testMap);}
819fa50876eaeaa3d9ce7f89c683666ca05cc3876ede0582a4797b8529e57ac0
validate
private void validate(T expected) throws TException
{    @SuppressWarnings("unchecked")    final Class<T> thriftClass = (Class<T>) expected.getClass();    final MemPageStore memPageStore = new MemPageStore(1);    final ThriftSchemaConverter schemaConverter = new ThriftSchemaConverter();    final MessageType schema = schemaConverter.convert(thriftClass);    LOG.info("{}", schema);    final MessageColumnIO columnIO = new ColumnIOFactory(true).getColumnIO(schema);    final ColumnWriteStoreV1 columns = new ColumnWriteStoreV1(memPageStore, ParquetProperties.builder().withPageSize(10000).withDictionaryEncoding(false).build());    final RecordConsumer recordWriter = columnIO.getRecordWriter(columns);    final StructType thriftType = schemaConverter.toStructType(thriftClass);    ParquetWriteProtocol parquetWriteProtocol = new ParquetWriteProtocol(recordWriter, columnIO, thriftType);    expected.write(parquetWriteProtocol);    recordWriter.flush();    columns.flush();    ThriftRecordConverter<T> converter = new TBaseRecordConverter<T>(thriftClass, schema, thriftType);    final RecordReader<T> recordReader = columnIO.getRecordReader(memPageStore, converter);    final T result = recordReader.read();    assertEquals(expected, result);}
7e3f62689a52f5cfc8f5889d1068814d43f1f4feaa85df375762f0f9cb0ab82c
testMap
public void testMap() throws Exception
{    String[] expectations = { "startMessage()", "startField(name, 0)", "addBinary(map_name)", "endField(name, 0)", "startField(names, 1)", "startGroup()", "startField(map, 0)", "startGroup()", "startField(key, 0)", "addBinary(foo)", "endField(key, 0)", "startField(value, 1)", "addBinary(bar)", "endField(value, 1)", "endGroup()", "startGroup()", "startField(key, 0)", "addBinary(foo2)", "endField(key, 0)", "startField(value, 1)", "addBinary(bar2)", "endField(value, 1)", "endGroup()", "endField(map, 0)", "endGroup()", "endField(names, 1)", "endMessage()" };    String[] expectationsAlt = { "startMessage()", "startField(name, 0)", "addBinary(map_name)", "endField(name, 0)", "startField(names, 1)", "startGroup()", "startField(map, 0)", "startGroup()", "startField(key, 0)", "addBinary(foo2)", "endField(key, 0)", "startField(value, 1)", "addBinary(bar2)", "endField(value, 1)", "endGroup()", "startGroup()", "startField(key, 0)", "addBinary(foo)", "endField(key, 0)", "startField(value, 1)", "addBinary(bar)", "endField(value, 1)", "endGroup()", "endField(map, 0)", "endGroup()", "endField(names, 1)", "endMessage()" };    final Map<String, String> map = new TreeMap<String, String>();    map.put("foo", "bar");    map.put("foo2", "bar2");    TestMap testMap = new TestMap("map_name", map);    try {        validatePig(expectations, testMap);    } catch (ComparisonFailure e) {                                validatePig(expectationsAlt, testMap);    }    validateThrift(expectations, testMap);}
e4903de046eccf727b541797bf46b5df0065572d65177ab8507bca58b6ad6d75
testMapInSet
public void testMapInSet() throws Exception
{    String[] pigExpectations = { "startMessage()", "startField(name, 0)", "addBinary(top)", "endField(name, 0)",     "startField(names, 1)", "startGroup()",     "startField(t, 0)", "startGroup()",     "startField(names_tuple, 0)", "startGroup()",     "startField(map, 0)", "startGroup()",     "startField(key, 0)", "addBinary(foo)", "endField(key, 0)",     "startField(value, 1)", "addBinary(bar)", "endField(value, 1)", "endGroup()", "endField(map, 0)", "endGroup()", "endField(names_tuple, 0)", "endGroup()", "endField(t, 0)", "endGroup()", "endField(names, 1)", "endMessage()" };    final Set<Map<String, String>> set = new HashSet<Map<String, String>>();    final Map<String, String> map = new HashMap<String, String>();    map.put("foo", "bar");    set.add(map);    TestMapInSet o = new TestMapInSet("top", set);    validatePig(pigExpectations, o);    String[] expectationsThrift = { "startMessage()", "startField(name, 0)", "addBinary(top)", "endField(name, 0)",     "startField(names, 1)", "startGroup()",     "startField(names_tuple, 0)", "startGroup()",     "startField(map, 0)", "startGroup()",     "startField(key, 0)", "addBinary(foo)", "endField(key, 0)",     "startField(value, 1)", "addBinary(bar)", "endField(value, 1)", "endGroup()", "endField(map, 0)", "endGroup()", "endField(names_tuple, 0)", "endGroup()", "endField(names, 1)", "endMessage()" };    validateThrift(expectationsThrift, o);}
13e7d015b81e27ba7fb2c3b2191050f0779fa77948b7fec14ff045cc34735bfa
testNameList
public void testNameList() throws TException
{    final List<String> names = new ArrayList<String>();    names.add("John");    names.add("Jack");    final TestNameList o = new TestNameList("name", names);    String[] pigExpectations = { "startMessage()", "startField(name, 0)", "addBinary(name)", "endField(name, 0)", "startField(names, 1)", "startGroup()", "startField(t, 0)", "startGroup()", "startField(names_tuple, 0)", "addBinary(John)", "endField(names_tuple, 0)", "endGroup()", "startGroup()", "startField(names_tuple, 0)", "addBinary(Jack)", "endField(names_tuple, 0)", "endGroup()", "endField(t, 0)", "endGroup()", "endField(names, 1)", "endMessage()" };    validatePig(pigExpectations, o);    String[] expectations = { "startMessage()", "startField(name, 0)", "addBinary(name)", "endField(name, 0)", "startField(names, 1)", "startGroup()", "startField(names_tuple, 0)", "addBinary(John)", "addBinary(Jack)", "endField(names_tuple, 0)", "endGroup()", "endField(names, 1)", "endMessage()" };    validateThrift(expectations, o);}
6a64abc82bed9075ee92449a7f1f42698adea155c4f8b809c5b80a67b55913a3
testStructInMap
public void testStructInMap() throws Exception
{    String[] expectations = { "startMessage()", "startField(name, 0)", "addBinary(map_name)", "endField(name, 0)", "startField(names, 1)", "startGroup()", "startField(map, 0)", "startGroup()", "startField(key, 0)", "addBinary(foo)", "endField(key, 0)", "startField(value, 1)", "startGroup()", "startField(name, 0)", "startGroup()", "startField(first_name, 0)", "addBinary(john)", "endField(first_name, 0)", "startField(last_name, 1)", "addBinary(johnson)", "endField(last_name, 1)", "endGroup()", "endField(name, 0)", "startField(phones, 1)", "startGroup()", "endGroup()", "endField(phones, 1)", "endGroup()", "endField(value, 1)", "endGroup()", "endField(map, 0)", "endGroup()", "endField(names, 1)", "startField(name_to_id, 2)", "startGroup()", "startField(map, 0)", "startGroup()", "startField(key, 0)", "addBinary(bar)", "endField(key, 0)", "startField(value, 1)", "addInt(10)", "endField(value, 1)", "endGroup()", "endField(map, 0)", "endGroup()", "endField(name_to_id, 2)", "endMessage()" };    final Map<String, TestPerson> map = new HashMap<String, TestPerson>();    map.put("foo", new TestPerson(new TestName("john", "johnson"), new HashMap<TestPhoneType, String>()));    final Map<String, Integer> stringToIntMap = Collections.singletonMap("bar", 10);    TestStructInMap testMap = new TestStructInMap("map_name", map, stringToIntMap);    validatePig(expectations, testMap);    validateThrift(expectations, testMap);}
fe592a25c5e8690cd8f353d0ffacc6b06484632aad2642f2fabb01c111ec2ef5
testProtocolEmptyAdressBook
public void testProtocolEmptyAdressBook() throws Exception
{    String[] expectations = { "startMessage()", "startField(persons, 0)", "startGroup()", "endGroup()", "endField(persons, 0)", "endMessage()" };    AddressBook a = new AddressBook(new ArrayList<Person>());    validatePig(expectations, a);    validateThrift(expectations, a);}
f3fd308d0f8d50e5318303478e1e8bd4595597309ed0aded36e40bdf37882576
testProtocolAddressBook
public void testProtocolAddressBook() throws Exception
{    String[] expectations = {     "startMessage()",     "startField(persons, 0)", "startGroup()",     "startField(t, 0)", "startGroup()", "startField(name, 0)",     "startGroup()", "startField(first_name, 0)", "addBinary(Bob)", "endField(first_name, 0)", "startField(last_name, 1)", "addBinary(Roberts)", "endField(last_name, 1)", "endGroup()", "endField(name, 0)", "startField(id, 1)", "addInt(1)", "endField(id, 1)", "startField(email, 2)", "addBinary(bob@roberts.com)", "endField(email, 2)", "startField(phones, 3)", "startGroup()", "startField(t, 0)", "startGroup()", "startField(number, 0)", "addBinary(555 999 9999)", "endField(number, 0)", "endGroup()", "startGroup()", "startField(number, 0)", "addBinary(555 999 9998)", "endField(number, 0)", "startField(type, 1)", "addBinary(HOME)", "endField(type, 1)", "endGroup()", "endField(t, 0)", "endGroup()", "endField(phones, 3)", "endGroup()", "startGroup()", "startField(name, 0)", "startGroup()", "startField(first_name, 0)", "addBinary(Dick)", "endField(first_name, 0)", "startField(last_name, 1)", "addBinary(Richardson)", "endField(last_name, 1)", "endGroup()", "endField(name, 0)", "startField(id, 1)", "addInt(2)", "endField(id, 1)", "startField(email, 2)", "addBinary(dick@richardson.com)", "endField(email, 2)", "startField(phones, 3)", "startGroup()", "startField(t, 0)", "startGroup()", "startField(number, 0)", "addBinary(555 999 9997)", "endField(number, 0)", "endGroup()", "startGroup()", "startField(number, 0)", "addBinary(555 999 9996)", "endField(number, 0)", "endGroup()", "endField(t, 0)", "endGroup()", "endField(phones, 3)", "endGroup()", "endField(t, 0)", "endGroup()", "endField(persons, 0)", "endMessage()" };    ArrayList<Person> persons = new ArrayList<Person>();    final PhoneNumber phoneNumber = new PhoneNumber("555 999 9998");    phoneNumber.type = PhoneType.HOME;    persons.add(new Person(new Name("Bob", "Roberts"), 1, "bob@roberts.com", Arrays.asList(new PhoneNumber("555 999 9999"), phoneNumber)));    persons.add(new Person(new Name("Dick", "Richardson"), 2, "dick@richardson.com", Arrays.asList(new PhoneNumber("555 999 9997"), new PhoneNumber("555 999 9996"))));    AddressBook a = new AddressBook(persons);    validatePig(expectations, a);        String[] expectationsThrift = Arrays.copyOf(expectations, expectations.length, String[].class);    expectationsThrift[3] = "startField(persons_tuple, 0)";    expectationsThrift[23] = "startField(phones_tuple, 0)";    expectationsThrift[37] = "endField(phones_tuple, 0)";    expectationsThrift[60] = "startField(phones_tuple, 0)";    expectationsThrift[71] = "endField(phones_tuple, 0)";    expectationsThrift[75] = "endField(persons_tuple, 0)";    validateThrift(expectationsThrift, a);}
e8a7eb2b6f5fc575346c8dadb1d877dd88b8d16b79b38f280be2c67f00881bb4
testOneOfEach
public void testOneOfEach() throws TException
{    String[] expectations = { "startMessage()", "startField(im_true, 0)", "addInt(1)", "endField(im_true, 0)", "startField(im_false, 1)", "addInt(0)", "endField(im_false, 1)", "startField(a_bite, 2)", "addInt(8)", "endField(a_bite, 2)", "startField(integer16, 3)", "addInt(16)", "endField(integer16, 3)", "startField(integer32, 4)", "addInt(32)", "endField(integer32, 4)", "startField(integer64, 5)", "addLong(64)", "endField(integer64, 5)", "startField(double_precision, 6)", "addDouble(1234.0)", "endField(double_precision, 6)", "startField(some_characters, 7)", "addBinary(string)", "endField(some_characters, 7)", "startField(zomg_unicode, 8)", "addBinary()", "endField(zomg_unicode, 8)", "startField(what_who, 9)", "addInt(0)", "endField(what_who, 9)", "startField(base64, 10)", "addBinary(a)", "endField(base64, 10)", "startField(byte_list, 11)", "startGroup()", "endGroup()", "endField(byte_list, 11)", "startField(i16_list, 12)", "startGroup()", "endGroup()", "endField(i16_list, 12)", "startField(i64_list, 13)", "startGroup()", "endGroup()", "endField(i64_list, 13)", "endMessage()" };    OneOfEach a = new OneOfEach(true, false, (byte) 8, (short) 16, (int) 32, (long) 64, (double) 1234, "string", "", false, ByteBuffer.wrap("a".getBytes()), new ArrayList<Byte>(), new ArrayList<Short>(), new ArrayList<Long>());    validatePig(expectations, a);    String[] thriftExpectations = Arrays.copyOf(expectations, expectations.length, String[].class);        thriftExpectations[2] = "addBoolean(true)";    thriftExpectations[5] = "addBoolean(false)";    thriftExpectations[29] = "addBoolean(false)";    validateThrift(thriftExpectations, a);}
d527b07d11ee36c114bd55be315b2f3af8e4bdfaad500e70385f171c71db263d
validateThrift
private void validateThrift(String[] expectations, TBase<?, ?> a) throws TException
{    final ThriftSchemaConverter thriftSchemaConverter = new ThriftSchemaConverter();        final Class<TBase<?, ?>> class1 = (Class<TBase<?, ?>>) a.getClass();    final MessageType schema = thriftSchemaConverter.convert(class1);    LOG.info("{}", schema);    final StructType structType = thriftSchemaConverter.toStructType(class1);    ExpectationValidatingRecordConsumer recordConsumer = new ExpectationValidatingRecordConsumer(new ArrayDeque<String>(Arrays.asList(expectations)));    final MessageColumnIO columnIO = new ColumnIOFactory().getColumnIO(schema);    ParquetWriteProtocol p = new ParquetWriteProtocol(new RecordConsumerLoggingWrapper(recordConsumer), columnIO, structType);    a.write(p);}
2e82a9202baed7d737adf8c9bc5d10b968f390e1d783db71a547043dd1d7cdf9
validatePig
private MessageType validatePig(String[] expectations, TBase<?, ?> a)
{    ThriftToPig<TBase<?, ?>> thriftToPig = new ThriftToPig(a.getClass());    ExpectationValidatingRecordConsumer recordConsumer = new ExpectationValidatingRecordConsumer(new ArrayDeque<String>(Arrays.asList(expectations)));    Schema pigSchema = thriftToPig.toSchema();    LOG.info("{}", pigSchema);    MessageType schema = new PigSchemaConverter().convert(pigSchema);    LOG.info("{}", schema);    TupleWriteSupport tupleWriteSupport = new TupleWriteSupport(pigSchema);    tupleWriteSupport.init(null);    tupleWriteSupport.prepareForWrite(recordConsumer);    final Tuple pigTuple = thriftToPig.getPigTuple(a);    LOG.info("{}", pigTuple);    tupleWriteSupport.write(pigTuple);    return schema;}
4956efdc015ad8d1c1a671bb363e04c3443aa9b2b59d91fb546b9309c4d71d41
testOneOfEach
public void testOneOfEach() throws Exception
{    OneOfEach a = new OneOfEach(true, false, (byte) 8, (short) 16, (int) 32, (long) 64, (double) 1234, "string", "", false, ByteBuffer.wrap("a".getBytes()), new ArrayList<Byte>(), new ArrayList<Short>(), new ArrayList<Long>());    writeReadCompare(a);}
90ee6962d1275dfbf80ccb9c6495b1e47c40025aebd2eb15c60b75e4bd8db4e2
testWriteRead
public void testWriteRead() throws Exception
{    ArrayList<Person> persons = new ArrayList<Person>();    final PhoneNumber phoneNumber = new PhoneNumber("555 999 9998");    phoneNumber.type = PhoneType.HOME;    persons.add(new Person(new Name("Bob", "Roberts"), 1, "bob@roberts.com", Arrays.asList(new PhoneNumber("555 999 9999"), phoneNumber)));    persons.add(new Person(new Name("Dick", "Richardson"), 2, "dick@richardson.com", Arrays.asList(new PhoneNumber("555 999 9997"), new PhoneNumber("555 999 9996"))));    AddressBook a = new AddressBook(persons);    writeReadCompare(a);}
c0ab3082d08dc4ee87af3167e37a41a2857deca0e1775d4ce103a3e8e8c2a5e8
testEmptyStruct
public void testEmptyStruct() throws Exception
{    AddressBook a = new AddressBook();    writeReadCompare(a);}
2cefbd86fc7612d0070fe1cd2e6a13a6670977a618eca0a75f58c1814b664267
testMapSet
public void testMapSet() throws Exception
{    final Set<Map<String, String>> set = new HashSet<Map<String, String>>();    final Map<String, String> map = new HashMap<String, String>();    map.put("foo", "bar");    set.add(map);    TestMapInSet a = new TestMapInSet("top", set);    writeReadCompare(a);}
96a6e9faa5e50c68dac01239b4f195431e5682173c92e335d10def0224e3ff7e
writeReadCompare
private void writeReadCompare(TBase<?, ?> a) throws TException, InstantiationException, IllegalAccessException
{    ProtocolPipe[] pipes = { new ProtocolReadToWrite(), new BufferedProtocolReadToWrite(ThriftSchemaConverter.toStructType((Class<TBase<?, ?>>) a.getClass())) };    for (ProtocolPipe p : pipes) {        final ByteArrayOutputStream in = new ByteArrayOutputStream();        final ByteArrayOutputStream out = new ByteArrayOutputStream();        a.write(protocol(in));        p.readOne(protocol(new ByteArrayInputStream(in.toByteArray())), protocol(out));        TBase<?, ?> b = a.getClass().newInstance();        b.read(protocol(new ByteArrayInputStream(out.toByteArray())));        assertEquals(p.getClass().getSimpleName(), a, b);    }}
846325a10c0fc1e3e365c5f065dfc09fd99296f38aede55335331a7ce2183a63
testIncompatibleSchemaRecord
public void testIncompatibleSchemaRecord() throws Exception
{        CountingErrorHandler countingHandler = new CountingErrorHandler();    BufferedProtocolReadToWrite p = new BufferedProtocolReadToWrite(ThriftSchemaConverter.toStructType(AddressBook.class), countingHandler);    final ByteArrayOutputStream in = new ByteArrayOutputStream();    final ByteArrayOutputStream out = new ByteArrayOutputStream();    OneOfEach a = new OneOfEach(true, false, (byte) 8, (short) 16, (int) 32, (long) 64, (double) 1234, "string", "", false, ByteBuffer.wrap("a".getBytes()), new ArrayList<Byte>(), new ArrayList<Short>(), new ArrayList<Long>());    a.write(protocol(in));    try {        p.readOne(protocol(new ByteArrayInputStream(in.toByteArray())), protocol(out));        fail("this should throw");    } catch (SkippableException e) {        Throwable cause = e.getCause();        assertTrue(cause instanceof DecodingSchemaMismatchException);        assertTrue(cause.getMessage().contains("the data type does not match the expected thrift structure"));        assertTrue(cause.getMessage().contains("got BOOL"));    }    assertEquals(0, countingHandler.recordCountOfMissingFields);    assertEquals(0, countingHandler.fieldIgnoredCount);}
f9f6aa9ae26acb864ec59ddc2a42cca8dc47173d9c55bdc0376bea00cc78778e
testUnrecognizedUnionMemberSchema
public void testUnrecognizedUnionMemberSchema() throws Exception
{    CountingErrorHandler countingHandler = new CountingErrorHandler();    BufferedProtocolReadToWrite p = new BufferedProtocolReadToWrite(ThriftSchemaConverter.toStructType(StructWithUnionV1.class), countingHandler);    final ByteArrayOutputStream in = new ByteArrayOutputStream();    final ByteArrayOutputStream out = new ByteArrayOutputStream();    StructWithUnionV1 validUnion = new StructWithUnionV1("a valid struct", UnionV1.aLong(new ALong(17L)));    StructWithUnionV2 invalidUnion = new StructWithUnionV2("a struct with new union member", UnionV2.aNewBool(new ABool(true)));    validUnion.write(protocol(in));    invalidUnion.write(protocol(in));    ByteArrayInputStream baos = new ByteArrayInputStream(in.toByteArray());        p.readOne(protocol(baos), protocol(out));    try {        p.readOne(protocol(baos), protocol(out));        fail("this should throw");    } catch (SkippableException e) {        Throwable cause = e.getCause();        assertEquals(DecodingSchemaMismatchException.class, cause.getClass());        assertTrue(cause.getMessage().startsWith("Unrecognized union member with id: 3 for struct:"));    }    assertEquals(0, countingHandler.recordCountOfMissingFields);    assertEquals(0, countingHandler.fieldIgnoredCount);}
1d26ce42ce4a1ed5b7124aacfdb945aef82de2b911d23209f6dab45563b10327
testUnionWithExtraOrNoValues
public void testUnionWithExtraOrNoValues() throws Exception
{    CountingErrorHandler countingHandler = new CountingErrorHandler();    BufferedProtocolReadToWrite p = new BufferedProtocolReadToWrite(ThriftSchemaConverter.toStructType(StructWithUnionV2.class), countingHandler);    ByteArrayOutputStream in = new ByteArrayOutputStream();    final ByteArrayOutputStream out = new ByteArrayOutputStream();    StructWithUnionV2 validUnion = new StructWithUnionV2("a valid struct", UnionV2.aLong(new ALong(17L)));    StructWithAStructThatLooksLikeUnionV2 allMissing = new StructWithAStructThatLooksLikeUnionV2("all missing", new AStructThatLooksLikeUnionV2());    AStructThatLooksLikeUnionV2 extra = new AStructThatLooksLikeUnionV2();    extra.setALong(new ALong(18L));    extra.setANewBool(new ABool(false));    StructWithAStructThatLooksLikeUnionV2 hasExtra = new StructWithAStructThatLooksLikeUnionV2("has extra", new AStructThatLooksLikeUnionV2(extra));    validUnion.write(protocol(in));    allMissing.write(protocol(in));    ByteArrayInputStream baos = new ByteArrayInputStream(in.toByteArray());        p.readOne(protocol(baos), protocol(out));    try {        p.readOne(protocol(baos), protocol(out));        fail("this should throw");    } catch (SkippableException e) {        Throwable cause = e.getCause();        assertEquals(DecodingSchemaMismatchException.class, cause.getClass());        assertTrue(cause.getMessage().startsWith("Cannot write a TUnion with no set value in"));    }    assertEquals(0, countingHandler.recordCountOfMissingFields);    assertEquals(0, countingHandler.fieldIgnoredCount);    in = new ByteArrayOutputStream();    validUnion.write(protocol(in));    hasExtra.write(protocol(in));    baos = new ByteArrayInputStream(in.toByteArray());        p.readOne(protocol(baos), protocol(out));    try {        p.readOne(protocol(baos), protocol(out));        fail("this should throw");    } catch (SkippableException e) {        Throwable cause = e.getCause();        assertEquals(DecodingSchemaMismatchException.class, cause.getClass());        assertTrue(cause.getMessage().startsWith("Cannot write a TUnion with more than 1 set value in"));    }    assertEquals(0, countingHandler.recordCountOfMissingFields);    assertEquals(0, countingHandler.fieldIgnoredCount);}
a0d225ace40a2b66387ac9915a8afa509970bd3f9689742316ab7c36715e7c65
testUnionWithStructWithUnknownField
public void testUnionWithStructWithUnknownField() throws Exception
{    CountingErrorHandler countingHandler = new CountingErrorHandler();    BufferedProtocolReadToWrite p = new BufferedProtocolReadToWrite(ThriftSchemaConverter.toStructType(UnionV3.class), countingHandler);    ByteArrayOutputStream in = new ByteArrayOutputStream();    final ByteArrayOutputStream out = new ByteArrayOutputStream();    UnionV3 validUnion = UnionV3.aStruct(new StructV1("a valid struct"));    StructV2 structV2 = new StructV2("a valid struct");    structV2.setAge("a valid age");    UnionThatLooksLikeUnionV3 unionWithUnknownStructField = UnionThatLooksLikeUnionV3.aStruct(structV2);    validUnion.write(protocol(in));    unionWithUnknownStructField.write(protocol(in));    ByteArrayInputStream baos = new ByteArrayInputStream(in.toByteArray());        p.readOne(protocol(baos), protocol(out));    p.readOne(protocol(baos), protocol(out));    assertEquals(1, countingHandler.recordCountOfMissingFields);    assertEquals(1, countingHandler.fieldIgnoredCount);    in = new ByteArrayOutputStream();    validUnion.write(protocol(in));    unionWithUnknownStructField.write(protocol(in));    baos = new ByteArrayInputStream(in.toByteArray());        p.readOne(protocol(baos), protocol(out));    p.readOne(protocol(baos), protocol(out));    assertEquals(2, countingHandler.recordCountOfMissingFields);    assertEquals(2, countingHandler.fieldIgnoredCount);}
8bf7d21c0119f2058710b29138ef3b17d13a54f33bd79cab14dc2490617c02cb
testEnumMissingSchema
public void testEnumMissingSchema() throws Exception
{    CountingErrorHandler countingHandler = new CountingErrorHandler();    BufferedProtocolReadToWrite p = new BufferedProtocolReadToWrite(ThriftSchemaConverter.toStructType(StructWithEnum.class), countingHandler);    final ByteArrayOutputStream in = new ByteArrayOutputStream();    final ByteArrayOutputStream out = new ByteArrayOutputStream();    StructWithMoreEnum enumDefinedInOldDefinition = new StructWithMoreEnum(NumberEnumWithMoreValue.THREE);    StructWithMoreEnum extraEnumDefinedInNewDefinition = new StructWithMoreEnum(NumberEnumWithMoreValue.FOUR);    enumDefinedInOldDefinition.write(protocol(in));    extraEnumDefinedInNewDefinition.write(protocol(in));    ByteArrayInputStream baos = new ByteArrayInputStream(in.toByteArray());        p.readOne(protocol(baos), protocol(out));    try {        p.readOne(protocol(baos), protocol(out));        fail("this should throw");    } catch (SkippableException e) {        Throwable cause = e.getCause();        assertEquals(DecodingSchemaMismatchException.class, cause.getClass());        assertTrue(cause.getMessage().contains("can not find index 4 in enum"));    }    assertEquals(0, countingHandler.recordCountOfMissingFields);    assertEquals(0, countingHandler.fieldIgnoredCount);}
e883ab3cdff103ea18ee96bb3312baab45de8a9e494810d8a2cc432c53b391d5
testMissingFieldHandling
public void testMissingFieldHandling() throws Exception
{    CountingErrorHandler countingHandler = new CountingErrorHandler() {        @Override        public void handleFieldIgnored(TField field) {            assertEquals(field.id, 4);            fieldIgnoredCount++;        }    };    BufferedProtocolReadToWrite structForRead = new BufferedProtocolReadToWrite(ThriftSchemaConverter.toStructType(StructV3.class), countingHandler);        final ByteArrayOutputStream in = new ByteArrayOutputStream();    StructV4WithExtracStructField dataWithNewSchema = new StructV4WithExtracStructField("name");    dataWithNewSchema.setAge("10");    dataWithNewSchema.setGender("male");    StructV3 structV3 = new StructV3("name");    structV3.setAge("10");    dataWithNewSchema.setAddedStruct(structV3);    dataWithNewSchema.write(protocol(in));        final ByteArrayOutputStream out = new ByteArrayOutputStream();    structForRead.readOne(protocol(new ByteArrayInputStream(in.toByteArray())), protocol(out));        assertEquals(1, countingHandler.recordCountOfMissingFields);    assertEquals(1, countingHandler.fieldIgnoredCount);    StructV4WithExtracStructField b = StructV4WithExtracStructField.class.newInstance();    b.read(protocol(new ByteArrayInputStream(out.toByteArray())));    assertEquals(dataWithNewSchema.getName(), b.getName());    assertEquals(dataWithNewSchema.getAge(), b.getAge());    assertEquals(dataWithNewSchema.getGender(), b.getGender());    assertEquals(null, b.getAddedStruct());}
c6d4c026a5d7600a6f6997c9acf2b33ef7ec477daefd17a7d1cea2eeef239341
handleFieldIgnored
public void handleFieldIgnored(TField field)
{    assertEquals(field.id, 4);    fieldIgnoredCount++;}
07f1a5547a47483a229bb65eceff741daa65b682778649ea92f55be35c98cf3b
TestExtraFieldWhenFieldIndexIsNotStartFromZero
public void TestExtraFieldWhenFieldIndexIsNotStartFromZero() throws Exception
{    CountingErrorHandler countingHandler = new CountingErrorHandler() {        @Override        public void handleFieldIgnored(TField field) {            assertEquals(3, field.id);            fieldIgnoredCount++;        }    };    BufferedProtocolReadToWrite structForRead = new BufferedProtocolReadToWrite(ThriftSchemaConverter.toStructType(StructWithIndexStartsFrom4.class), countingHandler);        final ByteArrayOutputStream in = new ByteArrayOutputStream();    StructWithExtraField dataWithNewExtraField = new StructWithExtraField(new Phone("111", "222"), new Phone("333", "444"));    dataWithNewExtraField.write(protocol(in));        final ByteArrayOutputStream out = new ByteArrayOutputStream();    structForRead.readOne(protocol(new ByteArrayInputStream(in.toByteArray())), protocol(out));    assertEquals(1, countingHandler.recordCountOfMissingFields);    assertEquals(1, countingHandler.fieldIgnoredCount);}
c6d4c026a5d7600a6f6997c9acf2b33ef7ec477daefd17a7d1cea2eeef239341
handleFieldIgnored
public void handleFieldIgnored(TField field)
{    assertEquals(3, field.id);    fieldIgnoredCount++;}
67fe93c1eabc8a8fa83eb06668e5513442d51317448f8777460514acdc678ca8
protocol
private TCompactProtocol protocol(OutputStream to)
{    return new TCompactProtocol(new TIOStreamTransport(to));}
b93f8c32ad08958b4105154c05f372b078f2cbec08752e3a9e4f9eac8cd4dc51
protocol
private TCompactProtocol protocol(InputStream from)
{    return new TCompactProtocol(new TIOStreamTransport(from));}
5e86374aed53ae808a885d12660b78da54852dbaf984433526574816342cacb9
handleRecordHasFieldIgnored
public void handleRecordHasFieldIgnored()
{    recordCountOfMissingFields++;}
c6d4c026a5d7600a6f6997c9acf2b33ef7ec477daefd17a7d1cea2eeef239341
handleFieldIgnored
public void handleFieldIgnored(TField field)
{    fieldIgnoredCount++;}
2822db7994697b5d04273ac8a905e5ac7a3fdbf226326334c8e82696ead30e6e
testToStringDoesNotThrow
public void testToStringDoesNotThrow()
{    StructType descriptor = new StructType(new ArrayList<ThriftField>(), StructOrUnionType.STRUCT);    ThriftMetaData tmd = new ThriftMetaData("non existent class!!!", descriptor);    assertEquals("ThriftMetaData(thriftClassName: non existent class!!!, descriptor: {\n" + "  \"id\" : \"STRUCT\",\n" + "  \"children\" : [ ],\n" + "  \"structOrUnionType\" : \"STRUCT\"\n" + "})", tmd.toString());    tmd = new ThriftMetaData("non existent class!!!", null);    assertEquals("ThriftMetaData(thriftClassName: non existent class!!!, descriptor: null)", tmd.toString());}
57b15f3da748d26656af8cd77ef119c25ee78a8e0b2fd16cc65cb284472846c2
testWriteRead
public void testWriteRead() throws IOException
{    Configuration configuration = new Configuration();    Path f = new Path("target/test/TestThriftParquetReaderWriter");    FileSystem fs = f.getFileSystem(configuration);    if (fs.exists(f)) {        fs.delete(f, true);    }    AddressBook original = new AddressBook(Arrays.asList(new Person(new Name("Bob", "Roberts"), 1, "bob@roberts.com", Arrays.asList(new PhoneNumber("5555555555")))));    {                ThriftParquetWriter<AddressBook> thriftParquetWriter = new ThriftParquetWriter<AddressBook>(f, AddressBook.class, CompressionCodecName.UNCOMPRESSED);        thriftParquetWriter.write(original);        thriftParquetWriter.close();    }    {                ThriftParquetReader<AddressBook> thriftParquetReader = new ThriftParquetReader<AddressBook>(f, AddressBook.class);        AddressBook read = thriftParquetReader.read();        Assert.assertEquals(original, read);        thriftParquetReader.close();    }    {                ThriftParquetReader<AddressBook> thriftParquetReader = new ThriftParquetReader<AddressBook>(f);        AddressBook read = thriftParquetReader.read();        Assert.assertEquals(original, read);        thriftParquetReader.close();    }}
9012c026e731988538abf60e6f831d2931b9be9a58d27f9e31dde0d79f51c570
testUnknownEnumThrowsGoodException
public void testUnknownEnumThrowsGoodException() throws Exception
{    EnumType et = new EnumType(Arrays.asList(new EnumValue(77, "hello")));    ThriftField field = new ThriftField("name", (short) 1, Requirement.REQUIRED, et);    ArrayList<TProtocol> events = new ArrayList<TProtocol>();    FieldEnumConverter conv = new FieldEnumConverter(events, field);    conv.addBinary(Binary.fromString("hello"));    assertEquals(1, events.size());    assertEquals(77, events.get(0).readI32());    try {        conv.addBinary(Binary.fromString("FAKE_ENUM_VALUE"));        fail("this should throw");    } catch (ParquetDecodingException e) {        assertEquals("Unrecognized enum value: FAKE_ENUM_VALUE known values: {Binary{\"hello\"}=77} in {\n" + "  \"name\" : \"name\",\n" + "  \"fieldId\" : 1,\n" + "  \"requirement\" : \"REQUIRED\",\n" + "  \"type\" : {\n" + "    \"id\" : \"ENUM\",\n" + "    \"values\" : [ {\n" + "      \"id\" : 77,\n" + "      \"name\" : \"hello\"\n" + "    } ]\n" + "  }\n" + "}", e.getMessage());    }}
91c60f07b48da9c36b105f52217273d151d9543353638d3b2833d1898f1864f1
constructorDoesNotRequireStructOrUnionTypeMeta
public void constructorDoesNotRequireStructOrUnionTypeMeta() throws Exception
{    String jsonWithNoStructOrUnionMeta = Strings.join(Files.readAllLines(new File("src/test/resources/org/apache/parquet/thrift/StructWithUnionV1NoStructOrUnionMeta.json").toPath(), StandardCharsets.UTF_8), "\n");    StructType noStructOrUnionMeta = (StructType) ThriftType.fromJSON(jsonWithNoStructOrUnionMeta);        new ThriftRecordConverter<StructWithUnionV1>(new ThriftReader<StructWithUnionV1>() {        @Override        public StructWithUnionV1 readOneRecord(TProtocol protocol) throws TException {            return null;        }    }, "name", new ThriftSchemaConverter().convert(StructWithUnionV1.class), noStructOrUnionMeta);}
8d38cce6ee4d93c2806136219c33b2681e7837ec3a5556ea5260764b1f9720c6
readOneRecord
public StructWithUnionV1 readOneRecord(TProtocol protocol) throws TException
{    return null;}
096270dbadb798b70cb543b069fd65c1aa1ad0b38a860f703963e64544ffe0af
testToMessageType
public void testToMessageType() throws Exception
{    String expected = "message ParquetSchema {\n" + "  optional group persons (LIST) = 1 {\n" + "    repeated group persons_tuple {\n" + "      required group name = 1 {\n" + "        optional binary first_name (UTF8) = 1;\n" + "        optional binary last_name (UTF8) = 2;\n" + "      }\n" + "      optional int32 id = 2;\n" + "      optional binary email (UTF8) = 3;\n" + "      optional group phones (LIST) = 4 {\n" + "        repeated group phones_tuple {\n" + "          optional binary number (UTF8) = 1;\n" + "          optional binary type (ENUM) = 2;\n" + "        }\n" + "      }\n" + "    }\n" + "  }\n" + "}";    ThriftSchemaConverter schemaConverter = new ThriftSchemaConverter();    final MessageType converted = schemaConverter.convert(AddressBook.class);    assertEquals(MessageTypeParser.parseMessageType(expected), converted);}
9862170efd6536876c11f3f8e9e4b2715472bc062b6522cd11ea08b8131c1c28
testToProjectedThriftType
public void testToProjectedThriftType()
{    shouldGetProjectedSchema("name/first_name", "name.first_name", "message ParquetSchema {" + "  required group name = 1 {" + "    optional binary first_name (UTF8) = 1;" + "  }}", Person.class);    shouldGetProjectedSchema("name/first_name;name/last_name", "name.first_name;name.last_name", "message ParquetSchema {" + "  required group name = 1 {" + "    optional binary first_name (UTF8) = 1;" + "    optional binary last_name (UTF8) = 2;" + "  }}", Person.class);    shouldGetProjectedSchema("name/{first,last}_name;", "name.{first,last}_name;", "message ParquetSchema {" + "  required group name = 1 {" + "    optional binary first_name (UTF8) = 1;" + "    optional binary last_name (UTF8) = 2;" + "  }}", Person.class);    shouldGetProjectedSchema("name/*", "name", "message ParquetSchema {" + "  required group name = 1 {" + "    optional binary first_name (UTF8) = 1;" + "    optional binary last_name (UTF8) = 2;" + "  }" + "}", Person.class);    shouldGetProjectedSchema("*/*_name", "*.*_name", "message ParquetSchema {" + "  required group name = 1 {" + "    optional binary first_name (UTF8) = 1;" + "    optional binary last_name (UTF8) = 2;" + "  }" + "}", Person.class);    shouldGetProjectedSchema("name/first_*", "name.first_*", "message ParquetSchema {" + "  required group name = 1 {" + "    optional binary first_name (UTF8) = 1;" + "  }" + "}", Person.class);    shouldGetProjectedSchema("*/*", "*.*", "message ParquetSchema {" + "  required group name = 1 {" + "  optional binary first_name (UTF8) = 1;" + "  optional binary last_name (UTF8) = 2;" + "} " + "  optional group phones (LIST) = 4 {" + "    repeated group phones_tuple {" + "      optional binary number (UTF8) = 1;" + "      optional binary type (ENUM) = 2;" + "    }" + "}}", Person.class);}
0b0145665a4c24e5005c9ecebc2c1f2ba02e5238fd57ac40072483d465616862
testProjectMapThriftType
public void testProjectMapThriftType()
{        shouldGetProjectedSchema("name;names/key*;names/value/**", "name;names.key*;names.value", "message ParquetSchema {\n" + "  optional binary name (UTF8) = 1;\n" + "  optional group names (MAP) = 2 {\n" + "    repeated group map (MAP_KEY_VALUE) {\n" + "      required binary key (UTF8);\n" + "      optional group value {\n" + "        optional group name = 1 {\n" + "          optional binary first_name (UTF8) = 1;\n" + "          optional binary last_name (UTF8) = 2;\n" + "        }\n" + "        optional group phones (MAP) = 2 {\n" + "          repeated group map (MAP_KEY_VALUE) {\n" + "            required binary key (ENUM);\n" + "            optional binary value (UTF8);\n" + "          }\n" + "        }\n" + "      }\n" + "    }\n" + "  }\n" + "}", TestStructInMap.class);        shouldGetProjectedSchema("name;names/key;names/value/name/*", "name;names.key;names.value.name", "message ParquetSchema {\n" + "  optional binary name (UTF8) = 1;\n" + "  optional group names (MAP) = 2 {\n" + "    repeated group map (MAP_KEY_VALUE) {\n" + "      required binary key (UTF8);\n" + "      optional group value {\n" + "        optional group name = 1 {\n" + "          optional binary first_name (UTF8) = 1;\n" + "          optional binary last_name (UTF8) = 2;\n" + "        }\n" + "      }\n" + "    }\n" + "  }\n" + "}", TestStructInMap.class);}
475583349488b69a4dedb8bbf4b51766111d92ce4a58ec0ad1e3168a4840aaab
testProjectOnlyKeyInMap
public void testProjectOnlyKeyInMap()
{    shouldGetProjectedSchema("name;names/key", "name;names.key", "message ParquetSchema {\n" + "  optional binary name (UTF8) = 1;\n" + "  optional group names (MAP) = 2 {\n" + "    repeated group map (MAP_KEY_VALUE) {\n" + "      required binary key (UTF8);\n" + "      optional group value {\n" + "        optional group name = 1 {\n" + "          optional binary first_name (UTF8) = 1;\n" + "        }\n" + "      }" + "    }\n" + "  }\n" + "}", TestStructInMap.class);}
de183801739ae6c1ec83618fcda6e211c18b351fdfe811a32dbf54b3969041fd
shouldThrowWhenProjectionFilterMatchesNothing
private void shouldThrowWhenProjectionFilterMatchesNothing(String filters, String unmatchedFilter, Class<? extends TBase<?, ?>> thriftClass)
{    try {        getDeprecatedFilteredSchema(filters, thriftClass);        fail("should throw projection exception when filter matches nothing");    } catch (ThriftProjectionException e) {        assertEquals("The following projection patterns did not match any columns in this schema:\n" + unmatchedFilter + "\n", e.getMessage());    }}
71fd689c4fa1fcabd23e6c8647cde05788436449b438a379b66b2706c149bd9f
shouldThrowWhenNoColumnsAreSelected
private void shouldThrowWhenNoColumnsAreSelected(String filters, Class<? extends TBase<?, ?>> thriftClass)
{    try {        getDeprecatedFilteredSchema(filters, thriftClass);        fail("should throw projection exception when no columns are selected");    } catch (ThriftProjectionException e) {        assertEquals("No columns have been selected", e.getMessage());    }}
ebbafef0b64fbbb5bdf5c6409aac53ec11dc185a3ad8cf624d514a70898520b6
testThrowWhenNoColumnsAreSelected
public void testThrowWhenNoColumnsAreSelected()
{    shouldThrowWhenNoColumnsAreSelected("non_existing", TestStructInMap.class);}
d9ca492b5d87f25dd52db7eef196823672e73409b756f962001cd6453ca4b235
testThrowWhenProjectionFilterMatchesNothing
public void testThrowWhenProjectionFilterMatchesNothing()
{    shouldThrowWhenProjectionFilterMatchesNothing("name;non_existing", "non_existing", TestStructInMap.class);    shouldThrowWhenProjectionFilterMatchesNothing("**;non_existing", "non_existing", TestStructInMap.class);    shouldThrowWhenProjectionFilterMatchesNothing("**;names/non_existing", "names/non_existing", TestStructInMap.class);    shouldThrowWhenProjectionFilterMatchesNothing("**;names/non_existing;non_existing", "names/non_existing\nnon_existing", TestStructInMap.class);}
e5b442a70e40731617f7f870aa8f00bb0e2c442c31d41e51f49e78f38303acb0
testProjectOnlyValueInMap
public void testProjectOnlyValueInMap()
{    try {        getDeprecatedFilteredSchema("name;names/value/**", TestStructInMap.class);        fail("this should throw");    } catch (ThriftProjectionException e) {        assertEquals("Cannot select only the values of a map, you must keep the keys as well: names", e.getMessage());    }    try {        getStrictFilteredSchema("name;names.value", TestStructInMap.class);        fail("this should throw");    } catch (ThriftProjectionException e) {        assertEquals("Cannot select only the values of a map, you must keep the keys as well: names", e.getMessage());    }}
0cdcef4fbbdde6401f1d63df74761e71a6622d489b860aa40a4fb942a4fcc645
doTestPartialKeyProjection
private void doTestPartialKeyProjection(String deprecated, String strict)
{    try {        getDeprecatedFilteredSchema(deprecated, MapStructV2.class);        fail("this should throw");    } catch (ThriftProjectionException e) {        assertEquals("Cannot select only a subset of the fields in a map key, for path map1", e.getMessage());    }    try {        getStrictFilteredSchema(strict, MapStructV2.class);        fail("this should throw");    } catch (ThriftProjectionException e) {        assertEquals("Cannot select only a subset of the fields in a map key, for path map1", e.getMessage());    }}
1db2bf3b0b1e118bb7566abad586a9e470315d83f046634151cc0f3fd7795fbb
testPartialKeyProjection
public void testPartialKeyProjection()
{    doTestPartialKeyProjection("map1/key/age", "map1.key.age");    doTestPartialKeyProjection("map1/key/age;map1/value/**", "map1.{key.age,value}");}
4da10cd34705522bb813e510ff95ed25de38ad20fb2a5d3f52c4b410dea8feaf
testSetPartialProjection
public void testSetPartialProjection()
{    try {        getDeprecatedFilteredSchema("set1/age", SetStructV2.class);        fail("this should throw");    } catch (ThriftProjectionException e) {        assertEquals("Cannot select only a subset of the fields in a set, for path set1", e.getMessage());    }    try {        getStrictFilteredSchema("set1.age", SetStructV2.class);        fail("this should throw");    } catch (ThriftProjectionException e) {        assertEquals("Cannot select only a subset of the fields in a set, for path set1", e.getMessage());    }}
9397458e39e2eb502b2a0aee7108356a3cdc438e9ee76c0a29e1ef40921bb959
testConvertStructCreatedViaDeprecatedConstructor
public void testConvertStructCreatedViaDeprecatedConstructor()
{    String expected = "message ParquetSchema {\n" + "  required binary a (UTF8) = 1;\n" + "  required binary b (UTF8) = 2;\n" + "}\n";    ThriftSchemaConverter converter = new ThriftSchemaConverter();    StructType structType = new StructType(Arrays.asList(new ThriftField("a", (short) 1, REQUIRED, new ThriftType.StringType()), new ThriftField("b", (short) 2, REQUIRED, new ThriftType.StringType())));    final MessageType converted = converter.convert(structType);    assertEquals(MessageTypeParser.parseMessageType(expected), converted);}
6e7851ee6c0120899bedc69c053ea068ff6958d9890ff49306d19ff30fc31e05
shouldGetProjectedSchema
public static void shouldGetProjectedSchema(String deprecatedFilterDesc, String strictFilterDesc, String expectedSchemaStr, Class<? extends TBase<?, ?>> thriftClass)
{    MessageType depRequestedSchema = getDeprecatedFilteredSchema(deprecatedFilterDesc, thriftClass);    MessageType strictRequestedSchema = getStrictFilteredSchema(strictFilterDesc, thriftClass);    MessageType expectedSchema = parseMessageType(expectedSchemaStr);    assertEquals(expectedSchema, depRequestedSchema);    assertEquals(expectedSchema, strictRequestedSchema);}
cbeaa5c14623f2e9ca7d9c5c2d504871dfbb76d817d84c619f626884833a3834
getDeprecatedFilteredSchema
private static MessageType getDeprecatedFilteredSchema(String filterDesc, Class<? extends TBase<?, ?>> thriftClass)
{    DeprecatedFieldProjectionFilter fieldProjectionFilter = new DeprecatedFieldProjectionFilter(filterDesc);    return new ThriftSchemaConverter(fieldProjectionFilter).convert(thriftClass);}
25fa147d6b7c38f1f0c489d5fc775ecfedb3dfca6e894f38d9c9ea50fe3bf929
getStrictFilteredSchema
private static MessageType getStrictFilteredSchema(String semicolonDelimitedString, Class<? extends TBase<?, ?>> thriftClass)
{    StrictFieldProjectionFilter fieldProjectionFilter = StrictFieldProjectionFilter.fromSemicolonDelimitedString(semicolonDelimitedString);    return new ThriftSchemaConverter(fieldProjectionFilter).convert(thriftClass);}
1450d5aabe69ce726329e94e50e212f2f272c9ccc91f90970fc1171ef7bed8c9
testToThriftType
public void testToThriftType() throws Exception
{    final StructType converted = ThriftSchemaConverter.toStructType(AddressBook.class);    final String json = converted.toJSON();    final ThriftType fromJSON = StructType.fromJSON(json);    assertEquals(json, fromJSON.toJSON());}
16d84d4220377b09cfde5aae4af0b4b66c3550ac56b9ec2238289cfb87bdd446
testTopLevelUnions
public void testTopLevelUnions()
{        shouldGetProjectedSchema("aLong/**", "aLong", "message ParquetSchema {\n" + "  optional group aString = 1 {\n" + "    required binary s (UTF8) = 1;\n" + "  }\n" + "  optional group aLong = 2 {\n" + "    required int64 l = 1;\n" + "  }\n" + "  optional group aNewBool = 3 {\n" + "    required boolean b = 1;\n" + "  }\n" + "}", UnionV2.class);            shouldGetProjectedSchema("aNewBool/**", "aNewBool", "message ParquetSchema {\n" + "  optional group structV3 = 1 {\n" + "    required binary name (UTF8) = 1;\n" + "  }\n" + "  optional group structV4 = 2 {\n" + "    required binary name (UTF8) = 1;\n" + "  }\n" + "  optional group aNewBool = 3 {\n" + "    required boolean b = 1;\n" + "  }\n" + "}", UnionOfStructs.class);}
7aec6e22f22207fa72dfaf9f17a356060b94343aba47074dc8715eab9facec09
optionalUnionShouldBeDropped
public void optionalUnionShouldBeDropped()
{    shouldGetProjectedSchema("name", "name", "message ParquetSchema {\n" + "  required binary name (UTF8) = 1;\n" + "}", StructWithOptionalUnionOfStructs.class);}
1229b1b0cf8c16362156b39087d2051823a455bd224235d88aee8a7175fae22c
optionalUnionInRequiredStructShouldBeDropped
public void optionalUnionInRequiredStructShouldBeDropped()
{    shouldGetProjectedSchema("name", "name", "message ParquetSchema {\n" + "  required binary name (UTF8) = 1;\n" + "}", OptionalInsideRequired.class);}
dde017c596038b7317265d41c082910c30799bd53f5657451b3a6161adc1e4f7
requiredUnionInsideOptionalStructShouldBeDropped
public void requiredUnionInsideOptionalStructShouldBeDropped()
{        shouldGetProjectedSchema("name", "name", "message ParquetSchema {\n" + "  required binary name (UTF8) = 1;\n" + "}", RequiredInsideOptional.class);}
5877777fc035dbe1d5dfbeb3d503cdf0ba8a4117632fcd30596ba45e8c95fd9d
requiredUnionInsideOptionalStructShouldBeKeptIfParentSelected
public void requiredUnionInsideOptionalStructShouldBeKeptIfParentSelected()
{    shouldGetProjectedSchema("aStruct/name", "aStruct.name", "message ParquetSchema {\n" + "  optional group aStruct = 2 {\n" + "    required binary name (UTF8) = 1;\n" + "    required group aUnion = 2 {\n" + "      optional group structV3 = 1 {\n" + "        required binary name (UTF8) = 1;\n" + "      }\n" + "      optional group structV4 = 2 {\n" + "        required binary name (UTF8) = 1;\n" + "      }\n" + "      optional group aNewBool = 3 {\n" + "        required boolean b = 1;\n" + "      }\n" + "    }\n" + "  }\n" + "}", RequiredInsideOptional.class);}
72821862c996d51b94cc1e4b085fc55dddab8374e12d7b1951b6a699858fdde2
selectingOneUnionMemberKeepsSentinels
public void selectingOneUnionMemberKeepsSentinels()
{    shouldGetProjectedSchema("aUnion/structV4/addedStruct/gender", "aUnion.structV4.addedStruct.gender", "message ParquetSchema {\n" + "  optional group aUnion = 2 {\n" + "    optional group structV3 = 1 {\n" + "      required binary name (UTF8) = 1;\n" + "    }\n" + "    optional group structV4 = 2 {\n" + "      optional group addedStruct = 4 {\n" + "        optional binary gender (UTF8) = 3;\n" + "      }\n" + "    }\n" + "    optional group aNewBool = 3 {\n" + "      required boolean b = 1;\n" + "    }\n" + "  }\n" + "}", StructWithOptionalUnionOfStructs.class);}
1b6eb2272b7c95ebdbdbd1f9e9183903794f3483b1d25563da85346843309548
testUnionInsideUnion
public void testUnionInsideUnion()
{    shouldGetProjectedSchema("structV3/age", "structV3.age", "message ParquetSchema {\n" + "  optional group structV3 = 1 {\n" + "    optional binary age (UTF8) = 2;\n" + "  }\n" + "  optional group unionOfStructs = 2 {\n" + "    optional group structV3 = 1 {\n" + "      required binary name (UTF8) = 1;\n" + "    }\n" + "    optional group structV4 = 2 {\n" + "      required binary name (UTF8) = 1;\n" + "    }\n" + "    optional group aNewBool = 3 {\n" + "      required boolean b = 1;\n" + "    }\n" + "  }\n" + "  optional group aLong = 3 {\n" + "    required int64 l = 1;\n" + "  }\n" + "}", NestedUnion.class);    shouldGetProjectedSchema("unionOfStructs/structV4/addedStruct/gender", "unionOfStructs.structV4.addedStruct.gender", "message ParquetSchema {\n" + "  optional group structV3 = 1 {\n" + "    required binary name (UTF8) = 1;\n" + "  }\n" + "  optional group unionOfStructs = 2 {\n" + "    optional group structV3 = 1 {\n" + "      required binary name (UTF8) = 1;\n" + "    }\n" + "    optional group structV4 = 2 {\n" + "      optional group addedStruct = 4 {\n" + "        optional binary gender (UTF8) = 3;\n" + "      }\n" + "    }\n" + "    optional group aNewBool = 3 {\n" + "      required boolean b = 1;\n" + "    }\n" + "  }\n" + "  optional group aLong = 3 {\n" + "    required int64 l = 1;\n" + "  }\n" + "}\n", NestedUnion.class);    shouldGetProjectedSchema("unionV2/aLong/**", "unionV2.aLong", "message ParquetSchema {\n" + "  optional group nestedUnion = 1 {\n" + "    optional group structV3 = 1 {\n" + "      required binary name (UTF8) = 1;\n" + "    }\n" + "    optional group unionOfStructs = 2 {\n" + "      optional group structV3 = 1 {\n" + "        required binary name (UTF8) = 1;\n" + "      }\n" + "      optional group structV4 = 2 {\n" + "        required binary name (UTF8) = 1;\n" + "      }\n" + "      optional group aNewBool = 3 {\n" + "        required boolean b = 1;\n" + "      }\n" + "    }\n" + "    optional group aLong = 3 {\n" + "      required int64 l = 1;\n" + "    }\n" + "  }\n" + "  optional group unionV2 = 2 {\n" + "    optional group aString = 1 {\n" + "      required binary s (UTF8) = 1;\n" + "    }\n" + "    optional group aLong = 2 {\n" + "      required int64 l = 1;\n" + "    }\n" + "    optional group aNewBool = 3 {\n" + "      required boolean b = 1;\n" + "    }\n" + "  }\n" + "}", NestedNestedUnion.class);}
affcd9f5fb3288aabc065bd38cd52a46074be5f4eb5411aa793ab8ca0776e145
testListOfUnions
public void testListOfUnions()
{                    shouldGetProjectedSchema("optListUnion/structV3/age", "optListUnion.structV3.age", "message ParquetSchema {\n" + "  optional group optListUnion (LIST) = 1 {\n" + "    repeated group optListUnion_tuple {\n" + "      optional group structV3 = 1 {\n" + "        optional binary age (UTF8) = 2;\n" + "      }\n" + "      optional group structV4 = 2 {\n" + "        required binary name (UTF8) = 1;\n" + "      }\n" + "      optional group aNewBool = 3 {\n" + "        required boolean b = 1;\n" + "      }\n" + "    }\n" + "  }\n" + "}", ListOfUnions.class);            shouldGetProjectedSchema("reqListUnion/structV3/age", "reqListUnion.structV3.age", "message ParquetSchema {\n" + "  required group reqListUnion (LIST) = 2 {\n" + "    repeated group reqListUnion_tuple {\n" + "      optional group structV3 = 1 {\n" + "        optional binary age (UTF8) = 2;\n" + "      }\n" + "      optional group structV4 = 2 {\n" + "        required binary name (UTF8) = 1;\n" + "      }\n" + "      optional group aNewBool = 3 {\n" + "        required boolean b = 1;\n" + "      }\n" + "    }\n" + "  }\n" + "}", ListOfUnions.class);}
43144fe9a0c239de3cc8a5698d31dd37077a9ebe4a5cad8b227eee2e9c4a6999
testMapWithUnionKey
public void testMapWithUnionKey()
{    shouldGetProjectedSchema("optMapWithUnionKey/key/**", "optMapWithUnionKey.key", "message ParquetSchema {\n" + "  optional group optMapWithUnionKey (MAP) = 1 {\n" + "    repeated group map (MAP_KEY_VALUE) {\n" + "      required group key {\n" + "        optional group structV3 = 1 {\n" + "          required binary name (UTF8) = 1;\n" + "          optional binary age (UTF8) = 2;\n" + "          optional binary gender (UTF8) = 3;\n" + "        }\n" + "        optional group structV4 = 2 {\n" + "          required binary name (UTF8) = 1;\n" + "          optional binary age (UTF8) = 2;\n" + "          optional binary gender (UTF8) = 3;\n" + "          optional group addedStruct = 4 {\n" + "            required binary name (UTF8) = 1;\n" + "            optional binary age (UTF8) = 2;\n" + "            optional binary gender (UTF8) = 3;\n" + "          }\n" + "        }\n" + "        optional group aNewBool = 3 {\n" + "          required boolean b = 1;\n" + "        }\n" + "      }\n" + "      optional group value {\n" + "        required binary name (UTF8) = 1;\n" + "      } " + "    }\n" + "  }\n" + "}", MapWithUnionKey.class);    shouldGetProjectedSchema("optMapWithUnionKey/key/**;optMapWithUnionKey/value/gender", "optMapWithUnionKey.{key,value.gender}", "message ParquetSchema {\n" + "  optional group optMapWithUnionKey (MAP) = 1 {\n" + "    repeated group map (MAP_KEY_VALUE) {\n" + "      required group key {\n" + "        optional group structV3 = 1 {\n" + "          required binary name (UTF8) = 1;\n" + "          optional binary age (UTF8) = 2;\n" + "          optional binary gender (UTF8) = 3;\n" + "        }\n" + "        optional group structV4 = 2 {\n" + "          required binary name (UTF8) = 1;\n" + "          optional binary age (UTF8) = 2;\n" + "          optional binary gender (UTF8) = 3;\n" + "          optional group addedStruct = 4 {\n" + "            required binary name (UTF8) = 1;\n" + "            optional binary age (UTF8) = 2;\n" + "            optional binary gender (UTF8) = 3;\n" + "          }\n" + "        }\n" + "        optional group aNewBool = 3 {\n" + "          required boolean b = 1;\n" + "        }\n" + "      }\n" + "      optional group value {\n" + "        optional binary gender (UTF8) = 3;\n" + "      }\n" + "    }\n" + "  }\n" + "}", MapWithUnionKey.class);}
7a2dbada60b5477b54e938028b3231bb13fbc9f0720c1ce0b37fd0b5fbdd867c
testMapWithUnionValue
public void testMapWithUnionValue()
{    shouldGetProjectedSchema("optMapWithUnionValue/key/**;optMapWithUnionValue/value/structV4/addedStruct/gender", "optMapWithUnionValue.{key,value.structV4.addedStruct.gender}", "message ParquetSchema {\n" + "  optional group optMapWithUnionValue (MAP) = 1 {\n" + "    repeated group map (MAP_KEY_VALUE) {\n" + "      required group key {\n" + "        required binary name (UTF8) = 1;\n" + "        optional binary age (UTF8) = 2;\n" + "        optional binary gender (UTF8) = 3;\n" + "      }\n" + "      optional group value {\n" + "        optional group structV3 = 1 {\n" + "          required binary name (UTF8) = 1;\n" + "        }\n" + "        optional group structV4 = 2 {\n" + "          optional group addedStruct = 4 {\n" + "            optional binary gender (UTF8) = 3;\n" + "          }\n" + "        }\n" + "        optional group aNewBool = 3 {\n" + "          required boolean b = 1;\n" + "        }\n" + "      }\n" + "    }\n" + "  }\n" + "}", MapWithUnionValue.class);}
0f27bae498ce8f54f99e40069471514742e443ef18e8c2f3e6a420eef7451bff
testMessyNestedUnions
public void testMessyNestedUnions()
{    shouldGetProjectedSchema("reqStructWithUnionV2/name", "reqStructWithUnionV2.name", "message ParquetSchema {\n" + "  required group reqUnionOfStructs = 2 {\n" + "    optional group structV3 = 1 {\n" + "      required binary name (UTF8) = 1;\n" + "    }\n" + "    optional group structV4 = 2 {\n" + "      required binary name (UTF8) = 1;\n" + "    }\n" + "    optional group aNewBool = 3 {\n" + "      required boolean b = 1;\n" + "    }\n" + "  }\n" + "  required group reqNestedUnion = 5 {\n" + "    optional group structV3 = 1 {\n" + "      required binary name (UTF8) = 1;\n" + "    }\n" + "    optional group unionOfStructs = 2 {\n" + "      optional group structV3 = 1 {\n" + "        required binary name (UTF8) = 1;\n" + "      }\n" + "      optional group structV4 = 2 {\n" + "        required binary name (UTF8) = 1;\n" + "      }\n" + "      optional group aNewBool = 3 {\n" + "        required boolean b = 1;\n" + "      }\n" + "    }\n" + "    optional group aLong = 3 {\n" + "      required int64 l = 1;\n" + "    }\n" + "  }\n" + "  required group reqStructWithUnionV2 = 8 {\n" + "    required binary name (UTF8) = 1;\n" + "    required group aUnion = 2 {\n" + "      optional group aString = 1 {\n" + "        required binary s (UTF8) = 1;\n" + "      }\n" + "      optional group aLong = 2 {\n" + "        required int64 l = 1;\n" + "      }\n" + "      optional group aNewBool = 3 {\n" + "        required boolean b = 1;\n" + "      }\n" + "    }\n" + "  }\n" + "  required group reqUnionStructUnion = 11 {\n" + "    optional group structV3 = 1 {\n" + "      required binary name (UTF8) = 1;\n" + "    }\n" + "    optional group structWithUnionOfStructs = 2 {\n" + "      required binary name (UTF8) = 1;\n" + "      required group aUnion = 2 {\n" + "        optional group structV3 = 1 {\n" + "          required binary name (UTF8) = 1;\n" + "        }\n" + "        optional group structV4 = 2 {\n" + "          required binary name (UTF8) = 1;\n" + "        }\n" + "        optional group aNewBool = 3 {\n" + "          required boolean b = 1;\n" + "        }\n" + "      }\n" + "    }\n" + "    optional group aLong = 3 {\n" + "      required int64 l = 1;\n" + "    }\n" + "  }\n" + "}", StructWithNestedUnion.class);}
7e3f62689a52f5cfc8f5889d1068814d43f1f4feaa85df375762f0f9cb0ab82c
testMap
public void testMap() throws Exception
{    Map<String, String> map = new TreeMap<String, String>();    map.put("foo", "bar");    map.put("foo2", "bar2");    TestMap testMap = new TestMap("map_name", map);    validateSameTupleAsEB(testMap);}
e4903de046eccf727b541797bf46b5df0065572d65177ab8507bca58b6ad6d75
testMapInSet
public void testMapInSet() throws Exception
{    final Set<Map<String, String>> set = new HashSet<Map<String, String>>();    final Map<String, String> map = new HashMap<String, String>();    map.put("foo", "bar");    set.add(map);    TestMapInSet o = new TestMapInSet("top", set);    validateSameTupleAsEB(o);}
6a64abc82bed9075ee92449a7f1f42698adea155c4f8b809c5b80a67b55913a3
testStructInMap
public void testStructInMap() throws Exception
{    final Map<String, TestPerson> map = new HashMap<String, TestPerson>();    map.put("foo", new TestPerson(new TestName("john", "johnson"), new HashMap<TestPhoneType, String>()));    final Map<String, Integer> stringToIntMap = Collections.singletonMap("bar", 10);    TestStructInMap testMap = new TestStructInMap("map_name", map, stringToIntMap);    validateSameTupleAsEB(testMap);}
fe592a25c5e8690cd8f353d0ffacc6b06484632aad2642f2fabb01c111ec2ef5
testProtocolEmptyAdressBook
public void testProtocolEmptyAdressBook() throws Exception
{    AddressBook a = new AddressBook(new ArrayList<Person>());    validateSameTupleAsEB(a);}
f3fd308d0f8d50e5318303478e1e8bd4595597309ed0aded36e40bdf37882576
testProtocolAddressBook
public void testProtocolAddressBook() throws Exception
{    ArrayList<Person> persons = new ArrayList<Person>();    final PhoneNumber phoneNumber = new PhoneNumber("555 999 9998");    phoneNumber.type = PhoneType.HOME;    persons.add(new Person(new Name("Bob", "Roberts"), 1, "bob@roberts.com", Arrays.asList(new PhoneNumber("555 999 9999"), phoneNumber)));    persons.add(new Person(new Name("Dick", "Richardson"), 2, "dick@richardson.com", Arrays.asList(new PhoneNumber("555 999 9997"), new PhoneNumber("555 999 9996"))));    AddressBook a = new AddressBook(persons);    validateSameTupleAsEB(a);}
4956efdc015ad8d1c1a671bb363e04c3443aa9b2b59d91fb546b9309c4d71d41
testOneOfEach
public void testOneOfEach() throws Exception
{    OneOfEach a = new OneOfEach(true, false, (byte) 8, (short) 16, (int) 32, (long) 64, (double) 1234, "string", "", false, ByteBuffer.wrap("a".getBytes()), new ArrayList<Byte>(), new ArrayList<Short>(), new ArrayList<Long>());    validateSameTupleAsEB(a);}
d1e15b2887c002cc978d5f1db9a1f8f50470d4cdd4be2518023ecd73c679e68c
testStringList
public void testStringList() throws Exception
{    final List<String> names = new ArrayList<String>();    names.add("John");    names.add("Jack");    TestNameList o = new TestNameList("name", names);    validateSameTupleAsEB(o);}
c9c82c10934e0bdce11e8721e80c2798199acab25e4f49b6f2ebecfb615ac934
validateSameTupleAsEB
public static void validateSameTupleAsEB(T o) throws TException
{    final ThriftSchemaConverter thriftSchemaConverter = new ThriftSchemaConverter();    @SuppressWarnings("unchecked")    final Class<T> class1 = (Class<T>) o.getClass();    final MessageType schema = thriftSchemaConverter.convert(class1);    final StructType structType = ThriftSchemaConverter.toStructType(class1);    final ThriftToPig<T> thriftToPig = new ThriftToPig<T>(class1);    final Schema pigSchema = thriftToPig.toSchema();    final TupleRecordMaterializer tupleRecordConverter = new TupleRecordMaterializer(schema, pigSchema, true);    RecordConsumer recordConsumer = new ConverterConsumer(tupleRecordConverter.getRootConverter(), schema);    final MessageColumnIO columnIO = new ColumnIOFactory().getColumnIO(schema);    ParquetWriteProtocol p = new ParquetWriteProtocol(new RecordConsumerLoggingWrapper(recordConsumer), columnIO, structType);    o.write(p);    final Tuple t = tupleRecordConverter.getCurrentRecord();    final Tuple expected = thriftToPig.getPigTuple(o);    assertEquals(expected.toString(), t.toString());    final MessageType filtered = new PigSchemaConverter().filter(schema, pigSchema);    assertEquals(schema.toString(), filtered.toString());}
bcd19f19c20c3bf0efb79bd48a250a1ad3af5cb6a832cbb160a9bc4245aee013
getOptions
public Options getOptions()
{    return null;}
87e68426860c663406a6b19d1af73970389935e15e4fcf00bf6314932b4b1706
supportsExtraArgs
public boolean supportsExtraArgs()
{    return true;}
c63b549756ae91b22099f01f710e7ada88960927f17b2134089e5c09ff4ee74b
execute
public void execute(CommandLine options) throws Exception
{    String[] args = options.getArgs();    if (args.length < min) {        throw new MissingArgumentException("missing required arguments");    }    if (args.length > max) {        throw new UnrecognizedOptionException("unknown extra argument \"" + args[max] + "\"");    }}
56ceb412c211e3518987f7bc500fc8e7aa497e7baff0552369315cfc4fd41555
getUsageDescription
public String[] getUsageDescription()
{    return USAGE;}
d6dbafa30c24af868522f3f3ef6a5e96d385df0c6d95ce5477510e7a9be34d4a
getCommandDescription
public String getCommandDescription()
{    return "Prints the content of a Parquet file. The output contains only the data, no metadata is displayed";}
bcd19f19c20c3bf0efb79bd48a250a1ad3af5cb6a832cbb160a9bc4245aee013
getOptions
public Options getOptions()
{    return OPTIONS;}
c63b549756ae91b22099f01f710e7ada88960927f17b2134089e5c09ff4ee74b
execute
public void execute(CommandLine options) throws Exception
{    super.execute(options);    String[] args = options.getArgs();    String input = args[0];    ParquetReader<SimpleRecord> reader = null;    try {        PrintWriter writer = new PrintWriter(Main.out, true);        reader = ParquetReader.builder(new SimpleReadSupport(), new Path(input)).build();        ParquetMetadata metadata = ParquetFileReader.readFooter(new Configuration(), new Path(input));        JsonRecordFormatter.JsonGroupFormatter formatter = JsonRecordFormatter.fromSchema(metadata.getFileMetaData().getSchema());        for (SimpleRecord value = reader.read(); value != null; value = reader.read()) {            if (options.hasOption('j')) {                writer.write(formatter.formatRecord(value));            } else {                value.prettyPrint(writer);            }            writer.println();        }    } finally {        if (reader != null) {            try {                reader.close();            } catch (Exception ex) {            }        }    }}
56ceb412c211e3518987f7bc500fc8e7aa497e7baff0552369315cfc4fd41555
getUsageDescription
public String[] getUsageDescription()
{    return USAGE;}
d6dbafa30c24af868522f3f3ef6a5e96d385df0c6d95ce5477510e7a9be34d4a
getCommandDescription
public String getCommandDescription()
{    return "Prints the column and offset indexes of a Parquet file.";}
bcd19f19c20c3bf0efb79bd48a250a1ad3af5cb6a832cbb160a9bc4245aee013
getOptions
public Options getOptions()
{    return OPTIONS;}
c63b549756ae91b22099f01f710e7ada88960927f17b2134089e5c09ff4ee74b
execute
public void execute(CommandLine options) throws Exception
{    super.execute(options);    String[] args = options.getArgs();    InputFile in = HadoopInputFile.fromPath(new Path(args[0]), new Configuration());    PrintWriter out = new PrintWriter(Main.out, true);    String rowGroupValue = options.getOptionValue("r");    Set<String> indexes = new HashSet<>();    if (rowGroupValue != null) {        indexes.addAll(Arrays.asList(rowGroupValue.split("\\s*,\\s*")));    }    boolean showColumnIndex = options.hasOption("i");    boolean showOffsetIndex = options.hasOption("o");    if (!showColumnIndex && !showOffsetIndex) {        showColumnIndex = true;        showOffsetIndex = true;    }    try (ParquetFileReader reader = ParquetFileReader.open(in)) {        boolean firstBlock = true;        int rowGroupIndex = 0;        for (BlockMetaData block : reader.getFooter().getBlocks()) {            if (!indexes.isEmpty() && !indexes.contains(Integer.toString(rowGroupIndex))) {                ++rowGroupIndex;                continue;            }            if (!firstBlock) {                out.println();                firstBlock = false;            }            out.format("row group %d:%n", rowGroupIndex);            for (ColumnChunkMetaData column : getColumns(block, options)) {                String path = column.getPath().toDotString();                if (showColumnIndex) {                    out.format("column index for column %s:%n", path);                    ColumnIndex columnIndex = reader.readColumnIndex(column);                    if (columnIndex == null) {                        out.println("NONE");                    } else {                        out.println(columnIndex);                    }                }                if (showOffsetIndex) {                    out.format("offset index for column %s:%n", path);                    OffsetIndex offsetIndex = reader.readOffsetIndex(column);                    if (offsetIndex == null) {                        out.println("NONE");                    } else {                        out.println(offsetIndex);                    }                }            }            ++rowGroupIndex;        }    }}
a3f7a8ed1b003487eca2c186bb851c18ef5055e192d2dab656163bb860714ebb
getColumns
private static List<ColumnChunkMetaData> getColumns(BlockMetaData block, CommandLine options)
{    List<ColumnChunkMetaData> columns = block.getColumns();    String pathValue = options.getOptionValue("c");    if (pathValue == null) {        return columns;    }    String[] paths = pathValue.split("\\s*,\\s*");    Map<String, ColumnChunkMetaData> pathMap = new HashMap<>();    for (ColumnChunkMetaData column : columns) {        pathMap.put(column.getPath().toDotString(), column);    }    List<ColumnChunkMetaData> filtered = new ArrayList<>();    for (String path : paths) {        ColumnChunkMetaData column = pathMap.get(path);        if (column != null) {            filtered.add(column);        }    }    return filtered;}
bcd19f19c20c3bf0efb79bd48a250a1ad3af5cb6a832cbb160a9bc4245aee013
getOptions
public Options getOptions()
{    return OPTIONS;}
56ceb412c211e3518987f7bc500fc8e7aa497e7baff0552369315cfc4fd41555
getUsageDescription
public String[] getUsageDescription()
{    return USAGE;}
d6dbafa30c24af868522f3f3ef6a5e96d385df0c6d95ce5477510e7a9be34d4a
getCommandDescription
public String getCommandDescription()
{    return "Prints the content and metadata of a Parquet file";}
c63b549756ae91b22099f01f710e7ada88960927f17b2134089e5c09ff4ee74b
execute
public void execute(CommandLine options) throws Exception
{    super.execute(options);    String[] args = options.getArgs();    String input = args[0];    Configuration conf = new Configuration();    Path inpath = new Path(input);    ParquetMetadata metaData = ParquetFileReader.readFooter(conf, inpath, NO_FILTER);    MessageType schema = metaData.getFileMetaData().getSchema();    boolean showmd = !options.hasOption('m');    boolean showdt = !options.hasOption('d');    boolean cropoutput = !options.hasOption('n');    Set<String> showColumns = null;    if (options.hasOption('c')) {        String[] cols = options.getOptionValues('c');        showColumns = new HashSet<String>(Arrays.asList(cols));    }    PrettyPrintWriter out = prettyPrintWriter(cropoutput);    dump(out, metaData, schema, inpath, showmd, showdt, showColumns);}
50cfc01df0e4e6b09c299af49d40962f1c56eba9624060a29093c0fd2f6f3a93
dump
public static void dump(PrettyPrintWriter out, ParquetMetadata meta, MessageType schema, Path inpath, boolean showmd, boolean showdt, Set<String> showColumns) throws IOException
{    Configuration conf = new Configuration();    List<BlockMetaData> blocks = meta.getBlocks();    List<ColumnDescriptor> columns = schema.getColumns();    if (showColumns != null) {        columns = new ArrayList<ColumnDescriptor>();        for (ColumnDescriptor column : schema.getColumns()) {            String path = Joiner.on('.').skipNulls().join(column.getPath());            if (showColumns.contains(path)) {                columns.add(column);            }        }    }    ParquetFileReader freader = null;    if (showmd) {        try {            long group = 0;            for (BlockMetaData block : blocks) {                if (group != 0)                    out.println();                out.format("row group %d%n", group++);                out.rule('-');                List<ColumnChunkMetaData> ccmds = block.getColumns();                if (showColumns != null) {                    ccmds = new ArrayList<ColumnChunkMetaData>();                    for (ColumnChunkMetaData ccmd : block.getColumns()) {                        String path = Joiner.on('.').skipNulls().join(ccmd.getPath().toArray());                        if (showColumns.contains(path)) {                            ccmds.add(ccmd);                        }                    }                }                MetadataUtils.showDetails(out, ccmds);                List<BlockMetaData> rblocks = Collections.singletonList(block);                freader = new ParquetFileReader(conf, meta.getFileMetaData(), inpath, rblocks, columns);                PageReadStore store = freader.readNextRowGroup();                while (store != null) {                    out.incrementTabLevel();                    for (ColumnDescriptor column : columns) {                        out.println();                        dump(out, store, column);                    }                    out.decrementTabLevel();                    store = freader.readNextRowGroup();                }                out.flushColumns();            }        } finally {            if (freader != null) {                freader.close();            }        }    }    if (showdt) {        boolean first = true;        for (ColumnDescriptor column : columns) {            if (!first || showmd)                out.println();            first = false;            out.format("%s %s%n", column.getType(), Joiner.on('.').skipNulls().join(column.getPath()));            out.rule('-');            try {                long page = 1;                long total = blocks.size();                long offset = 1;                freader = new ParquetFileReader(conf, meta.getFileMetaData(), inpath, blocks, Collections.singletonList(column));                PageReadStore store = freader.readNextRowGroup();                while (store != null) {                    ColumnReadStoreImpl crstore = new ColumnReadStoreImpl(store, new DumpGroupConverter(), schema, meta.getFileMetaData().getCreatedBy());                    dump(out, crstore, column, page++, total, offset);                    offset += store.getRowCount();                    store = freader.readNextRowGroup();                }                out.flushColumns();            } finally {                out.flushColumns();                if (freader != null) {                    freader.close();                }            }        }    }}
5471dfd666618c925c3503db38cb59aa3b03241e45c6723814da45c8dd17e3e9
verifyCrc
private static boolean verifyCrc(int referenceCrc, byte[] bytes)
{    crc.reset();    crc.update(bytes);    return crc.getValue() == ((long) referenceCrc & 0xffffffffL);}
0d896688acd1a1ac89b4489f19742a4068891cfde4fd1659137bb33cf384f20d
dump
public static void dump(final PrettyPrintWriter out, PageReadStore store, ColumnDescriptor column) throws IOException
{    PageReader reader = store.getPageReader(column);    long vc = reader.getTotalValueCount();    int rmax = column.getMaxRepetitionLevel();    int dmax = column.getMaxDefinitionLevel();    out.format("%s TV=%d RL=%d DL=%d", Joiner.on('.').skipNulls().join(column.getPath()), vc, rmax, dmax);    DictionaryPage dict = reader.readDictionaryPage();    if (dict != null) {        out.format(" DS:%d", dict.getDictionarySize());        out.format(" DE:%s", dict.getEncoding());    }    out.println();    out.rule('-');    DataPage page = reader.readPage();    for (long count = 0; page != null; count++) {        out.format("page %d:", count);        page.accept(new Visitor<Void>() {            @Override            public Void visit(DataPageV1 pageV1) {                out.format(" DLE:%s", pageV1.getDlEncoding());                out.format(" RLE:%s", pageV1.getRlEncoding());                out.format(" VLE:%s", pageV1.getValueEncoding());                Statistics<?> statistics = pageV1.getStatistics();                if (statistics != null) {                    out.format(" ST:[%s]", statistics);                } else {                    out.format(" ST:[none]");                }                if (pageV1.getCrc().isPresent()) {                    try {                        out.format(" CRC:%s", verifyCrc(pageV1.getCrc().getAsInt(), pageV1.getBytes().toByteArray()) ? "[verified]" : "[PAGE CORRUPT]");                    } catch (IOException e) {                        out.format(" CRC:[error getting page bytes]");                    }                } else {                    out.format(" CRC:[none]");                }                return null;            }            @Override            public Void visit(DataPageV2 pageV2) {                out.format(" DLE:RLE");                out.format(" RLE:RLE");                out.format(" VLE:%s", pageV2.getDataEncoding());                Statistics<?> statistics = pageV2.getStatistics();                if (statistics != null) {                    out.format(" ST:[%s]", statistics);                } else {                    out.format(" ST:[none]");                }                return null;            }        });        out.format(" SZ:%d", page.getUncompressedSize());        out.format(" VC:%d", page.getValueCount());        out.println();        page = reader.readPage();    }}
99b893b0f8d2da706ade7eccd7ab3aa6238ecdc7362606e46699d8273ac094bc
visit
public Void visit(DataPageV1 pageV1)
{    out.format(" DLE:%s", pageV1.getDlEncoding());    out.format(" RLE:%s", pageV1.getRlEncoding());    out.format(" VLE:%s", pageV1.getValueEncoding());    Statistics<?> statistics = pageV1.getStatistics();    if (statistics != null) {        out.format(" ST:[%s]", statistics);    } else {        out.format(" ST:[none]");    }    if (pageV1.getCrc().isPresent()) {        try {            out.format(" CRC:%s", verifyCrc(pageV1.getCrc().getAsInt(), pageV1.getBytes().toByteArray()) ? "[verified]" : "[PAGE CORRUPT]");        } catch (IOException e) {            out.format(" CRC:[error getting page bytes]");        }    } else {        out.format(" CRC:[none]");    }    return null;}
2705a8a4ba6c7c715347e1f5ecdbb06100378705a66ace3542bfb7891d898def
visit
public Void visit(DataPageV2 pageV2)
{    out.format(" DLE:RLE");    out.format(" RLE:RLE");    out.format(" VLE:%s", pageV2.getDataEncoding());    Statistics<?> statistics = pageV2.getStatistics();    if (statistics != null) {        out.format(" ST:[%s]", statistics);    } else {        out.format(" ST:[none]");    }    return null;}
99f834f1dc076f6b3bf2f0ab8087a9a3e1bc20e2c004ff47f36cea8ff37580ed
dump
public static void dump(PrettyPrintWriter out, ColumnReadStoreImpl crstore, ColumnDescriptor column, long page, long total, long offset) throws IOException
{    int dmax = column.getMaxDefinitionLevel();    ColumnReader creader = crstore.getColumnReader(column);    out.format("*** row group %d of %d, values %d to %d ***%n", page, total, offset, offset + creader.getTotalValueCount() - 1);    for (long i = 0, e = creader.getTotalValueCount(); i < e; ++i) {        int rlvl = creader.getCurrentRepetitionLevel();        int dlvl = creader.getCurrentDefinitionLevel();        out.format("value %d: R:%d D:%d V:", offset + i, rlvl, dlvl);        if (dlvl == dmax) {            PrimitiveStringifier stringifier = column.getPrimitiveType().stringifier();            switch(column.getType()) {                case FIXED_LEN_BYTE_ARRAY:                case INT96:                case BINARY:                    out.print(stringifier.stringify(creader.getBinary()));                    break;                case BOOLEAN:                    out.print(stringifier.stringify(creader.getBoolean()));                    break;                case DOUBLE:                    out.print(stringifier.stringify(creader.getDouble()));                    break;                case FLOAT:                    out.print(stringifier.stringify(creader.getFloat()));                    break;                case INT32:                    out.print(stringifier.stringify(creader.getInteger()));                    break;                case INT64:                    out.print(stringifier.stringify(creader.getLong()));                    break;            }        } else {            out.format("<null>");        }        out.println();        creader.consume();    }}
be5de781123fc387ff98b6aae108b4b5bdf199045365e5c0e0a02d717d9cbd1e
binaryToString
public static String binaryToString(Binary value)
{    byte[] data = value.getBytesUnsafe();    if (data == null)        return null;    try {        CharBuffer buffer = UTF8_DECODER.decode(value.toByteBuffer());        return buffer.toString();    } catch (Exception ex) {    }    return "<bytes...>";}
11a81a270313cf57825ab92aeb8562a82923bdfa02bcb4d0c15a7a42cbc97d04
binaryToBigInteger
public static BigInteger binaryToBigInteger(Binary value)
{    byte[] data = value.getBytesUnsafe();    if (data == null)        return null;    return new BigInteger(data);}
c913753273969d685569a46fda19cc510f56adc3f3f6862bcb880d6d8a6f633c
prettyPrintWriter
private static PrettyPrintWriter prettyPrintWriter(boolean cropOutput)
{    PrettyPrintWriter.Builder builder = PrettyPrintWriter.stdoutPrettyPrinter().withAutoColumn().withWhitespaceHandler(WhiteSpaceHandler.ELIMINATE_NEWLINES).withColumnPadding(1).withMaxBufferedLines(1000000).withFlushOnTab();    if (cropOutput) {        builder.withAutoCrop();    }    return builder.build();}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    return new DumpConverter();}
341d5da74353d6912781bcc5ff7e4f63d6afaa99f5625d597ad0200315691ac3
asGroupConverter
public GroupConverter asGroupConverter()
{    return new DumpGroupConverter();}
bcd19f19c20c3bf0efb79bd48a250a1ad3af5cb6a832cbb160a9bc4245aee013
getOptions
public Options getOptions()
{    return OPTIONS;}
56ceb412c211e3518987f7bc500fc8e7aa497e7baff0552369315cfc4fd41555
getUsageDescription
public String[] getUsageDescription()
{    return USAGE;}
d6dbafa30c24af868522f3f3ef6a5e96d385df0c6d95ce5477510e7a9be34d4a
getCommandDescription
public String getCommandDescription()
{    return "Prints the first n record of the Parquet file";}
c63b549756ae91b22099f01f710e7ada88960927f17b2134089e5c09ff4ee74b
execute
public void execute(CommandLine options) throws Exception
{    super.execute(options);    long num = DEFAULT;    if (options.hasOption('n')) {        num = Long.parseLong(options.getOptionValue('n'));    }    String[] args = options.getArgs();    String input = args[0];    ParquetReader<SimpleRecord> reader = null;    try {        PrintWriter writer = new PrintWriter(Main.out, true);        reader = ParquetReader.builder(new SimpleReadSupport(), new Path(input)).build();        for (SimpleRecord value = reader.read(); value != null && num-- > 0; value = reader.read()) {            value.prettyPrint(writer);            writer.println();        }    } finally {        if (reader != null) {            try {                reader.close();            } catch (Exception ex) {            }        }    }}
56ceb412c211e3518987f7bc500fc8e7aa497e7baff0552369315cfc4fd41555
getUsageDescription
public String[] getUsageDescription()
{    return USAGE;}
d6dbafa30c24af868522f3f3ef6a5e96d385df0c6d95ce5477510e7a9be34d4a
getCommandDescription
public String getCommandDescription()
{    return "Merges multiple Parquet files into one. " + "The command doesn't merge row groups, just places one after the other. " + "When used to merge many small files, the resulting file will still contain small row groups, " + "which usually leads to bad query performance.";}
c63b549756ae91b22099f01f710e7ada88960927f17b2134089e5c09ff4ee74b
execute
public void execute(CommandLine options) throws Exception
{        List<String> args = options.getArgList();    List<Path> inputFiles = getInputFiles(args.subList(0, args.size() - 1));    Path outputFile = new Path(args.get(args.size() - 1));        FileMetaData mergedMeta = mergedMetadata(inputFiles);    PrintWriter out = new PrintWriter(Main.out, true);        ParquetFileWriter writer = new ParquetFileWriter(conf, mergedMeta.getSchema(), outputFile, ParquetFileWriter.Mode.CREATE);    writer.start();    boolean tooSmallFilesMerged = false;    for (Path input : inputFiles) {        if (input.getFileSystem(conf).getFileStatus(input).getLen() < TOO_SMALL_FILE_THRESHOLD) {            out.format("Warning: file %s is too small, length: %d\n", input, input.getFileSystem(conf).getFileStatus(input).getLen());            tooSmallFilesMerged = true;        }        writer.appendFile(HadoopInputFile.fromPath(input, conf));    }    if (tooSmallFilesMerged) {        out.println("Warning: you merged too small files. " + "Although the size of the merged file is bigger, it STILL contains small row groups, thus you don't have the advantage of big row groups, " + "which usually leads to bad query performance!");    }    writer.end(mergedMeta.getKeyValueMetaData());}
a57715c912ed771cdcf5d4e294c63a5e04da96508065a5e64f369c44e4af5690
mergedMetadata
private FileMetaData mergedMetadata(List<Path> inputFiles) throws IOException
{    return ParquetFileWriter.mergeMetadataFiles(inputFiles, conf).getFileMetaData();}
477648beaf7c2ef059a64b91a6bbd82bd0dae325eff5803090786cc6783972a1
getInputFiles
private List<Path> getInputFiles(List<String> input) throws IOException
{    List<Path> inputFiles = null;    if (input.size() == 1) {        Path p = new Path(input.get(0));        FileSystem fs = p.getFileSystem(conf);        FileStatus status = fs.getFileStatus(p);        if (status.isDir()) {            inputFiles = getInputFilesFromDirectory(status);        }    } else {        inputFiles = parseInputFiles(input);    }    checkParquetFiles(inputFiles);    return inputFiles;}
29284e7baddd19c6ce9e51e4a045e7459ce026a4f19157961dec4e1844815be8
checkParquetFiles
private void checkParquetFiles(List<Path> inputFiles) throws IOException
{    if (inputFiles == null || inputFiles.size() <= 1) {        throw new IllegalArgumentException("Not enough files to merge");    }    for (Path inputFile : inputFiles) {        FileSystem fs = inputFile.getFileSystem(conf);        FileStatus status = fs.getFileStatus(inputFile);        if (status.isDir()) {            throw new IllegalArgumentException("Illegal parquet file: " + inputFile.toUri());        }    }}
959a91f780c9fafc220a877c40ff703dc95a9ba752c00cd2956eb086e03f54c9
getInputFilesFromDirectory
private List<Path> getInputFilesFromDirectory(FileStatus partitionDir) throws IOException
{    FileSystem fs = partitionDir.getPath().getFileSystem(conf);    FileStatus[] inputFiles = fs.listStatus(partitionDir.getPath(), HiddenFileFilter.INSTANCE);    List<Path> input = new ArrayList<Path>();    for (FileStatus f : inputFiles) {        input.add(f.getPath());    }    return input;}
2f7fef1f2418b265fef217160a3b5c0e75b1f5e7b96b5efabd499c20690d219c
parseInputFiles
private List<Path> parseInputFiles(List<String> input)
{    List<Path> inputFiles = new ArrayList<Path>();    for (String name : input) {        inputFiles.add(new Path(name));    }    return inputFiles;}
5277f174dd3fa3bca0a5e9c602621c03b0fd649df115cfb115c6421080390148
showDetails
 static void showDetails(PrettyPrintWriter out, ParquetMetadata meta, boolean showOriginalTypes)
{    showDetails(out, meta.getFileMetaData(), showOriginalTypes);    long i = 1;    for (BlockMetaData bmeta : meta.getBlocks()) {        out.println();        showDetails(out, bmeta, i++);    }}
2a20cd9725b5b1b699bc64202b3d1fc248b36cbc3a13534cc3fa0fb6922e132f
showDetails
 static void showDetails(PrettyPrintWriter out, FileMetaData meta, boolean showOriginalTypes)
{    out.format("creator: %s%n", meta.getCreatedBy());    Map<String, String> extra = meta.getKeyValueMetaData();    if (extra != null) {        for (Map.Entry<String, String> entry : meta.getKeyValueMetaData().entrySet()) {            out.print("extra: ");            out.incrementTabLevel();            out.format("%s = %s%n", entry.getKey(), entry.getValue());            out.decrementTabLevel();        }    }    out.println();    out.format("file schema: %s%n", meta.getSchema().getName());    out.rule('-');    showDetails(out, meta.getSchema(), showOriginalTypes);}
e6bdf9f7b381d46f058332aefa2cac3b422054302a6f6079192bae6eed3875a3
showDetails
private static void showDetails(PrettyPrintWriter out, BlockMetaData meta, Long num)
{    long rows = meta.getRowCount();    long tbs = meta.getTotalByteSize();    long offset = meta.getStartingPos();    out.format("row group%s: RC:%d TS:%d OFFSET:%d%n", (num == null ? "" : " " + num), rows, tbs, offset);    out.rule('-');    showDetails(out, meta.getColumns());}
67048ab43045cb0ddf235eb9678f6d5f2b6c45eb297cd85c357c0585ac279e30
showDetails
 static void showDetails(PrettyPrintWriter out, List<ColumnChunkMetaData> ccmeta)
{    Map<String, Object> chunks = new LinkedHashMap<String, Object>();    for (ColumnChunkMetaData cmeta : ccmeta) {        String[] path = cmeta.getPath().toArray();        Map<String, Object> current = chunks;        for (int i = 0; i < path.length - 1; ++i) {            String next = path[i];            if (!current.containsKey(next)) {                current.put(next, new LinkedHashMap<String, Object>());            }            current = (Map<String, Object>) current.get(next);        }        current.put(path[path.length - 1], cmeta);    }    showColumnChunkDetails(out, chunks, 0);}
03a3d81f604bb541b3b8043bb09c5b348f9e2ea35a24bffbb8fd7c5f643cce1a
showColumnChunkDetails
private static void showColumnChunkDetails(PrettyPrintWriter out, Map<String, Object> current, int depth)
{    for (Map.Entry<String, Object> entry : current.entrySet()) {        String name = Strings.repeat(".", depth) + entry.getKey();        Object value = entry.getValue();        if (value instanceof Map) {            out.println(name + ": ");            showColumnChunkDetails(out, (Map<String, Object>) value, depth + 1);        } else {            out.print(name + ": ");            showDetails(out, (ColumnChunkMetaData) value, false);        }    }}
f5b639327ba6b9b94248e60c8ea73fdf378952c8f663d4ba9b09461c02fd9995
showDetails
private static void showDetails(PrettyPrintWriter out, ColumnChunkMetaData meta, boolean name)
{    long doff = meta.getDictionaryPageOffset();    long foff = meta.getFirstDataPageOffset();    long tsize = meta.getTotalSize();    long usize = meta.getTotalUncompressedSize();    long count = meta.getValueCount();    double ratio = usize / (double) tsize;    String encodings = Joiner.on(',').skipNulls().join(meta.getEncodings());    if (name) {        String path = Joiner.on('.').skipNulls().join(meta.getPath());        out.format("%s: ", path);    }    out.format(" %s", meta.getType());    out.format(" %s", meta.getCodec());    out.format(" DO:%d", doff);    out.format(" FPO:%d", foff);    out.format(" SZ:%d/%d/%.2f", tsize, usize, ratio);    out.format(" VC:%d", count);    if (!encodings.isEmpty())        out.format(" ENC:%s", encodings);    Statistics<?> stats = meta.getStatistics();    if (stats != null) {        out.format(" ST:[%s]", stats);    } else {        out.format(" ST:[none]");    }    out.println();}
9c5e4d1faa9ac23347e5ee909363a8933d91cf5218d7f15614045f5d2a853f27
showDetails
 static void showDetails(PrettyPrintWriter out, MessageType type, boolean showOriginalTypes)
{    List<String> cpath = new ArrayList<String>();    for (Type ftype : type.getFields()) {        showDetails(out, ftype, 0, type, cpath, showOriginalTypes);    }}
23094d067a2aceb623196290a32e9c235b36a0639a509552f35ed3222fc70f04
showDetails
private static void showDetails(PrettyPrintWriter out, GroupType type, int depth, MessageType container, List<String> cpath, boolean showOriginalTypes)
{    String name = Strings.repeat(".", depth) + type.getName();    Repetition rep = type.getRepetition();    int fcount = type.getFieldCount();    out.format("%s: %s F:%d%n", name, rep, fcount);    cpath.add(type.getName());    for (Type ftype : type.getFields()) {        showDetails(out, ftype, depth + 1, container, cpath, showOriginalTypes);    }    cpath.remove(cpath.size() - 1);}
ceed22d2de7ea1cd28c189c64e6a4262714e07efa36a2122711563b2457cb77a
showDetails
private static void showDetails(PrettyPrintWriter out, PrimitiveType type, int depth, MessageType container, List<String> cpath, boolean showOriginalTypes)
{    String name = Strings.repeat(".", depth) + type.getName();    Repetition rep = type.getRepetition();    PrimitiveTypeName ptype = type.getPrimitiveTypeName();    out.format("%s: %s %s", name, rep, ptype);    if (showOriginalTypes) {        OriginalType otype;        try {            otype = type.getOriginalType();        } catch (Exception e) {            otype = null;        }        if (otype != null)            out.format(" O:%s", otype);    } else {        LogicalTypeAnnotation ltype = type.getLogicalTypeAnnotation();        if (ltype != null)            out.format(" L:%s", ltype);    }    if (container != null) {        cpath.add(type.getName());        String[] paths = cpath.toArray(new String[cpath.size()]);        cpath.remove(cpath.size() - 1);        ColumnDescriptor desc = container.getColumnDescription(paths);        int defl = desc.getMaxDefinitionLevel();        int repl = desc.getMaxRepetitionLevel();        out.format(" R:%d D:%d", repl, defl);    }    out.println();}
6943b12cd8dd4f494aeed687433b6e02931b6721a2c4b3744ab6b8699a3c4dbd
showDetails
private static void showDetails(PrettyPrintWriter out, Type type, int depth, MessageType container, List<String> cpath, boolean showOriginalTypes)
{    if (type instanceof GroupType) {        showDetails(out, type.asGroupType(), depth, container, cpath, showOriginalTypes);        return;    } else if (type instanceof PrimitiveType) {        showDetails(out, type.asPrimitiveType(), depth, container, cpath, showOriginalTypes);        return;    }}
2aa1a06a2c8660e5515b61f5cdb51c539437ef11ea59604b05c001b78a6eb65a
allCommands
public static Map<String, Command> allCommands()
{    Map<String, Command> results = new LinkedHashMap<String, Command>();    for (Map.Entry<String, Class<? extends Command>> entry : registry.entrySet()) {        try {            results.put(entry.getKey(), entry.getValue().newInstance());        } catch (Exception ex) {        }    }    return results;}
8a45770097d2085bc5b2bf2dead1a41ade148de56b1ad973a43458977fcb7215
getCommandByName
public static Command getCommandByName(String name)
{    Class<? extends Command> clazz = registry.get(name);    if (clazz == null) {        return null;    }    try {        return clazz.newInstance();    } catch (Exception ex) {        return null;    }}
bcd19f19c20c3bf0efb79bd48a250a1ad3af5cb6a832cbb160a9bc4245aee013
getOptions
public Options getOptions()
{    return OPTIONS;}
56ceb412c211e3518987f7bc500fc8e7aa497e7baff0552369315cfc4fd41555
getUsageDescription
public String[] getUsageDescription()
{    return USAGE;}
d6dbafa30c24af868522f3f3ef6a5e96d385df0c6d95ce5477510e7a9be34d4a
getCommandDescription
public String getCommandDescription()
{    return "Prints the count of rows in Parquet file(s)";}
c63b549756ae91b22099f01f710e7ada88960927f17b2134089e5c09ff4ee74b
execute
public void execute(CommandLine options) throws Exception
{    super.execute(options);    String[] args = options.getArgs();    String input = args[0];    out = new PrintWriter(Main.out, true);    inputPath = new Path(input);    conf = new Configuration();    inputFileStatuses = inputPath.getFileSystem(conf).globStatus(inputPath);    long rowCount = 0;    for (FileStatus fs : inputFileStatuses) {        long fileRowCount = 0;        for (Footer f : ParquetFileReader.readFooters(conf, fs, false)) {            for (BlockMetaData b : f.getParquetMetadata().getBlocks()) {                rowCount += b.getRowCount();                fileRowCount += b.getRowCount();            }        }        if (options.hasOption('d')) {            out.format("%s row count: %d\n", fs.getPath().getName(), fileRowCount);        }    }    out.format("Total RowCount: %d", rowCount);    out.println();}
56ceb412c211e3518987f7bc500fc8e7aa497e7baff0552369315cfc4fd41555
getUsageDescription
public String[] getUsageDescription()
{    return USAGE;}
d6dbafa30c24af868522f3f3ef6a5e96d385df0c6d95ce5477510e7a9be34d4a
getCommandDescription
public String getCommandDescription()
{    return "Prints the metadata of Parquet file(s)";}
bcd19f19c20c3bf0efb79bd48a250a1ad3af5cb6a832cbb160a9bc4245aee013
getOptions
public Options getOptions()
{    return OPTIONS;}
c63b549756ae91b22099f01f710e7ada88960927f17b2134089e5c09ff4ee74b
execute
public void execute(CommandLine options) throws Exception
{    super.execute(options);    String[] args = options.getArgs();    String input = args[0];    boolean showOriginalTypes = options.hasOption('o');    Configuration conf = new Configuration();    Path inputPath = new Path(input);    FileStatus inputFileStatus = inputPath.getFileSystem(conf).getFileStatus(inputPath);    List<Footer> footers = ParquetFileReader.readFooters(conf, inputFileStatus, false);    PrettyPrintWriter out = PrettyPrintWriter.stdoutPrettyPrinter().withAutoColumn().withWhitespaceHandler(WhiteSpaceHandler.COLLAPSE_WHITESPACE).withColumnPadding(1).build();    for (Footer f : footers) {        out.format("file: %s%n", f.getFile());        MetadataUtils.showDetails(out, f.getParquetMetadata(), showOriginalTypes);        out.flushColumns();    }}
56ceb412c211e3518987f7bc500fc8e7aa497e7baff0552369315cfc4fd41555
getUsageDescription
public String[] getUsageDescription()
{    return USAGE;}
d6dbafa30c24af868522f3f3ef6a5e96d385df0c6d95ce5477510e7a9be34d4a
getCommandDescription
public String getCommandDescription()
{    return "Prints the schema of Parquet file(s)";}
bcd19f19c20c3bf0efb79bd48a250a1ad3af5cb6a832cbb160a9bc4245aee013
getOptions
public Options getOptions()
{    return OPTIONS;}
c63b549756ae91b22099f01f710e7ada88960927f17b2134089e5c09ff4ee74b
execute
public void execute(CommandLine options) throws Exception
{    super.execute(options);    String[] args = options.getArgs();    String input = args[0];    Configuration conf = new Configuration();    ParquetMetadata metaData;    Path path = new Path(input);    FileSystem fs = path.getFileSystem(conf);    Path file;    if (fs.isDirectory(path)) {        FileStatus[] statuses = fs.listStatus(path, HiddenFileFilter.INSTANCE);        if (statuses.length == 0) {            throw new RuntimeException("Directory " + path.toString() + " is empty");        }        file = statuses[0].getPath();    } else {        file = path;    }    metaData = ParquetFileReader.readFooter(conf, file, NO_FILTER);    MessageType schema = metaData.getFileMetaData().getSchema();    Main.out.println(schema);    if (options.hasOption('d')) {        boolean showOriginalTypes = options.hasOption('o');        PrettyPrintWriter out = PrettyPrintWriter.stdoutPrettyPrinter().build();        MetadataUtils.showDetails(out, metaData, showOriginalTypes);    }}
bcd19f19c20c3bf0efb79bd48a250a1ad3af5cb6a832cbb160a9bc4245aee013
getOptions
public Options getOptions()
{    return OPTIONS;}
56ceb412c211e3518987f7bc500fc8e7aa497e7baff0552369315cfc4fd41555
getUsageDescription
public String[] getUsageDescription()
{    return USAGE;}
d6dbafa30c24af868522f3f3ef6a5e96d385df0c6d95ce5477510e7a9be34d4a
getCommandDescription
public String getCommandDescription()
{    return "Prints the size of Parquet file(s)";}
c63b549756ae91b22099f01f710e7ada88960927f17b2134089e5c09ff4ee74b
execute
public void execute(CommandLine options) throws Exception
{    super.execute(options);    String[] args = options.getArgs();    String input = args[0];    out = new PrintWriter(Main.out, true);    inputPath = new Path(input);    conf = new Configuration();    inputFileStatuses = inputPath.getFileSystem(conf).globStatus(inputPath);    long size = 0;    for (FileStatus fs : inputFileStatuses) {        long fileSize = 0;        for (Footer f : ParquetFileReader.readFooters(conf, fs, false)) {            for (BlockMetaData b : f.getParquetMetadata().getBlocks()) {                size += (options.hasOption('u') ? b.getTotalByteSize() : b.getCompressedSize());                fileSize += (options.hasOption('u') ? b.getTotalByteSize() : b.getCompressedSize());            }        }        if (options.hasOption('d')) {            if (options.hasOption('p')) {                out.format("%s: %s\n", fs.getPath().getName(), getPrettySize(fileSize));            } else {                out.format("%s: %d bytes\n", fs.getPath().getName(), fileSize);            }        }    }    if (options.hasOption('p')) {        out.format("Total Size: %s", getPrettySize(size));    } else {        out.format("Total Size: %d bytes", size);    }    out.println();}
d4d7b008e5c48fc7db0d14a181e2ef416293ea5abf0ed81fd255063e267a3fa3
getPrettySize
public String getPrettySize(long bytes)
{    if (bytes / ONE_KB < 1) {        return String.format("%d", bytes) + " bytes";    }    if (bytes / ONE_MB < 1) {        return String.format("%.3f", bytes / ONE_KB) + " KB";    }    if (bytes / ONE_GB < 1) {        return String.format("%.3f", bytes / ONE_MB) + " MB";    }    if (bytes / ONE_TB < 1) {        return String.format("%.3f", bytes / ONE_GB) + " GB";    }    if (bytes / ONE_PB < 1) {        return String.format("%.3f", bytes / ONE_TB) + " TB";    }    return String.format("%.3f", bytes / ONE_PB) + " PB";}
a5174cae4d44ac11f004757826065e89181079eb45ca632a10949a4033772544
formatResults
protected Object formatResults(List<Object> listOfValues)
{    if (super.typeInfo.getRepetition() == Type.Repetition.REPEATED) {        return listOfValues;    } else {        return listOfValues.get(SINGLE_VALUE);    }}
9fc052cce58bbba3adaf4d63befed714ac9b1673b23c914daffed359c18aa0ce
buildWriters
private Map<String, JsonRecordFormatter> buildWriters(GroupType groupSchema)
{    Map<String, JsonRecordFormatter> writers = new LinkedHashMap<String, JsonRecordFormatter>();    for (Type type : groupSchema.getFields()) {        if (type.isPrimitive()) {            writers.put(type.getName(), new JsonPrimitiveWriter(type));        } else {            writers.put(type.getName(), new JsonGroupFormatter((GroupType) type));        }    }    return writers;}
faefbf15ca4d578ded3ea2e2860a4d0e3000bb1e24be5a07b91b547c40865d8e
add
private Object add(SimpleRecord record)
{    return formatEntries(collateEntries(record));}
52b5dcc65acfef3a338362fcc0184ee34f4f337d0cb9c49d5d565e4857b8c4a3
collateEntries
private Map<String, List<Object>> collateEntries(SimpleRecord record)
{    Map<String, List<Object>> collatedEntries = new LinkedHashMap<String, List<Object>>();    for (SimpleRecord.NameValue value : record.getValues()) {        if (collatedEntries.containsKey(value.getName())) {            collatedEntries.get(value.getName()).add(value.getValue());        } else {            List<Object> newResultListForKey = new ArrayList<Object>();            newResultListForKey.add(value.getValue());            collatedEntries.put(value.getName(), newResultListForKey);        }    }    return collatedEntries;}
1e877a17cdc8e4d52cfbf73f2bfb11d91abc315cf958b1429de6fbfea9f6ecc3
formatEntries
private Object formatEntries(Map<String, List<Object>> entries)
{    Map<String, Object> results = new LinkedHashMap<String, Object>();    for (Map.Entry<String, List<Object>> entry : entries.entrySet()) {        JsonRecordFormatter formatter = formatters.get(entry.getKey());        results.put(entry.getKey(), formatter.formatResults(entry.getValue()));    }    return results;}
895714ee0ff2492a466aedbbbb03a1431d1598020ce223caff12432f3ee40ce8
formatResults
protected Object formatResults(List<SimpleRecord> values)
{    if (super.typeInfo.getRepetition() == Type.Repetition.REPEATED) {        List<Object> results = new ArrayList<Object>();        for (SimpleRecord object : values) {            results.add(add(object));        }        return results;    } else {        return add(values.get(SINGLE_VALUE));    }}
d5e9586c783d96d435f3f0fd3d77f136be537341702a98ee13fbd28455704d87
formatRecord
public String formatRecord(SimpleRecord value) throws IOException
{    ObjectMapper mapper = new ObjectMapper();    return mapper.writeValueAsString(add(value));}
034722e01789651bf97bbce3e2ed24269ead4a7df5c42c2ee640cf2674b1fc4f
fromSchema
public static JsonGroupFormatter fromSchema(MessageType messageType)
{    return new JsonGroupFormatter(messageType);}
8564785007326c5aff1a019d9d94bd98cf254d115cae2f5fdb7539c30d727b68
mergeOptionsInto
public static void mergeOptionsInto(Options opt, Options opts)
{    if (opts == null) {        return;    }    Collection<Option> all = opts.getOptions();    if (all != null && !all.isEmpty()) {        for (Option o : all) {            opt.addOption(o);        }    }}
fa245da26f99133f8ce4819613b1a28ad8e541e38b229ad3ae11471782c3ae00
mergeOptions
public static Options mergeOptions(Options opt, Options... opts)
{    Options results = new Options();    mergeOptionsInto(results, opt);    for (Options o : opts) {        mergeOptionsInto(results, o);    }    return results;}
0b9c7d737ce7748806a2f7783f58cf112dccfd738c0fd76f5da79ae5cda00882
showUsage
public static void showUsage(HelpFormatter format, PrintWriter err, String name, Command command)
{    Options options = mergeOptions(OPTIONS, command.getOptions());    String[] usage = command.getUsageDescription();    String ustr = name + " [option...]";    if (usage != null && usage.length >= 1) {        ustr = ustr + " " + usage[0];    }    format.printWrapped(err, WIDTH, name + ":\n" + command.getCommandDescription());    format.printUsage(err, WIDTH, ustr);    format.printWrapped(err, WIDTH, LEFT_PAD, "where option is one of:");    format.printOptions(err, WIDTH, options, LEFT_PAD, DESC_PAD);    if (usage != null && usage.length >= 2) {        for (int i = 1; i < usage.length; ++i) {            format.printWrapped(err, WIDTH, LEFT_PAD, usage[i]);        }    }}
084a4444ba0effc9022c4fc5c8aac00600398e2282b631ec6788a91f5fc96ac6
showUsage
public static void showUsage(String name, Command command)
{    HelpFormatter format = new HelpFormatter();    PrintWriter err = new PrintWriter(Main.err, true);    Options options = command.getOptions();    showUsage(format, err, "parquet-" + name, command);}
789ae091d33eb00fe33e55e85e0c3d2acecfad5bc811d4416936586bda7c1854
showUsage
public static void showUsage()
{    HelpFormatter format = new HelpFormatter();    PrintWriter err = new PrintWriter(Main.err, true);    Map<String, Command> all = Registry.allCommands();    boolean first = true;    for (Map.Entry<String, Command> entry : all.entrySet()) {        String name = entry.getKey();        Command command = entry.getValue();        if (!first)            err.println();        first = false;        showUsage(format, err, "parquet-tools " + name, command);    }}
0f06a205dbf7b012c35d02eccdb800a21fad62b814701261d1433d9d762457b9
die
public static void die(String message, boolean usage)
{    die(message, usage, null, null);}
fd3242f4f905f2234cb0c40833ef3063cff8ae42b02007c5cf62425be960a9ef
die
public static void die(Throwable th, boolean usage)
{    die(th, usage, null, null);}
4abaf1b6f0c604acfd03c263891a9840399588b1c806d52a7b408e66fdbe8b09
die
public static void die(String message, boolean usage, String name, Command command)
{    if (message != null) {        Main.err.println(message);        Main.err.println();    }    if (usage) {        if (name == null && command == null) {            showUsage();        } else {            showUsage(name, command);        }    }    System.exit(1);}
ba225c3b8e68a69c65d9d140b65625bbb873bb8686c8c3935e4b12d07dfb51df
die
public static void die(Throwable th, boolean usage, String name, Command command)
{    die(th.toString(), usage, name, command);}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    Main.out = System.out;    Main.err = System.err;    PrintStream VoidStream = new PrintStream(new OutputStream() {        @Override        public void write(int b) throws IOException {        }        @Override        public void write(byte[] b) throws IOException {        }        @Override        public void write(byte[] b, int off, int len) throws IOException {        }        @Override        public void flush() throws IOException {        }        @Override        public void close() throws IOException {        }    });    System.setOut(VoidStream);    System.setErr(VoidStream);    if (args.length == 0) {        die("No command specified", true, null, null);    }    String name = args[0];    if ("-h".equals(name) || "--help".equals(name)) {        showUsage();        System.exit(0);    }    Command command = Registry.getCommandByName(name);    if (command == null) {        die("Unknown command: " + name, true, null, null);    }    boolean debug = false;    try {        String[] cargs = Arrays.copyOfRange(args, 1, args.length);        Options opts = mergeOptions(OPTIONS, command.getOptions());        boolean extra = command.supportsExtraArgs();        CommandLineParser parser = new PosixParser();        CommandLine cmd = parser.parse(opts == null ? new Options() : opts, cargs, extra);        if (cmd.hasOption('h')) {            showUsage(name, command);            System.exit(0);        }        if (cmd.hasOption("no-color")) {            System.setProperty("DISABLE_COLORS", "true");        }        debug = cmd.hasOption("debug");        command.execute(cmd);    } catch (ParseException ex) {        if (debug)            ex.printStackTrace(Main.err);        die("Invalid arguments: " + ex.getMessage(), true, name, command);    } catch (Throwable th) {        if (debug)            th.printStackTrace(Main.err);        die(th, false, name, command);    }}
28b71ced43af8c83f8eb799b762b9363eea3393c08bf12a29b90de2304757b0c
write
public void write(int b) throws IOException
{}
9dc05e09d787e6afa8b5d2cf4cacaf1f65f348fcc597daca5502cd46ac6e898a
write
public void write(byte[] b) throws IOException
{}
6426ce3b66c4d2446558d8b5b93fe8a019e350f1ed5c2b61732f1efce14f0e67
write
public void write(byte[] b, int off, int len) throws IOException
{}
c3e67ec76f1b008887f1caba645a2614900cde6e477acca1bc3ecc36bf357fcf
flush
public void flush() throws IOException
{}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{}
f4a2dfb685b271b68fe4e462fc04f7a50157789b6cac8accc01c7ab3f6cea4e5
toJsonObject
protected Object toJsonObject()
{    Object[] result = new Object[values.size()];    for (int i = 0; i < values.size(); i++) {        result[i] = toJsonValue(values.get(i).getValue());    }    return result;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    record = new SimpleListRecord();}
f4a2dfb685b271b68fe4e462fc04f7a50157789b6cac8accc01c7ab3f6cea4e5
toJsonObject
protected Object toJsonObject()
{    Map<String, Object> result = Maps.newLinkedHashMap();    for (NameValue value : values) {        String key = null;        Object val = null;        for (NameValue kv : ((SimpleRecord) value.getValue()).values) {            String kvName = kv.getName();            Object kvValue = kv.getValue();            if (kvName.equals("key")) {                key = keyToString(kvValue);            } else if (kvName.equals("value")) {                val = toJsonValue(kvValue);            }        }        result.put(key, val);    }    return result;}
fd877f4c303b8352e201a8d4d4a6f4721ce30dcd97e301065bb342d960e6966d
keyToString
 String keyToString(Object kvValue)
{    if (kvValue == null) {        return "null";    }    Class<?> type = kvValue.getClass();    if (type.isArray()) {        if (type.getComponentType() == boolean.class) {            return Arrays.toString((boolean[]) kvValue);        } else if (type.getComponentType() == byte.class) {            return new BinaryNode((byte[]) kvValue).asText();        } else if (type.getComponentType() == char.class) {            return Arrays.toString((char[]) kvValue);        } else if (type.getComponentType() == double.class) {            return Arrays.toString((double[]) kvValue);        } else if (type.getComponentType() == float.class) {            return Arrays.toString((float[]) kvValue);        } else if (type.getComponentType() == int.class) {            return Arrays.toString((int[]) kvValue);        } else if (type.getComponentType() == long.class) {            return Arrays.toString((long[]) kvValue);        } else if (type.getComponentType() == short.class) {            return Arrays.toString((short[]) kvValue);        } else {            return Arrays.toString((Object[]) kvValue);        }    } else {        return String.valueOf(kvValue);    }}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    record = new SimpleMapRecord();}
7e6aded51d5b443fe143d42d705389f20ab94d0d9b6ae4cd8476353db0e18073
prepareForRead
public RecordMaterializer<SimpleRecord> prepareForRead(Configuration conf, Map<String, String> metaData, MessageType schema, ReadContext context)
{    return new SimpleRecordMaterializer(schema);}
179fb3d7a903b204c2b4bf2b8050f64585c9b7e332f5069356f97fbb27f885e3
init
public ReadContext init(InitContext context)
{    return new ReadContext(context.getFileSchema());}
d588477638c98200b5078dad39962655a50ca74e136b82c1fe82910c5f2f8a2a
add
public void add(String name, Object value)
{    values.add(new NameValue(name, value));}
3c694c33e147ee5dbab3aca8cfc6f4aabe079a3e2ab93ea54f1cb22b19127215
getValues
public List<NameValue> getValues()
{    return Collections.unmodifiableList(values);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return values.toString();}
8ef62393ee51c308a769dd988fba643a72f52e63c00d3272411b446314359748
prettyPrint
public void prettyPrint()
{    prettyPrint(new PrintWriter(System.out, true));}
4545e63ad71a274c82fddc7098e06b1e2446ffb1e38c2115f21814e22a6fd1ca
prettyPrint
public void prettyPrint(PrintWriter out)
{    prettyPrint(out, 0);}
7f4b000b6b1f98de3bc1ba05735718693956dbfa395f6a739acabfcd1521e3c2
prettyPrint
public void prettyPrint(PrintWriter out, int depth)
{    for (NameValue value : values) {        out.print(Strings.repeat(".", depth));        out.print(value.getName());        Object val = value.getValue();        if (val == null) {            out.print(" = ");            out.print("<null>");        } else if (byte[].class == val.getClass()) {            out.print(" = ");            out.print(new BinaryNode((byte[]) val).asText());        } else if (short[].class == val.getClass()) {            out.print(" = ");            out.print(Arrays.toString((short[]) val));        } else if (int[].class == val.getClass()) {            out.print(" = ");            out.print(Arrays.toString((int[]) val));        } else if (long[].class == val.getClass()) {            out.print(" = ");            out.print(Arrays.toString((long[]) val));        } else if (float[].class == val.getClass()) {            out.print(" = ");            out.print(Arrays.toString((float[]) val));        } else if (double[].class == val.getClass()) {            out.print(" = ");            out.print(Arrays.toString((double[]) val));        } else if (boolean[].class == val.getClass()) {            out.print(" = ");            out.print(Arrays.toString((boolean[]) val));        } else if (val.getClass().isArray()) {            out.print(" = ");            out.print(Arrays.deepToString((Object[]) val));        } else if (SimpleRecord.class.isAssignableFrom(val.getClass())) {            out.println(":");            ((SimpleRecord) val).prettyPrint(out, depth + 1);            continue;        } else {            out.print(" = ");            out.print(String.valueOf(val));        }        out.println();    }}
2ebe5f35b3e67bc4cee91073c1c48a201604db2735bd1edcbcc8307bb18abdcc
prettyPrintJson
public void prettyPrintJson(PrintWriter out) throws IOException
{    ObjectMapper mapper = new ObjectMapper();    out.write(mapper.writeValueAsString(this.toJsonObject()));}
f4a2dfb685b271b68fe4e462fc04f7a50157789b6cac8accc01c7ab3f6cea4e5
toJsonObject
protected Object toJsonObject()
{    Map<String, Object> result = Maps.newLinkedHashMap();    for (NameValue value : values) {        result.put(value.getName(), toJsonValue(value.getValue()));    }    return result;}
8ec574b1cb409bc9b79228e31f807ed952926723e2934ada25b1153138bd9f92
toJsonValue
protected static Object toJsonValue(Object val)
{    if (SimpleRecord.class.isAssignableFrom(val.getClass())) {        return ((SimpleRecord) val).toJsonObject();    } else if (byte[].class == val.getClass()) {        return new BinaryNode((byte[]) val);    } else {        return val;    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return name + ": " + value;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
cc9131919df0823e8e8ee6054b03ea6d4a394f817422ddb0f9240211f097bcaf
getValue
public Object getValue()
{    return value;}
3a93900ef54caf5d8c1d18895ebc1df6e1c5840f14ada3b514c84a98c685af0e
createConverter
private Converter createConverter(Type field)
{    LogicalTypeAnnotation ltype = field.getLogicalTypeAnnotation();    if (field.isPrimitive()) {        if (ltype != null) {            return ltype.accept(new LogicalTypeAnnotation.LogicalTypeAnnotationVisitor<Converter>() {                @Override                public Optional<Converter> visit(LogicalTypeAnnotation.StringLogicalTypeAnnotation stringLogicalType) {                    return of(new StringConverter(field.getName()));                }                @Override                public Optional<Converter> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType) {                    int scale = decimalLogicalType.getScale();                    return of(new DecimalConverter(field.getName(), scale));                }            }).orElse(new SimplePrimitiveConverter(field.getName()));        }        return new SimplePrimitiveConverter(field.getName());    }    GroupType groupType = field.asGroupType();    if (ltype != null) {        return ltype.accept(new LogicalTypeAnnotation.LogicalTypeAnnotationVisitor<Converter>() {            @Override            public Optional<Converter> visit(LogicalTypeAnnotation.MapLogicalTypeAnnotation mapLogicalType) {                return of(new SimpleMapRecordConverter(groupType, field.getName(), SimpleRecordConverter.this));            }            @Override            public Optional<Converter> visit(LogicalTypeAnnotation.ListLogicalTypeAnnotation listLogicalType) {                return of(new SimpleListRecordConverter(groupType, field.getName(), SimpleRecordConverter.this));            }        }).orElse(new SimpleRecordConverter(groupType, field.getName(), this));    }    return new SimpleRecordConverter(groupType, field.getName(), this);}
5fb3215e3f794a671dbece58af533e675ed0a214a9b877ada74c9f6f675ce3f7
visit
public Optional<Converter> visit(LogicalTypeAnnotation.StringLogicalTypeAnnotation stringLogicalType)
{    return of(new StringConverter(field.getName()));}
4e424a81f9df5673df26f7a4e241545faf9642f82e9ced00a7f6c9d69734e733
visit
public Optional<Converter> visit(LogicalTypeAnnotation.DecimalLogicalTypeAnnotation decimalLogicalType)
{    int scale = decimalLogicalType.getScale();    return of(new DecimalConverter(field.getName(), scale));}
7dd05dabd0339b792f8e70cd8ce25c85e06d2fcfe7cc9dc21a68b53302ea60ed
visit
public Optional<Converter> visit(LogicalTypeAnnotation.MapLogicalTypeAnnotation mapLogicalType)
{    return of(new SimpleMapRecordConverter(groupType, field.getName(), SimpleRecordConverter.this));}
93098f48380894d526768d686271a1c356b48a95dbec1d8c430aa13a2ff05bba
visit
public Optional<Converter> visit(LogicalTypeAnnotation.ListLogicalTypeAnnotation listLogicalType)
{    return of(new SimpleListRecordConverter(groupType, field.getName(), SimpleRecordConverter.this));}
9f3d57e82b573bd1ef1fdd31a37f25a810661b6aa88d2e4f67f1effe191dd4e5
getConverter
public Converter getConverter(int fieldIndex)
{    return converters[fieldIndex];}
0ca40ca1ea49f9eaca107315d54de6255ff29758b2cda1216784c883eb10cfc9
getCurrentRecord
 SimpleRecord getCurrentRecord()
{    return record;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    record = new SimpleRecord();}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    if (parent != null) {        parent.getCurrentRecord().add(name, record);    }}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    record.add(name, value.getBytes());}
23123f6657c241ab9b9f31f8efedc28a553ed91046d705121ce2667b065d6c17
addBoolean
public void addBoolean(boolean value)
{    record.add(name, value);}
2ca276cac62568e8f7346fa8beda2d4feb0081e254c085365f599a7dda7495c9
addDouble
public void addDouble(double value)
{    record.add(name, value);}
53db766aeaf41c97b70b147a385d1a1f455f4e6044c14f31e431add23e1b3f3b
addFloat
public void addFloat(float value)
{    record.add(name, value);}
a2ac1f40a6e220ec515710128c8baf77a725ad0b9f1767a998f776f27fff6cf6
addInt
public void addInt(int value)
{    record.add(name, value);}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    record.add(name, value);}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    record.add(name, value.toStringUsingUTF8());}
c1f3fb14ff859e26b55253da0dbd29c678eee79c0f140d14680808cf9663ad69
addBinary
public void addBinary(Binary value)
{    record.add(name, new BigDecimal(new BigInteger(value.getBytes()), scale));}
a2ac1f40a6e220ec515710128c8baf77a725ad0b9f1767a998f776f27fff6cf6
addInt
public void addInt(int value)
{    record.add(name, BigDecimal.valueOf(value).movePointLeft(scale));}
9a6a47a70d49feea026c6cc72e06459999af529e6c8cf39cc55fd90b8e34f2c8
addLong
public void addLong(long value)
{    record.add(name, BigDecimal.valueOf(value).movePointLeft(scale));}
e56761f4c27ef33b7b36716a2b7a29a26b1a563ed0bc45fb20d32e677a5c167b
getCurrentRecord
public SimpleRecord getCurrentRecord()
{    return root.getCurrentRecord();}
92fd854c4aebb01be238d83e407159211ea5cf60b5efd6fc7db8904dba13699b
getRootConverter
public GroupConverter getRootConverter()
{    return root;}
dcd4afe0a979d922546f2c8ae321124b3ee5dbc4bdf9698580a2a45a5a7a3345
showDetails
public static void showDetails(PrettyPrintWriter out, ParquetMetadata meta)
{    showDetails(out, meta.getFileMetaData());    long i = 1;    for (BlockMetaData bmeta : meta.getBlocks()) {        out.println();        showDetails(out, bmeta, i++);    }}
ee708b7a08178e7fd7df05493ec6a83f8e927b615252b0eba036f5aee60d79d7
showDetails
public static void showDetails(PrettyPrintWriter out, FileMetaData meta)
{    out.format("creator: %s%n", meta.getCreatedBy());    Map<String, String> extra = meta.getKeyValueMetaData();    if (extra != null) {        for (Map.Entry<String, String> entry : meta.getKeyValueMetaData().entrySet()) {            out.print("extra: ");            out.incrementTabLevel();            out.format("%s = %s%n", entry.getKey(), entry.getValue());            out.decrementTabLevel();        }    }    out.println();    out.format("file schema: %s%n", meta.getSchema().getName());    out.rule('-');    showDetails(out, meta.getSchema());}
d65183cf13e273b47c991155405346b8e7bcfb5e1b37a1f09efa2f8c97e45025
showDetails
public static void showDetails(PrettyPrintWriter out, BlockMetaData meta)
{    showDetails(out, meta, null);}
e6bdf9f7b381d46f058332aefa2cac3b422054302a6f6079192bae6eed3875a3
showDetails
private static void showDetails(PrettyPrintWriter out, BlockMetaData meta, Long num)
{    long rows = meta.getRowCount();    long tbs = meta.getTotalByteSize();    long offset = meta.getStartingPos();    out.format("row group%s: RC:%d TS:%d OFFSET:%d%n", (num == null ? "" : " " + num), rows, tbs, offset);    out.rule('-');    showDetails(out, meta.getColumns());}
7524894aa03fdbe93cb4fd41dba0d9a1e130204c77704e1253c96bad28b90633
showDetails
public static void showDetails(PrettyPrintWriter out, List<ColumnChunkMetaData> ccmeta)
{    Map<String, Object> chunks = new LinkedHashMap<String, Object>();    for (ColumnChunkMetaData cmeta : ccmeta) {        String[] path = cmeta.getPath().toArray();        Map<String, Object> current = chunks;        for (int i = 0; i < path.length - 1; ++i) {            String next = path[i];            if (!current.containsKey(next)) {                current.put(next, new LinkedHashMap<String, Object>());            }            current = (Map<String, Object>) current.get(next);        }        current.put(path[path.length - 1], cmeta);    }    showColumnChunkDetails(out, chunks, 0);}
03a3d81f604bb541b3b8043bb09c5b348f9e2ea35a24bffbb8fd7c5f643cce1a
showColumnChunkDetails
private static void showColumnChunkDetails(PrettyPrintWriter out, Map<String, Object> current, int depth)
{    for (Map.Entry<String, Object> entry : current.entrySet()) {        String name = Strings.repeat(".", depth) + entry.getKey();        Object value = entry.getValue();        if (value instanceof Map) {            out.println(name + ": ");            showColumnChunkDetails(out, (Map<String, Object>) value, depth + 1);        } else {            out.print(name + ": ");            showDetails(out, (ColumnChunkMetaData) value, false);        }    }}
b1de6d76d86049388615b3cd47be823879362114ae2dbf606944ff561f9bffad
showDetails
public static void showDetails(PrettyPrintWriter out, ColumnChunkMetaData meta)
{    showDetails(out, meta, true);}
f5b639327ba6b9b94248e60c8ea73fdf378952c8f663d4ba9b09461c02fd9995
showDetails
private static void showDetails(PrettyPrintWriter out, ColumnChunkMetaData meta, boolean name)
{    long doff = meta.getDictionaryPageOffset();    long foff = meta.getFirstDataPageOffset();    long tsize = meta.getTotalSize();    long usize = meta.getTotalUncompressedSize();    long count = meta.getValueCount();    double ratio = usize / (double) tsize;    String encodings = Joiner.on(',').skipNulls().join(meta.getEncodings());    if (name) {        String path = Joiner.on('.').skipNulls().join(meta.getPath());        out.format("%s: ", path);    }    out.format(" %s", meta.getType());    out.format(" %s", meta.getCodec());    out.format(" DO:%d", doff);    out.format(" FPO:%d", foff);    out.format(" SZ:%d/%d/%.2f", tsize, usize, ratio);    out.format(" VC:%d", count);    if (!encodings.isEmpty())        out.format(" ENC:%s", encodings);    Statistics<?> stats = meta.getStatistics();    if (stats != null) {        out.format(" ST:[%s]", stats);    } else {        out.format(" ST:[none]");    }    out.println();}
63170c3507f852c60ec3e7d9677c7cfcfad66fbd7c3617dcb275a411ca99656b
showDetails
public static void showDetails(PrettyPrintWriter out, ColumnDescriptor desc)
{    String path = Joiner.on(".").skipNulls().join(desc.getPath());    PrimitiveTypeName type = desc.getType();    int defl = desc.getMaxDefinitionLevel();    int repl = desc.getMaxRepetitionLevel();    out.format("column desc: %s T:%s R:%d D:%d%n", path, type, repl, defl);}
0bdadbd556457d02a782725e0b0b6081b87368d2562e1da061ff0c818e64c73d
showDetails
public static void showDetails(PrettyPrintWriter out, MessageType type)
{    List<String> cpath = new ArrayList<String>();    for (Type ftype : type.getFields()) {        showDetails(out, ftype, 0, type, cpath);    }}
81025fc288b3af715539f44f8beda746086b14d5ab46b8e187bfaa9774dac00d
showDetails
public static void showDetails(PrettyPrintWriter out, GroupType type)
{    showDetails(out, type, 0, null, null);}
f3ac16deafcef321fefa3115349c6e273a8106c192d31f3bfc38aded00935494
showDetails
public static void showDetails(PrettyPrintWriter out, PrimitiveType type)
{    showDetails(out, type, 0, null, null);}
02477bccfa79bacc7d4b3618ed52b4cece9219708be53250f3419f43f6537732
showDetails
public static void showDetails(PrettyPrintWriter out, Type type)
{    showDetails(out, type, 0, null, null);}
19924e015b6ca92bf93b58245a5ae1661d98a7265952054aa3fcd105bba436a9
showDetails
private static void showDetails(PrettyPrintWriter out, GroupType type, int depth, MessageType container, List<String> cpath)
{    String name = Strings.repeat(".", depth) + type.getName();    Repetition rep = type.getRepetition();    int fcount = type.getFieldCount();    out.format("%s: %s F:%d%n", name, rep, fcount);    cpath.add(type.getName());    for (Type ftype : type.getFields()) {        showDetails(out, ftype, depth + 1, container, cpath);    }    cpath.remove(cpath.size() - 1);}
c598b935d0727019d2bb3eb815af65d6441f5c4b3e1c264de445469971737b31
showDetails
private static void showDetails(PrettyPrintWriter out, PrimitiveType type, int depth, MessageType container, List<String> cpath)
{    String name = Strings.repeat(".", depth) + type.getName();    OriginalType otype = type.getOriginalType();    Repetition rep = type.getRepetition();    PrimitiveTypeName ptype = type.getPrimitiveTypeName();    out.format("%s: %s %s", name, rep, ptype);    if (otype != null)        out.format(" O:%s", otype);    if (container != null) {        cpath.add(type.getName());        String[] paths = cpath.toArray(new String[cpath.size()]);        cpath.remove(cpath.size() - 1);        ColumnDescriptor desc = container.getColumnDescription(paths);        int defl = desc.getMaxDefinitionLevel();        int repl = desc.getMaxRepetitionLevel();        out.format(" R:%d D:%d", repl, defl);    }    out.println();}
95d54dad2a3b1d2f2222455332d47bc4f40f58ad4646b66156bc7972cb937f7b
showDetails
private static void showDetails(PrettyPrintWriter out, Type type, int depth, MessageType container, List<String> cpath)
{    if (type instanceof GroupType) {        showDetails(out, type.asGroupType(), depth, container, cpath);        return;    } else if (type instanceof PrimitiveType) {        showDetails(out, type.asPrimitiveType(), depth, container, cpath);        return;    }}
96ca5795e9dbf773265ee543837ce4730523513a8a44ca33a0c412fd68e5a9c0
setTabLevel
public void setTabLevel(int level)
{    this.tabLevel = level;    this.tabs = Strings.repeat(" ", tabWidth * level);    if (flushOnTab)        flushColumns();}
65420685bc6241c8e4331175ac2da3acdd364cb0baf362a8ab83f30c177389f9
incrementTabLevel
public void incrementTabLevel()
{    setTabLevel(tabLevel + 1);}
ea22d1a0cef00b294fac04f17644d27889320f010accde452c2ca41e4445841b
decrementTabLevel
public void decrementTabLevel()
{    if (tabLevel == 0) {        return;    }    setTabLevel(tabLevel - 1);}
f7dc57718c80f2b6efb0af4b2a5354154fd20faaccab36db75184f5b448ac6c7
determineNumColumns
private int determineNumColumns()
{    int max = 0;    for (Line line : buffer) {        int num = line.countCharacter(columnSeparator);        if (num > max) {            max = num;        }    }    return max > maxColumns ? maxColumns : max;}
32a02210bc121559c281cfc14f47b60e733dcc4d028f4acdfd55a5e987af5076
determineColumnWidths
private int[] determineColumnWidths()
{    int columns = determineNumColumns();    if (columns == 0) {        return null;    }    int[] widths = new int[columns];    for (Line line : buffer) {        for (int last = 0, idx = 0; last < line.length() && idx < columns; ++idx) {            int pos = line.indexOf(columnSeparator, last);            if (pos < 0)                break;            int wid = pos - last + 1 + columnPadding;            if (wid > widths[idx]) {                widths[idx] = wid;            }            last = line.firstNonWhiteSpace(idx + 1);        }    }    return widths;}
d56b7b0fe82a814b700e6519e3a16d9c2f1b026223fcb4d6fd7e0e5bfa726609
toColumns
private Line toColumns(int[] widths, Line line) throws IOException
{    int last = 0;    for (int i = 0; i < widths.length; ++i) {        int width = widths[i];        int idx = line.indexOf(columnSeparator, last);        if (idx < 0)            break;        if ((idx + 1) <= width) {            line.spaceOut(width - (idx + 1), idx + 1);        }        last = line.firstNonWhiteSpace(idx + 1);    }    return line;}
7e5c9d43c4d10761769641b09d7930f8e440b3653734508bf6dc4acefe66b528
flushColumns
public void flushColumns()
{    flushColumns(false);}
1eb21e4aa9b504534470cc83595964e332a2214b1f485b3f3711f4edfc130bf3
flushColumns
private void flushColumns(boolean preserveLast)
{    int size = buffer.size();    int[] widths = null;    if (autoColumn) {        widths = determineColumnWidths();    }    StringBuilder builder = new StringBuilder();    try {        for (int i = 0; i < size - 1; ++i) {            Line line = buffer.get(i);            if (widths != null) {                line = toColumns(widths, line);            }            fixupLine(line);            builder.setLength(0);            line.toString(builder);            super.out.append(builder.toString());            super.out.append(LINE_SEP);        }        if (!preserveLast) {            Line line = buffer.get(size - 1);            if (widths != null) {                line = toColumns(widths, line);            }            fixupLine(line);            builder.setLength(0);            line.toString(builder);            super.out.append(builder.toString());        }        super.out.flush();    } catch (IOException ex) {    }    Line addback = null;    if (preserveLast) {        addback = buffer.get(size - 1);    }    buffer.clear();    if (addback != null)        buffer.add(addback);    else        buffer.add(new Line());}
2778c5f20b3717ca83e5f3c7269c4421e4e16e312a109fadac597023ef18a459
flushIfNeeded
private void flushIfNeeded()
{    flushIfNeeded(false);}
06693315388c3ebee246b8fc570fae66b0d3ce6a0b4d2ac9fa4f51f8e4a0b043
flushIfNeeded
private void flushIfNeeded(boolean preserveLast)
{    if (!autoColumn || buffer.size() > maxBufferedLines) {        flushColumns(preserveLast);    }}
a823b521b8f8d373eaf21fea1adb1637bea4787b0179baf32c283c1efce8edb6
appendToCurrent
private void appendToCurrent(String s)
{    int size = buffer.size();    Line value = buffer.get(size - 1);    if (value.isEmpty()) {        value.append(tabs());    }    value.append(span(s));}
b57e1d4917e02d3cfbf121df32bb67a8821952b9d2158e36415dafaf5c667e34
fixupLine
private void fixupLine(Line line)
{    if (autoCrop) {        line.trimTo(consoleWidth, appendToLongLine);    }}
a15f8d45a7ce0aa83aab948fb28c9eafde74c25a5171e97692b4e3d79d32cf9d
print
private void print(String s, boolean mayHaveNewlines)
{    if (s == null) {        appendToCurrent("null");        return;    }    if (s.isEmpty()) {        return;    }    if (LINE_SEP.equals(s)) {        buffer.add(new Line());        flushIfNeeded();        return;    }    if (whiteSpaceHandler != null) {        boolean endswith = s.endsWith(LINE_SEP);        switch(whiteSpaceHandler) {            case ELIMINATE_NEWLINES:                s = s.replaceAll("\\r\\n|\\r|\\n", " ");                break;            case COLLAPSE_WHITESPACE:                s = s.replaceAll("\\s+", " ");                break;        }        mayHaveNewlines = endswith;        if (endswith)            s = s + LINE_SEP;    }    if (!mayHaveNewlines) {        appendToCurrent(s);        return;    }    String[] lines = s.split("\\r?\\n", -1);    appendToCurrent(lines[0]);    for (int i = 1; i < lines.length; ++i) {        String value = lines[i];        if (value.isEmpty()) {            buffer.add(new Line());        } else {            Line line = new Line();            line.append(tabs());            line.append(span(value, true));            buffer.add(line);        }    }    resetColor();    flushIfNeeded(true);}
1904a6c118641507ba7cbb132dd32f9381ae0cddc226e2f494c85210c74807f0
print
public void print(String s)
{    print(s, true);}
61ec18fdee534037a4559a178a14e2b7a1caa49494d730ee98a1eacb2eca1c36
println
public void println()
{    print(LINE_SEP, true);    flushIfNeeded();}
03898c9a312c742b3adf79b045032a1c5bae27bc710bf96d451400941a46cea4
println
public void println(String x)
{    print(x);    println();}
b139344054966794213f046d16e0cae8d0ae34df29653c34bda4cbc8cffc1efe
print
public void print(boolean b)
{    print(String.valueOf(b), false);}
4fadeaa309a91a646ef4b6c369b7eda9968a207ec60f5fbe12c99e32c1d75e68
print
public void print(char c)
{    print(String.valueOf(c), false);}
0d9328626db4039ed01e4ea56640d8c351b8db4c57723a574c490e8b11d5bd22
print
public void print(int i)
{    print(String.valueOf(i), false);}
c7388ffb9bce68e8d8689355b3b73a3e63e1bcbf6c0fcb8b52fd3b5fc030d106
print
public void print(long l)
{    print(String.valueOf(l), false);}
a5da7715081b453e9052b52a9371b4686f88c30244278706c2703b091bb3c328
print
public void print(float f)
{    print(String.valueOf(f), false);}
e87779ccab1474b3b7572cf55a92aab3c8a8b1cc72fb56aa32d0020560338deb
print
public void print(double d)
{    print(String.valueOf(d), false);}
ddcfe69b836581a74a7d3a4b3d540bfd5cb8c707dde3ab806b123eb6ac16add6
print
public void print(char[] s)
{    print(String.valueOf(s), true);}
7f3af16e8cdc31fc2138edb5fec3dda5f0bffc4af423104d122858353246ec13
print
public void print(Object obj)
{    print(String.valueOf(obj), true);}
abb7ad0f65f09ff285ddcd89a38653819fa38d6a4f1adfc2ff4e6373b1702d9b
printf
public PrintWriter printf(String format, Object... args)
{    return printf(formatter.locale(), format, args);}
997a0cc36cf733a065e3b63f19b378eb9737ff69bae4970853248f459b163846
printf
public PrintWriter printf(Locale l, String format, Object... args)
{    formatter.format(l, format, args);    String results = formatString.toString();    formatString.setLength(0);    print(results);    flushIfNeeded();    return this;}
7218f2530403ca62d010fddd686902cbe67405fc12c7ac39e7fa8b0e6d34faa6
format
public PrintWriter format(String format, Object... args)
{    return printf(format, args);}
7ebc8e4ab328699409a5d1810d1454c70e4d9366ade001ff1b09ef6f61337e12
format
public PrintWriter format(Locale l, String format, Object... args)
{    return printf(l, format, args);}
6876c48ae47a1ed5b8697ac004e73c404b38ff848519b4c3a1429f98449703b6
append
public PrintWriter append(char c)
{    print(c);    return this;}
9ced10c75fd6677d0685572f4065d599064fa7016cb0a38eabf196f6eb25195e
append
public PrintWriter append(CharSequence csq)
{    if (csq == null) {        print("null");        return this;    }    return append(csq, 0, csq.length());}
e98cc7246ab3050507d90065d8d7b0e9057a3c326af21b12684ebd785135439c
append
public PrintWriter append(CharSequence csq, int start, int end)
{    if (csq == null) {        print("null");        return this;    }    print(csq.subSequence(start, end).toString());    return this;}
54dfaad13ade37e67a9c952f1ece14dc07e3dad9b72b135e90a06058c3ecfe0b
println
public void println(boolean x)
{    print(x);    println();}
0009a30937af5a461749ed1ee7f1449ea9e0861fce4ce29bc982c9a17aebe73b
println
public void println(char x)
{    print(x);    println();}
efe788b54f32362a1235e559ba465ec6f01bd6e21924351a02c899ee54dcd82f
println
public void println(int x)
{    print(x);    println();}
967ad356a4478c2a2048c2030b727c62b6d78fcf710ee793041cc9d0e4feb6d4
println
public void println(long x)
{    print(x);    println();}
e8ac0615955dddaf5efd1cf038cd0137c85775a8052be950a4f0c47febf593f7
println
public void println(float x)
{    print(x);    println();}
f642d1ea5e143bc27c38f863182ca13307bc3cc67521d7c8260b11f6d42eede6
println
public void println(double x)
{    print(x);    println();}
fb2c8004f178337caeb9516053df2bdc9893cae18e8b85c3ffd263be9d9caaf5
println
public void println(char[] x)
{    print(x);    println();}
0bae9a79ac5151b3c36e4586bf8aa41727dc5a4706f4221d2e06c449e14aa89d
println
public void println(Object x)
{    print(x);    println();}
00841b5f677d15835ac2987ff9a92565719ea691b88b43d9d4ddca20a466d1c9
rule
public void rule(char c)
{    if (tabs.length() >= consoleWidth)        return;    int width = consoleWidth;    if (width == Integer.MAX_VALUE) {        width = 100;    }    println(Strings.repeat(String.valueOf(c), width - tabs.length()));}
bd7a90a86f77864b45546b0c4bfbbda77078af0c09b8b9a39ef7717753cd3e21
iff
public PrettyPrintWriter iff(boolean predicate)
{    if (!predicate && acceptColorModification) {        resetColor();    } else {        acceptColorModification = false;    }    return this;}
c2fc6b9fcc32e9b92315b8aec6ff94ee7ecf85b8571ada189a88fcd22401cc42
otherwise
public PrettyPrintWriter otherwise()
{    acceptColorModification = false;    return this;}
541b8b35d2168ac1781f1af078fc1d955ec781dc6008b4cec959825479dac40a
black
public PrettyPrintWriter black()
{    if (!acceptColorModification)        return this;    colorForeground = FG_COLOR_BLACK;    return this;}
79210d6058e22a5c97ada16d30fbc68e71ecc998edb8b8d7475520091539743e
red
public PrettyPrintWriter red()
{    if (!acceptColorModification)        return this;    colorForeground = FG_COLOR_RED;    return this;}
dbd704d617c53910d5350b28f4f5b43f6eac8cc3efb94ac11e228b9269bbc5cc
green
public PrettyPrintWriter green()
{    if (!acceptColorModification)        return this;    colorForeground = FG_COLOR_GREEN;    return this;}
4ba730724c6a7d4830c9dd3be46107e9ca657080ac6d82723781bf54307e3655
yellow
public PrettyPrintWriter yellow()
{    if (!acceptColorModification)        return this;    colorForeground = FG_COLOR_YELLOW;    return this;}
97bcef242af6adbc3a602facfcec3eba338c7b4fbce2d85c286742ab84d51066
blue
public PrettyPrintWriter blue()
{    if (!acceptColorModification)        return this;    colorForeground = FG_COLOR_BLUE;    return this;}
55243074502e9bc0adc67d559268e28079efc91712ae530a3c14a1cfb1fe0e45
magenta
public PrettyPrintWriter magenta()
{    if (!acceptColorModification)        return this;    colorForeground = FG_COLOR_MAGENTA;    return this;}
d7d393488ee2b914dffd3c64a578aae40f7bc3699fe8c31083c86582ce7d2ed6
cyan
public PrettyPrintWriter cyan()
{    if (!acceptColorModification)        return this;    colorForeground = FG_COLOR_CYAN;    return this;}
d1ad5e50ff446ec67dc67dd66496163aee8c385d8c5a42aee21bb6880269d455
white
public PrettyPrintWriter white()
{    if (!acceptColorModification)        return this;    colorForeground = FG_COLOR_WHITE;    return this;}
e9e232645652da8c9d75719393b97dcbeeb68bcca92165a0129dcae8d1b05a14
bgblack
public PrettyPrintWriter bgblack()
{    if (!acceptColorModification)        return this;    colorBackground = BG_COLOR_BLACK;    return this;}
09dd24946a5b07ef6f20c3471f18c3a9ddcd0cfbc03a6fc95722a4fd1d3f4578
bgred
public PrettyPrintWriter bgred()
{    if (!acceptColorModification)        return this;    colorBackground = BG_COLOR_RED;    return this;}
0e9f70037f090c68f1faf543568618ad0c6f502d2ea50604dc174d9660a6545a
bggreen
public PrettyPrintWriter bggreen()
{    if (!acceptColorModification)        return this;    colorBackground = BG_COLOR_GREEN;    return this;}
788523150bd48ac31b5675067522e66b14b2addf53509e9e219477e8ac75a39a
bgyellow
public PrettyPrintWriter bgyellow()
{    if (!acceptColorModification)        return this;    colorBackground = BG_COLOR_YELLOW;    return this;}
b505dd8b8fa83f72dbb97af2fe3276724573ad705b67b3c633b98851113e62fb
bgblue
public PrettyPrintWriter bgblue()
{    if (!acceptColorModification)        return this;    colorBackground = BG_COLOR_BLUE;    return this;}
f900dbb51f9c653b9806bfc1e148bbe12fef3c3ad4de77ceb0dfc3cc3ef0e356
bgmagenta
public PrettyPrintWriter bgmagenta()
{    if (!acceptColorModification)        return this;    colorBackground = BG_COLOR_MAGENTA;    return this;}
da35af6e78056641aaf0005b49c31eb9ed4df2d59a29e56891cf731eb3644d6d
bgcyan
public PrettyPrintWriter bgcyan()
{    if (!acceptColorModification)        return this;    colorBackground = BG_COLOR_CYAN;    return this;}
813ab96d96574907036fe5decc92ce955b227239a210ef2d88a5641378a1587e
bgwhite
public PrettyPrintWriter bgwhite()
{    if (!acceptColorModification)        return this;    colorBackground = BG_COLOR_WHITE;    return this;}
2d9d79392d030c6a1db2372eddd657d60b3ddaa53e810fdfcb91ea7a2834cf75
bold
public PrettyPrintWriter bold()
{    if (!acceptColorModification)        return this;    colorMode = MODE_BOLD;    return this;}
204746dee51fd090c3fce7e2e95e7250e3b4306ffa197d0ccc53ce30d8fb1a0b
blink
public PrettyPrintWriter blink()
{    if (!acceptColorModification)        return this;    colorMode = MODE_BLINK;    return this;}
eea2f69111edc34c73a666867419dec07d0524c2c17b02ad3604059fe3850fc6
concealed
public PrettyPrintWriter concealed()
{    if (!acceptColorModification)        return this;    colorMode = MODE_CONCEALED;    return this;}
97e6acb8ab294b52db8f9a71b8400a63fb7ab97165b2933b118efb1299a8fdeb
off
public PrettyPrintWriter off()
{    if (!acceptColorModification)        return this;    colorMode = MODE_OFF;    return this;}
e6314ad36ea05402a81be44a48ad7f780893c626b35c1ac98552d5e3fff2c1aa
underscore
public PrettyPrintWriter underscore()
{    if (!acceptColorModification)        return this;    colorMode = MODE_UNDER;    return this;}
4aab5dd321de763f6515464868a236bc52ca68a7031ca35093c630b4dd88ae0e
reverse
public PrettyPrintWriter reverse()
{    if (!acceptColorModification)        return this;    colorMode = MODE_REVERSE;    return this;}
399d977b2fb0379ea9169ed19a936c6999288e437bc4798e9a1efd1a41b2a8b9
stdoutPrettyPrinter
public static Builder stdoutPrettyPrinter()
{    return new Builder(Main.out).withAutoFlush();}
726ffce5f1c3fcc8c45cd1ff68229a983473290e5f4843df73cd5ec777d00266
stderrPrettyPrinter
public static Builder stderrPrettyPrinter()
{    return new Builder(Main.err).withAutoFlush();}
86c48b9cfc1fffd8eac60c08f2dc1dc5a5f1a601d6db6ecc16aac0498ac280ae
newPrettyPrinter
public static Builder newPrettyPrinter(OutputStream out)
{    return new Builder(out);}
f5f6b1086bffe70c8a09855d605d8fa5036e08cba6517fe0f2b0d661ba2c35a5
withAutoFlush
public Builder withAutoFlush()
{    this.autoFlush = true;    return this;}
e16dde050f0cb03986ff17f99ae86f82da99fc1a1e55de1af0dfcc67a87b44fb
withAutoCrop
public Builder withAutoCrop()
{    return withAutoCrop(DEFAULT_WIDTH);}
954290c4dbb58c6de5205bc5e3f637692d51324a2af0cc09908b2ffc0724b37f
withAutoCrop
public Builder withAutoCrop(int consoleWidth)
{    return withAutoCrop(consoleWidth, DEFAULT_APPEND);}
fe1e2ed7e9f085f81ff7fa0170d83423ea0391ab9f4b1cc01ed286f7911ef1bd
withAutoCrop
public Builder withAutoCrop(int consoleWidth, String appendToLong)
{    return withAutoCrop(consoleWidth, mkspan(appendToLong));}
3dae149e25b37bb3537a5e2a15b8fd78adde1d3685ea1174a8c9f582dfcddca6
withAutoCrop
public Builder withAutoCrop(int consoleWidth, Span appendToLong)
{    this.consoleWidth = consoleWidth;    this.appendToLongLine = appendToLong;    this.autoCrop = true;    return this;}
70c819dd9f3c6c305158c5c8746d9fde9e0bb2e2a314558a832965e8624e9da1
withTabSize
public Builder withTabSize(int tabWidth)
{    this.tabWidth = tabWidth;    return this;}
627f49d08a8a8779dd679736c4c495a3209eed39341622f34f50bb905bd60492
withAutoColumn
public Builder withAutoColumn()
{    return withAutoColumn(DEFAULT_COLUMN_SEP);}
20bf3ad6b2d73cd746fa03acaa09f1976ebf861cb08bac968b2affcd7e33a1b0
withAutoColumn
public Builder withAutoColumn(char columnSeparator)
{    return withAutoColumn(columnSeparator, DEFAULT_MAX_COLUMNS);}
13fbd97a79cf9662260925fa2332f092a0c8020fb754e3d4ba7607cba91e6058
withAutoColumn
public Builder withAutoColumn(char columnSeparator, int maxColumns)
{    this.autoColumn = true;    this.columnSeparator = columnSeparator;    this.maxColumns = maxColumns;    return this;}
a55183cfb7a673f72df499ee78a67bc39065c8d4ee4c70fa605ec698951d130c
withColumnPadding
public Builder withColumnPadding(int columnPadding)
{    this.columnPadding = columnPadding;    return this;}
71302a2e25caf748786142ea793ad72a4447c81abcbd62d5be9496b968abb8a2
withWhitespaceHandler
public Builder withWhitespaceHandler(WhiteSpaceHandler whiteSpaceHandler)
{    this.whiteSpaceHandler = whiteSpaceHandler;    return this;}
3279f5e3414a460f5838dea8371678e3b406b53de9871e28c20e8537bfb48606
withMaxBufferedLines
public Builder withMaxBufferedLines(long maxBufferedLines)
{    this.maxBufferedLines = maxBufferedLines;    return this;}
a72f7037019591acc99c554ea327593c8996f5d02c4a007cbf3903ebd2376077
withFlushOnTab
public Builder withFlushOnTab()
{    this.flushOnTab = true;    return this;}
4211b60ae2374e5e3491ddfb8d1b5b35600d5355a6a6f28bf19b0a9fe0d0a2c1
build
public PrettyPrintWriter build()
{    return new PrettyPrintWriter(out, autoFlush, autoColumn, autoCrop, appendToLongLine, consoleWidth, tabWidth, columnSeparator, maxColumns, columnPadding, maxBufferedLines, flushOnTab, whiteSpaceHandler);}
cef6dff3ef5e5e4c71470b37f21d4ba06b09bc3de8a4c1e38e9d14c7c05f6ff7
tabs
private Span tabs()
{    return new Span(tabs);}
4b9519617c6ef8b4bf5599e446f5d5ff9537cf631f2e0e060eb28661e6653b79
span
private Span span(String span)
{    return span(span, false);}
2edfbd0bc8c9f2c40a525f01fcf8e53189b3eb7616e8e28fcb770cfc1772fc3b
resetColor
private void resetColor()
{    acceptColorModification = true;    colorMode = null;    colorForeground = null;    colorBackground = null;}
39e2954d2683a8197530424f790bf8ff7eedaddeda61b062aa60ccfb0b9a2e13
mkspan
public static Span mkspan(String span)
{    return new Span(span);}
7cf10bda1f1c4bd0ddaa1dc1dded9bbab71549e2f60ac10265a39751dbc7c750
mkspan
public static Span mkspan(String span, String color)
{    return mkspan(span, null, color, null);}
9c5214dd5a81ef2080deac30e047b2a1efbd59912f829d3fe20eca751a8ea44f
mkspan
public static Span mkspan(String span, String colorMode, String colorForeground, String colorBackground)
{    if (DEFAULT_COLORS > 0 && (colorMode != null || colorForeground != null || colorBackground != null)) {        String color = "\u001B[" + Joiner.on(';').skipNulls().join(colorMode, colorForeground, colorBackground) + "m";        return new Span(span, color);    } else {        return mkspan(span);    }}
3efff282de419db11ad3b8a36648258911f4495c7ab46ba04493a3d2a9b34b17
span
private Span span(String span, boolean keepColor)
{    Span result;    if (DEFAULT_COLORS > 0 && (colorMode != null || colorForeground != null || colorBackground != null)) {        result = mkspan(span, colorMode, colorForeground, colorBackground);    } else {        result = mkspan(span);    }    if (!keepColor) {        resetColor();    }    return result;}
17d3df9545516420e080e07a8dbf5ccf3982d6adb2e5f63a830db81bd6d7cac9
append
public void append(Span span)
{    length += span.length();    if (spans.isEmpty()) {        spans.add(span);        return;    }    Span last = spans.get(spans.size() - 1);    if (last.canAppend(span)) {        last.append(span);    } else {        spans.add(span);    }}
803915e853382ad445a6e2333fabb8beb8e4acd70e908a0d818400f7baac42af
isEmpty
public boolean isEmpty()
{    return length == 0;}
1d1ebdb99c526da23d9a06ed6c089d39abc457289b7aff9cbe5f58a377b283b2
length
public int length()
{    return length;}
8cc149574b30fc25e8a8ba17aca8594c67f7980119f11b41ac3c16737584d4f6
indexOf
public int indexOf(char ch, int start)
{    int offset = 0;    for (Span span : spans) {        if (start > span.length()) {            start -= span.length();            continue;        }        int idx = span.indexOf(ch, start);        if (idx >= 0)            return offset + idx;        offset += span.length() - start;        start = 0;    }    return -1;}
417d9d95ae0f729424109e0fc73ffb59245cf98d9a78299995da44515984630f
spaceOut
public void spaceOut(int width, int start)
{    for (Span span : spans) {        if (start > span.length()) {            start -= span.length();            continue;        }        span.spaceOut(width, start);        return;    }}
2a857eb7412def492db06f762ca07b8e89555b85e25b972de7e04dca517ea0ba
firstNonWhiteSpace
public int firstNonWhiteSpace(int start)
{    return start;}
dbd7edf01cedd0e54c5f88ebe665e189d69b5fe6d3ca82168f6de4c9676c6165
countCharacter
public int countCharacter(char ch)
{    int result = 0;    for (Span span : spans) {        result += span.countCharacter(ch);    }    return result;}
0241b6e192889ff7e3a5b9c4b44768461d0a555a0b5dbf10d8c8f166270a2804
trimTo
public void trimTo(int width, Span appendToLongLine)
{    int i = 0;    int remaining = width;    for (i = 0; i < spans.size(); ++i) {        Span next = spans.get(i);        if (next.length() > remaining) {            ++i;            next.trimTo(remaining, appendToLongLine);            break;        }        remaining -= next.length();    }    for (; i < spans.size(); ++i) {        spans.remove(i);    }}
1ce422a02136e656064acd0a0e7a6f1441c1b6e8c1bf7ab77679404f907e6f92
toString
public void toString(StringBuilder builder)
{    for (Span span : spans) {        span.toString(builder);    }}
1d1ebdb99c526da23d9a06ed6c089d39abc457289b7aff9cbe5f58a377b283b2
length
public int length()
{    return span.length();}
803915e853382ad445a6e2333fabb8beb8e4acd70e908a0d818400f7baac42af
isEmpty
public boolean isEmpty()
{    return span.isEmpty();}
8cc149574b30fc25e8a8ba17aca8594c67f7980119f11b41ac3c16737584d4f6
indexOf
public int indexOf(char ch, int start)
{    return span.indexOf(ch, start);}
417d9d95ae0f729424109e0fc73ffb59245cf98d9a78299995da44515984630f
spaceOut
public void spaceOut(int width, int start)
{    int removeTo = start;    while (removeTo < span.length() && Character.isWhitespace(span.charAt(removeTo))) {        removeTo++;    }    span = span.substring(0, start) + Strings.repeat(" ", width) + span.substring(removeTo);}
dbd7edf01cedd0e54c5f88ebe665e189d69b5fe6d3ca82168f6de4c9676c6165
countCharacter
public int countCharacter(char ch)
{    int result = 0;    for (int i = 0; i < span.length(); ++i) {        if (span.charAt(i) == ch) {            result++;        }    }    return result;}
0241b6e192889ff7e3a5b9c4b44768461d0a555a0b5dbf10d8c8f166270a2804
trimTo
public void trimTo(int width, Span appendToLongLine)
{    if (appendToLongLine != null && !appendToLongLine.isEmpty()) {        int shortten = appendToLongLine.length();        if (shortten > width)            shortten = width;        span = span.substring(0, width - shortten) + appendToLongLine;    } else {        span = span.substring(0, width + 1);    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder builder = new StringBuilder();    toString(builder);    return builder.toString();}
1ce422a02136e656064acd0a0e7a6f1441c1b6e8c1bf7ab77679404f907e6f92
toString
public void toString(StringBuilder builder)
{    if (color != null)        builder.append(color);    builder.append(span);    if (color != null)        builder.append(RESET);}
9437861f72ce1e462d720b68b98bce6ddb1d2d42c3906f74d5d37dbbbf5e6ec0
append
public void append(Span other)
{    span = span + other.span;}
9a9ddd9fe1e7bd9eb96f2f25330947194b9beb4287db424a826dd0cbd6674d56
canAppend
public boolean canAppend(Span other)
{    if (color == null && other == null)        return true;    if (color == null && other != null)        return false;    return color.equals(other);}
d132aa7bd3d39f4f38fdbb2db991b029bc98422868f9fec538df8de18ed561c7
array
private List<T> array(T... objects)
{    return Arrays.asList(objects);}
a0228e9f50a564a290f17b5257d728016ee7dcb7fd9266346f49112c7c626e2f
entry
private Map.Entry<String, T> entry(final String key, final T value)
{    return new Map.Entry<String, T>() {        @Override        public String getKey() {            return key;        }        @Override        public T getValue() {            return value;        }        @Override        public T setValue(T value) {            throw new UnsupportedOperationException();        }    };}
71dcee8caa732fdfbbc9042fbd951dc9dfd911ed9a4cabf0966856ac5de53dfc
getKey
public String getKey()
{    return key;}
5d1a642cd3f56327936f74c7e42620bdce9a2aa959d5c16e15c526e66eba684a
getValue
public T getValue()
{    return value;}
2a6951e9401c04b9c89f0b4bb961bc8ba45a7ea624cdcad37e5d4c6eef89c758
setValue
public T setValue(T value)
{    throw new UnsupportedOperationException();}
a28ca259e3b852783c705e5057b90fa42fbffec19816ab8faef1e86422085255
obj
private Map<String, ?> obj(Map.Entry<String, ?>... entries) throws IOException
{    Map<String, Object> entriesAsMap = new LinkedHashMap<String, Object>();    for (Map.Entry<String, ?> entry : entries) {        entriesAsMap.put(entry.getKey(), entry.getValue());    }    return entriesAsMap;}
501e42b3ebb4cae499d6e3d7e82001d8e33f6ceabc08e28cb0cf27fd39422c54
kv
private SimpleRecord.NameValue kv(String name, Object value)
{    return new SimpleRecord.NameValue(name, value);}
adbc7be88f9a46f4f4c5876335722a99f3a0856aa29565f1a3c9607c5a4769a7
asJsonString
private String asJsonString(Object object) throws IOException
{    ObjectMapper mapper = new ObjectMapper();    return mapper.writeValueAsString(object);}
bafc75d6216cb8fa29d6270ccb5b716e8c583e15aa7f06b460ca3540afb77a3e
testFlatSchemaWithArrays
public void testFlatSchemaWithArrays() throws Exception
{    SimpleRecord simple = new SimpleRecord();    MessageType schema = new MessageType("schema", new PrimitiveType(Type.Repetition.REQUIRED, PrimitiveType.PrimitiveTypeName.BINARY, "reqd"), new PrimitiveType(Type.Repetition.OPTIONAL, PrimitiveType.PrimitiveTypeName.DOUBLE, "opt"), new PrimitiveType(Type.Repetition.REPEATED, PrimitiveType.PrimitiveTypeName.INT32, "odd"), new PrimitiveType(Type.Repetition.REPEATED, PrimitiveType.PrimitiveTypeName.INT64, "even"));    simple.values.add(kv("reqd", "a required value"));    simple.values.add(kv("opt", 1.2345));    simple.values.add(kv("odd", 1));    simple.values.add(kv("odd", 3));    simple.values.add(kv("odd", 5));    simple.values.add(kv("odd", 7));    simple.values.add(kv("odd", 9));    simple.values.add(kv("even", 2));    simple.values.add(kv("even", 4));    simple.values.add(kv("even", 6));    simple.values.add(kv("even", 8));    simple.values.add(kv("even", 10));    String expected = asJsonString(obj(entry("reqd", "a required value"), entry("opt", 1.2345), entry("odd", array(1, 3, 5, 7, 9)), entry("even", array(2, 4, 6, 8, 10))));    String actual = JsonRecordFormatter.fromSchema(schema).formatRecord(simple);    assertEquals(expected, actual);}
2d43527f73bb99f112b27631cf72c7bdbc82d52280318b22c06ed22ebd1ad17c
testNestedGrouping
public void testNestedGrouping() throws Exception
{    SimpleRecord simple = new SimpleRecord();    MessageType schema = new MessageType("schema", new PrimitiveType(Type.Repetition.REPEATED, PrimitiveType.PrimitiveTypeName.BINARY, "flat-string"), new GroupType(Type.Repetition.OPTIONAL, "subgroup", new PrimitiveType(Type.Repetition.REQUIRED, PrimitiveType.PrimitiveTypeName.INT32, "flat-int"), new PrimitiveType(Type.Repetition.REPEATED, PrimitiveType.PrimitiveTypeName.BINARY, "string-list")));    SimpleRecord subgroup = new SimpleRecord();    subgroup.values.add(kv("flat-int", 12345));    subgroup.values.add(kv("string-list", "two"));    subgroup.values.add(kv("string-list", "four"));    subgroup.values.add(kv("string-list", "six"));    subgroup.values.add(kv("string-list", "eight"));    subgroup.values.add(kv("string-list", "ten"));    simple.values.add(kv("flat-string", "one"));    simple.values.add(kv("flat-string", "two"));    simple.values.add(kv("flat-string", "three"));    simple.values.add(kv("flat-string", "four"));    simple.values.add(kv("flat-string", "five"));    simple.values.add(kv("subgroup", subgroup));    String actual = JsonRecordFormatter.fromSchema(schema).formatRecord(simple);    String expected = asJsonString(obj(entry("flat-string", array("one", "two", "three", "four", "five")), entry("subgroup", obj(entry("flat-int", 12345), entry("string-list", array("two", "four", "six", "eight", "ten"))))));    assertEquals(expected, actual);}
88845882a6653ed509d45c1aeeb5198158e67d5b5149d5b32cb6e9d9b7d90959
testGroupList
public void testGroupList() throws Exception
{    SimpleRecord simple = new SimpleRecord();    MessageType schema = new MessageType("schema", new GroupType(Type.Repetition.REPEATED, "repeat-group", new PrimitiveType(Type.Repetition.REQUIRED, PrimitiveType.PrimitiveTypeName.INT64, "flat-int"), new PrimitiveType(Type.Repetition.REPEATED, PrimitiveType.PrimitiveTypeName.DOUBLE, "repeat-double")));    SimpleRecord repeatGroup = new SimpleRecord();    repeatGroup.values.add(kv("flat-int", 76543));    repeatGroup.values.add(kv("repeat-double", 1.2345));    repeatGroup.values.add(kv("repeat-double", 5.6789));    repeatGroup.values.add(kv("repeat-double", 10.11121314));    repeatGroup.values.add(kv("repeat-double", 0.4321));    repeatGroup.values.add(kv("repeat-double", 7.6543));    simple.values.add(kv("repeat-group", repeatGroup));    repeatGroup = new SimpleRecord();    repeatGroup.values.add(kv("flat-int", 12345));    repeatGroup.values.add(kv("repeat-double", 1.1));    repeatGroup.values.add(kv("repeat-double", 1.2));    repeatGroup.values.add(kv("repeat-double", 1.3));    repeatGroup.values.add(kv("repeat-double", 1.4));    repeatGroup.values.add(kv("repeat-double", 1.5));    simple.values.add(kv("repeat-group", repeatGroup));    repeatGroup = new SimpleRecord();    repeatGroup.values.add(kv("flat-int", 10293));    repeatGroup.values.add(kv("repeat-double", 9.5));    repeatGroup.values.add(kv("repeat-double", 9.4));    repeatGroup.values.add(kv("repeat-double", 9.3));    repeatGroup.values.add(kv("repeat-double", 9.2));    repeatGroup.values.add(kv("repeat-double", 9.1));    simple.values.add(kv("repeat-group", repeatGroup));    String actual = JsonRecordFormatter.fromSchema(schema).formatRecord(simple);    String expected = asJsonString(obj(entry("repeat-group", array(obj(entry("flat-int", 76543), entry("repeat-double", array(1.2345, 5.6789, 10.11121314, 0.4321, 7.6543))), obj(entry("flat-int", 12345), entry("repeat-double", array(1.1, 1.2, 1.3, 1.4, 1.5))), obj(entry("flat-int", 10293), entry("repeat-double", array(9.5, 9.4, 9.3, 9.2, 9.1)))))));    assertEquals(expected, actual);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "TestRecord {" + x + "," + y + "}";}
0df33d62278751dafad149c380795c8df5f490e8b87ac24bdfd5e17cb7832db9
testBinary
public void testBinary()
{    SimpleMapRecord r = new SimpleMapRecord();    Assert.assertEquals("null", r.keyToString(null));    Assert.assertEquals("[true, false, true]", r.keyToString(new boolean[] { true, false, true }));    Assert.assertEquals("[a, z]", r.keyToString(new char[] { 'a', 'z' }));    Assert.assertEquals("[1.0, 3.0]", r.keyToString(new double[] { 1.0, 3.0 }));    Assert.assertEquals("[2.0, 4.0]", r.keyToString(new float[] { 2.0f, 4.0f }));    Assert.assertEquals("[100, 999]", r.keyToString(new int[] { 100, 999 }));    Assert.assertEquals("[23, 37]", r.keyToString(new long[] { 23l, 37l }));    Assert.assertEquals("[-1, -2]", r.keyToString(new short[] { (short) -1, (short) -2 }));    Assert.assertEquals("dGVzdA==", r.keyToString("test".getBytes()));    Assert.assertEquals("TestRecord {222,333}", r.keyToString(new TestRecord(222, 333)));}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "TestRecord {" + x + "," + y + "}";}
0df33d62278751dafad149c380795c8df5f490e8b87ac24bdfd5e17cb7832db9
testBinary
public void testBinary()
{    SimpleMapRecord r = new SimpleMapRecord();    Assert.assertEquals("null", r.keyToString(null));    Assert.assertEquals("true", r.keyToString(true));    Assert.assertEquals("a", r.keyToString('a'));    Assert.assertEquals("3.0", r.keyToString(3.0));    Assert.assertEquals("4.0", r.keyToString(4.0f));    Assert.assertEquals("100", r.keyToString(100));    Assert.assertEquals("37", r.keyToString(37l));    Assert.assertEquals("-1", r.keyToString((short) -1));    Assert.assertEquals("test", r.keyToString("test"));    Assert.assertEquals("123.123", r.keyToString(new BigDecimal("123.123")));}
589b93aa1769ede2d6d2c0de150d5e58962caae7487306c2ed14f16bbc51c79b
testConverter
public void testConverter() throws IOException
{    try (ParquetReader<SimpleRecord> reader = ParquetReader.builder(new SimpleReadSupport(), new Path(testFile().getAbsolutePath())).build()) {        for (SimpleRecord record = reader.read(); record != null; record = reader.read()) {            for (SimpleRecord.NameValue value : record.getValues()) {                switch(value.getName()) {                    case INT32_FIELD:                        Assert.assertEquals(32, value.getValue());                        break;                    case INT64_FIELD:                        Assert.assertEquals(64L, value.getValue());                        break;                    case FLOAT_FIELD:                        Assert.assertEquals(1.0f, value.getValue());                        break;                    case DOUBLE_FIELD:                        Assert.assertEquals(2.0d, value.getValue());                        break;                    case BINARY_FIELD:                        Assert.assertArrayEquals("foobar".getBytes(), (byte[]) value.getValue());                        break;                    case FIXED_LEN_BYTE_ARRAY_FIELD:                        Assert.assertArrayEquals(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 }, (byte[]) value.getValue());                        break;                }            }        }    }}
c536957a0359efaba4fa041a9429ed02027b66c9e6f5cc21d07eb308cc675a0d
setUp
public void setUp() throws IOException
{    createTestParquetFile();}
386fc565be2c49649a48f2050cacbb32c5c3a90be45578f9ff9252cb28ae4b88
createSchema
private static MessageType createSchema()
{    return new MessageType("schema", new PrimitiveType(Type.Repetition.REQUIRED, PrimitiveType.PrimitiveTypeName.INT32, INT32_FIELD), new PrimitiveType(Type.Repetition.REQUIRED, PrimitiveType.PrimitiveTypeName.INT64, INT64_FIELD), new PrimitiveType(Type.Repetition.REQUIRED, PrimitiveType.PrimitiveTypeName.FLOAT, FLOAT_FIELD), new PrimitiveType(Type.Repetition.REQUIRED, PrimitiveType.PrimitiveTypeName.DOUBLE, DOUBLE_FIELD), new PrimitiveType(Type.Repetition.REQUIRED, PrimitiveType.PrimitiveTypeName.BINARY, BINARY_FIELD), new PrimitiveType(Type.Repetition.REQUIRED, PrimitiveType.PrimitiveTypeName.FIXED_LEN_BYTE_ARRAY, 12, FIXED_LEN_BYTE_ARRAY_FIELD));}
e3ad3201d82b5c8ac372acaf1d909afbdb5d59095f929fb2d9800f2d30f28ac9
createTestParquetFile
private void createTestParquetFile() throws IOException
{    Path fsPath = new Path(testFile().getPath());    Configuration conf = new Configuration();    MessageType schema = createSchema();    SimpleGroupFactory fact = new SimpleGroupFactory(schema);    GroupWriteSupport.setSchema(schema, conf);    try (ParquetWriter<Group> writer = new ParquetWriter<>(fsPath, new GroupWriteSupport(), CompressionCodecName.UNCOMPRESSED, 1024, 1024, 512, true, false, ParquetProperties.WriterVersion.PARQUET_2_0, conf)) {        writer.write(fact.newGroup().append(INT32_FIELD, 32).append(INT64_FIELD, 64L).append(FLOAT_FIELD, 1.0f).append(DOUBLE_FIELD, 2.0d).append(BINARY_FIELD, Binary.fromString("foobar")).append(FIXED_LEN_BYTE_ARRAY_FIELD, Binary.fromConstantByteArray(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 })));    }}
0ce656135232fc4b3a4313312629d7ff63e163335d1c8f4af37735d7ad2c8cc7
testFile
private File testFile()
{    return new File(this.tempFolder.getRoot(), getClass().getSimpleName() + ".parquet");}
