b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    super.setConf(conf);    if (conf == null)        return;    defaultInterval = conf.getInt("db.fetch.interval.default", 0);    maxInterval = conf.getInt("db.fetch.interval.max", 0);    LOG.info("defaultInterval=" + defaultInterval);    LOG.info("maxInterval=" + maxInterval);}
78f32340c1a2921e4a06f482869528b11caa8742761791025265b0fdc93b087a
initializeSchedule
public CrawlDatum initializeSchedule(Text url, CrawlDatum datum)
{    datum.setFetchTime(System.currentTimeMillis());    datum.setFetchInterval(defaultInterval);    datum.setRetriesSinceFetch(0);    return datum;}
319c7fad8a457ebb19672206c3ea49d47adb1e2fe5c1e1d279c4ce14d3c5cdec
setFetchSchedule
public CrawlDatum setFetchSchedule(Text url, CrawlDatum datum, long prevFetchTime, long prevModifiedTime, long fetchTime, long modifiedTime, int state)
{    datum.setRetriesSinceFetch(0);    return datum;}
c5a3977e5e82be9d18dd0ed2ff31349d518865337dbcff46cfd28e0e3b01475d
setPageGoneSchedule
public CrawlDatum setPageGoneSchedule(Text url, CrawlDatum datum, long prevFetchTime, long prevModifiedTime, long fetchTime)
{        if ((datum.getFetchInterval() * 1.5f) < maxInterval)        datum.setFetchInterval(datum.getFetchInterval() * 1.5f);    else        datum.setFetchInterval(maxInterval * 0.9f);    datum.setFetchTime(fetchTime + (long) datum.getFetchInterval() * 1000);    return datum;}
b59290c4b16321f29fba58f2c90d10c546a21e05a09954293752a59b7293dd3d
setPageRetrySchedule
public CrawlDatum setPageRetrySchedule(Text url, CrawlDatum datum, long prevFetchTime, long prevModifiedTime, long fetchTime)
{    datum.setFetchTime(fetchTime + (long) SECONDS_PER_DAY * 1000);    datum.setRetriesSinceFetch(datum.getRetriesSinceFetch() + 1);    return datum;}
fcea5ef9dbe3a7daaa8d7295a2f36bcaac467a3d63b54c837cab969f35a65dd3
calculateLastFetchTime
public long calculateLastFetchTime(CrawlDatum datum)
{    if (datum.getStatus() == CrawlDatum.STATUS_DB_UNFETCHED) {        return 0L;    } else {        return datum.getFetchTime() - (long) datum.getFetchInterval() * 1000;    }}
1523b7e94cb853af54da86ae7f42c1034d43361d271e83ff042823a0def22148
shouldFetch
public boolean shouldFetch(Text url, CrawlDatum datum, long curTime)
{        if (datum.getFetchTime() - curTime > (long) maxInterval * 1000) {        if (datum.getFetchInterval() > maxInterval) {            datum.setFetchInterval(maxInterval * 0.9f);        }        datum.setFetchTime(curTime);    }    if (datum.getFetchTime() > curTime) {                return false;    }    return true;}
b6ca5ccb5fc90c39e6626cee722cf222e5447f84a5c2affdc5adca83d430371d
forceRefetch
public CrawlDatum forceRefetch(Text url, CrawlDatum datum, boolean asap)
{        if (datum.getFetchInterval() > maxInterval)        datum.setFetchInterval(maxInterval * 0.9f);    datum.setStatus(CrawlDatum.STATUS_DB_UNFETCHED);    datum.setRetriesSinceFetch(0);    datum.setSignature(null);    datum.setModifiedTime(0L);    if (asap)        datum.setFetchTime(System.currentTimeMillis());    return datum;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    super.setConf(conf);    if (conf == null)        return;    INC_RATE = conf.getFloat("db.fetch.schedule.adaptive.inc_rate", 0.2f);    DEC_RATE = conf.getFloat("db.fetch.schedule.adaptive.dec_rate", 0.2f);    MIN_INTERVAL = conf.getFloat("db.fetch.schedule.adaptive.min_interval", (float) 60.0);    MAX_INTERVAL = conf.getFloat("db.fetch.schedule.adaptive.max_interval",     (float) SECONDS_PER_DAY * 365);    SYNC_DELTA = conf.getBoolean("db.fetch.schedule.adaptive.sync_delta", true);    SYNC_DELTA_RATE = conf.getFloat("db.fetch.schedule.adaptive.sync_delta_rate", 0.2f);}
319c7fad8a457ebb19672206c3ea49d47adb1e2fe5c1e1d279c4ce14d3c5cdec
setFetchSchedule
public CrawlDatum setFetchSchedule(Text url, CrawlDatum datum, long prevFetchTime, long prevModifiedTime, long fetchTime, long modifiedTime, int state)
{    super.setFetchSchedule(url, datum, prevFetchTime, prevModifiedTime, fetchTime, modifiedTime, state);    float interval = datum.getFetchInterval();    long refTime = fetchTime;        interval = (interval == 0) ? defaultInterval : interval;    if (datum.getMetaData().containsKey(Nutch.WRITABLE_FIXED_INTERVAL_KEY)) {                FloatWritable customIntervalWritable = (FloatWritable) (datum.getMetaData().get(Nutch.WRITABLE_FIXED_INTERVAL_KEY));        interval = customIntervalWritable.get();    } else {        if (modifiedTime <= 0)            modifiedTime = fetchTime;        switch(state) {            case FetchSchedule.STATUS_MODIFIED:                interval *= (1.0f - DEC_RATE);                modifiedTime = fetchTime;                break;            case FetchSchedule.STATUS_NOTMODIFIED:                interval *= (1.0f + INC_RATE);                break;            case FetchSchedule.STATUS_UNKNOWN:                break;        }        if (SYNC_DELTA) {                        long delta = (fetchTime - modifiedTime) / 1000L;            if (delta > interval)                interval = delta;            refTime = fetchTime - Math.round(delta * SYNC_DELTA_RATE * 1000);        }        if (interval < MIN_INTERVAL) {            interval = MIN_INTERVAL;        } else if (interval > MAX_INTERVAL) {            interval = MAX_INTERVAL;        }    }    datum.setFetchInterval(interval);    datum.setFetchTime(refTime + Math.round(interval * 1000.0));    datum.setModifiedTime(modifiedTime);    return datum;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    FetchSchedule fs = new AdaptiveFetchSchedule();    fs.setConf(NutchConfiguration.create());        long curTime = 0;        long delta = 1000L * 3600L * 24L;            long update = 1000L * 3600L * 24L * 30L;    boolean changed = true;    long lastModified = 0;    int miss = 0;    int totalMiss = 0;    int maxMiss = 0;    int fetchCnt = 0;    int changeCnt = 0;        CrawlDatum p = new CrawlDatum(1, 3600 * 24 * 30, 1.0f);    p.setFetchTime(0);    LOG.info(p.toString());        for (int i = 0; i < 10000; i++) {        if (lastModified + update < curTime) {                                    changed = true;            changeCnt++;            lastModified = curTime;        }        LOG.info(i + ". " + changed + "\twill fetch at " + (p.getFetchTime() / delta) + "\tinterval " + (p.getFetchInterval() / SECONDS_PER_DAY) + " days" + "\t missed " + miss);        if (p.getFetchTime() <= curTime) {            fetchCnt++;            fs.setFetchSchedule(new Text("http://www.example.com"), p, p.getFetchTime(), p.getModifiedTime(), curTime, lastModified, changed ? FetchSchedule.STATUS_MODIFIED : FetchSchedule.STATUS_NOTMODIFIED);            LOG.info("\tfetched & adjusted: " + "\twill fetch at " + (p.getFetchTime() / delta) + "\tinterval " + (p.getFetchInterval() / SECONDS_PER_DAY) + " days");            if (!changed)                miss++;            if (miss > maxMiss)                maxMiss = miss;            changed = false;            totalMiss += miss;            miss = 0;        }        if (changed)            miss++;        curTime += delta;    }    LOG.info("Total missed: " + totalMiss + ", max miss: " + maxMiss);    LOG.info("Page changed " + changeCnt + " times, fetched " + fetchCnt + " times.");}
5e595a50e85d74a354e7d49a4b93bfd8fcd0adfe78d6aa0831898818abf8ad04
hasDbStatus
public static boolean hasDbStatus(CrawlDatum datum)
{    if (datum.status <= STATUS_DB_MAX)        return true;    return false;}
199047e3b30436d05d89410a4c38f6262a7c385873dfaa03b36589da46991f96
hasFetchStatus
public static boolean hasFetchStatus(CrawlDatum datum)
{    if (datum.status > STATUS_DB_MAX && datum.status <= STATUS_FETCH_MAX)        return true;    return false;}
e5a03872780f5a31f8a4bf05d8a658913be5fd6a6e806f67b5f2c73c3d86697c
getStatus
public byte getStatus()
{    return status;}
d76fa57a92027b0b892bb506e4f4cd1a61763891787ca9346eaa1f3bc47a9316
getStatusName
public static String getStatusName(byte value)
{    String res = statNames.get(value);    if (res == null)        res = "unknown";    return res;}
f10fc673953be08342a612dc01b097739173af382a2589b0a00eee4b8c8cc412
getStatusByName
public static byte getStatusByName(String name)
{    for (Entry<Byte, String> status : statNames.entrySet()) {        if (name.equalsIgnoreCase(status.getValue())) {            return status.getKey();        }    }    return -1;}
78ea1ba2f8e3ed7bc64348f7b7ea6abc4ee5f91d684a7686596eb3cb28cca7ae
setStatus
public void setStatus(int status)
{    this.status = (byte) status;}
61cb43d82252835d718b08d86716b3c5a59a26727416256da2f81161ca82b087
getFetchTime
public long getFetchTime()
{    return fetchTime;}
dcbaeb1d109387ae00d176058c6c2fc7b35db459ca1e879349bd2c20a40efb85
setFetchTime
public void setFetchTime(long fetchTime)
{    this.fetchTime = fetchTime;}
3ac36524a16c497c55545f5c1c05290d45d753bd3fb5963c919068bb52413184
getModifiedTime
public long getModifiedTime()
{    return modifiedTime;}
610f4697fe5c52932f629e4df59840f6fc6317298018cc94e61d716d3ec4872a
setModifiedTime
public void setModifiedTime(long modifiedTime)
{    this.modifiedTime = modifiedTime;}
cdf70ceecb7ceb68b4ad80c08f637ff2fa442018492d14439c57c3b9c70baf8e
getRetriesSinceFetch
public byte getRetriesSinceFetch()
{    return retries;}
17204de829ee37272b6080e5b2b19cd3852db36abc0bea0c02a89c5b68669b79
setRetriesSinceFetch
public void setRetriesSinceFetch(int retries)
{    this.retries = (byte) retries;}
034836507896643c925fb70df196afa37eccaeb89581fb274a65048d46f4efbe
getFetchInterval
public int getFetchInterval()
{    return fetchInterval;}
b2c1fc82b406b27e794c2ad8117445df4e6396bf5450d3c35a82e33032eede4c
setFetchInterval
public void setFetchInterval(int fetchInterval)
{    this.fetchInterval = fetchInterval;}
35515c0b523a269ac81d76b7eb28e2119d2fbbfecc32a3bf4237566523c8b203
setFetchInterval
public void setFetchInterval(float fetchInterval)
{    this.fetchInterval = Math.round(fetchInterval);}
6f4b0f5ea8fd7dfa3fdce005672f6f3b0532cd398e75b8550ffa1c7fe96a733a
getScore
public float getScore()
{    return score;}
071161dd3251af6621397d84e4f0add6eab4e69fea95694f972de14af000f45c
setScore
public void setScore(float score)
{    this.score = score;}
b70fa8115359524fb45d83fffe77397bbb0ed5e9ab0c9f3d1c1fbaffda29e4be
getSignature
public byte[] getSignature()
{    return signature;}
ca658f06690988af7571bee9012cca1aef1488bc35dad156a7dcb2664ebe8352
setSignature
public void setSignature(byte[] signature)
{    if (signature != null && signature.length > 256)        throw new RuntimeException("Max signature length (256) exceeded: " + signature.length);    this.signature = signature;}
558029183a6b9e5c383aea74ac8c70b0f9a4d3d96c5f68f2027033c80f4c70c7
setMetaData
public void setMetaData(org.apache.hadoop.io.MapWritable mapWritable)
{    this.metaData = new org.apache.hadoop.io.MapWritable(mapWritable);}
8bb2d9e3ad4e7e21b981e141f6a28f1c2d754ff7e2a071d7ae26f6be27e1d857
putAllMetaData
public void putAllMetaData(CrawlDatum other)
{    for (Entry<Writable, Writable> e : other.getMetaData().entrySet()) {        getMetaData().put(e.getKey(), e.getValue());    }}
59391903948e8f9916093feda9a31715b3b9730d02dc00144b48efa6b5d827ef
getMetaData
public org.apache.hadoop.io.MapWritable getMetaData()
{    if (this.metaData == null)        this.metaData = new org.apache.hadoop.io.MapWritable();    return this.metaData;}
4e53f10d7a0e7e05d06687db243495d14d6d098709e1f38dd4970d914adf66b4
read
public static CrawlDatum read(DataInput in) throws IOException
{    CrawlDatum result = new CrawlDatum();    result.readFields(in);    return result;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{        byte version = in.readByte();    if (    version > CUR_VERSION)        throw new VersionMismatchException(CUR_VERSION, version);    status = in.readByte();    fetchTime = in.readLong();    retries = in.readByte();    if (version > 5) {        fetchInterval = in.readInt();    } else        fetchInterval = Math.round(in.readFloat());    score = in.readFloat();    if (version > 2) {        modifiedTime = in.readLong();        int cnt = in.readByte();        if (cnt > 0) {            signature = new byte[cnt];            in.readFully(signature);        } else            signature = null;    }    if (version > 3) {        boolean hasMetadata = false;        if (version < 7) {            org.apache.hadoop.io.MapWritable oldMetaData = new org.apache.hadoop.io.MapWritable();            if (in.readBoolean()) {                hasMetadata = true;                metaData = new org.apache.hadoop.io.MapWritable();                oldMetaData.readFields(in);            }            for (Writable key : oldMetaData.keySet()) {                metaData.put(key, oldMetaData.get(key));            }        } else {            if (in.readBoolean()) {                hasMetadata = true;                metaData = new org.apache.hadoop.io.MapWritable();                metaData.readFields(in);            }        }        if (hasMetadata == false)            metaData = null;    }        if (version < 5) {        if (oldToNew.containsKey(status))            status = oldToNew.get(status);        else            status = STATUS_DB_UNFETCHED;    }}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{        out.writeByte(CUR_VERSION);    out.writeByte(status);    out.writeLong(fetchTime);    out.writeByte(retries);    out.writeInt(fetchInterval);    out.writeFloat(score);    out.writeLong(modifiedTime);    if (signature == null) {        out.writeByte(0);    } else {        out.writeByte(signature.length);        out.write(signature);    }    if (metaData != null && metaData.size() > 0) {        out.writeBoolean(true);        metaData.write(out);    } else {        out.writeBoolean(false);    }}
6da075b0713cf146d4230e83b96f637887b3f5c37b6431e1ecb22eba4655c04c
set
public void set(CrawlDatum that)
{    this.status = that.status;    this.fetchTime = that.fetchTime;    this.retries = that.retries;    this.fetchInterval = that.fetchInterval;    this.score = that.score;    this.modifiedTime = that.modifiedTime;    this.signature = that.signature;    if (that.metaData != null) {                this.metaData = new org.apache.hadoop.io.MapWritable(that.metaData);    } else {        this.metaData = null;    }}
f8c30bcd824babaa2dd280fef431845f5c769bad000e6d84ad5bedf5844cb28c
compareTo
public int compareTo(CrawlDatum that)
{    if (that.score != this.score)        return (that.score - this.score) > 0 ? 1 : -1;    if (that.status != this.status)        return this.status - that.status;    if (that.fetchTime != this.fetchTime)        return (that.fetchTime - this.fetchTime) > 0 ? 1 : -1;    if (that.retries != this.retries)        return that.retries - this.retries;    if (that.fetchInterval != this.fetchInterval)        return (that.fetchInterval - this.fetchInterval) > 0 ? 1 : -1;    if (that.modifiedTime != this.modifiedTime)        return (that.modifiedTime - this.modifiedTime) > 0 ? 1 : -1;    return SignatureComparator._compare(this, that);}
8cd74526bc7e7f20597a504e1ed768d1c3a048c7a382f95e889101f52fd94ec3
compare
public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2)
{    float score1 = readFloat(b1, s1 + SCORE_OFFSET);    float score2 = readFloat(b2, s2 + SCORE_OFFSET);    if (score2 != score1) {        return (score2 - score1) > 0 ? 1 : -1;    }    int status1 = b1[s1 + 1];    int status2 = b2[s2 + 1];    if (status2 != status1)        return status1 - status2;    long fetchTime1 = readLong(b1, s1 + 2);    long fetchTime2 = readLong(b2, s2 + 2);    if (fetchTime2 != fetchTime1)        return (fetchTime2 - fetchTime1) > 0 ? 1 : -1;    int retries1 = b1[s1 + 10];    int retries2 = b2[s2 + 10];    if (retries2 != retries1)        return retries2 - retries1;    int fetchInterval1 = readInt(b1, s1 + 11);    int fetchInterval2 = readInt(b2, s2 + 11);    if (fetchInterval2 != fetchInterval1)        return (fetchInterval2 - fetchInterval1) > 0 ? 1 : -1;    long modifiedTime1 = readLong(b1, s1 + SCORE_OFFSET + 4);    long modifiedTime2 = readLong(b2, s2 + SCORE_OFFSET + 4);    if (modifiedTime2 != modifiedTime1)        return (modifiedTime2 - modifiedTime1) > 0 ? 1 : -1;    int sigl1 = b1[s1 + SIG_OFFSET];    int sigl2 = b2[s2 + SIG_OFFSET];    return SignatureComparator._compare(b1, SIG_OFFSET, sigl1, b2, SIG_OFFSET, sigl2);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder buf = new StringBuilder();    buf.append("Version: " + CUR_VERSION + "\n");    buf.append("Status: " + getStatus() + " (" + getStatusName(getStatus()) + ")\n");    buf.append("Fetch time: " + new Date(getFetchTime()) + "\n");    buf.append("Modified time: " + new Date(getModifiedTime()) + "\n");    buf.append("Retries since fetch: " + getRetriesSinceFetch() + "\n");    buf.append("Retry interval: " + getFetchInterval() + " seconds (" + (getFetchInterval() / FetchSchedule.SECONDS_PER_DAY) + " days)\n");    buf.append("Score: " + getScore() + "\n");    buf.append("Signature: " + StringUtil.toHexString(getSignature()) + "\n");    buf.append("Metadata: \n ");    if (metaData != null) {        for (Entry<Writable, Writable> e : metaData.entrySet()) {            buf.append("\t");            buf.append(e.getKey());            buf.append("=");            buf.append(e.getValue());            buf.append("\n");        }    }    return buf.toString();}
78da27b06c9fe07fd29c63eeebd062201fb9904b5f8b7dc603598239069152de
metadataEquals
private boolean metadataEquals(org.apache.hadoop.io.MapWritable otherMetaData)
{    if (metaData == null || metaData.size() == 0) {        return otherMetaData == null || otherMetaData.size() == 0;    }    if (otherMetaData == null) {                return false;    }    HashSet<Entry<Writable, Writable>> set1 = new HashSet<>(metaData.entrySet());    HashSet<Entry<Writable, Writable>> set2 = new HashSet<>(otherMetaData.entrySet());    return set1.equals(set2);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof CrawlDatum))        return false;    CrawlDatum other = (CrawlDatum) o;    boolean res = (this.status == other.status) && (this.fetchTime == other.fetchTime) && (this.modifiedTime == other.modifiedTime) && (this.retries == other.retries) && (this.fetchInterval == other.fetchInterval) && (SignatureComparator._compare(this.signature, other.signature) == 0) && (this.score == other.score);    if (!res)        return res;    return metadataEquals(other.metaData);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int res = 0;    if (signature != null) {        for (int i = 0; i < signature.length / 4; i += 4) {            res ^= (signature[i] << 24 + signature[i + 1] << 16 + signature[i + 2] << 8 + signature[i + 3]);        }    }    if (metaData != null) {        res ^= metaData.entrySet().hashCode();    }    return res ^ status ^ ((int) fetchTime) ^ ((int) modifiedTime) ^ retries ^ fetchInterval ^ Float.floatToIntBits(score);}
38a346dd3b669981824e4b3da3c5ad6417c63d84aae517cdaa4a223d2c21e809
clone
public Object clone()
{    try {        return super.clone();    } catch (CloneNotSupportedException e) {        throw new RuntimeException(e);    }}
1e74ce02c0b38fd3019153c4dcd78e1bc4ebe6fe60c7b72735d17dd2d512ec6a
evaluate
public boolean evaluate(Expression expr, String url)
{    if (expr != null && url != null) {                JexlContext jcontext = new MapContext();                jcontext.set("url", url);        jcontext.set("status", getStatusName(getStatus()));        jcontext.set("fetchTime", (long) (getFetchTime()));        jcontext.set("modifiedTime", (long) (getModifiedTime()));        jcontext.set("retries", getRetriesSinceFetch());        jcontext.set("interval", Integer.valueOf(getFetchInterval()));        jcontext.set("score", getScore());        jcontext.set("signature", StringUtil.toHexString(getSignature()));                for (Map.Entry<Writable, Writable> entry : getMetaData().entrySet()) {            Object value = entry.getValue();            Text tkey = (Text) entry.getKey();            if (value instanceof FloatWritable) {                FloatWritable fvalue = (FloatWritable) value;                jcontext.set(tkey.toString(), fvalue.get());            }            if (value instanceof IntWritable) {                IntWritable ivalue = (IntWritable) value;                jcontext.set(tkey.toString(), ivalue.get());            }            if (value instanceof Text) {                Text tvalue = (Text) value;                jcontext.set(tkey.toString().replace("-", "_"), tvalue.toString());            }            if (value instanceof ProtocolStatus) {                ProtocolStatus pvalue = (ProtocolStatus) value;                jcontext.set(tkey.toString().replace("-", "_"), pvalue.toString());            }        }        try {            if (Boolean.TRUE.equals(expr.evaluate(jcontext))) {                return true;            }        } catch (Exception e) {                }    }    return false;}
c2fd617f04a80d25acff4c60e6055c46dfaa638876b7b3520f4a7dca7ff8893e
update
public void update(Path crawlDb, Path[] segments, boolean normalize, boolean filter) throws IOException, InterruptedException, ClassNotFoundException
{    boolean additionsAllowed = getConf().getBoolean(CRAWLDB_ADDITIONS_ALLOWED, true);    update(crawlDb, segments, normalize, filter, additionsAllowed, false);}
2cfc1d8aca12e26f874743f0da690681acd56a2e0471041619c904299185c12d
update
public void update(Path crawlDb, Path[] segments, boolean normalize, boolean filter, boolean additionsAllowed, boolean force) throws IOException, InterruptedException, ClassNotFoundException
{    Path lock = lock(getConf(), crawlDb, force);    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    long start = System.currentTimeMillis();    Job job = CrawlDb.createJob(getConf(), crawlDb);    Configuration conf = job.getConfiguration();    conf.setBoolean(CRAWLDB_ADDITIONS_ALLOWED, additionsAllowed);    conf.setBoolean(CrawlDbFilter.URL_FILTERING, filter);    conf.setBoolean(CrawlDbFilter.URL_NORMALIZING, normalize);    boolean url404Purging = conf.getBoolean(CRAWLDB_PURGE_404, false);    if (LOG.isInfoEnabled()) {        LOG.info("CrawlDb update: starting at " + sdf.format(start));        LOG.info("CrawlDb update: db: " + crawlDb);        LOG.info("CrawlDb update: segments: " + Arrays.asList(segments));        LOG.info("CrawlDb update: additions allowed: " + additionsAllowed);        LOG.info("CrawlDb update: URL normalizing: " + normalize);        LOG.info("CrawlDb update: URL filtering: " + filter);        LOG.info("CrawlDb update: 404 purging: " + url404Purging);    }    for (int i = 0; i < segments.length; i++) {        FileSystem sfs = segments[i].getFileSystem(getConf());        Path fetch = new Path(segments[i], CrawlDatum.FETCH_DIR_NAME);        Path parse = new Path(segments[i], CrawlDatum.PARSE_DIR_NAME);        if (sfs.exists(fetch)) {            FileInputFormat.addInputPath(job, fetch);            if (sfs.exists(parse)) {                FileInputFormat.addInputPath(job, parse);            } else {                LOG.info(" - adding fetched but unparsed segment " + segments[i]);            }        } else {            LOG.info(" - skipping invalid segment " + segments[i]);        }    }    if (LOG.isInfoEnabled()) {        LOG.info("CrawlDb update: Merging segment data into db.");    }    FileSystem fs = crawlDb.getFileSystem(getConf());    Path outPath = FileOutputFormat.getOutputPath(job);    try {        boolean success = job.waitForCompletion(true);        if (!success) {            String message = "CrawlDb update job did not succeed, job status:" + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);            NutchJob.cleanupAfterFailure(outPath, lock, fs);            throw new RuntimeException(message);        }    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error("CrawlDb update job failed: {}", e.getMessage());        NutchJob.cleanupAfterFailure(outPath, lock, fs);        throw e;    }    CrawlDb.install(job, crawlDb);    if (filter) {        long urlsFiltered = job.getCounters().findCounter("CrawlDB filter", "URLs filtered").getValue();        LOG.info("CrawlDb update: Total number of existing URLs in CrawlDb rejected by URL filters: {}", urlsFiltered);    }    long end = System.currentTimeMillis();    LOG.info("CrawlDb update: finished at " + sdf.format(end) + ", elapsed: " + TimingUtil.elapsedTime(start, end));}
fa5d9d849cc7b92f56218cd44b1e632dfc276a0a0e31c3d1178703f8fdaf807b
createJob
public static Job createJob(Configuration config, Path crawlDb) throws IOException
{    Path newCrawlDb = new Path(crawlDb, Integer.toString(new Random().nextInt(Integer.MAX_VALUE)));    Job job = NutchJob.getInstance(config);    job.setJobName("crawldb " + crawlDb);    Path current = new Path(crawlDb, CURRENT_NAME);    if (current.getFileSystem(job.getConfiguration()).exists(current)) {        FileInputFormat.addInputPath(job, current);    }    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setMapperClass(CrawlDbFilter.class);    job.setReducerClass(CrawlDbReducer.class);    job.setJarByClass(CrawlDb.class);    FileOutputFormat.setOutputPath(job, newCrawlDb);    job.setOutputFormatClass(MapFileOutputFormat.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(CrawlDatum.class);        job.getConfiguration().setBoolean("mapreduce.fileoutputcommitter.marksuccessfuljobs", false);    return job;}
4b7794f1269c5186e9b314ceb7ad0eedae2964722f068e5d081da9391b24ee99
lock
public static Path lock(Configuration job, Path crawlDb, boolean force) throws IOException
{    Path lock = new Path(crawlDb, LOCK_NAME);    LockUtil.createLockFile(job, lock, force);    return lock;}
d60dbe8481f6b98c030d9d8a6fdcf91cea9b3970ca18334ced691a9c6bbb3507
install
private static void install(Configuration conf, Path crawlDb, Path tempCrawlDb) throws IOException
{    boolean preserveBackup = conf.getBoolean("db.preserve.backup", true);    FileSystem fs = crawlDb.getFileSystem(conf);    Path old = new Path(crawlDb, "old");    Path current = new Path(crawlDb, CURRENT_NAME);    if (fs.exists(current)) {        FSUtils.replace(fs, old, current, true);    }    FSUtils.replace(fs, current, tempCrawlDb, true);    Path lock = new Path(crawlDb, LOCK_NAME);    LockUtil.removeLockFile(fs, lock);    if (!preserveBackup && fs.exists(old)) {        fs.delete(old, true);    }}
8460443f94aba5b5df978b8b60bc3df7adadad667c227a935122223bd2083591
install
public static void install(Job job, Path crawlDb) throws IOException
{    Configuration conf = job.getConfiguration();    Path tempCrawlDb = org.apache.hadoop.mapreduce.lib.output.FileOutputFormat.getOutputPath(job);    install(conf, crawlDb, tempCrawlDb);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int res = ToolRunner.run(NutchConfiguration.create(), new CrawlDb(), args);    System.exit(res);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    if (args.length < 1) {        System.err.println("Usage: CrawlDb <crawldb> (-dir <segments> | <seg1> <seg2> ...) [-force] [-normalize] [-filter] [-noAdditions]");        System.err.println("\tcrawldb\tCrawlDb to update");        System.err.println("\t-dir segments\tparent directory containing all segments to update from");        System.err.println("\tseg1 seg2 ...\tlist of segment names to update from");        System.err.println("\t-force\tforce update even if CrawlDb appears to be locked (CAUTION advised)");        System.err.println("\t-normalize\tuse URLNormalizer on urls in CrawlDb and segment (usually not needed)");        System.err.println("\t-filter\tuse URLFilters on urls in CrawlDb and segment");        System.err.println("\t-noAdditions\tonly update already existing URLs, don't add any newly discovered URLs");        return -1;    }    boolean normalize = getConf().getBoolean(CrawlDbFilter.URL_NORMALIZING, false);    boolean filter = getConf().getBoolean(CrawlDbFilter.URL_FILTERING, false);    boolean additionsAllowed = getConf().getBoolean(CRAWLDB_ADDITIONS_ALLOWED, true);    boolean force = false;    HashSet<Path> dirs = new HashSet<>();    for (int i = 1; i < args.length; i++) {        if (args[i].equals("-normalize")) {            normalize = true;        } else if (args[i].equals("-filter")) {            filter = true;        } else if (args[i].equals("-force")) {            force = true;        } else if (args[i].equals("-noAdditions")) {            additionsAllowed = false;        } else if (args[i].equals("-dir")) {            Path dirPath = new Path(args[++i]);            FileSystem fs = dirPath.getFileSystem(getConf());            FileStatus[] paths = fs.listStatus(dirPath, HadoopFSUtil.getPassDirectoriesFilter(fs));            dirs.addAll(Arrays.asList(HadoopFSUtil.getPaths(paths)));        } else {            dirs.add(new Path(args[i]));        }    }    try {        update(new Path(args[0]), dirs.toArray(new Path[dirs.size()]), normalize, filter, additionsAllowed, force);        return 0;    } catch (Exception e) {        LOG.error("CrawlDb update: " + StringUtils.stringifyException(e));        return -1;    }}
084523121ab64bd9486b37875e438171d2b2467ace02bce8523551b0ce84ace4
run
public Map<String, Object> run(Map<String, Object> args, String crawlId) throws Exception
{    Map<String, Object> results = new HashMap<>();    boolean normalize = getConf().getBoolean(CrawlDbFilter.URL_NORMALIZING, false);    boolean filter = getConf().getBoolean(CrawlDbFilter.URL_FILTERING, false);    boolean additionsAllowed = getConf().getBoolean(CRAWLDB_ADDITIONS_ALLOWED, true);    boolean force = false;    HashSet<Path> dirs = new HashSet<>();    if (args.containsKey("normalize")) {        normalize = true;    }    if (args.containsKey("filter")) {        filter = true;    }    if (args.containsKey("force")) {        force = true;    }    if (args.containsKey("noAdditions")) {        additionsAllowed = false;    }    Path crawlDb;    if (args.containsKey(Nutch.ARG_CRAWLDB)) {        Object crawldbPath = args.get(Nutch.ARG_CRAWLDB);        if (crawldbPath instanceof Path) {            crawlDb = (Path) crawldbPath;        } else {            crawlDb = new Path(crawldbPath.toString());        }    } else {        crawlDb = new Path(crawlId + "/crawldb");    }    Path segmentsDir;    if (args.containsKey(Nutch.ARG_SEGMENTDIR)) {        Object segDir = args.get(Nutch.ARG_SEGMENTDIR);        if (segDir instanceof Path) {            segmentsDir = (Path) segDir;        } else {            segmentsDir = new Path(segDir.toString());        }        FileSystem fs = segmentsDir.getFileSystem(getConf());        FileStatus[] paths = fs.listStatus(segmentsDir, HadoopFSUtil.getPassDirectoriesFilter(fs));        dirs.addAll(Arrays.asList(HadoopFSUtil.getPaths(paths)));    } else if (args.containsKey(Nutch.ARG_SEGMENTS)) {        Object segments = args.get(Nutch.ARG_SEGMENTS);        ArrayList<String> segmentList = new ArrayList<>();        if (segments instanceof ArrayList) {            segmentList = (ArrayList<String>) segments;        } else if (segments instanceof Path) {            segmentList.add(segments.toString());        }        for (String segment : segmentList) {            dirs.add(new Path(segment));        }    } else {        String segmentDir = crawlId + "/segments";        File dir = new File(segmentDir);        File[] segmentsList = dir.listFiles();        Arrays.sort(segmentsList, (f1, f2) -> {            if (f1.lastModified() > f2.lastModified())                return -1;            else                return 0;        });        dirs.add(new Path(segmentsList[0].getPath()));    }    try {        update(crawlDb, dirs.toArray(new Path[dirs.size()]), normalize, filter, additionsAllowed, force);        results.put(Nutch.VAL_RESULT, Integer.toString(0));        return results;    } catch (Exception e) {        LOG.error("CrawlDb update: " + StringUtils.stringifyException(e));        results.put(Nutch.VAL_RESULT, Integer.toString(-1));        return results;    }}
623f163ec558825248a1fcdcbb8a2356b954fedb3df76656b1cf8f53bd31c399
setup
public void setup(Mapper<Text, CrawlDatum, Text, CrawlDatum>.Context context)
{    Configuration conf = context.getConfiguration();    urlFiltering = conf.getBoolean(URL_FILTERING, false);    urlNormalizers = conf.getBoolean(URL_NORMALIZING, false);    url404Purging = conf.getBoolean(CrawlDb.CRAWLDB_PURGE_404, false);    purgeOrphans = conf.getBoolean(CrawlDb.CRAWLDB_PURGE_ORPHANS, false);    if (urlFiltering) {        filters = new URLFilters(conf);    }    if (urlNormalizers) {        scope = conf.get(URL_NORMALIZING_SCOPE, URLNormalizers.SCOPE_CRAWLDB);        normalizers = new URLNormalizers(conf, scope);    }}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{}
c7247fbb9a78b0f2bf1b83c7a1cc1acc3831c597de4ebbf8907dd8852659368e
map
public void map(Text key, CrawlDatum value, Context context) throws IOException, InterruptedException
{    String url = key.toString();        if (url404Purging && CrawlDatum.STATUS_DB_GONE == value.getStatus()) {        context.getCounter("CrawlDB filter", "Gone records removed").increment(1);        return;    }        if (purgeOrphans && CrawlDatum.STATUS_DB_ORPHAN == value.getStatus()) {        context.getCounter("CrawlDB filter", "Orphan records removed").increment(1);        return;    }    if (url != null && urlNormalizers) {        try {                        url = normalizers.normalize(url, scope);        } catch (Exception e) {            LOG.warn("Skipping " + url + ":" + e);            url = null;        }    }    if (url != null && urlFiltering) {        try {                        url = filters.filter(url);        } catch (Exception e) {            LOG.warn("Skipping " + url + ":" + e);            url = null;        }    }    if (url == null) {        context.getCounter("CrawlDB filter", "URLs filtered").increment(1);    } else {                        newKey.set(url);        context.write(newKey, value);    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{}
cc92acbea55a169b09e99adca01aa87ef99b44125994f5318867984c7790a849
setup
public void setup(Reducer<Text, CrawlDatum, Text, CrawlDatum>.Context context)
{    Configuration conf = context.getConfiguration();    schedule = FetchScheduleFactory.getFetchSchedule(conf);}
dfa33bb74c8851fea1ca7d1879839d7b539c5564809dc8824a9b4ec385276528
reduce
public void reduce(Text key, Iterable<CrawlDatum> values, Context context) throws IOException, InterruptedException
{    CrawlDatum res = new CrawlDatum();        res.setFetchTime(-1);    MapWritable meta = new MapWritable();    for (CrawlDatum val : values) {        if (isNewer(res, val)) {                        meta = mergeMeta(val.getMetaData(), meta);            res.set(val);        } else {                        meta = mergeMeta(meta, val.getMetaData());        }    }    res.setMetaData(meta);    context.write(key, res);}
5cee87c582cb533280ca0a7c76cbd77520555df2112e07d409efecf7a4bd9db6
isNewer
private boolean isNewer(CrawlDatum cd1, CrawlDatum cd2)
{    return schedule.calculateLastFetchTime(cd2) > schedule.calculateLastFetchTime(cd1) || schedule.calculateLastFetchTime(cd2) == schedule.calculateLastFetchTime(cd1) && cd2.getFetchTime() > cd1.getFetchTime();}
5bbbb06f797b207bde093de3743d21c9e43c9ada8454792e7d3e72eeeb2e5557
mergeMeta
private MapWritable mergeMeta(MapWritable from, MapWritable to)
{    for (Entry<Writable, Writable> e : from.entrySet()) {        to.put(e.getKey(), e.getValue());    }    return to;}
37c18367d0f036d6705d47c4c1808b5d1ebbb63d9a3d6e4e3f1552a3b25489e7
merge
public void merge(Path output, Path[] dbs, boolean normalize, boolean filter) throws Exception
{    Path lock = CrawlDb.lock(getConf(), output, false);    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    long start = System.currentTimeMillis();    LOG.info("CrawlDb merge: starting at " + sdf.format(start));    Job job = createMergeJob(getConf(), output, normalize, filter);    for (int i = 0; i < dbs.length; i++) {        if (LOG.isInfoEnabled()) {            LOG.info("Adding " + dbs[i]);        }        FileInputFormat.addInputPath(job, new Path(dbs[i], CrawlDb.CURRENT_NAME));    }    Path outPath = FileOutputFormat.getOutputPath(job);    FileSystem fs = outPath.getFileSystem(getConf());    try {        boolean success = job.waitForCompletion(true);        if (!success) {            String message = "CrawlDbMerger job did not succeed, job status:" + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);            NutchJob.cleanupAfterFailure(outPath, lock, fs);            throw new RuntimeException(message);        }        CrawlDb.install(job, output);    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error("CrawlDbMerge job failed: {}", e.getMessage());        NutchJob.cleanupAfterFailure(outPath, lock, fs);        throw e;    }    long end = System.currentTimeMillis();    LOG.info("CrawlDb merge: finished at " + sdf.format(end) + ", elapsed: " + TimingUtil.elapsedTime(start, end));}
b46e02466b97b08495a9067f1672867ed7b610a943be48f69a18c0f1dfe10343
createMergeJob
public static Job createMergeJob(Configuration conf, Path output, boolean normalize, boolean filter) throws IOException
{    Path newCrawlDb = new Path(output, "merge-" + Integer.toString(new Random().nextInt(Integer.MAX_VALUE)));    Job job = NutchJob.getInstance(conf);    conf = job.getConfiguration();    job.setJobName("crawldb merge " + output);    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setJarByClass(CrawlDbMerger.class);    job.setMapperClass(CrawlDbFilter.class);    conf.setBoolean(CrawlDbFilter.URL_FILTERING, filter);    conf.setBoolean(CrawlDbFilter.URL_NORMALIZING, normalize);    job.setReducerClass(Merger.class);    FileOutputFormat.setOutputPath(job, newCrawlDb);    job.setOutputFormatClass(MapFileOutputFormat.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(CrawlDatum.class);    return job;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int res = ToolRunner.run(NutchConfiguration.create(), new CrawlDbMerger(), args);    System.exit(res);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    if (args.length < 2) {        System.err.println("Usage: CrawlDbMerger <output_crawldb> <crawldb1> [<crawldb2> <crawldb3> ...] [-normalize] [-filter]");        System.err.println("\toutput_crawldb\toutput CrawlDb");        System.err.println("\tcrawldb1 ...\tinput CrawlDb-s (single input CrawlDb is ok)");        System.err.println("\t-normalize\tuse URLNormalizer on urls in the crawldb(s) (usually not needed)");        System.err.println("\t-filter\tuse URLFilters on urls in the crawldb(s)");        return -1;    }    Path output = new Path(args[0]);    ArrayList<Path> dbs = new ArrayList<>();    boolean filter = false;    boolean normalize = false;    for (int i = 1; i < args.length; i++) {        if ("-filter".equals(args[i])) {            filter = true;            continue;        } else if ("-normalize".equals(args[i])) {            normalize = true;            continue;        }        final Path dbPath = new Path(args[i]);        FileSystem fs = dbPath.getFileSystem(getConf());        if (fs.exists(dbPath))            dbs.add(dbPath);    }    try {        merge(output, dbs.toArray(new Path[dbs.size()]), normalize, filter);        return 0;    } catch (Exception e) {        LOG.error("CrawlDb merge: " + StringUtils.stringifyException(e));        return -1;    }}
d383baacda15448f20f31cc977358cc507c9f757030d1571238d9c0fc12bb6c0
openReaders
private void openReaders(String crawlDb, Configuration config) throws IOException
{    if (readers != null)        return;    Path crawlDbPath = new Path(crawlDb, CrawlDb.CURRENT_NAME);    readers = MapFileOutputFormat.getReaders(crawlDbPath, config);}
f4c9b3570bfc7c26cee1106d0b648555131b44831a6ed8431c80653b43ae7f87
closeReaders
private void closeReaders()
{    if (readers == null)        return;    for (int i = 0; i < readers.length; i++) {        try {            readers[i].close();        } catch (Exception e) {        }    }    readers = null;}
831d68ee855931c823d3f7c4963952b0861bd5b943b7e8d7a277ac213838d5cb
write
public synchronized void write(Text key, CrawlDatum value) throws IOException
{    out.writeByte('"');    out.writeBytes(key.toString());    out.writeByte('"');    out.writeByte(',');    out.writeBytes(Integer.toString(value.getStatus()));    out.writeByte(',');    out.writeByte('"');    out.writeBytes(CrawlDatum.getStatusName(value.getStatus()));    out.writeByte('"');    out.writeByte(',');    out.writeBytes(new Date(value.getFetchTime()).toString());    out.writeByte(',');    out.writeBytes(new Date(value.getModifiedTime()).toString());    out.writeByte(',');    out.writeBytes(Integer.toString(value.getRetriesSinceFetch()));    out.writeByte(',');    out.writeBytes(Float.toString(value.getFetchInterval()));    out.writeByte(',');    out.writeBytes(Float.toString((value.getFetchInterval() / FetchSchedule.SECONDS_PER_DAY)));    out.writeByte(',');    out.writeBytes(Float.toString(value.getScore()));    out.writeByte(',');    out.writeByte('"');    out.writeBytes(value.getSignature() != null ? StringUtil.toHexString(value.getSignature()) : "null");    out.writeByte('"');    out.writeByte(',');    out.writeByte('"');    if (value.getMetaData() != null) {        for (Entry<Writable, Writable> e : value.getMetaData().entrySet()) {            out.writeBytes(e.getKey().toString());            out.writeByte(':');            out.writeBytes(e.getValue().toString());            out.writeBytes("|||");        }    }    out.writeByte('"');    out.writeByte('\n');}
f42b50fb7405fe3efd4bb24b63737025e0636e50456f86048e6f0d55a98a39c6
close
public synchronized void close(TaskAttemptContext context) throws IOException
{    out.close();}
be935341d889480a9b0779d98832f769de66c2cb925bdc2b427839461d1fc9b4
getRecordWriter
public RecordWriter<Text, CrawlDatum> getRecordWriter(TaskAttemptContext context) throws IOException
{    String name = getUniqueFile(context, "part", "");    Path dir = FileOutputFormat.getOutputPath(context);    FileSystem fs = dir.getFileSystem(context.getConfiguration());    DataOutputStream fileOut = fs.create(new Path(dir, name), context);    return new LineRecordWriter(fileOut);}
7ce364559169b6584b8d7e22affb4c51bfb4744fada2d867c12bd2914538abc0
setup
public void setup(Mapper<Text, CrawlDatum, Text, NutchWritable>.Context context)
{    Configuration conf = context.getConfiguration();    sort = conf.getBoolean("db.reader.stats.sort", false);}
c7247fbb9a78b0f2bf1b83c7a1cc1acc3831c597de4ebbf8907dd8852659368e
map
public void map(Text key, CrawlDatum value, Context context) throws IOException, InterruptedException
{    context.write(new Text("T"), COUNT_1);    context.write(new Text("status " + value.getStatus()), COUNT_1);    context.write(new Text("retry " + value.getRetriesSinceFetch()), COUNT_1);    if (Float.isNaN(value.getScore())) {        context.write(new Text("scNaN"), COUNT_1);    } else {        NutchWritable score = new NutchWritable(new FloatWritable(value.getScore()));        context.write(new Text("sc"), score);        context.write(new Text("sct"), score);        context.write(new Text("scd"), score);    }        NutchWritable fetchTime = new NutchWritable(new LongWritable(value.getFetchTime() / (1000 * 60)));    context.write(new Text("ft"), fetchTime);    context.write(new Text("ftt"), fetchTime);        NutchWritable fetchInterval = new NutchWritable(new LongWritable(value.getFetchInterval()));    context.write(new Text("fi"), fetchInterval);    context.write(new Text("fit"), fetchInterval);    if (sort) {        URL u = new URL(key.toString());        String host = u.getHost();        context.write(new Text("status " + value.getStatus() + " " + host), COUNT_1);    }}
b864d41dd79800483b325687dd2947814f49e293f85d5c289cd8b341c1f7d256
setup
public void setup(Reducer<Text, NutchWritable, Text, NutchWritable>.Context context)
{}
3a173d62b9c64632e8a5b3717dd7b139e87082c27f02e1c5ea40d48edc27b47b
reduce
public void reduce(Text key, Iterable<NutchWritable> values, Context context) throws IOException, InterruptedException
{    String k = key.toString();    if (k.equals("T") || k.startsWith("status") || k.startsWith("retry") || k.equals("ftt") || k.equals("fit")) {                long sum = 0;        for (NutchWritable value : values) {            sum += ((LongWritable) value.get()).get();        }                context.write(key, new NutchWritable(new LongWritable(sum)));    } else if (k.equals("sc")) {        float min = Float.MAX_VALUE;        float max = Float.MIN_VALUE;        for (NutchWritable nvalue : values) {            float value = ((FloatWritable) nvalue.get()).get();            if (max < value) {                max = value;            }            if (min > value) {                min = value;            }        }        context.write(key, new NutchWritable(new FloatWritable(min)));        context.write(key, new NutchWritable(new FloatWritable(max)));    } else if (k.equals("ft") || k.equals("fi")) {        long min = Long.MAX_VALUE;        long max = Long.MIN_VALUE;        for (NutchWritable nvalue : values) {            long value = ((LongWritable) nvalue.get()).get();            if (max < value) {                max = value;            }            if (min > value) {                min = value;            }        }        context.write(key, new NutchWritable(new LongWritable(min)));        context.write(key, new NutchWritable(new LongWritable(max)));    } else if (k.equals("sct")) {        float cnt = 0.0f;        for (NutchWritable nvalue : values) {            float value = ((FloatWritable) nvalue.get()).get();            cnt += value;        }        context.write(key, new NutchWritable(new FloatWritable(cnt)));    } else if (k.equals("scd")) {        MergingDigest tdigest = null;        for (NutchWritable nvalue : values) {            Writable value = nvalue.get();            if (value instanceof BytesWritable) {                byte[] bytes = ((BytesWritable) value).getBytes();                MergingDigest tdig = MergingDigest.fromBytes(ByteBuffer.wrap(bytes));                if (tdigest == null) {                    tdigest = tdig;                } else {                    tdigest.add(tdig);                }            } else if (value instanceof FloatWritable) {                float val = ((FloatWritable) value).get();                if (!Float.isNaN(val)) {                    if (tdigest == null) {                        tdigest = (MergingDigest) TDigest.createMergingDigest(100.0);                    }                    tdigest.add(val);                }            }        }        ByteBuffer tdigestBytes = ByteBuffer.allocate(tdigest.smallByteSize());        tdigest.asSmallBytes(tdigestBytes);        context.write(key, new NutchWritable(new BytesWritable(tdigestBytes.array())));    }}
a6f81ec08ef7074f9561a7d35a360ecdda8abf76d482cea9d829cc11d8be70af
setup
public void setup(Mapper<Text, CrawlDatum, FloatWritable, Text>.Context context)
{    Configuration conf = context.getConfiguration();    min = conf.getFloat("db.reader.topn.min", 0.0f);}
c7247fbb9a78b0f2bf1b83c7a1cc1acc3831c597de4ebbf8907dd8852659368e
map
public void map(Text key, CrawlDatum value, Context context) throws IOException, InterruptedException
{    if (value.getScore() < min)                return;        fw.set(-value.getScore());        context.write(fw, key);}
f8f7b021e550c422a98af8d0c82511387c65ef5c15a06383b56757cb4f748d61
reduce
public void reduce(FloatWritable key, Iterable<Text> values, Context context) throws IOException, InterruptedException
{    for (Text value : values) {        if (count < topN) {            key.set(-key.get());            context.write(key, value);            count++;        }    }}
805637f606b8306e06faf21f7999e3da6b1cff8a06426222e13382ad22af5910
setup
public void setup(Reducer<FloatWritable, Text, FloatWritable, Text>.Context context)
{    Configuration conf = context.getConfiguration();    topN = conf.getLong("db.reader.topn", 100) / Integer.parseInt(conf.get("mapreduce.job.reduces"));}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    closeReaders();}
341949d36acb3e20e37ea9cc044fa9035ef321e77d03c094bf8b92a5816aedc6
processStatJobHelper
private TreeMap<String, Writable> processStatJobHelper(String crawlDb, Configuration config, boolean sort) throws IOException, InterruptedException, ClassNotFoundException
{    Path tmpFolder = new Path(crawlDb, "stat_tmp" + System.currentTimeMillis());    Job job = NutchJob.getInstance(config);    config = job.getConfiguration();    job.setJobName("stats " + crawlDb);    config.setBoolean("db.reader.stats.sort", sort);    FileInputFormat.addInputPath(job, new Path(crawlDb, CrawlDb.CURRENT_NAME));    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setJarByClass(CrawlDbReader.class);    job.setMapperClass(CrawlDbStatMapper.class);    job.setCombinerClass(CrawlDbStatReducer.class);    job.setReducerClass(CrawlDbStatReducer.class);    FileOutputFormat.setOutputPath(job, tmpFolder);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(NutchWritable.class);        config.setBoolean("mapreduce.fileoutputcommitter.marksuccessfuljobs", false);    FileSystem fileSystem = tmpFolder.getFileSystem(config);    try {        boolean success = job.waitForCompletion(true);        if (!success) {            String message = "CrawlDbReader job did not succeed, job status:" + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);            fileSystem.delete(tmpFolder, true);            throw new RuntimeException(message);        }    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error(StringUtils.stringifyException(e));        fileSystem.delete(tmpFolder, true);        throw e;    }        SequenceFile.Reader[] readers = SegmentReaderUtil.getReaders(tmpFolder, config);    Text key = new Text();    NutchWritable value = new NutchWritable();    TreeMap<String, Writable> stats = new TreeMap<>();    for (int i = 0; i < readers.length; i++) {        SequenceFile.Reader reader = readers[i];        while (reader.next(key, value)) {            String k = key.toString();            Writable val = stats.get(k);            if (val == null) {                stats.put(k, value.get());                continue;            }            if (k.equals("sc")) {                float min = Float.MAX_VALUE;                float max = Float.MIN_VALUE;                if (stats.containsKey("scn")) {                    min = ((FloatWritable) stats.get("scn")).get();                } else {                    min = ((FloatWritable) stats.get("sc")).get();                }                if (stats.containsKey("scx")) {                    max = ((FloatWritable) stats.get("scx")).get();                } else {                    max = ((FloatWritable) stats.get("sc")).get();                }                float fvalue = ((FloatWritable) value.get()).get();                if (min > fvalue) {                    min = fvalue;                }                if (max < fvalue) {                    max = fvalue;                }                stats.put("scn", new FloatWritable(min));                stats.put("scx", new FloatWritable(max));            } else if (k.equals("ft") || k.equals("fi")) {                long min = Long.MAX_VALUE;                long max = Long.MIN_VALUE;                String minKey = k + "n";                String maxKey = k + "x";                if (stats.containsKey(minKey)) {                    min = ((LongWritable) stats.get(minKey)).get();                } else if (stats.containsKey(k)) {                    min = ((LongWritable) stats.get(k)).get();                }                if (stats.containsKey(maxKey)) {                    max = ((LongWritable) stats.get(maxKey)).get();                } else if (stats.containsKey(k)) {                    max = ((LongWritable) stats.get(k)).get();                }                long lvalue = ((LongWritable) value.get()).get();                if (min > lvalue) {                    min = lvalue;                }                if (max < lvalue) {                    max = lvalue;                }                stats.put(k + "n", new LongWritable(min));                stats.put(k + "x", new LongWritable(max));            } else if (k.equals("sct")) {                FloatWritable fvalue = (FloatWritable) value.get();                ((FloatWritable) val).set(((FloatWritable) val).get() + fvalue.get());            } else if (k.equals("scd")) {                MergingDigest tdigest = null;                MergingDigest tdig = MergingDigest.fromBytes(ByteBuffer.wrap(((BytesWritable) value.get()).getBytes()));                if (val instanceof BytesWritable) {                    tdigest = MergingDigest.fromBytes(ByteBuffer.wrap(((BytesWritable) val).getBytes()));                    tdigest.add(tdig);                } else {                    tdigest = tdig;                }                ByteBuffer tdigestBytes = ByteBuffer.allocate(tdigest.smallByteSize());                tdigest.asSmallBytes(tdigestBytes);                stats.put(k, new BytesWritable(tdigestBytes.array()));            } else {                LongWritable lvalue = (LongWritable) value.get();                ((LongWritable) val).set(((LongWritable) val).get() + lvalue.get());            }        }        reader.close();    }            stats.remove("sc");    stats.remove("fi");    stats.remove("ft");        fileSystem.delete(tmpFolder, true);    return stats;}
80e61231e22e487632ff0a3c118dc8f9e76191355fc79ab0c7106451b76e95f1
processStatJob
public void processStatJob(String crawlDb, Configuration config, boolean sort) throws IOException, InterruptedException, ClassNotFoundException
{    double[] quantiles = { .01, .05, .1, .2, .25, .3, .4, .5, .6, .7, .75, .8, .9, .95, .99 };    if (config.get("db.stats.score.quantiles") != null) {        List<Double> qs = new ArrayList<>();        for (String s : config.getStrings("db.stats.score.quantiles")) {            try {                double d = Double.parseDouble(s);                if (d >= 0.0 && d <= 1.0) {                    qs.add(d);                } else {                    LOG.warn("Skipping quantile {} not in range in db.stats.score.quantiles", s);                }            } catch (NumberFormatException e) {                LOG.warn("Skipping bad floating point number {} in db.stats.score.quantiles: {}", s, e.getMessage());            }            quantiles = new double[qs.size()];            int i = 0;            for (Double q : qs) {                quantiles[i++] = q;            }            Arrays.sort(quantiles);        }    }    if (LOG.isInfoEnabled()) {        LOG.info("CrawlDb statistics start: " + crawlDb);    }    TreeMap<String, Writable> stats = processStatJobHelper(crawlDb, config, sort);    if (LOG.isInfoEnabled()) {        LOG.info("Statistics for CrawlDb: " + crawlDb);        LongWritable totalCnt = new LongWritable(0);        if (stats.containsKey("T")) {            totalCnt = ((LongWritable) stats.get("T"));            stats.remove("T");        }        LOG.info("TOTAL urls:\t" + totalCnt.get());        for (Map.Entry<String, Writable> entry : stats.entrySet()) {            String k = entry.getKey();            long value = 0;            double fvalue = 0.0;            byte[] bytesValue = null;            Writable val = entry.getValue();            if (val instanceof LongWritable) {                value = ((LongWritable) val).get();            } else if (val instanceof FloatWritable) {                fvalue = ((FloatWritable) val).get();            } else if (val instanceof BytesWritable) {                bytesValue = ((BytesWritable) val).getBytes();            }            if (k.equals("scn")) {                LOG.info("min score:\t" + fvalue);            } else if (k.equals("scx")) {                LOG.info("max score:\t" + fvalue);            } else if (k.equals("sct")) {                LOG.info("avg score:\t" + (fvalue / totalCnt.get()));            } else if (k.equals("scNaN")) {                LOG.info("score == NaN:\t" + value);            } else if (k.equals("ftn")) {                LOG.info("earliest fetch time:\t" + new Date(1000 * 60 * value));            } else if (k.equals("ftx")) {                LOG.info("latest fetch time:\t" + new Date(1000 * 60 * value));            } else if (k.equals("ftt")) {                LOG.info("avg of fetch times:\t" + new Date(1000 * 60 * (value / totalCnt.get())));            } else if (k.equals("fin")) {                LOG.info("shortest fetch interval:\t{}", TimingUtil.secondsToDaysHMS(value));            } else if (k.equals("fix")) {                LOG.info("longest fetch interval:\t{}", TimingUtil.secondsToDaysHMS(value));            } else if (k.equals("fit")) {                LOG.info("avg fetch interval:\t{}", TimingUtil.secondsToDaysHMS(value / totalCnt.get()));            } else if (k.startsWith("status")) {                String[] st = k.split(" ");                int code = Integer.parseInt(st[1]);                if (st.length > 2)                    LOG.info("   " + st[2] + " :\t" + val);                else                    LOG.info(st[0] + " " + code + " (" + CrawlDatum.getStatusName((byte) code) + "):\t" + val);            } else if (k.equals("scd")) {                MergingDigest tdigest = MergingDigest.fromBytes(ByteBuffer.wrap(bytesValue));                for (double q : quantiles) {                    LOG.info("score quantile {}:\t{}", q, tdigest.quantile(q));                }            } else {                LOG.info(k + ":\t" + val);            }        }    }    if (LOG.isInfoEnabled()) {        LOG.info("CrawlDb statistics: done");    }}
dba8143a2a8108aafd3a29d79f93ffe681148bb6e7c4546e80f0da89aaeb52ad
get
public CrawlDatum get(String crawlDb, String url, Configuration config) throws IOException
{    Text key = new Text(url);    CrawlDatum val = new CrawlDatum();    openReaders(crawlDb, config);    CrawlDatum res = (CrawlDatum) MapFileOutputFormat.getEntry(readers, new HashPartitioner<>(), key, val);    return res;}
5a9c6fab723cd06e037823885214041aae316eb36f109c0513491669cd33e005
process
protected int process(String line, StringBuilder output) throws Exception
{    Job job = NutchJob.getInstance(getConf());    Configuration config = job.getConfiguration();        closeReaders();    readUrl(this.crawlDb, line, config, output);    return 0;}
5e6c6bee8754aea172aae26ccb033130320637182941e65bc4ae261cd3243f2e
readUrl
public void readUrl(String crawlDb, String url, Configuration config, StringBuilder output) throws IOException
{    CrawlDatum res = get(crawlDb, url, config);    output.append("URL: " + url + "\n");    if (res != null) {        output.append(res);    } else {        output.append("not found");    }    output.append("\n");}
992eef5c45b354b41b82df71925204eaabc183fdfc25274216f8ec4842200f43
processDumpJob
public void processDumpJob(String crawlDb, String output, Configuration config, String format, String regex, String status, Integer retry, String expr, Float sample) throws IOException, ClassNotFoundException, InterruptedException
{    if (LOG.isInfoEnabled()) {        LOG.info("CrawlDb dump: starting");        LOG.info("CrawlDb db: " + crawlDb);    }    Path outFolder = new Path(output);    Job job = NutchJob.getInstance(config);    job.setJobName("dump " + crawlDb);    Configuration jobConf = job.getConfiguration();    FileInputFormat.addInputPath(job, new Path(crawlDb, CrawlDb.CURRENT_NAME));    job.setInputFormatClass(SequenceFileInputFormat.class);    FileOutputFormat.setOutputPath(job, outFolder);    if (format.equals("csv")) {        job.setOutputFormatClass(CrawlDatumCsvOutputFormat.class);    } else if (format.equals("crawldb")) {        job.setOutputFormatClass(MapFileOutputFormat.class);    } else {        job.setOutputFormatClass(TextOutputFormat.class);    }    if (status != null)        jobConf.set("status", status);    if (regex != null)        jobConf.set("regex", regex);    if (retry != null)        jobConf.setInt("retry", retry);    if (expr != null) {        jobConf.set("expr", expr);        LOG.info("CrawlDb db: expr: " + expr);    }    if (sample != null) {        jobConf.setFloat("sample", sample);    }    job.setMapperClass(CrawlDbDumpMapper.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(CrawlDatum.class);    job.setJarByClass(CrawlDbReader.class);    try {        boolean success = job.waitForCompletion(true);        if (!success) {            String message = "CrawlDbReader job did not succeed, job status:" + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);            throw new RuntimeException(message);        }    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error(StringUtils.stringifyException(e));        throw e;    }    if (LOG.isInfoEnabled()) {        LOG.info("CrawlDb dump: done");    }}
623f163ec558825248a1fcdcbb8a2356b954fedb3df76656b1cf8f53bd31c399
setup
public void setup(Mapper<Text, CrawlDatum, Text, CrawlDatum>.Context context)
{    Configuration config = context.getConfiguration();    if (config.get("regex", null) != null) {        pattern = Pattern.compile(config.get("regex"));    }    status = config.get("status", null);    retry = config.getInt("retry", -1);    if (config.get("expr", null) != null) {        expr = JexlUtil.parseExpression(config.get("expr", null));    }    sample = config.getFloat("sample", 1);}
c7247fbb9a78b0f2bf1b83c7a1cc1acc3831c597de4ebbf8907dd8852659368e
map
public void map(Text key, CrawlDatum value, Context context) throws IOException, InterruptedException
{        if (sample < 1 && Math.random() > sample) {        return;    }        if (retry != -1) {        if (value.getRetriesSinceFetch() < retry) {            return;        }    }        if (status != null && !status.equalsIgnoreCase(CrawlDatum.getStatusName(value.getStatus())))        return;        if (pattern != null) {        matcher = pattern.matcher(key.toString());        if (!matcher.matches()) {            return;        }    }        if (expr != null) {        if (!value.evaluate(expr, key.toString())) {            return;        }    }    context.write(key, value);}
505697bc5bdcbad31a903e04e335b1093439244763ba8c889251e21328963aa2
processTopNJob
public void processTopNJob(String crawlDb, long topN, float min, String output, Configuration config) throws IOException, ClassNotFoundException, InterruptedException
{    if (LOG.isInfoEnabled()) {        LOG.info("CrawlDb topN: starting (topN=" + topN + ", min=" + min + ")");        LOG.info("CrawlDb db: " + crawlDb);    }    Path outFolder = new Path(output);    Path tempDir = new Path(config.get("mapreduce.cluster.temp.dir", ".") + "/readdb-topN-temp-" + Integer.toString(new Random().nextInt(Integer.MAX_VALUE)));    Job job = NutchJob.getInstance(config);    job.setJobName("topN prepare " + crawlDb);    FileInputFormat.addInputPath(job, new Path(crawlDb, CrawlDb.CURRENT_NAME));    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setJarByClass(CrawlDbReader.class);    job.setMapperClass(CrawlDbTopNMapper.class);    job.setReducerClass(Reducer.class);    FileOutputFormat.setOutputPath(job, tempDir);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    job.setOutputKeyClass(FloatWritable.class);    job.setOutputValueClass(Text.class);    job.getConfiguration().setFloat("db.reader.topn.min", min);    FileSystem fs = tempDir.getFileSystem(config);    try {        boolean success = job.waitForCompletion(true);        if (!success) {            String message = "CrawlDbReader job did not succeed, job status:" + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);            fs.delete(tempDir, true);            throw new RuntimeException(message);        }    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error(StringUtils.stringifyException(e));        fs.delete(tempDir, true);        throw e;    }    if (LOG.isInfoEnabled()) {        LOG.info("CrawlDb topN: collecting topN scores.");    }    job = NutchJob.getInstance(config);    job.setJobName("topN collect " + crawlDb);    job.getConfiguration().setLong("db.reader.topn", topN);    FileInputFormat.addInputPath(job, tempDir);    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setMapperClass(Mapper.class);    job.setReducerClass(CrawlDbTopNReducer.class);    job.setJarByClass(CrawlDbReader.class);    FileOutputFormat.setOutputPath(job, outFolder);    job.setOutputFormatClass(TextOutputFormat.class);    job.setOutputKeyClass(FloatWritable.class);    job.setOutputValueClass(Text.class);        job.setNumReduceTasks(1);    try {        boolean success = job.waitForCompletion(true);        if (!success) {            String message = "CrawlDbReader job did not succeed, job status:" + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);            fs.delete(tempDir, true);            throw new RuntimeException(message);        }    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error(StringUtils.stringifyException(e));        fs.delete(tempDir, true);        throw e;    }    fs.delete(tempDir, true);    if (LOG.isInfoEnabled()) {        LOG.info("CrawlDb topN: done");    }}
264f042392273a74ed569ca10b126227951f251a8f9aa6457b4848b3a581606d
run
public int run(String[] args) throws IOException, InterruptedException, ClassNotFoundException, Exception
{    @SuppressWarnings("resource")    CrawlDbReader dbr = new CrawlDbReader();    if (args.length < 2) {        System.err.println("Usage: CrawlDbReader <crawldb> (-stats | -dump <out_dir> | -topN <nnnn> <out_dir> [<min>] | -url <url>)");        System.err.println("\t<crawldb>\tdirectory name where crawldb is located");        System.err.println("\t-stats [-sort] \tprint overall statistics to System.out");        System.err.println("\t\t[-sort]\tlist status sorted by host");        System.err.println("\t-dump <out_dir> [-format normal|csv|crawldb]\tdump the whole db to a text file in <out_dir>");        System.err.println("\t\t[-format csv]\tdump in Csv format");        System.err.println("\t\t[-format normal]\tdump in standard format (default option)");        System.err.println("\t\t[-format crawldb]\tdump as CrawlDB");        System.err.println("\t\t[-regex <expr>]\tfilter records with expression");        System.err.println("\t\t[-retry <num>]\tminimum retry count");        System.err.println("\t\t[-status <status>]\tfilter records by CrawlDatum status");        System.err.println("\t\t[-expr <expr>]\tJexl expression to evaluate for this record");        System.err.println("\t\t[-sample <fraction>]\tOnly process a random sample with this ratio");        System.err.println("\t-url <url>\tprint information on <url> to System.out");        System.err.println("\t-topN <nnnn> <out_dir> [<min>]\tdump top <nnnn> urls sorted by score to <out_dir>");        System.err.println("\t\t[<min>]\tskip records with scores below this value.");        System.err.println("\t\t\tThis can significantly improve performance.");        return -1;    }    String param = null;    String crawlDb = args[0];    this.crawlDb = crawlDb;    int numConsumed = 0;    Configuration config = getConf();    for (int i = 1; i < args.length; i++) {        if (args[i].equals("-stats")) {            boolean toSort = false;            if (i < args.length - 1 && "-sort".equals(args[i + 1])) {                toSort = true;                i++;            }            dbr.processStatJob(crawlDb, config, toSort);        } else if (args[i].equals("-dump")) {            param = args[++i];            String format = "normal";            String regex = null;            Integer retry = null;            String status = null;            String expr = null;            Float sample = null;            for (int j = i + 1; j < args.length; j++) {                if (args[j].equals("-format")) {                    format = args[++j];                    i = i + 2;                }                if (args[j].equals("-regex")) {                    regex = args[++j];                    i = i + 2;                }                if (args[j].equals("-retry")) {                    retry = Integer.parseInt(args[++j]);                    i = i + 2;                }                if (args[j].equals("-status")) {                    status = args[++j];                    i = i + 2;                }                if (args[j].equals("-expr")) {                    expr = args[++j];                    i = i + 2;                }                if (args[j].equals("-sample")) {                    sample = Float.parseFloat(args[++j]);                    i = i + 2;                }            }            dbr.processDumpJob(crawlDb, param, config, format, regex, status, retry, expr, sample);        } else if (args[i].equals("-url")) {            param = args[++i];            StringBuilder output = new StringBuilder();            dbr.readUrl(crawlDb, param, config, output);            System.out.print(output);        } else if (args[i].equals("-topN")) {            param = args[++i];            long topN = Long.parseLong(param);            param = args[++i];            float min = 0.0f;            if (i < args.length - 1) {                min = Float.parseFloat(args[++i]);            }            dbr.processTopNJob(crawlDb, topN, min, param, config);        } else if ((numConsumed = super.parseArgs(args, i)) > 0) {            i += numConsumed - 1;        } else {            System.err.println("\nError: wrong argument " + args[i]);            return -1;        }    }    if (numConsumed > 0) {                return super.run();    }    return 0;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int result = ToolRunner.run(NutchConfiguration.create(), new CrawlDbReader(), args);    System.exit(result);}
52a3c695c3e670a6da3994d007070953cf5dbc8364dfc2805cf978a136b38990
query
public Object query(Map<String, String> args, Configuration conf, String type, String crawlId) throws Exception
{    Map<String, Object> results = new HashMap<>();    String crawlDb = crawlId + "/crawldb";    if (type.equalsIgnoreCase("stats")) {        boolean sort = false;        if (args.containsKey("sort")) {            if (args.get("sort").equalsIgnoreCase("true"))                sort = true;        }        TreeMap<String, Writable> stats = processStatJobHelper(crawlDb, NutchConfiguration.create(), sort);        LongWritable totalCnt = (LongWritable) stats.get("T");        stats.remove("T");        results.put("totalUrls", String.valueOf(totalCnt.get()));        Map<String, Object> statusMap = new HashMap<>();        for (Map.Entry<String, Writable> entry : stats.entrySet()) {            String k = entry.getKey();            long val = 0L;            double fval = 0.0;            if (entry.getValue() instanceof LongWritable) {                val = ((LongWritable) entry.getValue()).get();            } else if (entry.getValue() instanceof FloatWritable) {                fval = ((FloatWritable) entry.getValue()).get();            } else if (entry.getValue() instanceof BytesWritable) {                continue;            }            if (k.equals("scn")) {                results.put("minScore", String.valueOf(fval));            } else if (k.equals("scx")) {                results.put("maxScore", String.valueOf(fval));            } else if (k.equals("sct")) {                results.put("avgScore", String.valueOf((fval / totalCnt.get())));            } else if (k.startsWith("status")) {                String[] st = k.split(" ");                int code = Integer.parseInt(st[1]);                if (st.length > 2) {                    @SuppressWarnings("unchecked")                    Map<String, Object> individualStatusInfo = (Map<String, Object>) statusMap.get(String.valueOf(code));                    Map<String, String> hostValues;                    if (individualStatusInfo.containsKey("hostValues")) {                        hostValues = (Map<String, String>) individualStatusInfo.get("hostValues");                    } else {                        hostValues = new HashMap<>();                        individualStatusInfo.put("hostValues", hostValues);                    }                    hostValues.put(st[2], String.valueOf(val));                } else {                    Map<String, Object> individualStatusInfo = new HashMap<>();                    individualStatusInfo.put("statusValue", CrawlDatum.getStatusName((byte) code));                    individualStatusInfo.put("count", String.valueOf(val));                    statusMap.put(String.valueOf(code), individualStatusInfo);                }            } else {                results.put(k, String.valueOf(val));            }        }        results.put("status", statusMap);        return results;    }    if (type.equalsIgnoreCase("dump")) {        String output = args.get("out_dir");        String format = "normal";        String regex = null;        Integer retry = null;        String status = null;        String expr = null;        Float sample = null;        if (args.containsKey("format")) {            format = args.get("format");        }        if (args.containsKey("regex")) {            regex = args.get("regex");        }        if (args.containsKey("retry")) {            retry = Integer.parseInt(args.get("retry"));        }        if (args.containsKey("status")) {            status = args.get("status");        }        if (args.containsKey("expr")) {            expr = args.get("expr");        }        if (args.containsKey("sample")) {            sample = Float.parseFloat(args.get("sample"));        }        processDumpJob(crawlDb, output, conf, format, regex, status, retry, expr, sample);        File dumpFile = new File(output + "/part-00000");        return dumpFile;    }    if (type.equalsIgnoreCase("topN")) {        String output = args.get("out_dir");        long topN = Long.parseLong(args.get("nnn"));        float min = 0.0f;        if (args.containsKey("min")) {            min = Float.parseFloat(args.get("min"));        }        processTopNJob(crawlDb, topN, min, output, conf);        File dumpFile = new File(output + "/part-00000");        return dumpFile;    }    if (type.equalsIgnoreCase("url")) {        String url = args.get("url");        CrawlDatum res = get(crawlDb, url, conf);        results.put("status", res.getStatus());        results.put("fetchTime", new Date(res.getFetchTime()));        results.put("modifiedTime", new Date(res.getModifiedTime()));        results.put("retriesSinceFetch", res.getRetriesSinceFetch());        results.put("retryInterval", res.getFetchInterval());        results.put("score", res.getScore());        results.put("signature", StringUtil.toHexString(res.getSignature()));        Map<String, String> metadata = new HashMap<>();        if (res.getMetaData() != null) {            for (Entry<Writable, Writable> e : res.getMetaData().entrySet()) {                metadata.put(String.valueOf(e.getKey()), String.valueOf(e.getValue()));            }        }        results.put("metadata", metadata);        return results;    }    return results;}
cc92acbea55a169b09e99adca01aa87ef99b44125994f5318867984c7790a849
setup
public void setup(Reducer<Text, CrawlDatum, Text, CrawlDatum>.Context context)
{    Configuration conf = context.getConfiguration();    retryMax = conf.getInt("db.fetch.retry.max", 3);    scfilters = new ScoringFilters(conf);    additionsAllowed = conf.getBoolean(CrawlDb.CRAWLDB_ADDITIONS_ALLOWED, true);    maxInterval = conf.getInt("db.fetch.interval.max", 0);    schedule = FetchScheduleFactory.getFetchSchedule(conf);    int maxLinks = conf.getInt("db.update.max.inlinks", 10000);    linked = new InlinkPriorityQueue(maxLinks);}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{}
dfa33bb74c8851fea1ca7d1879839d7b539c5564809dc8824a9b4ec385276528
reduce
public void reduce(Text key, Iterable<CrawlDatum> values, Context context) throws IOException, InterruptedException
{    CrawlDatum fetch = new CrawlDatum();    CrawlDatum old = new CrawlDatum();    boolean fetchSet = false;    boolean oldSet = false;    byte[] signature = null;        boolean multiple = false;    linked.clear();    org.apache.hadoop.io.MapWritable metaFromParse = null;    for (CrawlDatum datum : values) {        if (!multiple)            multiple = true;        if (CrawlDatum.hasDbStatus(datum)) {            if (!oldSet) {                if (multiple) {                    old.set(datum);                } else {                                        old = datum;                }                oldSet = true;            } else {                                if (old.getFetchTime() < datum.getFetchTime())                    old.set(datum);            }            continue;        }        if (CrawlDatum.hasFetchStatus(datum)) {            if (!fetchSet) {                if (multiple) {                    fetch.set(datum);                } else {                    fetch = datum;                }                fetchSet = true;            } else {                                if (fetch.getFetchTime() < datum.getFetchTime())                    fetch.set(datum);            }            continue;        }        switch(        datum.getStatus()) {            case CrawlDatum.STATUS_LINKED:                CrawlDatum link;                if (multiple) {                    link = new CrawlDatum();                    link.set(datum);                } else {                    link = datum;                }                linked.insert(link);                break;            case CrawlDatum.STATUS_SIGNATURE:                signature = datum.getSignature();                break;            case CrawlDatum.STATUS_PARSE_META:                metaFromParse = datum.getMetaData();                break;            default:                LOG.warn("Unknown status, key: " + key + ", datum: " + datum);        }    }            int numLinks = linked.size();    List<CrawlDatum> linkList = new ArrayList<>(numLinks);    for (int i = numLinks - 1; i >= 0; i--) {        linkList.add(linked.pop());    }        if (!oldSet && !additionsAllowed)        return;        if (!fetchSet && linkList.size() > 0) {        fetch = linkList.get(0);        fetchSet = true;    }        if (!fetchSet) {        if (oldSet) {                        try {                scfilters.orphanedScore(key, old);            } catch (ScoringFilterException e) {                if (LOG.isWarnEnabled()) {                    LOG.warn("Couldn't update orphaned score, key={}: {}", key, e);                }            }            context.write(key, old);            context.getCounter("CrawlDB status", CrawlDatum.getStatusName(old.getStatus())).increment(1);        } else {            LOG.warn("Missing fetch and old value, signature=" + StringUtil.toHexString(signature));        }        return;    }    if (signature == null)        signature = fetch.getSignature();    long prevModifiedTime = oldSet ? old.getModifiedTime() : 0L;    long prevFetchTime = oldSet ? old.getFetchTime() : 0L;        result.set(fetch);    if (oldSet) {                if (old.getMetaData().size() > 0) {            result.putAllMetaData(old);                        if (fetch.getMetaData().size() > 0)                result.putAllMetaData(fetch);        }                if (old.getModifiedTime() > 0 && fetch.getModifiedTime() == 0) {            result.setModifiedTime(old.getModifiedTime());        }    }    switch(    fetch.getStatus()) {        case         CrawlDatum.STATUS_LINKED:            if (oldSet) {                                                result.set(old);            } else {                result = schedule.initializeSchedule(key, result);                result.setStatus(CrawlDatum.STATUS_DB_UNFETCHED);                try {                    scfilters.initialScore(key, result);                } catch (ScoringFilterException e) {                    if (LOG.isWarnEnabled()) {                        LOG.warn("Cannot filter init score for url " + key + ", using default: " + e.getMessage());                    }                    result.setScore(0.0f);                }            }            break;                case CrawlDatum.STATUS_FETCH_SUCCESS:                case CrawlDatum.STATUS_FETCH_REDIR_TEMP:        case CrawlDatum.STATUS_FETCH_REDIR_PERM:        case         CrawlDatum.STATUS_FETCH_NOTMODIFIED:                        if (metaFromParse != null) {                for (Entry<Writable, Writable> e : metaFromParse.entrySet()) {                    result.getMetaData().put(e.getKey(), e.getValue());                }            }                        int modified = FetchSchedule.STATUS_UNKNOWN;            if (fetch.getStatus() == CrawlDatum.STATUS_FETCH_NOTMODIFIED) {                modified = FetchSchedule.STATUS_NOTMODIFIED;            } else if (fetch.getStatus() == CrawlDatum.STATUS_FETCH_SUCCESS) {                                if (oldSet && old.getSignature() != null && signature != null) {                    if (SignatureComparator._compare(old.getSignature(), signature) != 0) {                        modified = FetchSchedule.STATUS_MODIFIED;                    } else {                        modified = FetchSchedule.STATUS_NOTMODIFIED;                    }                }            }                        result = schedule.setFetchSchedule(key, result, prevFetchTime, prevModifiedTime, fetch.getFetchTime(), fetch.getModifiedTime(), modified);                        if (modified == FetchSchedule.STATUS_NOTMODIFIED) {                result.setStatus(CrawlDatum.STATUS_DB_NOTMODIFIED);                                                result.setModifiedTime(prevModifiedTime);                if (oldSet)                    result.setSignature(old.getSignature());            } else {                switch(fetch.getStatus()) {                    case CrawlDatum.STATUS_FETCH_SUCCESS:                        result.setStatus(CrawlDatum.STATUS_DB_FETCHED);                        break;                    case CrawlDatum.STATUS_FETCH_REDIR_PERM:                        result.setStatus(CrawlDatum.STATUS_DB_REDIR_PERM);                        break;                    case CrawlDatum.STATUS_FETCH_REDIR_TEMP:                        result.setStatus(CrawlDatum.STATUS_DB_REDIR_TEMP);                        break;                    default:                        LOG.warn("Unexpected status: " + fetch.getStatus() + " resetting to old status.");                        if (oldSet)                            result.setStatus(old.getStatus());                        else                            result.setStatus(CrawlDatum.STATUS_DB_UNFETCHED);                }                result.setSignature(signature);            }                        if (maxInterval < result.getFetchInterval())                result = schedule.forceRefetch(key, result, false);            break;        case CrawlDatum.STATUS_SIGNATURE:            if (LOG.isWarnEnabled()) {                LOG.warn("Lone CrawlDatum.STATUS_SIGNATURE: " + key);            }            return;        case         CrawlDatum.STATUS_FETCH_RETRY:            if (oldSet) {                                result.setSignature(old.getSignature());            }            result = schedule.setPageRetrySchedule(key, result, prevFetchTime, prevModifiedTime, fetch.getFetchTime());            if (result.getRetriesSinceFetch() < retryMax) {                result.setStatus(CrawlDatum.STATUS_DB_UNFETCHED);            } else {                result.setStatus(CrawlDatum.STATUS_DB_GONE);                result = schedule.setPageGoneSchedule(key, result, prevFetchTime, prevModifiedTime, fetch.getFetchTime());            }            break;        case         CrawlDatum.STATUS_FETCH_GONE:            if (oldSet)                                result.setSignature(old.getSignature());            result.setStatus(CrawlDatum.STATUS_DB_GONE);            result = schedule.setPageGoneSchedule(key, result, prevFetchTime, prevModifiedTime, fetch.getFetchTime());            break;        default:            throw new RuntimeException("Unknown status: " + fetch.getStatus() + " " + key);    }    try {        scfilters.updateDbScore(key, oldSet ? old : null, result, linkList);    } catch (Exception e) {        if (LOG.isWarnEnabled()) {            LOG.warn("Couldn't update score, key={}: {}", key, e);        }    }        result.getMetaData().remove(Nutch.WRITABLE_GENERATE_TIME_KEY);    context.write(key, result);    context.getCounter("CrawlDB status", CrawlDatum.getStatusName(result.getStatus())).increment(1);}
ba684f2150f0d42f7db8223691686c2aca1865d2ca93738c6faf69bb5c19015e
lessThan
protected boolean lessThan(Object arg0, Object arg1)
{    CrawlDatum candidate = (CrawlDatum) arg0;    CrawlDatum least = (CrawlDatum) arg1;    return candidate.getScore() > least.getScore();}
77c36ca48500855acc66649995f6ab5bae26791d1e61992becc7e33217d31066
setup
public void setup(Mapper<Text, CrawlDatum, BytesWritable, CrawlDatum>.Context context)
{    Configuration arg0 = context.getConfiguration();    groupMode = arg0.get(DEDUPLICATION_GROUP_MODE);}
c7247fbb9a78b0f2bf1b83c7a1cc1acc3831c597de4ebbf8907dd8852659368e
map
public void map(Text key, CrawlDatum value, Context context) throws IOException, InterruptedException
{    if (value.getStatus() == CrawlDatum.STATUS_DB_FETCHED || value.getStatus() == CrawlDatum.STATUS_DB_NOTMODIFIED) {                byte[] signature = value.getSignature();        if (signature == null)            return;        String url = key.toString();        BytesWritable sig = null;        byte[] data;        switch(groupMode) {            case "none":                sig = new BytesWritable(signature);                break;            case "host":                byte[] host = URLUtil.getHost(url).getBytes();                data = new byte[signature.length + host.length];                System.arraycopy(signature, 0, data, 0, signature.length);                System.arraycopy(host, 0, data, signature.length, host.length);                sig = new BytesWritable(data);                break;            case "domain":                byte[] domain = URLUtil.getDomainName(url).getBytes();                data = new byte[signature.length + domain.length];                System.arraycopy(signature, 0, data, 0, signature.length);                System.arraycopy(domain, 0, data, signature.length, domain.length);                sig = new BytesWritable(data);                break;        }                value.getMetaData().put(urlKey, key);                context.write(sig, value);    }}
91e055f958e194614868b828c4af5de96fa8c4ee84fff48a8599320c7f9de6e7
setup
public void setup(Reducer<BytesWritable, CrawlDatum, Text, CrawlDatum>.Context context)
{    Configuration conf = context.getConfiguration();    compareOrder = conf.get(DEDUPLICATION_COMPARE_ORDER).split(",");}
a5cd1c020db88a027ab12d51b15f2362161a4badff1b535e238ef0a3e6d42007
writeOutAsDuplicate
private void writeOutAsDuplicate(CrawlDatum datum, Context context) throws IOException, InterruptedException
{    datum.setStatus(CrawlDatum.STATUS_DB_DUPLICATE);    Text key = (Text) datum.getMetaData().remove(urlKey);    context.getCounter("DeduplicationJobStatus", "Documents marked as duplicate").increment(1);    context.write(key, datum);}
30bbcf922d1d7e29a16e7805a7622852c7319f9969dae906f1906ca37f7da9e6
reduce
public void reduce(BytesWritable key, Iterable<CrawlDatum> values, Context context) throws IOException, InterruptedException
{    CrawlDatum existingDoc = null;    for (CrawlDatum newDoc : values) {        if (existingDoc == null) {            existingDoc = new CrawlDatum();            existingDoc.set(newDoc);            continue;        }        CrawlDatum duplicate = getDuplicate(existingDoc, newDoc);        if (duplicate != null) {            writeOutAsDuplicate(duplicate, context);            if (duplicate == existingDoc) {                                existingDoc.set(newDoc);            }        }    }}
71d21e48ad614dfabd7b3d030dffae56ff066d5b993196c67d561e93eb33303f
getDuplicate
private CrawlDatum getDuplicate(CrawlDatum existingDoc, CrawlDatum newDoc) throws IOException
{    for (int i = 0; i < compareOrder.length; i++) {        switch(compareOrder[i]) {            case "score":                                if (existingDoc.getScore() < newDoc.getScore()) {                    return existingDoc;                } else if (existingDoc.getScore() > newDoc.getScore()) {                                        return newDoc;                }                break;            case "fetchTime":                                if (existingDoc.getFetchTime() > newDoc.getFetchTime()) {                                        return newDoc;                } else if (existingDoc.getFetchTime() < newDoc.getFetchTime()) {                                        return existingDoc;                }                break;            case "httpsOverHttp":                                                String url1 = existingDoc.getMetaData().get(urlKey).toString();                String url2 = newDoc.getMetaData().get(urlKey).toString();                if (url1.startsWith("https://") && url2.startsWith("http://") && url1.substring(8).equals(url2.substring(7))) {                                        return newDoc;                } else if (url2.startsWith("https://") && url1.startsWith("http://") && url2.substring(8).equals(url1.substring(7))) {                                        return existingDoc;                }                break;            case "urlLength":                                String urlExisting;                String urlnewDoc;                try {                    urlExisting = URLDecoder.decode(existingDoc.getMetaData().get(urlKey).toString(), "UTF8");                    urlnewDoc = URLDecoder.decode(newDoc.getMetaData().get(urlKey).toString(), "UTF8");                } catch (UnsupportedEncodingException e) {                    LOG.error("Error decoding: " + urlKey);                    throw new IOException("UnsupportedEncodingException for " + urlKey);                }                if (urlExisting.length() < urlnewDoc.length()) {                                        return newDoc;                } else if (urlExisting.length() > urlnewDoc.length()) {                                        return existingDoc;                }                break;        }    }        return null;}
cc92acbea55a169b09e99adca01aa87ef99b44125994f5318867984c7790a849
setup
public void setup(Reducer<Text, CrawlDatum, Text, CrawlDatum>.Context context)
{}
dfa33bb74c8851fea1ca7d1879839d7b539c5564809dc8824a9b4ec385276528
reduce
public void reduce(Text key, Iterable<CrawlDatum> values, Context context) throws IOException, InterruptedException
{    boolean duplicateSet = false;    for (CrawlDatum val : values) {        if (val.getStatus() == CrawlDatum.STATUS_DB_DUPLICATE) {            duplicate.set(val);            duplicateSet = true;        } else {            old.set(val);        }    }        if (duplicateSet) {        context.write(key, duplicate);        return;    }        context.write(key, old);}
d756081f6122b82915ed5d6542d8c0a46cde13d93e4e426add1fcd67fd99590a
run
public int run(String[] args) throws IOException
{    if (args.length < 1) {        System.err.println("Usage: DeduplicationJob <crawldb> [-group <none|host|domain>] [-compareOrder <score>,<fetchTime>,<httpsOverHttp>,<urlLength>]");        return 1;    }    String group = "none";    Path crawlDb = new Path(args[0]);    String compareOrder = "score,fetchTime,urlLength";    for (int i = 1; i < args.length; i++) {        if (args[i].equals("-group"))            group = args[++i];        if (args[i].equals("-compareOrder")) {            compareOrder = args[++i];            if (compareOrder.indexOf("score") == -1 || compareOrder.indexOf("fetchTime") == -1 || compareOrder.indexOf("urlLength") == -1) {                System.err.println("DeduplicationJob: compareOrder must contain score, fetchTime and urlLength.");                return 1;            }        }    }    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    long start = System.currentTimeMillis();    LOG.info("DeduplicationJob: starting at " + sdf.format(start));    Path tempDir = new Path(crawlDb, "dedup-temp-" + Integer.toString(new Random().nextInt(Integer.MAX_VALUE)));    Job job = NutchJob.getInstance(getConf());    Configuration conf = job.getConfiguration();    job.setJobName("Deduplication on " + crawlDb);    conf.set(DEDUPLICATION_GROUP_MODE, group);    conf.set(DEDUPLICATION_COMPARE_ORDER, compareOrder);    job.setJarByClass(DeduplicationJob.class);    FileInputFormat.addInputPath(job, new Path(crawlDb, CrawlDb.CURRENT_NAME));    job.setInputFormatClass(SequenceFileInputFormat.class);    FileOutputFormat.setOutputPath(job, tempDir);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    job.setMapOutputKeyClass(BytesWritable.class);    job.setMapOutputValueClass(CrawlDatum.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(CrawlDatum.class);    job.setMapperClass(DBFilter.class);    job.setReducerClass(DedupReducer.class);    FileSystem fs = tempDir.getFileSystem(getConf());    try {        boolean success = job.waitForCompletion(true);        if (!success) {            String message = "Crawl job did not succeed, job status:" + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);            fs.delete(tempDir, true);            throw new RuntimeException(message);        }        CounterGroup g = job.getCounters().getGroup("DeduplicationJobStatus");        if (g != null) {            Counter counter = g.findCounter("Documents marked as duplicate");            long dups = counter.getValue();            LOG.info("Deduplication: " + (int) dups + " documents marked as duplicates");        }    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error("DeduplicationJob: " + StringUtils.stringifyException(e));        fs.delete(tempDir, true);        return -1;    }        if (LOG.isInfoEnabled()) {        LOG.info("Deduplication: Updating status of duplicate urls into crawl db.");    }    Job mergeJob = CrawlDb.createJob(getConf(), crawlDb);    FileInputFormat.addInputPath(mergeJob, tempDir);    mergeJob.setReducerClass(StatusUpdateReducer.class);    mergeJob.setJarByClass(DeduplicationJob.class);    fs = crawlDb.getFileSystem(getConf());    Path outPath = FileOutputFormat.getOutputPath(job);    Path lock = CrawlDb.lock(getConf(), crawlDb, false);    try {        boolean success = mergeJob.waitForCompletion(true);        if (!success) {            String message = "Crawl job did not succeed, job status:" + mergeJob.getStatus().getState() + ", reason: " + mergeJob.getStatus().getFailureInfo();            LOG.error(message);            fs.delete(tempDir, true);            NutchJob.cleanupAfterFailure(outPath, lock, fs);            throw new RuntimeException(message);        }    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error("DeduplicationMergeJob: " + StringUtils.stringifyException(e));        fs.delete(tempDir, true);        NutchJob.cleanupAfterFailure(outPath, lock, fs);        return -1;    }    CrawlDb.install(mergeJob, crawlDb);        fs.delete(tempDir, true);    long end = System.currentTimeMillis();    LOG.info("Deduplication finished at " + sdf.format(end) + ", elapsed: " + TimingUtil.elapsedTime(start, end));    return 0;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int result = ToolRunner.run(NutchConfiguration.create(), new DeduplicationJob(), args);    System.exit(result);}
084523121ab64bd9486b37875e438171d2b2467ace02bce8523551b0ce84ace4
run
public Map<String, Object> run(Map<String, Object> args, String crawlId) throws Exception
{    Map<String, Object> results = new HashMap<>();    String[] arg = new String[1];    String crawldb;    if (args.containsKey(Nutch.ARG_CRAWLDB)) {        crawldb = (String) args.get(Nutch.ARG_CRAWLDB);    } else {        crawldb = crawlId + "/crawldb";    }    arg[0] = crawldb;    int res = run(arg);    results.put(Nutch.VAL_RESULT, Integer.toString(res));    return results;}
319c7fad8a457ebb19672206c3ea49d47adb1e2fe5c1e1d279c4ce14d3c5cdec
setFetchSchedule
public CrawlDatum setFetchSchedule(Text url, CrawlDatum datum, long prevFetchTime, long prevModifiedTime, long fetchTime, long modifiedTime, int state)
{    datum = super.setFetchSchedule(url, datum, prevFetchTime, prevModifiedTime, fetchTime, modifiedTime, state);    if (datum.getFetchInterval() == 0) {        datum.setFetchInterval(defaultInterval);    }    datum.setFetchTime(fetchTime + (long) datum.getFetchInterval() * 1000);    if (modifiedTime <= 0 || state == FetchSchedule.STATUS_MODIFIED) {                modifiedTime = fetchTime;    }    datum.setModifiedTime(modifiedTime);    return datum;}
ac777a63f2c766c42d7487a7399f5e21c7bf133acccbd3c48e22ddbc9fb911c0
getFetchSchedule
public static synchronized FetchSchedule getFetchSchedule(Configuration conf)
{    String clazz = conf.get("db.fetch.schedule.class", DefaultFetchSchedule.class.getName());    ObjectCache objectCache = ObjectCache.get(conf);    FetchSchedule impl = (FetchSchedule) objectCache.getObject(clazz);    if (impl == null) {        try {            LOG.info("Using FetchSchedule impl: " + clazz);            Class<?> implClass = Class.forName(clazz);            impl = (FetchSchedule) implClass.getConstructor().newInstance();            impl.setConf(conf);            objectCache.setObject(clazz, impl);        } catch (Exception e) {            throw new RuntimeException("Couldn't create " + clazz, e);        }    }    return impl;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    url.readFields(in);    datum.readFields(in);    segnum.readFields(in);}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    url.write(out);    datum.write(out);    segnum.write(out);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "url=" + url.toString() + ", datum=" + datum.toString() + ", segnum=" + segnum.toString();}
1aef02eed81e402345bc9ab1c2538816be49e879d939f12df95b41f3e325d974
getPartition
public int getPartition(FloatWritable key, Writable value, int numReduceTasks)
{    return partitioner.getPartition(((SelectorEntry) value).url, key, numReduceTasks);}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return partitioner.getConf();}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    partitioner.setConf(conf);}
3b517e3eb82210e49d58b874d94dfeffac97a5e88abe451ff043a2ce16db4927
setup
public void setup(Mapper<Text, CrawlDatum, FloatWritable, SelectorEntry>.Context context) throws IOException
{    conf = context.getConfiguration();    curTime = conf.getLong(GENERATOR_CUR_TIME, System.currentTimeMillis());    filters = new URLFilters(conf);    scfilters = new ScoringFilters(conf);    filter = conf.getBoolean(GENERATOR_FILTER, true);    /* CrawlDb items are unblocked after 7 days as default */    genDelay = conf.getLong(GENERATOR_DELAY, 604800000L);    long time = conf.getLong(Nutch.GENERATE_TIME_KEY, 0L);    if (time > 0)        genTime.set(time);    schedule = FetchScheduleFactory.getFetchSchedule(conf);    scoreThreshold = conf.getFloat(GENERATOR_MIN_SCORE, Float.NaN);    intervalThreshold = conf.getInt(GENERATOR_MIN_INTERVAL, -1);    String restrictStatusString = conf.getTrimmed(GENERATOR_RESTRICT_STATUS, "");    if (!restrictStatusString.isEmpty()) {        restrictStatus = CrawlDatum.getStatusByName(restrictStatusString);    }    expr = JexlUtil.parseExpression(conf.get(GENERATOR_EXPR, null));}
c7247fbb9a78b0f2bf1b83c7a1cc1acc3831c597de4ebbf8907dd8852659368e
map
public void map(Text key, CrawlDatum value, Context context) throws IOException, InterruptedException
{    Text url = key;    if (filter) {                try {            if (filters.filter(url.toString()) == null)                return;        } catch (URLFilterException e) {            LOG.warn("Couldn't filter url: {} ({})", url, e.getMessage());        }    }    CrawlDatum crawlDatum = value;        if (!schedule.shouldFetch(url, crawlDatum, curTime)) {        LOG.debug("-shouldFetch rejected '{}', fetchTime={}, curTime={}", url, crawlDatum.getFetchTime(), curTime);        context.getCounter("Generator", "SCHEDULE_REJECTED").increment(1);        return;    }    LongWritable oldGenTime = (LongWritable) crawlDatum.getMetaData().get(Nutch.WRITABLE_GENERATE_TIME_KEY);    if (oldGenTime != null) {                if (        oldGenTime.get() + genDelay > curTime)                        context.getCounter("Generator", "WAIT_FOR_UPDATE").increment(1);        return;    }    float sort = 1.0f;    try {        sort = scfilters.generatorSortValue(key, crawlDatum, sort);    } catch (ScoringFilterException sfe) {        if (LOG.isWarnEnabled()) {            LOG.warn("Couldn't filter generatorSortValue for " + key + ": " + sfe);        }    }        if (expr != null) {        if (!crawlDatum.evaluate(expr, key.toString())) {            context.getCounter("Generator", "EXPR_REJECTED").increment(1);            return;        }    }    if (restrictStatus != -1 && restrictStatus != crawlDatum.getStatus()) {        context.getCounter("Generator", "STATUS_REJECTED").increment(1);        return;    }        if (!Float.isNaN(scoreThreshold) && sort < scoreThreshold) {        context.getCounter("Generator", "SCORE_TOO_LOW").increment(1);        return;    }        if (intervalThreshold != -1 && crawlDatum.getFetchInterval() > intervalThreshold) {        context.getCounter("Generator", "INTERVAL_REJECTED").increment(1);        return;    }        sortValue.set(sort);        crawlDatum.getMetaData().put(Nutch.WRITABLE_GENERATE_TIME_KEY, genTime);    entry.datum = crawlDatum;    entry.url = key;        context.write(sortValue, entry);}
20fa09f58ec45a3964c698b8ae376ba3a79fb28d33c088c2a56b5d9e9be1edee
open
public void open()
{    if (conf.get(GENERATOR_HOSTDB) != null) {        try {            Path path = new Path(conf.get(GENERATOR_HOSTDB), "current");            hostdbReaders = SegmentReaderUtil.getReaders(path, conf);        } catch (IOException e) {            LOG.error("Error reading HostDB because {}", e.getMessage());        }    }}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    if (hostdbReaders != null) {        try {            for (int i = 0; i < hostdbReaders.length; i++) {                hostdbReaders[i].close();            }        } catch (IOException e) {            LOG.error("Error closing HostDB because {}", e.getMessage());        }    }}
2d3280abbd160c58de92d6f301c04d1f04a84cc03248eca5c97a150dc150fb23
createContext
private JexlContext createContext(HostDatum datum)
{    JexlContext context = new MapContext();    context.set("dnsFailures", datum.getDnsFailures());    context.set("connectionFailures", datum.getConnectionFailures());    context.set("unfetched", datum.getUnfetched());    context.set("fetched", datum.getFetched());    context.set("notModified", datum.getNotModified());    context.set("redirTemp", datum.getRedirTemp());    context.set("redirPerm", datum.getRedirPerm());    context.set("gone", datum.getGone());    context.set("conf", conf);        for (Map.Entry<Writable, Writable> entry : datum.getMetaData().entrySet()) {        Object value = entry.getValue();        if (value instanceof FloatWritable) {            FloatWritable fvalue = (FloatWritable) value;            Text tkey = (Text) entry.getKey();            context.set(tkey.toString(), fvalue.get());        }        if (value instanceof IntWritable) {            IntWritable ivalue = (IntWritable) value;            Text tkey = (Text) entry.getKey();            context.set(tkey.toString(), ivalue.get());        }        if (value instanceof Text) {            Text tvalue = (Text) value;            Text tkey = (Text) entry.getKey();            context.set(tkey.toString().replace("-", "_"), tvalue.toString());        }    }    return context;}
7ac440e0f2bb4f2fed53e09f23bdeaeaff1a192ec96fcaa7c398a032d211bc40
setup
public void setup(Context context) throws IOException
{    conf = context.getConfiguration();    mos = new MultipleOutputs<FloatWritable, SelectorEntry>(context);    Job job = Job.getInstance(conf);    limit = conf.getLong(GENERATOR_TOP_N, Long.MAX_VALUE) / job.getNumReduceTasks();    maxNumSegments = conf.getInt(GENERATOR_MAX_NUM_SEGMENTS, 1);    segCounts = new int[maxNumSegments];    maxCount = conf.getInt(GENERATOR_MAX_COUNT, -1);    if (maxCount == -1) {        byDomain = false;    }    if (GENERATOR_COUNT_VALUE_DOMAIN.equals(conf.get(GENERATOR_COUNT_MODE)))        byDomain = true;    normalise = conf.getBoolean(GENERATOR_NORMALISE, true);    if (normalise)        normalizers = new URLNormalizers(conf, URLNormalizers.SCOPE_GENERATE_HOST_COUNT);    if (conf.get(GENERATOR_HOSTDB) != null) {        maxCountExpr = JexlUtil.parseExpression(conf.get(GENERATOR_MAX_COUNT_EXPR, null));        fetchDelayExpr = JexlUtil.parseExpression(conf.get(GENERATOR_FETCH_DELAY_EXPR, null));    }}
6a4f097a82d3a7057457740360a7d6c25ecd2ea478f6041870cf525d53e980d0
cleanup
public void cleanup(Context context) throws IOException, InterruptedException
{    mos.close();}
4537578ad29ab46c285d621cae7f7d8913f2a861340e3aaa6debf41df2e44d1a
reduce
public void reduce(FloatWritable key, Iterable<SelectorEntry> values, Context context) throws IOException, InterruptedException
{    String hostname = null;    HostDatum host = null;        LongWritable variableFetchDelayWritable = null;    Text variableFetchDelayKey = new Text("_variableFetchDelay_");        int maxCount = this.maxCount;    for (SelectorEntry entry : values) {        Text url = entry.url;        String urlString = url.toString();        URL u = null;                if (host == null) {            try {                hostname = URLUtil.getHost(urlString);                host = getHostDatum(hostname);            } catch (Exception e) {            }                        if (host == null) {                                host = new HostDatum();            } else {                if (maxCountExpr != null) {                    long variableMaxCount = Math.round((double) maxCountExpr.evaluate(createContext(host)));                    LOG.info("Generator: variable maxCount: {} for {}", variableMaxCount, hostname);                    maxCount = (int) variableMaxCount;                }                if (fetchDelayExpr != null) {                    long variableFetchDelay = Math.round((double) fetchDelayExpr.evaluate(createContext(host)));                    LOG.info("Generator: variable fetchDelay: {} ms for {}", variableFetchDelay, hostname);                    variableFetchDelayWritable = new LongWritable(variableFetchDelay);                }            }        }                if (variableFetchDelayWritable != null) {            entry.datum.getMetaData().put(variableFetchDelayKey, variableFetchDelayWritable);        }        if (count == limit) {                        if (currentsegmentnum < maxNumSegments) {                count = 0;                currentsegmentnum++;            } else                break;        }        String hostordomain = null;        try {            if (normalise && normalizers != null) {                urlString = normalizers.normalize(urlString, URLNormalizers.SCOPE_GENERATE_HOST_COUNT);            }            u = new URL(urlString);            if (byDomain) {                hostordomain = URLUtil.getDomainName(u);            } else {                hostordomain = u.getHost();            }        } catch (MalformedURLException e) {            LOG.warn("Malformed URL: '{}', skipping ({})", urlString, StringUtils.stringifyException(e));            context.getCounter("Generator", "MALFORMED_URL").increment(1);            continue;        }        hostordomain = hostordomain.toLowerCase();                if (maxCount > 0) {            int[] hostCount = hostCounts.get(hostordomain);            if (hostCount == null) {                hostCount = new int[] { 1, 0 };                hostCounts.put(hostordomain, hostCount);            }                        hostCount[1]++;                        while (segCounts[hostCount[0] - 1] >= limit && hostCount[0] < maxNumSegments) {                hostCount[0]++;                hostCount[1] = 0;            }                        if (hostCount[1] > maxCount) {                if (hostCount[0] < maxNumSegments) {                    hostCount[0]++;                    hostCount[1] = 1;                } else {                    if (hostCount[1] == (maxCount + 1)) {                        context.getCounter("Generator", "HOSTS_AFFECTED_PER_HOST_OVERFLOW").increment(1);                        LOG.info("Host or domain {} has more than {} URLs for all {} segments. Additional URLs won't be included in the fetchlist.", hostordomain, maxCount, maxNumSegments);                    }                                        context.getCounter("Generator", "URLS_SKIPPED_PER_HOST_OVERFLOW").increment(1);                    continue;                }            }            entry.segnum = new IntWritable(hostCount[0]);            segCounts[hostCount[0] - 1]++;        } else {            entry.segnum = new IntWritable(currentsegmentnum);            segCounts[currentsegmentnum - 1]++;        }        outputFile = generateFileName(entry);        mos.write("sequenceFiles", key, entry, outputFile);                        count++;    }}
75226422b975e318713a5f2213deb46e5f4e29f329ca1ccde9995fa6f2c2b102
generateFileName
private String generateFileName(SelectorEntry entry)
{    return "fetchlist-" + entry.segnum.toString() + "/part";}
7f894fc6a7c4ef35d66b3df6ec0928b72753e69f5a9ef3af8372c2fae953bbd3
getHostDatum
private HostDatum getHostDatum(String host) throws Exception
{    Text key = new Text();    HostDatum value = new HostDatum();    open();    for (int i = 0; i < hostdbReaders.length; i++) {        while (hostdbReaders[i].next(key, value)) {            if (host.equals(key.toString())) {                close();                return value;            }        }    }    close();    return null;}
8cd74526bc7e7f20597a504e1ed768d1c3a048c7a382f95e889101f52fd94ec3
compare
public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2)
{    return super.compare(b2, s2, l2, b1, s1, l1);}
36523ce72739122615f9543cb717246b3034509784d9de874b325babcb868d68
map
public void map(FloatWritable key, SelectorEntry value, Context context) throws IOException, InterruptedException
{    SelectorEntry entry = value;    context.write(entry.url, entry);}
80aaa7644ae8c758500e32d38b8950f2e0613afe46c7d1c7bad8adbe9e5b72f5
reduce
public void reduce(Text key, Iterable<SelectorEntry> values, Context context) throws IOException, InterruptedException
{        for (SelectorEntry entry : values) {        context.write(entry.url, entry.datum);    }}
1487ad502ab31c307d33fb896d3e5baa03b686bf54cf28348227f1e662c6bbfc
compare
public int compare(WritableComparable a, WritableComparable b)
{    Text url1 = (Text) a;    Text url2 = (Text) b;    int hash1 = hash(url1.getBytes(), 0, url1.getLength());    int hash2 = hash(url2.getBytes(), 0, url2.getLength());    return (hash1 < hash2 ? -1 : (hash1 == hash2 ? 0 : 1));}
8cd74526bc7e7f20597a504e1ed768d1c3a048c7a382f95e889101f52fd94ec3
compare
public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2)
{    int hash1 = hash(b1, s1, l1);    int hash2 = hash(b2, s2, l2);    return (hash1 < hash2 ? -1 : (hash1 == hash2 ? 0 : 1));}
e6f4aadd4f57897dc26d60ad7bc03681cfe5f2155c48e90345b9db557491e28d
hash
private static int hash(byte[] bytes, int start, int length)
{    int hash = 1;        for (int i = length - 1; i >= 0; i--) hash = (31 * hash) + (int) bytes[start + i];    return hash;}
c7247fbb9a78b0f2bf1b83c7a1cc1acc3831c597de4ebbf8907dd8852659368e
map
public void map(Text key, CrawlDatum value, Context context) throws IOException, InterruptedException
{    context.write(key, value);}
cc92acbea55a169b09e99adca01aa87ef99b44125994f5318867984c7790a849
setup
public void setup(Reducer<Text, CrawlDatum, Text, CrawlDatum>.Context context)
{    Configuration conf = context.getConfiguration();    generateTime = conf.getLong(Nutch.GENERATE_TIME_KEY, 0L);}
dfa33bb74c8851fea1ca7d1879839d7b539c5564809dc8824a9b4ec385276528
reduce
public void reduce(Text key, Iterable<CrawlDatum> values, Context context) throws IOException, InterruptedException
{    genTime.set(0L);    for (CrawlDatum val : values) {        if (val.getMetaData().containsKey(Nutch.WRITABLE_GENERATE_TIME_KEY)) {            LongWritable gt = (LongWritable) val.getMetaData().get(Nutch.WRITABLE_GENERATE_TIME_KEY);            genTime.set(gt.get());            if (genTime.get() != generateTime) {                orig.set(val);                genTime.set(0L);                continue;            }        } else {            orig.set(val);        }    }    if (genTime.get() != 0L) {        orig.getMetaData().put(Nutch.WRITABLE_GENERATE_TIME_KEY, genTime);    }    context.write(key, orig);}
9d893f2599481abc406c71c04eb44eb5e09c9c63af4c6402a0c5542b5caa4f43
generate
public Path[] generate(Path dbDir, Path segments, int numLists, long topN, long curTime) throws IOException, InterruptedException, ClassNotFoundException
{    Job job = NutchJob.getInstance(getConf());    Configuration conf = job.getConfiguration();    boolean filter = conf.getBoolean(GENERATOR_FILTER, true);    boolean normalise = conf.getBoolean(GENERATOR_NORMALISE, true);    return generate(dbDir, segments, numLists, topN, curTime, filter, normalise, false, 1, null);}
cae0493262b43b2aadc10bba85d3fe4d49ee7873aa0106a7c71cd7e79fd1a2e6
generate
public Path[] generate(Path dbDir, Path segments, int numLists, long topN, long curTime, boolean filter, boolean force) throws IOException, InterruptedException, ClassNotFoundException
{    return generate(dbDir, segments, numLists, topN, curTime, filter, true, force, 1, null);}
e62d0e3fb3cef50885e9d34f2bdeb60757c7bd3d725f1f916e107d9e06792237
generate
public Path[] generate(Path dbDir, Path segments, int numLists, long topN, long curTime, boolean filter, boolean norm, boolean force, int maxNumSegments, String expr) throws IOException, InterruptedException, ClassNotFoundException
{    return generate(dbDir, segments, numLists, topN, curTime, filter, true, force, 1, expr, null);}
a7ee890348d6577f2042c80e26e3c271b588b992cf37abbd3545a1f64c65701a
generate
public Path[] generate(Path dbDir, Path segments, int numLists, long topN, long curTime, boolean filter, boolean norm, boolean force, int maxNumSegments, String expr, String hostdb) throws IOException, InterruptedException, ClassNotFoundException
{    Path tempDir = new Path(getConf().get("mapreduce.cluster.temp.dir", ".") + "/generate-temp-" + java.util.UUID.randomUUID().toString());    FileSystem fs = tempDir.getFileSystem(getConf());    Path lock = CrawlDb.lock(getConf(), dbDir, force);    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    long start = System.currentTimeMillis();    LOG.info("Generator: starting at " + sdf.format(start));    LOG.info("Generator: Selecting best-scoring urls due for fetch.");    LOG.info("Generator: filtering: " + filter);    LOG.info("Generator: normalizing: " + norm);    if (topN != Long.MAX_VALUE) {        LOG.info("Generator: topN: {}", topN);    }    if (expr != null) {        LOG.info("Generator: expr: {}", expr);    }    if (hostdb != null) {        LOG.info("Generator: hostdb: {}", hostdb);    }        Job job = NutchJob.getInstance(getConf());    job.setJobName("generate: select from " + dbDir);    Configuration conf = job.getConfiguration();    if (numLists == -1) {        /* for politeness create exactly one partition per fetch task */        numLists = Integer.parseInt(conf.get("mapreduce.job.maps"));    }    if ("local".equals(conf.get("mapreduce.framework.name")) && numLists != 1) {                LOG.info("Generator: running in local mode, generating exactly one partition.");        numLists = 1;    }    conf.setLong(GENERATOR_CUR_TIME, curTime);        long generateTime = System.currentTimeMillis();    conf.setLong(Nutch.GENERATE_TIME_KEY, generateTime);    conf.setLong(GENERATOR_TOP_N, topN);    conf.setBoolean(GENERATOR_FILTER, filter);    conf.setBoolean(GENERATOR_NORMALISE, norm);    conf.setInt(GENERATOR_MAX_NUM_SEGMENTS, maxNumSegments);    if (expr != null) {        conf.set(GENERATOR_EXPR, expr);    }    if (hostdb != null) {        conf.set(GENERATOR_HOSTDB, hostdb);    }    FileInputFormat.addInputPath(job, new Path(dbDir, CrawlDb.CURRENT_NAME));    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setJarByClass(Selector.class);    job.setMapperClass(SelectorMapper.class);    job.setPartitionerClass(Selector.class);    job.setReducerClass(SelectorReducer.class);    FileOutputFormat.setOutputPath(job, tempDir);    job.setOutputKeyClass(FloatWritable.class);    job.setSortComparatorClass(DecreasingFloatComparator.class);    job.setOutputValueClass(SelectorEntry.class);    MultipleOutputs.addNamedOutput(job, "sequenceFiles", SequenceFileOutputFormat.class, FloatWritable.class, SelectorEntry.class);    try {        boolean success = job.waitForCompletion(true);        if (!success) {            String message = "Generator job did not succeed, job status:" + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);            NutchJob.cleanupAfterFailure(tempDir, lock, fs);            throw new RuntimeException(message);        }    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error("Generator job failed: {}", e.getMessage());        NutchJob.cleanupAfterFailure(tempDir, lock, fs);        throw e;    }    LOG.info("Generator: number of items rejected during selection:");    for (Counter counter : job.getCounters().getGroup("Generator")) {        LOG.info("Generator: {}  {}", String.format(Locale.ROOT, "%6d", counter.getValue()), counter.getName());    }            List<Path> generatedSegments = new ArrayList<>();    FileStatus[] status = fs.listStatus(tempDir);    try {        for (FileStatus stat : status) {            Path subfetchlist = stat.getPath();            if (!subfetchlist.getName().startsWith("fetchlist-"))                continue;                        Path newSeg = partitionSegment(segments, subfetchlist, numLists);            generatedSegments.add(newSeg);        }    } catch (Exception e) {        LOG.warn("Generator: exception while partitioning segments, exiting ...");        LockUtil.removeLockFile(getConf(), lock);        fs.delete(tempDir, true);        return null;    }    if (generatedSegments.size() == 0) {        LOG.warn("Generator: 0 records selected for fetching, exiting ...");        LockUtil.removeLockFile(getConf(), lock);        fs.delete(tempDir, true);        return null;    }    if (getConf().getBoolean(GENERATE_UPDATE_CRAWLDB, false)) {                Path tempDir2 = new Path(dbDir, "generate-temp-" + java.util.UUID.randomUUID().toString());        job = NutchJob.getInstance(getConf());        job.setJobName("generate: updatedb " + dbDir);        job.getConfiguration().setLong(Nutch.GENERATE_TIME_KEY, generateTime);        for (Path segmpaths : generatedSegments) {            Path subGenDir = new Path(segmpaths, CrawlDatum.GENERATE_DIR_NAME);            FileInputFormat.addInputPath(job, subGenDir);        }        FileInputFormat.addInputPath(job, new Path(dbDir, CrawlDb.CURRENT_NAME));        job.setInputFormatClass(SequenceFileInputFormat.class);        job.setMapperClass(CrawlDbUpdater.CrawlDbUpdateMapper.class);        job.setReducerClass(CrawlDbUpdater.CrawlDbUpdateReducer.class);        job.setJarByClass(CrawlDbUpdater.class);        job.setOutputFormatClass(MapFileOutputFormat.class);        job.setOutputKeyClass(Text.class);        job.setOutputValueClass(CrawlDatum.class);        FileOutputFormat.setOutputPath(job, tempDir2);        try {            boolean success = job.waitForCompletion(true);            if (!success) {                String message = "Generator job did not succeed, job status:" + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();                LOG.error(message);                NutchJob.cleanupAfterFailure(tempDir, lock, fs);                NutchJob.cleanupAfterFailure(tempDir2, lock, fs);                throw new RuntimeException(message);            }            CrawlDb.install(job, dbDir);        } catch (IOException | InterruptedException | ClassNotFoundException e) {            LOG.error("Generator job failed: {}", e.getMessage());            NutchJob.cleanupAfterFailure(tempDir, lock, fs);            NutchJob.cleanupAfterFailure(tempDir2, lock, fs);            throw e;        }        fs.delete(tempDir2, true);    }    LockUtil.removeLockFile(getConf(), lock);    fs.delete(tempDir, true);    long end = System.currentTimeMillis();    LOG.info("Generator: finished at " + sdf.format(end) + ", elapsed: " + TimingUtil.elapsedTime(start, end));    Path[] patharray = new Path[generatedSegments.size()];    return generatedSegments.toArray(patharray);}
f8c93f5bcf9a5922569a48461fdd78020782def0ba60568a74ab524353685a89
partitionSegment
private Path partitionSegment(Path segmentsDir, Path inputDir, int numLists) throws IOException, ClassNotFoundException, InterruptedException
{        if (LOG.isInfoEnabled()) {        LOG.info("Generator: Partitioning selected urls for politeness.");    }    Path segment = new Path(segmentsDir, generateSegmentName());    Path output = new Path(segment, CrawlDatum.GENERATE_DIR_NAME);    LOG.info("Generator: segment: " + segment);    Job job = NutchJob.getInstance(getConf());    job.setJobName("generate: partition " + segment);    Configuration conf = job.getConfiguration();    conf.setInt("partition.url.seed", new Random().nextInt());    FileInputFormat.addInputPath(job, inputDir);    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setJarByClass(Generator.class);    job.setMapperClass(SelectorInverseMapper.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(SelectorEntry.class);    job.setPartitionerClass(URLPartitioner.class);    job.setReducerClass(PartitionReducer.class);    job.setNumReduceTasks(numLists);    FileOutputFormat.setOutputPath(job, output);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(CrawlDatum.class);    job.setSortComparatorClass(HashComparator.class);    try {        boolean success = job.waitForCompletion(true);        if (!success) {            String message = "Generator job did not succeed, job status:" + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);            throw new RuntimeException(message);        }    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error(StringUtils.stringifyException(e));        throw e;    }    return segment;}
636853d50e42ca3167c3f9f4053c592451b2ed973e114fc90783bacdc1fa1353
generateSegmentName
public static synchronized String generateSegmentName()
{    try {        Thread.sleep(1000);    } catch (Throwable t) {    }    ;    return sdf.format(new Date(System.currentTimeMillis()));}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int res = ToolRunner.run(NutchConfiguration.create(), new Generator(), args);    System.exit(res);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    if (args.length < 2) {        System.out.println("Usage: Generator <crawldb> <segments_dir> [-force] [-topN N] [-numFetchers numFetchers] [-expr <expr>] [-adddays <numDays>] [-noFilter] [-noNorm] [-maxNumSegments <num>]");        return -1;    }    Path dbDir = new Path(args[0]);    Path segmentsDir = new Path(args[1]);    String hostdb = null;    long curTime = System.currentTimeMillis();    long topN = Long.MAX_VALUE;    int numFetchers = -1;    boolean filter = true;    boolean norm = true;    boolean force = false;    String expr = null;    int maxNumSegments = 1;    for (int i = 2; i < args.length; i++) {        if ("-topN".equals(args[i])) {            topN = Long.parseLong(args[i + 1]);            i++;        } else if ("-numFetchers".equals(args[i])) {            numFetchers = Integer.parseInt(args[i + 1]);            i++;        } else if ("-hostdb".equals(args[i])) {            hostdb = args[i + 1];            i++;        } else if ("-adddays".equals(args[i])) {            long numDays = Integer.parseInt(args[i + 1]);            curTime += numDays * 1000L * 60 * 60 * 24;        } else if ("-noFilter".equals(args[i])) {            filter = false;        } else if ("-noNorm".equals(args[i])) {            norm = false;        } else if ("-force".equals(args[i])) {            force = true;        } else if ("-maxNumSegments".equals(args[i])) {            maxNumSegments = Integer.parseInt(args[i + 1]);        } else if ("-expr".equals(args[i])) {            expr = args[i + 1];        }    }    try {        Path[] segs = generate(dbDir, segmentsDir, numFetchers, topN, curTime, filter, norm, force, maxNumSegments, expr, hostdb);        if (segs == null)            return 1;    } catch (Exception e) {        LOG.error("Generator: " + StringUtils.stringifyException(e));        return -1;    }    return 0;}
084523121ab64bd9486b37875e438171d2b2467ace02bce8523551b0ce84ace4
run
public Map<String, Object> run(Map<String, Object> args, String crawlId) throws Exception
{    Map<String, Object> results = new HashMap<>();    long curTime = System.currentTimeMillis();    long topN = Long.MAX_VALUE;    int numFetchers = -1;    boolean filter = true;    boolean norm = true;    boolean force = false;    int maxNumSegments = 1;    String expr = null;    String hostdb = null;    Path crawlDb;    if (args.containsKey(Nutch.ARG_CRAWLDB)) {        Object crawldbPath = args.get(Nutch.ARG_CRAWLDB);        if (crawldbPath instanceof Path) {            crawlDb = (Path) crawldbPath;        } else {            crawlDb = new Path(crawldbPath.toString());        }    } else {        crawlDb = new Path(crawlId + "/crawldb");    }    Path segmentsDir;    if (args.containsKey(Nutch.ARG_SEGMENTDIR)) {        Object segDir = args.get(Nutch.ARG_SEGMENTDIR);        if (segDir instanceof Path) {            segmentsDir = (Path) segDir;        } else {            segmentsDir = new Path(segDir.toString());        }    } else {        segmentsDir = new Path(crawlId + "/segments");    }    if (args.containsKey(Nutch.ARG_HOSTDB)) {        hostdb = (String) args.get(Nutch.ARG_HOSTDB);    }    if (args.containsKey("expr")) {        expr = (String) args.get("expr");    }    if (args.containsKey("topN")) {        topN = Long.parseLong((String) args.get("topN"));    }    if (args.containsKey("numFetchers")) {        numFetchers = Integer.parseInt((String) args.get("numFetchers"));    }    if (args.containsKey("adddays")) {        long numDays = Integer.parseInt((String) args.get("adddays"));        curTime += numDays * 1000L * 60 * 60 * 24;    }    if (args.containsKey("noFilter")) {        filter = false;    }    if (args.containsKey("noNorm")) {        norm = false;    }    if (args.containsKey("force")) {        force = true;    }    if (args.containsKey("maxNumSegments")) {        maxNumSegments = Integer.parseInt((String) args.get("maxNumSegments"));    }    try {        Path[] segs = generate(crawlDb, segmentsDir, numFetchers, topN, curTime, filter, norm, force, maxNumSegments, expr, hostdb);        if (segs == null) {            results.put(Nutch.VAL_RESULT, Integer.toString(1));            return results;        }    } catch (Exception e) {        LOG.error("Generator: " + StringUtils.stringifyException(e));        results.put(Nutch.VAL_RESULT, Integer.toString(-1));        return results;    }    results.put(Nutch.VAL_RESULT, Integer.toString(0));    return results;}
5cea2a7c4e1f15509b5030e71609dca919138d48d1aebe9efc31435a268ea192
setup
public void setup(Context context)
{    Configuration conf = context.getConfiguration();    boolean normalize = conf.getBoolean(CrawlDbFilter.URL_NORMALIZING, true);    boolean filter = conf.getBoolean(CrawlDbFilter.URL_FILTERING, true);    filterNormalizeAll = conf.getBoolean(URL_FILTER_NORMALIZE_ALL, false);    if (normalize) {        scope = conf.get(URL_NORMALIZING_SCOPE, URLNormalizers.SCOPE_INJECT);        urlNormalizers = new URLNormalizers(conf, scope);    }    interval = conf.getInt("db.fetch.interval.default", 2592000);    if (filter) {        filters = new URLFilters(conf);    }    scfilters = new ScoringFilters(conf);    scoreInjected = conf.getFloat("db.score.injected", 1.0f);    curTime = conf.getLong("injector.current.time", System.currentTimeMillis());    url404Purging = conf.getBoolean(CrawlDb.CRAWLDB_PURGE_404, false);}
2b889bbf73ce3ba54b81471a74e4af72862f38b422f959d769f98655dfab46a5
filterNormalize
private String filterNormalize(String url)
{    if (url != null) {        try {            if (urlNormalizers != null)                                url = urlNormalizers.normalize(url, scope);            if (filters != null)                                url = filters.filter(url);        } catch (Exception e) {            LOG.warn("Skipping " + url + ":" + e);            url = null;        }    }    return url;}
a8133f9b43e2bf1e99b1ee38adfcdb6d2fcf4a7960a8a4048fcde87833f8aaf2
processMetaData
private void processMetaData(String metadata, CrawlDatum datum, String url)
{    String[] splits = metadata.split(TAB_CHARACTER);    for (String split : splits) {                int indexEquals = split.indexOf(EQUAL_CHARACTER);        if (        indexEquals == -1)            continue;        String metaname = split.substring(0, indexEquals);        String metavalue = split.substring(indexEquals + 1);        try {            if (metaname.equals(nutchScoreMDName)) {                datum.setScore(Float.parseFloat(metavalue));            } else if (metaname.equals(nutchFetchIntervalMDName)) {                datum.setFetchInterval(Integer.parseInt(metavalue));            } else if (metaname.equals(nutchFixedFetchIntervalMDName)) {                int fixedInterval = Integer.parseInt(metavalue);                if (fixedInterval > -1) {                                                            datum.getMetaData().put(Nutch.WRITABLE_FIXED_INTERVAL_KEY, new FloatWritable(fixedInterval));                    datum.setFetchInterval(fixedInterval);                }            } else {                datum.getMetaData().put(new Text(metaname), new Text(metavalue));            }        } catch (NumberFormatException nfe) {            LOG.error("Invalid number '" + metavalue + "' in metadata '" + metaname + "' for url " + url);        }    }}
4c9ec82e8777bee39c94eaffbd42f3bf891ce1ff9da91c3080a6b85972806e5d
map
public void map(Text key, Writable value, Context context) throws IOException, InterruptedException
{    if (value instanceof Text) {                String url = key.toString().trim();                if (url.length() == 0 || url.startsWith("#"))            return;        url = filterNormalize(url);        if (url == null) {            context.getCounter("injector", "urls_filtered").increment(1);        } else {            CrawlDatum datum = new CrawlDatum();            datum.setStatus(CrawlDatum.STATUS_INJECTED);            datum.setFetchTime(curTime);            datum.setScore(scoreInjected);            datum.setFetchInterval(interval);            String metadata = value.toString().trim();            if (metadata.length() > 0)                processMetaData(metadata, datum, url);            try {                key.set(url);                scfilters.injectedScore(key, datum);            } catch (ScoringFilterException e) {                if (LOG.isWarnEnabled()) {                    LOG.warn("Cannot filter injected score for url " + url + ", using default (" + e.getMessage() + ")");                }            }            context.getCounter("injector", "urls_injected").increment(1);            context.write(key, datum);        }    } else if (value instanceof CrawlDatum) {                        CrawlDatum datum = (CrawlDatum) value;                if (url404Purging && CrawlDatum.STATUS_DB_GONE == datum.getStatus()) {            context.getCounter("injector", "urls_purged_404").increment(1);            return;        }        if (filterNormalizeAll) {            String url = filterNormalize(key.toString());            if (url == null) {                context.getCounter("injector", "urls_purged_filter").increment(1);            } else {                key.set(url);                context.write(key, datum);            }        } else {            context.write(key, datum);        }    }}
5cea2a7c4e1f15509b5030e71609dca919138d48d1aebe9efc31435a268ea192
setup
public void setup(Context context)
{    Configuration conf = context.getConfiguration();    interval = conf.getInt("db.fetch.interval.default", 2592000);    scoreInjected = conf.getFloat("db.score.injected", 1.0f);    overwrite = conf.getBoolean("db.injector.overwrite", false);    update = conf.getBoolean("db.injector.update", false);    LOG.info("Injector: overwrite: " + overwrite);    LOG.info("Injector: update: " + update);}
dfa33bb74c8851fea1ca7d1879839d7b539c5564809dc8824a9b4ec385276528
reduce
public void reduce(Text key, Iterable<CrawlDatum> values, Context context) throws IOException, InterruptedException
{    boolean oldSet = false;    boolean injectedSet = false;        for (CrawlDatum val : values) {        if (val.getStatus() == CrawlDatum.STATUS_INJECTED) {            injected.set(val);            injected.setStatus(CrawlDatum.STATUS_DB_UNFETCHED);            injectedSet = true;        } else {            old.set(val);            oldSet = true;        }    }    CrawlDatum result;    if (injectedSet && (!oldSet || overwrite)) {                result = injected;    } else {                result = old;        if (injectedSet && update) {                        old.putAllMetaData(injected);            old.setScore(injected.getScore() != scoreInjected ? injected.getScore() : old.getScore());            old.setFetchInterval(injected.getFetchInterval() != interval ? injected.getFetchInterval() : old.getFetchInterval());        }    }    if (injectedSet && oldSet) {        context.getCounter("injector", "urls_merged").increment(1);    }    context.write(key, result);}
319ffd628257d3021e7721ca63f447e8831a9e42871f360ff4d45279cf66632f
inject
public void inject(Path crawlDb, Path urlDir) throws IOException, ClassNotFoundException, InterruptedException
{    inject(crawlDb, urlDir, false, false);}
e857c5019cbd499622035466fac9a8379ee7c2e8517343c2787249e48b3ed762
inject
public void inject(Path crawlDb, Path urlDir, boolean overwrite, boolean update) throws IOException, ClassNotFoundException, InterruptedException
{    inject(crawlDb, urlDir, overwrite, update, true, true, false);}
2522057850eff96ce58bed2ff538e25159c4e0809224f696a1cd3fa05b5c9634
inject
public void inject(Path crawlDb, Path urlDir, boolean overwrite, boolean update, boolean normalize, boolean filter, boolean filterNormalizeAll) throws IOException, ClassNotFoundException, InterruptedException
{    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    long start = System.currentTimeMillis();    if (LOG.isInfoEnabled()) {        LOG.info("Injector: starting at " + sdf.format(start));        LOG.info("Injector: crawlDb: " + crawlDb);        LOG.info("Injector: urlDir: " + urlDir);        LOG.info("Injector: Converting injected urls to crawl db entries.");    }        Configuration conf = getConf();    conf.setLong("injector.current.time", System.currentTimeMillis());    conf.setBoolean("db.injector.overwrite", overwrite);    conf.setBoolean("db.injector.update", update);    conf.setBoolean(CrawlDbFilter.URL_NORMALIZING, normalize);    conf.setBoolean(CrawlDbFilter.URL_FILTERING, filter);    conf.setBoolean(URL_FILTER_NORMALIZE_ALL, filterNormalizeAll);    conf.setBoolean("mapreduce.fileoutputcommitter.marksuccessfuljobs", false);        FileSystem fs = crawlDb.getFileSystem(conf);    Path current = new Path(crawlDb, CrawlDb.CURRENT_NAME);    if (!fs.exists(current))        fs.mkdirs(current);    Path tempCrawlDb = new Path(crawlDb, "crawldb-" + Integer.toString(new Random().nextInt(Integer.MAX_VALUE)));        Path lock = CrawlDb.lock(conf, crawlDb, false);        Job job = Job.getInstance(conf, "inject " + urlDir);    job.setJarByClass(Injector.class);    job.setMapperClass(InjectMapper.class);    job.setReducerClass(InjectReducer.class);    job.setOutputFormatClass(MapFileOutputFormat.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(CrawlDatum.class);    job.setSpeculativeExecution(false);        MultipleInputs.addInputPath(job, current, SequenceFileInputFormat.class);    FileStatus[] seedFiles = urlDir.getFileSystem(getConf()).listStatus(urlDir);    int numSeedFiles = 0;    for (FileStatus seedFile : seedFiles) {        if (seedFile.isFile()) {            MultipleInputs.addInputPath(job, seedFile.getPath(), KeyValueTextInputFormat.class);            numSeedFiles++;            LOG.info("Injecting seed URL file {}", seedFile.getPath());        } else {            LOG.warn("Skipped non-file input in {}: {}", urlDir, seedFile.getPath());        }    }    if (numSeedFiles == 0) {        LOG.error("No seed files to inject found in {}", urlDir);        LockUtil.removeLockFile(fs, lock);        return;    }    FileOutputFormat.setOutputPath(job, tempCrawlDb);    try {                boolean success = job.waitForCompletion(true);        if (!success) {            String message = "Injector job did not succeed, job status: " + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);            NutchJob.cleanupAfterFailure(tempCrawlDb, lock, fs);                        throw new RuntimeException(message);        }                CrawlDb.install(job, crawlDb);        if (LOG.isInfoEnabled()) {            long urlsInjected = job.getCounters().findCounter("injector", "urls_injected").getValue();            long urlsFiltered = job.getCounters().findCounter("injector", "urls_filtered").getValue();            long urlsMerged = job.getCounters().findCounter("injector", "urls_merged").getValue();            long urlsPurged404 = job.getCounters().findCounter("injector", "urls_purged_404").getValue();            long urlsPurgedFilter = job.getCounters().findCounter("injector", "urls_purged_filter").getValue();            LOG.info("Injector: Total urls rejected by filters: " + urlsFiltered);            LOG.info("Injector: Total urls injected after normalization and filtering: " + urlsInjected);            LOG.info("Injector: Total urls injected but already in CrawlDb: " + urlsMerged);            LOG.info("Injector: Total new urls injected: " + (urlsInjected - urlsMerged));            if (filterNormalizeAll) {                LOG.info("Injector: Total urls removed from CrawlDb by filters: {}", urlsPurgedFilter);            }            if (conf.getBoolean(CrawlDb.CRAWLDB_PURGE_404, false)) {                LOG.info("Injector: Total urls with status gone removed from CrawlDb (db.update.purge.404): {}", urlsPurged404);            }            long end = System.currentTimeMillis();            LOG.info("Injector: finished at " + sdf.format(end) + ", elapsed: " + TimingUtil.elapsedTime(start, end));        }    } catch (IOException | InterruptedException | ClassNotFoundException | NullPointerException e) {        LOG.error("Injector job failed: {}", e.getMessage());        NutchJob.cleanupAfterFailure(tempCrawlDb, lock, fs);        throw e;    }}
6b3ea3dc2a8f3bdfff2e76acf75fd52532fdc7b685b5ffc97841034282297c1d
usage
public void usage()
{    System.err.println("Usage: Injector [-D...] <crawldb> <url_dir> [-overwrite|-update] [-noFilter] [-noNormalize] [-filterNormalizeAll]\n");    System.err.println("  <crawldb>\tPath to a crawldb directory. If not present, a new one would be created.");    System.err.println("  <url_dir>\tPath to URL file or directory with URL file(s) containing URLs to be injected.");    System.err.println("           \tA URL file should have one URL per line, optionally followed by custom metadata.");    System.err.println("           \tBlank lines or lines starting with a '#' would be ignored. Custom metadata must");    System.err.println("           \tbe of form 'key=value' and separated by tabs.");    System.err.println("           \tBelow are reserved metadata keys:\n");    System.err.println("           \t\tnutch.score: A custom score for a url");    System.err.println("           \t\tnutch.fetchInterval: A custom fetch interval for a url");    System.err.println("           \t\tnutch.fetchInterval.fixed: A custom fetch interval for a url that is not " + "changed by AdaptiveFetchSchedule\n");    System.err.println("           \tExample:");    System.err.println("           \t http://www.apache.org/");    System.err.println("           \t http://www.nutch.org/ \\t nutch.score=10 \\t nutch.fetchInterval=2592000 \\t userType=open_source\n");    System.err.println(" -overwrite\tOverwite existing crawldb records by the injected records. Has precedence over 'update'");    System.err.println(" -update   \tUpdate existing crawldb records with the injected records. Old metadata is preserved");    System.err.println();    System.err.println(" -nonormalize\tDo not normalize URLs before injecting");    System.err.println(" -nofilter \tDo not apply URL filters to injected URLs");    System.err.println(" -filterNormalizeAll\n" + "           \tNormalize and filter all URLs including the URLs of existing CrawlDb records");    System.err.println();    System.err.println(" -D...     \tset or overwrite configuration property (property=value)");    System.err.println(" -Ddb.update.purge.404=true\n" + "           \tremove URLs with status gone (404) from CrawlDb");}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int res = ToolRunner.run(NutchConfiguration.create(), new Injector(), args);    System.exit(res);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    if (args.length < 2) {        usage();        return -1;    }    boolean overwrite = false;    boolean update = false;    boolean normalize = true;    boolean filter = true;    boolean filterNormalizeAll = false;    for (int i = 2; i < args.length; i++) {        if (args[i].equals("-overwrite")) {            overwrite = true;        } else if (args[i].equals("-update")) {            update = true;        } else if (args[i].equals("-noNormalize")) {            normalize = false;        } else if (args[i].equals("-noFilter")) {            filter = false;        } else if (args[i].equals("-filterNormalizeAll")) {            filterNormalizeAll = true;        } else {            LOG.info("Injector: Found invalid argument \"" + args[i] + "\"\n");            usage();            return -1;        }    }    try {        inject(new Path(args[0]), new Path(args[1]), overwrite, update, normalize, filter, filterNormalizeAll);        return 0;    } catch (Exception e) {        LOG.error("Injector: " + StringUtils.stringifyException(e));        return -1;    }}
084523121ab64bd9486b37875e438171d2b2467ace02bce8523551b0ce84ace4
run
public Map<String, Object> run(Map<String, Object> args, String crawlId) throws Exception
{    if (args.size() < 1) {        throw new IllegalArgumentException("Required arguments <url_dir> or <seedName>");    }    Path input;    Object path = null;    if (args.containsKey(Nutch.ARG_SEEDDIR)) {        path = args.get(Nutch.ARG_SEEDDIR);    } else if (args.containsKey(Nutch.ARG_SEEDNAME)) {        path = NutchServer.getInstance().getSeedManager().getSeedList((String) args.get(Nutch.ARG_SEEDNAME)).getSeedFilePath();    } else {        throw new IllegalArgumentException("Required arguments <url_dir> or <seedName>");    }    if (path instanceof Path) {        input = (Path) path;    } else {        input = new Path(path.toString());    }    Map<String, Object> results = new HashMap<>();    Path crawlDb;    if (args.containsKey(Nutch.ARG_CRAWLDB)) {        Object crawldbPath = args.get(Nutch.ARG_CRAWLDB);        if (crawldbPath instanceof Path) {            crawlDb = (Path) crawldbPath;        } else {            crawlDb = new Path(crawldbPath.toString());        }    } else {        crawlDb = new Path(crawlId + "/crawldb");    }    inject(crawlDb, input);    results.put(Nutch.VAL_RESULT, Integer.toString(0));    return results;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    fromUrl = Text.readString(in);    anchor = Text.readString(in);}
b415817508279ac67efbbd121bfc69e06485631b4566513717a8372c38d11af3
skip
public static void skip(DataInput in) throws IOException
{        Text.skip(in);        Text.skip(in);}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    Text.writeString(out, fromUrl);    Text.writeString(out, anchor);}
3b009cbc6faec438b2c6229a4b2d5be7e43fa6526d8db164f413390dfdc409bd
read
public static Inlink read(DataInput in) throws IOException
{    Inlink inlink = new Inlink();    inlink.readFields(in);    return inlink;}
d3e140cc63ec811797121f88e0fbcea942de33a530eca65b77e05df3a2cb3823
getFromUrl
public String getFromUrl()
{    return fromUrl;}
5632266259dd12f97eac4eb8fa5fe7c4757994ac78574e29c6b86d0d82bc5627
getAnchor
public String getAnchor()
{    return anchor;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof Inlink))        return false;    Inlink other = (Inlink) o;    return this.fromUrl.equals(other.fromUrl) && this.anchor.equals(other.anchor);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return fromUrl.hashCode() ^ anchor.hashCode();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "fromUrl: " + fromUrl + " anchor: " + anchor;}
d4861b1f2f9eb56f6c17ca995387a2e0391b0841c9b7085493646582d9af9199
add
public void add(Inlink inlink)
{    inlinks.add(inlink);}
f8bcf51dc185cf8fe54f4d665d5700cca8a6ec9a5ae70f7ef4c8a9a7b55ae5a1
add
public void add(Inlinks inlinks)
{    this.inlinks.addAll(inlinks.inlinks);}
0f1f9cb2c810e7be3b85a1d7f23b0b28a688e7ba93d4ee8613191320fad935c1
iterator
public Iterator<Inlink> iterator()
{    return this.inlinks.iterator();}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return inlinks.size();}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    inlinks.clear();}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    int length = in.readInt();    inlinks.clear();    for (int i = 0; i < length; i++) {        add(Inlink.read(in));    }}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeInt(inlinks.size());    Iterator<Inlink> it = inlinks.iterator();    while (it.hasNext()) {        it.next().write(out);    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder buffer = new StringBuilder();    buffer.append("Inlinks:\n");    Iterator<Inlink> it = inlinks.iterator();    while (it.hasNext()) {        buffer.append(" ");        buffer.append(it.next());        buffer.append("\n");    }    return buffer.toString();}
5a582ce3517441c3d6bb4238dcdf26cb6805b7121ddf2245d74988114c5a3289
getAnchors
public String[] getAnchors()
{    HashMap<String, Set<String>> domainToAnchors = new HashMap<>();    ArrayList<String> results = new ArrayList<>();    Iterator<Inlink> it = inlinks.iterator();    while (it.hasNext()) {        Inlink inlink = it.next();        String anchor = inlink.getAnchor();        if (        anchor.length() == 0)            continue;                String domain = null;        try {            domain = new URL(inlink.getFromUrl()).getHost();        } catch (MalformedURLException e) {        }        Set<String> domainAnchors = domainToAnchors.get(domain);        if (domainAnchors == null) {            domainAnchors = new HashSet<>();            domainToAnchors.put(domain, domainAnchors);        }        if (domainAnchors.add(anchor)) {                                    results.add(anchor);        }    }    return results.toArray(new String[results.size()]);}
a2015d1f5142bb4eb6e98f7395adbe84b4ec7a9a11a47ea5c82976d0447a59d6
setup
public void setup(Mapper<Text, ParseData, Text, Inlinks>.Context context)
{    Configuration conf = context.getConfiguration();    maxAnchorLength = conf.getInt("linkdb.max.anchor.length", 100);    ignoreInternalLinks = conf.getBoolean(IGNORE_INTERNAL_LINKS, true);    ignoreExternalLinks = conf.getBoolean(IGNORE_EXTERNAL_LINKS, false);    if (conf.getBoolean(LinkDbFilter.URL_FILTERING, false)) {        urlFilters = new URLFilters(conf);    }    if (conf.getBoolean(LinkDbFilter.URL_NORMALIZING, false)) {        urlNormalizers = new URLNormalizers(conf, URLNormalizers.SCOPE_LINKDB);    }}
55fed5c2b20fc42050df5314664f76991da43a2c1ad801e48297aafe481684f6
map
public void map(Text key, ParseData parseData, Context context) throws IOException, InterruptedException
{    String fromUrl = key.toString();    String fromHost = getHost(fromUrl);    if (urlNormalizers != null) {        try {            fromUrl = urlNormalizers.normalize(fromUrl,             URLNormalizers.SCOPE_LINKDB);        } catch (Exception e) {            LOG.warn("Skipping {} :", fromUrl, e);            fromUrl = null;        }    }    if (fromUrl != null && urlFilters != null) {        try {                        fromUrl = urlFilters.filter(fromUrl);        } catch (Exception e) {            LOG.warn("Skipping {} :", fromUrl, e);            fromUrl = null;        }    }    if (fromUrl == null)                return;    Outlink[] outlinks = parseData.getOutlinks();    Inlinks inlinks = new Inlinks();    for (int i = 0; i < outlinks.length; i++) {        Outlink outlink = outlinks[i];        String toUrl = outlink.getToUrl();        if (ignoreInternalLinks) {            String toHost = getHost(toUrl);            if (toHost == null || toHost.equals(fromHost)) {                                continue;            }        } else if (ignoreExternalLinks) {            String toHost = getHost(toUrl);            if (toHost == null || !toHost.equals(fromHost)) {                                continue;            }        }        if (urlNormalizers != null) {            try {                                toUrl = urlNormalizers.normalize(toUrl, URLNormalizers.SCOPE_LINKDB);            } catch (Exception e) {                LOG.warn("Skipping {} :", toUrl, e);                toUrl = null;            }        }        if (toUrl != null && urlFilters != null) {            try {                                toUrl = urlFilters.filter(toUrl);            } catch (Exception e) {                LOG.warn("Skipping {} :", toUrl, e);                toUrl = null;            }        }        if (toUrl == null)            continue;        inlinks.clear();                String anchor = outlink.getAnchor();        if (anchor.length() > maxAnchorLength) {            anchor = anchor.substring(0, maxAnchorLength);        }                inlinks.add(new Inlink(fromUrl, anchor));        context.write(new Text(toUrl), inlinks);    }}
edf5823cc099bf14ac55cf51b4cf86b53513fe8247b2fda58a7752033a7c72ea
getHost
private static String getHost(String url)
{    try {        return new URL(url).getHost().toLowerCase();    } catch (MalformedURLException e) {        return null;    }}
d6e60c2656e61f730d3c989fc2a86d5b19be5d60d7faf7fb1d52d8dcaacece50
invert
public void invert(Path linkDb, final Path segmentsDir, boolean normalize, boolean filter, boolean force) throws IOException, InterruptedException, ClassNotFoundException
{    FileSystem fs = segmentsDir.getFileSystem(getConf());    FileStatus[] files = fs.listStatus(segmentsDir, HadoopFSUtil.getPassDirectoriesFilter(fs));    invert(linkDb, HadoopFSUtil.getPaths(files), normalize, filter, force);}
7c9ff63f1acb7d5bfd313344dabbdb6593253ba5c7d882943424730ad93a24cc
invert
public void invert(Path linkDb, Path[] segments, boolean normalize, boolean filter, boolean force) throws IOException, InterruptedException, ClassNotFoundException
{    Job job = LinkDb.createJob(getConf(), linkDb, normalize, filter);    Path lock = new Path(linkDb, LOCK_NAME);    FileSystem fs = linkDb.getFileSystem(getConf());    LockUtil.createLockFile(fs, lock, force);    Path currentLinkDb = new Path(linkDb, CURRENT_NAME);    Configuration conf = job.getConfiguration();    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    long start = System.currentTimeMillis();    if (LOG.isInfoEnabled()) {        LOG.info("LinkDb: starting at {}", sdf.format(start));        LOG.info("LinkDb: linkdb: {}", linkDb);        LOG.info("LinkDb: URL normalize: {}", normalize);        LOG.info("LinkDb: URL filter: {}", filter);        if (conf.getBoolean(IGNORE_INTERNAL_LINKS, true)) {            LOG.info("LinkDb: internal links will be ignored.");        }        if (conf.getBoolean(IGNORE_EXTERNAL_LINKS, false)) {            LOG.info("LinkDb: external links will be ignored.");        }    }    if (conf.getBoolean(IGNORE_INTERNAL_LINKS, true) && conf.getBoolean(IGNORE_EXTERNAL_LINKS, false)) {        LOG.warn("LinkDb: internal and external links are ignored! " + "Nothing to do, actually. Exiting.");        LockUtil.removeLockFile(fs, lock);        return;    }    for (int i = 0; i < segments.length; i++) {        if (LOG.isInfoEnabled()) {            LOG.info("LinkDb: adding segment: {}", segments[i]);        }        FileInputFormat.addInputPath(job, new Path(segments[i], ParseData.DIR_NAME));    }    try {        boolean success = job.waitForCompletion(true);        if (!success) {            String message = "LinkDb job did not succeed, job status:" + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);            LockUtil.removeLockFile(fs, lock);            throw new RuntimeException(message);        }    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error("LinkDb job failed: {}", e.getMessage());        LockUtil.removeLockFile(fs, lock);        throw e;    }    if (fs.exists(currentLinkDb)) {        if (LOG.isInfoEnabled()) {            LOG.info("LinkDb: merging with existing linkdb: {}", linkDb);        }                Path newLinkDb = FileOutputFormat.getOutputPath(job);        job = LinkDbMerger.createMergeJob(getConf(), linkDb, normalize, filter);        FileInputFormat.addInputPath(job, currentLinkDb);        FileInputFormat.addInputPath(job, newLinkDb);        try {            boolean success = job.waitForCompletion(true);            if (!success) {                String message = "LinkDb job did not succeed, job status:" + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();                LOG.error(message);                NutchJob.cleanupAfterFailure(newLinkDb, lock, fs);                throw new RuntimeException(message);            }        } catch (IOException | InterruptedException | ClassNotFoundException e) {            LOG.error("LinkDb job failed: {}", e.getMessage());            NutchJob.cleanupAfterFailure(newLinkDb, lock, fs);            throw e;        }        fs.delete(newLinkDb, true);    }    LinkDb.install(job, linkDb);    long end = System.currentTimeMillis();    LOG.info("LinkDb: finished at {}, elapsed: {}", sdf.format(end), TimingUtil.elapsedTime(start, end));}
5fa77a13eefd632c96fdfc7a1b78a9e35f19be5151e9b00d7abf52e4b6d13563
createJob
private static Job createJob(Configuration config, Path linkDb, boolean normalize, boolean filter) throws IOException
{    Path newLinkDb = new Path(linkDb, Integer.toString(new Random().nextInt(Integer.MAX_VALUE)));    Job job = NutchJob.getInstance(config);    Configuration conf = job.getConfiguration();    job.setJobName("linkdb " + linkDb);    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setJarByClass(LinkDb.class);    job.setMapperClass(LinkDb.LinkDbMapper.class);    job.setJarByClass(LinkDbMerger.class);    job.setCombinerClass(LinkDbMerger.LinkDbMergeReducer.class);        if (normalize || filter) {        try {            FileSystem fs = linkDb.getFileSystem(config);            if (!fs.exists(linkDb)) {                conf.setBoolean(LinkDbFilter.URL_FILTERING, filter);                conf.setBoolean(LinkDbFilter.URL_NORMALIZING, normalize);            }        } catch (Exception e) {            LOG.warn("LinkDb createJob:: {}", e.getMessage());        }    }    job.setReducerClass(LinkDbMerger.LinkDbMergeReducer.class);    FileOutputFormat.setOutputPath(job, newLinkDb);    job.setOutputFormatClass(MapFileOutputFormat.class);    conf.setBoolean("mapreduce.output.fileoutputformat.compress", true);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(Inlinks.class);    return job;}
3fe8a6579c4d8dcba8de0ba0036506daf66c5536b661009c7d70d7891a56b964
install
public static void install(Job job, Path linkDb) throws IOException
{    Configuration conf = job.getConfiguration();    Path newLinkDb = FileOutputFormat.getOutputPath(job);    FileSystem fs = linkDb.getFileSystem(conf);    Path old = new Path(linkDb, "old");    Path current = new Path(linkDb, CURRENT_NAME);    if (fs.exists(current)) {        if (fs.exists(old))            fs.delete(old, true);        fs.rename(current, old);    }    fs.mkdirs(linkDb);    fs.rename(newLinkDb, current);    if (fs.exists(old))        fs.delete(old, true);    LockUtil.removeLockFile(fs, new Path(linkDb, LOCK_NAME));}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int res = ToolRunner.run(NutchConfiguration.create(), new LinkDb(), args);    System.exit(res);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    if (args.length < 2) {        System.err.println("Usage: LinkDb <linkdb> (-dir <segmentsDir> | <seg1> <seg2> ...) [-force] [-noNormalize] [-noFilter]");        System.err.println("\tlinkdb\toutput LinkDb to create or update");        System.err.println("\t-dir segmentsDir\tparent directory of several segments, OR");        System.err.println("\tseg1 seg2 ...\t list of segment directories");        System.err.println("\t-force\tforce update even if LinkDb appears to be locked (CAUTION advised)");        System.err.println("\t-noNormalize\tdon't normalize link URLs");        System.err.println("\t-noFilter\tdon't apply URLFilters to link URLs");        return -1;    }    Path db = new Path(args[0]);    ArrayList<Path> segs = new ArrayList<>();    boolean filter = true;    boolean normalize = true;    boolean force = false;    for (int i = 1; i < args.length; i++) {        if ("-dir".equals(args[i])) {            Path segDir = new Path(args[++i]);            FileSystem fs = segDir.getFileSystem(getConf());            FileStatus[] paths = fs.listStatus(segDir, HadoopFSUtil.getPassDirectoriesFilter(fs));            segs.addAll(Arrays.asList(HadoopFSUtil.getPaths(paths)));        } else if ("-noNormalize".equalsIgnoreCase(args[i])) {            normalize = false;        } else if ("-noFilter".equalsIgnoreCase(args[i])) {            filter = false;        } else if ("-force".equalsIgnoreCase(args[i])) {            force = true;        } else            segs.add(new Path(args[i]));    }    try {        invert(db, segs.toArray(new Path[segs.size()]), normalize, filter, force);        return 0;    } catch (Exception e) {        LOG.error("LinkDb: {}", StringUtils.stringifyException(e));        return -1;    }}
084523121ab64bd9486b37875e438171d2b2467ace02bce8523551b0ce84ace4
run
public Map<String, Object> run(Map<String, Object> args, String crawlId) throws Exception
{    Map<String, Object> results = new HashMap<>();    Path linkdb;    if (args.containsKey(Nutch.ARG_LINKDB)) {        Object path = args.get(Nutch.ARG_LINKDB);        if (path instanceof Path) {            linkdb = (Path) path;        } else {            linkdb = new Path(path.toString());        }    } else {        linkdb = new Path(crawlId + "/linkdb");    }    ArrayList<Path> segs = new ArrayList<>();    boolean filter = true;    boolean normalize = true;    boolean force = false;    if (args.containsKey("noNormalize")) {        normalize = false;    }    if (args.containsKey("noFilter")) {        filter = false;    }    if (args.containsKey("force")) {        force = true;    }    Path segmentsDir;    if (args.containsKey(Nutch.ARG_SEGMENTDIR)) {        Object segDir = args.get(Nutch.ARG_SEGMENTDIR);        if (segDir instanceof Path) {            segmentsDir = (Path) segDir;        } else {            segmentsDir = new Path(segDir.toString());        }        FileSystem fs = segmentsDir.getFileSystem(getConf());        FileStatus[] paths = fs.listStatus(segmentsDir, HadoopFSUtil.getPassDirectoriesFilter(fs));        segs.addAll(Arrays.asList(HadoopFSUtil.getPaths(paths)));    } else if (args.containsKey(Nutch.ARG_SEGMENTS)) {        Object segments = args.get(Nutch.ARG_SEGMENTS);        ArrayList<String> segmentList = new ArrayList<>();        if (segments instanceof ArrayList) {            segmentList = (ArrayList<String>) segments;        } else if (segments instanceof Path) {            segmentList.add(segments.toString());        }        for (String segment : segmentList) {            segs.add(new Path(segment));        }    } else {        String segmentDir = crawlId + "/segments";        File dir = new File(segmentDir);        File[] segmentsList = dir.listFiles();        Arrays.sort(segmentsList, (f1, f2) -> {            if (f1.lastModified() > f2.lastModified())                return -1;            else                return 0;        });        segs.add(new Path(segmentsList[0].getPath()));    }    try {        invert(linkdb, segs.toArray(new Path[segs.size()]), normalize, filter, force);        results.put(Nutch.VAL_RESULT, Integer.toString(0));        return results;    } catch (Exception e) {        LOG.error("LinkDb: {}", StringUtils.stringifyException(e));        results.put(Nutch.VAL_RESULT, Integer.toString(-1));        return results;    }}
156dab930e85f0377c45c3446886e4367eb5bfc60e50e535a1fa1c520b7f57df
setup
public void setup(Mapper<Text, Inlinks, Text, Inlinks>.Context context)
{    Configuration conf = context.getConfiguration();    filter = conf.getBoolean(URL_FILTERING, false);    normalize = conf.getBoolean(URL_NORMALIZING, false);    if (filter) {        filters = new URLFilters(conf);    }    if (normalize) {        scope = conf.get(URL_NORMALIZING_SCOPE, URLNormalizers.SCOPE_LINKDB);        normalizers = new URLNormalizers(conf, scope);    }}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{}
d08df862dfa7bc5b8ff7a6e3e94c8fd6ba6640b936afc115e9d26911816bfa16
map
public void map(Text key, Inlinks value, Context context) throws IOException, InterruptedException
{    String url = key.toString();    Inlinks result = new Inlinks();    if (normalize) {        try {                        url = normalizers.normalize(url, scope);        } catch (Exception e) {            LOG.warn("Skipping " + url + ":" + e);            url = null;        }    }    if (url != null && filter) {        try {                        url = filters.filter(url);        } catch (Exception e) {            LOG.warn("Skipping " + url + ":" + e);            url = null;        }    }    if (url == null)                return;    Iterator<Inlink> it = value.iterator();    String fromUrl = null;    while (it.hasNext()) {        Inlink inlink = it.next();        fromUrl = inlink.getFromUrl();        if (normalize) {            try {                                fromUrl = normalizers.normalize(fromUrl, scope);            } catch (Exception e) {                LOG.warn("Skipping " + fromUrl + ":" + e);                fromUrl = null;            }        }        if (fromUrl != null && filter) {            try {                                fromUrl = filters.filter(fromUrl);            } catch (Exception e) {                LOG.warn("Skipping " + fromUrl + ":" + e);                fromUrl = null;            }        }        if (fromUrl != null) {            result.add(new Inlink(fromUrl, inlink.getAnchor()));        }    }    if (result.size() > 0) {                newKey.set(url);        context.write(newKey, result);    }}
5723c600787f2871a483b1db3fc3fa1580bcd494a33cea05b90e023c2105a824
setup
public void setup(Reducer<Text, Inlinks, Text, Inlinks>.Context context)
{    Configuration conf = context.getConfiguration();    maxInlinks = conf.getInt("linkdb.max.inlinks", 10000);}
30e5d6c655ece9693e53ba89892563804651e34094f0258d73f15daf7e17c44c
reduce
public void reduce(Text key, Iterable<Inlinks> values, Context context) throws IOException, InterruptedException
{    Inlinks result = new Inlinks();    for (Inlinks inlinks : values) {        int end = Math.min(maxInlinks - result.size(), inlinks.size());        Iterator<Inlink> it = inlinks.iterator();        int i = 0;        while (it.hasNext() && i++ < end) {            result.add(it.next());        }    }    if (result.size() == 0)        return;    context.write(key, result);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{}
37c18367d0f036d6705d47c4c1808b5d1ebbb63d9a3d6e4e3f1552a3b25489e7
merge
public void merge(Path output, Path[] dbs, boolean normalize, boolean filter) throws Exception
{    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    long start = System.currentTimeMillis();    LOG.info("LinkDb merge: starting at " + sdf.format(start));    Job job = createMergeJob(getConf(), output, normalize, filter);    for (int i = 0; i < dbs.length; i++) {        FileInputFormat.addInputPath(job, new Path(dbs[i], LinkDb.CURRENT_NAME));    }    try {        boolean success = job.waitForCompletion(true);        if (!success) {            String message = "LinkDbMerge job did not succeed, job status:" + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);            throw new RuntimeException(message);        }    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error("LinkDbMerge job failed: {}", e.getMessage());        throw e;    }    FileSystem fs = output.getFileSystem(getConf());    fs.mkdirs(output);    fs.rename(FileOutputFormat.getOutputPath(job), new Path(output, LinkDb.CURRENT_NAME));    long end = System.currentTimeMillis();    LOG.info("LinkDb merge: finished at " + sdf.format(end) + ", elapsed: " + TimingUtil.elapsedTime(start, end));}
501a345832b64552652ee69c9b109e9585c3ad3883ad67fb0193b4761428524a
createMergeJob
public static Job createMergeJob(Configuration config, Path linkDb, boolean normalize, boolean filter) throws IOException
{    Path newLinkDb = new Path(linkDb, "merge-" + Integer.toString(new Random().nextInt(Integer.MAX_VALUE)));    Job job = NutchJob.getInstance(config);    job.setJobName("linkdb merge " + linkDb);    Configuration conf = job.getConfiguration();    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setMapperClass(LinkDbFilter.class);    conf.setBoolean(LinkDbFilter.URL_NORMALIZING, normalize);    conf.setBoolean(LinkDbFilter.URL_FILTERING, filter);    job.setJarByClass(LinkDbMerger.class);    job.setReducerClass(LinkDbMergeReducer.class);    FileOutputFormat.setOutputPath(job, newLinkDb);    job.setOutputFormatClass(MapFileOutputFormat.class);    conf.setBoolean("mapreduce.output.fileoutputformat.compress", true);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(Inlinks.class);        conf.setBoolean("mapreduce.fileoutputcommitter.marksuccessfuljobs", false);    return job;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int res = ToolRunner.run(NutchConfiguration.create(), new LinkDbMerger(), args);    System.exit(res);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    if (args.length < 2) {        System.err.println("Usage: LinkDbMerger <output_linkdb> <linkdb1> [<linkdb2> <linkdb3> ...] [-normalize] [-filter]");        System.err.println("\toutput_linkdb\toutput LinkDb");        System.err.println("\tlinkdb1 ...\tinput LinkDb-s (single input LinkDb is ok)");        System.err.println("\t-normalize\tuse URLNormalizer on both fromUrls and toUrls in linkdb(s) (usually not needed)");        System.err.println("\t-filter\tuse URLFilters on both fromUrls and toUrls in linkdb(s)");        return -1;    }    Path output = new Path(args[0]);    ArrayList<Path> dbs = new ArrayList<>();    boolean normalize = false;    boolean filter = false;    for (int i = 1; i < args.length; i++) {        if (args[i].equals("-filter")) {            filter = true;        } else if (args[i].equals("-normalize")) {            normalize = true;        } else            dbs.add(new Path(args[i]));    }    try {        merge(output, dbs.toArray(new Path[dbs.size()]), normalize, filter);        return 0;    } catch (Exception e) {        LOG.error("LinkDbMerger: " + StringUtils.stringifyException(e));        return -1;    }}
3a0b93f43adb2c673a4e354a982313da1082ffaa08df573fdeadb43f21acde78
init
public void init(Path directory) throws Exception
{    this.directory = directory;}
ebe00bf38f2c022070b1291bf5ee1bf07885f7abbba05186035de6d64b6e76f4
getAnchors
public String[] getAnchors(Text url) throws IOException
{    Inlinks inlinks = getInlinks(url);    if (inlinks == null)        return null;    return inlinks.getAnchors();}
33b759f493b0e178a4e7c765ffe263154397a28a34e866b01a72c53af7c3c971
getInlinks
public Inlinks getInlinks(Text url) throws IOException
{    if (readers == null) {        synchronized (this) {            readers = MapFileOutputFormat.getReaders(new Path(directory, LinkDb.CURRENT_NAME), getConf());        }    }    return (Inlinks) MapFileOutputFormat.getEntry(readers, PARTITIONER, url, new Inlinks());}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    if (readers != null) {        for (int i = 0; i < readers.length; i++) {            readers[i].close();        }    }}
156dab930e85f0377c45c3446886e4367eb5bfc60e50e535a1fa1c520b7f57df
setup
public void setup(Mapper<Text, Inlinks, Text, Inlinks>.Context context)
{    Configuration conf = context.getConfiguration();    if (conf.get("linkdb.regex", null) != null) {        pattern = Pattern.compile(conf.get("linkdb.regex"));    }}
d08df862dfa7bc5b8ff7a6e3e94c8fd6ba6640b936afc115e9d26911816bfa16
map
public void map(Text key, Inlinks value, Context context) throws IOException, InterruptedException
{    if (pattern != null) {        matcher = pattern.matcher(key.toString());        if (!matcher.matches()) {            return;        }    }    context.write(key, value);}
ab45c20a36030c07c79a73ee2f8478601d6473a63049d853ab7f359a788159f2
processDumpJob
public void processDumpJob(String linkdb, String output, String regex) throws IOException, InterruptedException, ClassNotFoundException
{    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    long start = System.currentTimeMillis();    if (LOG.isInfoEnabled()) {        LOG.info("LinkDb dump: starting at " + sdf.format(start));        LOG.info("LinkDb dump: db: " + linkdb);    }    Path outFolder = new Path(output);    Job job = NutchJob.getInstance(getConf());    job.setJobName("read " + linkdb);    job.setJarByClass(LinkDbReader.class);    Configuration conf = job.getConfiguration();    if (regex != null) {        conf.set("linkdb.regex", regex);        job.setMapperClass(LinkDBDumpMapper.class);    }    FileInputFormat.addInputPath(job, new Path(linkdb, LinkDb.CURRENT_NAME));    job.setInputFormatClass(SequenceFileInputFormat.class);    FileOutputFormat.setOutputPath(job, outFolder);    job.setOutputFormatClass(TextOutputFormat.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(Inlinks.class);    try {        boolean success = job.waitForCompletion(true);        if (!success) {            String message = "LinkDbRead job did not succeed, job status:" + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);            throw new RuntimeException(message);        }    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error(StringUtils.stringifyException(e));        throw e;    }    long end = System.currentTimeMillis();    LOG.info("LinkDb dump: finished at {}, elapsed: {}", sdf.format(end), TimingUtil.elapsedTime(start, end));}
5a9c6fab723cd06e037823885214041aae316eb36f109c0513491669cd33e005
process
protected int process(String line, StringBuilder output) throws Exception
{    Inlinks links = getInlinks(new Text(line));    if (links == null) {        output.append(" - no link information.");    } else {        Iterator<Inlink> it = links.iterator();        while (it.hasNext()) {            output.append(it.next().toString());        }    }    output.append("\n");    return 0;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int res = ToolRunner.run(NutchConfiguration.create(), new LinkDbReader(), args);    System.exit(res);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    if (args.length < 2) {        System.err.println("Usage: LinkDbReader <linkdb> (-dump <out_dir> [-regex <regex>]) | -url <url>");        System.err.println("\t-dump <out_dir>\tdump whole link db to a text file in <out_dir>");        System.err.println("\t\t-regex <regex>\trestrict to url's matching expression");        System.err.println("\t-url <url>\tprint information about <url> to System.out");        return -1;    }    int numConsumed = 0;    try {        for (int i = 1; i < args.length; i++) {            if (args[i].equals("-dump")) {                String regex = null;                for (int j = i + 1; j < args.length; j++) {                    if (args[i].equals("-regex")) {                        regex = args[++j];                    }                }                processDumpJob(args[0], args[i + 1], regex);                return 0;            } else if (args[i].equals("-url")) {                init(new Path(args[0]));                return processSingle(args[++i]);            } else if ((numConsumed = super.parseArgs(args, i)) > 0) {                init(new Path(args[0]));                i += numConsumed - 1;            } else {                System.err.println("Error: wrong argument " + args[1]);                return -1;            }        }    } catch (Exception e) {        LOG.error("LinkDbReader: " + StringUtils.stringifyException(e));        return -1;    }    if (numConsumed > 0) {                return super.run();    }    return 0;}
d59e009ee1aea60ecf867f201cab5f4c054d40ca11c2efea928d1290d8bf45d7
calculate
public byte[] calculate(Content content, Parse parse)
{    byte[] data = content.getContent();    if (data == null || (data.length == 0))        data = content.getUrl().getBytes();    return MD5Hash.digest(data).getDigest();}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    super.setConf(conf);    if (conf == null)        return;            defaultIncRate = conf.getFloat(SCHEDULE_INC_RATE, 0.2f);    defaultDecRate = conf.getFloat(SCHEDULE_DEC_RATE, 0.2f);        Reader mimeFile = conf.getConfResourceAsReader(conf.get(SCHEDULE_MIME_FILE, "adaptive-mimetypes.txt"));    try {        readMimeFile(mimeFile);    } catch (IOException e) {        LOG.error(org.apache.hadoop.util.StringUtils.stringifyException(e));    }}
319c7fad8a457ebb19672206c3ea49d47adb1e2fe5c1e1d279c4ce14d3c5cdec
setFetchSchedule
public CrawlDatum setFetchSchedule(Text url, CrawlDatum datum, long prevFetchTime, long prevModifiedTime, long fetchTime, long modifiedTime, int state)
{        INC_RATE = defaultIncRate;    DEC_RATE = defaultDecRate;        if (datum.getMetaData().containsKey(HttpHeaders.WRITABLE_CONTENT_TYPE)) {                String currentMime = MimeUtil.cleanMimeType(datum.getMetaData().get(HttpHeaders.WRITABLE_CONTENT_TYPE).toString());                if (mimeMap.containsKey(currentMime)) {                        INC_RATE = mimeMap.get(currentMime).inc;            DEC_RATE = mimeMap.get(currentMime).dec;        }    }    return super.setFetchSchedule(url, datum, prevFetchTime, prevModifiedTime, fetchTime, modifiedTime, state);}
1c39a893e30c8db04dd415bed68d482550c545ff8facad597edc9d8380e16465
readMimeFile
private void readMimeFile(Reader mimeFile) throws IOException
{        mimeMap = new HashMap<>();        BufferedReader reader = new BufferedReader(mimeFile);    String line = null;    String[] splits = null;        while ((line = reader.readLine()) != null) {                if (StringUtils.isNotBlank(line) && !line.startsWith("#")) {                        splits = line.split("\t");                        if (splits.length == 3) {                                mimeMap.put(StringUtils.lowerCase(splits[0]), new AdaptiveRate(Float.valueOf(splits[1]), Float.valueOf(splits[2])));            } else {                LOG.warn("Invalid configuration line in: " + line);            }        }    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    FetchSchedule fs = new MimeAdaptiveFetchSchedule();    fs.setConf(NutchConfiguration.create());        long curTime = 0;        long delta = 1000L * 3600L * 24L;            long update = 1000L * 3600L * 24L * 30L;    boolean changed = true;    long lastModified = 0;    int miss = 0;    int totalMiss = 0;    int maxMiss = 0;    int fetchCnt = 0;    int changeCnt = 0;        CrawlDatum p = new CrawlDatum(1, 3600 * 24 * 30, 1.0f);        org.apache.hadoop.io.MapWritable x = new org.apache.hadoop.io.MapWritable();    x.put(HttpHeaders.WRITABLE_CONTENT_TYPE, new Text("text/html; charset=utf-8"));    p.setMetaData(x);    p.setFetchTime(0);    LOG.info(p.toString());        for (int i = 0; i < 10000; i++) {        if (lastModified + update < curTime) {                                    changed = true;            changeCnt++;            lastModified = curTime;        }        LOG.info(i + ". " + changed + "\twill fetch at " + (p.getFetchTime() / delta) + "\tinterval " + (p.getFetchInterval() / SECONDS_PER_DAY) + " days" + "\t missed " + miss);        if (p.getFetchTime() <= curTime) {            fetchCnt++;            fs.setFetchSchedule(new Text("http://www.example.com"), p, p.getFetchTime(), p.getModifiedTime(), curTime, lastModified, changed ? FetchSchedule.STATUS_MODIFIED : FetchSchedule.STATUS_NOTMODIFIED);            LOG.info("\tfetched & adjusted: " + "\twill fetch at " + (p.getFetchTime() / delta) + "\tinterval " + (p.getFetchInterval() / SECONDS_PER_DAY) + " days");            if (!changed)                miss++;            if (miss > maxMiss)                maxMiss = miss;            changed = false;            totalMiss += miss;            miss = 0;        }        if (changed)            miss++;        curTime += delta;    }    LOG.info("Total missed: " + totalMiss + ", max miss: " + maxMiss);    LOG.info("Page changed " + changeCnt + " times, fetched " + fetchCnt + " times.");}
12d58cdb2dcb4fa247f23a7a0ea32331b57584601f744f79c334060704b40b03
getTypes
protected Class<? extends Writable>[] getTypes()
{    return CLASSES;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
364e26e3073e39bab4c99d28b2142fd070e086b7541d68a1ca46b17c51e26fdd
compare
public int compare(Object o1, Object o2)
{    return _compare(o1, o2);}
3d15d3a80f473781ed004dafb335e20c9341ded46360f1a71532f19434fd6cd5
_compare
public static int _compare(Object o1, Object o2)
{    if (o1 == null && o2 == null)        return 0;    if (o1 == null)        return -1;    if (o2 == null)        return 1;    if (!(o1 instanceof byte[]))        return -1;    if (!(o2 instanceof byte[]))        return 1;    byte[] data1 = (byte[]) o1;    byte[] data2 = (byte[]) o2;    return _compare(data1, 0, data1.length, data2, 0, data2.length);}
be20f2583a9f8e9411ac2d36eaae245b5cdb44404dbfe59090fae9593d99ae39
_compare
public static int _compare(byte[] data1, int s1, int l1, byte[] data2, int s2, int l2)
{    if (l2 > l1)        return -1;    if (l2 < l1)        return 1;    int res = 0;    for (int i = 0; i < l1; i++) {        res = (data1[s1 + i] - data2[s2 + i]);        if (res != 0)            return res;    }    return 0;}
0780ebb181f94d661c802f78af605ee75144ae9b284dd40d20dc4f70c0185810
getSignature
public static synchronized Signature getSignature(Configuration conf)
{    String clazz = conf.get("db.signature.class", MD5Signature.class.getName());    ObjectCache objectCache = ObjectCache.get(conf);    Signature impl = (Signature) objectCache.getObject(clazz);    if (impl == null) {        try {            if (LOG.isInfoEnabled()) {                LOG.info("Using Signature impl: " + clazz);            }            Class<?> implClass = Class.forName(clazz);            impl = (Signature) implClass.getConstructor().newInstance();            impl.setConf(conf);            objectCache.setObject(clazz, impl);        } catch (Exception e) {            throw new RuntimeException("Couldn't create " + clazz, e);        }    }    return impl;}
d59e009ee1aea60ecf867f201cab5f4c054d40ca11c2efea928d1290d8bf45d7
calculate
public byte[] calculate(Content content, Parse parse)
{    String text = parse.getText();    if (text == null || text.length() == 0) {        return fallback.calculate(content, parse);    }    return MD5Hash.digest(text).getDigest();}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    super.setConf(conf);    MIN_TOKEN_LEN = conf.getInt("db.signature.text_profile.min_token_len", 2);    QUANT_RATE = conf.getFloat("db.signature.text_profile.quant_rate", 0.01f);    secondaryLexicographicSorting = conf.getBoolean("db.signature.text_profile.sec_sort_lex", true);}
d59e009ee1aea60ecf867f201cab5f4c054d40ca11c2efea928d1290d8bf45d7
calculate
public byte[] calculate(Content content, Parse parse)
{    HashMap<String, Token> tokens = new HashMap<>();    String text = null;    if (parse != null)        text = parse.getText();    if (text == null || text.length() == 0)        return fallback.calculate(content, parse);    StringBuffer curToken = new StringBuffer();    int maxFreq = 0;    for (int i = 0; i < text.length(); i++) {        char c = text.charAt(i);        if (Character.isLetterOrDigit(c)) {            curToken.append(Character.toLowerCase(c));        } else {            if (curToken.length() > 0) {                if (curToken.length() > MIN_TOKEN_LEN) {                                        String s = curToken.toString();                    Token tok = tokens.get(s);                    if (tok == null) {                        tok = new Token(0, s);                        tokens.put(s, tok);                    }                    tok.cnt++;                    if (tok.cnt > maxFreq)                        maxFreq = tok.cnt;                }                curToken.setLength(0);            }        }    }        if (curToken.length() > MIN_TOKEN_LEN) {                String s = curToken.toString();        Token tok = tokens.get(s);        if (tok == null) {            tok = new Token(0, s);            tokens.put(s, tok);        }        tok.cnt++;        if (tok.cnt > maxFreq)            maxFreq = tok.cnt;    }    Iterator<Token> it = tokens.values().iterator();    ArrayList<Token> profile = new ArrayList<>();        int QUANT = Math.round(maxFreq * QUANT_RATE);    if (QUANT < 2) {        if (maxFreq > 1)            QUANT = 2;        else            QUANT = 1;    }    while (it.hasNext()) {        Token t = it.next();                t.cnt = (t.cnt / QUANT) * QUANT;                if (t.cnt < QUANT) {            continue;        }        profile.add(t);    }    Collections.sort(profile, new TokenComparator());    StringBuffer newText = new StringBuffer();    it = profile.iterator();    while (it.hasNext()) {        Token t = it.next();        if (newText.length() > 0)            newText.append("\n");        newText.append(t.toString());    }    return MD5Hash.digest(newText.toString()).getDigest();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return val + " " + cnt;}
e315bf1cfb41d8e2597ec50550d3275994608ced6dda1cea0ddec3767543ec54
compare
public int compare(Token t1, Token t2)
{    int diffCnt = t2.cnt - t1.cnt;    if (diffCnt == 0 && secondaryLexicographicSorting) {        return t1.val.compareTo(t2.val);    }    return diffCnt;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    TextProfileSignature sig = new TextProfileSignature();    sig.setConf(NutchConfiguration.create());    HashMap<String, byte[]> res = new HashMap<>();    File[] files = new File(args[0]).listFiles();    for (int i = 0; i < files.length; i++) {        FileInputStream fis = new FileInputStream(files[i]);        BufferedReader br = new BufferedReader(new InputStreamReader(fis, "UTF-8"));        StringBuffer text = new StringBuffer();        String line = null;        while ((line = br.readLine()) != null) {            if (text.length() > 0)                text.append("\n");            text.append(line);        }        br.close();        byte[] signature = sig.calculate(null, new ParseImpl(text.toString(), null));        res.put(files[i].toString(), signature);    }    Iterator<String> it = res.keySet().iterator();    while (it.hasNext()) {        String name = it.next();        byte[] signature = res.get(name);        System.out.println(name + "\t" + StringUtil.toHexString(signature));    }}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    seed = conf.getInt("partition.url.seed", 0);    mode = conf.get(PARTITION_MODE_KEY, PARTITION_MODE_HOST);        if (!mode.equals(PARTITION_MODE_IP) && !mode.equals(PARTITION_MODE_DOMAIN) && !mode.equals(PARTITION_MODE_HOST)) {        LOG.error("Unknown partition mode : " + mode + " - forcing to byHost");        mode = PARTITION_MODE_HOST;    }    normalizers = new URLNormalizers(conf, URLNormalizers.SCOPE_PARTITION);}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{}
ae372067a40179a33ee7be0ad3ac3e04912aa43f9aa0ff2989f33133d72037f4
getPartition
public int getPartition(Text key, Writable value, int numReduceTasks)
{    String urlString = key.toString();    URL url = null;    int hashCode = 0;    try {        urlString = normalizers.normalize(urlString, URLNormalizers.SCOPE_PARTITION);        url = new URL(urlString);    } catch (MalformedURLException e) {        LOG.warn("Malformed URL: '" + urlString + "'");    }    if (url == null) {                hashCode = urlString.hashCode();    } else if (mode.equals(PARTITION_MODE_HOST)) {        hashCode = url.getHost().hashCode();    } else if (mode.equals(PARTITION_MODE_DOMAIN)) {        hashCode = URLUtil.getDomainName(url).hashCode();    } else if (mode.equals(PARTITION_MODE_IP)) {        try {            InetAddress address = InetAddress.getByName(url.getHost());            hashCode = address.getHostAddress().hashCode();        } catch (UnknownHostException e) {            Generator.LOG.info("Couldn't find IP for host: " + url.getHost());        }    }        hashCode ^= seed;    return (hashCode & Integer.MAX_VALUE) % numReduceTasks;}
57170083ee9b9d1dcc0b44189a0c14b54d9ba39714e3a193ddba0b1fb9abc029
getInstance
public static ExchangeConfig getInstance(Element element)
{    String id = element.getAttribute("id");    String clazz = element.getAttribute("class");        NodeList writerList = element.getElementsByTagName("writer");    String[] writers = new String[writerList.getLength()];    for (int i = 0; i < writerList.getLength(); i++) {        writers[i] = ((Element) writerList.item(i)).getAttribute("id");    }        NodeList paramList = element.getElementsByTagName("param");    Map<String, String> paramsMap = new HashMap<>();    for (int i = 0; i < paramList.getLength(); i++) {        Element param = (Element) paramList.item(i);        paramsMap.put(param.getAttribute("name"), param.getAttribute("value"));    }    return new ExchangeConfig(id, clazz, writers, paramsMap);}
09e8f13a9a603d31d64bb498b77d15572483824d843d0e82a570643192f62186
getId
public String getId()
{    return id;}
45481ede6a739a5a3dec0877747e98a0da505cff1aa530eced1e5f4258af7d55
getClazz
public String getClazz()
{    return clazz;}
fcef9dc6a7f8eb2ade29a97a3e9c5233e561884f6fdb10e842c96ff9d2270b2a
getWritersIDs
 String[] getWritersIDs()
{    return writersIDs;}
9a914969663ac068ea3ae4aab261451e2d015d39f830a40321a10efa18ba5a4f
getParameters
public Map<String, String> getParameters()
{    return parameters;}
cb2cc98a69710834995fa923b65175004ed76e43b1413813e278fe1a27f579c6
areAvailableExchanges
public boolean areAvailableExchanges()
{    return availableExchanges;}
661212221ce61ec2a5efd55216524d5f0e878bbaef5149063a9fb6f9016b4e04
loadConfigurations
private ExchangeConfig[] loadConfigurations(Configuration conf)
{    String filename = conf.get("exchanges.exchanges.file", "exchanges.xml");    InputSource inputSource = new InputSource(conf.getConfResourceAsInputStream(filename));    final List<ExchangeConfig> configList = new LinkedList<>();    try {        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();        DocumentBuilder builder = factory.newDocumentBuilder();        Element rootElement = builder.parse(inputSource).getDocumentElement();        NodeList exchangeList = rootElement.getElementsByTagName("exchange");        for (int i = 0; i < exchangeList.getLength(); i++) {            Element element = (Element) exchangeList.item(i);            ExchangeConfig exchangeConfig = ExchangeConfig.getInstance(element);            if ("default".equals(exchangeConfig.getClazz())) {                this.defaultExchangeConfig = exchangeConfig;                continue;            }            configList.add(exchangeConfig);        }    } catch (SAXException | IOException | ParserConfigurationException e) {        LOG.error(e.toString());    }    return configList.toArray(new ExchangeConfig[0]);}
20fa09f58ec45a3964c698b8ae376ba3a79fb28d33c088c2a56b5d9e9be1edee
open
public void open()
{    exchanges.forEach((id, value) -> value.exchange.open(value.config.getParameters()));}
a976bd11d3bb2468244e547cbe550fee1d3f6638976a3fd7d67f3d5c78f9e26e
indexWriters
public String[] indexWriters(final NutchDocument nutchDocument)
{    final Set<String> writersIDs = new HashSet<>();    exchanges.forEach((id, value) -> {        if (value.exchange.match(nutchDocument)) {            writersIDs.addAll(Arrays.asList(value.config.getWritersIDs()));        }    });        if (defaultExchangeConfig != null && writersIDs.isEmpty()) {        return defaultExchangeConfig.getWritersIDs();    }    return writersIDs.toArray(new String[0]);}
d911020d8855b2bdeebebd4cb729ddd2566052d5a678c401e6b323c59f45734d
getSplits
public List<InputSplit> getSplits(JobContext job) throws IOException
{    List<FileStatus> files = listStatus(job);    List<InputSplit> splits = new ArrayList<>();    for (FileStatus cur : files) {        splits.add(new FileSplit(cur.getPath(), 0, cur.getLen(), (String[]) null));    }    return splits;}
b2cdb513d7667a9001ee46b7d5738b76b8af3a80085e39ef1fb65dc62345a21e
isParsing
public static boolean isParsing(Configuration conf)
{    return conf.getBoolean("fetcher.parse", true);}
3f5a261c54edfc9e08f75bf4534994f218ac4f49c240ad013975ed6db082b6c3
isStoringContent
public static boolean isStoringContent(Configuration conf)
{    return conf.getBoolean("fetcher.store.content", true);}
fb79e778492a9e9bfdb22412039f8b2a02eb14acf345afa709c0060badc14210
getActiveThreads
private AtomicInteger getActiveThreads()
{    return activeThreads;}
26ebf73f6dbbde8b70b7c93d8117913afffa7d7ea2334f0b8e512c4c56538e7a
reportStatus
private void reportStatus(Context context, FetchItemQueues fetchQueues, int pagesLastSec, int bytesLastSec) throws IOException
{    StringBuilder status = new StringBuilder();    Long elapsed = Long.valueOf((System.currentTimeMillis() - start) / 1000);    float avgPagesSec = (float) pages.get() / elapsed.floatValue();    long avgBytesSec = (bytes.get() / 128l) / elapsed.longValue();    status.append(activeThreads).append(" threads (").append(spinWaiting.get()).append(" waiting), ");    status.append(fetchQueues.getQueueCount()).append(" queues, ");    status.append(fetchQueues.getTotalSize()).append(" URLs queued, ");    status.append(pages).append(" pages, ").append(errors).append(" errors, ");    status.append(String.format("%.2f", avgPagesSec)).append(" pages/s (");    status.append(pagesLastSec).append(" last sec), ");    status.append(avgBytesSec).append(" kbits/s (").append((bytesLastSec / 128)).append(" last sec)");    context.setStatus(status.toString());}
7ce364559169b6584b8d7e22affb4c51bfb4744fada2d867c12bd2914538abc0
setup
public void setup(Mapper<Text, CrawlDatum, Text, NutchWritable>.Context context)
{    Configuration conf = context.getConfiguration();    segmentName = conf.get(Nutch.SEGMENT_NAME_KEY);    storingContent = isStoringContent(conf);    parsing = isParsing(conf);}
56f1dbf6b56fd39054f5a15ad41d89da7cd7367d3517d3e697d35def48bfca36
run
public void run(Context innerContext) throws IOException
{    setup(innerContext);    Configuration conf = innerContext.getConfiguration();    LinkedList<FetcherThread> fetcherThreads = new LinkedList<>();    FetchItemQueues fetchQueues = new FetchItemQueues(conf);    QueueFeeder feeder;    int threadCount = conf.getInt("fetcher.threads.fetch", 10);    if (LOG.isInfoEnabled()) {        LOG.info("Fetcher: threads: {}", threadCount);    }    int timeoutDivisor = conf.getInt("fetcher.threads.timeout.divisor", 2);    if (LOG.isInfoEnabled()) {        LOG.info("Fetcher: time-out divisor: {}", timeoutDivisor);    }    int queueDepthMuliplier = conf.getInt("fetcher.queue.depth.multiplier", 50);    feeder = new QueueFeeder(innerContext, fetchQueues, threadCount * queueDepthMuliplier);            long timelimit = conf.getLong("fetcher.timelimit", -1);    if (timelimit != -1)        feeder.setTimeLimit(timelimit);    feeder.start();    for (int i = 0; i < threadCount; i++) {                FetcherThread t = new FetcherThread(conf, getActiveThreads(), fetchQueues, feeder, spinWaiting, lastRequestStart, innerContext, errors, segmentName, parsing, storingContent, pages, bytes);        fetcherThreads.add(t);        t.start();    }        long timeout = conf.getInt("mapreduce.task.timeout", 10 * 60 * 1000) / timeoutDivisor;            int pagesLastSec;    int bytesLastSec;    int throughputThresholdNumRetries = 0;    int throughputThresholdPages = conf.getInt("fetcher.throughput.threshold.pages", -1);    if (LOG.isInfoEnabled()) {        LOG.info("Fetcher: throughput threshold: {}", throughputThresholdPages);    }    int throughputThresholdMaxRetries = conf.getInt("fetcher.throughput.threshold.retries", 5);    if (LOG.isInfoEnabled()) {        LOG.info("Fetcher: throughput threshold retries: {}", throughputThresholdMaxRetries);    }    long throughputThresholdTimeLimit = conf.getLong("fetcher.throughput.threshold.check.after", -1);    int targetBandwidth = conf.getInt("fetcher.bandwidth.target", -1) * 1000;    int maxNumThreads = conf.getInt("fetcher.maxNum.threads", threadCount);    if (maxNumThreads < threadCount) {        LOG.info("fetcher.maxNum.threads can't be < than {} : using {} instead", threadCount, threadCount);        maxNumThreads = threadCount;    }    int bandwidthTargetCheckEveryNSecs = conf.getInt("fetcher.bandwidth.target.check.everyNSecs", 30);    if (bandwidthTargetCheckEveryNSecs < 1) {        LOG.info("fetcher.bandwidth.target.check.everyNSecs can't be < to 1 : using 1 instead");        bandwidthTargetCheckEveryNSecs = 1;    }    int maxThreadsPerQueue = conf.getInt("fetcher.threads.per.queue", 1);    int bandwidthTargetCheckCounter = 0;    long bytesAtLastBWTCheck = 0l;    do {                pagesLastSec = pages.get();        bytesLastSec = (int) bytes.get();        try {            Thread.sleep(1000);        } catch (InterruptedException e) {        }        pagesLastSec = pages.get() - pagesLastSec;        bytesLastSec = (int) bytes.get() - bytesLastSec;        innerContext.getCounter("FetcherStatus", "bytes_downloaded").increment(bytesLastSec);        reportStatus(innerContext, fetchQueues, pagesLastSec, bytesLastSec);        LOG.info("-activeThreads=" + activeThreads + ", spinWaiting=" + spinWaiting.get() + ", fetchQueues.totalSize=" + fetchQueues.getTotalSize() + ", fetchQueues.getQueueCount=" + fetchQueues.getQueueCount());        if (!feeder.isAlive() && fetchQueues.getTotalSize() < 5) {            fetchQueues.dump();        }                if (throughputThresholdTimeLimit < System.currentTimeMillis() && throughputThresholdPages != -1) {                        if (pagesLastSec < throughputThresholdPages) {                throughputThresholdNumRetries++;                LOG.warn("{}: dropping below configured threshold of {} pages per second", Integer.toString(throughputThresholdNumRetries), Integer.toString(throughputThresholdPages));                                if (throughputThresholdNumRetries == throughputThresholdMaxRetries) {                    LOG.warn("Dropped below threshold too many times, killing!");                                        throughputThresholdPages = -1;                                                            int hitByThrougputThreshold = fetchQueues.emptyQueues();                    if (hitByThrougputThreshold != 0)                        innerContext.getCounter("FetcherStatus", "hitByThrougputThreshold").increment(hitByThrougputThreshold);                }            }        }                if (targetBandwidth > 0) {            if (bandwidthTargetCheckCounter < bandwidthTargetCheckEveryNSecs)                bandwidthTargetCheckCounter++;            else if (bandwidthTargetCheckCounter == bandwidthTargetCheckEveryNSecs) {                long bpsSinceLastCheck = ((bytes.get() - bytesAtLastBWTCheck) * 8) / bandwidthTargetCheckEveryNSecs;                bytesAtLastBWTCheck = bytes.get();                bandwidthTargetCheckCounter = 0;                int averageBdwPerThread = 0;                if (activeThreads.get() > 0)                    averageBdwPerThread = Math.round(bpsSinceLastCheck / activeThreads.get());                LOG.info("averageBdwPerThread : {} kbps", (averageBdwPerThread / 1000));                if (bpsSinceLastCheck < targetBandwidth && averageBdwPerThread > 0) {                    if ((fetchQueues.getQueueCount() * maxThreadsPerQueue) > activeThreads.get()) {                        long remainingBdw = targetBandwidth - bpsSinceLastCheck;                        int additionalThreads = Math.round(remainingBdw / averageBdwPerThread);                        int availableThreads = maxNumThreads - activeThreads.get();                                                                        additionalThreads = (availableThreads < additionalThreads ? availableThreads : additionalThreads);                        LOG.info("Has space for more threads ({} vs {} kbps) \t=> adding {} new threads", new Object[] { (bpsSinceLastCheck / 1000), (targetBandwidth / 1000), additionalThreads });                                                for (int i = 0; i < additionalThreads; i++) {                            FetcherThread thread = new FetcherThread(conf, getActiveThreads(), fetchQueues, feeder, spinWaiting, lastRequestStart, innerContext, errors, segmentName, parsing, storingContent, pages, bytes);                            fetcherThreads.add(thread);                            thread.start();                        }                    }                } else if (bpsSinceLastCheck > targetBandwidth && averageBdwPerThread > 0) {                                                            long excessBdw = bpsSinceLastCheck - targetBandwidth;                    int excessThreads = Math.round(excessBdw / averageBdwPerThread);                    LOG.info("Exceeding target bandwidth ({} vs {} kbps). \t=> excessThreads = {}", new Object[] { bpsSinceLastCheck / 1000, (targetBandwidth / 1000), excessThreads });                                        if (excessThreads >= fetcherThreads.size())                        excessThreads = 0;                                        for (int i = 0; i < excessThreads; i++) {                        FetcherThread thread = fetcherThreads.removeLast();                        thread.setHalted(true);                    }                }            }        }                if (!feeder.isAlive()) {            int hitByTimeLimit = fetchQueues.checkTimelimit();            if (hitByTimeLimit != 0)                innerContext.getCounter("FetcherStatus", "hitByTimeLimit").increment(hitByTimeLimit);        }                if ((System.currentTimeMillis() - lastRequestStart.get()) > timeout) {            if (LOG.isWarnEnabled()) {                LOG.warn("Aborting with {} hung threads.", activeThreads);                for (int i = 0; i < fetcherThreads.size(); i++) {                    FetcherThread thread = fetcherThreads.get(i);                    if (thread.isAlive()) {                        LOG.warn("Thread #{} hung while processing {}", i, thread.getReprUrl());                        if (LOG.isDebugEnabled()) {                            StackTraceElement[] stack = thread.getStackTrace();                            StringBuilder sb = new StringBuilder();                            sb.append("Stack of thread #").append(i).append(":\n");                            for (StackTraceElement s : stack) {                                sb.append(s.toString()).append('\n');                            }                            LOG.debug(sb.toString());                        }                    }                }            }            return;        }    } while (activeThreads.get() > 0);    LOG.info("-activeThreads={}", activeThreads);}
832946efc70069e78887c918891fcb65da8790409cd6bdc76f82a406c2c51402
fetch
public void fetch(Path segment, int threads) throws IOException, InterruptedException, ClassNotFoundException
{    checkConfiguration();    long start = System.currentTimeMillis();    if (LOG.isInfoEnabled()) {        LOG.info("Fetcher: starting at {}", TimingUtil.logDateMillis(start));        LOG.info("Fetcher: segment: {}", segment);    }                long timelimit = getConf().getLong("fetcher.timelimit.mins", -1);    if (timelimit != -1) {        timelimit = System.currentTimeMillis() + (timelimit * 60 * 1000);        LOG.info("Fetcher Timelimit set for : {}  ({})", timelimit, TimingUtil.logDateMillis(timelimit));        getConf().setLong("fetcher.timelimit", timelimit);    }            timelimit = getConf().getLong("fetcher.throughput.threshold.check.after", 10);    timelimit = System.currentTimeMillis() + (timelimit * 60 * 1000);    getConf().setLong("fetcher.throughput.threshold.check.after", timelimit);    int maxOutlinkDepth = getConf().getInt("fetcher.follow.outlinks.depth", -1);    if (maxOutlinkDepth > 0) {        LOG.info("Fetcher: following outlinks up to depth: {}", Integer.toString(maxOutlinkDepth));        int maxOutlinkDepthNumLinks = getConf().getInt("fetcher.follow.outlinks.num.links", 4);        int outlinksDepthDivisor = getConf().getInt("fetcher.follow.outlinks.depth.divisor", 2);        int totalOutlinksToFollow = 0;        for (int i = 0; i < maxOutlinkDepth; i++) {            totalOutlinksToFollow += (int) Math.floor(outlinksDepthDivisor / (i + 1) * maxOutlinkDepthNumLinks);        }        LOG.info("Fetcher: maximum outlinks to follow: {}", Integer.toString(totalOutlinksToFollow));    }    Job job = NutchJob.getInstance(getConf());    job.setJobName("FetchData");    Configuration conf = job.getConfiguration();    conf.setInt("fetcher.threads.fetch", threads);    conf.set(Nutch.SEGMENT_NAME_KEY, segment.getName());        conf.set("mapreduce.map.speculative", "false");    FileInputFormat.addInputPath(job, new Path(segment, CrawlDatum.GENERATE_DIR_NAME));    job.setInputFormatClass(InputFormat.class);    job.setJarByClass(Fetcher.class);    job.setMapperClass(Fetcher.FetcherRun.class);    FileOutputFormat.setOutputPath(job, segment);    job.setOutputFormatClass(FetcherOutputFormat.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(NutchWritable.class);    try {        boolean success = job.waitForCompletion(true);        if (!success) {            String message = "Fetcher job did not succeed, job status:" + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);            throw new RuntimeException(message);        }    } catch (InterruptedException | ClassNotFoundException e) {        LOG.error(StringUtils.stringifyException(e));        throw e;    }    long end = System.currentTimeMillis();    LOG.info("Fetcher: finished at {}, elapsed: {}", TimingUtil.logDateMillis(end), TimingUtil.elapsedTime(start, end));}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int res = ToolRunner.run(NutchConfiguration.create(), new Fetcher(), args);    System.exit(res);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    String usage = "Usage: Fetcher <segment> [-threads n]";    if (args.length < 1) {        System.err.println(usage);        return -1;    }    Path segment = new Path(args[0]);    int threads = getConf().getInt("fetcher.threads.fetch", 10);    for (int i = 1; i < args.length; i++) {                if (args[i].equals("-threads")) {                        threads = Integer.parseInt(args[++i]);        }    }    getConf().setInt("fetcher.threads.fetch", threads);    try {        fetch(segment, threads);        return 0;    } catch (Exception e) {        LOG.error("Fetcher: {}", StringUtils.stringifyException(e));        return -1;    }}
162883ed48ea9036c67b87bbaf5d02146139976c0769a78781390bcb2e7a78f2
checkConfiguration
private void checkConfiguration()
{        String agentName = getConf().get("http.agent.name");    if (agentName == null || agentName.trim().length() == 0) {        String message = "Fetcher: No agents listed in 'http.agent.name'" + " property.";        if (LOG.isErrorEnabled()) {            LOG.error(message);        }        throw new IllegalArgumentException(message);    }}
084523121ab64bd9486b37875e438171d2b2467ace02bce8523551b0ce84ace4
run
public Map<String, Object> run(Map<String, Object> args, String crawlId) throws Exception
{    Map<String, Object> results = new HashMap<>();    Path segment = null;    if (args.containsKey(Nutch.ARG_SEGMENTS)) {        Object seg = args.get(Nutch.ARG_SEGMENTS);        if (seg instanceof Path) {            segment = (Path) seg;        } else if (seg instanceof String) {            segment = new Path(seg.toString());        } else if (seg instanceof ArrayList) {            String[] segmentsArray = (String[]) seg;            segment = new Path(segmentsArray[0].toString());            if (segmentsArray.length > 1) {                LOG.warn("Only the first segment of segments array is used.");            }        }    } else {        String segmentDir = crawlId + "/segments";        File segmentsDir = new File(segmentDir);        File[] segmentsList = segmentsDir.listFiles();        Arrays.sort(segmentsList, (f1, f2) -> {            if (f1.lastModified() > f2.lastModified())                return -1;            else                return 0;        });        segment = new Path(segmentsList[0].getPath());    }    int threads = getConf().getInt("fetcher.threads.fetch", 10);        if (args.containsKey("threads")) {                threads = Integer.parseInt((String) args.get("threads"));    }    getConf().setInt("fetcher.threads.fetch", threads);    try {        fetch(segment, threads);        results.put(Nutch.VAL_RESULT, Integer.toString(0));        return results;    } catch (Exception e) {        LOG.error("Fetcher: {}", StringUtils.stringifyException(e));        results.put(Nutch.VAL_RESULT, Integer.toString(-1));        return results;    }}
b735e7eb1a604a408c3d594812ba124315d945bcb7e3a4f393418af2971f06ba
checkOutputSpecs
public void checkOutputSpecs(JobContext job) throws IOException
{    Configuration conf = job.getConfiguration();    Path out = FileOutputFormat.getOutputPath(job);    if ((out == null) && (job.getNumReduceTasks() != 0)) {        throw new InvalidJobConfException("Output directory not set in conf.");    }    FileSystem fs = out.getFileSystem(conf);    if (fs.exists(new Path(out, CrawlDatum.FETCH_DIR_NAME))) {        throw new IOException("Segment already fetched!");    }}
1e9ba043b56989fdea846931e14ea76ec6d139ad32f9aacb327bd83d4ad39b09
getRecordWriter
public RecordWriter<Text, NutchWritable> getRecordWriter(TaskAttemptContext context) throws IOException
{    Configuration conf = context.getConfiguration();    String name = getUniqueFile(context, "part", "");    Path out = FileOutputFormat.getOutputPath(context);    final Path fetch = new Path(new Path(out, CrawlDatum.FETCH_DIR_NAME), name);    final Path content = new Path(new Path(out, Content.DIR_NAME), name);    final CompressionType compType = SequenceFileOutputFormat.getOutputCompressionType(context);    Option fKeyClassOpt = MapFile.Writer.keyClass(Text.class);    org.apache.hadoop.io.SequenceFile.Writer.Option fValClassOpt = SequenceFile.Writer.valueClass(CrawlDatum.class);    org.apache.hadoop.io.SequenceFile.Writer.Option fProgressOpt = SequenceFile.Writer.progressable((Progressable) context);    org.apache.hadoop.io.SequenceFile.Writer.Option fCompOpt = SequenceFile.Writer.compression(compType);    final MapFile.Writer fetchOut = new MapFile.Writer(conf, fetch, fKeyClassOpt, fValClassOpt, fCompOpt, fProgressOpt);    return new RecordWriter<Text, NutchWritable>() {        private MapFile.Writer contentOut;        private RecordWriter<Text, Parse> parseOut;        {            if (Fetcher.isStoringContent(conf)) {                Option cKeyClassOpt = MapFile.Writer.keyClass(Text.class);                org.apache.hadoop.io.SequenceFile.Writer.Option cValClassOpt = SequenceFile.Writer.valueClass(Content.class);                org.apache.hadoop.io.SequenceFile.Writer.Option cProgressOpt = SequenceFile.Writer.progressable((Progressable) context);                org.apache.hadoop.io.SequenceFile.Writer.Option cCompOpt = SequenceFile.Writer.compression(compType);                contentOut = new MapFile.Writer(conf, content, cKeyClassOpt, cValClassOpt, cCompOpt, cProgressOpt);            }            if (Fetcher.isParsing(conf)) {                parseOut = new ParseOutputFormat().getRecordWriter(context);            }        }        public void write(Text key, NutchWritable value) throws IOException, InterruptedException {            Writable w = value.get();            if (w instanceof CrawlDatum)                fetchOut.append(key, w);            else if (w instanceof Content && contentOut != null)                contentOut.append(key, w);            else if (w instanceof Parse && parseOut != null)                parseOut.write(key, (Parse) w);        }        public void close(TaskAttemptContext context) throws IOException, InterruptedException {            fetchOut.close();            if (contentOut != null) {                contentOut.close();            }            if (parseOut != null) {                parseOut.close(context);            }        }    };}
d7607c2d5bbbbb379cd6645a751df8f8473866371f43dfcd6ea182de9a1135f1
write
public void write(Text key, NutchWritable value) throws IOException, InterruptedException
{    Writable w = value.get();    if (w instanceof CrawlDatum)        fetchOut.append(key, w);    else if (w instanceof Content && contentOut != null)        contentOut.append(key, w);    else if (w instanceof Parse && parseOut != null)        parseOut.write(key, (Parse) w);}
b8b34e2eb30c67c8979d27754340818dab91e35c6af795f1b114e238b3f0efd0
close
public void close(TaskAttemptContext context) throws IOException, InterruptedException
{    fetchOut.close();    if (contentOut != null) {        contentOut.close();    }    if (parseOut != null) {        parseOut.close(context);    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{        activeThreads.incrementAndGet();    FetchItem fit = null;    try {                if (parsing && NutchServer.getInstance().isRunning())            reportToNutchServer = true;        while (true) {                        if (reportToNutchServer)                this.fetchNode = new FetchNode();            else                this.fetchNode = null;                        if (isHalted()) {                LOG.debug("{} set to halted", getName());                fit = null;                return;            }            fit = ((FetchItemQueues) fetchQueues).getFetchItem();            if (fit == null) {                if (feeder.isAlive() || ((FetchItemQueues) fetchQueues).getTotalSize() > 0) {                    LOG.debug("{} spin-waiting ...", getName());                                        ((AtomicInteger) spinWaiting).incrementAndGet();                    try {                        Thread.sleep(500);                    } catch (Exception e) {                    }                    ((AtomicInteger) spinWaiting).decrementAndGet();                    continue;                } else {                                        LOG.info("{} {} has no more work available", getName(), Thread.currentThread().getId());                    return;                }            }            lastRequestStart.set(System.currentTimeMillis());            Text reprUrlWritable = (Text) fit.datum.getMetaData().get(Nutch.WRITABLE_REPR_URL_KEY);            if (reprUrlWritable == null) {                setReprUrl(fit.url.toString());            } else {                setReprUrl(reprUrlWritable.toString());            }            try {                                redirecting = false;                redirectCount = 0;                                if (activatePublisher) {                    FetcherThreadEvent startEvent = new FetcherThreadEvent(PublishEventType.START, fit.getUrl().toString());                    publisher.publish(startEvent, conf);                }                do {                    if (LOG.isInfoEnabled()) {                        LOG.info("{} {} fetching {} (queue crawl delay={}ms)", getName(), Thread.currentThread().getId(), fit.url, ((FetchItemQueues) fetchQueues).getFetchItemQueue(fit.queueID).crawlDelay);                    }                    if (LOG.isDebugEnabled()) {                        LOG.debug("redirectCount={}", redirectCount);                    }                    redirecting = false;                    Protocol protocol = this.protocolFactory.getProtocol(fit.u);                    BaseRobotRules rules = protocol.getRobotRules(fit.url, fit.datum, robotsTxtContent);                    if (robotsTxtContent != null) {                        outputRobotsTxt(robotsTxtContent);                        robotsTxtContent.clear();                    }                    if (!rules.isAllowed(fit.url.toString())) {                                                ((FetchItemQueues) fetchQueues).finishFetchItem(fit, true);                        LOG.info("Denied by robots.txt: {}", fit.url);                        output(fit.url, fit.datum, null, ProtocolStatus.STATUS_ROBOTS_DENIED, CrawlDatum.STATUS_FETCH_GONE);                        context.getCounter("FetcherStatus", "robots_denied").increment(1);                        continue;                    }                    if (rules.getCrawlDelay() > 0) {                        if (rules.getCrawlDelay() > maxCrawlDelay && maxCrawlDelay >= 0) {                                                        ((FetchItemQueues) fetchQueues).finishFetchItem(fit, true);                            LOG.info("Crawl-Delay for {} too long ({}), skipping", fit.url, rules.getCrawlDelay());                            output(fit.url, fit.datum, null, ProtocolStatus.STATUS_ROBOTS_DENIED, CrawlDatum.STATUS_FETCH_GONE);                            context.getCounter("FetcherStatus", "robots_denied_maxcrawldelay").increment(1);                            continue;                        } else {                            FetchItemQueue fiq = ((FetchItemQueues) fetchQueues).getFetchItemQueue(fit.queueID);                            fiq.crawlDelay = rules.getCrawlDelay();                            if (LOG.isDebugEnabled()) {                                LOG.debug("Crawl delay for queue: " + fit.queueID + " is set to " + fiq.crawlDelay + " as per robots.txt. url: " + fit.url);                            }                        }                    }                    ProtocolOutput output = protocol.getProtocolOutput(fit.url, fit.datum);                    ProtocolStatus status = output.getStatus();                    Content content = output.getContent();                    ParseStatus pstatus = null;                                        ((FetchItemQueues) fetchQueues).finishFetchItem(fit);                                        if (fetchNode != null) {                        fetchNode.setStatus(status.getCode());                        fetchNode.setFetchTime(System.currentTimeMillis());                        fetchNode.setUrl(fit.url);                    }                                        if (activatePublisher) {                        FetcherThreadEvent endEvent = new FetcherThreadEvent(PublishEventType.END, fit.getUrl().toString());                        endEvent.addEventData("status", status.getName());                        publisher.publish(endEvent, conf);                    }                    context.getCounter("FetcherStatus", status.getName()).increment(1);                    switch(status.getCode()) {                        case ProtocolStatus.WOULDBLOCK:                                                        ((FetchItemQueues) fetchQueues).addFetchItem(fit);                            break;                        case                         ProtocolStatus.SUCCESS:                            pstatus = output(fit.url, fit.datum, content, status, CrawlDatum.STATUS_FETCH_SUCCESS, fit.outlinkDepth);                            updateStatus(content.getContent().length);                            if (pstatus != null && pstatus.isSuccess() && pstatus.getMinorCode() == ParseStatus.SUCCESS_REDIRECT) {                                String newUrl = pstatus.getMessage();                                int refreshTime = Integer.valueOf(pstatus.getArgs()[1]);                                Text redirUrl = handleRedirect(fit, newUrl, refreshTime < Fetcher.PERM_REFRESH_TIME, Fetcher.CONTENT_REDIR);                                if (redirUrl != null) {                                    fit = queueRedirect(redirUrl, fit);                                }                            }                            break;                                                case ProtocolStatus.MOVED:                        case ProtocolStatus.TEMP_MOVED:                            int code;                            boolean temp;                            if (status.getCode() == ProtocolStatus.MOVED) {                                code = CrawlDatum.STATUS_FETCH_REDIR_PERM;                                temp = false;                            } else {                                code = CrawlDatum.STATUS_FETCH_REDIR_TEMP;                                temp = true;                            }                            output(fit.url, fit.datum, content, status, code);                            String newUrl = status.getMessage();                            Text redirUrl = handleRedirect(fit, newUrl, temp, Fetcher.PROTOCOL_REDIR);                            if (redirUrl != null) {                                fit = queueRedirect(redirUrl, fit);                            } else {                                                                redirecting = false;                            }                            break;                        case ProtocolStatus.EXCEPTION:                            logError(fit.url, status.getMessage());                            int killedURLs = ((FetchItemQueues) fetchQueues).checkExceptionThreshold(fit.getQueueID());                            if (killedURLs != 0)                                context.getCounter("FetcherStatus", "AboveExceptionThresholdInQueue").increment(killedURLs);                                                case ProtocolStatus.RETRY:                        case ProtocolStatus.BLOCKED:                            output(fit.url, fit.datum, null, status, CrawlDatum.STATUS_FETCH_RETRY);                            break;                                                case ProtocolStatus.GONE:                        case ProtocolStatus.NOTFOUND:                        case ProtocolStatus.ACCESS_DENIED:                        case ProtocolStatus.ROBOTS_DENIED:                            output(fit.url, fit.datum, null, status, CrawlDatum.STATUS_FETCH_GONE);                            break;                        case ProtocolStatus.NOTMODIFIED:                            output(fit.url, fit.datum, null, status, CrawlDatum.STATUS_FETCH_NOTMODIFIED);                            break;                        default:                            if (LOG.isWarnEnabled()) {                                LOG.warn("{} {} Unknown ProtocolStatus: {}", getName(), Thread.currentThread().getId(), status.getCode());                            }                            output(fit.url, fit.datum, null, status, CrawlDatum.STATUS_FETCH_RETRY);                    }                    if (redirecting && redirectCount > maxRedirect) {                        ((FetchItemQueues) fetchQueues).finishFetchItem(fit);                        if (LOG.isInfoEnabled()) {                            LOG.info("{} {} - redirect count exceeded {}", getName(), Thread.currentThread().getId(), fit.url);                        }                        output(fit.url, fit.datum, null, ProtocolStatus.STATUS_REDIR_EXCEEDED, CrawlDatum.STATUS_FETCH_GONE);                    }                } while (redirecting && (redirectCount <= maxRedirect));            } catch (Throwable t) {                                                ((FetchItemQueues) fetchQueues).finishFetchItem(fit);                String message;                if (LOG.isDebugEnabled()) {                    message = StringUtils.stringifyException(t);                } else if (logUtil.logShort(t)) {                    message = t.getClass().getName();                } else {                    message = StringUtils.stringifyException(t);                }                logError(fit.url, message);                output(fit.url, fit.datum, null, ProtocolStatus.STATUS_FAILED, CrawlDatum.STATUS_FETCH_RETRY);            }        }    } catch (Throwable e) {        if (LOG.isErrorEnabled()) {            LOG.error("fetcher caught:", e);        }    } finally {        if (fit != null)            ((FetchItemQueues) fetchQueues).finishFetchItem(fit);                activeThreads.decrementAndGet();        LOG.info("{} {} -finishing thread {}, activeThreads={}", getName(), Thread.currentThread().getId(), getName(), activeThreads);    }}
7da52d8ad3198a2c952165dc616f3df09cc65d0850e6c54df9ea2150c7e72bbb
handleRedirect
private Text handleRedirect(FetchItem fit, String newUrl, boolean temp, String redirType) throws MalformedURLException, URLFilterException, InterruptedException
{    if (newUrl.length() > maxOutlinkLength) {        return null;    }    newUrl = normalizers.normalize(newUrl, URLNormalizers.SCOPE_FETCHER);    newUrl = urlFilters.filter(newUrl);    String urlString = fit.url.toString();    if (newUrl == null || newUrl.equals(urlString)) {        LOG.debug(" - {} redirect skipped: {}", redirType, (newUrl != null ? "to same url" : "filtered"));        return null;    }    if (ignoreAlsoRedirects && (ignoreExternalLinks || ignoreInternalLinks)) {        try {            URL origUrl = fit.u;            URL redirUrl = new URL(newUrl);            if (ignoreExternalLinks) {                String origHostOrDomain, newHostOrDomain;                if ("bydomain".equalsIgnoreCase(ignoreExternalLinksMode)) {                    origHostOrDomain = URLUtil.getDomainName(origUrl).toLowerCase();                    newHostOrDomain = URLUtil.getDomainName(redirUrl).toLowerCase();                } else {                                        origHostOrDomain = origUrl.getHost().toLowerCase();                    newHostOrDomain = redirUrl.getHost().toLowerCase();                }                if (!origHostOrDomain.equals(newHostOrDomain)) {                    LOG.debug(" - ignoring redirect {} from {} to {} because external links are ignored", redirType, urlString, newUrl);                    return null;                }            }            if (ignoreInternalLinks) {                String origHost = origUrl.getHost().toLowerCase();                String newHost = redirUrl.getHost().toLowerCase();                if (origHost.equals(newHost)) {                    LOG.debug(" - ignoring redirect {} from {} to {} because internal links are ignored", redirType, urlString, newUrl);                    return null;                }            }        } catch (MalformedURLException e) {            return null;        }    }    reprUrl = URLUtil.chooseRepr(reprUrl, newUrl, temp);    Text url = new Text(newUrl);    if (maxRedirect > 0) {        redirecting = true;        redirectCount++;        LOG.debug(" - {} redirect to {} (fetching now)", redirType, url);        return url;    } else {        CrawlDatum newDatum = new CrawlDatum(CrawlDatum.STATUS_LINKED, fit.datum.getFetchInterval(), fit.datum.getScore());                newDatum.getMetaData().putAll(fit.datum.getMetaData());        try {            scfilters.initialScore(url, newDatum);        } catch (ScoringFilterException e) {            e.printStackTrace();        }        if (reprUrl != null) {            newDatum.getMetaData().put(Nutch.WRITABLE_REPR_URL_KEY, new Text(reprUrl));        }        output(url, newDatum, null, null, CrawlDatum.STATUS_LINKED);        LOG.debug(" - {} redirect to {} (fetching later)", redirType, url);        return null;    }}
815f173fdfc4a0ffa90775d5b6936b7ad75744bf7ae72363e8ed6407523bf1b9
queueRedirect
private FetchItem queueRedirect(Text redirUrl, FetchItem fit) throws ScoringFilterException
{    CrawlDatum newDatum = new CrawlDatum(CrawlDatum.STATUS_DB_UNFETCHED, fit.datum.getFetchInterval(), fit.datum.getScore());        newDatum.getMetaData().putAll(fit.datum.getMetaData());    scfilters.initialScore(redirUrl, newDatum);    if (reprUrl != null) {        newDatum.getMetaData().put(Nutch.WRITABLE_REPR_URL_KEY, new Text(reprUrl));    }    fit = FetchItem.create(redirUrl, newDatum, queueMode);    if (fit != null) {        FetchItemQueue fiq = ((FetchItemQueues) fetchQueues).getFetchItemQueue(fit.queueID);        fiq.addInProgressFetchItem(fit);    } else {                redirecting = false;        context.getCounter("FetcherStatus", "FetchItem.notCreated.redirect").increment(1);    }    return fit;}
dad683cb5fdfd3221b066d380e64fdb3774c97af324da96296a492d4237cc416
logError
private void logError(Text url, String message)
{    if (LOG.isInfoEnabled()) {        LOG.info("{} {} fetch of {} failed with: {}", getName(), Thread.currentThread().getId(), url, message);    }    errors.incrementAndGet();}
7ebc6a82dc6b3d2719f22e504d81dc39edb86d7a66adbf87e6c83e1c6ca8a9a3
output
private ParseStatus output(Text key, CrawlDatum datum, Content content, ProtocolStatus pstatus, int status) throws InterruptedException
{    return output(key, datum, content, pstatus, status, 0);}
3173f63358ba1691209cfe959b3887f6cc59ecede0b605672b165896a6694408
output
private ParseStatus output(Text key, CrawlDatum datum, Content content, ProtocolStatus pstatus, int status, int outlinkDepth) throws InterruptedException
{    datum.setStatus(status);    datum.setFetchTime(System.currentTimeMillis());    if (pstatus != null)        datum.getMetaData().put(Nutch.WRITABLE_PROTO_STATUS_KEY, pstatus);    ParseResult parseResult = null;    if (content != null) {        Metadata metadata = content.getMetadata();                if (content.getContentType() != null)            datum.getMetaData().put(new Text(Metadata.CONTENT_TYPE), new Text(content.getContentType()));                metadata.set(Nutch.SEGMENT_NAME_KEY, segmentName);                try {            scfilters.passScoreBeforeParsing(key, datum, content);        } catch (Exception e) {            if (LOG.isWarnEnabled()) {                LOG.warn("{} {} Couldn't pass score, url {} ({})", getName(), Thread.currentThread().getId(), key, e);            }        }        if (status == CrawlDatum.STATUS_FETCH_SUCCESS) {            if (parsing && !(skipTruncated && ParseSegment.isTruncated(content))) {                try {                    parseResult = this.parseUtil.parse(content);                } catch (Exception e) {                    LOG.warn("{} {} Error parsing: {}: {}", getName(), Thread.currentThread().getId(), key, StringUtils.stringifyException(e));                }            }            if (parseResult == null && (parsing || signatureWithoutParsing)) {                byte[] signature = SignatureFactory.getSignature(conf).calculate(content, new ParseStatus().getEmptyParse(conf));                datum.setSignature(signature);            }        }        /*       * Store status code in content So we can read this value during parsing       * (as a separate job) and decide to parse or not.       */        content.getMetadata().add(Nutch.FETCH_STATUS_KEY, Integer.toString(status));    }    try {        context.write(key, new NutchWritable(datum));        if (content != null && storingContent)            context.write(key, new NutchWritable(content));        if (parseResult != null) {            for (Entry<Text, Parse> entry : parseResult) {                Text url = entry.getKey();                Parse parse = entry.getValue();                ParseStatus parseStatus = parse.getData().getStatus();                ParseData parseData = parse.getData();                if (!parseStatus.isSuccess()) {                    LOG.warn("{} {} Error parsing: {}: {}", getName(), Thread.currentThread().getId(), key, parseStatus);                    parse = parseStatus.getEmptyParse(conf);                }                                                byte[] signature = SignatureFactory.getSignature(conf).calculate(content, parse);                                parseData.getContentMeta().set(Nutch.SEGMENT_NAME_KEY, segmentName);                parseData.getContentMeta().set(Nutch.SIGNATURE_KEY, StringUtil.toHexString(signature));                                parseData.getContentMeta().set(Nutch.FETCH_TIME_KEY, Long.toString(datum.getFetchTime()));                if (url.equals(key))                    datum.setSignature(signature);                try {                    scfilters.passScoreAfterParsing(url, content, parse);                } catch (Exception e) {                    if (LOG.isWarnEnabled()) {                        LOG.warn("{} {} Couldn't pass score, url {} ({})", getName(), Thread.currentThread().getId(), key, e);                    }                }                String origin = null;                                Outlink[] links = parseData.getOutlinks();                int outlinksToStore = Math.min(maxOutlinks, links.length);                if (ignoreExternalLinks || ignoreInternalLinks) {                    URL originURL = new URL(url.toString());                                        if ("bydomain".equalsIgnoreCase(ignoreExternalLinksMode)) {                        origin = URLUtil.getDomainName(originURL).toLowerCase();                    } else                     {                        origin = originURL.getHost().toLowerCase();                    }                }                                if (fetchNode != null) {                    fetchNode.setOutlinks(links);                    fetchNode.setTitle(parseData.getTitle());                    FetchNodeDb.getInstance().put(fetchNode.getUrl().toString(), fetchNode);                }                int validCount = 0;                                List<Outlink> outlinkList = new ArrayList<>(outlinksToStore);                HashSet<String> outlinks = new HashSet<>(outlinksToStore);                for (int i = 0; i < links.length && validCount < outlinksToStore; i++) {                    String toUrl = links[i].getToUrl();                    if (toUrl.length() > maxOutlinkLength) {                        continue;                    }                    toUrl = ParseOutputFormat.filterNormalize(url.toString(), toUrl, origin, ignoreInternalLinks, ignoreExternalLinks, ignoreExternalLinksMode, urlFiltersForOutlinks, urlExemptionFilters, normalizersForOutlinks);                    if (toUrl == null) {                        continue;                    }                    validCount++;                    links[i].setUrl(toUrl);                    outlinkList.add(links[i]);                    outlinks.add(toUrl);                }                                if (activatePublisher) {                    FetcherThreadEvent reportEvent = new FetcherThreadEvent(PublishEventType.REPORT, url.toString());                    reportEvent.addOutlinksToEventData(outlinkList);                    reportEvent.addEventData(Nutch.FETCH_EVENT_TITLE, parseData.getTitle());                    reportEvent.addEventData(Nutch.FETCH_EVENT_CONTENTTYPE, parseData.getContentMeta().get("content-type"));                    reportEvent.addEventData(Nutch.FETCH_EVENT_SCORE, datum.getScore());                    reportEvent.addEventData(Nutch.FETCH_EVENT_FETCHTIME, datum.getFetchTime());                    reportEvent.addEventData(Nutch.FETCH_EVENT_CONTENTLANG, parseData.getContentMeta().get("content-language"));                    publisher.publish(reportEvent, conf);                }                                if (maxOutlinkDepth > 0 && outlinkDepth < maxOutlinkDepth) {                    FetchItem ft = FetchItem.create(url, null, queueMode);                    FetchItemQueue queue = ((FetchItemQueues) fetchQueues).getFetchItemQueue(ft.queueID);                    queue.alreadyFetched.add(url.toString().hashCode());                    context.getCounter("FetcherOutlinks", "outlinks_detected").increment(outlinks.size());                                        int outlinkCounter = 0;                    String followUrl;                                        Iterator<String> iter = outlinks.iterator();                    while (iter.hasNext() && outlinkCounter < maxOutlinkDepthNumLinks) {                        followUrl = iter.next();                                                if (outlinksIgnoreExternal) {                            if (!URLUtil.getHost(url.toString()).equals(URLUtil.getHost(followUrl))) {                                continue;                            }                        }                                                int urlHashCode = followUrl.hashCode();                        if (queue.alreadyFetched.contains(urlHashCode)) {                            continue;                        }                        queue.alreadyFetched.add(urlHashCode);                                                FetchItem fit = FetchItem.create(new Text(followUrl), new CrawlDatum(CrawlDatum.STATUS_LINKED, interval), queueMode, outlinkDepth + 1);                        context.getCounter("FetcherOutlinks", "outlinks_following").increment(1);                        ((FetchItemQueues) fetchQueues).addFetchItem(fit);                        outlinkCounter++;                    }                }                                                parseData.setOutlinks(outlinkList.toArray(new Outlink[outlinkList.size()]));                context.write(url, new NutchWritable(new ParseImpl(new ParseText(parse.getText()), parseData, parse.isCanonical())));            }        }    } catch (IOException e) {        if (LOG.isErrorEnabled()) {            LOG.error("fetcher caught:", e);        }    }        if (parseResult != null && !parseResult.isEmpty()) {        Parse p = parseResult.get(content.getUrl());        if (p != null) {            context.getCounter("ParserStatus", ParseStatus.majorCodes[p.getData().getStatus().getMajorCode()]).increment(1);            return p.getData().getStatus();        }    }    return null;}
cf34d30d2ea309e0c43fee8e20bb9cc5c38751318c4055ae5f8225459b6603e9
outputRobotsTxt
private void outputRobotsTxt(List<Content> robotsTxtContent) throws InterruptedException
{    for (Content robotsTxt : robotsTxtContent) {        LOG.debug("fetched and stored robots.txt {}", robotsTxt.getUrl());        try {            context.write(new Text(robotsTxt.getUrl()), new NutchWritable(robotsTxt));        } catch (IOException e) {            LOG.error("fetcher caught:", e);        }    }}
74931d5978c06861a81643616017e2725f86356cc6acd71b7be3ae33758a0296
updateStatus
private void updateStatus(int bytesInPage) throws IOException
{    pages.incrementAndGet();    bytes.addAndGet(bytesInPage);}
c4234f8bd62ce069fb469b5e07dea87df2c222e3489ec2b7842c4577789d5aa6
setHalted
public synchronized void setHalted(boolean halted)
{    this.halted = halted;}
d8c24b69ca745963bb796ff6761af9e6554cafff574f90c17c8b442e6f13836b
isHalted
public synchronized boolean isHalted()
{    return halted;}
30dd5cab99607565ceb0a6984cc4bf004048ba4540865142217dd65d36b29399
getReprUrl
public String getReprUrl()
{    return reprUrl;}
9db538737e24f86382d2ac2bed19ab9d0902a8d32eb92b1ccef170f6bbd5904e
setReprUrl
private void setReprUrl(String urlString)
{    this.reprUrl = urlString;}
609d9fa4b1b532e6fb244aa19720792827326fb6814a7f3f14d92a75f7e9e2ac
getEventType
public PublishEventType getEventType()
{    return eventType;}
c499a71d06c39bc81b802d22b6e71aaac07f1a0fedbf482a72177b7cfe42037d
setEventType
public void setEventType(PublishEventType eventType)
{    this.eventType = eventType;}
1c9dc3b2571b744c7318c7a1e3698ae5865b501878441a4c6eebc4887494cd00
getEventData
public Map<String, Object> getEventData()
{    return eventData;}
13ec9374e74bde1900976700b5d0735183f9f8cbea62f58ee5a662d7a9b3b51e
setEventData
public void setEventData(Map<String, Object> eventData)
{    this.eventData = eventData;}
354afe66bbdb19ee4d620955bbb214ebf9b5aa09359dea30ffb867002b5a25bd
getUrl
public String getUrl()
{    return url;}
c3d2ee14b0a87d91276b6034d452ebbd50ed47914948b9edaea83747da585af6
setUrl
public void setUrl(String url)
{    this.url = url;}
1e1dc5f4cc43c15500110797277d1288a18044bfd448439aba3b36ab89796067
addEventData
public void addEventData(String key, Object value)
{    if (eventData == null) {        eventData = new HashMap<>();    }    eventData.put(key, value);}
218130a592dd85595630be772c84ac5b51796dcafe781430b8e1451e136a8057
addOutlinksToEventData
public void addOutlinksToEventData(Collection<Outlink> links)
{    ArrayList<Map<String, String>> outlinkList = new ArrayList<>();    for (Outlink link : links) {        Map<String, String> outlink = new HashMap<>();        outlink.put("url", link.getToUrl());        outlink.put("anchor", link.getAnchor());        outlinkList.add(outlink);    }    this.addEventData("outlinks", outlinkList);}
3d71861ffb08176b9b618d057ac96a84a93a4e0195801a8674d9ea8bf30661b2
getTimestamp
public Long getTimestamp()
{    return timestamp;}
b1ea4fa2e8d9353da01762775bc3120d365d9867f9e6698e9deafda385a74e32
setTimestamp
public void setTimestamp(Long timestamp)
{    this.timestamp = timestamp;}
fc795fdb51ed96fd8d43aff4783ba30fcff6b3985dae7cf483cdb3957fcc868e
publish
public void publish(FetcherThreadEvent event, Configuration conf)
{    if (publisher != null) {        publisher.publish(event, conf);    } else {        LOG.warn("Could not instantiate publisher implementation, continuing without publishing");    }}
c9d596fd0cbded76075b0a09bdd78fbedaec34b6d18f489872fa352f21568347
create
public static FetchItem create(Text url, CrawlDatum datum, String queueMode)
{    return create(url, datum, queueMode, 0);}
6a1a515686770d2b6fc5ccd029be1817e918397bcd9f8094908fca3b2c9786b8
create
public static FetchItem create(Text url, CrawlDatum datum, String queueMode, int outlinkDepth)
{    URL u = null;    try {        u = new URL(url.toString());    } catch (Exception e) {        LOG.warn("Cannot parse url: " + url, e);        return null;    }    String key;    if (FetchItemQueues.QUEUE_MODE_IP.equalsIgnoreCase(queueMode)) {        try {            final InetAddress addr = InetAddress.getByName(u.getHost());            key = addr.getHostAddress();        } catch (final UnknownHostException e) {                        LOG.warn("Unable to resolve: " + u.getHost() + ", skipping.");            return null;        }    } else if (FetchItemQueues.QUEUE_MODE_DOMAIN.equalsIgnoreCase(queueMode)) {        key = URLUtil.getDomainName(u).toLowerCase(Locale.ROOT);        if (key == null) {            LOG.warn("Unknown domain for url: " + url + ", using URL string as key");            key = u.toExternalForm();        }    } else {        key = u.getHost().toLowerCase(Locale.ROOT);        if (key == null) {            LOG.warn("Unknown host for url: " + url + ", using URL string as key");            key = u.toExternalForm();        }    }    return new FetchItem(url, u, datum, key, outlinkDepth);}
0cc1c3b448d97a80d03fc5f9a1043521957cf618cb24c17b7636a9fe564c100d
getDatum
public CrawlDatum getDatum()
{    return datum;}
f9e59e3914ee6aedaf97bd2c264d9e96bd54043f111009be2929e99f01fe0c73
getQueueID
public String getQueueID()
{    return queueID;}
cdb4714bcc0fedcba260b68f17f9b760fc44bc785ebc946174199961669bf126
getUrl
public Text getUrl()
{    return url;}
0d63cefa340cc2bda06db9a17e4bfcdce220354a4b5dd187bf613224e0d99a18
getURL2
public URL getURL2()
{    return u;}
9a5ff0512aee082d664a3734e6be8e51cf503e3bf998979088b4dd9fdda3bbd7
emptyQueue
public synchronized int emptyQueue()
{    int presize = queue.size();    queue.clear();    return presize;}
7ec185e280bd1f09f678c9a882962cce8017cf7334e4dd7e0f75abaecb12ef9c
getQueueSize
public int getQueueSize()
{    return queue.size();}
aedb088a2f459ab049d9d029599ce339b47a0b2a53a06019839f58e0580b737e
getInProgressSize
public int getInProgressSize()
{    return inProgress.get();}
0f793926cf482681258af5f44cb046f3f6aaa91a5634980164df1af5e61d8d7a
incrementExceptionCounter
public int incrementExceptionCounter()
{    return exceptionCounter.incrementAndGet();}
5a5cf62152d3e6ec139da4a4d6c63242ace8711ca1e0feedc14e4fe48514d5ce
finishFetchItem
public void finishFetchItem(FetchItem it, boolean asap)
{    if (it != null) {        inProgress.decrementAndGet();        setEndTime(System.currentTimeMillis(), asap);    }}
b08040b94ceda37e2c455dba4307fd92f6fa7edf72b3d8dd413db3ba0f72e15c
addFetchItem
public void addFetchItem(FetchItem it)
{    if (it == null)        return;        if (it.datum.getMetaData().containsKey(variableFetchDelayKey)) {        if (!variableFetchDelaySet) {            variableFetchDelaySet = true;            crawlDelay = ((LongWritable) (it.datum.getMetaData().get(variableFetchDelayKey))).get();            minCrawlDelay = ((LongWritable) (it.datum.getMetaData().get(variableFetchDelayKey))).get();            setEndTime(System.currentTimeMillis() - crawlDelay);        }                it.datum.getMetaData().remove(variableFetchDelayKey);    }    queue.add(it);}
25f4c357e6a456bdc2e0cc4c92163bb57f8960093ab9ce5e98410ee32b70a458
addInProgressFetchItem
public void addInProgressFetchItem(FetchItem it)
{    if (it == null)        return;    inProgress.incrementAndGet();}
3dc455dc96d7ada58a50aa4eaeb6f7f134c2fa6d0308f15ee9b1d089f1fccd3d
getFetchItem
public FetchItem getFetchItem()
{    if (inProgress.get() >= maxThreads)        return null;    long now = System.currentTimeMillis();    if (nextFetchTime.get() > now)        return null;    FetchItem it = null;    if (queue.size() == 0)        return null;    try {        it = queue.remove(0);        inProgress.incrementAndGet();    } catch (Exception e) {        LOG.error("Cannot remove FetchItem from queue or cannot add it to inProgress queue", e);    }    return it;}
a289ab6279aa4f8fe93ceccf3b94c1800860d7e279a024e219d980b144c9da8e
setCookie
public void setCookie(Text cookie)
{    this.cookie = cookie;}
f94a5083fe899ad2d04d72513226a40251f71a592ea56365e8cba05ddb991299
getCookie
public Text getCookie()
{    return cookie;}
3f11db02a944c68acff1d05aaf41cdb9a383bc19395f655b3c76323d1780448c
dump
public synchronized void dump()
{    LOG.info("  maxThreads    = " + maxThreads);    LOG.info("  inProgress    = " + inProgress.get());    LOG.info("  crawlDelay    = " + crawlDelay);    LOG.info("  minCrawlDelay = " + minCrawlDelay);    LOG.info("  nextFetchTime = " + nextFetchTime.get());    LOG.info("  now           = " + System.currentTimeMillis());    for (int i = 0; i < queue.size(); i++) {        FetchItem it = queue.get(i);        LOG.info("  " + i + ". " + it.url);    }}
9e0aa3fd2a595bf93003455ee187a67b4ca011df44381ff3c0d21fffc92b3c04
setEndTime
private void setEndTime(long endTime)
{    setEndTime(endTime, false);}
db040300d030f6712f5a6f329577e964e5349251002bdd5781b8cb788c976eaa
setEndTime
private void setEndTime(long endTime, boolean asap)
{    if (!asap)        nextFetchTime.set(endTime + (maxThreads > 1 ? minCrawlDelay : crawlDelay));    else        nextFetchTime.set(endTime);}
3e24d0cbda48bba2c8713205df3ba36803625e8af34ede6f0b9de4fa809a2b0c
checkQueueMode
protected static String checkQueueMode(String queueMode)
{        if (!queueMode.equals(QUEUE_MODE_IP) && !queueMode.equals(QUEUE_MODE_DOMAIN) && !queueMode.equals(QUEUE_MODE_HOST)) {        LOG.error("Unknown partition mode : {} - forcing to byHost", queueMode);        queueMode = QUEUE_MODE_HOST;    }    return queueMode;}
f8cd59b0d90b2037b9552bc1581b4389f453b72004e7f2b32fd156999a28d903
getTotalSize
public int getTotalSize()
{    return totalSize.get();}
2612acb68f14ae0ffa1e6f888b79c60e6a6c13c4d8ea74f7cfaad71b1bce3939
getQueueCount
public int getQueueCount()
{    return queues.size();}
0a47a15bccda933d3db7a13caa848c89b7368c45bbdaa107ad313c83b1d30289
addFetchItem
public void addFetchItem(Text url, CrawlDatum datum)
{    FetchItem it = FetchItem.create(url, datum, queueMode);    if (it != null)        addFetchItem(it);}
bfaa89ec1f53a7f4925b88b25f61d408e6b35ae2919a2080c46694fe8ab75a73
addFetchItem
public synchronized void addFetchItem(FetchItem it)
{    FetchItemQueue fiq = getFetchItemQueue(it.queueID);    fiq.addFetchItem(it);    totalSize.incrementAndGet();}
c91f4f1a76fda3ad0146e63bd29313d8e0475f97d8e18934e6bf4c2f482fd763
finishFetchItem
public void finishFetchItem(FetchItem it)
{    finishFetchItem(it, false);}
5a5cf62152d3e6ec139da4a4d6c63242ace8711ca1e0feedc14e4fe48514d5ce
finishFetchItem
public void finishFetchItem(FetchItem it, boolean asap)
{    FetchItemQueue fiq = queues.get(it.queueID);    if (fiq == null) {        LOG.warn("Attempting to finish item from unknown queue: " + it);        return;    }    fiq.finishFetchItem(it, asap);}
8b08e79ec26e69aff58bfa3cb9b2f83b7f148392c08f1d8dffda80aa83df03c8
getFetchItemQueue
public synchronized FetchItemQueue getFetchItemQueue(String id)
{    FetchItemQueue fiq = queues.get(id);    if (fiq == null) {                fiq = new FetchItemQueue(conf, maxThreads, crawlDelay, minCrawlDelay);        queues.put(id, fiq);    }    return fiq;}
62d099df4c725eef9df6a6806f87293e9c177b3bf5bc0ee8df1f428f2805d40f
getFetchItem
public synchronized FetchItem getFetchItem()
{    Iterator<Map.Entry<String, FetchItemQueue>> it = queues.entrySet().iterator();    while (it.hasNext()) {        FetchItemQueue fiq = it.next().getValue();                if (fiq.getQueueSize() == 0 && fiq.getInProgressSize() == 0) {            it.remove();            continue;        }        FetchItem fit = fiq.getFetchItem();        if (fit != null) {            totalSize.decrementAndGet();            return fit;        }    }    return null;}
35e6737ec53851b3c45f648cd8d92b1d07a10b2e5f442662959b568686487692
checkTimelimit
public synchronized int checkTimelimit()
{    int count = 0;    if (System.currentTimeMillis() >= timelimit && timelimit != -1) {                count = emptyQueues();                if (totalSize.get() != 0 && queues.size() == 0)            totalSize.set(0);    }    return count;}
21cb213c322428d498918433d6fdf45d4b5a1beb1c000f0c4d4fcf7ce5e8a16a
emptyQueues
public synchronized int emptyQueues()
{    int count = 0;    for (String id : queues.keySet()) {        FetchItemQueue fiq = queues.get(id);        if (fiq.getQueueSize() == 0)            continue;        LOG.info("* queue: " + id + " >> dropping! ");        int deleted = fiq.emptyQueue();        for (int i = 0; i < deleted; i++) {            totalSize.decrementAndGet();        }        count += deleted;    }    return count;}
6f4110d7edf228df66bab3b2a8423209f5273f7f2f4de1b3031b7eff0e5fd0cb
checkExceptionThreshold
public synchronized int checkExceptionThreshold(String queueid)
{    FetchItemQueue fiq = queues.get(queueid);    if (fiq == null) {        return 0;    }    if (fiq.getQueueSize() == 0) {        return 0;    }    int excCount = fiq.incrementExceptionCounter();    if (maxExceptionsPerQueue != -1 && excCount >= maxExceptionsPerQueue) {                int deleted = fiq.emptyQueue();        LOG.info("* queue: " + queueid + " >> removed " + deleted + " URLs from queue because " + excCount + " exceptions occurred");        for (int i = 0; i < deleted; i++) {            totalSize.decrementAndGet();        }        return deleted;    }    return 0;}
3f11db02a944c68acff1d05aaf41cdb9a383bc19395f655b3c76323d1780448c
dump
public synchronized void dump()
{    for (String id : queues.keySet()) {        FetchItemQueue fiq = queues.get(id);        if (fiq.getQueueSize() == 0)            continue;        LOG.info("* queue: " + id);        fiq.dump();    }}
cdb4714bcc0fedcba260b68f17f9b760fc44bc785ebc946174199961669bf126
getUrl
public Text getUrl()
{    return url;}
e4aa14216c693ca4f89ac71bd76fa447d936c963005585dd62bc7280525388d6
setUrl
public void setUrl(Text url)
{    this.url = url;}
b639a29bd9292f7139347645f848b106f66bd0a41b6cb5a3ea56b650135ffa05
getOutlinks
public Outlink[] getOutlinks()
{    return outlinks;}
a9db415739b76b61a760c64892fe85e6b27e9857394bb1073c66639389a7d445
setOutlinks
public void setOutlinks(Outlink[] links)
{    this.outlinks = links;}
bfbf8f81d09b885c0f37c95c31de89a2ffa7676596bc6d4a873d28b384c04d1d
getStatus
public int getStatus()
{    return status;}
78ea1ba2f8e3ed7bc64348f7b7ea6abc4ee5f91d684a7686596eb3cb28cca7ae
setStatus
public void setStatus(int status)
{    this.status = status;}
e5ef01fa2cf65dfc9fab56435459437471698c703940d8b9a6902680e8c38e95
getTitle
public String getTitle()
{    return title;}
3c9df8226074a83c462c9aca91d66db107912d85c3f2a3012dd56005602e538a
setTitle
public void setTitle(String title)
{    this.title = title;}
61cb43d82252835d718b08d86716b3c5a59a26727416256da2f81161ca82b087
getFetchTime
public long getFetchTime()
{    return fetchTime;}
dcbaeb1d109387ae00d176058c6c2fc7b35db459ca1e879349bd2c20a40efb85
setFetchTime
public void setFetchTime(long fetchTime)
{    this.fetchTime = fetchTime;}
80e10b2a224fdbaff512753c29ffafb1b1311a97a48a033fbde49a4f32301818
getInstance
public static FetchNodeDb getInstance()
{    if (fetchNodeDbInstance == null) {        fetchNodeDbInstance = new FetchNodeDb();    }    return fetchNodeDbInstance;}
9ffc94fcdea30ac701464a4ae7da4655d2a5b1eb5a47c2e6ffc96b8221424671
put
public void put(String url, FetchNode fetchNode)
{    System.out.println("FetchNodeDb : putting node - " + fetchNode.hashCode());    fetchNodeDbMap.put(index++, fetchNode);}
78f8bc2202bf64a0418b5b2d7e1f9f16fe510fed7e59226795355f1ca437614d
getFetchNodeDb
public Map<Integer, FetchNode> getFetchNodeDb()
{    return fetchNodeDbMap;}
43a70a32b756faa0c15211594f59ffe264457c34399534cf061ed5aae987571b
setTimeLimit
public void setTimeLimit(long tl)
{    timelimit = tl;}
2b889bbf73ce3ba54b81471a74e4af72862f38b422f959d769f98655dfab46a5
filterNormalize
private String filterNormalize(String url)
{    if (url != null) {        try {            if (urlNormalizers != null)                                url = urlNormalizers.normalize(url, urlNormalizerScope);            if (urlFilters != null)                url = urlFilters.filter(url);        } catch (MalformedURLException | URLFilterException e) {            LOG.warn("Skipping {}: {}", url, e);            url = null;        }    }    return url;}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    boolean hasMore = true;    int cnt = 0;    int timelimitcount = 0;    while (hasMore) {        if (System.currentTimeMillis() >= timelimit && timelimit != -1) {                        try {                hasMore = context.nextKeyValue();                timelimitcount++;            } catch (IOException e) {                LOG.error("QueueFeeder error reading input, record " + cnt, e);                return;            } catch (InterruptedException e) {                LOG.info("QueueFeeder interrupted, exception:", e);                return;            }            continue;        }        int feed = size - queues.getTotalSize();        if (feed <= 0) {                        try {                Thread.sleep(1000);            } catch (InterruptedException e) {            }            continue;        }        LOG.debug("-feeding {} input urls ...", feed);        while (feed > 0 && hasMore) {            try {                hasMore = context.nextKeyValue();                if (hasMore) {                    Text url = context.getCurrentKey();                    if (urlFilters != null || urlNormalizers != null) {                        String u = filterNormalize(url.toString());                        if (u == null) {                                                        context.getCounter("FetcherStatus", "filtered").increment(1);                            continue;                        }                        url = new Text(u);                    } else /*             * Need to copy key and value objects because MapReduce will reuse             * the original objects while the objects are stored in the queue.             */                    {                        url = new Text(url);                    }                    CrawlDatum datum = new CrawlDatum();                    datum.set((CrawlDatum) context.getCurrentValue());                    queues.addFetchItem(url, datum);                    cnt++;                    feed--;                }            } catch (IOException e) {                LOG.error("QueueFeeder error reading input, record " + cnt, e);                return;            } catch (InterruptedException e) {                LOG.info("QueueFeeder interrupted, exception:", e);            }        }    }    LOG.info("QueueFeeder finished: total {} records hit by time limit : {}", cnt, timelimitcount);}
82d9fb87b78078551ed11c333ec6db05535a369daf92cfc4cbaa37fbb66d3ba0
resetFailures
public void resetFailures()
{    setDnsFailures(0l);    setConnectionFailures(0l);}
dabee42aea8f9e73e146bbafb3583f5da11373ef2aa29edf8b2fa7bcacc6ba68
setDnsFailures
public void setDnsFailures(Long dnsFailures)
{    this.dnsFailures = dnsFailures;}
a4848125c415ef73788eb71e0c95c9d2b4c1c14894835d7f4b343591ece4b44e
setConnectionFailures
public void setConnectionFailures(Long connectionFailures)
{    this.connectionFailures = connectionFailures;}
fbda2e9ef7c5d32eecf37ecb61bc247e7039e9e83615c130a0082cc726654ecf
incDnsFailures
public void incDnsFailures()
{    this.dnsFailures++;}
07ebf9265c14e4d1f4755ddd936e6e8e00a0862734549c808ce5b7c8cd461ab8
incConnectionFailures
public void incConnectionFailures()
{    this.connectionFailures++;}
a2512829974a81cad4d68866270897ff1476b7f2015a9cdf1109f0ba14b3ec17
numFailures
public Long numFailures()
{    return getDnsFailures() + getConnectionFailures();}
31e10c92057ea523dacdbdbb53ab43fbb94954836441da469e4aa85a68f7750e
getDnsFailures
public Long getDnsFailures()
{    return dnsFailures;}
9448d88450b2e9d306b29682fc98bba0d1d37c91751ad6e6e3dcba2bb861ea49
getConnectionFailures
public Long getConnectionFailures()
{    return connectionFailures;}
071161dd3251af6621397d84e4f0add6eab4e69fea95694f972de14af000f45c
setScore
public void setScore(float score)
{    this.score = score;}
5c779aec2c0963cc620ccf9fd1837b803e425bfbaf3439b367327c15022dea68
setLastCheck
public void setLastCheck()
{    setLastCheck(new Date());}
801929e9330c7719c4eaf3b5a522fb8fc8898ced6e8624dbbe54c384e4a2d547
setLastCheck
public void setLastCheck(Date date)
{    lastCheck = date;}
803915e853382ad445a6e2333fabb8beb8e4acd70e908a0d818400f7baac42af
isEmpty
public boolean isEmpty()
{    return (lastCheck.getTime() == 0) ? true : false;}
6f4b0f5ea8fd7dfa3fdce005672f6f3b0532cd398e75b8550ffa1c7fe96a733a
getScore
public float getScore()
{    return score;}
c76e4466c19976bc15436209320a27b878a95219c5b07e7def8c607e4b0ac086
numRecords
public Long numRecords()
{    return unfetched + fetched + gone + redirPerm + redirTemp + notModified;}
1009e09f7a2aa00614e95825fef4eabf33de417a1b64560b764bcdd3c3b2c02b
getLastCheck
public Date getLastCheck()
{    return lastCheck;}
54f6361f7aacef472970549e02512c761c3fad5583006a36b5f1df659d52b9cc
hasHomepageUrl
public boolean hasHomepageUrl()
{    return homepageUrl.length() > 0;}
6a57e3fd8f38641faf88b96fbb1b4cf748cae06969aed5942928ed314e330b37
getHomepageUrl
public String getHomepageUrl()
{    return homepageUrl;}
4f340af918b0eb62773c9d697b6c47ca82251079667f37dcadf9ddb34a6dcc42
setHomepageUrl
public void setHomepageUrl(String homepageUrl)
{    this.homepageUrl = homepageUrl;}
a015bdc71f118e8add540407387b246fd15d7d64b6463689d9329930545a5047
setUnfetched
public void setUnfetched(long val)
{    unfetched = val;}
71a580f7800d7e11fe095eb3260f671691fe902e71f75d916bc927af44ae9ed7
getUnfetched
public long getUnfetched()
{    return unfetched;}
5cdfcb345290bd96846816a61cb62fc0dd5428cccad32aa350829b6c1cf294bf
setFetched
public void setFetched(long val)
{    fetched = val;}
0946d5d81925d7c4bc3c6c23571cc2e8da1f75bbe3eaa95f84c84ee9ee1ec47a
getFetched
public long getFetched()
{    return fetched;}
9ab7e9ffacdaf928f1f8c030b3372a9fa0efcd437880f97c326a030962f94a15
setNotModified
public void setNotModified(long val)
{    notModified = val;}
732791729a469086cca55c4a8f0d8127f2c9082d66cc18fc2d42a95243c3e3bb
getNotModified
public long getNotModified()
{    return notModified;}
e530c3e9d5d8071636a0b182a944c2f0ed77689c04594d13a190e8f0fea9eddb
setRedirTemp
public void setRedirTemp(long val)
{    redirTemp = val;}
0dc031ab8e12e213072113ea3150c35abe282d4da29de91ffc867b862ab1597b
getRedirTemp
public long getRedirTemp()
{    return redirTemp;}
bb18c511015908dc8e08a116aca252fbd187e088f7a82c049812e1883895d825
setRedirPerm
public void setRedirPerm(long val)
{    redirPerm = val;}
9541999d73f09d053e502b8218db9366ffca9620e410984b79e65fb6881fb960
getRedirPerm
public long getRedirPerm()
{    return redirPerm;}
59001bdb9a734addc9e5b5cfe0492572f98641d4af61ff8c3fb5c9c7c21d1f90
setGone
public void setGone(long val)
{    gone = val;}
74b1a66194cfdfdfe74512e2e4513f7f19f7f66be2ac570e673accb6e004b1ce
getGone
public long getGone()
{    return gone;}
6796d6969d1871f25466f988d5c9ad5407404d99f3a46ea6887e8a747b489966
resetStatistics
public void resetStatistics()
{    setUnfetched(0);    setFetched(0);    setGone(0);    setRedirTemp(0);    setRedirPerm(0);    setNotModified(0);}
558029183a6b9e5c383aea74ac8c70b0f9a4d3d96c5f68f2027033c80f4c70c7
setMetaData
public void setMetaData(org.apache.hadoop.io.MapWritable mapWritable)
{    this.metaData = new org.apache.hadoop.io.MapWritable(mapWritable);}
d78e74a9c4df5f702029aacaa886b8fda18ee21dfdf7a38db044db265d5947c9
putAllMetaData
public void putAllMetaData(HostDatum other)
{    for (Entry<Writable, Writable> e : other.getMetaData().entrySet()) {        getMetaData().put(e.getKey(), e.getValue());    }}
59391903948e8f9916093feda9a31715b3b9730d02dc00144b48efa6b5d827ef
getMetaData
public org.apache.hadoop.io.MapWritable getMetaData()
{    if (this.metaData == null)        this.metaData = new org.apache.hadoop.io.MapWritable();    return this.metaData;}
848285689c67067583c9cc1497cd7cd8cc6ecc4c7205a1ffbc88044ffad03d12
clone
public Object clone() throws CloneNotSupportedException
{    HostDatum result = (HostDatum) super.clone();    result.score = score;    result.lastCheck = lastCheck;    result.homepageUrl = homepageUrl;    result.dnsFailures = dnsFailures;    result.connectionFailures = connectionFailures;    result.unfetched = unfetched;    result.fetched = fetched;    result.notModified = notModified;    result.redirTemp = redirTemp;    result.redirPerm = redirPerm;    result.gone = gone;    result.metaData = metaData;    return result;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    score = in.readFloat();    lastCheck = new Date(in.readLong());    homepageUrl = Text.readString(in);    dnsFailures = in.readLong();    connectionFailures = in.readLong();    unfetched = in.readLong();    fetched = in.readLong();    notModified = in.readLong();    redirTemp = in.readLong();    redirPerm = in.readLong();    gone = in.readLong();    metaData = new org.apache.hadoop.io.MapWritable();    metaData.readFields(in);}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeFloat(score);    out.writeLong(lastCheck.getTime());    Text.writeString(out, homepageUrl);    out.writeLong(dnsFailures);    out.writeLong(connectionFailures);    out.writeLong(unfetched);    out.writeLong(fetched);    out.writeLong(notModified);    out.writeLong(redirTemp);    out.writeLong(redirPerm);    out.writeLong(gone);    metaData.write(out);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder buf = new StringBuilder();    buf.append(Long.toString(getUnfetched()));    buf.append("\t");    buf.append(Long.toString(getFetched()));    buf.append("\t");    buf.append(Long.toString(getGone()));    buf.append("\t");    buf.append(Long.toString(getRedirTemp()));    buf.append("\t");    buf.append(Long.toString(getRedirPerm()));    buf.append("\t");    buf.append(Long.toString(getNotModified()));    buf.append("\t");    buf.append(Long.toString(numRecords()));    buf.append("\t");    buf.append(Long.toString(getDnsFailures()));    buf.append("\t");    buf.append(Long.toString(getConnectionFailures()));    buf.append("\t");    buf.append(Long.toString(numFailures()));    buf.append("\t");    buf.append(Float.toString(score));    buf.append("\t");    buf.append(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(lastCheck));    buf.append("\t");    buf.append(homepageUrl);    buf.append("\t");    for (Entry<Writable, Writable> e : getMetaData().entrySet()) {        buf.append(e.getKey().toString());        buf.append(':');        buf.append(e.getValue().toString());        buf.append("|||");    }    return buf.toString();}
5cea2a7c4e1f15509b5030e71609dca919138d48d1aebe9efc31435a268ea192
setup
public void setup(Context context)
{    dumpHomepages = context.getConfiguration().getBoolean(HOSTDB_DUMP_HOMEPAGES, false);    dumpHostnames = context.getConfiguration().getBoolean(HOSTDB_DUMP_HOSTNAMES, false);    fieldHeader = context.getConfiguration().getBoolean(HOSTDB_DUMP_HEADER, true);    String expr = context.getConfiguration().get(HOSTDB_FILTER_EXPRESSION);    if (expr != null) {                JexlEngine jexl = new JexlEngine();                jexl.setSilent(true);        jexl.setStrict(true);                this.expr = jexl.createExpression(expr);    }}
4660a64b2c6fd12aa12f7ec6ae6ec18aba534cb9fd0be63c4465c05188012bed
map
public void map(Text key, HostDatum datum, Context context) throws IOException, InterruptedException
{    if (fieldHeader && !dumpHomepages && !dumpHostnames) {        context.write(new Text("hostname"), new Text("unfetched\tfetched\tgone\tredirTemp\tredirPerm\tnotModified\tnumRecords\tdnsFail\tcnxFail\tsumFail\tscore\tlastCheck\thomepage\tmetadata"));        fieldHeader = false;    }    if (expr != null) {                JexlContext jcontext = new MapContext();                jcontext.set("unfetched", datum.getUnfetched());        jcontext.set("fetched", datum.getFetched());        jcontext.set("gone", datum.getGone());        jcontext.set("redirTemp", datum.getRedirTemp());        jcontext.set("redirPerm", datum.getRedirPerm());        jcontext.set("redirs", datum.getRedirPerm() + datum.getRedirTemp());        jcontext.set("notModified", datum.getNotModified());        jcontext.set("ok", datum.getFetched() + datum.getNotModified());        jcontext.set("numRecords", datum.numRecords());        jcontext.set("dnsFailures", datum.getDnsFailures());        jcontext.set("connectionFailures", datum.getConnectionFailures());                for (Map.Entry<Writable, Writable> entry : datum.getMetaData().entrySet()) {            Object value = entry.getValue();            if (value instanceof FloatWritable) {                FloatWritable fvalue = (FloatWritable) value;                Text tkey = (Text) entry.getKey();                jcontext.set(tkey.toString(), fvalue.get());            }            if (value instanceof IntWritable) {                IntWritable ivalue = (IntWritable) value;                Text tkey = (Text) entry.getKey();                jcontext.set(tkey.toString(), ivalue.get());            }        }                try {            if (!Boolean.TRUE.equals(expr.evaluate(jcontext))) {                return;            }        } catch (Exception e) {            LOG.info(e.toString() + " for " + key.toString());        }    }    if (dumpHomepages) {        if (datum.hasHomepageUrl()) {            context.write(new Text(datum.getHomepageUrl()), emptyText);        }        return;    }    if (dumpHostnames) {        context.write(key, emptyText);        return;    }        context.write(key, new Text(datum.toString()));}
06de2637b3ca1c4e70c83893120878574e9f2a82c2ab5965ba812f2d5ffc2ec4
readHostDb
private void readHostDb(Path hostDb, Path output, boolean dumpHomepages, boolean dumpHostnames, String expr) throws Exception
{    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    long start = System.currentTimeMillis();    LOG.info("ReadHostDb: starting at " + sdf.format(start));    Configuration conf = getConf();    conf.setBoolean(HOSTDB_DUMP_HOMEPAGES, dumpHomepages);    conf.setBoolean(HOSTDB_DUMP_HOSTNAMES, dumpHostnames);    if (expr != null) {        conf.set(HOSTDB_FILTER_EXPRESSION, expr);    }    conf.setBoolean("mapreduce.fileoutputcommitter.marksuccessfuljobs", false);    conf.set("mapreduce.output.textoutputformat.separator", "\t");    Job job = Job.getInstance(conf);    job.setJobName("ReadHostDb");    job.setJarByClass(ReadHostDb.class);    FileInputFormat.addInputPath(job, new Path(hostDb, "current"));    FileOutputFormat.setOutputPath(job, output);    job.setMapperClass(ReadHostDbMapper.class);    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setOutputFormatClass(TextOutputFormat.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(Text.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(Text.class);    job.setNumReduceTasks(0);    try {        boolean success = job.waitForCompletion(true);        if (!success) {            String message = "ReadHostDb job did not succeed, job status: " + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);                        throw new RuntimeException(message);        }    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error("ReadHostDb job failed: {}", e.getMessage());        throw e;    }    long end = System.currentTimeMillis();    LOG.info("ReadHostDb: finished at " + sdf.format(end) + ", elapsed: " + TimingUtil.elapsedTime(start, end));}
4e2fbf3e9a4af211f0dec53b2c086a0a3a62d38a524b4cd7b5e9e0128b8e60a7
getHostDbRecord
private void getHostDbRecord(Path hostDb, String host) throws Exception
{    Configuration conf = getConf();    SequenceFile.Reader[] readers = SegmentReaderUtil.getReaders(hostDb, conf);    Class<?> keyClass = readers[0].getKeyClass();    Class<?> valueClass = readers[0].getValueClass();    if (!keyClass.getName().equals("org.apache.hadoop.io.Text"))        throw new IOException("Incompatible key (" + keyClass.getName() + ")");    Text key = (Text) keyClass.getConstructor().newInstance();    HostDatum value = (HostDatum) valueClass.getConstructor().newInstance();    for (int i = 0; i < readers.length; i++) {        while (readers[i].next(key, value)) {            if (host.equals(key.toString())) {                System.out.println(value.toString());            }        }        readers[i].close();    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int res = ToolRunner.run(NutchConfiguration.create(), new ReadHostDb(), args);    System.exit(res);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    if (args.length < 2) {        System.err.println("Usage: ReadHostDb <hostdb> [-get <url>] [<output> [-dumpHomepages | -dumpHostnames | -expr <expr.>]]");        return -1;    }    boolean dumpHomepages = false;    boolean dumpHostnames = false;    String expr = null;    String get = null;    for (int i = 0; i < args.length; i++) {        if (args[i].equals("-dumpHomepages")) {            LOG.info("ReadHostDb: dumping homepage URL's");            dumpHomepages = true;        }        if (args[i].equals("-dumpHostnames")) {            LOG.info("ReadHostDb: dumping hostnames");            dumpHostnames = true;        }        if (args[i].equals("-get")) {            get = args[i + 1];            LOG.info("ReadHostDb: get: " + get);            i++;        }        if (args[i].equals("-expr")) {            expr = args[i + 1];            LOG.info("ReadHostDb: evaluating expression: " + expr);            i++;        }    }    try {        if (get != null) {            getHostDbRecord(new Path(args[0], "current"), get);        } else {            readHostDb(new Path(args[0]), new Path(args[1]), dumpHomepages, dumpHostnames, expr);        }        return 0;    } catch (Exception e) {        LOG.error("ReadHostDb: " + StringUtils.stringifyException(e));        return -1;    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{        try {                @SuppressWarnings("unused")        InetAddress inetAddr = InetAddress.getByName(host);        if (datum.isEmpty()) {            context.getCounter("UpdateHostDb", "new_known_host").increment(1);            datum.setLastCheck();            LOG.info(host + ": new_known_host " + datum);        } else if (datum.getDnsFailures() > 0) {            context.getCounter("UpdateHostDb", "rediscovered_host").increment(1);            datum.setLastCheck();            datum.setDnsFailures(0l);            LOG.info(host + ": rediscovered_host " + datum);        } else {            context.getCounter("UpdateHostDb", "existing_known_host").increment(1);            datum.setLastCheck();            LOG.info(host + ": existing_known_host " + datum);        }                context.write(hostText, datum);    } catch (UnknownHostException e) {        try {                        if (datum.isEmpty()) {                datum.setLastCheck();                datum.setDnsFailures(1l);                context.write(hostText, datum);                context.getCounter("UpdateHostDb", "new_unknown_host").increment(1);                LOG.info(host + ": new_unknown_host " + datum);            } else {                datum.setLastCheck();                datum.incDnsFailures();                                if (purgeFailedHostsThreshold == -1 || purgeFailedHostsThreshold < datum.getDnsFailures()) {                    context.write(hostText, datum);                    context.getCounter("UpdateHostDb", "existing_unknown_host").increment(1);                    LOG.info(host + ": existing_unknown_host " + datum);                } else {                    context.getCounter("UpdateHostDb", "purged_unknown_host").increment(1);                    LOG.info(host + ": purged_unknown_host " + datum);                }            }            context.getCounter("UpdateHostDb", Long.toString(datum.numFailures()) + "_times_failed").increment(1);        } catch (Exception ioe) {            LOG.warn(StringUtils.stringifyException(ioe));        }    } catch (Exception e) {        LOG.warn(StringUtils.stringifyException(e));    }    context.getCounter("UpdateHostDb", "checked_hosts").increment(1);}
535e8d0a8a25dc27bdb8bc0614010c5795468c370ae406f9984c59a9e17a108c
updateHostDb
private void updateHostDb(Path hostDb, Path crawlDb, Path topHosts, boolean checkFailed, boolean checkNew, boolean checkKnown, boolean force, boolean filter, boolean normalize) throws Exception
{    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    long start = System.currentTimeMillis();    LOG.info("UpdateHostDb: starting at " + sdf.format(start));    Job job = NutchJob.getInstance(getConf());    Configuration conf = job.getConfiguration();    boolean preserveBackup = conf.getBoolean("db.preserve.backup", true);    job.setJarByClass(UpdateHostDb.class);    job.setJobName("UpdateHostDb");    FileSystem fs = hostDb.getFileSystem(conf);    Path old = new Path(hostDb, "old");    Path current = new Path(hostDb, "current");    Path tempHostDb = new Path(hostDb, "hostdb-" + Integer.toString(new Random().nextInt(Integer.MAX_VALUE)));        Path lock = new Path(hostDb, LOCK_NAME);    if (!fs.exists(current)) {        fs.mkdirs(current);    }    LockUtil.createLockFile(fs, lock, false);    MultipleInputs.addInputPath(job, current, SequenceFileInputFormat.class);    if (topHosts != null) {        MultipleInputs.addInputPath(job, topHosts, KeyValueTextInputFormat.class);    }    if (crawlDb != null) {                conf.setBoolean("hostdb.reading.crawldb", true);        MultipleInputs.addInputPath(job, new Path(crawlDb, CrawlDb.CURRENT_NAME), SequenceFileInputFormat.class);    }    FileOutputFormat.setOutputPath(job, tempHostDb);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(NutchWritable.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(HostDatum.class);    job.setMapperClass(UpdateHostDbMapper.class);    job.setReducerClass(UpdateHostDbReducer.class);    job.setSpeculativeExecution(false);    conf.setBoolean("mapreduce.fileoutputcommitter.marksuccessfuljobs", false);    conf.setBoolean(HOSTDB_CHECK_FAILED, checkFailed);    conf.setBoolean(HOSTDB_CHECK_NEW, checkNew);    conf.setBoolean(HOSTDB_CHECK_KNOWN, checkKnown);    conf.setBoolean(HOSTDB_FORCE_CHECK, force);    conf.setBoolean(HOSTDB_URL_FILTERING, filter);    conf.setBoolean(HOSTDB_URL_NORMALIZING, normalize);    conf.setClassLoader(Thread.currentThread().getContextClassLoader());    try {        boolean success = job.waitForCompletion(true);        if (!success) {            String message = "UpdateHostDb job did not succeed, job status:" + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);            NutchJob.cleanupAfterFailure(tempHostDb, lock, fs);            throw new RuntimeException(message);        }        FSUtils.replace(fs, old, current, true);        FSUtils.replace(fs, current, tempHostDb, true);        if (!preserveBackup && fs.exists(old))            fs.delete(old, true);    } catch (Exception e) {        LOG.error("UpdateHostDb job failed: {}", e.getMessage());        NutchJob.cleanupAfterFailure(tempHostDb, lock, fs);        throw e;    }    LockUtil.removeLockFile(fs, lock);    long end = System.currentTimeMillis();    LOG.info("UpdateHostDb: finished at " + sdf.format(end) + ", elapsed: " + TimingUtil.elapsedTime(start, end));}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int res = ToolRunner.run(NutchConfiguration.create(), new UpdateHostDb(), args);    System.exit(res);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    if (args.length < 2) {        System.err.println("Usage: UpdateHostDb -hostdb <hostdb> " + "[-tophosts <tophosts>] [-crawldb <crawldb>] [-checkAll] [-checkFailed]" + " [-checkNew] [-checkKnown] [-force] [-filter] [-normalize]");        return -1;    }    Path hostDb = null;    Path crawlDb = null;    Path topHosts = null;    boolean checkFailed = false;    boolean checkNew = false;    boolean checkKnown = false;    boolean force = false;    boolean filter = false;    boolean normalize = false;    for (int i = 0; i < args.length; i++) {        if (args[i].equals("-hostdb")) {            hostDb = new Path(args[i + 1]);            LOG.info("UpdateHostDb: hostdb: " + hostDb);            i++;        }        if (args[i].equals("-crawldb")) {            crawlDb = new Path(args[i + 1]);            LOG.info("UpdateHostDb: crawldb: " + crawlDb);            i++;        }        if (args[i].equals("-tophosts")) {            topHosts = new Path(args[i + 1]);            LOG.info("UpdateHostDb: tophosts: " + topHosts);            i++;        }        if (args[i].equals("-checkFailed")) {            LOG.info("UpdateHostDb: checking failed hosts");            checkFailed = true;        }        if (args[i].equals("-checkNew")) {            LOG.info("UpdateHostDb: checking new hosts");            checkNew = true;        }        if (args[i].equals("-checkKnown")) {            LOG.info("UpdateHostDb: checking known hosts");            checkKnown = true;        }        if (args[i].equals("-checkAll")) {            LOG.info("UpdateHostDb: checking all hosts");            checkFailed = true;            checkNew = true;            checkKnown = true;        }        if (args[i].equals("-force")) {            LOG.info("UpdateHostDb: forced check");            force = true;        }        if (args[i].equals("-filter")) {            LOG.info("UpdateHostDb: filtering enabled");            filter = true;        }        if (args[i].equals("-normalize")) {            LOG.info("UpdateHostDb: normalizing enabled");            normalize = true;        }    }    if (hostDb == null) {        System.err.println("hostDb is mandatory");        return -1;    }    try {        updateHostDb(hostDb, crawlDb, topHosts, checkFailed, checkNew, checkKnown, force, filter, normalize);        return 0;    } catch (Exception e) {        LOG.error("UpdateHostDb: " + StringUtils.stringifyException(e));        return -1;    }}
828efea1a07a16b05f247248072a0d2d0eb481455453c583f4002cb29e76342d
setup
public void setup(Mapper<Text, Writable, Text, NutchWritable>.Context context)
{    Configuration conf = context.getConfiguration();    readingCrawlDb = conf.getBoolean("hostdb.reading.crawldb", false);    filter = conf.getBoolean(UpdateHostDb.HOSTDB_URL_FILTERING, false);    normalize = conf.getBoolean(UpdateHostDb.HOSTDB_URL_NORMALIZING, false);    if (filter)        filters = new URLFilters(conf);    if (normalize)        normalizers = new URLNormalizers(conf, URLNormalizers.SCOPE_DEFAULT);}
2cbfa1ffca31ef412b53211240c587de6fc24b0ca35ca1f4c20bb9d6a63774db
filterNormalize
protected String filterNormalize(String url)
{                url = "http://" + url + "/";    try {        if (normalize)            url = normalizers.normalize(url, URLNormalizers.SCOPE_DEFAULT);        if (filter)            url = filters.filter(url);        if (url == null)            return null;    } catch (Exception e) {        return null;    }        return URLUtil.getHost(url);}
4c9ec82e8777bee39c94eaffbd42f3bf891ce1ff9da91c3080a6b85972806e5d
map
public void map(Text key, Writable value, Context context) throws IOException, InterruptedException
{        String keyStr = key.toString();        if (key instanceof Text && value instanceof CrawlDatum) {                buffer = filterNormalize(URLUtil.getHost(keyStr));                if (buffer == null) {            context.getCounter("UpdateHostDb", "filtered_records").increment(1);            LOG.info("UpdateHostDb: " + URLUtil.getHost(keyStr) + " crawldatum has been filtered");            return;        }                host.set(buffer);        crawlDatum = (CrawlDatum) value;        hostDatum = new HostDatum();                if (crawlDatum.getStatus() != CrawlDatum.STATUS_DB_UNFETCHED) {                        String protocol = URLUtil.getProtocol(keyStr);                        String homepage = protocol + "://" + buffer + "/";                        if (keyStr.equals(homepage)) {                                if (crawlDatum.getStatus() == CrawlDatum.STATUS_DB_REDIR_PERM || crawlDatum.getStatus() == CrawlDatum.STATUS_DB_REDIR_TEMP) {                                        ProtocolStatus z = (ProtocolStatus) crawlDatum.getMetaData().get(Nutch.WRITABLE_PROTO_STATUS_KEY);                                        args = z.getArgs();                                        reprUrl = args[0];                                        if (reprUrl != null) {                        LOG.info("UpdateHostDb: homepage: " + keyStr + " redirects to: " + args[0]);                        context.write(host, new NutchWritable(hostDatum));                        hostDatum.setHomepageUrl(reprUrl);                    } else {                        LOG.info("UpdateHostDb: homepage: " + keyStr + " redirects to: " + args[0] + " but has been filtered out");                    }                } else {                    hostDatum.setHomepageUrl(homepage);                    context.write(host, new NutchWritable(hostDatum));                    LOG.info("UpdateHostDb: homepage: " + homepage);                }            }        }                context.write(host, new NutchWritable(crawlDatum));    }        if (key instanceof Text && value instanceof HostDatum) {        buffer = filterNormalize(keyStr);                if (buffer == null) {            context.getCounter("UpdateHostDb", "filtered_records").increment(1);            LOG.info("UpdateHostDb: " + key.toString() + " hostdatum has been filtered");            return;        }                hostDatum = (HostDatum) value;        key.set(buffer);                if (readingCrawlDb) {            hostDatum.resetStatistics();        }        context.write(key, new NutchWritable(hostDatum));    }        if (key instanceof Text && value instanceof Text) {        buffer = filterNormalize(keyStr);                if (buffer == null) {            context.getCounter("UpdateHostDb", "filtered_records").increment(1);            LOG.info("UpdateHostDb: " + key.toString() + " score has been filtered");            return;        }        key.set(buffer);        context.write(key, new NutchWritable(new FloatWritable(Float.parseFloat(value.toString()))));    }}
d6122fbda441aab7dceb0e79e3ee68a11579a766c3122c91b2ed530f1501ff02
setup
public void setup(Reducer<Text, NutchWritable, Text, HostDatum>.Context context)
{    Configuration conf = context.getConfiguration();    purgeFailedHostsThreshold = conf.getInt(UpdateHostDb.HOSTDB_PURGE_FAILED_HOSTS_THRESHOLD, -1);    numResolverThreads = conf.getInt(UpdateHostDb.HOSTDB_NUM_RESOLVER_THREADS, 10);    recheckInterval = conf.getInt(UpdateHostDb.HOSTDB_RECHECK_INTERVAL, 86400) * 1000;    checkFailed = conf.getBoolean(UpdateHostDb.HOSTDB_CHECK_FAILED, false);    checkNew = conf.getBoolean(UpdateHostDb.HOSTDB_CHECK_NEW, false);    checkKnown = conf.getBoolean(UpdateHostDb.HOSTDB_CHECK_KNOWN, false);    force = conf.getBoolean(UpdateHostDb.HOSTDB_FORCE_CHECK, false);    numericFields = conf.getStrings(UpdateHostDb.HOSTDB_NUMERIC_FIELDS);    stringFields = conf.getStrings(UpdateHostDb.HOSTDB_STRING_FIELDS);    percentiles = conf.getInts(UpdateHostDb.HOSTDB_PERCENTILES);        if (numericFields != null) {        numericFieldWritables = new Text[numericFields.length];        for (int i = 0; i < numericFields.length; i++) {            numericFieldWritables[i] = new Text(numericFields[i]);        }    }    if (stringFields != null) {        stringFieldWritables = new Text[stringFields.length];        for (int i = 0; i < stringFields.length; i++) {            stringFieldWritables[i] = new Text(stringFields[i]);        }    }        executor = new ThreadPoolExecutor(numResolverThreads, numResolverThreads, 5, TimeUnit.SECONDS, queue);        executor.prestartAllCoreThreads();}
3a173d62b9c64632e8a5b3717dd7b139e87082c27f02e1c5ea40d48edc27b47b
reduce
public void reduce(Text key, Iterable<NutchWritable> values, Context context) throws IOException, InterruptedException
{    Map<String, Map<String, Long>> stringCounts = new HashMap<>();    Map<String, Float> maximums = new HashMap<>();        Map<String, Float> sums = new HashMap<>();        Map<String, Long> counts = new HashMap<>();    Map<String, Float> minimums = new HashMap<>();    Map<String, TDigest> tdigests = new HashMap<String, TDigest>();    HostDatum hostDatum = new HostDatum();    float score = 0;    if (stringFields != null) {        for (int i = 0; i < stringFields.length; i++) {            stringCounts.put(stringFields[i], new HashMap<>());        }    }        for (NutchWritable val : values) {                final Writable value = val.get();                if (value instanceof CrawlDatum) {            CrawlDatum buffer = (CrawlDatum) value;                        switch(buffer.getStatus()) {                case CrawlDatum.STATUS_DB_UNFETCHED:                    hostDatum.setUnfetched(hostDatum.getUnfetched() + 1l);                    break;                case CrawlDatum.STATUS_DB_FETCHED:                    hostDatum.setFetched(hostDatum.getFetched() + 1l);                    break;                case CrawlDatum.STATUS_DB_GONE:                    hostDatum.setGone(hostDatum.getGone() + 1l);                    break;                case CrawlDatum.STATUS_DB_REDIR_TEMP:                    hostDatum.setRedirTemp(hostDatum.getRedirTemp() + 1l);                    break;                case CrawlDatum.STATUS_DB_REDIR_PERM:                    hostDatum.setRedirPerm(hostDatum.getRedirPerm() + 1l);                    break;                case CrawlDatum.STATUS_DB_NOTMODIFIED:                    hostDatum.setNotModified(hostDatum.getNotModified() + 1l);                    break;            }                        if (buffer.getRetriesSinceFetch() != 0) {                hostDatum.incConnectionFailures();            }                        if (buffer.getStatus() == CrawlDatum.STATUS_DB_FETCHED || buffer.getStatus() == CrawlDatum.STATUS_DB_NOTMODIFIED) {                                if (stringFields != null) {                    for (int i = 0; i < stringFields.length; i++) {                                                if (buffer.getMetaData().get(stringFieldWritables[i]) != null) {                                                        String metadataValue = null;                            try {                                metadataValue = buffer.getMetaData().get(stringFieldWritables[i]).toString();                            } catch (Exception e) {                                LOG.error("Metadata field " + stringFields[i] + " is probably not a numeric value");                            }                                                        if (stringCounts.get(stringFields[i]).containsKey(metadataValue)) {                                                                stringCounts.get(stringFields[i]).put(metadataValue, stringCounts.get(stringFields[i]).get(metadataValue) + 1l);                            } else {                                                                stringCounts.get(stringFields[i]).put(metadataValue, 1l);                            }                        }                    }                }                                if (numericFields != null) {                    for (int i = 0; i < numericFields.length; i++) {                                                if (buffer.getMetaData().get(numericFieldWritables[i]) != null) {                            try {                                                                Float metadataValue = Float.parseFloat(buffer.getMetaData().get(numericFieldWritables[i]).toString());                                                                if (tdigests.containsKey(numericFields[i])) {                                    tdigests.get(numericFields[i]).add(metadataValue);                                } else {                                                                        TDigest tdigest = TDigest.createDigest(100);                                    tdigest.add((double) metadataValue);                                    tdigests.put(numericFields[i], tdigest);                                }                                                                if (minimums.containsKey(numericFields[i])) {                                                                        if (metadataValue < minimums.get(numericFields[i])) {                                        minimums.put(numericFields[i], metadataValue);                                    }                                } else {                                                                        minimums.put(numericFields[i], metadataValue);                                }                                                                if (maximums.containsKey(numericFields[i])) {                                                                        if (metadataValue > maximums.get(numericFields[i])) {                                        maximums.put(numericFields[i], metadataValue);                                    }                                } else {                                                                        maximums.put(numericFields[i], metadataValue);                                }                                                                if (sums.containsKey(numericFields[i])) {                                                                        sums.put(numericFields[i], sums.get(numericFields[i]) + metadataValue);                                    counts.put(numericFields[i], counts.get(numericFields[i]) + 1l);                                } else {                                                                        sums.put(numericFields[i], metadataValue);                                    counts.put(numericFields[i], 1l);                                }                            } catch (Exception e) {                                LOG.error(e.getMessage() + " when processing values for " + key.toString());                            }                        }                    }                }            }        } else         if (value instanceof HostDatum) {            HostDatum buffer = (HostDatum) value;                        if (buffer.hasHomepageUrl()) {                hostDatum.setHomepageUrl(buffer.getHomepageUrl());            }                        if (!buffer.isEmpty()) {                hostDatum.setLastCheck(buffer.getLastCheck());            }                        if (buffer.getDnsFailures() > 0) {                hostDatum.setDnsFailures(buffer.getDnsFailures());            }                        if (buffer.getConnectionFailures() > 0) {                hostDatum.setConnectionFailures(buffer.getConnectionFailures());            }                        if (!buffer.getMetaData().isEmpty()) {                hostDatum.setMetaData(buffer.getMetaData());            }                        if (buffer.getScore() > 0) {                hostDatum.setScore(buffer.getScore());            }        } else         if (value instanceof FloatWritable) {            FloatWritable buffer = (FloatWritable) value;            score = buffer.get();        } else {            LOG.error("Class {} not handled", value.getClass());        }    }        if (score > 0) {        hostDatum.setScore(score);    }        for (Map.Entry<String, Map<String, Long>> entry : stringCounts.entrySet()) {        for (Map.Entry<String, Long> subEntry : entry.getValue().entrySet()) {            hostDatum.getMetaData().put(new Text(entry.getKey() + "." + subEntry.getKey()), new LongWritable(subEntry.getValue()));        }    }    for (Map.Entry<String, Float> entry : maximums.entrySet()) {        hostDatum.getMetaData().put(new Text("max." + entry.getKey()), new FloatWritable(entry.getValue()));    }    for (Map.Entry<String, Float> entry : sums.entrySet()) {        hostDatum.getMetaData().put(new Text("avg." + entry.getKey()), new FloatWritable(entry.getValue() / counts.get(entry.getKey())));    }    for (Map.Entry<String, TDigest> entry : tdigests.entrySet()) {                for (int i = 0; i < percentiles.length; i++) {            hostDatum.getMetaData().put(new Text("pct" + Long.toString(percentiles[i]) + "." + entry.getKey()), new FloatWritable((float) entry.getValue().quantile(0.5)));        }    }    for (Map.Entry<String, Float> entry : minimums.entrySet()) {        hostDatum.getMetaData().put(new Text("min." + entry.getKey()), new FloatWritable(entry.getValue()));    }    context.getCounter("UpdateHostDb", "total_hosts").increment(1);        if (shouldCheck(hostDatum)) {                resolverThread = new ResolverThread(key.toString(), hostDatum, context, purgeFailedHostsThreshold);                try {            queue.put(resolverThread);        } catch (InterruptedException e) {            LOG.error("UpdateHostDb: " + StringUtils.stringifyException(e));        }                return;    } else {        context.getCounter("UpdateHostDb", "skipped_not_eligible").increment(1);        LOG.info("UpdateHostDb: " + key.toString() + ": skipped_not_eligible");    }        context.write(key, hostDatum);}
4db80efdfa55ed0083224c99473f642faf8ba12171321f7f2e92543f9bcde19f
shouldCheck
protected boolean shouldCheck(HostDatum datum)
{        if (checkNew && datum.isEmpty()) {        return true;    }        if (checkKnown && !datum.isEmpty() && datum.getDnsFailures() == 0) {        return isEligibleForCheck(datum);    }        if (checkFailed && datum.getDnsFailures() > 0) {        return isEligibleForCheck(datum);    }        return false;}
e5f2dd921b488a9cd3eec0a10f9ad002f9a6f08b6af7a8e6c7d64e69499b48ae
isEligibleForCheck
protected boolean isEligibleForCheck(HostDatum datum)
{        if (force || datum.getLastCheck().getTime() + (recheckInterval * datum.getDnsFailures() + 1) > now) {        return true;    }    return false;}
2778012f52c2a7f59c6c1765a2439ec3859291f93e8799745965b94d3103029c
cleanup
public void cleanup(Context context)
{    LOG.info("UpdateHostDb: feeder finished, waiting for shutdown");        executor.shutdown();    boolean finished = false;        while (!finished) {        try {                        if (!executor.isTerminated()) {                LOG.info("UpdateHostDb: resolver threads waiting: " + Integer.toString(executor.getPoolSize()));                Thread.sleep(1000);            } else {                                finished = true;            }        } catch (InterruptedException e) {                        LOG.warn(StringUtils.stringifyException(e));        }    }}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
c7247fbb9a78b0f2bf1b83c7a1cc1acc3831c597de4ebbf8907dd8852659368e
map
public void map(Text key, CrawlDatum value, Context context) throws IOException, InterruptedException
{    if (value.getStatus() == CrawlDatum.STATUS_DB_GONE || value.getStatus() == CrawlDatum.STATUS_DB_DUPLICATE) {        context.write(OUT, key);    }}
b7acaa45b74b578c75116fab7cd25a0f82a741c1e168a29459bcca44b0701653
setup
public void setup(Reducer<ByteWritable, Text, Text, ByteWritable>.Context context)
{    Configuration conf = context.getConfiguration();    writers = IndexWriters.get(conf);    try {        writers.open(conf, "Deletion");    } catch (IOException e) {        throw new RuntimeException(e);    }    noCommit = conf.getBoolean("noCommit", false);}
5280200a464ac0f0289c30b6dc02c096415969f50a3b9b7612ebdcf6285af5a3
cleanup
public void cleanup(Context context) throws IOException
{    if (totalDeleted > 0 && !noCommit) {        writers.commit();    }    writers.close();    LOG.info("CleaningJob: deleted a total of " + totalDeleted + " documents");}
7b3e239b2f42a512de034625ad59aac2eeb748032fe6d8c3b306e06bd17be90c
reduce
public void reduce(ByteWritable key, Iterable<Text> values, Context context) throws IOException
{    for (Text document : values) {        writers.delete(document.toString());        totalDeleted++;        context.getCounter("CleaningJobStatus", "Deleted documents").increment(1);                                        }}
9b0b80bde209cdd261c7ae818107509b59b40b52cc4191a771537b905f26bc78
delete
public void delete(String crawldb, boolean noCommit) throws IOException, InterruptedException, ClassNotFoundException
{    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    long start = System.currentTimeMillis();    LOG.info("CleaningJob: starting at " + sdf.format(start));    Job job = NutchJob.getInstance(getConf());    Configuration conf = job.getConfiguration();    FileInputFormat.addInputPath(job, new Path(crawldb, CrawlDb.CURRENT_NAME));    conf.setBoolean("noCommit", noCommit);    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setOutputFormatClass(NullOutputFormat.class);    job.setMapOutputKeyClass(ByteWritable.class);    job.setMapOutputValueClass(Text.class);    job.setMapperClass(DBFilter.class);    job.setReducerClass(DeleterReducer.class);    job.setJarByClass(CleaningJob.class);    job.setJobName("CleaningJob");        conf.setBoolean(IndexerMapReduce.INDEXER_DELETE, true);    try {        boolean success = job.waitForCompletion(true);        if (!success) {            String message = "CleaningJob did not succeed, job status:" + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);            throw new RuntimeException(message);        }    } catch (InterruptedException | ClassNotFoundException e) {        LOG.error(StringUtils.stringifyException(e));        throw e;    }    long end = System.currentTimeMillis();    LOG.info("CleaningJob: finished at " + sdf.format(end) + ", elapsed: " + TimingUtil.elapsedTime(start, end));}
d756081f6122b82915ed5d6542d8c0a46cde13d93e4e426add1fcd67fd99590a
run
public int run(String[] args) throws IOException
{    if (args.length < 1) {        String usage = "Usage: CleaningJob <crawldb> [-noCommit]";        LOG.error("Missing crawldb. " + usage);        System.err.println(usage);        return 1;    }    boolean noCommit = false;    if (args.length == 2 && args[1].equals("-noCommit")) {        noCommit = true;    }    try {        delete(args[0], noCommit);    } catch (final Exception e) {        LOG.error("CleaningJob: " + StringUtils.stringifyException(e));        System.err.println("ERROR CleaningJob: " + StringUtils.stringifyException(e));        return -1;    }    return 0;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int result = ToolRunner.run(NutchConfiguration.create(), new CleaningJob(), args);    System.exit(result);}
63d58dffcd74a4adddd87927dc8df85e6193bc5e61936fb4f4a5b2d6cddd136c
normalizeUrl
private static String normalizeUrl(String url, boolean normalize, URLNormalizers urlNormalizers)
{    if (!normalize) {        return url;    }    String normalized = null;    if (urlNormalizers != null) {        try {                        normalized = urlNormalizers.normalize(url, URLNormalizers.SCOPE_INDEXER);            normalized = normalized.trim();        } catch (Exception e) {            LOG.warn("Skipping " + url + ":" + e);            normalized = null;        }    }    return normalized;}
0e3111bc76a2dc9d4888446c6ecde57300504c4381094ec24ee9d72d3cdd8ac0
filterUrl
private static String filterUrl(String url, boolean filter, URLFilters urlFilters)
{    if (!filter) {        return url;    }    try {        url = urlFilters.filter(url);    } catch (Exception e) {        url = null;    }    return url;}
828efea1a07a16b05f247248072a0d2d0eb481455453c583f4002cb29e76342d
setup
public void setup(Mapper<Text, Writable, Text, NutchWritable>.Context context)
{    Configuration conf = context.getConfiguration();    normalize = conf.getBoolean(URL_NORMALIZING, false);    filter = conf.getBoolean(URL_FILTERING, false);    if (normalize) {        urlNormalizers = new URLNormalizers(conf, URLNormalizers.SCOPE_INDEXER);    }    if (filter) {        urlFilters = new URLFilters(conf);    }}
4c9ec82e8777bee39c94eaffbd42f3bf891ce1ff9da91c3080a6b85972806e5d
map
public void map(Text key, Writable value, Context context) throws IOException, InterruptedException
{    String urlString = filterUrl(normalizeUrl(key.toString(), normalize, urlNormalizers), filter, urlFilters);    if (urlString == null) {        return;    } else {        key.set(urlString);    }    context.write(key, new NutchWritable(value));}
f85dc3616075039f1d30ad5bdf5615efe73f5974012244f2322358a92b28463c
setup
public void setup(Reducer<Text, NutchWritable, Text, NutchIndexAction>.Context context)
{    Configuration conf = context.getConfiguration();    filters = new IndexingFilters(conf);    scfilters = new ScoringFilters(conf);    delete = conf.getBoolean(INDEXER_DELETE, false);    deleteRobotsNoIndex = conf.getBoolean(INDEXER_DELETE_ROBOTS_NOINDEX, false);    deleteSkippedByIndexingFilter = conf.getBoolean(INDEXER_DELETE_SKIPPED, false);    skip = conf.getBoolean(INDEXER_SKIP_NOTMODIFIED, false);    base64 = conf.getBoolean(INDEXER_BINARY_AS_BASE64, false);    normalize = conf.getBoolean(URL_NORMALIZING, false);    filter = conf.getBoolean(URL_FILTERING, false);    if (normalize) {        urlNormalizers = new URLNormalizers(conf, URLNormalizers.SCOPE_INDEXER);    }    if (filter) {        urlFilters = new URLFilters(conf);    }}
3a173d62b9c64632e8a5b3717dd7b139e87082c27f02e1c5ea40d48edc27b47b
reduce
public void reduce(Text key, Iterable<NutchWritable> values, Context context) throws IOException, InterruptedException
{    Inlinks inlinks = null;    CrawlDatum dbDatum = null;    CrawlDatum fetchDatum = null;    Content content = null;    ParseData parseData = null;    ParseText parseText = null;    for (NutchWritable val : values) {                final Writable value = val.get();        if (value instanceof Inlinks) {            inlinks = (Inlinks) value;        } else if (value instanceof CrawlDatum) {            final CrawlDatum datum = (CrawlDatum) value;            if (CrawlDatum.hasDbStatus(datum)) {                dbDatum = datum;            } else if (CrawlDatum.hasFetchStatus(datum)) {                                if (datum.getStatus() != CrawlDatum.STATUS_FETCH_NOTMODIFIED) {                    fetchDatum = datum;                }            } else if (CrawlDatum.STATUS_LINKED == datum.getStatus() || CrawlDatum.STATUS_SIGNATURE == datum.getStatus() || CrawlDatum.STATUS_PARSE_META == datum.getStatus()) {                continue;            } else {                throw new RuntimeException("Unexpected status: " + datum.getStatus());            }        } else if (value instanceof ParseData) {            parseData = (ParseData) value;                        if (deleteRobotsNoIndex) {                                String robotsMeta = parseData.getMeta("robots");                                if (robotsMeta != null && robotsMeta.toLowerCase().indexOf("noindex") != -1) {                                        context.write(key, DELETE_ACTION);                    context.getCounter("IndexerStatus", "deleted (robots=noindex)").increment(1);                    return;                }            }        } else if (value instanceof ParseText) {            parseText = (ParseText) value;        } else if (value instanceof Content) {            content = (Content) value;        } else if (LOG.isWarnEnabled()) {            LOG.warn("Unrecognized type: " + value.getClass());        }    }        if (delete && fetchDatum != null) {        if (fetchDatum.getStatus() == CrawlDatum.STATUS_FETCH_GONE || dbDatum != null && dbDatum.getStatus() == CrawlDatum.STATUS_DB_GONE) {            context.getCounter("IndexerStatus", "deleted (gone)").increment(1);            context.write(key, DELETE_ACTION);            return;        }        if (fetchDatum.getStatus() == CrawlDatum.STATUS_FETCH_REDIR_PERM || fetchDatum.getStatus() == CrawlDatum.STATUS_FETCH_REDIR_TEMP || dbDatum != null && dbDatum.getStatus() == CrawlDatum.STATUS_DB_REDIR_PERM || dbDatum != null && dbDatum.getStatus() == CrawlDatum.STATUS_DB_REDIR_TEMP) {            context.getCounter("IndexerStatus", "deleted (redirects)").increment(1);            context.write(key, DELETE_ACTION);            return;        }    }    if (fetchDatum == null || parseText == null || parseData == null) {                return;    }        if (delete && dbDatum != null && dbDatum.getStatus() == CrawlDatum.STATUS_DB_DUPLICATE) {        context.getCounter("IndexerStatus", "deleted (duplicates)").increment(1);        context.write(key, DELETE_ACTION);        return;    }        if (skip && dbDatum != null && dbDatum.getStatus() == CrawlDatum.STATUS_DB_NOTMODIFIED) {        context.getCounter("IndexerStatus", "skipped (not modified)").increment(1);        return;    }    if (!parseData.getStatus().isSuccess() || fetchDatum.getStatus() != CrawlDatum.STATUS_FETCH_SUCCESS) {        return;    }    NutchDocument doc = new NutchDocument();    doc.add("id", key.toString());    final Metadata metadata = parseData.getContentMeta();        doc.add("segment", metadata.get(Nutch.SEGMENT_NAME_KEY));        doc.add("digest", metadata.get(Nutch.SIGNATURE_KEY));    final Parse parse = new ParseImpl(parseText, parseData);    float boost = 1.0f;        try {        boost = scfilters.indexerScore(key, doc, dbDatum, fetchDatum, parse, inlinks, boost);    } catch (final ScoringFilterException e) {        context.getCounter("IndexerStatus", "errors (ScoringFilter)").increment(1);        if (LOG.isWarnEnabled()) {            LOG.warn("Error calculating score {}: {}", key, e);        }        return;    }        doc.setWeight(boost);        doc.add("boost", Float.toString(boost));    try {        if (dbDatum != null) {                        fetchDatum.setSignature(dbDatum.getSignature());                                    final Text url = (Text) dbDatum.getMetaData().get(Nutch.WRITABLE_REPR_URL_KEY);            if (url != null) {                                                                                String urlString = filterUrl(normalizeUrl(key.toString(), normalize, urlNormalizers), filter, urlFilters);                if (urlString != null) {                    url.set(urlString);                    fetchDatum.getMetaData().put(Nutch.WRITABLE_REPR_URL_KEY, url);                }            }        }                doc = filters.filter(doc, parse, key, fetchDatum, inlinks);    } catch (final IndexingException e) {        if (LOG.isWarnEnabled()) {            LOG.warn("Error indexing " + key + ": " + e);        }        context.getCounter("IndexerStatus", "errors (IndexingFilter)").increment(1);        return;    }        if (doc == null) {                if (deleteSkippedByIndexingFilter) {            NutchIndexAction action = new NutchIndexAction(null, NutchIndexAction.DELETE);            context.write(key, action);            context.getCounter("IndexerStatus", "deleted (IndexingFilter)").increment(1);        } else {            context.getCounter("IndexerStatus", "skipped (IndexingFilter)").increment(1);        }        return;    }    if (content != null) {                String binary;        if (base64) {                                                            binary = StringUtils.newStringUtf8(Base64.encodeBase64(content.getContent(), false, false));        } else {            binary = new String(content.getContent());        }        doc.add("binaryContent", binary);    }    context.getCounter("IndexerStatus", "indexed (add/update)").increment(1);    NutchIndexAction action = new NutchIndexAction(doc, NutchIndexAction.ADD);    context.write(key, action);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{}
15735184fa7a84227c45cca916d877972d5533df72e900b951368384c97484f5
initMRJob
public static void initMRJob(Path crawlDb, Path linkDb, Collection<Path> segments, Job job, boolean addBinaryContent) throws IOException
{    LOG.info("IndexerMapReduce: crawldb: {}", crawlDb);    if (linkDb != null)        LOG.info("IndexerMapReduce: linkdb: {}", linkDb);    Configuration conf = job.getConfiguration();    for (final Path segment : segments) {        LOG.info("IndexerMapReduces: adding segment: {}", segment);        FileInputFormat.addInputPath(job, new Path(segment, CrawlDatum.FETCH_DIR_NAME));        FileInputFormat.addInputPath(job, new Path(segment, CrawlDatum.PARSE_DIR_NAME));        FileInputFormat.addInputPath(job, new Path(segment, ParseData.DIR_NAME));        FileInputFormat.addInputPath(job, new Path(segment, ParseText.DIR_NAME));        if (addBinaryContent) {            FileInputFormat.addInputPath(job, new Path(segment, Content.DIR_NAME));        }    }    FileInputFormat.addInputPath(job, new Path(crawlDb, CrawlDb.CURRENT_NAME));    if (linkDb != null) {        Path currentLinkDb = new Path(linkDb, LinkDb.CURRENT_NAME);        try {            if (currentLinkDb.getFileSystem(conf).exists(currentLinkDb)) {                FileInputFormat.addInputPath(job, currentLinkDb);            } else {                LOG.warn("Ignoring linkDb for indexing, no linkDb found in path: {}", linkDb);            }        } catch (IOException e) {            LOG.warn("Failed to use linkDb ({}) for indexing: {}", linkDb, org.apache.hadoop.util.StringUtils.stringifyException(e));        }    }    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setJarByClass(IndexerMapReduce.class);    job.setMapperClass(IndexerMapReduce.IndexerMapper.class);    job.setReducerClass(IndexerMapReduce.IndexerReducer.class);    job.setOutputFormatClass(IndexerOutputFormat.class);    job.setOutputKeyClass(Text.class);    job.setMapOutputValueClass(NutchWritable.class);    job.setOutputValueClass(NutchWritable.class);}
e9b610ee03cb21d3b9ce352a9d51da21bb04f94d42445b97f2e27767eafb8088
getRecordWriter
public RecordWriter<Text, NutchIndexAction> getRecordWriter(TaskAttemptContext context) throws IOException
{    Configuration conf = context.getConfiguration();    final IndexWriters writers = IndexWriters.get(conf);    String name = getUniqueFile(context, "part", "");    writers.open(conf, name);    LOG.info(writers.describe());    return new RecordWriter<Text, NutchIndexAction>() {        public void close(TaskAttemptContext context) throws IOException {                        boolean noCommit = conf.getBoolean(IndexerMapReduce.INDEXER_NO_COMMIT, false);            if (!noCommit) {                writers.commit();            }            writers.close();        }        public void write(Text key, NutchIndexAction indexAction) throws IOException {            if (indexAction.action == NutchIndexAction.ADD) {                writers.write(indexAction.doc);            } else if (indexAction.action == NutchIndexAction.DELETE) {                writers.delete(key.toString());            }        }    };}
118202e50c9711dbea3c9045d10f01c58e2fd2ce631f1eb50a35dad80b983835
close
public void close(TaskAttemptContext context) throws IOException
{        boolean noCommit = conf.getBoolean(IndexerMapReduce.INDEXER_NO_COMMIT, false);    if (!noCommit) {        writers.commit();    }    writers.close();}
b1c9c3e5c530eb819903dc75e442c0c5f0ed5a95e87b920e5ea93a4c780027fa
write
public void write(Text key, NutchIndexAction indexAction) throws IOException
{    if (indexAction.action == NutchIndexAction.ADD) {        writers.write(indexAction.doc);    } else if (indexAction.action == NutchIndexAction.DELETE) {        writers.delete(key.toString());    }}
8fa98404280fecfd497ce9400c07196998fbeaf2ee8524779c09bd3c220d4ea9
filter
public NutchDocument filter(NutchDocument doc, Parse parse, Text url, CrawlDatum datum, Inlinks inlinks) throws IndexingException
{    for (int i = 0; i < this.indexingFilters.length; i++) {        doc = this.indexingFilters[i].filter(doc, parse, url, datum, inlinks);                if (doc == null)            return null;    }    return doc;}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    String url = null;    String usage =     "Usage:\n" +     "  IndexingFiltersChecker [OPTIONS] <url>\n" +     "    Fetch single URL and index it\n" +     "  IndexingFiltersChecker [OPTIONS] -stdin\n" +     "    Read URLs to be indexed from stdin\n" +     "  IndexingFiltersChecker [OPTIONS] -listen <port> [-keepClientCnxOpen]\n" +     "    Listen on <port> for URLs to be indexed\n" +     "Options:\n" +     "  -D<property>=<value>\tset/overwrite Nutch/Hadoop properties\n" +     "                  \t(a generic Hadoop option to be passed\n" + "                  \t before other command-specific options)\n" +     "  -normalize      \tnormalize URLs\n" +     "  -followRedirects\tfollow redirects when fetching URL\n" +     "  -dumpText       \tshow the entire plain-text content,\n" +     "                  \tnot only the first 100 characters\n" +     "  -doIndex        \tpass document to configured index writers\n" +     "                  \tand let them index it\n" + "  -md <key>=<value>\tmetadata added to CrawlDatum before parsing\n";        if (args.length < 1) {        System.err.println(usage);        System.exit(-1);    }        doIndex = getConf().getBoolean("doIndex", false);    int numConsumed;    for (int i = 0; i < args.length; i++) {        if (args[i].equals("-normalize")) {            normalizers = new URLNormalizers(getConf(), URLNormalizers.SCOPE_DEFAULT);        } else if (args[i].equals("-followRedirects")) {            followRedirects = true;        } else if (args[i].equals("-dumpText")) {            dumpText = true;        } else if (args[i].equals("-doIndex")) {            doIndex = true;        } else if (args[i].equals("-md")) {            String k = null, v = null;            String nextOne = args[++i];            int firstEquals = nextOne.indexOf("=");            if (firstEquals != -1) {                k = nextOne.substring(0, firstEquals);                v = nextOne.substring(firstEquals + 1);            } else                k = nextOne;            metadata.put(k, v);        } else if ((numConsumed = super.parseArgs(args, i)) > 0) {            i += numConsumed - 1;        } else if (i != args.length - 1) {            System.err.println("ERR: Not a recognized argument: " + args[i]);            System.err.println(usage);            System.exit(-1);        } else {            url = args[i];        }    }    if (url != null) {        return super.processSingle(url);    } else {                return super.run();    }}
563ec4efd6e4e3fda75530afd24463760e6ea1470b0992ce11ca2059e645f277
process
protected int process(String url, StringBuilder output) throws Exception
{    if (normalizers != null) {        url = normalizers.normalize(url, URLNormalizers.SCOPE_DEFAULT);    }    LOG.info("fetching: " + url);    CrawlDatum datum = new CrawlDatum();    Iterator<String> iter = metadata.keySet().iterator();    while (iter.hasNext()) {        String key = iter.next();        String value = metadata.get(key);        if (value == null)            value = "";        datum.getMetaData().put(new Text(key), new Text(value));    }    int maxRedirects = getConf().getInt("http.redirect.max", 3);    if (followRedirects) {        if (maxRedirects == 0) {            LOG.info("Following max. 3 redirects (ignored http.redirect.max == 0)");            maxRedirects = 3;        } else {            LOG.info("Following max. {} redirects", maxRedirects);        }    }    ProtocolOutput protocolOutput = getProtocolOutput(url, datum);    Text turl = new Text(url);        int numRedirects = 0;    while (!protocolOutput.getStatus().isSuccess() && followRedirects && protocolOutput.getStatus().isRedirect() && maxRedirects >= numRedirects) {        String[] stuff = protocolOutput.getStatus().getArgs();        url = stuff[0];        LOG.info("Follow redirect to {}", url);        if (normalizers != null) {            url = normalizers.normalize(url, URLNormalizers.SCOPE_DEFAULT);        }        turl.set(url);                protocolOutput = getProtocolOutput(url, datum);        numRedirects++;    }    if (!protocolOutput.getStatus().isSuccess()) {        System.err.println("Fetch failed with protocol status: " + protocolOutput.getStatus());        if (protocolOutput.getStatus().isRedirect()) {            System.err.println("Redirect(s) not handled due to configuration.");            System.err.println("Max Redirects to handle per config: " + maxRedirects);            System.err.println("Number of Redirects handled: " + numRedirects);        }        return -1;    }    Content content = protocolOutput.getContent();    if (content == null) {        output.append("No content for " + url + "\n");        return 0;    }    String contentType = content.getContentType();    if (contentType == null) {        LOG.error("Failed to determine content type!");        return -1;    }        datum.getMetaData().put(new Text(Metadata.CONTENT_TYPE), new Text(contentType));    if (ParseSegment.isTruncated(content)) {        LOG.warn("Content is truncated, parse may fail!");    }    ScoringFilters scfilters = new ScoringFilters(getConf());        try {        scfilters.passScoreBeforeParsing(turl, datum, content);    } catch (Exception e) {        LOG.warn("Couldn't pass score, url {} ({})", url, e);    }    LOG.info("parsing: {}", url);    LOG.info("contentType: {}", contentType);    ParseResult parseResult = new ParseUtil(getConf()).parse(content);    NutchDocument doc = new NutchDocument();    doc.add("id", url);    Text urlText = new Text(url);    Inlinks inlinks = null;    Parse parse = parseResult.get(urlText);    if (parse == null) {        LOG.error("Failed to get parse from parse result");        LOG.error("Available parses in parse result (by URL key):");        for (Map.Entry<Text, Parse> entry : parseResult) {            LOG.error("  " + entry.getKey());        }        LOG.error("Parse result does not contain a parse for URL to be checked:");        LOG.error("  " + urlText);        return -1;    }    byte[] signature = SignatureFactory.getSignature(getConf()).calculate(content, parse);    parse.getData().getContentMeta().set(Nutch.SIGNATURE_KEY, StringUtil.toHexString(signature));    String digest = parse.getData().getContentMeta().get(Nutch.SIGNATURE_KEY);    doc.add("digest", digest);    datum.setSignature(signature);        try {        scfilters.passScoreAfterParsing(turl, content, parseResult.get(turl));    } catch (Exception e) {        LOG.warn("Couldn't pass score, url {} ({})", turl, e);    }    IndexingFilters indexers = new IndexingFilters(getConf());    try {        doc = indexers.filter(doc, parse, urlText, datum, inlinks);    } catch (IndexingException e) {        e.printStackTrace();    }    if (doc == null) {        output.append("Document discarded by indexing filter\n");        return 0;    }    for (String fname : doc.getFieldNames()) {        List<Object> values = doc.getField(fname).getValues();        if (values != null) {            for (Object value : values) {                String str = value.toString();                int minText = dumpText ? str.length() : Math.min(100, str.length());                output.append(fname + " :\t" + str.substring(0, minText) + "\n");            }        }    }        output.append("\n");    if (doIndex) {        IndexWriters writers = IndexWriters.get(getConf());        writers.open(getConf(), "IndexingFilterChecker");        writers.write(doc);        writers.close();    }    return 0;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    final int res = ToolRunner.run(NutchConfiguration.create(), new IndexingFiltersChecker(), args);    System.exit(res);}
89fcd55f732ac1ab08549f322ee7d401bd78193c219de343b6114e77b1d567cd
index
public void index(Path crawlDb, Path linkDb, List<Path> segments, boolean noCommit) throws IOException, InterruptedException, ClassNotFoundException
{    index(crawlDb, linkDb, segments, noCommit, false, null);}
f19e7ace30efad728e30bebac7fe9c4d4b55145ac6328e9c7ae143ad3e68c583
index
public void index(Path crawlDb, Path linkDb, List<Path> segments, boolean noCommit, boolean deleteGone) throws IOException, InterruptedException, ClassNotFoundException
{    index(crawlDb, linkDb, segments, noCommit, deleteGone, null);}
f840e433613d17f47b16514aa842664d1c2cab330f36b37e4b9dd9e60770bb4a
index
public void index(Path crawlDb, Path linkDb, List<Path> segments, boolean noCommit, boolean deleteGone, String params) throws IOException, InterruptedException, ClassNotFoundException
{    index(crawlDb, linkDb, segments, noCommit, deleteGone, params, false, false);}
c0f9c73b212a0a21adae862ac8086707dc7f60488f69535df6def1ccced96a51
index
public void index(Path crawlDb, Path linkDb, List<Path> segments, boolean noCommit, boolean deleteGone, String params, boolean filter, boolean normalize) throws IOException, InterruptedException, ClassNotFoundException
{    index(crawlDb, linkDb, segments, noCommit, deleteGone, params, false, false, false);}
983f03055d941a834e5cf19175a7e1b387a996fbfc8f064b727bd84bb9eba103
index
public void index(Path crawlDb, Path linkDb, List<Path> segments, boolean noCommit, boolean deleteGone, String params, boolean filter, boolean normalize, boolean addBinaryContent) throws IOException, InterruptedException, ClassNotFoundException
{    index(crawlDb, linkDb, segments, noCommit, deleteGone, params, false, false, false, false);}
8bbf1ee1b8a39c8c2e07f8ad12a1e83ca156c67889782129c36dd844fbcc4ea8
index
public void index(Path crawlDb, Path linkDb, List<Path> segments, boolean noCommit, boolean deleteGone, String params, boolean filter, boolean normalize, boolean addBinaryContent, boolean base64) throws IOException, InterruptedException, ClassNotFoundException
{    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    long start = System.currentTimeMillis();    LOG.info("Indexer: starting at {}", sdf.format(start));    final Job job = NutchJob.getInstance(getConf());    job.setJobName("Indexer");    Configuration conf = job.getConfiguration();    LOG.info("Indexer: deleting gone documents: {}", deleteGone);    LOG.info("Indexer: URL filtering: {}", filter);    LOG.info("Indexer: URL normalizing: {}", normalize);    if (addBinaryContent) {        if (base64) {            LOG.info("Indexer: adding binary content as Base64");        } else {            LOG.info("Indexer: adding binary content");        }    }    IndexerMapReduce.initMRJob(crawlDb, linkDb, segments, job, addBinaryContent);    conf.setBoolean(IndexerMapReduce.INDEXER_DELETE, deleteGone);    conf.setBoolean(IndexerMapReduce.URL_FILTERING, filter);    conf.setBoolean(IndexerMapReduce.URL_NORMALIZING, normalize);    conf.setBoolean(IndexerMapReduce.INDEXER_BINARY_AS_BASE64, base64);    conf.setBoolean(IndexerMapReduce.INDEXER_NO_COMMIT, noCommit);    if (params != null) {        conf.set(IndexerMapReduce.INDEXER_PARAMS, params);    }    job.setReduceSpeculativeExecution(false);    final Path tmp = new Path("tmp_" + System.currentTimeMillis() + "-" + new Random().nextInt());    FileOutputFormat.setOutputPath(job, tmp);    try {        try {            boolean success = job.waitForCompletion(true);            if (!success) {                String message = "Indexing job did not succeed, job status:" + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();                LOG.error(message);                throw new RuntimeException(message);            }        } catch (IOException | InterruptedException | ClassNotFoundException e) {            LOG.error(StringUtils.stringifyException(e));            throw e;        }        LOG.info("Indexer: number of documents indexed, deleted, or skipped:");        for (Counter counter : job.getCounters().getGroup("IndexerStatus")) {            LOG.info("Indexer: {}  {}", String.format(Locale.ROOT, "%6d", counter.getValue()), counter.getName());        }        long end = System.currentTimeMillis();        LOG.info("Indexer: finished at " + sdf.format(end) + ", elapsed: " + TimingUtil.elapsedTime(start, end));    } finally {        tmp.getFileSystem(conf).delete(tmp, true);    }}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    if (args.length < 2) {        System.err.println("Usage: Indexer <crawldb> [-linkdb <linkdb>] [-params k1=v1&k2=v2...] (<segment> ... | -dir <segments>) [-noCommit] [-deleteGone] [-filter] [-normalize] [-addBinaryContent] [-base64]");        return -1;    }    final Path crawlDb = new Path(args[0]);    Path linkDb = null;    final List<Path> segments = new ArrayList<>();    String params = null;    boolean noCommit = false;    boolean deleteGone = false;    boolean filter = false;    boolean normalize = false;    boolean addBinaryContent = false;    boolean base64 = false;    for (int i = 1; i < args.length; i++) {        FileSystem fs = null;        Path dir = null;        if (args[i].equals("-linkdb")) {            linkDb = new Path(args[++i]);        } else if (args[i].equals("-dir")) {            dir = new Path(args[++i]);            fs = dir.getFileSystem(getConf());            FileStatus[] fstats = fs.listStatus(dir, HadoopFSUtil.getPassDirectoriesFilter(fs));            Path[] files = HadoopFSUtil.getPaths(fstats);            for (Path p : files) {                if (SegmentChecker.isIndexable(p, fs)) {                    segments.add(p);                }            }        } else if (args[i].equals("-noCommit")) {            noCommit = true;        } else if (args[i].equals("-deleteGone")) {            deleteGone = true;        } else if (args[i].equals("-filter")) {            filter = true;        } else if (args[i].equals("-normalize")) {            normalize = true;        } else if (args[i].equals("-addBinaryContent")) {            addBinaryContent = true;        } else if (args[i].equals("-base64")) {            base64 = true;        } else if (args[i].equals("-params")) {            params = args[++i];        } else {            dir = new Path(args[i]);            fs = dir.getFileSystem(getConf());            if (SegmentChecker.isIndexable(dir, fs)) {                segments.add(dir);            }        }    }    try {        index(crawlDb, linkDb, segments, noCommit, deleteGone, params, filter, normalize, addBinaryContent, base64);        return 0;    } catch (final Exception e) {        LOG.error("Indexer: {}", StringUtils.stringifyException(e));        return -1;    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    final int res = ToolRunner.run(NutchConfiguration.create(), new IndexingJob(), args);    System.exit(res);}
084523121ab64bd9486b37875e438171d2b2467ace02bce8523551b0ce84ace4
run
public Map<String, Object> run(Map<String, Object> args, String crawlId) throws Exception
{    boolean noCommit = false;    boolean deleteGone = false;    boolean filter = false;    boolean normalize = false;    boolean isSegment = false;    String params = null;    Configuration conf = getConf();    Path crawlDb;    if (args.containsKey(Nutch.ARG_CRAWLDB)) {        Object crawldbPath = args.get(Nutch.ARG_CRAWLDB);        if (crawldbPath instanceof Path) {            crawlDb = (Path) crawldbPath;        } else {            crawlDb = new Path(crawldbPath.toString());        }    } else {        crawlDb = new Path(crawlId + "/crawldb");    }    Path linkdb = null;    List<Path> segments = new ArrayList<>();    if (args.containsKey(Nutch.ARG_LINKDB)) {        Object path = args.get(Nutch.ARG_LINKDB);        if (path instanceof Path) {            linkdb = (Path) path;        } else {            linkdb = new Path(path.toString());        }    } else {        linkdb = new Path(crawlId + "/linkdb");    }    if (args.containsKey(Nutch.ARG_SEGMENTDIR)) {        isSegment = true;        Path segmentsDir;        Object segDir = args.get(Nutch.ARG_SEGMENTDIR);        if (segDir instanceof Path) {            segmentsDir = (Path) segDir;        } else {            segmentsDir = new Path(segDir.toString());        }        FileSystem fs = segmentsDir.getFileSystem(getConf());        FileStatus[] fstats = fs.listStatus(segmentsDir, HadoopFSUtil.getPassDirectoriesFilter(fs));        Path[] files = HadoopFSUtil.getPaths(fstats);        for (Path p : files) {            if (SegmentChecker.isIndexable(p, fs)) {                segments.add(p);            }        }    }    if (args.containsKey(Nutch.ARG_SEGMENTS)) {        Object segmentsFromArg = args.get(Nutch.ARG_SEGMENTS);        ArrayList<String> segmentList = new ArrayList<String>();        if (segmentsFromArg instanceof ArrayList) {            segmentList = (ArrayList<String>) segmentsFromArg;        } else if (segmentsFromArg instanceof Path) {            segmentList.add(segmentsFromArg.toString());        }        for (String segment : segmentList) {            segments.add(new Path(segment));        }    }    if (!isSegment) {        String segment_dir = crawlId + "/segments";        File segmentsDir = new File(segment_dir);        File[] segmentsList = segmentsDir.listFiles();        Arrays.sort(segmentsList, (f1, f2) -> {            if (f1.lastModified() > f2.lastModified())                return -1;            else                return 0;        });        Path segment = new Path(segmentsList[0].getPath());        segments.add(segment);    }    if (args.containsKey("noCommit")) {        noCommit = true;    }    if (args.containsKey("deleteGone")) {        deleteGone = true;    }    if (args.containsKey("normalize")) {        normalize = true;    }    if (args.containsKey("filter")) {        filter = true;    }    if (args.containsKey("params")) {        params = (String) args.get("params");    }    setConf(conf);    index(crawlDb, linkdb, segments, noCommit, deleteGone, params, filter, normalize);    Map<String, Object> results = new HashMap<>();    results.put(Nutch.VAL_RESULT, 0);    return results;}
3211504d80e38cb6279cf5b7700c8f4808623616f2bf099ce3184423cacacb31
getInstanceFromElement
 static IndexWriterConfig getInstanceFromElement(Element rootElement)
{    String id = rootElement.getAttribute("id");    String clazz = rootElement.getAttribute("class");    NodeList parametersList = rootElement.getElementsByTagName("param");    Map<String, String> parameters = new HashMap<>();    for (int i = 0; i < parametersList.getLength(); i++) {        Element parameterNode = (Element) parametersList.item(i);        parameters.put(parameterNode.getAttribute("name"), parameterNode.getAttribute("value"));    }    return new IndexWriterConfig(id, clazz, parameters, MappingReader.parseMapping((Element) rootElement.getElementsByTagName("mapping").item(0)));}
fcf6f1f3f3089d2f28008ff9f3d791d4eff41e4cace8960a930bfd186bc7eb40
getId
 String getId()
{    return id;}
2b08fd7ff5dd2b20ede350554410209b867b1ca492c36ff1b1355d32ec7185e7
getClazz
 String getClazz()
{    return clazz;}
46acbfceceeb1d63645c3bb191380716ea41eeb083d1969f49995c1ba1598c7c
getParams
 IndexWriterParams getParams()
{    return params;}
beca6d8c6da141149dac2c082b9070e7c29222708b4551a0c39ec8a6116dc98a
getMapping
 Map<MappingReader.Actions, Map<String, List<String>>> getMapping()
{    return mapping;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder();    sb.append("ID: ");    sb.append(id);    sb.append("\n");    sb.append("Class: ");    sb.append(clazz);    sb.append("\n");    sb.append("Params {\n");    for (Map.Entry<String, String> entry : params.entrySet()) {        sb.append("\t");        sb.append(entry.getKey());        sb.append(":\t");        sb.append(entry.getValue());        sb.append("\n");    }    sb.append("}\n");    sb.append("Mapping {\n");    for (Map.Entry<MappingReader.Actions, Map<String, List<String>>> entry : mapping.entrySet()) {        sb.append("\t");        sb.append(entry.getKey());        sb.append(" {\n");        for (Map.Entry<String, List<String>> entry1 : entry.getValue().entrySet()) {            sb.append("\t\t");            sb.append(entry1.getKey());            sb.append(":\t");            sb.append(String.join(",", entry1.getValue()));            sb.append("\n");        }        sb.append("\t}\n");    }    sb.append("}\n");    return sb.toString();}
43bc38669aa8036f98c68a70f4ecfe38e746f84c9b9025689746c64b6ce8ef71
get
public String get(String name, String defaultValue)
{    return this.getOrDefault(name, defaultValue);}
3197d6464d19d658f4372e80017a96934ac33f5143c86ef2bb59aeb36d356fa3
getBoolean
public boolean getBoolean(String name, boolean defaultValue)
{    String value;    if ((value = this.get(name)) != null && !"".equals(value)) {        return Boolean.parseBoolean(value);    }    return defaultValue;}
83c7110fe4ce0eea5fb447231831bd459d47abd7fee2318fa95cff8b19b2c2e3
getLong
public long getLong(String name, long defaultValue)
{    String value;    if ((value = this.get(name)) != null && !"".equals(value)) {        return Long.parseLong(value);    }    return defaultValue;}
565763a699f335b53a4d96f65d9bfba4c88f0e6153542c9a40eac5b24696a1f6
getInt
public int getInt(String name, int defaultValue)
{    String value;    if ((value = this.get(name)) != null && !"".equals(value)) {        return Integer.parseInt(value);    }    return defaultValue;}
cbfd708bc3393df4844b0bf5f4df63353cde35f898a75b4d596aac3c5d25e812
getStrings
public String[] getStrings(String name)
{    String value = this.get(name);    return StringUtils.getStrings(value);}
75e0e7b46ce362eabe350a07702efbd204bb1cba48d57bc9a3aeb0dc62e8a2c5
getStrings
public String[] getStrings(String name, String... defaultValue)
{    String value;    if ((value = this.get(name)) != null && !"".equals(value)) {        return StringUtils.getStrings(value);    }    return defaultValue;}
07bca31073a0ee1fe560d657b03e5c00c803f92133b4af70898ca2021226f210
get
public static synchronized IndexWriters get(Configuration conf)
{    String uuid = NutchConfiguration.getUUID(conf);    if (uuid == null) {                uuid = "nonNutchConf@" + conf.hashCode();    }    return CACHE.computeIfAbsent(uuid, k -> new IndexWriters(conf));}
00965edc4526af635926d215d0e6494ca1b58950b34bc6a00790cd85c1804a70
loadWritersConfiguration
private IndexWriterConfig[] loadWritersConfiguration(Configuration conf)
{    String filename = conf.get("indexer.indexwriters.file", "index-writers.xml");    InputStream ssInputStream = conf.getConfResourceAsInputStream(filename);    InputSource inputSource = new InputSource(ssInputStream);    try {        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();        DocumentBuilder builder = factory.newDocumentBuilder();        Document document = builder.parse(inputSource);        Element rootElement = document.getDocumentElement();        NodeList writerList = rootElement.getElementsByTagName("writer");        IndexWriterConfig[] indexWriterConfigs = new IndexWriterConfig[writerList.getLength()];        for (int i = 0; i < writerList.getLength(); i++) {            indexWriterConfigs[i] = IndexWriterConfig.getInstanceFromElement((Element) writerList.item(i));        }        return indexWriterConfigs;    } catch (SAXException | IOException | ParserConfigurationException e) {        LOG.error(e.toString());        return new IndexWriterConfig[0];    }}
7f7271ede9486ea1886118b6f06018d2bea954f3a38c8e53d4c0299d2be6991c
mapDocument
private NutchDocument mapDocument(final NutchDocument document, final Map<MappingReader.Actions, Map<String, List<String>>> mapping)
{    try {        NutchDocument mappedDocument = document.clone();        mapping.get(MappingReader.Actions.COPY).forEach((key, value) -> {                        if (mappedDocument.getField(key) != null) {                for (String field : value) {                                        if (!key.equals(field)) {                        for (Object val : mappedDocument.getField(key).getValues()) {                            mappedDocument.add(field, val);                        }                    }                }            }        });        mapping.get(MappingReader.Actions.RENAME).forEach((key, value) -> {                        if (mappedDocument.getField(key) != null) {                NutchField field = mappedDocument.removeField(key);                mappedDocument.add(value.get(0), field.getValues());                mappedDocument.getField(value.get(0)).setWeight(field.getWeight());            }        });        mapping.get(MappingReader.Actions.REMOVE).forEach((key, value) -> mappedDocument.removeField(key));        return mappedDocument;    } catch (CloneNotSupportedException e) {        LOG.warn("An instance of class {} can't be cloned.", document.getClass().getName());        return document;    }}
184adff0e3e70c82f3e392d2a630c403a8f49eea5e14fbd979c0263629c7fef7
getIndexWriters
private Collection<String> getIndexWriters(NutchDocument doc)
{    if (this.exchanges.areAvailableExchanges()) {        return Arrays.asList(this.exchanges.indexWriters(doc));    }    return this.indexWriters.keySet();}
18802229aeca38b5cc61ddfa505a9bf38ba2840d5872fa162a646fc53b96b5ec
open
public void open(Configuration conf, String name) throws IOException
{    for (Map.Entry<String, IndexWriterWrapper> entry : this.indexWriters.entrySet()) {        entry.getValue().getIndexWriter().open(conf, name);        entry.getValue().getIndexWriter().open(entry.getValue().getIndexWriterConfig().getParams());    }}
74ee4a060942b9a364cf3176d078a605623c67f28d08d73cb9323276cbd56798
write
public void write(NutchDocument doc) throws IOException
{    for (String indexWriterId : getIndexWriters(doc)) {        if (!this.indexWriters.containsKey(indexWriterId)) {            LOG.warn("Index writer {} is not present. Maybe the plugin is not in plugin.includes or there is a misspelling.", indexWriterId);            continue;        }        NutchDocument mappedDocument = mapDocument(doc, this.indexWriters.get(indexWriterId).getIndexWriterConfig().getMapping());        this.indexWriters.get(indexWriterId).getIndexWriter().write(mappedDocument);    }}
7b17c91d90b92c38f88e0fd76dcf4a9477e38972e89e874237b0ee939c14c40d
update
public void update(NutchDocument doc) throws IOException
{    for (String indexWriterId : getIndexWriters(doc)) {        if (!this.indexWriters.containsKey(indexWriterId)) {            LOG.warn("Index writer {} is not present. Maybe the plugin is not in plugin.includes or there is a misspelling.", indexWriterId);            continue;        }        NutchDocument mappedDocument = mapDocument(doc, this.indexWriters.get(indexWriterId).getIndexWriterConfig().getMapping());        this.indexWriters.get(indexWriterId).getIndexWriter().update(mappedDocument);    }}
dea506e2ed0c9b5f5198b693294dc12a256d914241f20c24393244b56d304554
delete
public void delete(String key) throws IOException
{    for (IndexWriterWrapper iww : indexWriters.values()) {        iww.getIndexWriter().delete(key);    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    for (Map.Entry<String, IndexWriterWrapper> entry : this.indexWriters.entrySet()) {        entry.getValue().getIndexWriter().close();    }}
9686b51f14ae68fc049f472c7635d5385053dc8384dae21aaed20cdf86644fa0
commit
public void commit() throws IOException
{    for (Map.Entry<String, IndexWriterWrapper> entry : this.indexWriters.entrySet()) {        entry.getValue().getIndexWriter().commit();    }}
2ded294e245ca74370bf1437ff1090253c858f944436c063447fc488008c576e
describe
public String describe()
{    StringBuilder builder = new StringBuilder();    if (this.indexWriters.size() == 0)        builder.append("No IndexWriters activated - check your configuration\n");    else        builder.append("Active IndexWriters :\n");    for (IndexWriterWrapper indexWriterWrapper : this.indexWriters.values()) {                builder.append(indexWriterWrapper.getIndexWriter().getClass().getSimpleName()).append(":\n");                AsciiTable at = new AsciiTable();        at.getRenderer().setCWC((rows, colNumbers, tableWidth) -> {            int maxLengthFirstColumn = 0;            int maxLengthLastColumn = 0;            for (AT_Row row : rows) {                if (row.getType() == TableRowType.CONTENT) {                                        int lengthFirstColumn = row.getCells().get(0).toString().length();                    if (lengthFirstColumn > maxLengthFirstColumn) {                        maxLengthFirstColumn = lengthFirstColumn;                    }                                        int lengthLastColumn = row.getCells().get(2).toString().length();                    if (lengthLastColumn > maxLengthLastColumn) {                        maxLengthLastColumn = lengthLastColumn;                    }                }            }            return new int[] { maxLengthFirstColumn, tableWidth - maxLengthFirstColumn - maxLengthLastColumn, maxLengthLastColumn };        });                Map<String, Map.Entry<String, Object>> properties = indexWriterWrapper.getIndexWriter().describe();                properties.forEach((key, value) -> {            at.addRule();            at.addRow(key, value.getKey(), value.getValue() != null ? value.getValue() : "");        });                at.addRule();                builder.append(at.render(150)).append("\n\n");    }    return builder.toString();}
9019b4d2acbfb5d05b0d063b2e07df2cb394f50cef325cf1b26b871e834f54eb
getIndexWriterConfig
 IndexWriterConfig getIndexWriterConfig()
{    return indexWriterConfig;}
0e74fac7042abb84df4a0ed17359e8a5f1c6338a299907f8a34d7b208fca98c8
setIndexWriterConfig
 void setIndexWriterConfig(IndexWriterConfig indexWriterConfig)
{    this.indexWriterConfig = indexWriterConfig;}
007a979b910d7aa0cfee80f02eea4469bde2feb71984a9d45db043c8f02a42c8
getIndexWriter
 IndexWriter getIndexWriter()
{    return indexWriter;}
40268c3727a628293bb6c0e06f5f8cc5eb3ff8ae69c38df9e498c37422b283e6
setIndexWriter
 void setIndexWriter(IndexWriter indexWriter)
{    this.indexWriter = indexWriter;}
1be1572d67106de1d9881f307fa137d195c597cff87cb658913279f59bb3a09f
parseMapping
 static Map<Actions, Map<String, List<String>>> parseMapping(Element mappingElement)
{    Map<Actions, Map<String, List<String>>> parsedMapping = new HashMap<>();        Node node = mappingElement.getElementsByTagName("rename").item(0);    if (node != null) {        NodeList fieldList = ((Element) node).getElementsByTagName("field");        Map<String, List<String>> fieldsMap = new HashMap<>();        for (int j = 0; j < fieldList.getLength(); j++) {            Element field = (Element) fieldList.item(j);            fieldsMap.put(field.getAttribute("source"), Collections.singletonList(field.getAttribute("dest")));        }        parsedMapping.put(Actions.RENAME, fieldsMap);    }        node = mappingElement.getElementsByTagName("copy").item(0);    if (node != null) {        NodeList fieldList = ((Element) node).getElementsByTagName("field");        Map<String, List<String>> fieldsMap = new HashMap<>();        for (int j = 0; j < fieldList.getLength(); j++) {            Element field = (Element) fieldList.item(j);            fieldsMap.put(field.getAttribute("source"), Arrays.asList(field.getAttribute("dest").split(",")));        }        parsedMapping.put(Actions.COPY, fieldsMap);    }        node = mappingElement.getElementsByTagName("remove").item(0);    if (node != null) {        NodeList fieldList = ((Element) node).getElementsByTagName("field");        Map<String, List<String>> fieldsMap = new HashMap<>();        for (int j = 0; j < fieldList.getLength(); j++) {            Element field = (Element) fieldList.item(j);            fieldsMap.put(field.getAttribute("source"), null);        }        parsedMapping.put(Actions.REMOVE, fieldsMap);    }    return parsedMapping;}
d588477638c98200b5078dad39962655a50ca74e136b82c1fe82910c5f2f8a2a
add
public void add(String name, Object value)
{    NutchField field = fields.get(name);    if (field == null) {        field = new NutchField(value);        fields.put(name, field);    } else {        field.add(value);    }}
b1c20c4b777ee52f69d39531eb2b20a2aefc67540c2a9b501797f756ca74ac3e
getFieldValue
public Object getFieldValue(String name)
{    NutchField field = fields.get(name);    if (field == null) {        return null;    }    if (field.getValues().size() == 0) {        return null;    }    return field.getValues().get(0);}
3e603382a5fb749f2eb9f9046e54aafe984b84f1e2eeac8f6ecccd849455f84f
getField
public NutchField getField(String name)
{    return fields.get(name);}
1d31f82d0221633aeab811997b7f36de5feb5bbcc3e425e24d720e1adfbe0666
removeField
public NutchField removeField(String name)
{    return fields.remove(name);}
75208cbd32d9c9fa74ad64dded4b0e01d94d48f5f81f4602f17ae67251bc97a8
getFieldNames
public Collection<String> getFieldNames()
{    return fields.keySet();}
8ab26f9bc023708d2d47c71ca5ea987652628a0e6e40517d8de65514c667b8ae
iterator
public Iterator<Entry<String, NutchField>> iterator()
{    return fields.entrySet().iterator();}
29c66223ae551e58c37bfcd42782292f19ce9d9da320a02f986f8f7986eb5210
getWeight
public float getWeight()
{    return weight;}
01ddf0824d4ea4a79ccd87358d3268e302a596080ce6f3024742845a7e3a7311
setWeight
public void setWeight(float weight)
{    this.weight = weight;}
7512a3a45536711e25552036068bcaf722a14736d11718044cef3303a1a0477d
getDocumentMeta
public Metadata getDocumentMeta()
{    return documentMeta;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    fields.clear();    byte version = in.readByte();    if (version != VERSION) {        throw new VersionMismatchException(VERSION, version);    }    int size = WritableUtils.readVInt(in);    for (int i = 0; i < size; i++) {        String name = Text.readString(in);        NutchField field = new NutchField();        field.readFields(in);        fields.put(name, field);    }    weight = in.readFloat();    documentMeta.readFields(in);}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeByte(VERSION);    WritableUtils.writeVInt(out, fields.size());    for (Map.Entry<String, NutchField> entry : fields.entrySet()) {        Text.writeString(out, entry.getKey());        NutchField field = entry.getValue();        field.write(out);    }    out.writeFloat(weight);    documentMeta.write(out);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder();    sb.append("doc {\n");    for (Map.Entry<String, NutchField> entry : fields.entrySet()) {        sb.append("\t");        sb.append(entry.getKey());        sb.append(":\t");        sb.append(entry.getValue());        sb.append("\n");    }    sb.append("}\n");    return sb.toString();}
15366960a68467f305c783d533a14e66da0da21e593e73d4978869f986829899
clone
public NutchDocument clone() throws CloneNotSupportedException
{    NutchDocument clonedDocument = (NutchDocument) super.clone();    clonedDocument.fields = new HashMap<>();    for (Entry<String, NutchField> field : this.fields.entrySet()) {        clonedDocument.fields.put(field.getKey(), field.getValue().clone());    }    return clonedDocument;}
1ccac8b8222efd0efee7f5838d8c63fdec5411763b65f54a1ddbc8aa7225dd14
add
public void add(Object value)
{    values.add(value);}
29c66223ae551e58c37bfcd42782292f19ce9d9da320a02f986f8f7986eb5210
getWeight
public float getWeight()
{    return weight;}
01ddf0824d4ea4a79ccd87358d3268e302a596080ce6f3024742845a7e3a7311
setWeight
public void setWeight(float weight)
{    this.weight = weight;}
76b6456b4fd6bdb2e44bd7bf7e9dd35e8cae33d4ea82d162fd99f4dc247e8bc3
getValues
public List<Object> getValues()
{    return values;}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    weight = 1.0f;    values.clear();}
286c41c1bd0110e155b51df8f80298d0507af375e19aacf3b7b01f14911f77b2
clone
public NutchField clone() throws CloneNotSupportedException
{    NutchField result = (NutchField) super.clone();    result.weight = weight;    result.values = (ArrayList<Object>) values.clone();    return result;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    weight = in.readFloat();    int count = in.readInt();    values = new ArrayList<>();    for (int i = 0; i < count; i++) {        String type = Text.readString(in);        if ("java.lang.String".equals(type)) {            values.add(Text.readString(in));        } else if ("java.lang.Boolean".equals(type)) {            values.add(in.readBoolean());        } else if ("java.lang.Integer".equals(type)) {            values.add(in.readInt());        } else if ("java.lang.Float".equals(type)) {            values.add(in.readFloat());        } else if ("java.lang.Long".equals(type)) {            values.add(in.readLong());        } else if ("java.util.Date".equals(type)) {            values.add(new Date(in.readLong()));        }    }}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeFloat(weight);    out.writeInt(values.size());    for (Object value : values) {        Text.writeString(out, value.getClass().getName());        if (value instanceof Boolean) {            out.writeBoolean((Boolean) value);        } else if (value instanceof Integer) {            out.writeInt((Integer) value);        } else if (value instanceof Long) {            out.writeLong((Long) value);        } else if (value instanceof Float) {            out.writeFloat((Float) value);        } else if (value instanceof String) {            Text.writeString(out, (String) value);        } else if (value instanceof Date) {            Date date = (Date) value;            out.writeLong(date.getTime());        }    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return values.toString();}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    action = in.readByte();    doc = new NutchDocument();    doc.readFields(in);}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.write(action);    doc.write(out);}
6c03b4498655115542092b087f09b35dfb2c6feadbf9418baae22825a9aa40d0
isMultiValued
public boolean isMultiValued(final String name)
{    return metadata.get(name) != null && metadata.get(name).length > 1;}
385ffc0c7d915296b959086d2f83c3aee279ddb31a8a629f955386cbb059e5cf
names
public String[] names()
{    return metadata.keySet().toArray(new String[metadata.keySet().size()]);}
1a3cc025cad34f2ce505bef060fbb1322cf072dd51a3e9a10c99832543d2fe75
get
public String get(final String name)
{    String[] values = metadata.get(name);    if (values == null) {        return null;    } else {        return values[0];    }}
8f77f4f308388538f66a31d64d86a2998c1c0edba873a9a9ec4cb9c9687dd017
getValues
public String[] getValues(final String name)
{    return _getValues(name);}
ec5876d566533246b041e35b6769cf04dbb41c7a009923f8ba829f2f2fb6c7a8
_getValues
private String[] _getValues(final String name)
{    String[] values = metadata.get(name);    if (values == null) {        values = new String[0];    }    return values;}
8ec7c2a09a37225d7bb23ac344623ad769e7c1fab6e5ff08b07d06c3979417d8
add
public void add(final String name, final String value)
{    String[] values = metadata.get(name);    if (values == null) {        set(name, value);    } else {        String[] newValues = new String[values.length + 1];        System.arraycopy(values, 0, newValues, 0, values.length);        newValues[newValues.length - 1] = value;        metadata.put(name, newValues);    }}
6075447fd9a32243841eae2ad94f1f819b631571ff33f7338195b659625a716d
addAll
public void addAll(Metadata metadata)
{    for (String name : metadata.names()) {        String[] addValues = metadata.getValues(name);        if (addValues == null)            continue;        String[] oldValues = this.metadata.get(name);        if (oldValues == null) {            this.metadata.put(name, addValues);        } else {            String[] newValues = new String[oldValues.length + addValues.length];            System.arraycopy(oldValues, 0, newValues, 0, oldValues.length);            System.arraycopy(addValues, 0, newValues, oldValues.length, addValues.length);            this.metadata.put(name, newValues);        }    }}
3fd5c6968fe810198fdd516cb242b5f9eb7f53659575661c27b3bdfaee8f2d96
setAll
public void setAll(Properties properties)
{    Enumeration<?> names = properties.propertyNames();    while (names.hasMoreElements()) {        String name = (String) names.nextElement();        metadata.put(name, new String[] { properties.getProperty(name) });    }}
f53208f35f60c2e5f71f21e00193f4a65c30f7d49d6d28f1489f28bb8b5867f9
set
public void set(String name, String value)
{    metadata.put(name, new String[] { value });}
75380b92540e0d6d1adcf8b152cd5c49cc1926519e7634ca73cc59582f561f15
remove
public void remove(String name)
{    metadata.remove(name);}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return metadata.size();}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    metadata.clear();}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (o == null) {        return false;    }    Metadata other = null;    try {        other = (Metadata) o;    } catch (ClassCastException cce) {        return false;    }    if (other.size() != size()) {        return false;    }    String[] names = names();    for (int i = 0; i < names.length; i++) {        String[] otherValues = other._getValues(names[i]);        String[] thisValues = _getValues(names[i]);        if (otherValues.length != thisValues.length) {            return false;        }        for (int j = 0; j < otherValues.length; j++) {            if (!otherValues[j].equals(thisValues[j])) {                return false;            }        }    }    return true;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuffer buf = new StringBuffer();    String[] names = names();    for (int i = 0; i < names.length; i++) {        String[] values = _getValues(names[i]);        for (int j = 0; j < values.length; j++) {            buf.append(names[i]).append("=").append(values[j]).append(" ");        }    }    return buf.toString();}
6ce8f423999e48ee8ccc8ead0930648784c8032b66979cb68c99c4f899ae9ef8
write
public final void write(DataOutput out) throws IOException
{    out.writeInt(size());    String[] values = null;    String[] names = names();    for (int i = 0; i < names.length; i++) {        Text.writeString(out, names[i]);        values = _getValues(names[i]);        int cnt = 0;        for (int j = 0; j < values.length; j++) {            if (values[j] != null)                cnt++;        }        out.writeInt(cnt);        for (int j = 0; j < values.length; j++) {            if (values[j] != null) {                Text.writeString(out, values[j]);            }        }    }}
7add649f77ab882651a0aefca1bcc5bc5472da2482e6f0b33a883360f704f801
readFields
public final void readFields(DataInput in) throws IOException
{    int keySize = in.readInt();    String key;    for (int i = 0; i < keySize; i++) {        key = Text.readString(in);        int valueSize = in.readInt();        for (int j = 0; j < valueSize; j++) {            add(key, Text.readString(in));        }    }}
3278491613baf75b185ed9d8d57b8e0f596c9babb670aa112cc72d53896855cf
getMetadata
public Metadata getMetadata()
{    return metadata;}
6f0274c483d4908a775c8f2f699b67d7967c729253dc65a582cbe740169e724b
addMeta
public void addMeta(String name, String value)
{    metadata.add(name, value);}
21845f521a1711209c478f6e2900a1bb2ecb829fb383e844548e3bc2ef803a39
setMeta
public void setMeta(String name, String value)
{    metadata.set(name, value);}
04f5f63d6492303c86d2d4c16bf82061c4a3643f90c6b563d1713ec04b2af868
getMeta
public String getMeta(String name)
{    return metadata.get(name);}
c65803c4bcc996198503030cddee13d81d75adee0ef22e8f6b89efdcb4140e77
getMetaValues
public String[] getMetaValues(String name)
{    return metadata.getValues(name);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    super.readFields(in);    metadata = new Metadata();    metadata.readFields(in);}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    super.write(out);    metadata.write(out);}
0177b5be7fa7e16a9878d48992d7d7e233438476a23de878bbb152b5cb0482dd
normalize
private static String normalize(final String str)
{    char c;    StringBuffer buf = new StringBuffer();    for (int i = 0; i < str.length(); i++) {        c = str.charAt(i);        if (Character.isLetter(c)) {            buf.append(Character.toLowerCase(c));        }    }    return buf.toString();}
1237a6c1c86dadf5fab513fd5917e84a144c11c949a786ab33caed32e3a1603c
getNormalizedName
public static String getNormalizedName(final String name)
{    String searched = normalize(name);    String value = NAMES_IDX.get(searched);    if ((value == null) && (normalized != null)) {        int threshold = Math.min(3, searched.length() / TRESHOLD_DIVIDER);        for (int i = 0; i < normalized.length && value == null; i++) {            if (StringUtils.getLevenshteinDistance(searched, normalized[i]) < threshold) {                value = NAMES_IDX.get(normalized[i]);            }        }    }    return (value != null) ? value : name;}
69884b2f74ead749a762ee84b23a281003003aa2bfffc10a805f0919c83d9158
remove
public void remove(final String name)
{    super.remove(getNormalizedName(name));}
8ec7c2a09a37225d7bb23ac344623ad769e7c1fab6e5ff08b07d06c3979417d8
add
public void add(final String name, final String value)
{    super.add(getNormalizedName(name), value);}
8f77f4f308388538f66a31d64d86a2998c1c0edba873a9a9ec4cb9c9687dd017
getValues
public String[] getValues(final String name)
{    return super.getValues(getNormalizedName(name));}
1a3cc025cad34f2ce505bef060fbb1322cf072dd51a3e9a10c99832543d2fe75
get
public String get(final String name)
{    return super.get(getNormalizedName(name));}
8ed8dbd2d011aa83b4d88d58ecdb4fe180d5d0b8ff901d83629e7beb3aed46db
set
public void set(final String name, final String value)
{    super.set(getNormalizedName(name), value);}
c890708d75cf3f5e5aadff486e71f3bea8329e0beb63dc9db82c60637b8d8eb1
toString
public static String toString(Date date)
{    String string;    synchronized (format) {        string = format.format(date);    }    return string;}
422acd327a6a5f1b29454e3fd355f79b9e66ae00954b87ca93f89d26184a2f2d
toString
public static String toString(Calendar cal)
{    String string;    synchronized (format) {        string = format.format(cal.getTime());    }    return string;}
0406aaeb6365a3a4031e51e6c6569162792d52188125846005c68564bf66ea86
toString
public static String toString(long time)
{    String string;    synchronized (format) {        string = format.format(new Date(time));    }    return string;}
9df63e46708ccc9d078cd9879d5e59fec9c214577160a46735c41f6d84d9772d
toDate
public static Date toDate(String dateString) throws ParseException
{    Date date;    synchronized (format) {        date = format.parse(dateString);    }    return date;}
d9166577fc30821b3bc0e759937b3ad3e3e89bdb8d7108d5b04c6ec6ea5ea4fb
toLong
public static long toLong(String dateString) throws ParseException
{    long time;    synchronized (format) {        time = format.parse(dateString).getTime();    }    return time;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    Date now = new Date(System.currentTimeMillis());    String string = HttpDateFormat.toString(now);    long time = HttpDateFormat.toLong(string);    System.out.println(string);    System.out.println(HttpDateFormat.toString(time));}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return config;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    config = conf;    for (String exceptClassName : conf.getTrimmedStrings(HTTP_LOG_SUPPRESSION, "java.net.UnknownHostException", "java.net.NoRouteToHostException")) {        Class<?> clazz = conf.getClassByNameOrNull(exceptClassName);        if (clazz == null) {            LOG.warn("Class {} configured for log stack suppression not found.", exceptClassName);            continue;        }        if (!Throwable.class.isAssignableFrom(clazz)) {            LOG.warn("Class {} configured for log stack suppression does not extend Throwable.", exceptClassName);            continue;        }        exceptionsLogShort.add(clazz.asSubclass(Throwable.class));    }}
b906b51aae26dcf611ed640837c6cd3914b799c4b745abba4c3a37d2e39fadb2
logShort
public boolean logShort(Throwable t)
{    if (exceptionsLogShort.contains(t.getClass())) {        return true;    }    return false;}
d3eb7b90174e04e7451266f07f5a2c93017e8bc6823b3a74ec61ecb5373d8be1
isExempted
public boolean isExempted(String fromUrl, String toUrl)
{    if (filters.length < 1) {                return false;    }        boolean exempted = fromUrl != null && toUrl != null;        for (int i = 0; i < this.filters.length && exempted; i++) {        exempted = this.filters[i].filter(fromUrl, toUrl);    }    return exempted;}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    usage = "Usage: URLFilterChecker [-Dproperty=value]... [-filterName filterName] (-stdin | -listen <port> [-keepClientCnxOpen]) \n" + "\n  -filterName\tURL filter plugin name (eg. urlfilter-regex) to check," + "\n             \t(if not given all configured URL filters are applied)" + "\n  -stdin     \ttool reads a list of URLs from stdin, one URL per line" + "\n  -listen <port>\trun tool as Telnet server listening on <port>\n";        if (args.length < 1) {        System.err.println(usage);        System.exit(-1);    }    int numConsumed;    for (int i = 0; i < args.length; i++) {        if (args[i].equals("-filterName")) {            getConf().set("plugin.includes", args[++i]);        } else if ((numConsumed = super.parseArgs(args, i)) > 0) {            i += numConsumed - 1;        } else {            System.err.println("ERROR: Not a recognized argument: " + args[i]);            System.err.println(usage);            System.exit(-1);        }    }        filters = new URLFilters(getConf());    System.out.print("Checking combination of these URLFilters: ");    for (URLFilter filter : filters.getFilters()) {        System.out.print(filter.getClass().getSimpleName() + " ");    }    System.out.println("");        return super.run();}
5a9c6fab723cd06e037823885214041aae316eb36f109c0513491669cd33e005
process
protected int process(String line, StringBuilder output) throws Exception
{    String out = filters.filter(line);    if (out != null) {        output.append("+");        output.append(out);    } else {        output.append("-");        output.append(line);    }    return 0;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    final int res = ToolRunner.run(NutchConfiguration.create(), new URLFilterChecker(), args);    System.exit(res);}
3f8cfb4e75b6bacaea2e82d2d114dc4216fe653f0b80f4c42f5ea99fa0be67eb
getFilters
public URLFilter[] getFilters()
{    return this.filters;}
f6b4e1fe35a5b9527037b63c74144b5807675a3c53d34a9f53e20fc6137d3d78
filter
public String filter(String urlString) throws URLFilterException
{    for (int i = 0; i < this.filters.length; i++) {        if (urlString == null)            return null;        urlString = this.filters[i].filter(urlString);    }    return urlString;}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    usage = "Usage: URLNormalizerChecker [-Dproperty=value]... [-normalizer <normalizerName>] [-scope <scope>] (-stdin | -listen <port> [-keepClientCnxOpen])\n" + "\n  -normalizer\tURL normalizer plugin (eg. urlnormalizer-basic) to check," + "\n             \t(if not given all configured URL normalizers are applied)" + "\n  -scope     \tone of: default,partition,generate_host_count,fetcher,crawldb,linkdb,inject,outlink" + "\n  -stdin     \ttool reads a list of URLs from stdin, one URL per line" + "\n  -listen <port>\trun tool as Telnet server listening on <port>" + "\n\nAn empty line is added to the output if a URL fails to normalize (MalformedURLException or null returned).\n";        if (args.length < 1) {        System.err.println(usage);        System.exit(-1);    }    int numConsumed;    for (int i = 0; i < args.length; i++) {        if (args[i].equals("-normalizer")) {            getConf().set("plugin.includes", args[++i]);        } else if (args[i].equals("-scope")) {            scope = args[++i];        } else if ((numConsumed = super.parseArgs(args, i)) > 0) {            i += numConsumed - 1;        } else {            System.err.println("ERROR: Not a recognized argument: " + args[i]);            System.err.println(usage);            System.exit(-1);        }    }        normalizers = new URLNormalizers(getConf(), scope);    System.out.print("Checking combination of these URLNormalizers: ");    for (URLNormalizer normalizer : normalizers.getURLNormalizers(scope)) {        System.out.print(normalizer.getClass().getSimpleName() + " ");    }    System.out.println("");        return super.run();}
5a9c6fab723cd06e037823885214041aae316eb36f109c0513491669cd33e005
process
protected int process(String line, StringBuilder output) throws Exception
{    try {        String norm = normalizers.normalize(line, scope);        if (norm == null) {            output.append("");        } else {            output.append(norm);        }    } catch (MalformedURLException e) {        output.append("");    }    return 0;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    final int res = ToolRunner.run(NutchConfiguration.create(), new URLNormalizerChecker(), args);    System.exit(res);}
35cb8af9930ead5f1d2bf6f358737097bff1b768c0bb23e85287bacb66ddeb33
getURLNormalizers
 URLNormalizer[] getURLNormalizers(String scope)
{    List<Extension> extensions = getExtensions(scope);    ObjectCache objectCache = ObjectCache.get(conf);    if (extensions == EMPTY_EXTENSION_LIST) {        return EMPTY_NORMALIZERS;    }    List<URLNormalizer> normalizers = new Vector<>(extensions.size());    Iterator<Extension> it = extensions.iterator();    while (it.hasNext()) {        Extension ext = it.next();        URLNormalizer normalizer = null;        try {                        normalizer = (URLNormalizer) objectCache.getObject(ext.getId());            if (normalizer == null) {                                normalizer = (URLNormalizer) ext.getExtensionInstance();                objectCache.setObject(ext.getId(), normalizer);            }            normalizers.add(normalizer);        } catch (PluginRuntimeException e) {            e.printStackTrace();            LOG.warn("URLNormalizers:PluginRuntimeException when " + "initializing url normalizer plugin " + ext.getDescriptor().getPluginId() + " instance in getURLNormalizers " + "function: attempting to continue instantiating plugins");        }    }    return normalizers.toArray(new URLNormalizer[normalizers.size()]);}
b0a553cca90fff030abf5f61ea4b0151575461db5793ca3b8a92ad50b3604956
getExtensions
private List<Extension> getExtensions(String scope)
{    ObjectCache objectCache = ObjectCache.get(conf);    List<Extension> extensions = (List<Extension>) objectCache.getObject(URLNormalizer.X_POINT_ID + "_x_" + scope);        if (extensions == EMPTY_EXTENSION_LIST) {        return EMPTY_EXTENSION_LIST;    }    if (extensions == null) {        extensions = findExtensions(scope);        if (extensions != null) {            objectCache.setObject(URLNormalizer.X_POINT_ID + "_x_" + scope, extensions);        } else {                                    objectCache.setObject(URLNormalizer.X_POINT_ID + "_x_" + scope, EMPTY_EXTENSION_LIST);            extensions = EMPTY_EXTENSION_LIST;        }    }    return extensions;}
a09fd0a31c4354d91ac34474135bc7300b25f0de94b07c00ad24a367093ccf61
findExtensions
private List<Extension> findExtensions(String scope)
{    String[] orders = null;    String orderlist = conf.get("urlnormalizer.order." + scope);    if (orderlist == null)        orderlist = conf.get("urlnormalizer.order");    if (orderlist != null && !orderlist.trim().equals("")) {        orders = orderlist.trim().split("\\s+");    }    String scopelist = conf.get("urlnormalizer.scope." + scope);    Set<String> impls = null;    if (scopelist != null && !scopelist.trim().equals("")) {        String[] names = scopelist.split("\\s+");        impls = new HashSet<>(Arrays.asList(names));    }    Extension[] extensions = this.extensionPoint.getExtensions();    HashMap<String, Extension> normalizerExtensions = new HashMap<>();    for (int i = 0; i < extensions.length; i++) {        Extension extension = extensions[i];        if (impls != null && !impls.contains(extension.getClazz()))            continue;        normalizerExtensions.put(extension.getClazz(), extension);    }    List<Extension> res = new ArrayList<>();    if (orders == null) {        res.addAll(normalizerExtensions.values());    } else {                for (int i = 0; i < orders.length; i++) {            Extension e = normalizerExtensions.get(orders[i]);            if (e != null) {                res.add(e);                normalizerExtensions.remove(orders[i]);            }        }                res.addAll(normalizerExtensions.values());    }    return res;}
74abbdeba913940ca747a127baff7032aa47f6b1ce6e65185ebfcd9754faf4d1
normalize
public String normalize(String urlString, String scope) throws MalformedURLException
{        String initialString = urlString;    for (int k = 0; k < loopCount; k++) {        for (int i = 0; i < this.normalizers.length; i++) {            if (urlString == null)                return null;            urlString = this.normalizers[i].normalize(urlString, scope);        }        if (initialString.equals(urlString))            break;        initialString = urlString;    }    return urlString;}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    noIndex = false;    noFollow = false;    noCache = false;    refresh = false;    refreshTime = 0;    baseHref = null;    refreshHref = null;    generalTags.clear();    httpEquivTags.clear();}
f3b09c06f1db2b4fe2882deda140579ad29a94e32108afaf680ebc1cd5193e8c
setNoFollow
public void setNoFollow()
{    noFollow = true;}
3891a5e7ed7993d3b02f7172cfa32a47ee1178860c9a41b9d86104c470261896
setNoIndex
public void setNoIndex()
{    noIndex = true;}
446ebcbe36cd2e0457ced4c92ca98ad188b2c87d8ff14318c7eebe9d2864cd39
setNoCache
public void setNoCache()
{    noCache = true;}
b9c29b078ca52c08bce045045e3357cae8c9420d91c9fff555e6f76bfa288438
setRefresh
public void setRefresh(boolean refresh)
{    this.refresh = refresh;}
138705280c868aafb05211e895ad99b566e406a6a618031786ef5c37aef2e4e1
setBaseHref
public void setBaseHref(URL baseHref)
{    this.baseHref = baseHref;}
7dfcc8a6aad39500c3232bb78b6f1d9a6a06f91cf65daccffd2e73b34608daed
setRefreshHref
public void setRefreshHref(URL refreshHref)
{    this.refreshHref = refreshHref;}
9d3f00b213b03965ce100ddcd3703be6d42ad4a699c584c3bfab42747ed454cb
setRefreshTime
public void setRefreshTime(int refreshTime)
{    this.refreshTime = refreshTime;}
7031b32df4db8a71a56e269f0463985de4cfff270873d6879d25cc89cd9cacf2
getNoIndex
public boolean getNoIndex()
{    return noIndex;}
91eb3529fc8907c2c1f46921e89beb3fb18e938a152dbf46ef9ec552e9bd5cc5
getNoFollow
public boolean getNoFollow()
{    return noFollow;}
d9509905e4e578609429bc24314cdddc97690ab53592dafefc44b3418c8079e8
getNoCache
public boolean getNoCache()
{    return noCache;}
cd1456844c6480033f550afdebf4fd6ef7dbca5bc7ac22edf59609b60ad77e78
getRefresh
public boolean getRefresh()
{    return refresh;}
ab5a4f4af945d00efe7dc6f0d4b27b82d262a5bf86322c91fc3c8a088cabbad8
getBaseHref
public URL getBaseHref()
{    return baseHref;}
8f6e2dfd56b0097df28eced7a09b7243c38389e8f9872a88a509b945830b24b0
getRefreshHref
public URL getRefreshHref()
{    return refreshHref;}
66c8a8dd85f0f0f56dc4078a1d6d2fb9d08943ab12c22a5f78c6b452e9df4715
getRefreshTime
public int getRefreshTime()
{    return refreshTime;}
935faf4ba7632de3cea1812b7d9ab022f74940d6cdfd0344dbb398ebd6c8bf0e
getGeneralTags
public Metadata getGeneralTags()
{    return generalTags;}
d6d8796e1ecd943b535d66a677f826e80089bb1ba3c96fddbe9493d817d94815
getHttpEquivTags
public Properties getHttpEquivTags()
{    return httpEquivTags;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuffer sb = new StringBuffer();    sb.append("base=" + baseHref + ", noCache=" + noCache + ", noFollow=" + noFollow + ", noIndex=" + noIndex + ", refresh=" + refresh + ", refreshHref=" + refreshHref + "\n");    sb.append(" * general tags:\n");    String[] names = generalTags.names();    for (String name : names) {        String key = name;        sb.append("   - " + key + "\t=\t" + generalTags.get(key) + "\n");    }    sb.append(" * http-equiv tags:\n");    Iterator<Object> it = httpEquivTags.keySet().iterator();    it = httpEquivTags.keySet().iterator();    while (it.hasNext()) {        String key = (String) it.next();        sb.append("   - " + key + "\t=\t" + httpEquivTags.get(key) + "\n");    }    return sb.toString();}
9ff841f3d46425f0defcf4346027b52742d29abc435829a9bc29d5c88e553a7b
filter
public ParseResult filter(Content content, ParseResult parseResult, HTMLMetaTags metaTags, DocumentFragment doc)
{        for (int i = 0; i < this.htmlParseFilters.length; i++) {                parseResult = htmlParseFilters[i].filter(content, parseResult, metaTags, doc);                if (!parseResult.isSuccess()) {                                                parseResult.filter();            return parseResult;        }    }    return parseResult;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    toUrl = Text.readString(in);    anchor = Text.readString(in);    boolean hasMD = in.readBoolean();    if (hasMD) {        md = new org.apache.hadoop.io.MapWritable();        md.readFields(in);    } else        md = null;}
b415817508279ac67efbbd121bfc69e06485631b4566513717a8372c38d11af3
skip
public static void skip(DataInput in) throws IOException
{        Text.skip(in);        Text.skip(in);    boolean hasMD = in.readBoolean();    if (hasMD) {        MapWritable metadata = new org.apache.hadoop.io.MapWritable();        metadata.readFields(in);        ;    }}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    Text.writeString(out, toUrl);    Text.writeString(out, anchor);    if (md != null && md.size() > 0) {        out.writeBoolean(true);        md.write(out);    } else {        out.writeBoolean(false);    }}
9c2cbe32e1c896e79d1311069b0d84c70192e0a9f40d451297351f410b0a7f97
read
public static Outlink read(DataInput in) throws IOException
{    Outlink outlink = new Outlink();    outlink.readFields(in);    return outlink;}
4d18fea59207679d810bc8f621507b7bf2e9825eda53b5b0bba9ecd9ccaf8d33
getToUrl
public String getToUrl()
{    return toUrl;}
b9fa60b415e77f4f9473e9e3cdee5059617c9cf84ef7e908bc17d26c5bea8e20
setUrl
public void setUrl(String toUrl)
{    this.toUrl = toUrl;}
5632266259dd12f97eac4eb8fa5fe7c4757994ac78574e29c6b86d0d82bc5627
getAnchor
public String getAnchor()
{    return anchor;}
6ffc0911586e7dbb70dc442f14d7f247bcb55dffa6a8a853eab42ebe4744b282
getMetadata
public MapWritable getMetadata()
{    return md;}
e6695e734f0ac2e08a05aa4b526fb0c73393506a59dd650c565d7502526a4353
setMetadata
public void setMetadata(MapWritable md)
{    this.md = md;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof Outlink))        return false;    Outlink other = (Outlink) o;    return this.toUrl.equals(other.toUrl) && this.anchor.equals(other.anchor);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuffer repr = new StringBuffer("toUrl: ");    repr.append(toUrl);    repr.append(" anchor: ");    repr.append(anchor);    if (md != null && !md.isEmpty()) {        for (Entry<Writable, Writable> e : md.entrySet()) {            repr.append(" ");            repr.append(e.getKey());            repr.append(": ");            repr.append(e.getValue());        }    }    return repr.toString();}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return toUrl.hashCode() ^ anchor.hashCode();}
83c609e9ce8b37765c06f4c904f01954853a260a3b008ac3043dae7e861c9ade
getOutlinks
public static Outlink[] getOutlinks(final String plainText, Configuration conf)
{    return OutlinkExtractor.getOutlinks(plainText, "", conf);}
a09b654eacbcad1ddd61bd09c313a628f791e2c3b82e0e2e05e65018b5e590e5
getOutlinks
public static Outlink[] getOutlinks(final String plainText, String anchor, Configuration conf)
{    if (plainText == null) {        return new Outlink[0];    }    long start = System.currentTimeMillis();    final List<Outlink> outlinks = new ArrayList<>();    try {        Matcher matcher = URL_PATTERN.matcher(plainText);        String url;                while (matcher.find()) {                        if (System.currentTimeMillis() - start >= 60000L) {                if (LOG.isWarnEnabled()) {                    LOG.warn("Time limit exceeded for getOutLinks");                }                break;            }            url = matcher.group().trim();            try {                outlinks.add(new Outlink(url, anchor));            } catch (MalformedURLException mue) {                LOG.warn("Invalid url: '" + url + "', skipping.");            }        }    } catch (Exception ex) {                if (LOG.isErrorEnabled()) {            LOG.error("getOutlinks", ex);        }    }    final Outlink[] retval;        if (outlinks.size() > 0) {        retval = outlinks.toArray(new Outlink[0]);    } else {        retval = new Outlink[0];    }    return retval;}
64119ac6b136b56bea5e6680f618c2192414914eb851297fd42290649970b14a
call
public ParseResult call() throws Exception
{    return p.getParse(content);}
f3dcd6cac2be74ec9f039ad9eb1314878f9d79733059f60f41d693a1ba0c23a0
getStatus
public ParseStatus getStatus()
{    return status;}
e5ef01fa2cf65dfc9fab56435459437471698c703940d8b9a6902680e8c38e95
getTitle
public String getTitle()
{    return title;}
b639a29bd9292f7139347645f848b106f66bd0a41b6cb5a3ea56b650135ffa05
getOutlinks
public Outlink[] getOutlinks()
{    return outlinks;}
01b9ecd0ac8d06d26a897cfcf9e3f04d4d54393c30ee09e027e4c1d0d94270a3
getContentMeta
public Metadata getContentMeta()
{    return contentMeta;}
98bff27bf044e21e31fd15fe81ec0bd249e92201cae988553b5ad3e4f3f59906
getParseMeta
public Metadata getParseMeta()
{    return parseMeta;}
d67a73420736d3acb7d884e6f6b11f778e37651a7865da8183bf8875a4da885b
setParseMeta
public void setParseMeta(Metadata parseMeta)
{    this.parseMeta = parseMeta;}
01245d002fdf98423608f0206928c70b34bf34b5d3333207715159f4416334fc
setOutlinks
public void setOutlinks(Outlink[] outlinks)
{    this.outlinks = outlinks;}
04f5f63d6492303c86d2d4c16bf82061c4a3643f90c6b563d1713ec04b2af868
getMeta
public String getMeta(String name)
{    String value = parseMeta.get(name);    if (value == null) {        value = contentMeta.get(name);    }    return value;}
030b04dc0daca5784913ea0b60fc938e081bf539c3416d1093544c0761d518b0
getVersion
public byte getVersion()
{    return version;}
7add649f77ab882651a0aefca1bcc5bc5472da2482e6f0b33a883360f704f801
readFields
public final void readFields(DataInput in) throws IOException
{    version = in.readByte();        if (version != VERSION)        throw new VersionMismatchException(VERSION, version);    status = ParseStatus.read(in);        title = Text.readString(in);    int numOutlinks = in.readInt();    outlinks = new Outlink[numOutlinks];    for (int i = 0; i < numOutlinks; i++) {        outlinks[i] = Outlink.read(in);    }    contentMeta.clear();    contentMeta.readFields(in);    parseMeta.clear();    parseMeta.readFields(in);}
6ce8f423999e48ee8ccc8ead0930648784c8032b66979cb68c99c4f899ae9ef8
write
public final void write(DataOutput out) throws IOException
{        out.writeByte(VERSION);        status.write(out);        Text.writeString(out, title);        out.writeInt(outlinks.length);    for (int i = 0; i < outlinks.length; i++) {        outlinks[i].write(out);    }        contentMeta.write(out);    parseMeta.write(out);}
e21f280fe63d5db6f365bd94cfb86ef44a7403777be83b18d5b8fd53071a2233
read
public static ParseData read(DataInput in) throws IOException
{    ParseData parseText = new ParseData();    parseText.readFields(in);    return parseText;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof ParseData))        return false;    ParseData other = (ParseData) o;    return this.status.equals(other.status) && this.title.equals(other.title) && Arrays.equals(this.outlinks, other.outlinks) && this.contentMeta.equals(other.contentMeta) && this.parseMeta.equals(other.parseMeta);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuffer buffer = new StringBuffer();    buffer.append("Version: " + version + "\n");    buffer.append("Status: " + status + "\n");    buffer.append("Title: " + title + "\n");    if (outlinks != null) {        buffer.append("Outlinks: " + outlinks.length + "\n");        for (int i = 0; i < outlinks.length; i++) {            buffer.append("  outlink: " + outlinks[i] + "\n");        }    }    buffer.append("Content Metadata: " + contentMeta + "\n");    buffer.append("Parse Metadata: " + parseMeta + "\n");    return buffer.toString();}
6538d76a086933ae50b4ee6e131d43b17cf0047fe2ae644bcffc294ff69a38d9
main
public static void main(String[] argv) throws Exception
{    String usage = "ParseData (-local | -dfs <namenode:port>) recno segment";    if (argv.length < 3) {        System.out.println("usage:" + usage);        return;    }    Options opts = new Options();    Configuration conf = NutchConfiguration.create();    GenericOptionsParser parser = new GenericOptionsParser(conf, opts, argv);    String[] remainingArgs = parser.getRemainingArgs();    try (FileSystem fs = FileSystem.get(conf)) {        int recno = Integer.parseInt(remainingArgs[0]);        String segment = remainingArgs[1];        Path file = new Path(segment, DIR_NAME);        System.out.println("Reading from file: " + file);        ArrayFile.Reader parses = new ArrayFile.Reader(fs, file.toString(), conf);        ParseData parseDatum = new ParseData();        parses.get(recno, parseDatum);        System.out.println("Retrieved " + recno + " from file " + file);        System.out.println(parseDatum);        parses.close();    }}
496805007af0b81862a2d8c2609ce7b43ae81205859ec65f6872584c88bc5dc7
getText
public String getText()
{    return text.getText();}
2eccfd3216064a47b7f606e71ba5ceff23ebe25e03a3cd5ab3d81a86cd08a928
getData
public ParseData getData()
{    return data;}
d1cf6994e53f65296f2f70ed2fd388f02fa3bbc0b3df2ffa307c4402a9a7892e
isCanonical
public boolean isCanonical()
{    return isCanonical;}
6ce8f423999e48ee8ccc8ead0930648784c8032b66979cb68c99c4f899ae9ef8
write
public final void write(DataOutput out) throws IOException
{    out.writeBoolean(isCanonical);    text.write(out);    data.write(out);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    isCanonical = in.readBoolean();    text = new ParseText();    text.readFields(in);    data = new ParseData();    data.readFields(in);}
a13dff17c130b9a49645b1a8613c8954d0613eb11ce2663efac1d6aa0685a72a
read
public static ParseImpl read(DataInput in) throws IOException
{    ParseImpl parseImpl = new ParseImpl();    parseImpl.readFields(in);    return parseImpl;}
69ec669423bdd421a02f6714bb842c5311e6b926156ea4de24f13b04e1c9d13f
getKey
public Text getKey()
{    return key;}
029fd0463c6f1776ec8d8be8a6c2c042d0692801fb4f2030e044f3c251d3a0f7
getValue
public CrawlDatum getValue()
{    return value;}
8bd27514166eb63ad8690c3d59ef97866e5b4931e372a8a3ffffeccdb3aba302
setValue
public CrawlDatum setValue(CrawlDatum value)
{    this.value = value;    return this.value;}
77ab841ad031e596b23c11a2272c70097646883015abd28e78559b1da3dde4a6
getOutputCommitter
public OutputCommitter getOutputCommitter(TaskAttemptContext context) throws IOException
{    Path path = FileOutputFormat.getOutputPath(context);    return new FileOutputCommitter(path, context);}
153790a47f625636a5db4143238044ac6863b0ddd645a70b34ba4ec459b4223c
checkOutputSpecs
public void checkOutputSpecs(JobContext context) throws IOException
{    Configuration conf = context.getConfiguration();    Path out = FileOutputFormat.getOutputPath(context);    FileSystem fs = out.getFileSystem(context.getConfiguration());    if ((out == null) && (context.getNumReduceTasks() != 0)) {        throw new IOException("Output directory not set in JobContext.");    }    if (fs == null) {        fs = out.getFileSystem(conf);    }    if (fs.exists(new Path(out, CrawlDatum.PARSE_DIR_NAME))) {        throw new IOException("Segment already parsed!");    }}
90a25af8da0d5dbbee7eaf75b6c8862e4f4d1f1b167f7d06eba361333225ce3f
getUniqueFile
public String getUniqueFile(TaskAttemptContext context, String name)
{    TaskID taskId = context.getTaskAttemptID().getTaskID();    int partition = taskId.getId();    StringBuilder result = new StringBuilder();    result.append(name);    result.append('-');    result.append(TaskID.getRepresentingCharacter(taskId.getTaskType()));    result.append('-');    result.append(NUMBER_FORMAT.format(partition));    return result.toString();}
daf2a49f8bd6295d58ca3e72d7198bc4cdcb818742970554f1f68ced46f64a43
getRecordWriter
public RecordWriter<Text, Parse> getRecordWriter(TaskAttemptContext context) throws IOException
{    Configuration conf = context.getConfiguration();    String name = getUniqueFile(context, "part");    Path dir = FileOutputFormat.getOutputPath(context);    FileSystem fs = dir.getFileSystem(context.getConfiguration());    if (conf.getBoolean("parse.filter.urls", true)) {        filters = new URLFilters(conf);        exemptionFilters = new URLExemptionFilters(conf);    }    if (conf.getBoolean("parse.normalize.urls", true)) {        normalizers = new URLNormalizers(conf, URLNormalizers.SCOPE_OUTLINK);    }    this.scfilters = new ScoringFilters(conf);    final int interval = conf.getInt("db.fetch.interval.default", 2592000);    final boolean ignoreInternalLinks = conf.getBoolean("db.ignore.internal.links", false);    final boolean ignoreExternalLinks = conf.getBoolean("db.ignore.external.links", false);    final String ignoreExternalLinksMode = conf.get("db.ignore.external.links.mode", "byHost");            final boolean storeText = conf.getBoolean("parser.store.text", true);    int maxOutlinksPerPage = conf.getInt("db.max.outlinks.per.page", 100);    final int maxOutlinks = (maxOutlinksPerPage < 0) ? Integer.MAX_VALUE : maxOutlinksPerPage;    int maxOutlinkL = conf.getInt("db.max.outlink.length", 4096);    final int maxOutlinkLength = (maxOutlinkL < 0) ? Integer.MAX_VALUE : maxOutlinkL;    final boolean isParsing = conf.getBoolean("fetcher.parse", true);    final CompressionType compType = SequenceFileOutputFormat.getOutputCompressionType(context);    Path out = FileOutputFormat.getOutputPath(context);    Path text = new Path(new Path(out, ParseText.DIR_NAME), name);    Path data = new Path(new Path(out, ParseData.DIR_NAME), name);    Path crawl = new Path(new Path(out, CrawlDatum.PARSE_DIR_NAME), name);    final String[] parseMDtoCrawlDB = conf.get("db.parsemeta.to.crawldb", "").split(" *, *");        final MapFile.Writer textOut;    if (storeText) {        Option tKeyClassOpt = (Option) MapFile.Writer.keyClass(Text.class);        org.apache.hadoop.io.SequenceFile.Writer.Option tValClassOpt = SequenceFile.Writer.valueClass(ParseText.class);        org.apache.hadoop.io.SequenceFile.Writer.Option tProgressOpt = SequenceFile.Writer.progressable((Progressable) context);        org.apache.hadoop.io.SequenceFile.Writer.Option tCompOpt = SequenceFile.Writer.compression(CompressionType.RECORD);        textOut = new MapFile.Writer(conf, text, tKeyClassOpt, tValClassOpt, tCompOpt, tProgressOpt);    } else {        textOut = null;    }        Option dKeyClassOpt = (Option) MapFile.Writer.keyClass(Text.class);    org.apache.hadoop.io.SequenceFile.Writer.Option dValClassOpt = SequenceFile.Writer.valueClass(ParseData.class);    org.apache.hadoop.io.SequenceFile.Writer.Option dProgressOpt = SequenceFile.Writer.progressable((Progressable) context);    org.apache.hadoop.io.SequenceFile.Writer.Option dCompOpt = SequenceFile.Writer.compression(compType);    final MapFile.Writer dataOut = new MapFile.Writer(conf, data, dKeyClassOpt, dValClassOpt, dCompOpt, dProgressOpt);    final SequenceFile.Writer crawlOut = SequenceFile.createWriter(conf, SequenceFile.Writer.file(crawl), SequenceFile.Writer.keyClass(Text.class), SequenceFile.Writer.valueClass(CrawlDatum.class), SequenceFile.Writer.bufferSize(fs.getConf().getInt("io.file.buffer.size", 4096)), SequenceFile.Writer.replication(fs.getDefaultReplication(crawl)), SequenceFile.Writer.blockSize(1073741824), SequenceFile.Writer.compression(compType, new DefaultCodec()), SequenceFile.Writer.progressable((Progressable) context), SequenceFile.Writer.metadata(new Metadata()));    return new RecordWriter<Text, Parse>() {        public void write(Text key, Parse parse) throws IOException {            String fromUrl = key.toString();                        String origin = null;            if (textOut != null) {                textOut.append(key, new ParseText(parse.getText()));            }            ParseData parseData = parse.getData();                        String sig = parseData.getContentMeta().get(Nutch.SIGNATURE_KEY);            if (sig != null) {                byte[] signature = StringUtil.fromHexString(sig);                if (signature != null) {                                        CrawlDatum d = new CrawlDatum(CrawlDatum.STATUS_SIGNATURE, 0);                    d.setSignature(signature);                    crawlOut.append(key, d);                }            }                                    CrawlDatum parseMDCrawlDatum = null;            for (String mdname : parseMDtoCrawlDB) {                String mdvalue = parse.getData().getParseMeta().get(mdname);                if (mdvalue != null) {                    if (parseMDCrawlDatum == null)                        parseMDCrawlDatum = new CrawlDatum(CrawlDatum.STATUS_PARSE_META, 0);                    parseMDCrawlDatum.getMetaData().put(new Text(mdname), new Text(mdvalue));                }            }            if (parseMDCrawlDatum != null)                crawlOut.append(key, parseMDCrawlDatum);                        if (ignoreExternalLinks || ignoreInternalLinks) {                URL originURL = new URL(fromUrl.toString());                                if ("bydomain".equalsIgnoreCase(ignoreExternalLinksMode)) {                    origin = URLUtil.getDomainName(originURL).toLowerCase();                } else                 {                    origin = originURL.getHost().toLowerCase();                }            }            ParseStatus pstatus = parseData.getStatus();            if (pstatus != null && pstatus.isSuccess() && pstatus.getMinorCode() == ParseStatus.SUCCESS_REDIRECT) {                String newUrl = pstatus.getMessage();                int refreshTime = Integer.valueOf(pstatus.getArgs()[1]);                newUrl = filterNormalize(fromUrl, newUrl, origin, ignoreInternalLinks, ignoreExternalLinks, ignoreExternalLinksMode, filters, exemptionFilters, normalizers, URLNormalizers.SCOPE_FETCHER);                if (newUrl != null) {                    String reprUrl = URLUtil.chooseRepr(fromUrl, newUrl, refreshTime < Fetcher.PERM_REFRESH_TIME);                    CrawlDatum newDatum = new CrawlDatum();                    newDatum.setStatus(CrawlDatum.STATUS_LINKED);                    if (reprUrl != null && !reprUrl.equals(newUrl)) {                        newDatum.getMetaData().put(Nutch.WRITABLE_REPR_URL_KEY, new Text(reprUrl));                    }                    crawlOut.append(new Text(newUrl), newDatum);                }            }                        Outlink[] links = parseData.getOutlinks();            int outlinksToStore = Math.min(maxOutlinks, links.length);            int validCount = 0;            CrawlDatum adjust = null;            List<Entry<Text, CrawlDatum>> targets = new ArrayList<>(outlinksToStore);            List<Outlink> outlinkList = new ArrayList<>(outlinksToStore);            for (int i = 0; i < links.length && validCount < outlinksToStore; i++) {                String toUrl = links[i].getToUrl();                                if (!isParsing) {                    if (toUrl.length() > maxOutlinkLength) {                        continue;                    }                    toUrl = ParseOutputFormat.filterNormalize(fromUrl, toUrl, origin, ignoreInternalLinks, ignoreExternalLinks, ignoreExternalLinksMode, filters, exemptionFilters, normalizers);                    if (toUrl == null) {                        continue;                    }                }                CrawlDatum target = new CrawlDatum(CrawlDatum.STATUS_LINKED, interval);                Text targetUrl = new Text(toUrl);                                                                MapWritable outlinkMD = links[i].getMetadata();                if (outlinkMD != null) {                    target.getMetaData().putAll(outlinkMD);                }                try {                    scfilters.initialScore(targetUrl, target);                } catch (ScoringFilterException e) {                    LOG.warn("Cannot filter init score for url " + key + ", using default: " + e.getMessage());                    target.setScore(0.0f);                }                targets.add(new SimpleEntry(targetUrl, target));                                links[i].setUrl(toUrl);                outlinkList.add(links[i]);                validCount++;            }            try {                                adjust = scfilters.distributeScoreToOutlinks(key, parseData, targets, null, links.length);            } catch (ScoringFilterException e) {                LOG.warn("Cannot distribute score from " + key + ": " + e.getMessage());            }            for (Entry<Text, CrawlDatum> target : targets) {                crawlOut.append(target.getKey(), target.getValue());            }            if (adjust != null)                crawlOut.append(key, adjust);            Outlink[] filteredLinks = outlinkList.toArray(new Outlink[outlinkList.size()]);            parseData = new ParseData(parseData.getStatus(), parseData.getTitle(), filteredLinks, parseData.getContentMeta(), parseData.getParseMeta());            dataOut.append(key, parseData);            if (!parse.isCanonical()) {                CrawlDatum datum = new CrawlDatum();                datum.setStatus(CrawlDatum.STATUS_FETCH_SUCCESS);                String timeString = parse.getData().getContentMeta().get(Nutch.FETCH_TIME_KEY);                try {                    datum.setFetchTime(Long.parseLong(timeString));                } catch (Exception e) {                    LOG.warn("Can't read fetch time for: " + key);                    datum.setFetchTime(System.currentTimeMillis());                }                crawlOut.append(key, datum);            }        }        public void close(TaskAttemptContext context) throws IOException {            if (textOut != null)                textOut.close();            dataOut.close();            crawlOut.close();        }    };}
fd1671275549899796a1b9364a86ffec2a628f357b09b417b2194e809cccddd1
write
public void write(Text key, Parse parse) throws IOException
{    String fromUrl = key.toString();        String origin = null;    if (textOut != null) {        textOut.append(key, new ParseText(parse.getText()));    }    ParseData parseData = parse.getData();        String sig = parseData.getContentMeta().get(Nutch.SIGNATURE_KEY);    if (sig != null) {        byte[] signature = StringUtil.fromHexString(sig);        if (signature != null) {                        CrawlDatum d = new CrawlDatum(CrawlDatum.STATUS_SIGNATURE, 0);            d.setSignature(signature);            crawlOut.append(key, d);        }    }            CrawlDatum parseMDCrawlDatum = null;    for (String mdname : parseMDtoCrawlDB) {        String mdvalue = parse.getData().getParseMeta().get(mdname);        if (mdvalue != null) {            if (parseMDCrawlDatum == null)                parseMDCrawlDatum = new CrawlDatum(CrawlDatum.STATUS_PARSE_META, 0);            parseMDCrawlDatum.getMetaData().put(new Text(mdname), new Text(mdvalue));        }    }    if (parseMDCrawlDatum != null)        crawlOut.append(key, parseMDCrawlDatum);        if (ignoreExternalLinks || ignoreInternalLinks) {        URL originURL = new URL(fromUrl.toString());                if ("bydomain".equalsIgnoreCase(ignoreExternalLinksMode)) {            origin = URLUtil.getDomainName(originURL).toLowerCase();        } else         {            origin = originURL.getHost().toLowerCase();        }    }    ParseStatus pstatus = parseData.getStatus();    if (pstatus != null && pstatus.isSuccess() && pstatus.getMinorCode() == ParseStatus.SUCCESS_REDIRECT) {        String newUrl = pstatus.getMessage();        int refreshTime = Integer.valueOf(pstatus.getArgs()[1]);        newUrl = filterNormalize(fromUrl, newUrl, origin, ignoreInternalLinks, ignoreExternalLinks, ignoreExternalLinksMode, filters, exemptionFilters, normalizers, URLNormalizers.SCOPE_FETCHER);        if (newUrl != null) {            String reprUrl = URLUtil.chooseRepr(fromUrl, newUrl, refreshTime < Fetcher.PERM_REFRESH_TIME);            CrawlDatum newDatum = new CrawlDatum();            newDatum.setStatus(CrawlDatum.STATUS_LINKED);            if (reprUrl != null && !reprUrl.equals(newUrl)) {                newDatum.getMetaData().put(Nutch.WRITABLE_REPR_URL_KEY, new Text(reprUrl));            }            crawlOut.append(new Text(newUrl), newDatum);        }    }        Outlink[] links = parseData.getOutlinks();    int outlinksToStore = Math.min(maxOutlinks, links.length);    int validCount = 0;    CrawlDatum adjust = null;    List<Entry<Text, CrawlDatum>> targets = new ArrayList<>(outlinksToStore);    List<Outlink> outlinkList = new ArrayList<>(outlinksToStore);    for (int i = 0; i < links.length && validCount < outlinksToStore; i++) {        String toUrl = links[i].getToUrl();                if (!isParsing) {            if (toUrl.length() > maxOutlinkLength) {                continue;            }            toUrl = ParseOutputFormat.filterNormalize(fromUrl, toUrl, origin, ignoreInternalLinks, ignoreExternalLinks, ignoreExternalLinksMode, filters, exemptionFilters, normalizers);            if (toUrl == null) {                continue;            }        }        CrawlDatum target = new CrawlDatum(CrawlDatum.STATUS_LINKED, interval);        Text targetUrl = new Text(toUrl);                                MapWritable outlinkMD = links[i].getMetadata();        if (outlinkMD != null) {            target.getMetaData().putAll(outlinkMD);        }        try {            scfilters.initialScore(targetUrl, target);        } catch (ScoringFilterException e) {            LOG.warn("Cannot filter init score for url " + key + ", using default: " + e.getMessage());            target.setScore(0.0f);        }        targets.add(new SimpleEntry(targetUrl, target));                links[i].setUrl(toUrl);        outlinkList.add(links[i]);        validCount++;    }    try {                adjust = scfilters.distributeScoreToOutlinks(key, parseData, targets, null, links.length);    } catch (ScoringFilterException e) {        LOG.warn("Cannot distribute score from " + key + ": " + e.getMessage());    }    for (Entry<Text, CrawlDatum> target : targets) {        crawlOut.append(target.getKey(), target.getValue());    }    if (adjust != null)        crawlOut.append(key, adjust);    Outlink[] filteredLinks = outlinkList.toArray(new Outlink[outlinkList.size()]);    parseData = new ParseData(parseData.getStatus(), parseData.getTitle(), filteredLinks, parseData.getContentMeta(), parseData.getParseMeta());    dataOut.append(key, parseData);    if (!parse.isCanonical()) {        CrawlDatum datum = new CrawlDatum();        datum.setStatus(CrawlDatum.STATUS_FETCH_SUCCESS);        String timeString = parse.getData().getContentMeta().get(Nutch.FETCH_TIME_KEY);        try {            datum.setFetchTime(Long.parseLong(timeString));        } catch (Exception e) {            LOG.warn("Can't read fetch time for: " + key);            datum.setFetchTime(System.currentTimeMillis());        }        crawlOut.append(key, datum);    }}
118202e50c9711dbea3c9045d10f01c58e2fd2ce631f1eb50a35dad80b983835
close
public void close(TaskAttemptContext context) throws IOException
{    if (textOut != null)        textOut.close();    dataOut.close();    crawlOut.close();}
fb5735e4ae640e345f0ef410b998b4b89f57dd3a25c9eefab80f740208dd2b9c
filterNormalize
public static String filterNormalize(String fromUrl, String toUrl, String fromHost, boolean ignoreInternalLinks, boolean ignoreExternalLinks, String ignoreExternalLinksMode, URLFilters filters, URLExemptionFilters exemptionFilters, URLNormalizers normalizers)
{    return filterNormalize(fromUrl, toUrl, fromHost, ignoreInternalLinks, ignoreExternalLinks, ignoreExternalLinksMode, filters, exemptionFilters, normalizers, URLNormalizers.SCOPE_OUTLINK);}
14ee269f3cf0c20ab0dfea5c06e07125d6c7fe13768e37b339d8acc2d471ffe7
filterNormalize
public static String filterNormalize(String fromUrl, String toUrl, String origin, boolean ignoreInternalLinks, boolean ignoreExternalLinks, String ignoreExternalLinksMode, URLFilters filters, URLExemptionFilters exemptionFilters, URLNormalizers normalizers, String urlNormalizerScope)
{        if (fromUrl.equals(toUrl)) {        return null;    }    if (ignoreExternalLinks || ignoreInternalLinks) {        URL targetURL = null;        try {            targetURL = new URL(toUrl);        } catch (MalformedURLException e1) {                        return null;        }        if (ignoreExternalLinks) {            if ("bydomain".equalsIgnoreCase(ignoreExternalLinksMode)) {                String toDomain = URLUtil.getDomainName(targetURL).toLowerCase();                                if (toDomain == null || !toDomain.equals(origin)) {                                        return null;                }            } else {                String toHost = targetURL.getHost().toLowerCase();                if (!toHost.equals(origin)) {                                        if (                    exemptionFilters == null || !exemptionFilters.isExempted(fromUrl, toUrl)) {                                                return null;                    }                }            }        }        if (ignoreInternalLinks) {            if ("bydomain".equalsIgnoreCase(ignoreExternalLinksMode)) {                String toDomain = URLUtil.getDomainName(targetURL).toLowerCase();                                if (toDomain == null || toDomain.equals(origin)) {                                        return null;                }            } else {                String toHost = targetURL.getHost().toLowerCase();                                if (toHost == null || toHost.equals(origin)) {                                        return null;                }            }        }    }    try {        if (normalizers != null) {                        toUrl = normalizers.normalize(toUrl, urlNormalizerScope);                }        if (filters != null) {                        toUrl = filters.filter(toUrl);        }        if (toUrl == null) {            return null;        }    } catch (Exception e) {        return null;    }    return toUrl;}
7e48f7eba8bcc2aeff4aa37f100f0bfe0e720df615bf60925b2ad72f7791d8d6
getPluginList
 List<String> getPluginList(String mimeType)
{    return fMimeTypeToPluginMap.get(mimeType);}
7acc352d26045170d8a1251fca5a3a8cda2fdbf515cd723577bfd7491f984876
setAliases
 void setAliases(Map<String, String> aliases)
{    this.aliases = aliases;}
980c384e4561d8e03924802e5f901413fbe3e53585237b1fa82dbf5403f73040
getAliases
 Map<String, String> getAliases()
{    return aliases;}
64f8ec1ac0d346d9d2f933e3711d7fb6817c5a973776d6ef9a71cc660bf33c87
setPluginList
 void setPluginList(String mimeType, List<String> l)
{    fMimeTypeToPluginMap.put(mimeType, l);}
4e5fb33091ae96a8ac88cafbfdafe09b137fb635aa0963cf0d1f4254e6fb8f6b
getSupportedMimeTypes
 List<String> getSupportedMimeTypes()
{    return Arrays.asList(fMimeTypeToPluginMap.keySet().toArray(new String[] {}));}
a186a144eb4be4d9462aa3a28f79e5a11c940f656c18a59613f6f57383051610
parse
public ParsePluginList parse(Configuration conf)
{    ParsePluginList pList = new ParsePluginList();        DocumentBuilderFactory factory = null;    DocumentBuilder parser = null;    Document document = null;    InputSource inputSource = null;    InputStream ppInputStream = null;    if (fParsePluginsFile != null) {        URL parsePluginUrl = null;        try {            parsePluginUrl = new URL(fParsePluginsFile);            ppInputStream = parsePluginUrl.openStream();        } catch (Exception e) {            if (LOG.isWarnEnabled()) {                LOG.warn("Unable to load parse plugins file from URL " + "[" + fParsePluginsFile + "]. Reason is [" + e + "]");            }            return pList;        }    } else {        ppInputStream = conf.getConfResourceAsInputStream(conf.get(PP_FILE_PROP));    }    inputSource = new InputSource(ppInputStream);    try {        factory = DocumentBuilderFactory.newInstance();        parser = factory.newDocumentBuilder();        document = parser.parse(inputSource);    } catch (Exception e) {        if (LOG.isWarnEnabled()) {            LOG.warn("Unable to parse [" + fParsePluginsFile + "]." + "Reason is [" + e + "]");        }        return null;    }    Element parsePlugins = document.getDocumentElement();        Map<String, String> aliases = getAliases(parsePlugins);        pList.setAliases(aliases);        NodeList mimeTypes = parsePlugins.getElementsByTagName("mimeType");        for (int i = 0; i < mimeTypes.getLength(); i++) {        Element mimeType = (Element) mimeTypes.item(i);        String mimeTypeStr = mimeType.getAttribute("name");                NodeList pluginList = mimeType.getElementsByTagName("plugin");                if (pluginList != null && pluginList.getLength() > 0) {            List<String> plugList = new ArrayList<>(pluginList.getLength());            for (int j = 0; j < pluginList.getLength(); j++) {                Element plugin = (Element) pluginList.item(j);                String pluginId = plugin.getAttribute("id");                String extId = aliases.get(pluginId);                if (extId == null) {                                        extId = pluginId;                }                String orderStr = plugin.getAttribute("order");                int order = -1;                try {                    order = Integer.parseInt(orderStr);                } catch (NumberFormatException ignore) {                }                if (order != -1) {                    plugList.add(order - 1, extId);                } else {                    plugList.add(extId);                }            }                        pList.setPluginList(mimeTypeStr, plugList);        } else if (LOG.isWarnEnabled()) {            LOG.warn("ParsePluginsReader:ERROR:no plugins defined for mime type: " + mimeTypeStr + ", continuing parse");        }    }    return pList;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    String parsePluginFile = null;    String usage = "ParsePluginsReader [--file <parse plugin file location>]";    if ((args.length != 0 && args.length != 2) || (args.length == 2 && !"--file".equals(args[0]))) {        System.err.println(usage);        System.exit(1);    }    for (int i = 0; i < args.length; i++) {        if (args[i].equals("--file")) {            parsePluginFile = args[++i];        }    }    ParsePluginsReader reader = new ParsePluginsReader();    if (parsePluginFile != null) {        reader.setFParsePluginsFile(parsePluginFile);    }    ParsePluginList prefs = reader.parse(NutchConfiguration.create());    for (String mimeType : prefs.getSupportedMimeTypes()) {        System.out.println("MIMETYPE: " + mimeType);        List<String> plugList = prefs.getPluginList(mimeType);        System.out.println("EXTENSION IDs:");        for (String j : plugList) {            System.out.println(j);        }    }}
06afe67984f1a6de04c17ed0632a57a98ebdb462047f09c72b63f8ca13a6b089
getFParsePluginsFile
public String getFParsePluginsFile()
{    return fParsePluginsFile;}
8edc19f2ab72aad505b67ce17e39898c7c42180d0c5d0d03d31fdfb731259f01
setFParsePluginsFile
public void setFParsePluginsFile(String parsePluginsFile)
{    fParsePluginsFile = parsePluginsFile;}
f14853492d8e40bca04f6c0e88e244de072a640221b09981603a770c00a92a4e
getAliases
private Map<String, String> getAliases(Element parsePluginsRoot)
{    Map<String, String> aliases = new HashMap<>();    NodeList aliasRoot = parsePluginsRoot.getElementsByTagName("aliases");    if (aliasRoot == null || aliasRoot.getLength() == 0) {        if (LOG.isWarnEnabled()) {            LOG.warn("No aliases defined in parse-plugins.xml!");        }        return aliases;    }    if (aliasRoot.getLength() > 1) {                if (LOG.isWarnEnabled()) {            LOG.warn("There should only be one \"aliases\" tag in parse-plugins.xml");        }    }    Element aliasRootElem = (Element) aliasRoot.item(0);    NodeList aliasElements = aliasRootElem.getElementsByTagName("alias");    if (aliasElements != null && aliasElements.getLength() > 0) {        for (int i = 0; i < aliasElements.getLength(); i++) {            Element aliasElem = (Element) aliasElements.item(i);            String parsePluginId = aliasElem.getAttribute("name");            String extensionId = aliasElem.getAttribute("extension-id");            if (LOG.isTraceEnabled()) {                LOG.trace("Found alias: plugin-id: " + parsePluginId + ", extension-id: " + extensionId);            }            if (parsePluginId != null && extensionId != null) {                aliases.put(parsePluginId, extensionId);            }        }    }    return aliases;}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    String url = null;    String usage =     "Usage:\n" +     "  ParserChecker [OPTIONS] <url>\n" +     "    Fetch single URL and parse it\n" +     "  ParserChecker [OPTIONS] -stdin\n" +     "    Read URLs to be parsed from stdin\n" +     "  ParserChecker [OPTIONS] -listen <port> [-keepClientCnxOpen]\n" +     "    Listen on <port> for URLs to be parsed\n" +     "Options:\n" +     "  -D<property>=<value>\tset/overwrite Nutch/Hadoop properties\n" +     "                  \t(a generic Hadoop option to be passed\n" + "                  \t before other command-specific options)\n" +     "  -normalize      \tnormalize URLs\n" +     "  -followRedirects\tfollow redirects when fetching URL\n" +     "  -dumpText       \talso show the plain-text extracted by parsers\n" +     "  -forceAs <mimeType>\tforce parsing as <mimeType>\n" + "  -md <key>=<value>\tmetadata added to CrawlDatum before parsing\n";        if (args.length < 1) {        System.err.println(usage);        System.exit(-1);    }    int numConsumed;    for (int i = 0; i < args.length; i++) {        if (args[i].equals("-normalize")) {            normalizers = new URLNormalizers(getConf(), URLNormalizers.SCOPE_DEFAULT);        } else if (args[i].equals("-followRedirects")) {            followRedirects = true;        } else if (args[i].equals("-forceAs")) {            forceAsContentType = args[++i];        } else if (args[i].equals("-dumpText")) {            dumpText = true;        } else if (args[i].equals("-md")) {            String k = null, v = null;            String nextOne = args[++i];            int firstEquals = nextOne.indexOf("=");            if (firstEquals != -1) {                k = nextOne.substring(0, firstEquals);                v = nextOne.substring(firstEquals + 1);            } else                k = nextOne;            metadata.put(k, v);        } else if ((numConsumed = super.parseArgs(args, i)) > 0) {            i += numConsumed - 1;        } else if (i != args.length - 1) {            System.err.println("ERR: Not a recognized argument: " + args[i]);            System.err.println(usage);            System.exit(-1);        } else {            url = args[i];        }    }    scfilters = new ScoringFilters(getConf());    if (url != null) {        return super.processSingle(url);    } else {                return super.run();    }}
563ec4efd6e4e3fda75530afd24463760e6ea1470b0992ce11ca2059e645f277
process
protected int process(String url, StringBuilder output) throws Exception
{    if (normalizers != null) {        url = normalizers.normalize(url, URLNormalizers.SCOPE_DEFAULT);    }    LOG.info("fetching: " + url);    CrawlDatum datum = new CrawlDatum();    Iterator<String> iter = metadata.keySet().iterator();    while (iter.hasNext()) {        String key = iter.next();        String value = metadata.get(key);        if (value == null)            value = "";        datum.getMetaData().put(new Text(key), new Text(value));    }    int maxRedirects = getConf().getInt("http.redirect.max", 3);    if (followRedirects) {        if (maxRedirects == 0) {            LOG.info("Following max. 3 redirects (ignored http.redirect.max == 0)");            maxRedirects = 3;        } else {            LOG.info("Following max. {} redirects", maxRedirects);        }    }    ProtocolOutput protocolOutput = getProtocolOutput(url, datum);    Text turl = new Text(url);        int numRedirects = 0;    while (!protocolOutput.getStatus().isSuccess() && followRedirects && protocolOutput.getStatus().isRedirect() && maxRedirects >= numRedirects) {        String[] stuff = protocolOutput.getStatus().getArgs();        url = stuff[0];        LOG.info("Follow redirect to {}", url);        if (normalizers != null) {            url = normalizers.normalize(url, URLNormalizers.SCOPE_DEFAULT);        }        turl.set(url);                protocolOutput = getProtocolOutput(url, datum);        numRedirects++;    }    if (!protocolOutput.getStatus().isSuccess()) {        System.err.println("Fetch failed with protocol status: " + protocolOutput.getStatus());        if (protocolOutput.getStatus().isRedirect()) {            System.err.println("Redirect(s) not handled due to configuration.");            System.err.println("Max Redirects to handle per config: " + maxRedirects);            System.err.println("Number of Redirects handled: " + numRedirects);        }        return -1;    }    Content content = protocolOutput.getContent();    if (content == null) {        output.append("No content for " + url + "\n");        return 0;    }    String contentType;    if (forceAsContentType != null) {        content.setContentType(forceAsContentType);        contentType = forceAsContentType;    } else {        contentType = content.getContentType();    }    if (contentType == null) {        LOG.error("Failed to determine content type!");        return -1;    }        datum.getMetaData().put(new Text(Metadata.CONTENT_TYPE), new Text(contentType));    if (ParseSegment.isTruncated(content)) {        LOG.warn("Content is truncated, parse may fail!");    }        try {        scfilters.passScoreBeforeParsing(turl, datum, content);    } catch (Exception e) {        if (LOG.isWarnEnabled()) {            LOG.warn("Couldn't pass score before parsing, url " + turl + " (" + e + ")");            LOG.warn(StringUtils.stringifyException(e));        }    }    ParseResult parseResult = new ParseUtil(getConf()).parse(content);    if (parseResult == null) {        LOG.error("Parsing content failed!");        return (-1);    }        byte[] signature = SignatureFactory.getSignature(getConf()).calculate(content, parseResult.get(new Text(url)));    if (LOG.isInfoEnabled()) {        LOG.info("parsing: " + url);        LOG.info("contentType: " + contentType);        LOG.info("signature: " + StringUtil.toHexString(signature));    }    for (Map.Entry<Text, Parse> entry : parseResult) {        turl = entry.getKey();        Parse parse = entry.getValue();                try {            scfilters.passScoreAfterParsing(turl, content, parse);        } catch (Exception e) {            if (LOG.isWarnEnabled()) {                LOG.warn("Couldn't pass score after parsing, url " + turl + " (" + e + ")");                LOG.warn(StringUtils.stringifyException(e));            }        }        output.append(turl + "\n");        output.append(parse.getData() + "\n");        if (dumpText) {            output.append(parse.getText());        }    }    return 0;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int res = ToolRunner.run(NutchConfiguration.create(), new ParserChecker(), args);    System.exit(res);}
0be9684b222a2c3d68b3ee10463dfa1f9141302038261de5b5504362737efceb
createParseResult
public static ParseResult createParseResult(String url, Parse parse)
{    ParseResult parseResult = new ParseResult(url);    parseResult.put(new Text(url), new ParseText(parse.getText()), parse.getData());    return parseResult;}
803915e853382ad445a6e2333fabb8beb8e4acd70e908a0d818400f7baac42af
isEmpty
public boolean isEmpty()
{    return parseMap.isEmpty();}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return parseMap.size();}
c01353e586577f0aa9aed0ac544c6be79a753a0fead60ff2ed4fcbf5bccc7ea1
get
public Parse get(String key)
{    return get(new Text(key));}
30505dd8209399feaa229b9dc6ed0faff1ef6667c7686a2441f4ff505d4840ed
get
public Parse get(Text key)
{    return parseMap.get(key);}
90a9ad43a5c8921bfaec9111441215479aa50b712ddf877c225eed63f3254930
put
public void put(Text key, ParseText text, ParseData data)
{    put(key.toString(), text, data);}
3fbe8a534db8b5494fa24f508d1c2d81751694549cd927e438809641c430f305
put
public void put(String key, ParseText text, ParseData data)
{    parseMap.put(new Text(key), new ParseImpl(text, data, key.equals(originalUrl)));}
df2bfdc0a5a88f89c9163429b5e282009519290d96df7a34828cfb2f2a55d2bf
iterator
public Iterator<Entry<Text, Parse>> iterator()
{    return parseMap.entrySet().iterator();}
aaa8728280b643d6f2ce2059e07d52693163c65d9c72dd701a647b372c58b227
filter
public void filter()
{    for (Iterator<Entry<Text, Parse>> i = iterator(); i.hasNext(); ) {        Entry<Text, Parse> entry = i.next();        if (!entry.getValue().getData().getStatus().isSuccess()) {            LOG.warn(entry.getKey() + " is not parsed successfully, filtering");            i.remove();        }    }}
612931c72bde28f1dce5cd75713a8d061fc0015a7653f03c77fdbe463c352c87
isSuccess
public boolean isSuccess()
{    for (Iterator<Entry<Text, Parse>> i = iterator(); i.hasNext(); ) {        Entry<Text, Parse> entry = i.next();        if (!entry.getValue().getData().getStatus().isSuccess()) {            return false;        }    }    return true;}
fa76c322f382a112456fe2be2eace2e00dbcd43d5a83308f820aa7309bc8acbc
isAnySuccess
public boolean isAnySuccess()
{    for (Iterator<Entry<Text, Parse>> i = iterator(); i.hasNext(); ) {        Entry<Text, Parse> entry = i.next();        if (entry.getValue().getData().getStatus().isSuccess()) {            return true;        }    }    return false;}
2f56a6e37db44222bf977975df28c09544f5742258477bf67446ff72b9153a14
getParsers
public Parser[] getParsers(String contentType, String url) throws ParserNotFound
{    List<Parser> parsers = null;    List<Extension> parserExts = null;    ObjectCache objectCache = ObjectCache.get(conf);                                parserExts = getExtensions(contentType);    if (parserExts == null) {        throw new ParserNotFound(url, contentType);    }    parsers = new Vector<>(parserExts.size());    for (Iterator<Extension> i = parserExts.iterator(); i.hasNext(); ) {        Extension ext = i.next();        Parser p = null;        try {                        p = (Parser) objectCache.getObject(ext.getId());            if (p == null) {                                p = (Parser) ext.getExtensionInstance();                objectCache.setObject(ext.getId(), p);            }            parsers.add(p);        } catch (PluginRuntimeException e) {            if (LOG.isWarnEnabled()) {                LOG.warn("ParserFactory:PluginRuntimeException when " + "initializing parser plugin " + ext.getDescriptor().getPluginId() + " instance because: " + e.getMessage() + " - attempting to continue instantiating parsers", e);            }        }    }    return parsers.toArray(new Parser[] {});}
48370219e67c5ff933b4f2ddd2e66f9c1caa4374a1768775d978b3dfa0da1577
getParserById
public Parser getParserById(String id) throws ParserNotFound
{    Extension[] extensions = this.extensionPoint.getExtensions();    Extension parserExt = null;    ObjectCache objectCache = ObjectCache.get(conf);    if (id != null) {        parserExt = getExtension(extensions, id);    }    if (parserExt == null) {        parserExt = getExtensionFromAlias(extensions, id);    }    if (parserExt == null) {        throw new ParserNotFound("No Parser Found for id [" + id + "]");    }        if (objectCache.getObject(parserExt.getId()) != null) {        return (Parser) objectCache.getObject(parserExt.getId());        } else {        try {            Parser p = (Parser) parserExt.getExtensionInstance();            objectCache.setObject(parserExt.getId(), p);            return p;        } catch (PluginRuntimeException e) {            if (LOG.isWarnEnabled()) {                LOG.warn("Canno initialize parser " + parserExt.getDescriptor().getPluginId() + " (cause: " + e.toString());            }            throw new ParserNotFound("Cannot init parser for id [" + id + "]");        }    }}
99b801921fe9b8b6be14ac20765c01c13c82b4d00f0e47aa28f15f2f462d88ad
getExtensions
protected List<Extension> getExtensions(String contentType)
{    ObjectCache objectCache = ObjectCache.get(conf);        String type = null;    type = MimeUtil.cleanMimeType(contentType);    List<Extension> extensions = (List<Extension>) objectCache.getObject(type);        if (extensions == EMPTY_EXTENSION_LIST) {        return null;    }    if (extensions == null) {        extensions = findExtensions(type);        if (extensions != null) {            objectCache.setObject(type, extensions);        } else {                                    objectCache.setObject(type, EMPTY_EXTENSION_LIST);        }    }    return extensions;}
2523b94d4bbdd39d82c0f9060e32b507df8bea0b6f7268e9cb5769620982fa0e
findExtensions
private List<Extension> findExtensions(String contentType)
{    Extension[] extensions = this.extensionPoint.getExtensions();        List<String> parsePluginList = this.parsePluginList.getPluginList(contentType);    List<Extension> extensionList = matchExtensions(parsePluginList, extensions, contentType);    if (extensionList != null) {        return extensionList;    }        parsePluginList = this.parsePluginList.getPluginList(DEFAULT_PLUGIN);    return matchExtensions(parsePluginList, extensions, DEFAULT_PLUGIN);}
5cde5d04fd926c7ba897e8133f3f1153819ac8ffcdbe50fbecaeeb436df170e9
matchExtensions
private List<Extension> matchExtensions(List<String> plugins, Extension[] extensions, String contentType)
{    List<Extension> extList = new ArrayList<>();    if (plugins != null) {        for (String parsePluginId : plugins) {            Extension ext = getExtension(extensions, parsePluginId, contentType);            if (ext == null) {                                ext = getExtension(extensions, parsePluginId);                if (LOG.isWarnEnabled()) {                    if (ext != null) {                                                                                                LOG.warn("ParserFactory:Plugin: " + parsePluginId + " mapped to contentType " + contentType + " via parse-plugins.xml, but " + "its plugin.xml " + "file does not claim to support contentType: " + contentType);                    } else {                                                LOG.warn("ParserFactory: Plugin: " + parsePluginId + " mapped to contentType " + contentType + " via parse-plugins.xml, but not enabled via " + "plugin.includes in nutch-default.xml");                    }                }            }            if (ext != null) {                                extList.add(ext);            }        }    } else {        for (int i = 0; i < extensions.length; i++) {            if ("*".equals(extensions[i].getAttribute("contentType"))) {                extList.add(0, extensions[i]);            } else if (extensions[i].getAttribute("contentType") != null && contentType.matches(escapeContentType(extensions[i].getAttribute("contentType")))) {                extList.add(extensions[i]);            }        }        if (extList.size() > 0) {            if (LOG.isInfoEnabled()) {                StringBuffer extensionsIDs = new StringBuffer("[");                boolean isFirst = true;                for (Extension ext : extList) {                    if (!isFirst)                        extensionsIDs.append(" - ");                    else                        isFirst = false;                    extensionsIDs.append(ext.getId());                }                extensionsIDs.append("]");                LOG.info("The parsing plugins: " + extensionsIDs.toString() + " are enabled via the plugin.includes system " + "property, and all claim to support the content type " + contentType + ", but they are not mapped to it  in the " + "parse-plugins.xml file");            }        } else if (LOG.isDebugEnabled()) {            LOG.debug("ParserFactory:No parse plugins mapped or enabled for " + "contentType " + contentType);        }    }    return (extList.size() > 0) ? extList : null;}
8d43f94125232c45dbe22a8c0e589c221e8b8a26daf71ea26a716641eefb341f
escapeContentType
private String escapeContentType(String contentType)
{        return contentType.replace("+", "\\+").replace(".", "\\.");}
b9eb498aae6523914f7b5179886f0480b92f7ebd7c6c97a538c6882925772fdd
match
private boolean match(Extension extension, String id, String type)
{    return ((id.equals(extension.getId())) && (extension.getAttribute("contentType").equals("*") || type.matches(escapeContentType(extension.getAttribute("contentType"))) || type.equals(DEFAULT_PLUGIN)));}
e32c9955d88de3ea8fa2d8b2eeb4cd0816c5723b68080f26316cc56536ebb370
getExtension
private Extension getExtension(Extension[] list, String id, String type)
{    for (int i = 0; i < list.length; i++) {        if (match(list[i], id, type)) {            return list[i];        }    }    return null;}
e3af4416bbe6d05598e4e164674b4336dd5ad9763cc801f424003c5c3b62c271
getExtension
private Extension getExtension(Extension[] list, String id)
{    for (int i = 0; i < list.length; i++) {        if (id.equals(list[i].getId())) {            return list[i];        }    }    return null;}
1b2849e878ffc6c1ffeb2d65a0b3f0a7657bfc8f66a46a370dde068c8a0a1252
getExtensionFromAlias
private Extension getExtensionFromAlias(Extension[] list, String id)
{    return getExtension(list, parsePluginList.getAliases().get(id));}
354afe66bbdb19ee4d620955bbb214ebf9b5aa09359dea30ffb867002b5a25bd
getUrl
public String getUrl()
{    return url;}
baea39c86756a5efaaec8e2f01175d687e0a60e86379d9b91d98a3d4089abf86
getContentType
public String getContentType()
{    return contentType;}
addfe98b50f466a02b77d9a48a037b5bbdb50bf04379c6d7a0692d3bfe3f998d
setup
public void setup(Mapper<WritableComparable<?>, Content, Text, ParseImpl>.Context context)
{    Configuration conf = context.getConfiguration();    scfilters = new ScoringFilters(conf);    skipTruncated = conf.getBoolean(SKIP_TRUNCATED, true);}
2778012f52c2a7f59c6c1765a2439ec3859291f93e8799745965b94d3103029c
cleanup
public void cleanup(Context context)
{}
4bf4074aa1822c667a52d7e5ea1ec78ebc57b209b50890a80382f06cd77bc17f
map
public void map(WritableComparable<?> key, Content content, Context context) throws IOException, InterruptedException
{        if (key instanceof Text) {        newKey.set(key.toString());        key = newKey;    }    String fetchStatus = content.getMetadata().get(Nutch.FETCH_STATUS_KEY);    if (fetchStatus == null) {                LOG.debug("Skipping {} as content has no fetch status", key);        return;    } else if (Integer.parseInt(fetchStatus) != CrawlDatum.STATUS_FETCH_SUCCESS) {                LOG.debug("Skipping {} as content is not fetched successfully", key);        return;    }    if (skipTruncated && isTruncated(content)) {        return;    }    long start = System.currentTimeMillis();    ParseResult parseResult = null;    try {        if (parseUtil == null)            parseUtil = new ParseUtil(context.getConfiguration());        parseResult = parseUtil.parse(content);    } catch (Exception e) {        LOG.warn("Error parsing: " + key + ": " + StringUtils.stringifyException(e));        return;    }    for (Entry<Text, Parse> entry : parseResult) {        Text url = entry.getKey();        Parse parse = entry.getValue();        ParseStatus parseStatus = parse.getData().getStatus();        context.getCounter("ParserStatus", ParseStatus.majorCodes[parseStatus.getMajorCode()]).increment(1);        if (!parseStatus.isSuccess()) {            LOG.warn("Error parsing: " + key + ": " + parseStatus);            parse = parseStatus.getEmptyParse(context.getConfiguration());        }                parse.getData().getContentMeta().set(Nutch.SEGMENT_NAME_KEY, context.getConfiguration().get(Nutch.SEGMENT_NAME_KEY));                byte[] signature = SignatureFactory.getSignature(context.getConfiguration()).calculate(content, parse);        parse.getData().getContentMeta().set(Nutch.SIGNATURE_KEY, StringUtil.toHexString(signature));        try {            scfilters.passScoreAfterParsing(url, content, parse);        } catch (ScoringFilterException e) {            if (LOG.isWarnEnabled()) {                LOG.warn("Error passing score: " + url + ": " + e.getMessage());            }        }        long end = System.currentTimeMillis();        LOG.info("Parsed (" + Long.toString(end - start) + "ms):" + url);        context.write(url, new ParseImpl(new ParseText(parse.getText()), parse.getData(), parse.isCanonical()));    }}
129a2684af8477dbac9ac216585c49652c3a1ad523a01e2ebeb53164fadea0c7
isTruncated
public static boolean isTruncated(Content content)
{    byte[] contentBytes = content.getContent();    if (contentBytes == null)        return false;    Metadata metadata = content.getMetadata();    if (metadata == null)        return false;    String lengthStr = metadata.get(Response.CONTENT_LENGTH);    if (lengthStr != null)        lengthStr = lengthStr.trim();    if (StringUtil.isEmpty(lengthStr)) {        return false;    }    int inHeaderSize;    String url = content.getUrl();    try {        inHeaderSize = Integer.parseInt(lengthStr);    } catch (NumberFormatException e) {        LOG.warn("Wrong contentlength format for " + url, e);        return false;    }    int actualSize = contentBytes.length;    if (inHeaderSize > actualSize) {        LOG.info(url + " skipped. Content of size " + inHeaderSize + " was truncated to " + actualSize);        return true;    }    if (LOG.isDebugEnabled()) {        LOG.debug(url + " actualSize=" + actualSize + " inHeaderSize=" + inHeaderSize);    }    return false;}
9de2ce6e2ff5aad98ae61813db583ed64fb65e862714548cf20ac06acc27f8df
reduce
public void reduce(Text key, Iterable<Writable> values, Context context) throws IOException, InterruptedException
{    Iterator<Writable> valuesIter = values.iterator();        context.write(key, valuesIter.next());}
c90ddca42d072a0fb99340b999926e5385c948a42c8bd1d5f7fa20257241e117
parse
public void parse(Path segment) throws IOException, InterruptedException, ClassNotFoundException
{    if (SegmentChecker.isParsed(segment, segment.getFileSystem(getConf()))) {        LOG.warn("Segment: " + segment +         " already parsed!! Skipped parsing this segment!!");        return;    }    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    long start = System.currentTimeMillis();    if (LOG.isInfoEnabled()) {        LOG.info("ParseSegment: starting at {}", sdf.format(start));        LOG.info("ParseSegment: segment: {}", segment);    }    Job job = NutchJob.getInstance(getConf());    job.setJobName("parse " + segment);    Configuration conf = job.getConfiguration();    FileInputFormat.addInputPath(job, new Path(segment, Content.DIR_NAME));    conf.set(Nutch.SEGMENT_NAME_KEY, segment.getName());    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setJarByClass(ParseSegment.class);    job.setMapperClass(ParseSegment.ParseSegmentMapper.class);    job.setReducerClass(ParseSegment.ParseSegmentReducer.class);    FileOutputFormat.setOutputPath(job, segment);    job.setOutputFormatClass(ParseOutputFormat.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(ParseImpl.class);    try {        boolean success = job.waitForCompletion(true);        if (!success) {            String message = "Parse job did not succeed, job status:" + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);            throw new RuntimeException(message);        }    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error(StringUtils.stringifyException(e));        throw e;    }    long end = System.currentTimeMillis();    LOG.info("ParseSegment: finished at " + sdf.format(end) + ", elapsed: " + TimingUtil.elapsedTime(start, end));}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int res = ToolRunner.run(NutchConfiguration.create(), new ParseSegment(), args);    System.exit(res);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    Path segment;    String usage = "Usage: ParseSegment segment [-noFilter] [-noNormalize]";    if (args.length == 0) {        System.err.println(usage);        System.exit(-1);    }    if (args.length > 1) {        for (int i = 1; i < args.length; i++) {            String param = args[i];            if ("-nofilter".equalsIgnoreCase(param)) {                getConf().setBoolean("parse.filter.urls", false);            } else if ("-nonormalize".equalsIgnoreCase(param)) {                getConf().setBoolean("parse.normalize.urls", false);            }        }    }    segment = new Path(args[0]);    parse(segment);    return 0;}
084523121ab64bd9486b37875e438171d2b2467ace02bce8523551b0ce84ace4
run
public Map<String, Object> run(Map<String, Object> args, String crawlId) throws Exception
{    Map<String, Object> results = new HashMap<>();    Path segment = null;    if (args.containsKey(Nutch.ARG_SEGMENTS)) {        Object seg = args.get(Nutch.ARG_SEGMENTS);        if (seg instanceof Path) {            segment = (Path) seg;        } else if (seg instanceof String) {            segment = new Path(seg.toString());        } else if (seg instanceof ArrayList) {            String[] segmentsArray = (String[]) seg;            segment = new Path(segmentsArray[0].toString());            if (segmentsArray.length > 1) {                LOG.warn("Only the first segment of segments array is used.");            }        }    } else {        String segment_dir = crawlId + "/segments";        File segmentsDir = new File(segment_dir);        File[] segmentsList = segmentsDir.listFiles();        Arrays.sort(segmentsList, (f1, f2) -> {            if (f1.lastModified() > f2.lastModified())                return -1;            else                return 0;        });        segment = new Path(segmentsList[0].getPath());    }    if (args.containsKey("nofilter")) {        getConf().setBoolean("parse.filter.urls", false);    }    if (args.containsKey("nonormalize")) {        getConf().setBoolean("parse.normalize.urls", false);    }    parse(segment);    results.put(Nutch.VAL_RESULT, Integer.toString(0));    return results;}
030b04dc0daca5784913ea0b60fc938e081bf539c3416d1093544c0761d518b0
getVersion
public byte getVersion()
{    return VERSION;}
271f05b19cbcbbe0fc7da12f660303f146ff1c49e94c205cf89aff5707e0f7fb
read
public static ParseStatus read(DataInput in) throws IOException
{    ParseStatus res = new ParseStatus();    res.readFields(in);    return res;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    byte version = in.readByte();    switch(version) {        case 1:            majorCode = in.readByte();            minorCode = in.readShort();            args = WritableUtils.readCompressedStringArray(in);            break;        case 2:            majorCode = in.readByte();            minorCode = in.readShort();            args = WritableUtils.readStringArray(in);            break;        default:            throw new VersionMismatchException(VERSION, version);    }}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeByte(VERSION);    out.writeByte(majorCode);    out.writeShort(minorCode);    if (args == null) {        out.writeInt(-1);    } else {        WritableUtils.writeStringArray(out, args);    }}
612931c72bde28f1dce5cd75713a8d061fc0015a7653f03c77fdbe463c352c87
isSuccess
public boolean isSuccess()
{    return majorCode == SUCCESS;}
b46153cc21231cb60e014b6b3c49b437699575e4012681cb08026e5238c66751
getMessage
public String getMessage()
{    if (args != null && args.length > 0 && args[0] != null)        return args[0];    return null;}
63c9fbbfc8fd0c446fa0184a5eed4111e14f05b4735608439c43552757f7ae4c
getArgs
public String[] getArgs()
{    return args;}
3951eda68572e9de2d9ce39dd5912cb2f6a71853ef62a761dedf06a759e93a78
getMajorCode
public int getMajorCode()
{    return majorCode;}
1d62dc8165f36aec093667e5a602680893e51d92699ac6c31d4ca00aba184b32
getMinorCode
public int getMinorCode()
{    return minorCode;}
f87b47b82deed40472e216a6e8cbf4c7049a85819e95e2e1744e6a5c98a52590
getEmptyParse
public Parse getEmptyParse(Configuration conf)
{    return new EmptyParseImpl(this, conf);}
00c438fb3199ffd382b912af925598aaf8637331f1ff2451da3af6aaeb5b43f8
getEmptyParseResult
public ParseResult getEmptyParseResult(String url, Configuration conf)
{    return ParseResult.createParseResult(url, getEmptyParse(conf));}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuffer res = new StringBuffer();    String name = null;    if (majorCode >= 0 && majorCode < majorCodes.length)        name = majorCodes[majorCode];    else        name = "UNKNOWN!";    res.append(name + "(" + majorCode + "," + minorCode + ")");    if (args != null) {        if (args.length == 1) {            res.append(": " + String.valueOf(args[0]));        } else {            for (int i = 0; i < args.length; i++) {                if (args[i] != null)                    res.append(", args[" + i + "]=" + String.valueOf(args[i]));            }        }    }    return res.toString();}
0a0b1b63acd4735986d567c825abbda7a5cce7fff7021cbd22b60b2b93d27dce
setArgs
public void setArgs(String[] args)
{    this.args = args;}
96b2dc73882e9b3439c628f61bcafaaf041e75207cedefacb077f08f36772e92
setMessage
public void setMessage(String msg)
{    if (args == null || args.length == 0) {        args = new String[1];    }    args[0] = msg;}
5a88edbb7a290e8e0e912a18d6ea78ca225d4c7fa854649170266da304848700
setMajorCode
public void setMajorCode(byte majorCode)
{    this.majorCode = majorCode;}
a88f114fce9edf748d787763355b48a349f626633567c72bde6a2b2c6097ba11
setMinorCode
public void setMinorCode(short minorCode)
{    this.minorCode = minorCode;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (o == null)        return false;    if (!(o instanceof ParseStatus))        return false;    boolean res = true;    ParseStatus other = (ParseStatus) o;    res = res && (this.majorCode == other.majorCode) && (this.minorCode == other.minorCode);    if (!res)        return res;    if (this.args == null) {        if (other.args == null)            return true;        else            return false;    } else {        if (other.args == null)            return false;        if (other.args.length != this.args.length)            return false;        for (int i = 0; i < this.args.length; i++) {            if (!this.args[i].equals(other.args[i]))                return false;        }    }    return true;}
2eccfd3216064a47b7f606e71ba5ceff23ebe25e03a3cd5ab3d81a86cd08a928
getData
public ParseData getData()
{    return data;}
496805007af0b81862a2d8c2609ce7b43ae81205859ec65f6872584c88bc5dc7
getText
public String getText()
{    return "";}
d1cf6994e53f65296f2f70ed2fd388f02fa3bbc0b3df2ffa307c4402a9a7892e
isCanonical
public boolean isCanonical()
{    return true;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    byte version = in.readByte();    switch(version) {        case 1:            text = WritableUtils.readCompressedString(in);            break;        case VERSION:            text = Text.readString(in);            break;        default:            throw new VersionMismatchException(VERSION, version);    }}
6ce8f423999e48ee8ccc8ead0930648784c8032b66979cb68c99c4f899ae9ef8
write
public final void write(DataOutput out) throws IOException
{    out.write(VERSION);    Text.writeString(out, text);}
9bef3254b8cdf283d73997160a0c66e88e5d03af3ab7bb3d3a2e694846e09a41
read
public static final ParseText read(DataInput in) throws IOException
{    ParseText parseText = new ParseText();    parseText.readFields(in);    return parseText;}
496805007af0b81862a2d8c2609ce7b43ae81205859ec65f6872584c88bc5dc7
getText
public String getText()
{    return text;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof ParseText))        return false;    ParseText other = (ParseText) o;    return this.text.equals(other.text);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return text;}
6538d76a086933ae50b4ee6e131d43b17cf0047fe2ae644bcffc294ff69a38d9
main
public static void main(String[] argv) throws Exception
{    String usage = "ParseText (-local | -dfs <namenode:port>) recno segment";    if (argv.length < 3) {        System.out.println("usage:" + usage);        return;    }    Options opts = new Options();    Configuration conf = NutchConfiguration.create();    GenericOptionsParser parser = new GenericOptionsParser(conf, opts, argv);    String[] remainingArgs = parser.getRemainingArgs();    try (FileSystem fs = FileSystem.get(conf)) {        int recno = Integer.parseInt(remainingArgs[0]);        String segment = remainingArgs[1];        String filename = new Path(segment, ParseText.DIR_NAME).toString();        ParseText parseText = new ParseText();        ArrayFile.Reader parseTexts = new ArrayFile.Reader(fs, filename, conf);        parseTexts.get(recno, parseText);        System.out.println("Retrieved " + recno + " from file " + filename);        System.out.println(parseText);        parseTexts.close();    }}
7249f4d01fde4ed9592dc0796585c7ce76a056a1644033aa6ac2826f68f2886b
parse
public ParseResult parse(Content content) throws ParseException
{    Parser[] parsers = null;    try {        parsers = this.parserFactory.getParsers(content.getContentType(), content.getUrl() != null ? content.getUrl() : "");    } catch (ParserNotFound e) {        if (LOG.isWarnEnabled()) {            LOG.warn("No suitable parser found when trying to parse content " + content.getUrl() + " of type " + content.getContentType());        }        throw new ParseException(e.getMessage());    }    ParseResult parseResult = null;    for (int i = 0; i < parsers.length; i++) {        if (LOG.isDebugEnabled()) {            LOG.debug("Parsing [" + content.getUrl() + "] with [" + parsers[i] + "]");        }        if (maxParseTime != -1) {            parseResult = runParser(parsers[i], content);        } else {            try {                parseResult = parsers[i].getParse(content);            } catch (Throwable e) {                LOG.warn("Error parsing " + content.getUrl() + " with " + parsers[i].getClass().getName(), e);            }        }        if (parseResult != null && parseResult.isAnySuccess()) {            return parseResult;        }        }        if (parseResult != null && !parseResult.isEmpty()) {        return parseResult;    }    if (LOG.isWarnEnabled()) {        LOG.warn("Unable to successfully parse content " + content.getUrl() + " of type " + content.getContentType());    }    return new ParseStatus(new ParseException("Unable to successfully parse content")).getEmptyParseResult(content.getUrl(), null);}
61c0bc4027e068659b0d2024e10096282b0b841dc4d360238cb2f27cebac6322
parseByExtensionId
public ParseResult parseByExtensionId(String extId, Content content) throws ParseException
{    Parser p = null;    try {        p = this.parserFactory.getParserById(extId);    } catch (ParserNotFound e) {        if (LOG.isWarnEnabled()) {            LOG.warn("No suitable parser found when trying to parse content " + content.getUrl() + " of type " + content.getContentType());        }        throw new ParseException(e.getMessage());    }    ParseResult parseResult = null;    if (maxParseTime != -1) {        parseResult = runParser(p, content);    } else {        try {            parseResult = p.getParse(content);        } catch (Throwable e) {            LOG.warn("Error parsing " + content.getUrl() + " with " + p.getClass().getName(), e);        }    }    if (parseResult != null && !parseResult.isEmpty()) {        return parseResult;    } else {        if (LOG.isWarnEnabled()) {            LOG.warn("Unable to successfully parse content " + content.getUrl() + " of type " + content.getContentType());        }        return new ParseStatus(new ParseException("Unable to successfully parse content")).getEmptyParseResult(content.getUrl(), null);    }}
61ac669ee06331bb283bfb30b0f9ede4299cef6290dea2489bbe275fe09c766a
runParser
private ParseResult runParser(Parser p, Content content)
{    ParseCallable pc = new ParseCallable(p, content);    Future<ParseResult> task = executorService.submit(pc);    ParseResult res = null;    try {        res = task.get(maxParseTime, TimeUnit.SECONDS);    } catch (Exception e) {        LOG.warn("Error parsing " + content.getUrl() + " with " + p.getClass().getName(), e);        task.cancel(true);    } finally {        pc = null;    }    return res;}
7159239d5d85b28b1367d28c656874ae12a836f72f6be051cb8d16544d3787ba
setExtensionPoint
private void setExtensionPoint(String point)
{    fTargetPoint = point;}
17039133b8cee8bb4d064dd0b7ea999692a7038b1912eb255b04c7e44c0bc076
getAttribute
public String getAttribute(String pKey)
{    return fAttributes.get(pKey);}
45481ede6a739a5a3dec0877747e98a0da505cff1aa530eced1e5f4258af7d55
getClazz
public String getClazz()
{    return fClazz;}
09e8f13a9a603d31d64bb498b77d15572483824d843d0e82a570643192f62186
getId
public String getId()
{    return fId;}
ebe0b8d889dc4a3acfae77cf34bf48a4bc36c1951dcd9f280556c415ad6cf46f
addAttribute
public void addAttribute(String pKey, String pValue)
{    fAttributes.put(pKey, pValue);}
ec69ebb4fabfe8d86fba86d8ac9e0de2735446e4dc31720ef965bbcb8efbf9a1
setClazz
public void setClazz(String extensionClazz)
{    fClazz = extensionClazz;}
1afb237fb4ac5ea407dd11666dda80e92e13942e4455d51660c450fba6342328
setId
public void setId(String extensionID)
{    fId = extensionID;}
a0adcf1ca399073e72ad300e732fbd4e7927223234a0ddf9c0fb3ee7c9c765a2
getTargetPoint
public String getTargetPoint()
{    return fTargetPoint;}
a23cc9072e7d47a3edec93740ebcfa0b4ff55ed89bd9dd498932881677a1795c
getExtensionInstance
public Object getExtensionInstance() throws PluginRuntimeException
{        synchronized (getId()) {        try {            PluginRepository pluginRepository = PluginRepository.get(conf);            Class<?> extensionClazz = pluginRepository.getCachedClass(fDescriptor, getClazz());                                    pluginRepository.getPluginInstance(getDescriptor());            Object object = null;            try {                object = extensionClazz.getConstructor().newInstance();            } catch (IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) {                e.printStackTrace();            }            if (object != null && object instanceof Configurable) {                ((Configurable) object).setConf(this.conf);            }            return object;        } catch (ClassNotFoundException e) {            throw new PluginRuntimeException(e);        } catch (InstantiationException e) {            throw new PluginRuntimeException(e);        } catch (IllegalAccessException e) {            throw new PluginRuntimeException(e);        }    }}
80e158f089023ed6aea90c0aa2bc175aa2d83bf43b8907ff21e39f06f374031f
getDescriptor
public PluginDescriptor getDescriptor()
{    return fDescriptor;}
82f49d7a91a2e4a6bbaa6222dcdb726cbf830c8f28f61947f249aa7171466526
setDescriptor
public void setDescriptor(PluginDescriptor pDescriptor)
{    fDescriptor = pDescriptor;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return getId() + ", " + getClazz() + ", " + getTargetPoint();}
09e8f13a9a603d31d64bb498b77d15572483824d843d0e82a570643192f62186
getId
public String getId()
{    return ftId;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return fName;}
997cbe5d0f733e43c7b465673669ac93f7d881b9090e98c30c129c87f443aa13
getSchema
public String getSchema()
{    return fSchema;}
396693fd553d1d121750bc3b9e5c5782f6ba9702d7cd2c6a9e5619082edce8f4
setId
private void setId(String pId)
{    ftId = pId;}
7cef0297cc4922ddb7aaa895290b7ad0a4f1b7bced696187e11a3098ab750f2f
setName
private void setName(String pName)
{    fName = pName;}
269716ca9bcac4503be41fc443c5ba74c798e809d8009085dabdeaf3f4a00be7
setSchema
private void setSchema(String pSchema)
{    fSchema = pSchema;}
8dc8e7e56fe58a0368906b22f08f9d9b44c79bfb341b1aec7f18fc704a7f9cbe
addExtension
public void addExtension(Extension extension)
{    fExtensions.add(extension);}
7e84467bed0b81192092c8ee2fcd24444b27f5f2c029977b1dbef4b950b4e1ae
getExtensions
public Extension[] getExtensions()
{    return fExtensions.toArray(new Extension[fExtensions.size()]);}
d449fb5b3a7bef4aa1423b66ccbb1a205468f666362fa693e493df2f7eac899d
startUp
public void startUp() throws PluginRuntimeException
{}
d3246b79916b4cc62dc403ec16c3a5d9bf041c4911faad78791d4214c838d9e5
shutDown
public void shutDown() throws PluginRuntimeException
{}
80e158f089023ed6aea90c0aa2bc175aa2d83bf43b8907ff21e39f06f374031f
getDescriptor
public PluginDescriptor getDescriptor()
{    return fDescriptor;}
6a104060d0169943e386842ec6bc1e6bb6acf9e019358814d702db58cca44c9a
setDescriptor
private void setDescriptor(PluginDescriptor descriptor)
{    fDescriptor = descriptor;}
f02ec37a20530e45e47a678cf238f78284654c7b754ccb2bcaeea803d7b3de1b
finalize
protected void finalize() throws Throwable
{    super.finalize();    shutDown();}
8c956139382e7688e18e46cdd63cfc738a5f8ed8745e44ae9b0972572c2a8c31
loadClass
protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException
{        Class<?> c = findLoadedClass(name);    if (c == null) {        try {                        c = findClass(name);        } catch (ClassNotFoundException | SecurityException e) {            c = loadClassFromParent(name, resolve);        }    }    if (resolve) {        resolveClass(c);    }    return c;}
cb4ef627d99dc98e94b4296943fd5b9acd9f9e4316760bc53b97168c883985e8
loadClassFromParent
private Class<?> loadClassFromParent(String name, boolean resolve) throws ClassNotFoundException
{                Class<?> c;    try {        c = super.loadClass(name, resolve);    } catch (ClassNotFoundException e) {        c = loadClassFromSystem(name);    } catch (SecurityException e) {        c = loadClassFromSystem(name);    }    return c;}
51c3189ea64f9553e7f9114f5bce5d233822d3b37355bbf8d7c5a31c73a8242d
loadClassFromSystem
private Class<?> loadClassFromSystem(String name) throws ClassNotFoundException
{    Class<?> c = null;    if (system != null) {                c = system.loadClass(name);    }    return c;}
bcc5a2f1edfa03062c4fa5ef6036b5928969d0ee6c466f40311c231516815b7d
getResource
public URL getResource(String name)
{    URL url = findResource(name);    if (url == null)        url = super.getResource(name);    if (url == null && system != null)        url = system.getResource(name);    return url;}
22ede0261801b11d6ae3c9ef94a83073ebaa74fec5cf2193f3c85e6594c3ab9c
getResources
public Enumeration<URL> getResources(String name) throws IOException
{    /**     * Similar to super, but local resources are enumerated before parent     * resources     */    Enumeration<URL> systemUrls = null;    if (system != null) {        systemUrls = system.getResources(name);    }    Enumeration<URL> localUrls = findResources(name);    Enumeration<URL> parentUrls = null;    if (getParent() != null) {        parentUrls = getParent().getResources(name);    }    final List<URL> urls = new ArrayList<URL>();    if (localUrls != null) {        while (localUrls.hasMoreElements()) {            URL local = localUrls.nextElement();            urls.add(local);        }    }    if (systemUrls != null) {        while (systemUrls.hasMoreElements()) {            urls.add(systemUrls.nextElement());        }    }    if (parentUrls != null) {        while (parentUrls.hasMoreElements()) {            urls.add(parentUrls.nextElement());        }    }    return new Enumeration<URL>() {        Iterator<URL> iter = urls.iterator();        public boolean hasMoreElements() {            return iter.hasNext();        }        public URL nextElement() {            return iter.next();        }    };}
da08cdf75cc560a035cb95d54ab8d7f8ebf15cea6ebb6681d933f83f69d95057
hasMoreElements
public boolean hasMoreElements()
{    return iter.hasNext();}
21aab578775075ab2849f940d52fab66b06639c3a2e09c51e5772b7abe56195e
nextElement
public URL nextElement()
{    return iter.next();}
737f3472a801fef249f64d5937c0c9e44abb66f9a6ac01689fb29a90df8ab4ef
getResourceAsStream
public InputStream getResourceAsStream(String name)
{    URL url = getResource(name);    try {        return url != null ? url.openStream() : null;    } catch (IOException e) {    }    return null;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    final int PRIME = 31;    int result = 1;    result = PRIME * result + ((parent == null) ? 0 : parent.hashCode());    result = PRIME * result + Arrays.hashCode(urls);    return result;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj)        return true;    if (obj == null)        return false;    if (getClass() != obj.getClass())        return false;    final PluginClassLoader other = (PluginClassLoader) obj;    if (parent == null) {        if (other.parent != null)            return false;    } else if (!parent.equals(other.parent))        return false;    if (!Arrays.equals(urls, other.urls))        return false;    return true;}
fb1ee4b0f3a72c48610ebeca39c839e78388bce9e879b046970a3b5833082e9e
setPath
private void setPath(String pPath)
{    fPluginPath = pPath;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return fName;}
b349aaac2c6ccdd3555889672ea1785097c9b99e02b55a3c64c583df257d3f4b
setProvidername
private void setProvidername(String providerName)
{    fProviderName = providerName;}
bf109d574104378d07e4bb39426ae1df1f381da5765557e96fdb9a91d20bb146
setName
private void setName(String name)
{    fName = name;}
53edfa40fd522d077efb383559faed9a1f26801cc6b6411d187036a093b95305
setVersion
private void setVersion(String version)
{    fVersion = version;}
dbf24d38475b7b0b5637f8f9c7a038941f9769935cbbecbd435bfb71249fdb0a
getPluginClass
public String getPluginClass()
{    return fPluginClass;}
e40018fc807fa823545250d99554b82c0110af0a901e2555662130f4395a24be
getPluginId
public String getPluginId()
{    return fPluginId;}
7e84467bed0b81192092c8ee2fcd24444b27f5f2c029977b1dbef4b950b4e1ae
getExtensions
public Extension[] getExtensions()
{    return fExtensions.toArray(new Extension[fExtensions.size()]);}
f914b3e300197bb144e2ff8113a4801b1848b300b75000199c36bb3b9d925e8a
addExtension
public void addExtension(Extension pExtension)
{    fExtensions.add(pExtension);}
b583df2e21459bf4bb9e8abf10e5617fda38d63897b35da2012bc8bfc001265f
setPluginClass
private void setPluginClass(String pluginClass)
{    fPluginClass = pluginClass;}
86b2ab7a50d58ec662ffb6519cf21f4a1ffe6fa3684395f77eae0d53d75bd53b
setPluginId
private void setPluginId(String pluginId)
{    fPluginId = pluginId;}
aae121af61d3311040229f488189db77cae6fca942e768104ba4e48de1402b16
addExtensionPoint
public void addExtensionPoint(ExtensionPoint extensionPoint)
{    fExtensionPoints.add(extensionPoint);}
ef9cb2d16252f0409df52f0f4de394fad3576aedef2ef039aa2009273c14d37d
getExtenstionPoints
public ExtensionPoint[] getExtenstionPoints()
{    return fExtensionPoints.toArray(new ExtensionPoint[fExtensionPoints.size()]);}
5447ca4e61e459ba89d2e4172ef65e649389027eabba8684d377122d9066ccc3
getDependencies
public String[] getDependencies()
{    return fDependencies.toArray(new String[fDependencies.size()]);}
6e0784eb07a084db2d83972f8f786b230a65aa8b38de520d847f5be3f921bbc2
addDependency
public void addDependency(String pId)
{    fDependencies.add(pId);}
55faa79ecb4d4c8dc947baeba882dd60420615475172cbc1caf1da5180aa4e3c
addExportedLibRelative
public void addExportedLibRelative(String pLibPath) throws MalformedURLException
{    URI uri = new File(getPluginPath() + File.separator + pLibPath).toURI();    URL url = uri.toURL();    fExportedLibs.add(url);}
163057d5587d5af347c7f9c0d532f326d269e7825b4792d4ceb4f30412eddf9c
getPluginPath
public String getPluginPath()
{    return fPluginPath;}
e8ebbf74884979584923f6938b9d067b5ce5fc3f88e864a874a88c8e9e37919e
getExportedLibUrls
public URL[] getExportedLibUrls()
{    return fExportedLibs.toArray(new URL[0]);}
abd72b85ac479902fbba48fc9ba92f1e500b5fbf68217c947a7ba6942b5d0578
addNotExportedLibRelative
public void addNotExportedLibRelative(String pLibPath) throws MalformedURLException
{    URI uri = new File(getPluginPath() + File.separator + pLibPath).toURI();    URL url = uri.toURL();    fNotExportedLibs.add(url);}
9980688ee5c08ac5bc2c5a840ab191cab29138415d116df8b63f22b049ce5816
getNotExportedLibUrls
public URL[] getNotExportedLibUrls()
{    return fNotExportedLibs.toArray(new URL[fNotExportedLibs.size()]);}
7765f87470dfaf45a95fcdfe59a4adccb60639233e9bd95a3c6b5c871f874e42
getClassLoader
public PluginClassLoader getClassLoader()
{    if (fClassLoader != null)        return fClassLoader;    ArrayList<URL> arrayList = new ArrayList<>();    arrayList.addAll(fExportedLibs);    arrayList.addAll(fNotExportedLibs);    arrayList.addAll(getDependencyLibs());    File file = new File(getPluginPath());    try {        for (File file2 : file.listFiles()) {            if (file2.getAbsolutePath().endsWith("properties"))                arrayList.add(file2.getParentFile().toURI().toURL());        }    } catch (MalformedURLException e) {        LOG.debug(getPluginId() + " " + e.toString());    }    URL[] urls = arrayList.toArray(new URL[arrayList.size()]);    fClassLoader = new PluginClassLoader(urls, PluginDescriptor.class.getClassLoader());    return fClassLoader;}
2ce3abf3fe675fe6810180977dcc3843d16f3d9c628cecf1f04baaae2e3fa02c
getDependencyLibs
private ArrayList<URL> getDependencyLibs()
{    ArrayList<URL> list = new ArrayList<>();    collectLibs(list, this);    return list;}
9bdd7460e8ec92cbd37b66c9ad5c74eae57cb9adabf39e9418da028cb52ac088
collectLibs
private void collectLibs(ArrayList<URL> pLibs, PluginDescriptor pDescriptor)
{    for (String id : pDescriptor.getDependencies()) {        PluginDescriptor descriptor = PluginRepository.get(fConf).getPluginDescriptor(id);        for (URL url : descriptor.getExportedLibUrls()) {            pLibs.add(url);        }        collectLibs(pLibs, descriptor);    }}
19eb1aaa9ae93eb3cb308f6093076eb46c08245671560fb6987cf06397c8a379
getResourceString
public String getResourceString(String pKey, Locale pLocale) throws IOException
{    if (fMessages.containsKey(pLocale.toString())) {        ResourceBundle bundle = fMessages.get(pLocale.toString());        try {            return bundle.getString(pKey);        } catch (MissingResourceException e) {            return '!' + pKey + '!';        }    }    try {        ResourceBundle res = ResourceBundle.getBundle("messages", pLocale, getClassLoader());        return res.getString(pKey);    } catch (MissingResourceException x) {        return '!' + pKey + '!';    }}
da0ea2c4a813b54885cb134a03cf3257bc3040f94d6839dad0f9b08d61ffcab3
getProviderName
public String getProviderName()
{    return fProviderName;}
446b3b91c7c41085df1dc5542616b89ccd409f6a1d45e4d60d3ca00ac839ecf0
getVersion
public String getVersion()
{    return fVersion;}
85d65e53d80837a3a1aa4195d8a598f57a71d266fec29b3594b921f85f075cf0
parsePluginFolder
public Map<String, PluginDescriptor> parsePluginFolder(String[] pluginFolders)
{    Map<String, PluginDescriptor> map = new HashMap<>();    if (pluginFolders == null) {        throw new IllegalArgumentException("plugin.folders is not defined");    }    for (String name : pluginFolders) {        File directory = getPluginFolder(name);        if (directory == null) {            continue;        }        LOG.info("Plugins: looking in: " + directory.getAbsolutePath());        for (File oneSubFolder : directory.listFiles()) {            if (oneSubFolder.isDirectory()) {                String manifestPath = oneSubFolder.getAbsolutePath() + File.separator + "plugin.xml";                try {                    LOG.debug("parsing: " + manifestPath);                    PluginDescriptor p = parseManifestFile(manifestPath);                    map.put(p.getPluginId(), p);                } catch (Exception e) {                    LOG.warn("Error while loading plugin `" + manifestPath + "` " + e.toString());                }            }        }    }    return map;}
a949873e65927020c3009eb8c02e2822f8bd27f6550f9f22257f219aa8bdf771
getPluginFolder
public File getPluginFolder(String name)
{    File directory = new File(name);    if (!directory.isAbsolute()) {        URL url = PluginManifestParser.class.getClassLoader().getResource(name);        if (url == null && directory.exists() && directory.isDirectory() && directory.listFiles().length > 0) {                        return directory;        } else if (url == null) {            LOG.warn("Plugins: directory not found: " + name);            return null;        } else if (!"file".equals(url.getProtocol())) {            LOG.warn("Plugins: not a file: url. Can't load plugins from: " + url);            return null;        }        String path = url.getPath();        if (        WINDOWS && path.startsWith("/"))            path = path.substring(1);        try {                        path = URLDecoder.decode(path, "UTF-8");        } catch (UnsupportedEncodingException e) {        }        directory = new File(path);    } else if (!directory.exists()) {        LOG.warn("Plugins: directory not found: " + name);        return null;    }    return directory;}
38506cdfd381ae2e7f35b541b1adc98e50bc1cd925f79de3635bf6503ff09452
parseManifestFile
private PluginDescriptor parseManifestFile(String pManifestPath) throws MalformedURLException, SAXException, IOException, ParserConfigurationException
{    Document document = parseXML(new File(pManifestPath).toURI().toURL());    String pPath = new File(pManifestPath).getParent();    return parsePlugin(document, pPath);}
ba93ef11968ea854723d707570ffc0f1d42b3d6532bcaf74792fa74b1a85b30e
parseXML
private Document parseXML(URL url) throws SAXException, IOException, ParserConfigurationException
{    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();    DocumentBuilder builder = factory.newDocumentBuilder();    return builder.parse(url.openStream());}
5a717ca5a6f84c762346d28526639073544ed9db5c2164ba45fa1a2b96e09d3b
parsePlugin
private PluginDescriptor parsePlugin(Document pDocument, String pPath) throws MalformedURLException
{    Element rootElement = pDocument.getDocumentElement();    String id = rootElement.getAttribute(ATTR_ID);    String name = rootElement.getAttribute(ATTR_NAME);    String version = rootElement.getAttribute("version");    String providerName = rootElement.getAttribute("provider-name");    String pluginClazz = null;    if (rootElement.getAttribute(ATTR_CLASS).trim().length() > 0) {        pluginClazz = rootElement.getAttribute(ATTR_CLASS);    }    PluginDescriptor pluginDescriptor = new PluginDescriptor(id, version, name, providerName, pluginClazz, pPath, this.conf);    LOG.debug("plugin: id=" + id + " name=" + name + " version=" + version + " provider=" + providerName + "class=" + pluginClazz);    parseExtension(rootElement, pluginDescriptor);    parseExtensionPoints(rootElement, pluginDescriptor);    parseLibraries(rootElement, pluginDescriptor);    parseRequires(rootElement, pluginDescriptor);    return pluginDescriptor;}
b4f3365f999a72f32b0d0ecd0bd7c7b3e9f6e006593fe244f147a63c6900b292
parseRequires
private void parseRequires(Element pRootElement, PluginDescriptor pDescriptor) throws MalformedURLException
{    NodeList nodelist = pRootElement.getElementsByTagName("requires");    if (nodelist.getLength() > 0) {        Element requires = (Element) nodelist.item(0);        NodeList imports = requires.getElementsByTagName("import");        for (int i = 0; i < imports.getLength(); i++) {            Element anImport = (Element) imports.item(i);            String plugin = anImport.getAttribute("plugin");            if (plugin != null) {                pDescriptor.addDependency(plugin);            }        }    }}
c7034f9ef7df28ad403c44dd1d5d026b1f63312e34ce93c38b57fda5e84db07b
parseLibraries
private void parseLibraries(Element pRootElement, PluginDescriptor pDescriptor) throws MalformedURLException
{    NodeList nodelist = pRootElement.getElementsByTagName("runtime");    if (nodelist.getLength() > 0) {        Element runtime = (Element) nodelist.item(0);        NodeList libraries = runtime.getElementsByTagName("library");        for (int i = 0; i < libraries.getLength(); i++) {            Element library = (Element) libraries.item(i);            String libName = library.getAttribute(ATTR_NAME);            NodeList list = library.getElementsByTagName("export");            Element exportElement = (Element) list.item(0);            if (exportElement != null)                pDescriptor.addExportedLibRelative(libName);            else                pDescriptor.addNotExportedLibRelative(libName);        }    }}
af2ee047f138b36448582f65ccbbf2cf6b7b4bf7d7ab0f790c336907a79b9535
parseExtensionPoints
private void parseExtensionPoints(Element pRootElement, PluginDescriptor pPluginDescriptor)
{    NodeList list = pRootElement.getElementsByTagName("extension-point");    if (list != null) {        for (int i = 0; i < list.getLength(); i++) {            Element oneExtensionPoint = (Element) list.item(i);            String id = oneExtensionPoint.getAttribute(ATTR_ID);            String name = oneExtensionPoint.getAttribute(ATTR_NAME);            String schema = oneExtensionPoint.getAttribute("schema");            ExtensionPoint extensionPoint = new ExtensionPoint(id, name, schema);            pPluginDescriptor.addExtensionPoint(extensionPoint);        }    }}
dd8572f615d2a8fe6145c3b37c98f022ebc1f71b41d42a051b1b556d17e07005
parseExtension
private void parseExtension(Element pRootElement, PluginDescriptor pPluginDescriptor)
{    NodeList extensions = pRootElement.getElementsByTagName("extension");    if (extensions != null) {        for (int i = 0; i < extensions.getLength(); i++) {            Element oneExtension = (Element) extensions.item(i);            String pointId = oneExtension.getAttribute("point");            NodeList extensionImplementations = oneExtension.getChildNodes();            if (extensionImplementations != null) {                for (int j = 0; j < extensionImplementations.getLength(); j++) {                    Node node = extensionImplementations.item(j);                    if (!node.getNodeName().equals("implementation")) {                        continue;                    }                    Element oneImplementation = (Element) node;                    String id = oneImplementation.getAttribute(ATTR_ID);                    String extensionClass = oneImplementation.getAttribute(ATTR_CLASS);                    LOG.debug("impl: point=" + pointId + " class=" + extensionClass);                    Extension extension = new Extension(pPluginDescriptor, pointId, id, extensionClass, this.conf, this.pluginRepository);                    NodeList parameters = oneImplementation.getElementsByTagName("parameter");                    if (parameters != null) {                        for (int k = 0; k < parameters.getLength(); k++) {                            Element param = (Element) parameters.item(k);                            extension.addAttribute(param.getAttribute(ATTR_NAME), param.getAttribute("value"));                        }                    }                    pPluginDescriptor.addExtension(extension);                }            }        }    }}
07b9fa178d520666574f4d401947773a245c2ee1b6857065ef47a5afb294632f
get
public static synchronized PluginRepository get(Configuration conf)
{    String uuid = NutchConfiguration.getUUID(conf);    if (uuid == null) {                uuid = "nonNutchConf@" + conf.hashCode();    }    PluginRepository result = CACHE.get(uuid);    if (result == null) {        result = new PluginRepository(conf);        CACHE.put(uuid, result);    }    return result;}
ae7e707104ab2d38f7c19e385e19e338f82182d6bb6696d275fcf2701a8e640f
installExtensionPoints
private void installExtensionPoints(List<PluginDescriptor> plugins)
{    if (plugins == null) {        return;    }    for (PluginDescriptor plugin : plugins) {        for (ExtensionPoint point : plugin.getExtenstionPoints()) {            String xpId = point.getId();            LOG.debug("Adding extension point " + xpId);            fExtensionPoints.put(xpId, point);        }    }}
0caa4ac18960da44611defcaa0ac555af51f1e98eb87d677966c7d670c50b4e5
installExtensions
private void installExtensions(List<PluginDescriptor> pRegisteredPlugins) throws PluginRuntimeException
{    for (PluginDescriptor descriptor : pRegisteredPlugins) {        for (Extension extension : descriptor.getExtensions()) {            String xpId = extension.getTargetPoint();            ExtensionPoint point = getExtensionPoint(xpId);            if (point == null) {                throw new PluginRuntimeException("Plugin (" + descriptor.getPluginId() + "), " + "extension point: " + xpId + " does not exist.");            }            point.addExtension(extension);        }    }}
a96a140b4c615f16c3ab1a9a2affcf5e962410306548a07f7d897e3c5e950709
getPluginCheckedDependencies
private void getPluginCheckedDependencies(PluginDescriptor plugin, Map<String, PluginDescriptor> plugins, Map<String, PluginDescriptor> dependencies, Map<String, PluginDescriptor> branch) throws MissingDependencyException, CircularDependencyException
{    if (dependencies == null) {        dependencies = new HashMap<>();    }    if (branch == null) {        branch = new HashMap<>();    }    branch.put(plugin.getPluginId(), plugin);        for (String id : plugin.getDependencies()) {        PluginDescriptor dependency = plugins.get(id);        if (dependency == null) {            throw new MissingDependencyException("Missing dependency " + id + " for plugin " + plugin.getPluginId());        }        if (branch.containsKey(id)) {            throw new CircularDependencyException("Circular dependency detected " + id + " for plugin " + plugin.getPluginId());        }        dependencies.put(id, dependency);        getPluginCheckedDependencies(plugins.get(id), plugins, dependencies, branch);    }    branch.remove(plugin.getPluginId());}
e8c402f9e9b3c0b5eb7267970e23dc792d8f272ae10fed181353b61547d6849f
getPluginCheckedDependencies
private Map<String, PluginDescriptor> getPluginCheckedDependencies(PluginDescriptor plugin, Map<String, PluginDescriptor> plugins) throws MissingDependencyException, CircularDependencyException
{    Map<String, PluginDescriptor> dependencies = new HashMap<>();    Map<String, PluginDescriptor> branch = new HashMap<>();    getPluginCheckedDependencies(plugin, plugins, dependencies, branch);    return dependencies;}
bd962bf1971cb836498e3204a38efba2572ab32f7016bd363c6d2c4faee2b232
getDependencyCheckedPlugins
private List<PluginDescriptor> getDependencyCheckedPlugins(Map<String, PluginDescriptor> filtered, Map<String, PluginDescriptor> all)
{    if (filtered == null) {        return null;    }    Map<String, PluginDescriptor> checked = new HashMap<>();    for (PluginDescriptor plugin : filtered.values()) {        try {            checked.putAll(getPluginCheckedDependencies(plugin, all));            checked.put(plugin.getPluginId(), plugin);        } catch (MissingDependencyException mde) {                        LOG.warn(mde.getMessage());        } catch (CircularDependencyException cde) {                        LOG.warn(cde.getMessage());        }    }    return new ArrayList<>(checked.values());}
8b22f5a469bbba6d27dc211406459b68b5eb1a3d5431bc0e79120f5c1a40b262
getPluginDescriptors
public PluginDescriptor[] getPluginDescriptors()
{    return fRegisteredPlugins.toArray(new PluginDescriptor[fRegisteredPlugins.size()]);}
7329938c1b2790c2b1cd76b789dc62b78bf23f31d9408c62e6051ae6b941f69e
getPluginDescriptor
public PluginDescriptor getPluginDescriptor(String pPluginId)
{    for (PluginDescriptor descriptor : fRegisteredPlugins) {        if (descriptor.getPluginId().equals(pPluginId))            return descriptor;    }    return null;}
be522ac8da54a6702f1d73e6035d9d0a1e51e00e87446dce59d3e18192394d5c
getExtensionPoint
public ExtensionPoint getExtensionPoint(String pXpId)
{    return this.fExtensionPoints.get(pXpId);}
e0e8fadf5d4bd3b6d914d1f3bf833213d6817b011796811403fdf87fd6db49b9
getPluginInstance
public Plugin getPluginInstance(PluginDescriptor pDescriptor) throws PluginRuntimeException
{    if (fActivatedPlugins.containsKey(pDescriptor.getPluginId()))        return fActivatedPlugins.get(pDescriptor.getPluginId());    try {                synchronized (pDescriptor) {            Class<?> pluginClass = getCachedClass(pDescriptor, pDescriptor.getPluginClass());            Constructor<?> constructor = pluginClass.getConstructor(new Class<?>[] { PluginDescriptor.class, Configuration.class });            Plugin plugin = (Plugin) constructor.newInstance(new Object[] { pDescriptor, this.conf });            plugin.startUp();            fActivatedPlugins.put(pDescriptor.getPluginId(), plugin);            return plugin;        }    } catch (ClassNotFoundException e) {        throw new PluginRuntimeException(e);    } catch (InstantiationException e) {        throw new PluginRuntimeException(e);    } catch (IllegalAccessException e) {        throw new PluginRuntimeException(e);    } catch (NoSuchMethodException e) {        throw new PluginRuntimeException(e);    } catch (InvocationTargetException e) {        throw new PluginRuntimeException(e);    }}
c877676255afe4b155764b97f6c38224ed558f15f9c31794935cadea3069a1bc
finalize
public void finalize() throws Throwable
{    shutDownActivatedPlugins();}
0d2d23e3fbb5650a52eb56c7dedc1355cc5e0113db72a51a9da011d6459f1eb7
shutDownActivatedPlugins
private void shutDownActivatedPlugins() throws PluginRuntimeException
{    for (Plugin plugin : fActivatedPlugins.values()) {        plugin.shutDown();    }}
ffd7b952e08ac195a23bb15dfde9d88123c28b0a766d1fbbde8bd33fac0e7843
getCachedClass
public Class getCachedClass(PluginDescriptor pDescriptor, String className) throws ClassNotFoundException
{    Map<PluginClassLoader, Class> descMap = CLASS_CACHE.get(className);    if (descMap == null) {        descMap = new HashMap<>();        CLASS_CACHE.put(className, descMap);    }    PluginClassLoader loader = pDescriptor.getClassLoader();    Class clazz = descMap.get(loader);    if (clazz == null) {        clazz = loader.loadClass(className);        descMap.put(loader, clazz);    }    return clazz;}
a8e36d5d5fba79362c97dcb9413e594a7906a3ba49f4355978eb2005ca0c0a36
displayStatus
private void displayStatus()
{    LOG.info("Plugin Auto-activation mode: [" + this.auto + "]");    LOG.info("Registered Plugins:");    if ((fRegisteredPlugins == null) || (fRegisteredPlugins.size() == 0)) {        LOG.info("\tNONE");    } else {        for (PluginDescriptor plugin : fRegisteredPlugins) {            LOG.info("\t" + plugin.getName() + " (" + plugin.getPluginId() + ")");        }    }    LOG.info("Registered Extension-Points:");    if ((fExtensionPoints == null) || (fExtensionPoints.size() == 0)) {        LOG.info("\tNONE");    } else {        for (ExtensionPoint ep : fExtensionPoints.values()) {            LOG.info("\t" + ep.getName() + " (" + ep.getId() + ")");        }    }}
42091bb92acfb1c29c6325e8e272c0b828758dbe7d0da558041b4968a8e85862
filter
private Map<String, PluginDescriptor> filter(Pattern excludes, Pattern includes, Map<String, PluginDescriptor> plugins)
{    Map<String, PluginDescriptor> map = new HashMap<>();    if (plugins == null) {        return map;    }    for (PluginDescriptor plugin : plugins.values()) {        if (plugin == null) {            continue;        }        String id = plugin.getPluginId();        if (id == null) {            continue;        }        if (!includes.matcher(id).matches()) {            LOG.debug("not including: " + id);            continue;        }        if (excludes.matcher(id).matches()) {            LOG.debug("excluding: " + id);            continue;        }        map.put(plugin.getPluginId(), plugin);    }    return map;}
5bcb9620219d9a8b5a1f63a3514ed3dbaba012e9e6d64bbfa17c35bdc69ce5ac
getOrderedPlugins
public synchronized Object[] getOrderedPlugins(Class<?> clazz, String xPointId, String orderProperty)
{    Object[] filters;    ObjectCache objectCache = ObjectCache.get(conf);    filters = (Object[]) objectCache.getObject(clazz.getName());    if (filters == null) {        String order = conf.get(orderProperty);        List<String> orderOfFilters = new ArrayList<>();        boolean userDefinedOrder = false;        if (order != null && !order.trim().isEmpty()) {            orderOfFilters = Arrays.asList(order.trim().split("\\s+"));            userDefinedOrder = true;        }        try {            ExtensionPoint point = PluginRepository.get(conf).getExtensionPoint(xPointId);            if (point == null)                throw new RuntimeException(xPointId + " not found.");            Extension[] extensions = point.getExtensions();            HashMap<String, Object> filterMap = new HashMap<>();            for (int i = 0; i < extensions.length; i++) {                Extension extension = extensions[i];                Object filter = extension.getExtensionInstance();                if (!filterMap.containsKey(filter.getClass().getName())) {                    filterMap.put(filter.getClass().getName(), filter);                    if (!userDefinedOrder)                        orderOfFilters.add(filter.getClass().getName());                }            }            List<Object> sorted = new ArrayList<>();            for (String orderedFilter : orderOfFilters) {                Object f = filterMap.get(orderedFilter);                if (f == null) {                    LOG.error(clazz.getSimpleName() + " : " + orderedFilter + " declared in configuration property " + orderProperty + " but not found in an active plugin - ignoring.");                    continue;                }                sorted.add(f);            }            Object[] filter = (Object[]) Array.newInstance(clazz, sorted.size());            for (int i = 0; i < sorted.size(); i++) {                filter[i] = sorted.get(i);                if (LOG.isTraceEnabled()) {                    LOG.trace(clazz.getSimpleName() + " : filters[" + i + "] = " + filter[i].getClass());                }            }            objectCache.setObject(clazz.getName(), filter);        } catch (PluginRuntimeException e) {            throw new RuntimeException(e);        }        filters = (Object[]) objectCache.getObject(clazz.getName());    }    return filters;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    if (args.length < 2) {        System.err.println("Usage: PluginRepository pluginId className [arg1 arg2 ...]");        return;    }    Configuration conf = NutchConfiguration.create();    PluginRepository repo = new PluginRepository(conf);        PluginDescriptor d = repo.getPluginDescriptor(args[0]);    if (d == null) {        System.err.println("Plugin '" + args[0] + "' not present or inactive.");        return;    }    ClassLoader cl = d.getClassLoader();        Class<?> clazz = null;    try {        clazz = Class.forName(args[1], true, cl);    } catch (Exception e) {        System.err.println("Could not load the class '" + args[1] + ": " + e.getMessage());        return;    }    Method m = null;    try {        m = clazz.getMethod("main", new Class<?>[] { args.getClass() });    } catch (Exception e) {        System.err.println("Could not find the 'main(String[])' method in class " + args[1] + ": " + e.getMessage());        return;    }    String[] subargs = new String[args.length - 2];    System.arraycopy(args, 2, subargs, 0, subargs.length);    m.invoke(null, new Object[] { subargs });}
86ff8440734953be3a0283749f438d0e1438e3ad802efec0cd0f875db5e686cb
readFieldsCompressed
private final void readFieldsCompressed(DataInput in) throws IOException
{    byte oldVersion = in.readByte();    switch(oldVersion) {        case 0:        case 1:                        url = Text.readString(in);                        base = Text.readString(in);                        content = new byte[in.readInt()];            in.readFully(content);                        contentType = Text.readString(in);                        int keySize = in.readInt();            String key;            for (int i = 0; i < keySize; i++) {                key = Text.readString(in);                int valueSize = in.readInt();                for (int j = 0; j < valueSize; j++) {                    metadata.add(key, Text.readString(in));                }            }            break;        case 2:                        url = Text.readString(in);                        base = Text.readString(in);                        content = new byte[in.readInt()];            in.readFully(content);                        contentType = Text.readString(in);                        metadata.readFields(in);            break;        default:            throw new VersionMismatchException((byte) 2, oldVersion);    }}
7add649f77ab882651a0aefca1bcc5bc5472da2482e6f0b33a883360f704f801
readFields
public final void readFields(DataInput in) throws IOException
{    metadata.clear();    int sizeOrVersion = in.readInt();    if (sizeOrVersion < 0) {                version = sizeOrVersion;        switch(version) {            case VERSION:                url = Text.readString(in);                base = Text.readString(in);                content = new byte[in.readInt()];                in.readFully(content);                contentType = Text.readString(in);                metadata.readFields(in);                break;            default:                throw new VersionMismatchException((byte) VERSION, (byte) version);        }    } else {                byte[] compressed = new byte[sizeOrVersion];        in.readFully(compressed, 0, compressed.length);        ByteArrayInputStream deflated = new ByteArrayInputStream(compressed);        DataInput inflater = new DataInputStream(new InflaterInputStream(deflated));        readFieldsCompressed(inflater);    }}
6ce8f423999e48ee8ccc8ead0930648784c8032b66979cb68c99c4f899ae9ef8
write
public final void write(DataOutput out) throws IOException
{    out.writeInt(VERSION);        Text.writeString(out, url);        Text.writeString(out, base);        out.writeInt(content.length);    out.write(content);        Text.writeString(out, contentType);        metadata.write(out);}
2c3d4fe92b6ee321c5da9b816fbc1e965f6bb3919b4713e7d367fc031237d25d
read
public static Content read(DataInput in) throws IOException
{    Content content = new Content();    content.readFields(in);    return content;}
354afe66bbdb19ee4d620955bbb214ebf9b5aa09359dea30ffb867002b5a25bd
getUrl
public String getUrl()
{    return url;}
99b10929791089fcc9511ac3b3a500f4ef333755c13315abd48363194bfa2e8c
getBaseUrl
public String getBaseUrl()
{    return base;}
a724d7d22eec9af58dc1baab31eb2f9394c370706fcded02b6d254fcd56fd2b9
getContent
public byte[] getContent()
{    return content;}
68fc55e2d339c2cf2ddd2db9bc85c4c827d67095e86ed9e0b4f753656223257c
setContent
public void setContent(byte[] content)
{    this.content = content;}
baea39c86756a5efaaec8e2f01175d687e0a60e86379d9b91d98a3d4089abf86
getContentType
public String getContentType()
{    return contentType;}
0fb322b51843eb1ce41d862b5784d90ff09322b3bdedfe11d4da435b1d369b7c
setContentType
public void setContentType(String contentType)
{    this.contentType = contentType;}
3278491613baf75b185ed9d8d57b8e0f596c9babb670aa112cc72d53896855cf
getMetadata
public Metadata getMetadata()
{    return metadata;}
3d75b4f93fffacb6e9ca645720d4a174e7b1772706baab104d664fe61f0c9f7f
setMetadata
public void setMetadata(Metadata metadata)
{    this.metadata = metadata;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof Content)) {        return false;    }    Content that = (Content) o;    return this.url.equals(that.url) && this.base.equals(that.base) && Arrays.equals(this.getContent(), that.getContent()) && this.contentType.equals(that.contentType) && this.metadata.equals(that.metadata);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuffer buffer = new StringBuffer();    buffer.append("Version: " + version + "\n");    buffer.append("url: " + url + "\n");    buffer.append("base: " + base + "\n");    buffer.append("contentType: " + contentType + "\n");    buffer.append("metadata: " + metadata + "\n");    buffer.append("Content:\n");        buffer.append(new String(content));    return buffer.toString();}
6538d76a086933ae50b4ee6e131d43b17cf0047fe2ae644bcffc294ff69a38d9
main
public static void main(String[] argv) throws Exception
{    String usage = "Content (-local | -dfs <namenode:port>) recno segment";    if (argv.length < 3) {        System.out.println("usage:" + usage);        return;    }    Options opts = new Options();    Configuration conf = NutchConfiguration.create();    GenericOptionsParser parser = new GenericOptionsParser(conf, opts, argv);    String[] remainingArgs = parser.getRemainingArgs();    try (FileSystem fs = FileSystem.get(conf)) {        int recno = Integer.parseInt(remainingArgs[0]);        String segment = remainingArgs[1];        Path file = new Path(segment, DIR_NAME);        System.out.println("Reading from file: " + file);        ArrayFile.Reader contents = new ArrayFile.Reader(fs, file.toString(), conf);        Content content = new Content();        contents.get(recno, content);        System.out.println("Retrieved " + recno + " from file " + file);        System.out.println(content);        contents.close();    }}
3d884bbea030aea227fd90b89f3a6ba60688785767966b4b5815a6232f2ba50d
getContentType
private String getContentType(String typeName, String url, byte[] data)
{    return this.mimeTypes.autoResolveContentType(typeName, url, data);}
75c401209bce1e327f94e26a7ee532456d3a5e9e75775595afd2482c66ae3f0a
getProtocol
public Protocol getProtocol(String urlString) throws ProtocolNotFound
{    try {        URL url = new URL(urlString);        return getProtocol(url);    } catch (MalformedURLException e) {        throw new ProtocolNotFound(urlString, e.toString());    }}
47de76f8ec6f52a43f52b8181752aad8fd42f1577c1a9a35ad32480b9d555668
getProtocol
public Protocol getProtocol(URL url) throws ProtocolNotFound
{    try {        Protocol protocol = null;                String host = url.getHost();        if (hostProtocolMapping.containsKey(host)) {            Extension extension = getExtensionById(hostProtocolMapping.get(host));            if (extension != null) {                protocol = getProtocolInstanceByExtension(extension);            }        }                if (protocol == null) {                        if (defaultProtocolImplMapping.containsKey(url.getProtocol())) {                Extension extension = getExtensionById(defaultProtocolImplMapping.get(url.getProtocol()));                if (extension != null) {                    protocol = getProtocolInstanceByExtension(extension);                }            }        }                if (protocol == null) {            Extension extension = findExtension(url.getProtocol(), "protocolName");            if (extension != null) {                protocol = getProtocolInstanceByExtension(extension);            }        }                if (protocol != null) {            return protocol;        }                throw new ProtocolNotFound(url.toString());    } catch (PluginRuntimeException e) {        throw new ProtocolNotFound(url.toString(), e.toString());    }}
563689db6c12dbcbf0e4f73f2e56f8c36b5705297c0729c3941bf9f172caa55a
getProtocolInstanceByExtension
private Protocol getProtocolInstanceByExtension(Extension extension) throws PluginRuntimeException
{    Protocol protocol = null;    String cacheId = extension.getId();    ObjectCache objectCache = ObjectCache.get(conf);    synchronized (objectCache) {        if (!objectCache.hasObject(cacheId)) {            protocol = (Protocol) extension.getExtensionInstance();            objectCache.setObject(cacheId, protocol);        }        protocol = (Protocol) objectCache.getObject(cacheId);    }    return protocol;}
a460420557948599ac75ec0bded27a90b23127a7eef3b10cda673fd3a50f5c52
getExtensionById
private Extension getExtensionById(String id)
{    Extension[] extensions = this.extensionPoint.getExtensions();    for (int i = 0; i < extensions.length; i++) {        if (id.equals(extensions[i].getId())) {            return extensions[i];        }    }    return null;}
2a9c51d7a6d4de58a471ad862ab13b1cc488b5e54e651f8296d4f1cfa26784b4
findExtension
private Extension findExtension(String name, String attribute) throws PluginRuntimeException
{    for (int i = 0; i < this.extensionPoint.getExtensions().length; i++) {        Extension extension = this.extensionPoint.getExtensions()[i];        if (contains(name, extension.getAttribute(attribute)))            return extension;    }    return null;}
16f8d16f7048f29878e4ef18ad6b68cffa489df440941841f3ccd18e2cf96eb0
contains
 boolean contains(String what, String where)
{    if (where != null) {        String[] parts = where.split("[, ]");        for (int i = 0; i < parts.length; i++) {            if (parts[i].equals(what))                return true;        }    }    return false;}
bf58a24bff579aea91fb0c0ddd129692ebf475914f22d59eed98c7226f6ae467
getProtocolById
public Protocol getProtocolById(String id) throws PluginRuntimeException
{    Extension ext = getExtensionById(id);    if (ext == null) {        throw new PluginRuntimeException("ID " + id + " not found");    }    return getProtocolInstanceByExtension(ext);}
354afe66bbdb19ee4d620955bbb214ebf9b5aa09359dea30ffb867002b5a25bd
getUrl
public String getUrl()
{    return url;}
d259121852aac982589235875ff98496f66b06874df4752538f4789f0121d301
getContent
public Content getContent()
{    return content;}
81ee9d5516e210a3c59ad37933bc367c8e534b5350edcd22f011abc318eb69c3
setContent
public void setContent(Content content)
{    this.content = content;}
ac8bf96722cb351c50a935963c28fbec68ab08aa5e115a6a9dcbbe4bddc7ce26
getStatus
public ProtocolStatus getStatus()
{    return status;}
7d374bc3bd5fa6efdb06424febaf6b4026a6c7525d573cc1541884ecb1b2e645
setStatus
public void setStatus(ProtocolStatus status)
{    this.status = status;}
55afb0a6be13d174fe49811673c4273b471f2cecd01f12a8b0807dd39ff0b28d
read
public static ProtocolStatus read(DataInput in) throws IOException
{    ProtocolStatus res = new ProtocolStatus();    res.readFields(in);    return res;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    byte version = in.readByte();    switch(version) {        case 1:            code = in.readByte();            lastModified = in.readLong();            args = WritableUtils.readCompressedStringArray(in);            break;        case VERSION:            code = in.readByte();            lastModified = in.readLong();            args = WritableUtils.readStringArray(in);            break;        default:            throw new VersionMismatchException(VERSION, version);    }}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeByte(VERSION);    out.writeByte((byte) code);    out.writeLong(lastModified);    if (args == null) {        out.writeInt(-1);    } else {        WritableUtils.writeStringArray(out, args);    }}
0a0b1b63acd4735986d567c825abbda7a5cce7fff7021cbd22b60b2b93d27dce
setArgs
public void setArgs(String[] args)
{    this.args = args;}
63c9fbbfc8fd0c446fa0184a5eed4111e14f05b4735608439c43552757f7ae4c
getArgs
public String[] getArgs()
{    return args;}
871172d34cf47bd1ccc8d8f81877fbf834289fcf345350e529b8b4e7a6708c5d
getCode
public int getCode()
{    return code;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return codeToName.get(this.code);}
52c71cd098f5267549bfeb4d4d11128cd144a16616c12f5bac0f7df096e76b64
setCode
public void setCode(int code)
{    this.code = code;}
612931c72bde28f1dce5cd75713a8d061fc0015a7653f03c77fdbe463c352c87
isSuccess
public boolean isSuccess()
{    return code == SUCCESS;}
c699202d30ed772169e3510c58ed2b9f64f43ee56c100c9a980ed81199f14502
isTransientFailure
public boolean isTransientFailure()
{    return code == ACCESS_DENIED || code == EXCEPTION || code == REDIR_EXCEEDED || code == RETRY || code == TEMP_MOVED || code == WOULDBLOCK || code == PROTO_NOT_FOUND;}
60c310dc34eec6114f3fb1b3cc827494d4ed53e41901b369ecc3c32491efc730
isPermanentFailure
public boolean isPermanentFailure()
{    return code == FAILED || code == GONE || code == MOVED || code == NOTFOUND || code == ROBOTS_DENIED;}
235028ea8ddb2341c1042a1108f87e7ae256c2220fdd3fdcc5c1d74c2e32dbcf
isRedirect
public boolean isRedirect()
{    return code == MOVED || code == TEMP_MOVED;}
b46153cc21231cb60e014b6b3c49b437699575e4012681cb08026e5238c66751
getMessage
public String getMessage()
{    if (args != null && args.length > 0)        return args[0];    return null;}
96b2dc73882e9b3439c628f61bcafaaf041e75207cedefacb077f08f36772e92
setMessage
public void setMessage(String msg)
{    if (args != null && args.length > 0)        args[0] = msg;    else        args = new String[] { msg };}
2ec784375f5f3608678998e41354a271f8bfe208c827c31b5e5d990a02005727
getLastModified
public long getLastModified()
{    return lastModified;}
f816b33355a5adb182dc62c0dcd6518cb195fd9607db9a4b27810a5d1e22a347
setLastModified
public void setLastModified(long lastModified)
{    this.lastModified = lastModified;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (o == null)        return false;    if (!(o instanceof ProtocolStatus))        return false;    ProtocolStatus other = (ProtocolStatus) o;    if (this.code != other.code || this.lastModified != other.lastModified)        return false;    if (this.args == null) {        if (other.args == null)            return true;        else            return false;    } else {        if (other.args == null)            return false;        if (other.args.length != this.args.length)            return false;        for (int i = 0; i < this.args.length; i++) {            if (!this.args[i].equals(other.args[i]))                return false;        }    }    return true;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuffer res = new StringBuffer();    res.append(codeToName.get(Integer.valueOf(code)) + "(" + code + "), lastModified=" + lastModified);    if (args != null) {        if (args.length == 1) {            res.append(": " + String.valueOf(args[0]));        } else {            for (int i = 0; i < args.length; i++) {                if (args[i] != null)                    res.append(", args[" + i + "]=" + String.valueOf(args[i]));            }        }    }    return res.toString();}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;        String agentName = conf.get("http.agent.name");    if (agentName == null || (agentName = agentName.trim()).isEmpty()) {        throw new RuntimeException("Agent name not configured!");    }    agentNames = agentName;            String otherAgents = conf.get("http.robots.agents");    if (otherAgents != null && !otherAgents.trim().isEmpty()) {        StringTokenizer tok = new StringTokenizer(otherAgents, ",");        StringBuilder sb = new StringBuilder(agentNames);        while (tok.hasMoreTokens()) {            String str = tok.nextToken().trim();            if (str.equals("*") || str.equals(agentName)) {                                                } else {                sb.append(",").append(str);            }        }        agentNames = sb.toString();    }    String[] confWhiteList = conf.getStrings("http.robot.rules.whitelist");    if (confWhiteList == null) {        LOG.info("robots.txt whitelist not configured.");    } else {        for (int i = 0; i < confWhiteList.length; i++) {            if (confWhiteList[i].isEmpty()) {                LOG.info("Empty whitelisted URL skipped!");                continue;            }            whiteList.add(confWhiteList[i]);        }        if (whiteList.size() > 0) {            matcher = new SuffixStringMatcher(whiteList);            LOG.info("Whitelisted hosts: " + whiteList);        }    }}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
4d3b443a6b2e2ecc31aa84a1c9eff1ed0169ec38675c83ac85bbb37b41806b74
isWhiteListed
public boolean isWhiteListed(URL url)
{    boolean match = false;    String urlString = url.getHost();    if (matcher != null) {        match = matcher.matches(urlString);    }    return match;}
aad04a6ce6c7edebcf1698a46c77ca0018dd62eb4186e3060acf934678dcbd2d
parseRules
public BaseRobotRules parseRules(String url, byte[] content, String contentType, String robotName)
{    return robotParser.parseContent(url, content, contentType, robotName);}
5fc701f07c0b958d7d09a4bca41a8c5805243e89465469287b7170e5404facbe
getRobotRulesSet
public BaseRobotRules getRobotRulesSet(Protocol protocol, Text url, List<Content> robotsTxtContent)
{    URL u = null;    try {        u = new URL(url.toString());    } catch (Exception e) {        return EMPTY_RULES;    }    return getRobotRulesSet(protocol, u, robotsTxtContent);}
6626d4c6677d79f6a354e804d198c3610a8dcc28cf6c3c96d1038f9e3e67fb6c
run
public int run(String[] args)
{    if (args.length < 2) {        String[] help = { "Usage: RobotRulesParser [ -Dproperty=... ] <robots-file-or-url> <url-file> [<agent-names>]", "", "<robots-file-or-url>\tlocal file or URL parsed as robots.txt file", "\tIf <robots-file-or-url> starts with a protocol specification", "\t(`http', `https', `ftp' or `file'), robots.txt it is fetched", "\tusing the specified protocol. Otherwise, a local file is assumed.", "", "<url-file>\tlocal file with URLs (one per line), for every URL", "\tthe path part (including the query) is checked whether", "\tit is allowed by the robots.txt rules.  Other parts of the URLs", "\t(mainly the host) are ignored.", "", "<agent-names>\tcomma-separated list of agent names", "\tused to select rules from the robots.txt file.", "\tIf no agent name is given the property http.agent.name is used.", "\tIf http.agent.name is empty, robots.txt is checked for rules", "\tassigned to the user agent `*' (meaning any other).", "", "Important properties:", " -D fetcher.store.robotstxt=true", "\toutput content and HTTP meta data of fetched robots.txt (if not a local file)", " -D http.agent.name=...\tsame as argument <agent-names>", " -D http.robots.agents=...\tadditional agent names", " -D http.robot.rules.whitelist=..." };        for (String s : help) {            System.err.println(s);        }        return -1;    }    Protocol protocol = null;    URL robotsTxtUrl = null;    if (args[0].matches("^(?:https?|ftp|file)://?.*")) {        try {            robotsTxtUrl = new URL(args[0]);        } catch (MalformedURLException e) {            LOG.warn("Not a valid URL, assuming local file: {}", args[0]);        }        ProtocolFactory factory = new ProtocolFactory(conf);        try {            protocol = factory.getProtocol(robotsTxtUrl);        } catch (ProtocolNotFound e) {            LOG.error("No protocol found for {}: {}", args[0], StringUtils.stringifyException(e));            return -1;        }    }    if (robotsTxtUrl == null) {                File robotsFile = new File(args[0]);        if (!robotsFile.exists()) {            LOG.error("File does not exist: {}", args[0]);            return -1;        } else {            try {                robotsTxtUrl = robotsFile.toURI().toURL();            } catch (MalformedURLException e) {            }        }    }    File urlFile = new File(args[1]);    if (args.length > 2) {                String agents = args[2];        conf.set("http.agent.name", agents);        setConf(conf);    }    List<Content> robotsTxtContent = null;    if (getConf().getBoolean("fetcher.store.robotstxt", false)) {        robotsTxtContent = new LinkedList<>();    }    try {        BaseRobotRules rules = getRobotRulesSet(protocol, robotsTxtUrl, robotsTxtContent);        if (robotsTxtContent != null) {            for (Content robotsTxt : robotsTxtContent) {                LOG.info("fetched robots.txt {}:", robotsTxt.getUrl());                LOG.info(robotsTxt.toString());            }        }        System.out.println("Testing robots.txt for agent names: " + agentNames);        LineNumberReader testsIn = new LineNumberReader(new FileReader(urlFile));        String testPath;        testPath = testsIn.readLine();        while (testPath != null) {            testPath = testPath.trim();            try {                                URL url = new URL(testPath);                String status;                if (isWhiteListed(url)) {                    status = "whitelisted";                } else if (rules.isAllowed(testPath)) {                    status = "allowed";                } else {                    status = "not allowed";                }                System.out.println(status + ":\t" + testPath);            } catch (MalformedURLException e) {                LOG.warn("Not a valid URL: {}", testPath);            }            testPath = testsIn.readLine();        }        testsIn.close();    } catch (IOException e) {        LOG.error("Failed to run: " + StringUtils.stringifyException(e));        return -1;    }    return 0;}
864c0169c928fedbd7b44b5b99a297e2c361400a046a2a8f02c4ca557c2e7acf
getRobotRulesSet
public BaseRobotRules getRobotRulesSet(Protocol protocol, URL url, List<Content> robotsTxtContent)
{    BaseRobotRules rules;    if (protocol != null) {        rules = protocol.getRobotRules(new Text(url.toString()), null, robotsTxtContent);    } else {        try {            int contentLength = url.openConnection().getContentLength();            byte[] robotsBytes = new byte[contentLength];            InputStream openStream = url.openStream();            openStream.read(robotsBytes);            openStream.close();            rules = robotParser.parseContent(url.toString(), robotsBytes, "text/plain", this.conf.get("http.agent.name"));        } catch (IOException e) {            LOG.error("Failed to open robots.txt file " + url + StringUtils.stringifyException(e));            rules = EMPTY_RULES;        }    }    return rules;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    Configuration conf = NutchConfiguration.create();    int res = ToolRunner.run(conf, new TestRobotRulesParser(conf), args);    System.exit(res);}
d881f05a8776e4de41efb99b77602c86852470eb1ef56eea5d14db34ce16fd97
setConfig
public boolean setConfig(Configuration conf)
{    boolean success = false;    try {        for (int i = 0; i < this.publishers.length; i++) {            success |= this.publishers[i].setConfig(conf);            if (success)                LOG.info("Successfully loaded {} publisher", this.publishers[i].getClass().getName());        }    } catch (Exception e) {        LOG.warn("Error while loading publishers : {}", e.getMessage());    }    if (!success) {        LOG.warn("Could not load any publishers out of {} publishers", this.publishers.length);    }    return success;}
115d539bd26423957d10ec55be21a6cbbc0ef2c60ccddad15c781f7b0ccd0cc0
publish
public void publish(Object event, Configuration conf)
{    for (int i = 0; i < this.publishers.length; i++) {        try {            this.publishers[i].publish(event, conf);        } catch (Exception e) {            LOG.warn("Could not post event to {}", this.publishers[i].getClass().getName());        }    }}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
3289d9012415678ad1c3e3443add269fd37c2ec2f5df3aa1733dc466c75edc2d
setConf
public void setConf(Configuration arg0)
{}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
0b6feb77383ae8d81d2c30e18bf6315732aeabecd96f00250a9915d31f7fbc88
injectedScore
public void injectedScore(Text url, CrawlDatum datum) throws ScoringFilterException
{}
2dcbf82c99c2e2b740c6a208c3e1e729c537864ed30748e09cdb44bbfad01075
initialScore
public void initialScore(Text url, CrawlDatum datum) throws ScoringFilterException
{}
c7d75ff32784416ea95ea0863f39cb7d0da44832579d23df72069418eb890bf5
generatorSortValue
public float generatorSortValue(Text url, CrawlDatum datum, float initSort) throws ScoringFilterException
{    return initSort;}
53571795b495728e7ad1dc9749d44ee6378e3f595ad89330bb07ce03d5f44873
passScoreBeforeParsing
public void passScoreBeforeParsing(Text url, CrawlDatum datum, Content content) throws ScoringFilterException
{}
b9e96bf8d75863926c418ca10c8e728ef083a9a13368adf5af855a1fa573c6c7
passScoreAfterParsing
public void passScoreAfterParsing(Text url, Content content, Parse parse) throws ScoringFilterException
{}
89fdd7122298e467ee01a9f463b423fa9405ab98df3d1247ebce0e733465af3f
distributeScoreToOutlinks
public CrawlDatum distributeScoreToOutlinks(Text fromUrl, ParseData parseData, Collection<Entry<Text, CrawlDatum>> targets, CrawlDatum adjust, int allCount) throws ScoringFilterException
{    return adjust;}
021571540bd16053b37a45bee8e233da357044b2982932447da62f33fd6e6f2a
updateDbScore
public void updateDbScore(Text url, CrawlDatum old, CrawlDatum datum, List<CrawlDatum> inlinked) throws ScoringFilterException
{}
d2a95754238ce8e7ee9557976c163d8b3860456f1815caeadede92b2c9ee04fa
indexerScore
public float indexerScore(Text url, NutchDocument doc, CrawlDatum dbDatum, CrawlDatum fetchDatum, Parse parse, Inlinks inlinks, float initScore) throws ScoringFilterException
{    return initScore;}
fdd0c20c4e3eefd8eb3601b8acbc7ab0829ab80b5dde44752644178b1ae88748
orphanedScore
public void orphanedScore(Text url, CrawlDatum datum) throws ScoringFilterException
{}
c7d75ff32784416ea95ea0863f39cb7d0da44832579d23df72069418eb890bf5
generatorSortValue
public float generatorSortValue(Text url, CrawlDatum datum, float initSort) throws ScoringFilterException
{    for (int i = 0; i < this.filters.length; i++) {        initSort = this.filters[i].generatorSortValue(url, datum, initSort);    }    return initSort;}
2dcbf82c99c2e2b740c6a208c3e1e729c537864ed30748e09cdb44bbfad01075
initialScore
public void initialScore(Text url, CrawlDatum datum) throws ScoringFilterException
{    for (int i = 0; i < this.filters.length; i++) {        this.filters[i].initialScore(url, datum);    }}
0b6feb77383ae8d81d2c30e18bf6315732aeabecd96f00250a9915d31f7fbc88
injectedScore
public void injectedScore(Text url, CrawlDatum datum) throws ScoringFilterException
{    for (int i = 0; i < this.filters.length; i++) {        this.filters[i].injectedScore(url, datum);    }}
021571540bd16053b37a45bee8e233da357044b2982932447da62f33fd6e6f2a
updateDbScore
public void updateDbScore(Text url, CrawlDatum old, CrawlDatum datum, List<CrawlDatum> inlinked) throws ScoringFilterException
{    for (int i = 0; i < this.filters.length; i++) {        this.filters[i].updateDbScore(url, old, datum, inlinked);    }}
fdd0c20c4e3eefd8eb3601b8acbc7ab0829ab80b5dde44752644178b1ae88748
orphanedScore
public void orphanedScore(Text url, CrawlDatum datum) throws ScoringFilterException
{    for (int i = 0; i < this.filters.length; i++) {        this.filters[i].orphanedScore(url, datum);    }}
53571795b495728e7ad1dc9749d44ee6378e3f595ad89330bb07ce03d5f44873
passScoreBeforeParsing
public void passScoreBeforeParsing(Text url, CrawlDatum datum, Content content) throws ScoringFilterException
{    for (int i = 0; i < this.filters.length; i++) {        this.filters[i].passScoreBeforeParsing(url, datum, content);    }}
b9e96bf8d75863926c418ca10c8e728ef083a9a13368adf5af855a1fa573c6c7
passScoreAfterParsing
public void passScoreAfterParsing(Text url, Content content, Parse parse) throws ScoringFilterException
{    for (int i = 0; i < this.filters.length; i++) {        this.filters[i].passScoreAfterParsing(url, content, parse);    }}
89fdd7122298e467ee01a9f463b423fa9405ab98df3d1247ebce0e733465af3f
distributeScoreToOutlinks
public CrawlDatum distributeScoreToOutlinks(Text fromUrl, ParseData parseData, Collection<Entry<Text, CrawlDatum>> targets, CrawlDatum adjust, int allCount) throws ScoringFilterException
{    for (int i = 0; i < this.filters.length; i++) {        adjust = this.filters[i].distributeScoreToOutlinks(fromUrl, parseData, targets, adjust, allCount);    }    return adjust;}
d2a95754238ce8e7ee9557976c163d8b3860456f1815caeadede92b2c9ee04fa
indexerScore
public float indexerScore(Text url, NutchDocument doc, CrawlDatum dbDatum, CrawlDatum fetchDatum, Parse parse, Inlinks inlinks, float initScore) throws ScoringFilterException
{    for (int i = 0; i < this.filters.length; i++) {        initScore = this.filters[i].indexerScore(url, doc, dbDatum, fetchDatum, parse, inlinks, initScore);    }    return initScore;}
354afe66bbdb19ee4d620955bbb214ebf9b5aa09359dea30ffb867002b5a25bd
getUrl
public String getUrl()
{    return url;}
5632266259dd12f97eac4eb8fa5fe7c4757994ac78574e29c6b86d0d82bc5627
getAnchor
public String getAnchor()
{    return anchor;}
71e4b2b75e43d7d014b1ac7ca926b0badcc8cf34fccd8abd8b7944c83298ef5e
setAnchor
public void setAnchor(String anchor)
{    this.anchor = anchor;}
6f4b0f5ea8fd7dfa3fdce005672f6f3b0532cd398e75b8550ffa1c7fe96a733a
getScore
public float getScore()
{    return score;}
071161dd3251af6621397d84e4f0add6eab4e69fea95694f972de14af000f45c
setScore
public void setScore(float score)
{    this.score = score;}
c3d2ee14b0a87d91276b6034d452ebbd50ed47914948b9edaea83747da585af6
setUrl
public void setUrl(String url)
{    this.url = url;}
efd4f04d2f7438e26699863148fedf2a1756ec4f9ea70d9d64b80b1bdb63169b
getTimestamp
public long getTimestamp()
{    return timestamp;}
23574c7060a42d0554036b2d82b9f8b8f373b5505c3988ea0bfa6e52911b43a6
setTimestamp
public void setTimestamp(long timestamp)
{    this.timestamp = timestamp;}
6a79ce306a61534105e0c81dd5b743a59b840c3ea934797f718971c56b5b2caf
getLinkType
public byte getLinkType()
{    return linkType;}
e067c5c8b6f81db0d656a96f01916bef157538f5dfda022138adcd1bb61f01a5
setLinkType
public void setLinkType(byte linkType)
{    this.linkType = linkType;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    url = Text.readString(in);    anchor = Text.readString(in);    score = in.readFloat();    timestamp = in.readLong();    linkType = in.readByte();}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    Text.writeString(out, url);    Text.writeString(out, anchor != null ? anchor : "");    out.writeFloat(score);    out.writeLong(timestamp);    out.writeByte(linkType);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    String type = (linkType == INLINK ? "inlink" : (linkType == OUTLINK) ? "outlink" : "unknown");    return "url: " + url + ", anchor: " + anchor + ", score: " + score + ", timestamp: " + timestamp + ", link type: " + type;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    if (args == null || args.length < 2) {        System.out.println("LinkDumper$Reader usage: <webgraphdb> <url>");        return;    }        Configuration conf = NutchConfiguration.create();    Path webGraphDb = new Path(args[0]);    String url = args[1];    MapFile.Reader[] readers = MapFileOutputFormat.getReaders(new Path(webGraphDb, DUMP_DIR), conf);        Text key = new Text(url);    LinkNodes nodes = new LinkNodes();    MapFileOutputFormat.getEntry(readers, new HashPartitioner<>(), key, nodes);        LinkNode[] linkNodesAr = nodes.getLinks();    System.out.println(url + ":");    for (LinkNode node : linkNodesAr) {        System.out.println("  " + node.getUrl() + " - " + node.getNode().toString());    }        FSUtils.closeReaders(readers);}
354afe66bbdb19ee4d620955bbb214ebf9b5aa09359dea30ffb867002b5a25bd
getUrl
public String getUrl()
{    return url;}
c3d2ee14b0a87d91276b6034d452ebbd50ed47914948b9edaea83747da585af6
setUrl
public void setUrl(String url)
{    this.url = url;}
1a0935ca55eb5c352a44ffc78d317fcfcd52f8768900c12529e25d14af5e0d66
getNode
public Node getNode()
{    return node;}
9d705976ef27829ced2b26dabfbbd53adb3ea6886dfc71150dc65c28fb53fcae
setNode
public void setNode(Node node)
{    this.node = node;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    url = in.readUTF();    node = new Node();    node.readFields(in);}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeUTF(url);    node.write(out);}
2922b943ab6022aa4eb34e425a3f0f5de037a88884b7dd5e338da6519d387d84
getLinks
public LinkNode[] getLinks()
{    return links;}
61d4d0612f8cfc0832525492c2308104bf0ad122fcaf3c58c6d98684f01cf9f3
setLinks
public void setLinks(LinkNode[] links)
{    this.links = links;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    int numLinks = in.readInt();    if (numLinks > 0) {        links = new LinkNode[numLinks];        for (int i = 0; i < numLinks; i++) {            LinkNode node = new LinkNode();            node.readFields(in);            links[i] = node;        }    }}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    if (links != null && links.length > 0) {        int numLinks = links.length;        out.writeInt(numLinks);        for (int i = 0; i < numLinks; i++) {            links[i].write(out);        }    }}
4c9ec82e8777bee39c94eaffbd42f3bf891ce1ff9da91c3080a6b85972806e5d
map
public void map(Text key, Writable value, Context context) throws IOException, InterruptedException
{    ObjectWritable objWrite = new ObjectWritable();    objWrite.set(value);    context.write(key, objWrite);}
930d18a91277ee78c94350f2a55d5dca608f794bdedc8de55bf447d01ef528c2
setup
public void setup(Reducer<Text, ObjectWritable, Text, LinkNode>.Context context)
{    conf = context.getConfiguration();}
b9b0a523834c4e0bcd156a3ab07183b8f8e543eb2099b09234a97a9d4d2fb6cb
reduce
public void reduce(Text key, Iterable<ObjectWritable> values, Context context) throws IOException, InterruptedException
{    String fromUrl = key.toString();    List<LinkDatum> outlinks = new ArrayList<>();    Node node = null;        for (ObjectWritable write : values) {        Object obj = write.get();        if (obj instanceof Node) {            node = (Node) obj;        } else if (obj instanceof LinkDatum) {            outlinks.add(WritableUtils.clone((LinkDatum) obj, conf));        }    }        int numOutlinks = node.getNumOutlinks();    if (numOutlinks > 0) {        for (int i = 0; i < outlinks.size(); i++) {            LinkDatum outlink = outlinks.get(i);            String toUrl = outlink.getUrl();                        context.write(new Text(toUrl), new LinkNode(fromUrl, node));        }    }}
927f0d53f0eb52bcdc842c57b1540eba2b16af58902dad89baef82079f7b89e3
reduce
public void reduce(Text key, Iterable<LinkNode> values, Context context) throws IOException, InterruptedException
{    List<LinkNode> nodeList = new ArrayList<>();    int numNodes = 0;    for (LinkNode cur : values) {        if (numNodes < maxInlinks) {            nodeList.add(WritableUtils.clone(cur, conf));            numNodes++;        } else {            break;        }    }    LinkNode[] linkNodesAr = nodeList.toArray(new LinkNode[nodeList.size()]);    LinkNodes linkNodes = new LinkNodes(linkNodesAr);    context.write(key, linkNodes);}
b4283850b92145441f10f9a68e4efca65084cc9297c65b7022a8fc20046bd80e
dumpLinks
public void dumpLinks(Path webGraphDb) throws IOException, InterruptedException, ClassNotFoundException
{    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    long start = System.currentTimeMillis();    LOG.info("NodeDumper: starting at " + sdf.format(start));    Configuration conf = getConf();    FileSystem fs = webGraphDb.getFileSystem(conf);    Path linkdump = new Path(webGraphDb, DUMP_DIR);    Path nodeDb = new Path(webGraphDb, WebGraph.NODE_DIR);    Path outlinkDb = new Path(webGraphDb, WebGraph.OUTLINK_DIR);        Path tempInverted = new Path(webGraphDb, "inverted-" + Integer.toString(new Random().nextInt(Integer.MAX_VALUE)));    Job inverter = NutchJob.getInstance(conf);    inverter.setJobName("LinkDumper: inverter");    FileInputFormat.addInputPath(inverter, nodeDb);    FileInputFormat.addInputPath(inverter, outlinkDb);    inverter.setInputFormatClass(SequenceFileInputFormat.class);    inverter.setJarByClass(Inverter.class);    inverter.setMapperClass(Inverter.InvertMapper.class);    inverter.setReducerClass(Inverter.InvertReducer.class);    inverter.setMapOutputKeyClass(Text.class);    inverter.setMapOutputValueClass(ObjectWritable.class);    inverter.setOutputKeyClass(Text.class);    inverter.setOutputValueClass(LinkNode.class);    FileOutputFormat.setOutputPath(inverter, tempInverted);    inverter.setOutputFormatClass(SequenceFileOutputFormat.class);    try {        LOG.info("LinkDumper: running inverter");        boolean success = inverter.waitForCompletion(true);        if (!success) {            String message = "LinkDumper inverter job did not succeed, job status:" + inverter.getStatus().getState() + ", reason: " + inverter.getStatus().getFailureInfo();            LOG.error(message);            throw new RuntimeException(message);        }        LOG.info("LinkDumper: finished inverter");    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error("LinkDumper inverter job failed:", e);        throw e;    }        Job merger = NutchJob.getInstance(conf);    merger.setJobName("LinkDumper: merger");    FileInputFormat.addInputPath(merger, tempInverted);    merger.setJarByClass(Merger.class);    merger.setInputFormatClass(SequenceFileInputFormat.class);    merger.setReducerClass(Merger.class);    merger.setMapOutputKeyClass(Text.class);    merger.setMapOutputValueClass(LinkNode.class);    merger.setOutputKeyClass(Text.class);    merger.setOutputValueClass(LinkNodes.class);    FileOutputFormat.setOutputPath(merger, linkdump);    merger.setOutputFormatClass(MapFileOutputFormat.class);    try {        LOG.info("LinkDumper: running merger");        boolean success = merger.waitForCompletion(true);        if (!success) {            String message = "LinkDumper merger job did not succeed, job status:" + merger.getStatus().getState() + ", reason: " + merger.getStatus().getFailureInfo();            LOG.error(message);            throw new RuntimeException(message);        }        LOG.info("LinkDumper: finished merger");    } catch (IOException e) {        LOG.error("LinkDumper merger job failed:", e);        throw e;    }    fs.delete(tempInverted, true);    long end = System.currentTimeMillis();    LOG.info("LinkDumper: finished at " + sdf.format(end) + ", elapsed: " + TimingUtil.elapsedTime(start, end));}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int res = ToolRunner.run(NutchConfiguration.create(), new LinkDumper(), args);    System.exit(res);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    Options options = new Options();    OptionBuilder.withArgName("help");    OptionBuilder.withDescription("show this help message");    Option helpOpts = OptionBuilder.create("help");    options.addOption(helpOpts);    OptionBuilder.withArgName("webgraphdb");    OptionBuilder.hasArg();    OptionBuilder.withDescription("the web graph database to use");    Option webGraphDbOpts = OptionBuilder.create("webgraphdb");    options.addOption(webGraphDbOpts);    CommandLineParser parser = new GnuParser();    try {        CommandLine line = parser.parse(options, args);        if (line.hasOption("help") || !line.hasOption("webgraphdb")) {            HelpFormatter formatter = new HelpFormatter();            formatter.printHelp("LinkDumper", options);            return -1;        }        String webGraphDb = line.getOptionValue("webgraphdb");        dumpLinks(new Path(webGraphDb));        return 0;    } catch (Exception e) {        LOG.error("LinkDumper: " + StringUtils.stringifyException(e));        return -2;    }}
76a507437ccf235412c4aeb6632a1cb22e867a9fdb58e72274bf65bbf1ba51de
runCounter
private int runCounter(FileSystem fs, Path webGraphDb) throws IOException, ClassNotFoundException, InterruptedException
{        Path numLinksPath = new Path(webGraphDb, NUM_NODES);    Path nodeDb = new Path(webGraphDb, WebGraph.NODE_DIR);    Job counter = NutchJob.getInstance(getConf());    Configuration conf = counter.getConfiguration();    counter.setJobName("LinkRank Counter");    FileInputFormat.addInputPath(counter, nodeDb);    FileOutputFormat.setOutputPath(counter, numLinksPath);    counter.setInputFormatClass(SequenceFileInputFormat.class);    counter.setJarByClass(Counter.class);    counter.setMapperClass(Counter.CountMapper.class);    counter.setCombinerClass(Counter.CountReducer.class);    counter.setReducerClass(Counter.CountReducer.class);    counter.setMapOutputKeyClass(Text.class);    counter.setMapOutputValueClass(LongWritable.class);    counter.setOutputKeyClass(Text.class);    counter.setOutputValueClass(LongWritable.class);    counter.setNumReduceTasks(1);    counter.setOutputFormatClass(TextOutputFormat.class);    conf.setBoolean("mapreduce.fileoutputcommitter.marksuccessfuljobs", false);        LOG.info("Starting link counter job");    try {        boolean success = counter.waitForCompletion(true);        if (!success) {            String message = "Link counter job did not succeed, job status:" + counter.getStatus().getState() + ", reason: " + counter.getStatus().getFailureInfo();            LOG.error(message);            throw new RuntimeException(message);        }    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error("Link counter job failed:", e);        throw e;    }    LOG.info("Finished link counter job");            FileStatus[] numLinksFiles = fs.listStatus(numLinksPath);    if (numLinksFiles.length == 0) {        throw new IOException("Failed to read numlinks temp file: " + " no file found in " + numLinksPath);    } else if (numLinksFiles.length > 1) {        throw new IOException("Failed to read numlinks temp file: " + " expected only one file but found " + numLinksFiles.length + " files in folder " + numLinksPath);    }    Path numLinksFile = numLinksFiles[0].getPath();    LOG.info("Reading numlinks temp file {}", numLinksFile);    FSDataInputStream readLinks = fs.open(numLinksFile);    CompressionCodecFactory cf = new CompressionCodecFactory(conf);    CompressionCodec codec = cf.getCodec(numLinksFiles[0].getPath());    InputStream streamLinks;    if (codec == null) {        LOG.debug("No compression codec found for {}, trying uncompressed", numLinksFile);        streamLinks = readLinks;    } else {        LOG.info("Compression codec of numlinks temp file: {}", codec.getDefaultExtension());        readLinks.seek(0);        streamLinks = codec.createInputStream(readLinks);    }    BufferedReader buffer = new BufferedReader(new InputStreamReader(streamLinks));    String numLinksLine = buffer.readLine();    readLinks.close();        if (numLinksLine == null || numLinksLine.length() == 0) {        LOG.error("Failed to determine number of links because of empty line in input {}", numLinksFile);        fs.delete(numLinksPath, true);        throw new IOException("No links to process, is the webgraph empty?");    }        LOG.info("Deleting numlinks temp file");    fs.delete(numLinksPath, true);    String numLinks = numLinksLine.split("\\s+")[1];    return Integer.parseInt(numLinks);}
37a128bb3fc4961bac2ce91632e9189e0cc6494106d7b24b71e621a0099d1608
runInitializer
private void runInitializer(Path nodeDb, Path output) throws IOException, InterruptedException, ClassNotFoundException
{        Job initializer = NutchJob.getInstance(getConf());    Configuration conf = initializer.getConfiguration();    initializer.setJobName("LinkAnalysis Initializer");    FileInputFormat.addInputPath(initializer, nodeDb);    FileOutputFormat.setOutputPath(initializer, output);    initializer.setJarByClass(Initializer.class);    initializer.setInputFormatClass(SequenceFileInputFormat.class);    initializer.setMapperClass(Initializer.class);    initializer.setMapOutputKeyClass(Text.class);    initializer.setMapOutputValueClass(Node.class);    initializer.setOutputKeyClass(Text.class);    initializer.setOutputValueClass(Node.class);    initializer.setOutputFormatClass(MapFileOutputFormat.class);    conf.setBoolean("mapreduce.fileoutputcommitter.marksuccessfuljobs", false);        LOG.info("Starting initialization job");    try {        boolean success = initializer.waitForCompletion(true);        if (!success) {            String message = "Initialization job did not succeed, job status:" + initializer.getStatus().getState() + ", reason: " + initializer.getStatus().getFailureInfo();            LOG.error(message);            throw new RuntimeException(message);        }    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error("Initialization job failed:", e);        throw e;    }    LOG.info("Finished initialization job.");}
d8ba4f251f9ad108ced35115a82f5215dd04a6234afb61b551b2ae7aa346ce48
runInverter
private void runInverter(Path nodeDb, Path outlinkDb, Path output) throws IOException, InterruptedException, ClassNotFoundException
{        Job inverter = NutchJob.getInstance(getConf());    Configuration conf = inverter.getConfiguration();    inverter.setJobName("LinkAnalysis Inverter");    FileInputFormat.addInputPath(inverter, nodeDb);    FileInputFormat.addInputPath(inverter, outlinkDb);    FileOutputFormat.setOutputPath(inverter, output);    inverter.setInputFormatClass(SequenceFileInputFormat.class);    inverter.setJarByClass(Inverter.class);    inverter.setMapperClass(Inverter.InvertMapper.class);    inverter.setReducerClass(Inverter.InvertReducer.class);    inverter.setMapOutputKeyClass(Text.class);    inverter.setMapOutputValueClass(ObjectWritable.class);    inverter.setOutputKeyClass(Text.class);    inverter.setOutputValueClass(LinkDatum.class);    inverter.setOutputFormatClass(SequenceFileOutputFormat.class);    conf.setBoolean("mapreduce.fileoutputcommitter.marksuccessfuljobs", false);        LOG.info("Starting inverter job");    try {        boolean success = inverter.waitForCompletion(true);        if (!success) {            String message = "Inverter job did not succeed, job status:" + inverter.getStatus().getState() + ", reason: " + inverter.getStatus().getFailureInfo();            LOG.error(message);            throw new RuntimeException(message);        }    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error("Inverter job failed:", e);        throw e;    }    LOG.info("Finished inverter job.");}
dee066f90a948a23829e0876c12c1ad80d9d7e6836b5c4e5778657dbcd9ee918
runAnalysis
private void runAnalysis(Path nodeDb, Path inverted, Path output, int iteration, int numIterations, float rankOne) throws IOException, InterruptedException, ClassNotFoundException
{    Job analyzer = NutchJob.getInstance(getConf());    Configuration conf = analyzer.getConfiguration();    conf.set("link.analyze.iteration", String.valueOf(iteration + 1));    analyzer.setJobName("LinkAnalysis Analyzer, iteration " + (iteration + 1) + " of " + numIterations);    FileInputFormat.addInputPath(analyzer, nodeDb);    FileInputFormat.addInputPath(analyzer, inverted);    FileOutputFormat.setOutputPath(analyzer, output);    conf.set("link.analyze.rank.one", String.valueOf(rankOne));    analyzer.setMapOutputKeyClass(Text.class);    analyzer.setMapOutputValueClass(ObjectWritable.class);    analyzer.setInputFormatClass(SequenceFileInputFormat.class);    analyzer.setJarByClass(Analyzer.class);    analyzer.setMapperClass(Analyzer.AnalyzerMapper.class);    analyzer.setReducerClass(Analyzer.AnalyzerReducer.class);    analyzer.setOutputKeyClass(Text.class);    analyzer.setOutputValueClass(Node.class);    analyzer.setOutputFormatClass(MapFileOutputFormat.class);    conf.setBoolean("mapreduce.fileoutputcommitter.marksuccessfuljobs", false);    LOG.info("Starting analysis job");    try {        boolean success = analyzer.waitForCompletion(true);        if (!success) {            String message = "Analysis job did not succeed, job status:" + analyzer.getStatus().getState() + ", reason: " + analyzer.getStatus().getFailureInfo();            LOG.error(message);            throw new RuntimeException(message);        }    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error("Analysis job failed:", e);        throw e;    }    LOG.info("Finished analysis job.");}
c68029ab89d09daeef5293b1a4316e03e013d345b6de63585a5bc030aad15f64
setup
public void setup(Mapper<Text, Node, Text, LongWritable>.Context context)
{}
e1c4d13ae4342d9659e0937ff945670ce2f03707a6b24a193067278391c07015
map
public void map(Text key, Node value, Context context) throws IOException, InterruptedException
{    context.write(numNodes, one);}
497ca62e886a7a1e08bc525bdff6cdcbeedeac969bed5d96fc2e7db75b92092b
setup
public void setup(Reducer<Text, LongWritable, Text, LongWritable>.Context context)
{}
8f445d7a50d60bc0e03a6c7a84a91342429188f7c21933677bb53751bf0afa10
reduce
public void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException
{    long total = 0;    for (LongWritable val : values) {        total += val.get();    }    context.write(numNodes, new LongWritable(total));}
79abcf990443bb6d2ab24d7964b0142e8b5a6b9faa5b1a0294d4f7f655b92cac
setup
public void setup(Mapper<Text, Node, Text, Node>.Context context)
{    conf = context.getConfiguration();    initialScore = conf.getFloat("link.analyze.initial.score", 1.0f);}
d1956767b27c429ef39e6acaa13498f92459d631fd2491ea03278a2191163536
map
public void map(Text key, Node node, Context context) throws IOException, InterruptedException
{    String url = key.toString();    Node outNode = WritableUtils.clone(node, conf);    outNode.setInlinkScore(initialScore);    context.write(new Text(url), outNode);}
6aa9e21715cc441948f643fa54980bb8ca3aff40fe49a430c2c0ac9e2ae5a0f4
setup
public void setup(Mapper<Text, Writable, Text, ObjectWritable>.Context context)
{}
4c9ec82e8777bee39c94eaffbd42f3bf891ce1ff9da91c3080a6b85972806e5d
map
public void map(Text key, Writable value, Context context) throws IOException, InterruptedException
{    ObjectWritable objWrite = new ObjectWritable();    objWrite.set(value);    context.write(key, objWrite);}
ea89e6f25752e9596a00f822c362d602de3c9d680c2413e0cf5a62dfb52ab0de
setup
public void setup(Reducer<Text, ObjectWritable, Text, LinkDatum>.Context context)
{    conf = context.getConfiguration();}
b9b0a523834c4e0bcd156a3ab07183b8f8e543eb2099b09234a97a9d4d2fb6cb
reduce
public void reduce(Text key, Iterable<ObjectWritable> values, Context context) throws IOException, InterruptedException
{    String fromUrl = key.toString();    List<LinkDatum> outlinks = new ArrayList<>();    Node node = null;        for (ObjectWritable write : values) {        Object obj = write.get();        if (obj instanceof Node) {            node = (Node) obj;        } else if (obj instanceof LinkDatum) {            outlinks.add(WritableUtils.clone((LinkDatum) obj, conf));        }    }            int numOutlinks = node.getNumOutlinks();    float inlinkScore = node.getInlinkScore();    float outlinkScore = node.getOutlinkScore();    LOG.debug(fromUrl + ": num outlinks " + numOutlinks);        if (numOutlinks > 0) {        for (int i = 0; i < outlinks.size(); i++) {            LinkDatum outlink = outlinks.get(i);            String toUrl = outlink.getUrl();            outlink.setUrl(fromUrl);            outlink.setScore(outlinkScore);                        context.write(new Text(toUrl), outlink);            LOG.debug(toUrl + ": inverting inlink from " + fromUrl + " origscore: " + inlinkScore + " numOutlinks: " + numOutlinks + " inlinkscore: " + outlinkScore);        }    }}
6aa9e21715cc441948f643fa54980bb8ca3aff40fe49a430c2c0ac9e2ae5a0f4
setup
public void setup(Mapper<Text, Writable, Text, ObjectWritable>.Context context)
{    conf = context.getConfiguration();}
4c9ec82e8777bee39c94eaffbd42f3bf891ce1ff9da91c3080a6b85972806e5d
map
public void map(Text key, Writable value, Context context) throws IOException, InterruptedException
{    ObjectWritable objWrite = new ObjectWritable();    objWrite.set(WritableUtils.clone(value, conf));    context.write(key, objWrite);}
e95d54c415f5e4829b79721aa0da88e233aa9e068dbed1badd81230a01cdcfb2
setup
public void setup(Reducer<Text, ObjectWritable, Text, Node>.Context context)
{    conf = context.getConfiguration();    dampingFactor = conf.getFloat("link.analyze.damping.factor", 0.85f);    rankOne = conf.getFloat("link.analyze.rank.one", 0.0f);    itNum = conf.getInt("link.analyze.iteration", 0);    limitPages = conf.getBoolean("link.ignore.limit.page", true);    limitDomains = conf.getBoolean("link.ignore.limit.domain", true);}
b9b0a523834c4e0bcd156a3ab07183b8f8e543eb2099b09234a97a9d4d2fb6cb
reduce
public void reduce(Text key, Iterable<ObjectWritable> values, Context context) throws IOException, InterruptedException
{    String url = key.toString();    Set<String> domains = new HashSet<>();    Set<String> pages = new HashSet<>();    Node node = null;        int numInlinks = 0;    float totalInlinkScore = rankOne;    for (ObjectWritable next : values) {        Object value = next.get();        if (value instanceof Node) {            node = (Node) value;        } else if (value instanceof LinkDatum) {            LinkDatum linkDatum = (LinkDatum) value;            float scoreFromInlink = linkDatum.getScore();            String inlinkUrl = linkDatum.getUrl();            String inLinkDomain = URLUtil.getDomainName(inlinkUrl);            String inLinkPage = URLUtil.getPage(inlinkUrl);                        if ((limitPages && pages.contains(inLinkPage)) || (limitDomains && domains.contains(inLinkDomain))) {                LOG.debug(url + ": ignoring " + scoreFromInlink + " from " + inlinkUrl + ", duplicate page or domain");                continue;            }                        numInlinks++;            totalInlinkScore += scoreFromInlink;            domains.add(inLinkDomain);            pages.add(inLinkPage);            LOG.debug(url + ": adding " + scoreFromInlink + " from " + inlinkUrl + ", total: " + totalInlinkScore);        }    }        float linkRankScore = (1 - dampingFactor) + (dampingFactor * totalInlinkScore);    LOG.debug(url + ": score: " + linkRankScore + " num inlinks: " + numInlinks + " iteration: " + itNum);        Node outNode = WritableUtils.clone(node, conf);    outNode.setInlinkScore(linkRankScore);    context.write(key, outNode);}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{}
8b5c2d34322df3677ed55df3d8472ef293d9ea7bb69757ed8aa25b04e0260dc4
analyze
public void analyze(Path webGraphDb) throws IOException, ClassNotFoundException, InterruptedException
{    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    long start = System.currentTimeMillis();    LOG.info("Analysis: starting at " + sdf.format(start));            Path linkRank = new Path(webGraphDb, "linkrank");    Configuration conf = getConf();    FileSystem fs = linkRank.getFileSystem(conf);        if (!fs.exists(linkRank)) {        fs.mkdirs(linkRank);    }        Path wgOutlinkDb = new Path(webGraphDb, WebGraph.OUTLINK_DIR);    Path wgNodeDb = new Path(webGraphDb, WebGraph.NODE_DIR);    Path nodeDb = new Path(linkRank, WebGraph.NODE_DIR);            int numLinks = runCounter(fs, webGraphDb);    runInitializer(wgNodeDb, nodeDb);    float rankOneScore = (1f / (float) numLinks);    if (LOG.isInfoEnabled()) {        LOG.info("Analysis: Number of links: " + numLinks);        LOG.info("Analysis: Rank One: " + rankOneScore);    }            int numIterations = conf.getInt("link.analyze.num.iterations", 10);    for (int i = 0; i < numIterations; i++) {                LOG.info("Analysis: Starting iteration " + (i + 1) + " of " + numIterations);        Path tempRank = new Path(linkRank + "-" + Integer.toString(new Random().nextInt(Integer.MAX_VALUE)));        fs.mkdirs(tempRank);        Path tempInverted = new Path(tempRank, "inverted");        Path tempNodeDb = new Path(tempRank, WebGraph.NODE_DIR);                runInverter(nodeDb, wgOutlinkDb, tempInverted);        runAnalysis(nodeDb, tempInverted, tempNodeDb, i, numIterations, rankOneScore);                LOG.info("Analysis: Installing new link scores");        FSUtils.replace(fs, linkRank, tempRank, true);        LOG.info("Analysis: finished iteration " + (i + 1) + " of " + numIterations);    }        LOG.info("Analysis: Installing web graph nodes");    FSUtils.replace(fs, wgNodeDb, nodeDb, true);        fs.delete(linkRank, true);    long end = System.currentTimeMillis();    LOG.info("Analysis: finished at " + sdf.format(end) + ", elapsed: " + TimingUtil.elapsedTime(start, end));}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int res = ToolRunner.run(NutchConfiguration.create(), new LinkRank(), args);    System.exit(res);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    Options options = new Options();    OptionBuilder.withArgName("help");    OptionBuilder.withDescription("show this help message");    Option helpOpts = OptionBuilder.create("help");    options.addOption(helpOpts);    OptionBuilder.withArgName("webgraphdb");    OptionBuilder.hasArg();    OptionBuilder.withDescription("the web graph db to use");    Option webgraphOpts = OptionBuilder.create("webgraphdb");    options.addOption(webgraphOpts);    CommandLineParser parser = new GnuParser();    try {        CommandLine line = parser.parse(options, args);        if (line.hasOption("help") || !line.hasOption("webgraphdb")) {            HelpFormatter formatter = new HelpFormatter();            formatter.printHelp("LinkRank", options);            return -1;        }        String webGraphDb = line.getOptionValue("webgraphdb");        analyze(new Path(webGraphDb));        return 0;    } catch (Exception e) {        LOG.error("LinkAnalysis: " + StringUtils.stringifyException(e));        return -2;    }}
acb0b309ea76b3a9ef4916f803103ed88976cfec00d31f9ef4e35d3fe0c57eff
getNumInlinks
public int getNumInlinks()
{    return numInlinks;}
3a3570f99005966ad4dc1e66873e8370d7db4b8945b0bc9118c8efea2910285a
setNumInlinks
public void setNumInlinks(int numInlinks)
{    this.numInlinks = numInlinks;}
e21fcd1836b73ecad6c85ef8fae64c8cdc642c0c8e95dcc73ff4c5d6a5c718e0
getNumOutlinks
public int getNumOutlinks()
{    return numOutlinks;}
44e25faa91cd26accaebf5f6e77ac51807006674e558d06fe4135fa39de7b65d
setNumOutlinks
public void setNumOutlinks(int numOutlinks)
{    this.numOutlinks = numOutlinks;}
6b9afd5d71d0955efc13fbe96156499c8f66716c402e5292b9ec9c145ffee586
getInlinkScore
public float getInlinkScore()
{    return inlinkScore;}
5a0bd7ef1d92667e5bf5702e7347653b2109e998112211aebb7ded43b672a989
setInlinkScore
public void setInlinkScore(float inlinkScore)
{    this.inlinkScore = inlinkScore;}
10cb2bacac0131679cfca17cd542a99263ff3a4680820b702456979ca216d4c1
getOutlinkScore
public float getOutlinkScore()
{    return (numOutlinks > 0) ? inlinkScore / numOutlinks : inlinkScore;}
3278491613baf75b185ed9d8d57b8e0f596c9babb670aa112cc72d53896855cf
getMetadata
public Metadata getMetadata()
{    return metadata;}
3d75b4f93fffacb6e9ca645720d4a174e7b1772706baab104d664fe61f0c9f7f
setMetadata
public void setMetadata(Metadata metadata)
{    this.metadata = metadata;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    numInlinks = in.readInt();    numOutlinks = in.readInt();    inlinkScore = in.readFloat();    metadata.clear();    metadata.readFields(in);}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeInt(numInlinks);    out.writeInt(numOutlinks);    out.writeFloat(inlinkScore);    metadata.write(out);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "num inlinks: " + numInlinks + ", num outlinks: " + numOutlinks + ", inlink score: " + inlinkScore + ", outlink score: " + getOutlinkScore() + ", metadata: " + metadata.toString();}
17c832dee6c97b7dd221e632cb0ce41fd746f2dda1c9ccc1d005e23d0c5df3e2
setup
public void setup(Mapper<Text, Node, FloatWritable, Text>.Context context)
{    conf = context.getConfiguration();    inlinks = conf.getBoolean("inlinks", false);    outlinks = conf.getBoolean("outlinks", false);}
d1956767b27c429ef39e6acaa13498f92459d631fd2491ea03278a2191163536
map
public void map(Text key, Node node, Context context) throws IOException, InterruptedException
{    float number = 0;    if (inlinks) {        number = node.getNumInlinks();    } else if (outlinks) {        number = node.getNumOutlinks();    } else {        number = node.getInlinkScore();    }        context.write(new FloatWritable(-number), key);}
892b19f620ce74ac8252a747fadf372a841436f60b50779aeead53a332b516e7
setup
public void setup(Reducer<FloatWritable, Text, Text, FloatWritable>.Context context)
{    conf = context.getConfiguration();    topn = conf.getLong("topn", Long.MAX_VALUE);}
f8f7b021e550c422a98af8d0c82511387c65ef5c15a06383b56757cb4f748d61
reduce
public void reduce(FloatWritable key, Iterable<Text> values, Context context) throws IOException, InterruptedException
{            float val = key.get();    FloatWritable number = new FloatWritable(val == 0 ? 0 : -val);    long numCollected = 0;        for (Text value : values) {        if (numCollected < topn) {            Text url = WritableUtils.clone(value, conf);            context.write(url, number);            numCollected++;        }    }}
2c0f3742a0e0b6b52ce4b93f9ee918269932f4c1307643a3226924fcdf6086d8
setup
public void setup(Mapper<Text, Node, Text, FloatWritable>.Context context)
{    conf = context.getConfiguration();    inlinks = conf.getBoolean("inlinks", false);    outlinks = conf.getBoolean("outlinks", false);    host = conf.getBoolean("host", false);}
d1956767b27c429ef39e6acaa13498f92459d631fd2491ea03278a2191163536
map
public void map(Text key, Node node, Context context) throws IOException, InterruptedException
{    float number = 0;    if (inlinks) {        number = node.getNumInlinks();    } else if (outlinks) {        number = node.getNumOutlinks();    } else {        number = node.getInlinkScore();    }    if (host) {        key.set(URLUtil.getHost(key.toString()));    } else {        key.set(URLUtil.getDomainName(key.toString()));    }    context.write(key, new FloatWritable(number));}
34c929c8611186c396613d7273abd8be3d694373224b165b7e53c7f6360d1fb4
reduce
public void reduce(Text key, Iterable<FloatWritable> values, Context context) throws IOException, InterruptedException
{    long numCollected = 0;    float sumOrMax = 0;    float val = 0;        for (FloatWritable value : values) {        if (numCollected < topn) {            val = value.get();            if (sum) {                sumOrMax += val;            } else {                if (sumOrMax < val) {                    sumOrMax = val;                }            }            numCollected++;        } else {            break;        }    }    context.write(key, new FloatWritable(sumOrMax));}
57d3bfb00f83805ea27ca2c6793358de31a693a4415d56c7074b1fd85af001ee
setup
public void setup(Reducer<Text, FloatWritable, Text, FloatWritable>.Context context)
{    conf = context.getConfiguration();    topn = conf.getLong("topn", Long.MAX_VALUE);    sum = conf.getBoolean("sum", false);}
f45b1a76f0260ab7d482b95567ee52d0e758d1ecc36ca8e74046690df1f12000
dumpNodes
public void dumpNodes(Path webGraphDb, DumpType type, long topN, Path output, boolean asEff, NameType nameType, AggrType aggrType, boolean asSequenceFile) throws Exception
{    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    long start = System.currentTimeMillis();    LOG.info("NodeDumper: starting at " + sdf.format(start));    Path nodeDb = new Path(webGraphDb, WebGraph.NODE_DIR);    Job dumper = NutchJob.getInstance(getConf());    Configuration conf = dumper.getConfiguration();    dumper.setJobName("NodeDumper: " + webGraphDb);    FileInputFormat.addInputPath(dumper, nodeDb);    dumper.setInputFormatClass(SequenceFileInputFormat.class);    if (nameType == null) {        dumper.setJarByClass(Sorter.class);        dumper.setMapperClass(Sorter.SorterMapper.class);        dumper.setReducerClass(Sorter.SorterReducer.class);        dumper.setMapOutputKeyClass(FloatWritable.class);        dumper.setMapOutputValueClass(Text.class);    } else {        dumper.setJarByClass(Dumper.class);        dumper.setMapperClass(Dumper.DumperMapper.class);        dumper.setReducerClass(Dumper.DumperReducer.class);        dumper.setMapOutputKeyClass(Text.class);        dumper.setMapOutputValueClass(FloatWritable.class);    }    dumper.setOutputKeyClass(Text.class);    dumper.setOutputValueClass(FloatWritable.class);    FileOutputFormat.setOutputPath(dumper, output);    if (asSequenceFile) {        dumper.setOutputFormatClass(SequenceFileOutputFormat.class);    } else {        dumper.setOutputFormatClass(TextOutputFormat.class);    }    dumper.setNumReduceTasks(1);    conf.setBoolean("inlinks", type == DumpType.INLINKS);    conf.setBoolean("outlinks", type == DumpType.OUTLINKS);    conf.setBoolean("scores", type == DumpType.SCORES);    conf.setBoolean("host", nameType == NameType.HOST);    conf.setBoolean("domain", nameType == NameType.DOMAIN);    conf.setBoolean("sum", aggrType == AggrType.SUM);    conf.setBoolean("max", aggrType == AggrType.MAX);    conf.setLong("topn", topN);        if (asEff) {        conf.set("mapreduce.output.textoutputformat.separator", "=");    }    try {        LOG.info("NodeDumper: running");        boolean success = dumper.waitForCompletion(true);        if (!success) {            String message = "NodeDumper job did not succeed, job status:" + dumper.getStatus().getState() + ", reason: " + dumper.getStatus().getFailureInfo();            LOG.error(message);            throw new RuntimeException(message);        }    } catch (IOException e) {        LOG.error("NodeDumper job failed:", e);        throw e;    }    long end = System.currentTimeMillis();    LOG.info("NodeDumper: finished at " + sdf.format(end) + ", elapsed: " + TimingUtil.elapsedTime(start, end));}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int res = ToolRunner.run(NutchConfiguration.create(), new NodeDumper(), args);    System.exit(res);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    Options options = new Options();    OptionBuilder.withArgName("help");    OptionBuilder.withDescription("show this help message");    Option helpOpts = OptionBuilder.create("help");    options.addOption(helpOpts);    OptionBuilder.withArgName("webgraphdb");    OptionBuilder.hasArg();    OptionBuilder.withDescription("the web graph database to use");    Option webGraphDbOpts = OptionBuilder.create("webgraphdb");    options.addOption(webGraphDbOpts);    OptionBuilder.withArgName("inlinks");    OptionBuilder.withDescription("show highest inlinks");    Option inlinkOpts = OptionBuilder.create("inlinks");    options.addOption(inlinkOpts);    OptionBuilder.withArgName("outlinks");    OptionBuilder.withDescription("show highest outlinks");    Option outlinkOpts = OptionBuilder.create("outlinks");    options.addOption(outlinkOpts);    OptionBuilder.withArgName("scores");    OptionBuilder.withDescription("show highest scores");    Option scoreOpts = OptionBuilder.create("scores");    options.addOption(scoreOpts);    OptionBuilder.withArgName("topn");    OptionBuilder.hasOptionalArg();    OptionBuilder.withDescription("show topN scores");    Option topNOpts = OptionBuilder.create("topn");    options.addOption(topNOpts);    OptionBuilder.withArgName("output");    OptionBuilder.hasArg();    OptionBuilder.withDescription("the output directory to use");    Option outputOpts = OptionBuilder.create("output");    options.addOption(outputOpts);    OptionBuilder.withArgName("asEff");    OptionBuilder.withDescription("Solr ExternalFileField compatible output format");    Option effOpts = OptionBuilder.create("asEff");    options.addOption(effOpts);    OptionBuilder.hasArgs(2);    OptionBuilder.withDescription("group <host|domain> <sum|max>");    Option groupOpts = OptionBuilder.create("group");    options.addOption(groupOpts);    OptionBuilder.withArgName("asSequenceFile");    OptionBuilder.withDescription("whether to output as a sequencefile");    Option sequenceFileOpts = OptionBuilder.create("asSequenceFile");    options.addOption(sequenceFileOpts);    CommandLineParser parser = new GnuParser();    try {        CommandLine line = parser.parse(options, args);        if (line.hasOption("help") || !line.hasOption("webgraphdb")) {            HelpFormatter formatter = new HelpFormatter();            formatter.printHelp("NodeDumper", options);            return -1;        }        String webGraphDb = line.getOptionValue("webgraphdb");        boolean inlinks = line.hasOption("inlinks");        boolean outlinks = line.hasOption("outlinks");        long topN = (line.hasOption("topn") ? Long.parseLong(line.getOptionValue("topn")) : Long.MAX_VALUE);                String output = line.getOptionValue("output");        DumpType type = (inlinks ? DumpType.INLINKS : outlinks ? DumpType.OUTLINKS : DumpType.SCORES);        NameType nameType = null;        AggrType aggrType = null;        String[] group = line.getOptionValues("group");        if (group != null && group.length == 2) {            nameType = (group[0].equals("host") ? NameType.HOST : group[0].equals("domain") ? NameType.DOMAIN : null);            aggrType = (group[1].equals("sum") ? AggrType.SUM : group[1].equals("sum") ? AggrType.MAX : null);        }                boolean asEff = line.hasOption("asEff");        boolean asSequenceFile = line.hasOption("asSequenceFile");        dumpNodes(new Path(webGraphDb), type, topN, new Path(output), asEff, nameType, aggrType, asSequenceFile);        return 0;    } catch (Exception e) {        LOG.error("NodeDumper: " + StringUtils.stringifyException(e));        return -2;    }}
7d85ea4a22c8c5ea7a9602cc3770f4fe816754714d9375c961fde44ca0c0f2d6
dumpUrl
public void dumpUrl(Path webGraphDb, String url) throws IOException
{    nodeReaders = MapFileOutputFormat.getReaders(new Path(webGraphDb, WebGraph.NODE_DIR), getConf());        Text key = new Text(url);    Node node = new Node();    MapFileOutputFormat.getEntry(nodeReaders, new HashPartitioner<>(), key, node);    System.out.println(url + ":");    System.out.println("  inlink score: " + node.getInlinkScore());    System.out.println("  outlink score: " + node.getOutlinkScore());    System.out.println("  num inlinks: " + node.getNumInlinks());    System.out.println("  num outlinks: " + node.getNumOutlinks());    FSUtils.closeReaders(nodeReaders);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    Options options = new Options();    OptionBuilder.withArgName("help");    OptionBuilder.withDescription("show this help message");    Option helpOpts = OptionBuilder.create("help");    options.addOption(helpOpts);    OptionBuilder.withArgName("webgraphdb");    OptionBuilder.hasArg();    OptionBuilder.withDescription("the webgraphdb to use");    Option webGraphOpts = OptionBuilder.create("webgraphdb");    options.addOption(webGraphOpts);    OptionBuilder.withArgName("url");    OptionBuilder.hasOptionalArg();    OptionBuilder.withDescription("the url to dump");    Option urlOpts = OptionBuilder.create("url");    options.addOption(urlOpts);    CommandLineParser parser = new GnuParser();    try {                CommandLine line = parser.parse(options, args);        if (line.hasOption("help") || !line.hasOption("webgraphdb") || !line.hasOption("url")) {            HelpFormatter formatter = new HelpFormatter();            formatter.printHelp("WebGraphReader", options);            return;        }                String webGraphDb = line.getOptionValue("webgraphdb");        String url = line.getOptionValue("url");        NodeReader reader = new NodeReader(NutchConfiguration.create());        reader.dumpUrl(new Path(webGraphDb), url);        return;    } catch (Exception e) {        e.printStackTrace();        return;    }}
4c9ec82e8777bee39c94eaffbd42f3bf891ce1ff9da91c3080a6b85972806e5d
map
public void map(Text key, Writable value, Context context) throws IOException, InterruptedException
{    ObjectWritable objWrite = new ObjectWritable();    objWrite.set(value);    context.write(key, objWrite);}
fc2e1c6e3da6b1fd8534646910df00d223ac7b2dd1c389cdcb1681ecdf3186df
setup
public void setup(Reducer<Text, ObjectWritable, Text, CrawlDatum>.Context context)
{    Configuration conf = context.getConfiguration();    clearScore = conf.getFloat("link.score.updater.clear.score", 0.0f);}
b9b0a523834c4e0bcd156a3ab07183b8f8e543eb2099b09234a97a9d4d2fb6cb
reduce
public void reduce(Text key, Iterable<ObjectWritable> values, Context context) throws IOException, InterruptedException
{    String url = key.toString();    Node node = null;    CrawlDatum datum = null;        for (ObjectWritable next : values) {        Object value = next.get();        if (value instanceof Node) {            node = (Node) value;        } else if (value instanceof CrawlDatum) {            datum = (CrawlDatum) value;        }    }        if (datum != null) {        if (node != null) {                        float inlinkScore = node.getInlinkScore();            datum.setScore(inlinkScore);            LOG.debug(url + ": setting to score " + inlinkScore);        } else {                        datum.setScore(clearScore);            LOG.debug(url + ": setting to clear score of " + clearScore);        }        context.write(key, datum);    } else {        LOG.debug(url + ": no datum");    }}
6576706d70ab7b9d2515ec721c59541c38466341438fff5ea88f62f38e037e50
update
public void update(Path crawlDb, Path webGraphDb) throws IOException, ClassNotFoundException, InterruptedException
{    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    long start = System.currentTimeMillis();    LOG.info("ScoreUpdater: starting at " + sdf.format(start));    Configuration conf = getConf();        LOG.info("Running crawldb update " + crawlDb);    Path nodeDb = new Path(webGraphDb, WebGraph.NODE_DIR);    Path crawlDbCurrent = new Path(crawlDb, CrawlDb.CURRENT_NAME);    Path newCrawlDb = new Path(crawlDb, Integer.toString(new Random().nextInt(Integer.MAX_VALUE)));        Job updater = NutchJob.getInstance(conf);    updater.setJobName("Update CrawlDb from WebGraph");    FileInputFormat.addInputPath(updater, crawlDbCurrent);    FileInputFormat.addInputPath(updater, nodeDb);    FileOutputFormat.setOutputPath(updater, newCrawlDb);    updater.setInputFormatClass(SequenceFileInputFormat.class);    updater.setJarByClass(ScoreUpdater.class);    updater.setMapperClass(ScoreUpdater.ScoreUpdaterMapper.class);    updater.setReducerClass(ScoreUpdater.ScoreUpdaterReducer.class);    updater.setMapOutputKeyClass(Text.class);    updater.setMapOutputValueClass(ObjectWritable.class);    updater.setOutputKeyClass(Text.class);    updater.setOutputValueClass(CrawlDatum.class);    updater.setOutputFormatClass(MapFileOutputFormat.class);    try {        boolean success = updater.waitForCompletion(true);        if (!success) {            String message = "Update CrawlDb from WebGraph job did not succeed, job status:" + updater.getStatus().getState() + ", reason: " + updater.getStatus().getFailureInfo();            LOG.error(message);                        FileSystem fs = newCrawlDb.getFileSystem(conf);            if (fs.exists(newCrawlDb)) {                fs.delete(newCrawlDb, true);            }            throw new RuntimeException(message);        }    } catch (IOException | ClassNotFoundException | InterruptedException e) {        LOG.error("Update CrawlDb from WebGraph:", e);                FileSystem fs = newCrawlDb.getFileSystem(conf);        if (fs.exists(newCrawlDb)) {            fs.delete(newCrawlDb, true);        }        throw e;    }        LOG.info("ScoreUpdater: installing new crawldb " + crawlDb);    CrawlDb.install(updater, crawlDb);    long end = System.currentTimeMillis();    LOG.info("ScoreUpdater: finished at " + sdf.format(end) + ", elapsed: " + TimingUtil.elapsedTime(start, end));}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int res = ToolRunner.run(NutchConfiguration.create(), new ScoreUpdater(), args);    System.exit(res);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    Options options = new Options();    OptionBuilder.withArgName("help");    OptionBuilder.withDescription("show this help message");    Option helpOpts = OptionBuilder.create("help");    options.addOption(helpOpts);    OptionBuilder.withArgName("crawldb");    OptionBuilder.hasArg();    OptionBuilder.withDescription("the crawldb to use");    Option crawlDbOpts = OptionBuilder.create("crawldb");    options.addOption(crawlDbOpts);    OptionBuilder.withArgName("webgraphdb");    OptionBuilder.hasArg();    OptionBuilder.withDescription("the webgraphdb to use");    Option webGraphOpts = OptionBuilder.create("webgraphdb");    options.addOption(webGraphOpts);    CommandLineParser parser = new GnuParser();    try {        CommandLine line = parser.parse(options, args);        if (line.hasOption("help") || !line.hasOption("webgraphdb") || !line.hasOption("crawldb")) {            HelpFormatter formatter = new HelpFormatter();            formatter.printHelp("ScoreUpdater", options);            return -1;        }        String crawlDb = line.getOptionValue("crawldb");        String webGraphDb = line.getOptionValue("webgraphdb");        update(new Path(crawlDb), new Path(webGraphDb));        return 0;    } catch (Exception e) {        LOG.error("ScoreUpdater: " + StringUtils.stringifyException(e));        return -1;    }}
2a3a332dafecbd00d73092a727db8dfa3e9886fa9abf073fce073a7577f4a2b2
getFetchTime
private static long getFetchTime(ParseData data)
{        long fetchTime = System.currentTimeMillis();    String fetchTimeStr = data.getContentMeta().get(Nutch.FETCH_TIME_KEY);    try {                fetchTime = Long.parseLong(fetchTimeStr);    } catch (Exception e) {        fetchTime = System.currentTimeMillis();    }    return fetchTime;}
e11615f25423f23b12ac61fa89d714c7a78c076dbe8eedd09b15b0bddf0ecf2e
normalizeUrl
private String normalizeUrl(String url)
{    if (!normalize) {        return url;    }    String normalized = null;    if (urlNormalizers != null) {        try {                        normalized = urlNormalizers.normalize(url, URLNormalizers.SCOPE_DEFAULT);            normalized = normalized.trim();        } catch (Exception e) {            LOG.warn("Skipping " + url + ":" + e);            normalized = null;        }    }    return normalized;}
7f152217952ce86e8e79def830e6b4e82aa04772a965bc61218a81d15f64ce7d
filterUrl
private String filterUrl(String url)
{    if (!filter) {        return url;    }    try {        url = filters.filter(url);    } catch (Exception e) {        url = null;    }    return url;}
828efea1a07a16b05f247248072a0d2d0eb481455453c583f4002cb29e76342d
setup
public void setup(Mapper<Text, Writable, Text, NutchWritable>.Context context)
{    Configuration config = context.getConfiguration();    conf = config;    normalize = conf.getBoolean(URL_NORMALIZING, false);    filter = conf.getBoolean(URL_FILTERING, false);    if (normalize) {        urlNormalizers = new URLNormalizers(conf, URLNormalizers.SCOPE_DEFAULT);    }    if (filter) {        filters = new URLFilters(conf);    }}
4c9ec82e8777bee39c94eaffbd42f3bf891ce1ff9da91c3080a6b85972806e5d
map
public void map(Text key, Writable value, Context context) throws IOException, InterruptedException
{        String url = normalizeUrl(key.toString());    if (url == null) {        return;    }        if (filterUrl(url) == null) {        return;    }        key.set(url);    if (value instanceof CrawlDatum) {        CrawlDatum datum = (CrawlDatum) value;        if (datum.getStatus() == CrawlDatum.STATUS_FETCH_REDIR_TEMP || datum.getStatus() == CrawlDatum.STATUS_FETCH_REDIR_PERM || datum.getStatus() == CrawlDatum.STATUS_FETCH_GONE) {                        context.write(key, new NutchWritable(new BooleanWritable(true)));        }    } else if (value instanceof ParseData) {                        ParseData data = (ParseData) value;        long fetchTime = getFetchTime(data);        Outlink[] outlinkAr = data.getOutlinks();        Map<String, String> outlinkMap = new LinkedHashMap<>();                if (outlinkAr != null && outlinkAr.length > 0) {            for (int i = 0; i < outlinkAr.length; i++) {                Outlink outlink = outlinkAr[i];                String toUrl = normalizeUrl(outlink.getToUrl());                if (filterUrl(toUrl) == null) {                    continue;                }                                                                boolean existingUrl = outlinkMap.containsKey(toUrl);                if (toUrl != null && (!existingUrl || (existingUrl && outlinkMap.get(toUrl) == null))) {                    outlinkMap.put(toUrl, outlink.getAnchor());                }            }        }                for (String outlinkUrl : outlinkMap.keySet()) {            String anchor = outlinkMap.get(outlinkUrl);            LinkDatum datum = new LinkDatum(outlinkUrl, anchor, fetchTime);            context.write(key, new NutchWritable(datum));        }    } else if (value instanceof LinkDatum) {        LinkDatum datum = (LinkDatum) value;        String linkDatumUrl = normalizeUrl(datum.getUrl());        if (filterUrl(linkDatumUrl) != null) {            datum.setUrl(linkDatumUrl);                        context.write(key, new NutchWritable(datum));        }    }}
59bd5d9f5ddc38ec6ca1e34d842057cc0b93f1dfd1d2d8555a3085844f93e001
setup
public void setup(Reducer<Text, NutchWritable, Text, LinkDatum>.Context context)
{    Configuration config = context.getConfiguration();    conf = config;    ignoreHost = conf.getBoolean("link.ignore.internal.host", true);    ignoreDomain = conf.getBoolean("link.ignore.internal.domain", true);    limitPages = conf.getBoolean("link.ignore.limit.page", true);    limitDomains = conf.getBoolean("link.ignore.limit.domain", true);}
3a173d62b9c64632e8a5b3717dd7b139e87082c27f02e1c5ea40d48edc27b47b
reduce
public void reduce(Text key, Iterable<NutchWritable> values, Context context) throws IOException, InterruptedException
{            long mostRecent = 0L;    List<LinkDatum> outlinkList = new ArrayList<>();    for (NutchWritable val : values) {        final Writable value = val.get();        if (value instanceof LinkDatum) {                        LinkDatum next = (LinkDatum) value;            long timestamp = next.getTimestamp();            if (mostRecent == 0L || mostRecent < timestamp) {                mostRecent = timestamp;            }            outlinkList.add(WritableUtils.clone(next, conf));            context.getCounter("WebGraph.outlinks", "added links").increment(1);        } else if (value instanceof BooleanWritable) {            BooleanWritable delete = (BooleanWritable) value;                        if (delete.get() == true) {                                context.getCounter("WebGraph.outlinks", "removed links").increment(1);                return;            }        }    }        String url = key.toString();    String domain = URLUtil.getDomainName(url);    String host = URLUtil.getHost(url);        Set<String> domains = new HashSet<>();    Set<String> pages = new HashSet<>();        for (LinkDatum datum : outlinkList) {                String toUrl = datum.getUrl();        String toDomain = URLUtil.getDomainName(toUrl);        String toHost = URLUtil.getHost(toUrl);        String toPage = URLUtil.getPage(toUrl);        datum.setLinkType(LinkDatum.OUTLINK);                if (datum.getTimestamp() == mostRecent && (!limitPages || (limitPages && !pages.contains(toPage))) && (!limitDomains || (limitDomains && !domains.contains(toDomain))) && (!ignoreHost || (ignoreHost && !toHost.equalsIgnoreCase(host))) && (!ignoreDomain || (ignoreDomain && !toDomain.equalsIgnoreCase(domain)))) {            context.write(key, datum);            pages.add(toPage);            domains.add(toDomain);        }    }}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{}
74d7f8db50f09ea89642348214f53b7d2164edbc72f30375b7a19caf4f487065
setup
public void setup(Mapper<Text, LinkDatum, Text, LinkDatum>.Context context)
{    timestamp = System.currentTimeMillis();}
2bce4ef42f87c09adeb91cf1c5e94d3723182dcbb4b12616908371afdd18ae2a
map
public void map(Text key, LinkDatum datum, Context context) throws IOException, InterruptedException
{        String fromUrl = key.toString();    String toUrl = datum.getUrl();    String anchor = datum.getAnchor();        LinkDatum inlink = new LinkDatum(fromUrl, anchor, timestamp);    inlink.setLinkType(LinkDatum.INLINK);    context.write(new Text(toUrl), inlink);}
29f7636989d8eaa0429409d9903231694d07dbdc37952c30eebd4fa3bfc217b9
setup
public void setup(Reducer<Text, LinkDatum, Text, Node>.Context context)
{}
67909c5ea1d4fa7fc64a4f5d986e548aa19dc91db0aefc33ea9affbeb42750ed
reduce
public void reduce(Text key, Iterable<LinkDatum> values, Context context) throws IOException, InterruptedException
{    Node node = new Node();    int numInlinks = 0;    int numOutlinks = 0;        for (LinkDatum next : values) {        if (next.getLinkType() == LinkDatum.INLINK) {            numInlinks++;        } else if (next.getLinkType() == LinkDatum.OUTLINK) {            numOutlinks++;        }    }        node.setNumInlinks(numInlinks);    node.setNumOutlinks(numOutlinks);    node.setInlinkScore(0.0f);    context.write(key, node);}
e079c2e49dd5406721fb530719f8f51b9946eb0f8d0054b466175a733df8f353
createWebGraph
public void createWebGraph(Path webGraphDb, Path[] segments, boolean normalize, boolean filter) throws IOException, InterruptedException, ClassNotFoundException
{    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    long start = System.currentTimeMillis();    if (LOG.isInfoEnabled()) {        LOG.info("WebGraphDb: starting at " + sdf.format(start));        LOG.info("WebGraphDb: webgraphdb: " + webGraphDb);        LOG.info("WebGraphDb: URL normalize: " + normalize);        LOG.info("WebGraphDb: URL filter: " + filter);    }    FileSystem fs = webGraphDb.getFileSystem(getConf());        Path lock = new Path(webGraphDb, LOCK_NAME);    if (!fs.exists(webGraphDb)) {        fs.mkdirs(webGraphDb);    }    LockUtil.createLockFile(fs, lock, false);        Path outlinkDb = new Path(webGraphDb, OUTLINK_DIR);    Path oldOutlinkDb = new Path(webGraphDb, OLD_OUTLINK_DIR);    if (!fs.exists(outlinkDb)) {        fs.mkdirs(outlinkDb);    }    Path tempOutlinkDb = new Path(outlinkDb + "-" + Integer.toString(new Random().nextInt(Integer.MAX_VALUE)));    Job outlinkJob = NutchJob.getInstance(getConf());    Configuration outlinkJobConf = outlinkJob.getConfiguration();    outlinkJob.setJobName("Outlinkdb: " + outlinkDb);    boolean deleteGone = outlinkJobConf.getBoolean("link.delete.gone", false);    boolean preserveBackup = outlinkJobConf.getBoolean("db.preserve.backup", true);    if (deleteGone) {        LOG.info("OutlinkDb: deleting gone links");    }        if (segments != null) {        for (int i = 0; i < segments.length; i++) {            FileSystem sfs = segments[i].getFileSystem(outlinkJobConf);            Path parseData = new Path(segments[i], ParseData.DIR_NAME);            if (sfs.exists(parseData)) {                LOG.info("OutlinkDb: adding input: " + parseData);                FileInputFormat.addInputPath(outlinkJob, parseData);            }            if (deleteGone) {                Path crawlFetch = new Path(segments[i], CrawlDatum.FETCH_DIR_NAME);                if (sfs.exists(crawlFetch)) {                    LOG.info("OutlinkDb: adding input: " + crawlFetch);                    FileInputFormat.addInputPath(outlinkJob, crawlFetch);                }            }        }    }        LOG.info("OutlinkDb: adding input: " + outlinkDb);    FileInputFormat.addInputPath(outlinkJob, outlinkDb);    outlinkJobConf.setBoolean(OutlinkDb.URL_NORMALIZING, normalize);    outlinkJobConf.setBoolean(OutlinkDb.URL_FILTERING, filter);    outlinkJob.setInputFormatClass(SequenceFileInputFormat.class);    outlinkJob.setJarByClass(OutlinkDb.class);    outlinkJob.setMapperClass(OutlinkDb.OutlinkDbMapper.class);    outlinkJob.setReducerClass(OutlinkDb.OutlinkDbReducer.class);    outlinkJob.setMapOutputKeyClass(Text.class);    outlinkJob.setMapOutputValueClass(NutchWritable.class);    outlinkJob.setOutputKeyClass(Text.class);    outlinkJob.setOutputValueClass(LinkDatum.class);    FileOutputFormat.setOutputPath(outlinkJob, tempOutlinkDb);    outlinkJob.setOutputFormatClass(MapFileOutputFormat.class);    outlinkJobConf.setBoolean("mapreduce.fileoutputcommitter.marksuccessfuljobs", false);        try {        LOG.info("OutlinkDb: running");        boolean success = outlinkJob.waitForCompletion(true);        if (!success) {            String message = "OutlinkDb job did not succeed, job status:" + outlinkJob.getStatus().getState() + ", reason: " + outlinkJob.getStatus().getFailureInfo();            LOG.error(message);            NutchJob.cleanupAfterFailure(tempOutlinkDb, lock, fs);            throw new RuntimeException(message);        }        LOG.info("OutlinkDb: installing " + outlinkDb);        FSUtils.replace(fs, oldOutlinkDb, outlinkDb, true);        FSUtils.replace(fs, outlinkDb, tempOutlinkDb, true);        if (!preserveBackup && fs.exists(oldOutlinkDb))            fs.delete(oldOutlinkDb, true);        LOG.info("OutlinkDb: finished");    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error("OutlinkDb failed:", e);                NutchJob.cleanupAfterFailure(tempOutlinkDb, lock, fs);        throw e;    }        Path inlinkDb = new Path(webGraphDb, INLINK_DIR);    Path tempInlinkDb = new Path(inlinkDb + "-" + Integer.toString(new Random().nextInt(Integer.MAX_VALUE)));    Job inlinkJob = NutchJob.getInstance(getConf());    Configuration inlinkJobConf = inlinkJob.getConfiguration();    inlinkJob.setJobName("Inlinkdb " + inlinkDb);    LOG.info("InlinkDb: adding input: " + outlinkDb);    FileInputFormat.addInputPath(inlinkJob, outlinkDb);    inlinkJob.setInputFormatClass(SequenceFileInputFormat.class);    inlinkJob.setJarByClass(InlinkDb.class);    inlinkJob.setMapperClass(InlinkDb.InlinkDbMapper.class);    inlinkJob.setMapOutputKeyClass(Text.class);    inlinkJob.setMapOutputValueClass(LinkDatum.class);    inlinkJob.setOutputKeyClass(Text.class);    inlinkJob.setOutputValueClass(LinkDatum.class);    FileOutputFormat.setOutputPath(inlinkJob, tempInlinkDb);    inlinkJob.setOutputFormatClass(MapFileOutputFormat.class);    inlinkJobConf.setBoolean("mapreduce.fileoutputcommitter.marksuccessfuljobs", false);    try {                LOG.info("InlinkDb: running");        boolean success = inlinkJob.waitForCompletion(true);        if (!success) {            String message = "InlinkDb job did not succeed, job status:" + inlinkJob.getStatus().getState() + ", reason: " + inlinkJob.getStatus().getFailureInfo();            LOG.error(message);            NutchJob.cleanupAfterFailure(tempInlinkDb, lock, fs);            throw new RuntimeException(message);        }        LOG.info("InlinkDb: installing " + inlinkDb);        FSUtils.replace(fs, inlinkDb, tempInlinkDb, true);        LOG.info("InlinkDb: finished");    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error("InlinkDb failed:", e);                NutchJob.cleanupAfterFailure(tempInlinkDb, lock, fs);        throw e;    }        Path nodeDb = new Path(webGraphDb, NODE_DIR);    Path tempNodeDb = new Path(nodeDb + "-" + Integer.toString(new Random().nextInt(Integer.MAX_VALUE)));    Job nodeJob = NutchJob.getInstance(getConf());    Configuration nodeJobConf = nodeJob.getConfiguration();    nodeJob.setJobName("NodeDb " + nodeDb);    LOG.info("NodeDb: adding input: " + outlinkDb);    LOG.info("NodeDb: adding input: " + inlinkDb);    FileInputFormat.addInputPath(nodeJob, outlinkDb);    FileInputFormat.addInputPath(nodeJob, inlinkDb);    nodeJob.setInputFormatClass(SequenceFileInputFormat.class);    nodeJob.setJarByClass(NodeDb.class);    nodeJob.setReducerClass(NodeDb.NodeDbReducer.class);    nodeJob.setMapOutputKeyClass(Text.class);    nodeJob.setMapOutputValueClass(LinkDatum.class);    nodeJob.setOutputKeyClass(Text.class);    nodeJob.setOutputValueClass(Node.class);    FileOutputFormat.setOutputPath(nodeJob, tempNodeDb);    nodeJob.setOutputFormatClass(MapFileOutputFormat.class);    nodeJobConf.setBoolean("mapreduce.fileoutputcommitter.marksuccessfuljobs", false);    try {                LOG.info("NodeDb: running");        boolean success = nodeJob.waitForCompletion(true);        if (!success) {            String message = "NodeDb job did not succeed, job status:" + nodeJob.getStatus().getState() + ", reason: " + nodeJob.getStatus().getFailureInfo();            LOG.error(message);                        NutchJob.cleanupAfterFailure(tempNodeDb, lock, fs);            throw new RuntimeException(message);        }        LOG.info("NodeDb: installing " + nodeDb);        FSUtils.replace(fs, nodeDb, tempNodeDb, true);        LOG.info("NodeDb: finished");    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error("NodeDb failed:", e);                NutchJob.cleanupAfterFailure(tempNodeDb, lock, fs);        throw e;    }        LockUtil.removeLockFile(fs, lock);    long end = System.currentTimeMillis();    LOG.info("WebGraphDb: finished at " + sdf.format(end) + ", elapsed: " + TimingUtil.elapsedTime(start, end));}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int res = ToolRunner.run(NutchConfiguration.create(), new WebGraph(), args);    System.exit(res);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{        Option helpOpt = new Option("h", "help", false, "show this help message");    Option normOpt = new Option("n", "normalize", false, "whether to use URLNormalizers on the URL's in the segment");    Option filtOpt = new Option("f", "filter", false, "whether to use URLFilters on the URL's in the segment");        @SuppressWarnings("static-access")    Option graphOpt = OptionBuilder.withArgName("webgraphdb").hasArg().withDescription("the web graph database to create (if none exists) or use if one does").create("webgraphdb");    @SuppressWarnings("static-access")    Option segOpt = OptionBuilder.withArgName("segment").hasArgs().withDescription("the segment(s) to use").create("segment");    @SuppressWarnings("static-access")    Option segDirOpt = OptionBuilder.withArgName("segmentDir").hasArgs().withDescription("the segment directory to use").create("segmentDir");        Options options = new Options();    options.addOption(helpOpt);    options.addOption(normOpt);    options.addOption(filtOpt);    options.addOption(graphOpt);    options.addOption(segOpt);    options.addOption(segDirOpt);    CommandLineParser parser = new GnuParser();    try {        CommandLine line = parser.parse(options, args);        if (line.hasOption("help") || !line.hasOption("webgraphdb") || (!line.hasOption("segment") && !line.hasOption("segmentDir"))) {            HelpFormatter formatter = new HelpFormatter();            formatter.printHelp("WebGraph", options, true);            return -1;        }        String webGraphDb = line.getOptionValue("webgraphdb");        Path[] segPaths = null;                if (line.hasOption("segment")) {            String[] segments = line.getOptionValues("segment");            segPaths = new Path[segments.length];            for (int i = 0; i < segments.length; i++) {                segPaths[i] = new Path(segments[i]);            }        }                if (line.hasOption("segmentDir")) {            Path dir = new Path(line.getOptionValue("segmentDir"));            FileSystem fs = dir.getFileSystem(getConf());            FileStatus[] fstats = fs.listStatus(dir, HadoopFSUtil.getPassDirectoriesFilter(fs));            segPaths = HadoopFSUtil.getPaths(fstats);        }        boolean normalize = false;        if (line.hasOption("normalize")) {            normalize = true;        }        boolean filter = false;        if (line.hasOption("filter")) {            filter = true;        }        createWebGraph(new Path(webGraphDb), segPaths, normalize, filter);        return 0;    } catch (Exception e) {        LOG.error("WebGraph: " + StringUtils.stringifyException(e));        return -2;    }}
e4d104bee9bedfb5a9216c31d1cbffabd6729e380a6d09f049046be3a04fd8f2
getCurrentValue
public Text getCurrentValue()
{    return new Text();}
eb59369d3867061f66f8b47b2591be7079168068a6ff46e700fac22564deac0f
getCurrentKey
public Text getCurrentKey()
{    return new Text();}
e54f90c585dcdd34f8c67cbc0dd7a90e094b3a7f9e889c8d1beeae2b9a8487ce
nextKeyValue
public boolean nextKeyValue()
{    return false;}
3ab06d0195092fb2ca7f28d301fb239eef0e72a5bfae5ed8436a8037b3844295
initialize
public void initialize(InputSplit split, TaskAttemptContext context)
{}
2978830b269e5606bec8a58cd63e21e0f6b74f2387e47bc0dc0804aa0c307e60
next
public synchronized boolean next(Text key, Text value) throws IOException, InterruptedException
{        Text tKey = key;    if (!sequenceFileRecordReader.nextKeyValue()) {        return false;    }    tKey.set(innerKey.toString());    String contentAsStr = new String(innerValue.getContent());        contentAsStr = contentAsStr.replaceAll("\n", " ");    value.set(contentAsStr);    return true;}
46dc59cbf7e4d6aafe0869ef2726ed2c5c897b673d9e37f94ab9b0e962f65f7f
getProgress
public float getProgress() throws IOException
{    return sequenceFileRecordReader.getProgress();}
9b54ee9eb50c9cbdd959f0273108f77f9dc460339fff2b1de4192c511db8fe67
close
public synchronized void close() throws IOException
{    sequenceFileRecordReader.close();}
cf67357e6e62815ae8bfe95d1b19ab6540afcaefddfc72b705fe7093ae29ac18
getRecordReader
public RecordReader<Text, Text> getRecordReader(InputSplit split, Job job, Context context) throws IOException
{    context.setStatus(split.toString());    Configuration conf = job.getConfiguration();    return new ContentAsTextRecordReader(conf, (FileSplit) split);}
f116b373065c8818c62e5556713e19fc85ade68349948efcb27e0a1737ffbcc9
isIndexable
public static boolean isIndexable(Path segmentPath, FileSystem fs) throws IOException
{    if (segmentPath == null || fs == null) {        LOG.info("No segment path or filesystem set.");        return false;    }    boolean checkResult = true;    checkResult &= checkSegmentDir(segmentPath, fs);    if (checkResult) {        return true;    } else {        return false;    }}
71afdff18bf77e57f6d1d97159b7f205a277ec71eea900f596b4a5afb7d03023
checkSegmentDir
public static boolean checkSegmentDir(Path segmentPath, FileSystem fs) throws IOException
{    if (segmentPath.getName().length() != 14) {        LOG.warn("The input path at {} is not a segment... skipping", segmentPath.getName());        return false;    }    FileStatus[] fstats_segment = fs.listStatus(segmentPath, HadoopFSUtil.getPassDirectoriesFilter(fs));    Path[] segment_files = HadoopFSUtil.getPaths(fstats_segment);    boolean crawlFetchExists = false;    boolean crawlParseExists = false;    boolean parseDataExists = false;    boolean parseTextExists = false;    for (Path path : segment_files) {        String pathName = path.getName();        crawlFetchExists |= pathName.equals(CrawlDatum.FETCH_DIR_NAME);        crawlParseExists |= pathName.equals(CrawlDatum.PARSE_DIR_NAME);        parseDataExists |= pathName.equals(ParseData.DIR_NAME);        parseTextExists |= pathName.equals(ParseText.DIR_NAME);    }    if (parseTextExists && crawlParseExists && crawlFetchExists && parseDataExists) {                LOG.info("Segment dir is complete: " + segmentPath.toString() + ".");        return true;    } else {                StringBuilder missingDir = new StringBuilder("");        if (parseDataExists == false) {            missingDir.append(ParseData.DIR_NAME + ", ");        }        if (parseTextExists == false) {            missingDir.append(ParseText.DIR_NAME + ", ");        }        if (crawlParseExists == false) {            missingDir.append(CrawlDatum.PARSE_DIR_NAME + ", ");        }        if (crawlFetchExists == false) {            missingDir.append(CrawlDatum.FETCH_DIR_NAME + ", ");        }        String missingDirString = missingDir.toString();        LOG.warn("Skipping segment: " + segmentPath.toString() + ". Missing sub directories: " + missingDirString.substring(0, missingDirString.length() - 2));        return false;    }}
0371f8e90135ad7d88a1d228407c93bb8c579c4b9dfce25c0e4f66a25314a6b5
isParsed
public static boolean isParsed(Path segment, FileSystem fs) throws IOException
{    if (fs.exists(new Path(segment, CrawlDatum.PARSE_DIR_NAME))) {        return true;    }    return false;}
7240e22ba9014f9370aed219837db59960e19f81a4731b7229450d0e47243e37
filter
public boolean filter(Text key, CrawlDatum generateData, CrawlDatum fetchData, CrawlDatum sigData, Content content, ParseData parseData, ParseText parseText, Collection<CrawlDatum> linked)
{    for (SegmentMergeFilter filter : filters) {        if (!filter.filter(key, generateData, fetchData, sigData, content, parseData, parseText, linked)) {            if (LOG.isTraceEnabled())                LOG.trace("Key " + key + " dropped by " + filter.getClass().getName());            return false;        }    }    if (LOG.isTraceEnabled())        LOG.trace("Key " + key + " accepted for merge.");    return true;}
d6b855f0dc7708847456051a03efd9b0773771ca3969a95e68116ed4712ed174
createRecordReader
public RecordReader<Text, MetaWrapper> createRecordReader(final InputSplit split, TaskAttemptContext context) throws IOException
{    context.setStatus(split.toString());        SegmentPart segmentPart;    final String spString;    final FileSplit fSplit = (FileSplit) split;    try {        segmentPart = SegmentPart.get(fSplit);        spString = segmentPart.toString();    } catch (IOException e) {        throw new RuntimeException("Cannot identify segment:", e);    }    final SequenceFileRecordReader<Text, Writable> splitReader = new SequenceFileRecordReader<>();    return new SequenceFileRecordReader<Text, MetaWrapper>() {        private Text key;        private MetaWrapper wrapper;        private Writable w;        @Override        public void initialize(InputSplit split, TaskAttemptContext context) throws IOException, InterruptedException {            splitReader.initialize(split, context);        }        @Override        public synchronized boolean nextKeyValue() throws IOException, InterruptedException {            try {                boolean res = splitReader.nextKeyValue();                if (res == false) {                    return res;                }                key = splitReader.getCurrentKey();                w = splitReader.getCurrentValue();                wrapper = new MetaWrapper();                wrapper.set(w);                wrapper.setMeta(SEGMENT_PART_KEY, spString);                return res;            } catch (InterruptedException e) {                LOG.error(StringUtils.stringifyException(e));                throw e;            }        }        @Override        public Text getCurrentKey() {            return key;        }        @Override        public MetaWrapper getCurrentValue() {            return wrapper;        }        @Override        public synchronized void close() throws IOException {            splitReader.close();        }    };}
9d0cf270b93b06f7b05e0b26685b605f12e030ebd482ce0d8a319c619269541a
initialize
public void initialize(InputSplit split, TaskAttemptContext context) throws IOException, InterruptedException
{    splitReader.initialize(split, context);}
562ed48bb66934c63f3f519a75bdb6b7b52bf9b99aca8ba072e6eac1bfc1360e
nextKeyValue
public synchronized boolean nextKeyValue() throws IOException, InterruptedException
{    try {        boolean res = splitReader.nextKeyValue();        if (res == false) {            return res;        }        key = splitReader.getCurrentKey();        w = splitReader.getCurrentValue();        wrapper = new MetaWrapper();        wrapper.set(w);        wrapper.setMeta(SEGMENT_PART_KEY, spString);        return res;    } catch (InterruptedException e) {        LOG.error(StringUtils.stringifyException(e));        throw e;    }}
eb59369d3867061f66f8b47b2591be7079168068a6ff46e700fac22564deac0f
getCurrentKey
public Text getCurrentKey()
{    return key;}
c6c6b25e02415e665f1544d9d3a362eab38b3f3849ad797eaeb3b7dafbb70819
getCurrentValue
public MetaWrapper getCurrentValue()
{    return wrapper;}
9b54ee9eb50c9cbdd959f0273108f77f9dc460339fff2b1de4192c511db8fe67
close
public synchronized void close() throws IOException
{    splitReader.close();}
55ea07c015c9c5fb693ff7dfb8e362fa3a688e4e7b1f8465e0238c84805f3531
getRecordWriter
public RecordWriter<Text, MetaWrapper> getRecordWriter(TaskAttemptContext context) throws IOException
{    Configuration conf = context.getConfiguration();    String name = getUniqueFile(context, "part", "");    Path dir = FileOutputFormat.getOutputPath(context);    FileSystem fs = dir.getFileSystem(context.getConfiguration());    return new RecordWriter<Text, MetaWrapper>() {        MapFile.Writer cOut = null;        MapFile.Writer fOut = null;        MapFile.Writer pdOut = null;        MapFile.Writer ptOut = null;        SequenceFile.Writer gOut = null;        SequenceFile.Writer pOut = null;        HashMap<String, Closeable> sliceWriters = new HashMap<>();        String segmentName = conf.get("segment.merger.segmentName");        public void write(Text key, MetaWrapper wrapper) throws IOException {                        SegmentPart sp = SegmentPart.parse(wrapper.getMeta(SEGMENT_PART_KEY));            Writable o = wrapper.get();            String slice = wrapper.getMeta(SEGMENT_SLICE_KEY);            if (o instanceof CrawlDatum) {                if (sp.partName.equals(CrawlDatum.GENERATE_DIR_NAME)) {                    gOut = ensureSequenceFile(slice, CrawlDatum.GENERATE_DIR_NAME);                    gOut.append(key, o);                } else if (sp.partName.equals(CrawlDatum.FETCH_DIR_NAME)) {                    fOut = ensureMapFile(slice, CrawlDatum.FETCH_DIR_NAME, CrawlDatum.class);                    fOut.append(key, o);                } else if (sp.partName.equals(CrawlDatum.PARSE_DIR_NAME)) {                    pOut = ensureSequenceFile(slice, CrawlDatum.PARSE_DIR_NAME);                    pOut.append(key, o);                } else {                    throw new IOException("Cannot determine segment part: " + sp.partName);                }            } else if (o instanceof Content) {                cOut = ensureMapFile(slice, Content.DIR_NAME, Content.class);                cOut.append(key, o);            } else if (o instanceof ParseData) {                                if (slice == null) {                    ((ParseData) o).getContentMeta().set(Nutch.SEGMENT_NAME_KEY, segmentName);                } else {                    ((ParseData) o).getContentMeta().set(Nutch.SEGMENT_NAME_KEY, segmentName + "-" + slice);                }                pdOut = ensureMapFile(slice, ParseData.DIR_NAME, ParseData.class);                pdOut.append(key, o);            } else if (o instanceof ParseText) {                ptOut = ensureMapFile(slice, ParseText.DIR_NAME, ParseText.class);                ptOut.append(key, o);            }        }                private SequenceFile.Writer ensureSequenceFile(String slice, String dirName) throws IOException {            if (slice == null)                slice = DEFAULT_SLICE;            SequenceFile.Writer res = (SequenceFile.Writer) sliceWriters.get(slice + dirName);            if (res != null)                return res;            Path wname;            Path out = FileOutputFormat.getOutputPath(context);            if (slice == DEFAULT_SLICE) {                wname = new Path(new Path(new Path(out, segmentName), dirName), name);            } else {                wname = new Path(new Path(new Path(out, segmentName + "-" + slice), dirName), name);            }            res = SequenceFile.createWriter(conf, SequenceFile.Writer.file(wname), SequenceFile.Writer.keyClass(Text.class), SequenceFile.Writer.valueClass(CrawlDatum.class), SequenceFile.Writer.bufferSize(fs.getConf().getInt("io.file.buffer.size", 4096)), SequenceFile.Writer.replication(fs.getDefaultReplication(wname)), SequenceFile.Writer.blockSize(1073741824), SequenceFile.Writer.compression(SequenceFileOutputFormat.getOutputCompressionType(context), new DefaultCodec()), SequenceFile.Writer.progressable((Progressable) context), SequenceFile.Writer.metadata(new Metadata()));            sliceWriters.put(slice + dirName, res);            return res;        }                private MapFile.Writer ensureMapFile(String slice, String dirName, Class<? extends Writable> clazz) throws IOException {            if (slice == null)                slice = DEFAULT_SLICE;            MapFile.Writer res = (MapFile.Writer) sliceWriters.get(slice + dirName);            if (res != null)                return res;            Path wname;            Path out = FileOutputFormat.getOutputPath(context);            if (slice == DEFAULT_SLICE) {                wname = new Path(new Path(new Path(out, segmentName), dirName), name);            } else {                wname = new Path(new Path(new Path(out, segmentName + "-" + slice), dirName), name);            }            CompressionType compType = SequenceFileOutputFormat.getOutputCompressionType(context);            if (clazz.isAssignableFrom(ParseText.class)) {                compType = CompressionType.RECORD;            }            Option rKeyClassOpt = MapFile.Writer.keyClass(Text.class);            org.apache.hadoop.io.SequenceFile.Writer.Option rValClassOpt = SequenceFile.Writer.valueClass(clazz);            org.apache.hadoop.io.SequenceFile.Writer.Option rProgressOpt = SequenceFile.Writer.progressable((Progressable) context);            org.apache.hadoop.io.SequenceFile.Writer.Option rCompOpt = SequenceFile.Writer.compression(compType);            res = new MapFile.Writer(conf, wname, rKeyClassOpt, rValClassOpt, rCompOpt, rProgressOpt);            sliceWriters.put(slice + dirName, res);            return res;        }        @Override        public void close(TaskAttemptContext context) throws IOException {            Iterator<Closeable> it = sliceWriters.values().iterator();            while (it.hasNext()) {                Object o = it.next();                if (o instanceof SequenceFile.Writer) {                    ((SequenceFile.Writer) o).close();                } else {                    ((MapFile.Writer) o).close();                }            }        }    };}
a0ff6e1b339a4688e85bede4a618a72143d194b1566d78f8cad6e72af32477e1
write
public void write(Text key, MetaWrapper wrapper) throws IOException
{        SegmentPart sp = SegmentPart.parse(wrapper.getMeta(SEGMENT_PART_KEY));    Writable o = wrapper.get();    String slice = wrapper.getMeta(SEGMENT_SLICE_KEY);    if (o instanceof CrawlDatum) {        if (sp.partName.equals(CrawlDatum.GENERATE_DIR_NAME)) {            gOut = ensureSequenceFile(slice, CrawlDatum.GENERATE_DIR_NAME);            gOut.append(key, o);        } else if (sp.partName.equals(CrawlDatum.FETCH_DIR_NAME)) {            fOut = ensureMapFile(slice, CrawlDatum.FETCH_DIR_NAME, CrawlDatum.class);            fOut.append(key, o);        } else if (sp.partName.equals(CrawlDatum.PARSE_DIR_NAME)) {            pOut = ensureSequenceFile(slice, CrawlDatum.PARSE_DIR_NAME);            pOut.append(key, o);        } else {            throw new IOException("Cannot determine segment part: " + sp.partName);        }    } else if (o instanceof Content) {        cOut = ensureMapFile(slice, Content.DIR_NAME, Content.class);        cOut.append(key, o);    } else if (o instanceof ParseData) {                if (slice == null) {            ((ParseData) o).getContentMeta().set(Nutch.SEGMENT_NAME_KEY, segmentName);        } else {            ((ParseData) o).getContentMeta().set(Nutch.SEGMENT_NAME_KEY, segmentName + "-" + slice);        }        pdOut = ensureMapFile(slice, ParseData.DIR_NAME, ParseData.class);        pdOut.append(key, o);    } else if (o instanceof ParseText) {        ptOut = ensureMapFile(slice, ParseText.DIR_NAME, ParseText.class);        ptOut.append(key, o);    }}
9e2d692920a1b69e755b4848ed71f104d0c92815267f903212458018d216d802
ensureSequenceFile
private SequenceFile.Writer ensureSequenceFile(String slice, String dirName) throws IOException
{    if (slice == null)        slice = DEFAULT_SLICE;    SequenceFile.Writer res = (SequenceFile.Writer) sliceWriters.get(slice + dirName);    if (res != null)        return res;    Path wname;    Path out = FileOutputFormat.getOutputPath(context);    if (slice == DEFAULT_SLICE) {        wname = new Path(new Path(new Path(out, segmentName), dirName), name);    } else {        wname = new Path(new Path(new Path(out, segmentName + "-" + slice), dirName), name);    }    res = SequenceFile.createWriter(conf, SequenceFile.Writer.file(wname), SequenceFile.Writer.keyClass(Text.class), SequenceFile.Writer.valueClass(CrawlDatum.class), SequenceFile.Writer.bufferSize(fs.getConf().getInt("io.file.buffer.size", 4096)), SequenceFile.Writer.replication(fs.getDefaultReplication(wname)), SequenceFile.Writer.blockSize(1073741824), SequenceFile.Writer.compression(SequenceFileOutputFormat.getOutputCompressionType(context), new DefaultCodec()), SequenceFile.Writer.progressable((Progressable) context), SequenceFile.Writer.metadata(new Metadata()));    sliceWriters.put(slice + dirName, res);    return res;}
8acf011d2a8ecd2837f11ff09fddfeda8723fbccb8f189ee7da62a84dc730500
ensureMapFile
private MapFile.Writer ensureMapFile(String slice, String dirName, Class<? extends Writable> clazz) throws IOException
{    if (slice == null)        slice = DEFAULT_SLICE;    MapFile.Writer res = (MapFile.Writer) sliceWriters.get(slice + dirName);    if (res != null)        return res;    Path wname;    Path out = FileOutputFormat.getOutputPath(context);    if (slice == DEFAULT_SLICE) {        wname = new Path(new Path(new Path(out, segmentName), dirName), name);    } else {        wname = new Path(new Path(new Path(out, segmentName + "-" + slice), dirName), name);    }    CompressionType compType = SequenceFileOutputFormat.getOutputCompressionType(context);    if (clazz.isAssignableFrom(ParseText.class)) {        compType = CompressionType.RECORD;    }    Option rKeyClassOpt = MapFile.Writer.keyClass(Text.class);    org.apache.hadoop.io.SequenceFile.Writer.Option rValClassOpt = SequenceFile.Writer.valueClass(clazz);    org.apache.hadoop.io.SequenceFile.Writer.Option rProgressOpt = SequenceFile.Writer.progressable((Progressable) context);    org.apache.hadoop.io.SequenceFile.Writer.Option rCompOpt = SequenceFile.Writer.compression(compType);    res = new MapFile.Writer(conf, wname, rKeyClassOpt, rValClassOpt, rCompOpt, rProgressOpt);    sliceWriters.put(slice + dirName, res);    return res;}
118202e50c9711dbea3c9045d10f01c58e2fd2ce631f1eb50a35dad80b983835
close
public void close(TaskAttemptContext context) throws IOException
{    Iterator<Closeable> it = sliceWriters.values().iterator();    while (it.hasNext()) {        Object o = it.next();        if (o instanceof SequenceFile.Writer) {            ((SequenceFile.Writer) o).close();        } else {            ((MapFile.Writer) o).close();        }    }}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    super.setConf(conf);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{}
0ed9b58ab1646319cf5b36e3de9c2eb0f8c0de3605ae3a32e8b55c584bfd149b
setup
public void setup(Mapper<Text, MetaWrapper, Text, MetaWrapper>.Context context)
{    Configuration conf = context.getConfiguration();    if (conf.getBoolean("segment.merger.filter", false)) {        filters = new URLFilters(conf);    }    if (conf.getBoolean("segment.merger.normalizer", false))        normalizers = new URLNormalizers(conf, URLNormalizers.SCOPE_DEFAULT);}
0cf54c28d5fa2aedab3bc95282f9a2b63dde93abba25273722bf0b5de888e2e0
map
public void map(Text key, MetaWrapper value, Context context) throws IOException, InterruptedException
{    Text newKey = new Text();    String url = key.toString();    if (normalizers != null) {        try {                        url = normalizers.normalize(url, URLNormalizers.SCOPE_DEFAULT);        } catch (Exception e) {            LOG.warn("Skipping {} : {}", url, e.getMessage());            url = null;        }    }    if (url != null && filters != null) {        try {            url = filters.filter(url);        } catch (Exception e) {            LOG.warn("Skipping key {} : {}", url, e.getMessage());            url = null;        }    }    if (url != null) {        newKey.set(url);        context.write(newKey, value);    }}
0dab3932c28b4dce08de4b41b6d8f53b3e497607e0247b3511e9198677ed3095
setup
public void setup(Reducer<Text, MetaWrapper, Text, MetaWrapper>.Context context)
{    Configuration conf = context.getConfiguration();    if (conf.getBoolean("segment.merger.filter", false)) {        mergeFilters = new SegmentMergeFilters(conf);    }    sliceSize = conf.getLong("segment.merger.slice", -1);    if ((sliceSize > 0) && (LOG.isInfoEnabled())) {        LOG.info("Slice size: {} URLs.", sliceSize);    }    if (sliceSize > 0) {        sliceSize = sliceSize / Integer.parseInt(conf.get("mapreduce.job.reduces"));    }}
176837ec7ca7a15ddaa1e240e99eba971a582dd688160abc6a6317fad52a3f9e
reduce
public void reduce(Text key, Iterable<MetaWrapper> values, Context context) throws IOException, InterruptedException
{    CrawlDatum lastG = null;    CrawlDatum lastF = null;    CrawlDatum lastSig = null;    Content lastC = null;    ParseData lastPD = null;    ParseText lastPT = null;    String lastGname = null;    String lastFname = null;    String lastSigname = null;    String lastCname = null;    String lastPDname = null;    String lastPTname = null;    TreeMap<String, ArrayList<CrawlDatum>> linked = new TreeMap<>();    for (MetaWrapper wrapper : values) {        Object o = wrapper.get();        String spString = wrapper.getMeta(SEGMENT_PART_KEY);        if (spString == null) {            throw new IOException("Null segment part, key=" + key);        }        SegmentPart sp = SegmentPart.parse(spString);        if (o instanceof CrawlDatum) {            CrawlDatum val = (CrawlDatum) o;                        if (sp.partName.equals(CrawlDatum.GENERATE_DIR_NAME)) {                if (lastG == null) {                    lastG = val;                    lastGname = sp.segmentName;                } else {                                        if (lastGname.compareTo(sp.segmentName) < 0) {                        lastG = val;                        lastGname = sp.segmentName;                    }                }            } else if (sp.partName.equals(CrawlDatum.FETCH_DIR_NAME)) {                                if (CrawlDatum.hasFetchStatus(val) && val.getStatus() != CrawlDatum.STATUS_FETCH_RETRY && val.getStatus() != CrawlDatum.STATUS_FETCH_NOTMODIFIED) {                    if (lastF == null) {                        lastF = val;                        lastFname = sp.segmentName;                    } else {                        if (lastFname.compareTo(sp.segmentName) < 0) {                            lastF = val;                            lastFname = sp.segmentName;                        }                    }                }            } else if (sp.partName.equals(CrawlDatum.PARSE_DIR_NAME)) {                if (val.getStatus() == CrawlDatum.STATUS_SIGNATURE) {                    if (lastSig == null) {                        lastSig = val;                        lastSigname = sp.segmentName;                    } else {                                                if (lastSigname.compareTo(sp.segmentName) < 0) {                            lastSig = val;                            lastSigname = sp.segmentName;                        }                    }                    continue;                }                                ArrayList<CrawlDatum> segLinked = linked.get(sp.segmentName);                if (segLinked == null) {                    segLinked = new ArrayList<>();                    linked.put(sp.segmentName, segLinked);                }                segLinked.add(val);            } else {                throw new IOException("Cannot determine segment part: " + sp.partName);            }        } else if (o instanceof Content) {            if (lastC == null) {                lastC = (Content) o;                lastCname = sp.segmentName;            } else {                if (lastCname.compareTo(sp.segmentName) < 0) {                    lastC = (Content) o;                    lastCname = sp.segmentName;                }            }        } else if (o instanceof ParseData) {            if (lastPD == null) {                lastPD = (ParseData) o;                lastPDname = sp.segmentName;            } else {                if (lastPDname.compareTo(sp.segmentName) < 0) {                    lastPD = (ParseData) o;                    lastPDname = sp.segmentName;                }            }        } else if (o instanceof ParseText) {            if (lastPT == null) {                lastPT = (ParseText) o;                lastPTname = sp.segmentName;            } else {                if (lastPTname.compareTo(sp.segmentName) < 0) {                    lastPT = (ParseText) o;                    lastPTname = sp.segmentName;                }            }        }    }        if (mergeFilters != null && !mergeFilters.filter(key, lastG, lastF, lastSig, lastC, lastPD, lastPT, linked.isEmpty() ? null : linked.lastEntry().getValue())) {        return;    }    curCount++;    String sliceName;    MetaWrapper wrapper = new MetaWrapper();    if (sliceSize > 0) {        sliceName = String.valueOf(curCount / sliceSize);        wrapper.setMeta(SEGMENT_SLICE_KEY, sliceName);    }    SegmentPart sp = new SegmentPart();        if (lastG != null) {        wrapper.set(lastG);        sp.partName = CrawlDatum.GENERATE_DIR_NAME;        sp.segmentName = lastGname;        wrapper.setMeta(SEGMENT_PART_KEY, sp.toString());        context.write(key, wrapper);    }    if (lastF != null) {        wrapper.set(lastF);        sp.partName = CrawlDatum.FETCH_DIR_NAME;        sp.segmentName = lastFname;        wrapper.setMeta(SEGMENT_PART_KEY, sp.toString());        context.write(key, wrapper);    }    if (lastSig != null) {        wrapper.set(lastSig);        sp.partName = CrawlDatum.PARSE_DIR_NAME;        sp.segmentName = lastSigname;        wrapper.setMeta(SEGMENT_PART_KEY, sp.toString());        context.write(key, wrapper);    }    if (lastC != null) {        wrapper.set(lastC);        sp.partName = Content.DIR_NAME;        sp.segmentName = lastCname;        wrapper.setMeta(SEGMENT_PART_KEY, sp.toString());        context.write(key, wrapper);    }    if (lastPD != null) {        wrapper.set(lastPD);        sp.partName = ParseData.DIR_NAME;        sp.segmentName = lastPDname;        wrapper.setMeta(SEGMENT_PART_KEY, sp.toString());        context.write(key, wrapper);    }    if (lastPT != null) {        wrapper.set(lastPT);        sp.partName = ParseText.DIR_NAME;        sp.segmentName = lastPTname;        wrapper.setMeta(SEGMENT_PART_KEY, sp.toString());        context.write(key, wrapper);    }    if (linked.size() > 0) {        String name = linked.lastKey();        sp.partName = CrawlDatum.PARSE_DIR_NAME;        sp.segmentName = name;        wrapper.setMeta(SEGMENT_PART_KEY, sp.toString());        ArrayList<CrawlDatum> segLinked = linked.get(name);        for (int i = 0; i < segLinked.size(); i++) {            CrawlDatum link = segLinked.get(i);            wrapper.set(link);            context.write(key, wrapper);        }    }}
3d4c15638c69f8bbd14096a85088c2c6b6c5a325d24ca1869eb58cbb47434c50
merge
public void merge(Path out, Path[] segs, boolean filter, boolean normalize, long slice) throws IOException, ClassNotFoundException, InterruptedException
{    String segmentName = Generator.generateSegmentName();    if (LOG.isInfoEnabled()) {        LOG.info("Merging {} segments to {}/{}", segs.length, out, segmentName);    }    Job job = NutchJob.getInstance(getConf());    Configuration conf = job.getConfiguration();    job.setJobName("mergesegs " + out + "/" + segmentName);    conf.setBoolean("segment.merger.filter", filter);    conf.setBoolean("segment.merger.normalizer", normalize);    conf.setLong("segment.merger.slice", slice);    conf.set("segment.merger.segmentName", segmentName);        boolean g = true;    boolean f = true;    boolean p = true;    boolean c = true;    boolean pd = true;    boolean pt = true;        boolean pg = true;    boolean pf = true;    boolean pp = true;    boolean pc = true;    boolean ppd = true;    boolean ppt = true;    for (int i = 0; i < segs.length; i++) {        FileSystem fs = segs[i].getFileSystem(conf);        if (!fs.exists(segs[i])) {            if (LOG.isWarnEnabled()) {                LOG.warn("Input dir {} doesn't exist, skipping.", segs[i]);            }            segs[i] = null;            continue;        }        if (LOG.isInfoEnabled()) {            LOG.info("SegmentMerger:   adding {}", segs[i]);        }        Path cDir = new Path(segs[i], Content.DIR_NAME);        Path gDir = new Path(segs[i], CrawlDatum.GENERATE_DIR_NAME);        Path fDir = new Path(segs[i], CrawlDatum.FETCH_DIR_NAME);        Path pDir = new Path(segs[i], CrawlDatum.PARSE_DIR_NAME);        Path pdDir = new Path(segs[i], ParseData.DIR_NAME);        Path ptDir = new Path(segs[i], ParseText.DIR_NAME);        c = c && fs.exists(cDir);        g = g && fs.exists(gDir);        f = f && fs.exists(fDir);        p = p && fs.exists(pDir);        pd = pd && fs.exists(pdDir);        pt = pt && fs.exists(ptDir);                if (g != pg || f != pf || p != pp || c != pc || pd != ppd || pt != ppt) {            LOG.info("{} changed input dirs", segs[i]);        }        pg = g;        pf = f;        pp = p;        pc = c;        ppd = pd;        ppt = pt;    }    StringBuilder sb = new StringBuilder();    if (c)        sb.append(" " + Content.DIR_NAME);    if (g)        sb.append(" " + CrawlDatum.GENERATE_DIR_NAME);    if (f)        sb.append(" " + CrawlDatum.FETCH_DIR_NAME);    if (p)        sb.append(" " + CrawlDatum.PARSE_DIR_NAME);    if (pd)        sb.append(" " + ParseData.DIR_NAME);    if (pt)        sb.append(" " + ParseText.DIR_NAME);    if (LOG.isInfoEnabled()) {        LOG.info("SegmentMerger: using segment data from: {}", sb.toString());    }    for (int i = 0; i < segs.length; i++) {        if (segs[i] == null)            continue;        if (g) {            Path gDir = new Path(segs[i], CrawlDatum.GENERATE_DIR_NAME);            FileInputFormat.addInputPath(job, gDir);        }        if (c) {            Path cDir = new Path(segs[i], Content.DIR_NAME);            FileInputFormat.addInputPath(job, cDir);        }        if (f) {            Path fDir = new Path(segs[i], CrawlDatum.FETCH_DIR_NAME);            FileInputFormat.addInputPath(job, fDir);        }        if (p) {            Path pDir = new Path(segs[i], CrawlDatum.PARSE_DIR_NAME);            FileInputFormat.addInputPath(job, pDir);        }        if (pd) {            Path pdDir = new Path(segs[i], ParseData.DIR_NAME);            FileInputFormat.addInputPath(job, pdDir);        }        if (pt) {            Path ptDir = new Path(segs[i], ParseText.DIR_NAME);            FileInputFormat.addInputPath(job, ptDir);        }    }    job.setInputFormatClass(ObjectInputFormat.class);    job.setJarByClass(SegmentMerger.class);    job.setMapperClass(SegmentMerger.SegmentMergerMapper.class);    job.setReducerClass(SegmentMerger.SegmentMergerReducer.class);    FileOutputFormat.setOutputPath(job, out);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(MetaWrapper.class);    job.setOutputFormatClass(SegmentOutputFormat.class);    setConf(conf);    try {        boolean success = job.waitForCompletion(true);        if (!success) {            String message = "SegmentMerger job did not succeed, job status:" + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);            throw new RuntimeException(message);        }    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error("SegmentMerger job failed: {}", e.getMessage());        throw e;    }}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    if (args.length < 2) {        System.err.println("SegmentMerger output_dir (-dir segments | seg1 seg2 ...) [-filter] [-slice NNNN]");        System.err.println("\toutput_dir\tname of the parent dir for output segment slice(s)");        System.err.println("\t-dir segments\tparent dir containing several segments");        System.err.println("\tseg1 seg2 ...\tlist of segment dirs");        System.err.println("\t-filter\t\tfilter out URL-s prohibited by current URLFilters");        System.err.println("\t-normalize\t\tnormalize URL via current URLNormalizers");        System.err.println("\t-slice NNNN\tcreate many output segments, each containing NNNN URLs");        return -1;    }    Configuration conf = NutchConfiguration.create();    Path out = new Path(args[0]);    ArrayList<Path> segs = new ArrayList<>();    long sliceSize = 0;    boolean filter = false;    boolean normalize = false;    for (int i = 1; i < args.length; i++) {        if ("-dir".equals(args[i])) {            Path dirPath = new Path(args[++i]);            FileSystem fs = dirPath.getFileSystem(conf);            FileStatus[] fstats = fs.listStatus(dirPath, HadoopFSUtil.getPassDirectoriesFilter(fs));            Path[] files = HadoopFSUtil.getPaths(fstats);            for (int j = 0; j < files.length; j++) segs.add(files[j]);        } else if ("-filter".equals(args[i])) {            filter = true;        } else if ("-normalize".equals(args[i])) {            normalize = true;        } else if ("-slice".equals(args[i])) {            sliceSize = Long.parseLong(args[++i]);        } else {            segs.add(new Path(args[i]));        }    }    if (segs.isEmpty()) {        System.err.println("ERROR: No input segments.");        return -1;    }    merge(out, segs.toArray(new Path[segs.size()]), filter, normalize, sliceSize);    return 0;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int result = ToolRunner.run(NutchConfiguration.create(), new SegmentMerger(), args);    System.exit(result);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return segmentName + "/" + partName;}
3903d81e515d8f06a53d8f865069d3d7a8f679f3498dbad68a5e1e4ea973c84e
get
public static SegmentPart get(FileSplit split) throws IOException
{    return get(split.getPath().toString());}
3ba4b99ebb18d575887ff027b62c9c3c2e35b7538373b79a2917c20d7e5931a2
get
public static SegmentPart get(String path) throws IOException
{        String dir = path.replace('\\', '/');    int idx = dir.lastIndexOf("/part-");    if (idx == -1) {        throw new IOException("Cannot determine segment part: " + dir);    }    dir = dir.substring(0, idx);    idx = dir.lastIndexOf('/');    if (idx == -1) {        throw new IOException("Cannot determine segment part: " + dir);    }    String part = dir.substring(idx + 1);        dir = dir.substring(0, idx);    idx = dir.lastIndexOf('/');    if (idx == -1) {        throw new IOException("Cannot determine segment name: " + dir);    }    String segment = dir.substring(idx + 1);    return new SegmentPart(segment, part);}
7a6aa9b4cb1532b8330edc70bba4bffe86fc39f2f474d07aec68774300bdcbe6
parse
public static SegmentPart parse(String string) throws IOException
{    int idx = string.indexOf('/');    if (idx == -1) {        throw new IOException("Invalid SegmentPart: '" + string + "'");    }    String segment = string.substring(0, idx);    String part = string.substring(idx + 1);    return new SegmentPart(segment, part);}
d7fe40a4727ffeae003ffe9c01ab2cc455f4eeb8a63448f93d94a9fc4a22a779
map
public void map(WritableComparable<?> key, Writable value, Context context) throws IOException, InterruptedException
{        if (key instanceof Text) {        newKey.set(key.toString());        key = newKey;    }    context.write((Text) key, new NutchWritable(value));}
fbb6fa16d85e5471ca1c27786a1251834b51a98f8c17782a6224fe898242e600
getRecordWriter
public RecordWriter<WritableComparable<?>, Writable> getRecordWriter(TaskAttemptContext context) throws IOException, InterruptedException
{    String name = getUniqueFile(context, "part", "");    Path dir = FileOutputFormat.getOutputPath(context);    FileSystem fs = dir.getFileSystem(context.getConfiguration());    final Path segmentDumpFile = new Path(FileOutputFormat.getOutputPath(context), name);        if (fs.exists(segmentDumpFile))        fs.delete(segmentDumpFile, true);    final PrintStream printStream = new PrintStream(fs.create(segmentDumpFile), false, StandardCharsets.UTF_8.name());    return new RecordWriter<WritableComparable<?>, Writable>() {        public synchronized void write(WritableComparable<?> key, Writable value) throws IOException {            printStream.println(value);        }        public synchronized void close(TaskAttemptContext context) throws IOException {            printStream.close();        }    };}
fbf3993a2f124dfb97aa059774c7a6a3945f8b87cdbe599694f5d0d08d05cfc4
write
public synchronized void write(WritableComparable<?> key, Writable value) throws IOException
{    printStream.println(value);}
f42b50fb7405fe3efd4bb24b63737025e0636e50456f86048e6f0d55a98a39c6
close
public synchronized void close(TaskAttemptContext context) throws IOException
{    printStream.close();}
54a6656c898c07ec3ef653fc744e6fd5fbcdb2382df9faa3d4927b22c6104639
setup
public void setup(Job job)
{    Configuration conf = job.getConfiguration();    this.co = conf.getBoolean("segment.reader.co", true);    this.fe = conf.getBoolean("segment.reader.fe", true);    this.ge = conf.getBoolean("segment.reader.ge", true);    this.pa = conf.getBoolean("segment.reader.pa", true);    this.pd = conf.getBoolean("segment.reader.pd", true);    this.pt = conf.getBoolean("segment.reader.pt", true);}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{}
3a173d62b9c64632e8a5b3717dd7b139e87082c27f02e1c5ea40d48edc27b47b
reduce
public void reduce(Text key, Iterable<NutchWritable> values, Context context) throws IOException, InterruptedException
{    StringBuffer dump = new StringBuffer();    dump.append("\nRecno:: ").append(recNo++).append("\n");    dump.append("URL:: " + key.toString() + "\n");    for (NutchWritable val : values) {                Writable value = val.get();        if (value instanceof CrawlDatum) {            dump.append("\nCrawlDatum::\n").append(((CrawlDatum) value).toString());        } else if (value instanceof Content) {            dump.append("\nContent::\n").append(((Content) value).toString());        } else if (value instanceof ParseData) {            dump.append("\nParseData::\n").append(((ParseData) value).toString());        } else if (value instanceof ParseText) {            dump.append("\nParseText::\n").append(((ParseText) value).toString());        } else if (LOG.isWarnEnabled()) {            LOG.warn("Unrecognized type: " + value.getClass());        }    }    context.write(key, new Text(dump.toString()));}
bc4388551ca3090447e8a1b83c1bc6ccbf7190a6e6e44e83a37c77945b195284
dump
public void dump(Path segment, Path output) throws IOException, InterruptedException, ClassNotFoundException
{    if (LOG.isInfoEnabled()) {        LOG.info("SegmentReader: dump segment: " + segment);    }    Job job = Job.getInstance();    job.setJobName("read " + segment);    Configuration conf = job.getConfiguration();    if (ge)        FileInputFormat.addInputPath(job, new Path(segment, CrawlDatum.GENERATE_DIR_NAME));    if (fe)        FileInputFormat.addInputPath(job, new Path(segment, CrawlDatum.FETCH_DIR_NAME));    if (pa)        FileInputFormat.addInputPath(job, new Path(segment, CrawlDatum.PARSE_DIR_NAME));    if (co)        FileInputFormat.addInputPath(job, new Path(segment, Content.DIR_NAME));    if (pd)        FileInputFormat.addInputPath(job, new Path(segment, ParseData.DIR_NAME));    if (pt)        FileInputFormat.addInputPath(job, new Path(segment, ParseText.DIR_NAME));    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setMapperClass(InputCompatMapper.class);    job.setReducerClass(InputCompatReducer.class);    job.setJarByClass(SegmentReader.class);    Path tempDir = new Path(conf.get("hadoop.tmp.dir", "/tmp") + "/segread-" + new java.util.Random().nextInt());    FileSystem fs = tempDir.getFileSystem(conf);    fs.delete(tempDir, true);    FileOutputFormat.setOutputPath(job, tempDir);    job.setOutputFormatClass(TextOutputFormat.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(NutchWritable.class);    try {        boolean success = job.waitForCompletion(true);        if (!success) {            String message = "SegmentReader job did not succeed, job status:" + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);            throw new RuntimeException(message);        }    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error(StringUtils.stringifyException(e));        throw e;    }        Path dumpFile = new Path(output, conf.get("segment.dump.dir", "dump"));    FileSystem outFs = dumpFile.getFileSystem(conf);        outFs.delete(dumpFile, true);    FileStatus[] fstats = fs.listStatus(tempDir, HadoopFSUtil.getPassAllFilter());    Path[] files = HadoopFSUtil.getPaths(fstats);    int currentRecordNumber = 0;    if (files.length > 0) {        try (PrintWriter writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outFs.create(dumpFile), StandardCharsets.UTF_8)))) {            for (int i = 0; i < files.length; i++) {                Path partFile = files[i];                try {                    currentRecordNumber = append(fs, conf, partFile, writer, currentRecordNumber);                } catch (IOException exception) {                    if (LOG.isWarnEnabled()) {                        LOG.warn("Couldn't copy the content of " + partFile.toString() + " into " + dumpFile.toString());                        LOG.warn(exception.getMessage());                    }                }            }        }    }    fs.delete(tempDir, true);    if (LOG.isInfoEnabled()) {        LOG.info("SegmentReader: done");    }}
43c34267aa0c6ebd748eff23924b62b5427993dc1944e91480a6c95ad35a9b8e
append
private int append(FileSystem fs, Configuration conf, Path src, PrintWriter writer, int currentRecordNumber) throws IOException
{    try (BufferedReader reader = new BufferedReader(new InputStreamReader(fs.open(src), StandardCharsets.UTF_8))) {        String line = reader.readLine();        while (line != null) {            if (line.startsWith("Recno:: ")) {                line = "Recno:: " + currentRecordNumber++;            }            writer.println(line);            line = reader.readLine();        }        return currentRecordNumber;    }}
5e4f92ec8b4962723b950655b39274c1073f6dd8dfe4f67da2727497eb37ea35
get
public void get(final Path segment, final Text key, Writer writer, final Map<String, List<Writable>> results) throws Exception
{    LOG.info("SegmentReader: get '" + key + "'");    ArrayList<Thread> threads = new ArrayList<>();    if (co)        threads.add(new Thread() {            public void run() {                try {                    List<Writable> res = getMapRecords(new Path(segment, Content.DIR_NAME), key);                    results.put("co", res);                } catch (Exception e) {                    LOG.error("Exception:", e);                }            }        });    if (fe)        threads.add(new Thread() {            public void run() {                try {                    List<Writable> res = getMapRecords(new Path(segment, CrawlDatum.FETCH_DIR_NAME), key);                    results.put("fe", res);                } catch (Exception e) {                    LOG.error("Exception:", e);                }            }        });    if (ge)        threads.add(new Thread() {            public void run() {                try {                    List<Writable> res = getSeqRecords(new Path(segment, CrawlDatum.GENERATE_DIR_NAME), key);                    results.put("ge", res);                } catch (Exception e) {                    LOG.error("Exception:", e);                }            }        });    if (pa)        threads.add(new Thread() {            public void run() {                try {                    List<Writable> res = getSeqRecords(new Path(segment, CrawlDatum.PARSE_DIR_NAME), key);                    results.put("pa", res);                } catch (Exception e) {                    LOG.error("Exception:", e);                }            }        });    if (pd)        threads.add(new Thread() {            public void run() {                try {                    List<Writable> res = getMapRecords(new Path(segment, ParseData.DIR_NAME), key);                    results.put("pd", res);                } catch (Exception e) {                    LOG.error("Exception:", e);                }            }        });    if (pt)        threads.add(new Thread() {            public void run() {                try {                    List<Writable> res = getMapRecords(new Path(segment, ParseText.DIR_NAME), key);                    results.put("pt", res);                } catch (Exception e) {                    LOG.error("Exception:", e);                }            }        });    Iterator<Thread> it = threads.iterator();    while (it.hasNext()) it.next().start();    int cnt;    do {        cnt = 0;        try {            Thread.sleep(5000);        } catch (Exception e) {        }        ;        it = threads.iterator();        while (it.hasNext()) {            if (it.next().isAlive())                cnt++;        }        if ((cnt > 0) && (LOG.isDebugEnabled())) {            LOG.debug("(" + cnt + " to retrieve)");        }    } while (cnt > 0);    for (int i = 0; i < keys.length; i++) {        List<Writable> res = results.get(keys[i][0]);        if (res != null && res.size() > 0) {            for (int k = 0; k < res.size(); k++) {                writer.write(keys[i][1]);                writer.write(res.get(k) + "\n");            }        }        writer.flush();    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        List<Writable> res = getMapRecords(new Path(segment, Content.DIR_NAME), key);        results.put("co", res);    } catch (Exception e) {        LOG.error("Exception:", e);    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        List<Writable> res = getMapRecords(new Path(segment, CrawlDatum.FETCH_DIR_NAME), key);        results.put("fe", res);    } catch (Exception e) {        LOG.error("Exception:", e);    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        List<Writable> res = getSeqRecords(new Path(segment, CrawlDatum.GENERATE_DIR_NAME), key);        results.put("ge", res);    } catch (Exception e) {        LOG.error("Exception:", e);    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        List<Writable> res = getSeqRecords(new Path(segment, CrawlDatum.PARSE_DIR_NAME), key);        results.put("pa", res);    } catch (Exception e) {        LOG.error("Exception:", e);    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        List<Writable> res = getMapRecords(new Path(segment, ParseData.DIR_NAME), key);        results.put("pd", res);    } catch (Exception e) {        LOG.error("Exception:", e);    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        List<Writable> res = getMapRecords(new Path(segment, ParseText.DIR_NAME), key);        results.put("pt", res);    } catch (Exception e) {        LOG.error("Exception:", e);    }}
76d359c0a394f10b6619c1822b2322ad8e9fb138dbfc66d5cc1decfa2691ad6b
getMapRecords
private List<Writable> getMapRecords(Path dir, Text key) throws Exception
{    MapFile.Reader[] readers = MapFileOutputFormat.getReaders(dir, getConf());    ArrayList<Writable> res = new ArrayList<>();    Class<?> keyClass = readers[0].getKeyClass();    Class<?> valueClass = readers[0].getValueClass();    if (!keyClass.getName().equals("org.apache.hadoop.io.Text"))        throw new IOException("Incompatible key (" + keyClass.getName() + ")");    Writable value = (Writable) valueClass.getConstructor().newInstance();        for (int i = 0; i < readers.length; i++) {        if (readers[i].get(key, value) != null) {            res.add(value);            value = (Writable) valueClass.getConstructor().newInstance();            Text aKey = (Text) keyClass.getConstructor().newInstance();            while (readers[i].next(aKey, value) && aKey.equals(key)) {                res.add(value);                value = (Writable) valueClass.getConstructor().newInstance();            }        }        readers[i].close();    }    return res;}
cd379a0903f6239016e9f1f3176c19a99d7fdf4c5024a13c177d8fc74aa0728f
getSeqRecords
private List<Writable> getSeqRecords(Path dir, Text key) throws Exception
{    SequenceFile.Reader[] readers = org.apache.hadoop.mapred.SequenceFileOutputFormat.getReaders(getConf(), dir);    ArrayList<Writable> res = new ArrayList<>();    Class<?> keyClass = readers[0].getKeyClass();    Class<?> valueClass = readers[0].getValueClass();    if (!keyClass.getName().equals("org.apache.hadoop.io.Text"))        throw new IOException("Incompatible key (" + keyClass.getName() + ")");    WritableComparable<?> aKey = (WritableComparable<?>) keyClass.getConstructor().newInstance();    Writable value = (Writable) valueClass.getConstructor().newInstance();    for (int i = 0; i < readers.length; i++) {        while (readers[i].next(aKey, value)) {            if (aKey.equals(key)) {                res.add(value);                value = (Writable) valueClass.getConstructor().newInstance();            }        }        readers[i].close();    }    return res;}
6649401c2bb68f47f3e72739d55e6f4c95ba1fb276129de5fe6da70ca1ca5cf5
list
public void list(List<Path> dirs, Writer writer) throws Exception
{    writer.write("NAME\t\tGENERATED\tFETCHER START\t\tFETCHER END\t\tFETCHED\tPARSED\n");    for (int i = 0; i < dirs.size(); i++) {        Path dir = dirs.get(i);        SegmentReaderStats stats = new SegmentReaderStats();        getStats(dir, stats);        writer.write(dir.getName() + "\t");        if (stats.generated == -1)            writer.write("?");        else            writer.write(stats.generated + "");        writer.write("\t\t");        if (stats.start == -1)            writer.write("?\t");        else            writer.write(sdf.format(new Date(stats.start)));        writer.write("\t");        if (stats.end == -1)            writer.write("?");        else            writer.write(sdf.format(new Date(stats.end)));        writer.write("\t");        if (stats.fetched == -1)            writer.write("?");        else            writer.write(stats.fetched + "");        writer.write("\t");        if (stats.parsed == -1)            writer.write("?");        else            writer.write(stats.parsed + "");        writer.write("\n");        writer.flush();    }}
b4f54455f28eb58cb6997cc23247c3764d0e0d9fa63051598aafc85b9e1b6713
getStats
public void getStats(Path segment, final SegmentReaderStats stats) throws Exception
{    long cnt = 0L;    Text key = new Text();    CrawlDatum val = new CrawlDatum();    FileSystem fs = segment.getFileSystem(getConf());    if (ge) {        SequenceFile.Reader[] readers = SegmentReaderUtil.getReaders(new Path(segment, CrawlDatum.GENERATE_DIR_NAME), getConf());        for (int i = 0; i < readers.length; i++) {            while (readers[i].next(key, val)) cnt++;            readers[i].close();        }        stats.generated = cnt;    }    if (fe) {        Path fetchDir = new Path(segment, CrawlDatum.FETCH_DIR_NAME);        if (fs.exists(fetchDir) && fs.getFileStatus(fetchDir).isDirectory()) {            cnt = 0L;            long start = Long.MAX_VALUE;            long end = Long.MIN_VALUE;            CrawlDatum value = new CrawlDatum();            MapFile.Reader[] mreaders = MapFileOutputFormat.getReaders(fetchDir, getConf());            for (int i = 0; i < mreaders.length; i++) {                while (mreaders[i].next(key, value)) {                    cnt++;                    if (value.getFetchTime() < start)                        start = value.getFetchTime();                    if (value.getFetchTime() > end)                        end = value.getFetchTime();                }                mreaders[i].close();            }            stats.start = start;            stats.end = end;            stats.fetched = cnt;        }    }    if (pd) {        Path parseDir = new Path(segment, ParseData.DIR_NAME);        if (fs.exists(parseDir) && fs.getFileStatus(parseDir).isDirectory()) {            cnt = 0L;            long errors = 0L;            ParseData value = new ParseData();            MapFile.Reader[] mreaders = MapFileOutputFormat.getReaders(parseDir, getConf());            for (int i = 0; i < mreaders.length; i++) {                while (mreaders[i].next(key, value)) {                    cnt++;                    if (!value.getStatus().isSuccess())                        errors++;                }                mreaders[i].close();            }            stats.parsed = cnt;            stats.parseErrors = errors;        }    }}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    if (args.length < 2) {        usage();        return -1;    }    int mode = -1;    if (args[0].equals("-dump"))        mode = MODE_DUMP;    else if (args[0].equals("-list"))        mode = MODE_LIST;    else if (args[0].equals("-get"))        mode = MODE_GET;    boolean co = true;    boolean fe = true;    boolean ge = true;    boolean pa = true;    boolean pd = true;    boolean pt = true;        for (int i = 1; i < args.length; i++) {        if (args[i].equals("-nocontent")) {            co = false;            args[i] = null;        } else if (args[i].equals("-nofetch")) {            fe = false;            args[i] = null;        } else if (args[i].equals("-nogenerate")) {            ge = false;            args[i] = null;        } else if (args[i].equals("-noparse")) {            pa = false;            args[i] = null;        } else if (args[i].equals("-noparsedata")) {            pd = false;            args[i] = null;        } else if (args[i].equals("-noparsetext")) {            pt = false;            args[i] = null;        }    }    Configuration conf = NutchConfiguration.create();    SegmentReader segmentReader = new SegmentReader(conf, co, fe, ge, pa, pd, pt);        switch(mode) {        case MODE_DUMP:            this.co = co;            this.fe = fe;            this.ge = ge;            this.pa = pa;            this.pd = pd;            this.pt = pt;            String input = args[1];            if (input == null) {                System.err.println("Missing required argument: <segment_dir>");                usage();                return -1;            }            String output = args.length > 2 ? args[2] : null;            if (output == null) {                System.err.println("Missing required argument: <output>");                usage();                return -1;            }            dump(new Path(input), new Path(output));            return 0;        case MODE_LIST:            ArrayList<Path> dirs = new ArrayList<>();            for (int i = 1; i < args.length; i++) {                if (args[i] == null)                    continue;                if (args[i].equals("-dir")) {                    Path dir = new Path(args[++i]);                    FileSystem fs = dir.getFileSystem(conf);                    FileStatus[] fstats = fs.listStatus(dir, HadoopFSUtil.getPassDirectoriesFilter(fs));                    Path[] files = HadoopFSUtil.getPaths(fstats);                    if (files != null && files.length > 0) {                        dirs.addAll(Arrays.asList(files));                    }                } else                    dirs.add(new Path(args[i]));            }            segmentReader.list(dirs, new OutputStreamWriter(System.out, StandardCharsets.UTF_8));            return 0;        case MODE_GET:            input = args[1];            if (input == null) {                System.err.println("Missing required argument: <segment_dir>");                usage();                return -1;            }            String key = args.length > 2 ? args[2] : null;            if (key == null) {                System.err.println("Missing required argument: <keyValue>");                usage();                return -1;            }            segmentReader.get(new Path(input), new Text(key), new OutputStreamWriter(System.out, StandardCharsets.UTF_8), new HashMap<>());            return 0;        default:            System.err.println("Invalid operation: " + args[0]);            usage();            return -1;    }}
6c655505072f20944de454aea0c62e0c64dc3a771527717e8ff71d825b651203
usage
private static void usage()
{    System.err.println("Usage: SegmentReader (-dump ... | -list ... | -get ...) [general options]\n");    System.err.println("* General options:");    System.err.println("\t-nocontent\tignore content directory");    System.err.println("\t-nofetch\tignore crawl_fetch directory");    System.err.println("\t-nogenerate\tignore crawl_generate directory");    System.err.println("\t-noparse\tignore crawl_parse directory");    System.err.println("\t-noparsedata\tignore parse_data directory");    System.err.println("\t-noparsetext\tignore parse_text directory");    System.err.println();    System.err.println("* SegmentReader -dump <segment_dir> <output> [general options]");    System.err.println("  Dumps content of a <segment_dir> as a text file to <output>.\n");    System.err.println("\t<segment_dir>\tname of the segment directory.");    System.err.println("\t<output>\tname of the (non-existent) output directory.");    System.err.println();    System.err.println("* SegmentReader -list (<segment_dir1> ... | -dir <segments>) [general options]");    System.err.println("  List a synopsis of segments in specified directories, or all segments in");    System.err.println("  a directory <segments>, and print it on System.out\n");    System.err.println("\t<segment_dir1> ...\tlist of segment directories to process");    System.err.println("\t-dir <segments>\t\tdirectory that contains multiple segments");    System.err.println();    System.err.println("* SegmentReader -get <segment_dir> <keyValue> [general options]");    System.err.println("  Get a specified record from a segment, and print it on System.out.\n");    System.err.println("\t<segment_dir>\tname of the segment directory.");    System.err.println("\t<keyValue>\tvalue of the key (url).");    System.err.println("\t\tNote: put double-quotes around strings with spaces.");}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int result = ToolRunner.run(NutchConfiguration.create(), new SegmentReader(), args);    System.exit(result);}
36b8d0e8d74544c475c90df1017edd7493396ed6feb9bd3b8dcc5e88301a5188
get
public Configuration get(String confId)
{    if (confId == null) {        return configurations.get(ConfigResource.DEFAULT);    }    return configurations.get(confId);}
e08cf225a44cc0500cf09d43be328d2f584b4ad9e1d8c09502f6fb781f1117ab
getAsMap
public Map<String, String> getAsMap(String confId)
{    Configuration configuration = configurations.get(confId);    if (configuration == null) {        return Collections.emptyMap();    }    Iterator<Entry<String, String>> iterator = configuration.iterator();    Map<String, String> configMap = Maps.newTreeMap();    while (iterator.hasNext()) {        Entry<String, String> entry = iterator.next();        configMap.put(entry.getKey(), entry.getValue());    }    return configMap;}
ecdebc3e31b799d11ba65862bda4fdcd3cf18fcff646520fd2e5778727a85533
setProperty
public void setProperty(String confId, String propName, String propValue)
{    if (!configurations.containsKey(confId)) {        throw new IllegalArgumentException("Unknown configId '" + confId + "'");    }    Configuration conf = configurations.get(confId);    conf.set(propName, propValue);}
31aae17eddcb84ab0bc58cf54e62e510d59b6772842fc25cb9bf8233cb9eb8d9
list
public Set<String> list()
{    return configurations.keySet();}
0a5e9f200d69bfb5ba95441528155376d9c1f5e6a44d1134a1f5736c87fe1a2c
create
public String create(NutchConfig nutchConfig)
{    if (StringUtils.isBlank(nutchConfig.getConfigId())) {        nutchConfig.setConfigId(String.valueOf(newConfigId.incrementAndGet()));    }    if (!canCreate(nutchConfig)) {        throw new IllegalArgumentException("Config already exists.");    }    createHadoopConfig(nutchConfig);    return nutchConfig.getConfigId();}
d8dd72ed149b356c19b726295fb447a48efabdbaae1a5bdad4d53197eab2cb53
delete
public void delete(String confId)
{    configurations.remove(confId);}
22bd47e410625fa1bb404d428a43faf93e219790a470e796616622f1b52ad074
canCreate
private boolean canCreate(NutchConfig nutchConfig)
{    if (nutchConfig.isForce()) {        return true;    }    if (!configurations.containsKey(nutchConfig.getConfigId())) {        return true;    }    return false;}
e9f39951adf99a42aa1cc08096a20cf820a1d93970f5df2fea689a3b6f823b08
createHadoopConfig
private void createHadoopConfig(NutchConfig nutchConfig)
{    Configuration conf = NutchConfiguration.create();    configurations.put(nutchConfig.getConfigId(), conf);    if (MapUtils.isEmpty(nutchConfig.getParams())) {        return;    }    for (Entry<String, String> e : nutchConfig.getParams().entrySet()) {        conf.set(e.getKey(), e.getValue());    }}
b0cf379453550900377f8d9cfc8e95889974a36d40db4e396b6d8819637c78cf
createToolByType
public NutchTool createToolByType(JobType type, Configuration conf)
{    if (!typeToClass.containsKey(type)) {        return null;    }    Class<? extends NutchTool> clz = typeToClass.get(type);    return createTool(clz, conf);}
5c8ca52d2ddb1e7f8442ac214cb7831fe7ab7e3c85adec45dc93201d7d62dfaf
createToolByClassName
public NutchTool createToolByClassName(String className, Configuration conf)
{    try {        Class clz = Class.forName(className);        return createTool(clz, conf);    } catch (ClassNotFoundException e) {        throw new IllegalStateException(e);    }}
5531f9acaa84fe20dbacbddbdf23953e4c48fc854fd2a9265f5e695ecb0278d4
createTool
private NutchTool createTool(Class<? extends NutchTool> clz, Configuration conf)
{    return ReflectionUtils.newInstance(clz, conf);}
0872076b74a931b1637b5dc7e7fcc07a519d76ab793da2ff28f5e1f32224265c
create
public JobInfo create(JobConfig jobConfig)
{    if (jobConfig.getArgs() == null) {        throw new IllegalArgumentException("Arguments cannot be null!");    }    Configuration conf = cloneConfiguration(jobConfig.getConfId());    NutchTool tool = createTool(jobConfig, conf);    JobWorker worker = new JobWorker(jobConfig, conf, tool);    executor.execute(worker);    executor.purge();    return worker.getInfo();}
b51f11c0469917ede467f8369821c68d874666a84465ce5c22423a7cdfa9ce01
cloneConfiguration
private Configuration cloneConfiguration(String confId)
{    Configuration conf = configManager.get(confId);    if (conf == null) {        throw new IllegalArgumentException("Unknown confId " + confId);    }    return new Configuration(conf);}
a53234ba01ea4adccb7e6e95733d240cbce7400b3323bf56a48f4aec0d76cc9e
list
public Collection<JobInfo> list(String crawlId, State state)
{    if (state == null || state == State.ANY) {        return executor.getAllJobs();    }    if (state == State.RUNNING || state == State.IDLE) {        return executor.getJobRunning();    }    return executor.getJobHistory();}
9927884cb85e43752f3cd5c7ea770d088b9fd9814c56581971178f49e5f92c7b
get
public JobInfo get(String crawlId, String jobId)
{    return executor.getInfo(jobId);}
d31e437086bde38e54eb2946829e0544bbe18cf1a4b3239e8847bb6e36d9a112
abort
public boolean abort(String crawlId, String id)
{    return executor.findWorker(id).killJob();}
5eef917e5f4749c084a9808aded5b415340f4cac4d50791ab40fbdd9c3406aeb
stop
public boolean stop(String crawlId, String id)
{    return executor.findWorker(id).stopJob();}
79d3f96f6bd939bcecf70e4cd4397e6d4ca1ef86227fae2a24f8b3a50d9e36c4
createTool
private NutchTool createTool(JobConfig jobConfig, Configuration conf)
{    if (StringUtils.isNotBlank(jobConfig.getJobClassName())) {        return jobFactory.createToolByClassName(jobConfig.getJobClassName(), conf);    }    return jobFactory.createToolByType(jobConfig.getType(), conf);}
9bd05d5f7796877fc830b42e1e86dfe3aa845b4174b3cad8b05266c788e91fb0
generateId
private String generateId()
{    if (jobConfig.getCrawlId() == null) {        return MessageFormat.format("{0}-{1}-{2}", jobConfig.getConfId(), jobConfig.getType(), String.valueOf(hashCode()));    }    return MessageFormat.format("{0}-{1}-{2}-{3}", jobConfig.getCrawlId(), jobConfig.getConfId(), jobConfig.getType(), String.valueOf(hashCode()));}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        getInfo().setState(State.RUNNING);        getInfo().setMsg("OK");        getInfo().setResult(tool.run(getInfo().getArgs(), getInfo().getCrawlId()));        getInfo().setState(State.FINISHED);    } catch (Exception e) {        LOG.error("Cannot run job worker!", e);        getInfo().setMsg("ERROR: " + e.toString());        getInfo().setState(State.FAILED);    }}
2ee1df5f2b3f6a6b0ce1831cb8d83775f65a0cbce89e8be0e8eef084aaa5b59c
getInfo
public JobInfo getInfo()
{    return jobInfo;}
229444c959c9e7c2c866ae288f5b3c1a26f3a392593e2f10c6d5b6f58d1b948d
stopJob
public boolean stopJob()
{    getInfo().setState(State.STOPPING);    try {        return tool.stopJob();    } catch (Exception e) {        throw new RuntimeException("Cannot stop job with id " + getInfo().getId(), e);    }}
ef52dabb72c4cb010d19a70c2a598efc720a6b459edde768b2635f34747af503
killJob
public boolean killJob()
{    getInfo().setState(State.KILLING);    try {        boolean result = tool.killJob();        getInfo().setState(State.KILLED);        return result;    } catch (Exception e) {        throw new RuntimeException("Cannot kill job with id " + getInfo().getId(), e);    }}
ab001f1acf346e0f743ea41ba07bee92a2142d7940957a3d25255b07b4e44590
setInfo
public void setInfo(JobInfo jobInfo)
{    this.jobInfo = jobInfo;}
2d5cc6062b587f5b810af6cda9c6e49282ab102deda834e153667d02d4bed6e9
read
public List read(String path) throws FileNotFoundException
{    List<HashMap> rows = new ArrayList<>();    Path file = new Path(path);    SequenceFile.Reader reader;    try {        reader = new SequenceFile.Reader(conf, Reader.file(file));        Writable key = (Writable) ReflectionUtils.newInstance(reader.getKeyClass(), conf);        LinkDatum value = new LinkDatum();        while (reader.next(key, value)) {            try {                HashMap<String, String> t_row = getLinksRow(key, value);                rows.add(t_row);            } catch (Exception e) {            }        }        reader.close();    } catch (FileNotFoundException fne) {        throw new FileNotFoundException();    } catch (IOException e) {        e.printStackTrace();        LOG.error("Error occurred while reading file {} : {}", file, StringUtils.stringifyException(e));        throw new WebApplicationException();    }    return rows;}
b7b171c529bbe9d3e5aa57d9c759c1cb69f40a4cdf851ac068ab367c6de32d87
head
public List head(String path, int nrows) throws FileNotFoundException
{    List<HashMap> rows = new ArrayList<>();    Path file = new Path(path);    SequenceFile.Reader reader;    try {        reader = new SequenceFile.Reader(conf, Reader.file(file));        Writable key = (Writable) ReflectionUtils.newInstance(reader.getKeyClass(), conf);        LinkDatum value = new LinkDatum();        int i = 0;        while (reader.next(key, value) && i < nrows) {            HashMap<String, String> t_row = getLinksRow(key, value);            rows.add(t_row);            i++;        }        reader.close();    } catch (FileNotFoundException fne) {        throw new FileNotFoundException();    } catch (IOException e) {        e.printStackTrace();        LOG.error("Error occurred while reading file {} : {}", file, StringUtils.stringifyException(e));        throw new WebApplicationException();    }    return rows;}
495c08c4ff75e254f32fe01d78b718e51dc815cbeaaf8f6f2733f8360d08fb0f
slice
public List slice(String path, int start, int end) throws FileNotFoundException
{    List<HashMap> rows = new ArrayList<>();    Path file = new Path(path);    SequenceFile.Reader reader;    try {        reader = new SequenceFile.Reader(conf, Reader.file(file));        Writable key = (Writable) ReflectionUtils.newInstance(reader.getKeyClass(), conf);        LinkDatum value = new LinkDatum();        int i = 0;                for (; i < start && reader.next(key, value); i++) {        }        while (reader.next(key, value) && i < end) {            HashMap<String, String> t_row = getLinksRow(key, value);            rows.add(t_row);            i++;        }        reader.close();    } catch (FileNotFoundException fne) {        throw new FileNotFoundException();    } catch (IOException e) {        e.printStackTrace();        LOG.error("Error occurred while reading file {} : {}", file, StringUtils.stringifyException(e));        throw new WebApplicationException();    }    return rows;}
235aa15be0fff955584fc37db0f4f90f54e2b943d3f9e37e2bc1ef37e312e024
count
public int count(String path) throws FileNotFoundException
{    Path file = new Path(path);    SequenceFile.Reader reader;    int i = 0;    try {        reader = new SequenceFile.Reader(conf, Reader.file(file));        Writable key = (Writable) ReflectionUtils.newInstance(reader.getKeyClass(), conf);        Writable value = (Writable) ReflectionUtils.newInstance(reader.getValueClass(), conf);        while (reader.next(key, value)) {            i++;        }        reader.close();    } catch (FileNotFoundException fne) {        throw new FileNotFoundException();    } catch (IOException e) {        LOG.error("Error occurred while reading file {} : {}", file, StringUtils.stringifyException(e));        throw new WebApplicationException();    }    return i;}
3c2de017f13e50de3869e86ec4999e82dfc5de605f76b2f0f9da058cdbf301db
getLinksRow
private HashMap<String, String> getLinksRow(Writable key, LinkDatum value)
{    HashMap<String, String> tRow = new HashMap<>();    tRow.put("key_url", key.toString());    tRow.put("url", value.getUrl());    tRow.put("anchor", value.getAnchor());    tRow.put("score", String.valueOf(value.getScore()));    tRow.put("timestamp", String.valueOf(value.getTimestamp()));    tRow.put("linktype", String.valueOf(value.getLinkType()));    return tRow;}
2d5cc6062b587f5b810af6cda9c6e49282ab102deda834e153667d02d4bed6e9
read
public List read(String path) throws FileNotFoundException
{    List<HashMap> rows = new ArrayList<>();    Path file = new Path(path);    SequenceFile.Reader reader;    try {        reader = new SequenceFile.Reader(conf, Reader.file(file));        Writable key = (Writable) ReflectionUtils.newInstance(reader.getKeyClass(), conf);        Node value = new Node();        while (reader.next(key, value)) {            try {                HashMap<String, String> t_row = getNodeRow(key, value);                rows.add(t_row);            } catch (Exception e) {            }        }        reader.close();    } catch (FileNotFoundException fne) {        throw new FileNotFoundException();    } catch (IOException e) {        e.printStackTrace();        LOG.error("Error occurred while reading file {} : {}", file, StringUtils.stringifyException(e));        throw new WebApplicationException();    }    return rows;}
b7b171c529bbe9d3e5aa57d9c759c1cb69f40a4cdf851ac068ab367c6de32d87
head
public List head(String path, int nrows) throws FileNotFoundException
{    List<HashMap> rows = new ArrayList<>();    Path file = new Path(path);    SequenceFile.Reader reader;    try {        reader = new SequenceFile.Reader(conf, Reader.file(file));        Writable key = (Writable) ReflectionUtils.newInstance(reader.getKeyClass(), conf);        Node value = new Node();        int i = 0;        while (reader.next(key, value) && i < nrows) {            HashMap<String, String> t_row = getNodeRow(key, value);            rows.add(t_row);            i++;        }        reader.close();    } catch (FileNotFoundException fne) {        throw new FileNotFoundException();    } catch (IOException e) {        e.printStackTrace();        LOG.error("Error occurred while reading file {} : {}", file, StringUtils.stringifyException(e));        throw new WebApplicationException();    }    return rows;}
495c08c4ff75e254f32fe01d78b718e51dc815cbeaaf8f6f2733f8360d08fb0f
slice
public List slice(String path, int start, int end) throws FileNotFoundException
{    List<HashMap> rows = new ArrayList<>();    Path file = new Path(path);    SequenceFile.Reader reader;    try {        reader = new SequenceFile.Reader(conf, Reader.file(file));        Writable key = (Writable) ReflectionUtils.newInstance(reader.getKeyClass(), conf);        Node value = new Node();        int i = 0;                for (; i < start && reader.next(key, value); i++) {        }        while (reader.next(key, value) && i < end) {            HashMap<String, String> t_row = getNodeRow(key, value);            rows.add(t_row);            i++;        }        reader.close();    } catch (FileNotFoundException fne) {        throw new FileNotFoundException();    } catch (IOException e) {        e.printStackTrace();        LOG.error("Error occurred while reading file {} : {}", file, StringUtils.stringifyException(e));        throw new WebApplicationException();    }    return rows;}
235aa15be0fff955584fc37db0f4f90f54e2b943d3f9e37e2bc1ef37e312e024
count
public int count(String path) throws FileNotFoundException
{    Path file = new Path(path);    SequenceFile.Reader reader;    int i = 0;    try {        reader = new SequenceFile.Reader(conf, Reader.file(file));        Writable key = (Writable) ReflectionUtils.newInstance(reader.getKeyClass(), conf);        Node value = new Node();        while (reader.next(key, value)) {            i++;        }        reader.close();    } catch (FileNotFoundException fne) {        throw new FileNotFoundException();    } catch (IOException e) {        e.printStackTrace();        LOG.error("Error occurred while reading file {} : {}", file, StringUtils.stringifyException(e));        throw new WebApplicationException();    }    return i;}
f6ba9cb6566143753e0db2f4a2a3b6486d547b75e41a51a83419c46160a5f93a
getNodeRow
private HashMap<String, String> getNodeRow(Writable key, Node value)
{    HashMap<String, String> tRow = new HashMap<>();    tRow.put("key_url", key.toString());    tRow.put("num_inlinks", String.valueOf(value.getNumInlinks()));    tRow.put("num_outlinks", String.valueOf(value.getNumOutlinks()));    tRow.put("inlink_score", String.valueOf(value.getInlinkScore()));    tRow.put("outlink_score", String.valueOf(value.getOutlinkScore()));    tRow.put("metadata", value.getMetadata().toString());    return tRow;}
16f8d1ac914597e6b0ed88685d71e0a1e15a311d6b1b37e027a070e9301de720
beforeExecute
protected void beforeExecute(Thread thread, Runnable runnable)
{    super.beforeExecute(thread, runnable);    synchronized (runningWorkers) {        runningWorkers.offer(((JobWorker) runnable));    }}
945c2c3c22f5530db86e5ac22db0ed6cea2186fae83a235542633248fa785187
afterExecute
protected void afterExecute(Runnable runnable, Throwable throwable)
{    super.afterExecute(runnable, throwable);    synchronized (runningWorkers) {        runningWorkers.remove((JobWorker) runnable);    }    JobWorker worker = ((JobWorker) runnable);    addStatusToHistory(worker);}
33bd670117fcc4468cb7a8ef0fc88fe0283fbfa89c1a2b17ede8a7259438d2fe
addStatusToHistory
private void addStatusToHistory(JobWorker worker)
{    synchronized (workersHistory) {        if (!workersHistory.offer(worker)) {            workersHistory.poll();            workersHistory.add(worker);        }    }}
e38771f7a63279fb481d29cb61997f04407271d22d89e256c33a5ffddc9e9f4b
findWorker
public JobWorker findWorker(String jobId)
{    synchronized (runningWorkers) {        for (JobWorker worker : runningWorkers) {            if (StringUtils.equals(worker.getInfo().getId(), jobId)) {                return worker;            }        }    }    return null;}
5ef88bd1075009987d2abb2b4613eeaafba4e9c269a9f58623d9253e9c2d8419
getJobHistory
public Collection<JobInfo> getJobHistory()
{    return getJobsInfo(workersHistory);}
fe53f9e6db178999d8351f8e032fd2f0d5ccb0ee0c08f639fb38d6651397baa0
getJobRunning
public Collection<JobInfo> getJobRunning()
{    return getJobsInfo(runningWorkers);}
4c6fbde67b2f6ef9a8702cde23cb9d6f114223cf87b8910652c06933094a848d
getAllJobs
public Collection<JobInfo> getAllJobs()
{    return CollectionUtils.union(getJobRunning(), getJobHistory());}
fdd6f33ef6684cebd31b7fba67060102b5415bee863c6581e24ad06fcaede7a9
getJobsInfo
private Collection<JobInfo> getJobsInfo(Collection<JobWorker> workers)
{    List<JobInfo> jobsInfo = Lists.newLinkedList();    for (JobWorker worker : workers) {        jobsInfo.add(worker.getInfo());    }    return jobsInfo;}
f9778a4e2f922772e9925fef386b9ba1f8194adaa0baba5cc1fcc9b23c6a1f9e
getInfo
public JobInfo getInfo(String jobId)
{    for (JobInfo jobInfo : getAllJobs()) {        if (StringUtils.equals(jobId, jobInfo.getId())) {            return jobInfo;        }    }    return null;}
56e21c78c7a964334ab4c46435b5996f3f5d815f993bce42bb97c0a9d59a1ebd
getSeedList
public SeedList getSeedList(String seedName)
{    if (seeds.containsKey(seedName)) {        return seeds.get(seedName);    } else        return null;}
9b24f97bdfce892b69f28cc5db92a903c417bc502b59cabaabb570272cdc2522
setSeedList
public void setSeedList(String seedName, SeedList seedList)
{    seeds.put(seedName, seedList);}
99a66b40f656c976b0a9768e34243d0f214ff0a9fa7acfdb3256c526327f033d
getSeeds
public Map<String, SeedList> getSeeds()
{    return seeds;}
bd5213bf1d94a2638e6cb17c0502e367ad6199dfd981bc9791f094adce46fa51
deleteSeedList
public boolean deleteSeedList(String seedName)
{    if (seeds.containsKey(seedName)) {        seeds.remove(seedName);        return true;    } else        return false;}
73d1c8a3f1467fef43b65603208bd4b53d00ebf4eacdc5cb3be539345747c287
read
public List<List<String>> read(String path) throws FileNotFoundException
{        List<List<String>> rows = new ArrayList<>();    Path file = new Path(path);    SequenceFile.Reader reader;    try {        reader = new SequenceFile.Reader(conf, Reader.file(file));        Writable key = (Writable) ReflectionUtils.newInstance(reader.getKeyClass(), conf);        Writable value = (Writable) ReflectionUtils.newInstance(reader.getValueClass(), conf);        while (reader.next(key, value)) {            List<String> row = new ArrayList<>();            row.add(key.toString());            row.add(value.toString());            rows.add(row);        }        reader.close();    } catch (FileNotFoundException fne) {        throw new FileNotFoundException();    } catch (IOException e) {                e.printStackTrace();        LOG.error("Error occurred while reading file {} : {}", file, StringUtils.stringifyException(e));        throw new WebApplicationException();    }    return rows;}
69faf6bc5d39ecc4b08466993932301af9f07a4845da1c7c80d82afcdb52e6a7
head
public List<List<String>> head(String path, int nrows) throws FileNotFoundException
{        List<List<String>> rows = new ArrayList<>();    Path file = new Path(path);    SequenceFile.Reader reader;    try {        reader = new SequenceFile.Reader(conf, Reader.file(file));        Writable key = (Writable) ReflectionUtils.newInstance(reader.getKeyClass(), conf);        Writable value = (Writable) ReflectionUtils.newInstance(reader.getValueClass(), conf);        int i = 0;        while (reader.next(key, value) && i < nrows) {            List<String> row = new ArrayList<>();            row.add(key.toString());            row.add(value.toString());            rows.add(row);            i++;        }        reader.close();    } catch (FileNotFoundException fne) {        throw new FileNotFoundException();    } catch (IOException e) {                LOG.error("Error occurred while reading file {} : {}", file, StringUtils.stringifyException(e));        throw new WebApplicationException();    }    return rows;}
a980dfd96aaf4636579b4326437df7056dbbd6bd1ae4f024735b4b76e022668d
slice
public List<List<String>> slice(String path, int start, int end) throws FileNotFoundException
{    List<List<String>> rows = new ArrayList<>();    Path file = new Path(path);    SequenceFile.Reader reader;    try {        reader = new SequenceFile.Reader(conf, Reader.file(file));        Writable key = (Writable) ReflectionUtils.newInstance(reader.getKeyClass(), conf);        Writable value = (Writable) ReflectionUtils.newInstance(reader.getValueClass(), conf);        int i = 0;                for (; i < start && reader.next(key, value); i++) {        }        while (reader.next(key, value) && i < end) {            List<String> row = new ArrayList<>();            row.add(key.toString());            row.add(value.toString());            rows.add(row);            i++;        }        reader.close();    } catch (FileNotFoundException fne) {        throw new FileNotFoundException();    } catch (IOException e) {                LOG.error("Error occurred while reading file {} : {}", file, StringUtils.stringifyException(e));        throw new WebApplicationException();    }    return rows;}
235aa15be0fff955584fc37db0f4f90f54e2b943d3f9e37e2bc1ef37e312e024
count
public int count(String path) throws FileNotFoundException
{    Path file = new Path(path);    SequenceFile.Reader reader;    int i = 0;    try {        reader = new SequenceFile.Reader(conf, Reader.file(file));        Writable key = (Writable) ReflectionUtils.newInstance(reader.getKeyClass(), conf);        Writable value = (Writable) ReflectionUtils.newInstance(reader.getValueClass(), conf);        while (reader.next(key, value)) {            i++;        }        reader.close();    } catch (FileNotFoundException fne) {        throw new FileNotFoundException();    } catch (IOException e) {                LOG.error("Error occurred while reading file {} : {}", file, StringUtils.stringifyException(e));        throw new WebApplicationException();    }    return i;}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        tool.run(serviceConfig.getArgs(), serviceConfig.getCrawlId());    } catch (Exception e) {                LOG.error("Error running service worker : {}", StringUtils.stringifyException(e));    }}
d726d439acbb486b0bcc34ef94adc962f6a73fd68ff1149a7e31aaa8c58d0a42
getConfId
public String getConfId()
{    return confId;}
1d6e336afe4461fa7024c33fec9b59f98a177447f3975354c8db4ff0e39931a3
setConfId
public void setConfId(String confId)
{    this.confId = confId;}
6d6b5d566a007c2dac6db36d21e025c67e2cb381eae7e19ddb59541d1e07afbf
getArgs
public Map<String, String> getArgs()
{    return args;}
7b0edd9d4ede8d70062a9dfb1425c58865a1ba402f1b91a52db852966f59a0db
setArgs
public void setArgs(Map<String, String> args)
{    this.args = args;}
624f725337dde847c4a699397a02f1b5558c709c88374adb10e603d835f48c88
getType
public String getType()
{    return type;}
8ab53042064bb8f4e31355121ce5a5ccc6f3b8e9227cceb605ae26d51b21bddd
setType
public void setType(String type)
{    this.type = type;}
b7482d498c7b22fc604b0b48eb53a91e8ead98ec6e3f7cc14a3a793cd7fe10f5
getCrawlId
public String getCrawlId()
{    return crawlId;}
ccbfead7f316723a5f535c4a186c2e469b383dfa2da2301e832c8fe94ff39f8c
setCrawlId
public void setCrawlId(String crawlId)
{    this.crawlId = crawlId;}
b7482d498c7b22fc604b0b48eb53a91e8ead98ec6e3f7cc14a3a793cd7fe10f5
getCrawlId
public String getCrawlId()
{    return crawlId;}
ccbfead7f316723a5f535c4a186c2e469b383dfa2da2301e832c8fe94ff39f8c
setCrawlId
public void setCrawlId(String crawlId)
{    this.crawlId = crawlId;}
4cbb3c04c2494e74cfd1e91b057fb4f4f8e88e55c6ec5fb363e683d40e015632
getType
public JobType getType()
{    return type;}
a451ec17772a76e4e462aa1698a67c082b8b23faf4a02917e56b03f25700dda8
setType
public void setType(JobType type)
{    this.type = type;}
d726d439acbb486b0bcc34ef94adc962f6a73fd68ff1149a7e31aaa8c58d0a42
getConfId
public String getConfId()
{    return confId;}
1d6e336afe4461fa7024c33fec9b59f98a177447f3975354c8db4ff0e39931a3
setConfId
public void setConfId(String confId)
{    this.confId = confId;}
b89f717d1c2ccf000ae99377b7c8ddb5164d7e6a8cc65662a01c3271ccb9352c
getArgs
public Map<String, Object> getArgs()
{    return args;}
1f52953b823b923cf7c59ae2d932cfb4b2d828b1a01e63cdb2685bd7abec655d
setArgs
public void setArgs(Map<String, Object> args)
{    this.args = args;}
a87ca441585fc8ea037fb5ca01a0d223c81219d837acae14f1417d5f53dcf33b
getJobClassName
public String getJobClassName()
{    return jobClassName;}
120b3e2af60cf29a690ac934713ef6651a55dadf8a5ee014bd6f30de0828af8c
setJobClassName
public void setJobClassName(String jobClass)
{    this.jobClassName = jobClass;}
b99a57a667be2220ce63e71d2d71787b18dbeba85c101f40604dc0a847bb1469
getParams
public Map<String, String> getParams()
{    return params;}
5a81c725a428f6a960f0b8f2a8afee85f878dfbf313f7f43c5fac142bd8c31ac
setParams
public void setParams(Map<String, String> params)
{    this.params = params;}
55a5683b09dff619d378eee339dadb9ff70b54646f437f3c2bad137ba965ea6d
getConfigId
public String getConfigId()
{    return configId;}
29e9bd8fb379800312ca1d4b3dee0c75ec36d8372d727142a9661e9e5b95e1ae
setConfigId
public void setConfigId(String configId)
{    this.configId = configId;}
c5f7c19b3e53a75d9efff00555003fd50c371af2aa66f0f68b4abdb918b43f3f
isForce
public boolean isForce()
{    return force;}
093a23608c3f52987289dde6033a6dfc780b1569f791caa0eae287db7c8b8798
setForce
public void setForce(boolean force)
{    this.force = force;}
58e7b527ecd5014eaf5f30fc9c50ba33e1f005f8ce9d24246253d62377788662
getPath
public String getPath()
{    return path;}
de663c4293dc7b4649bc9588c013d3f165ef1bdb800ee63172ba8730f7b71d91
setPath
public void setPath(String path)
{    this.path = path;}
f734c2eebae9a730cc7699b15559fb359d3fde242fc8d95d883eb6e678db260e
getId
public Long getId()
{    return id;}
f244308ce1625e52b4f2d91f9d304d40b50af7d199f0957560887f734910fbdf
setId
public void setId(Long id)
{    this.id = id;}
06c160d2c24eb06ff7b9488c400a6ca3f696309f70dcc8157ef409bdb19e4ac1
getSeedUrls
public Collection<SeedUrl> getSeedUrls()
{    return seedUrls;}
9bd7d75bc9343faf37d83de812f75afa2b1ec476e356cad23e6aa4072ed92aa2
setSeedUrls
public void setSeedUrls(Collection<SeedUrl> seedUrls)
{    this.seedUrls = seedUrls;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
f498f22eaf0816bf385a43365651d1b6d0455905fdd2d6be01ceefeb84e8f432
setName
public void setName(String name)
{    this.name = name;}
cdb15c0af9d5817743c99e7fd45c348ea576dd715b4806dcb32653cd206213e3
getSeedFilePath
public String getSeedFilePath()
{    return seedFilePath;}
99ac269fae3f5b81099c2562c837059ab69af50e5b78b1b59a4e5ba91d053e37
setSeedFilePath
public void setSeedFilePath(String seedFilePath)
{    this.seedFilePath = seedFilePath;}
6a44a4ae854f746e7b745357cc2ae29e96fe72eb7734d967383f4d4553552eca
getSeedUrlsCount
public int getSeedUrlsCount()
{    if (CollectionUtils.isEmpty(seedUrls)) {        return 0;    }    return seedUrls.size();}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    final int prime = 31;    int result = 1;    result = prime * result + ((id == null) ? 0 : id.hashCode());    return result;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj)        return true;    if (obj == null)        return false;    if (getClass() != obj.getClass())        return false;    SeedList other = (SeedList) obj;    if (id == null) {        if (other.id != null)            return false;    } else if (!id.equals(other.id))        return false;    return true;}
f734c2eebae9a730cc7699b15559fb359d3fde242fc8d95d883eb6e678db260e
getId
public Long getId()
{    return id;}
f244308ce1625e52b4f2d91f9d304d40b50af7d199f0957560887f734910fbdf
setId
public void setId(Long id)
{    this.id = id;}
354afe66bbdb19ee4d620955bbb214ebf9b5aa09359dea30ffb867002b5a25bd
getUrl
public String getUrl()
{    return url;}
c3d2ee14b0a87d91276b6034d452ebbd50ed47914948b9edaea83747da585af6
setUrl
public void setUrl(String url)
{    this.url = url;}
73f3d3052a702eb3ef8401812dc8df9d826a3d021ac5ea90a81aeceebdb2acf0
getSeedList
public SeedList getSeedList()
{    return seedList;}
4fd1171b31fed3e24da42b85162b2c8bf763cc6db708c9a35f93f9ce714984b9
setSeedList
public void setSeedList(SeedList seedList)
{    this.seedList = seedList;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    final int prime = 31;    int result = 1;    result = prime * result + ((id == null) ? 0 : id.hashCode());    return result;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj)        return true;    if (obj == null)        return false;    if (getClass() != obj.getClass())        return false;    SeedUrl other = (SeedUrl) obj;    if (id == null) {        if (other.id != null)            return false;    } else if (!id.equals(other.id))        return false;    return true;}
b7482d498c7b22fc604b0b48eb53a91e8ead98ec6e3f7cc14a3a793cd7fe10f5
getCrawlId
public String getCrawlId()
{    return crawlId;}
ccbfead7f316723a5f535c4a186c2e469b383dfa2da2301e832c8fe94ff39f8c
setCrawlId
public void setCrawlId(String crawlId)
{    this.crawlId = crawlId;}
d726d439acbb486b0bcc34ef94adc962f6a73fd68ff1149a7e31aaa8c58d0a42
getConfId
public String getConfId()
{    return confId;}
1d6e336afe4461fa7024c33fec9b59f98a177447f3975354c8db4ff0e39931a3
setConfId
public void setConfId(String confId)
{    this.confId = confId;}
b89f717d1c2ccf000ae99377b7c8ddb5164d7e6a8cc65662a01c3271ccb9352c
getArgs
public Map<String, Object> getArgs()
{    return args;}
1f52953b823b923cf7c59ae2d932cfb4b2d828b1a01e63cdb2685bd7abec655d
setArgs
public void setArgs(Map<String, Object> args)
{    this.args = args;}
354afe66bbdb19ee4d620955bbb214ebf9b5aa09359dea30ffb867002b5a25bd
getUrl
public String getUrl()
{    return url;}
c3d2ee14b0a87d91276b6034d452ebbd50ed47914948b9edaea83747da585af6
setUrl
public void setUrl(String url)
{    this.url = url;}
bfbf8f81d09b885c0f37c95c31de89a2ffa7676596bc6d4a873d28b384c04d1d
getStatus
public int getStatus()
{    return status;}
78ea1ba2f8e3ed7bc64348f7b7ea6abc4ee5f91d684a7686596eb3cb28cca7ae
setStatus
public void setStatus(int status)
{    this.status = status;}
bc3e8f2f78f6981a705491ab1cafb74a7055f144a1780b149d75f1fc24865213
getNumOfOutlinks
public int getNumOfOutlinks()
{    return numOfOutlinks;}
e68b5789de8d1287d234a61027309f9934d8fb4d16a32263e95a245fddc2be7c
setNumOfOutlinks
public void setNumOfOutlinks(int numOfOutlinks)
{    this.numOfOutlinks = numOfOutlinks;}
66ecd02c97f49e8e7ebc607369e9b395214f7cddb28d35acec27704cdef6b24d
setChildNodes
public void setChildNodes(Outlink[] links)
{    ChildNode childNode;    for (Outlink outlink : links) {        childNode = new ChildNode(outlink.getToUrl(), outlink.getAnchor());        children.add(childNode);    }}
a5a06925160779b10eb293e55ca77107ae88b707940b316a67e79f5f75277cbe
getAnchorText
public String getAnchorText()
{    return anchorText;}
71bcb37624f68290f5e7e870586467fb8d7784061d1a2015009baf1e0954f554
setAnchorText
public void setAnchorText(String anchorText)
{    this.anchorText = anchorText;}
b10b4c6683368eaca0cd1877610430a9858f93beb83ffd14b432ecfedacf2a66
getChildUrl
public String getChildUrl()
{    return childUrl;}
890133a28795c86a37e88a5f80b7afd119786859b37e4623970a5bd49cca8c79
setChildUrl
public void setChildUrl(String childUrl)
{    this.childUrl = childUrl;}
6f07bbf668477df3d34eee06984b0808c66b6c872edb738d631ad3346e7a5a4a
getChildren
public List<ChildNode> getChildren()
{    return children;}
9b3d5143ddc2770e6687b00ae16177b27ffcbf84b88d5c141b4943de49b4617e
setChildren
public void setChildren(List<ChildNode> children)
{    this.children = children;}
09e8f13a9a603d31d64bb498b77d15572483824d843d0e82a570643192f62186
getId
public String getId()
{    return id;}
ef03857fdefb7c5e949826b070dcbdc52b14cca8f50e0c7e1f5da4ee7e390f1a
setId
public void setId(String id)
{    this.id = id;}
4cbb3c04c2494e74cfd1e91b057fb4f4f8e88e55c6ec5fb363e683d40e015632
getType
public JobType getType()
{    return type;}
a451ec17772a76e4e462aa1698a67c082b8b23faf4a02917e56b03f25700dda8
setType
public void setType(JobType type)
{    this.type = type;}
d726d439acbb486b0bcc34ef94adc962f6a73fd68ff1149a7e31aaa8c58d0a42
getConfId
public String getConfId()
{    return confId;}
1d6e336afe4461fa7024c33fec9b59f98a177447f3975354c8db4ff0e39931a3
setConfId
public void setConfId(String confId)
{    this.confId = confId;}
b89f717d1c2ccf000ae99377b7c8ddb5164d7e6a8cc65662a01c3271ccb9352c
getArgs
public Map<String, Object> getArgs()
{    return args;}
1f52953b823b923cf7c59ae2d932cfb4b2d828b1a01e63cdb2685bd7abec655d
setArgs
public void setArgs(Map<String, Object> args)
{    this.args = args;}
3d6097c074ca9c7fd4f17f773b785364ca528870d61eb65dcddc4dc18ae42c15
getResult
public Map<String, Object> getResult()
{    return result;}
54144c51dd9579335c4347fa1a39e606e0b1ae3f46fba451f9f8640fb4586c10
setResult
public void setResult(Map<String, Object> result)
{    this.result = result;}
25732bf4689a2f9e30b003ed7ca49c4862da4931f831c5d1f6b63d803ca45d30
getState
public State getState()
{    return state;}
625a3338b65461ce0c036e446c5b196367e621720863da9c1300ea7977052a01
setState
public void setState(State state)
{    this.state = state;}
ee3c7c9f25e95b8615126f38a4151371e1123750674266d188e844ed092015d7
getMsg
public String getMsg()
{    return msg;}
9ac61442c3646e8121175908076f09a081755340dc832804af4aff146b4d9eda
setMsg
public void setMsg(String msg)
{    this.msg = msg;}
b7482d498c7b22fc604b0b48eb53a91e8ead98ec6e3f7cc14a3a793cd7fe10f5
getCrawlId
public String getCrawlId()
{    return crawlId;}
ccbfead7f316723a5f535c4a186c2e469b383dfa2da2301e832c8fe94ff39f8c
setCrawlId
public void setCrawlId(String crawlId)
{    this.crawlId = crawlId;}
9487044afac901905d396f0e67d984e4d2335428bebf9888c09bb43beb3db0a9
getStartDate
public Date getStartDate()
{    return startDate;}
13e1b2b3e832ce3c80e11b892dc23ce14e32bd325574a4b2cbdc660721a2c1c1
setStartDate
public void setStartDate(Date startDate)
{    this.startDate = startDate;}
5ba6d6eaba81f00592dacf3dc511ecbc0f608c5ed6c75fb12cacb59bfb2dfc21
getConfiguration
public Set<String> getConfiguration()
{    return configuration;}
b1fc27741f5dd43628ba6c4702c2dcda54f5ceefbedd41858c6da20129ad322b
setConfiguration
public void setConfiguration(Set<String> configuration)
{    this.configuration = configuration;}
98745bd382f7517a9315624f424aa802c57930e214d1140b931435cd4146dbb8
getJobs
public Collection<JobInfo> getJobs()
{    return jobs;}
2896e1bcb28f1af17ecfb5b6eb8a5de0ca8621c352b3f278aee671f36fdecf1b
setJobs
public void setJobs(Collection<JobInfo> jobs)
{    this.jobs = jobs;}
26f539f2fc53e38dfacb464be2b5fb2337ac64dcd4dd961ee904d83f55d11e87
getRunningJobs
public Collection<JobInfo> getRunningJobs()
{    return runningJobs;}
f622645992ac994dc58c1153a36909d29cb0f3f14c3b3758de4934ca1a311055
setRunningJobs
public void setRunningJobs(Collection<JobInfo> runningJobs)
{    this.runningJobs = runningJobs;}
594fe75536e070e395da760bbc6f7d0c31771dbea746c5a17d5f5b4249f31b92
getDumpPaths
public List<String> getDumpPaths()
{    return dumpPaths;}
0dffcda693646725ffa21ec31bb07f0b24ef7e0c812da6e934432b28ae2181ee
setDumpPaths
public void setDumpPaths(List<String> dumpPaths)
{    this.dumpPaths = dumpPaths;}
c965ed61e91b3ee0aa9ce036da150ffdc10b39ac90121bcd8d73b15f13fb1844
getInstance
public static NutchServer getInstance()
{    return server;}
4d0051cc394e1b815e471ae12914a67ea486971d86b019b185bd4d8c21baa01f
startServer
protected static void startServer()
{    server.start();}
612efbc97aee9982c2daa2cc6855741c4f0e6452c40c1771dd72a793e564599e
start
private void start()
{    LOG.info("Starting NutchServer on {}:{}  ...", host, port);    try {        String address = "http://" + host + ":" + port;        sf.setAddress(address);        sf.create();    } catch (Exception e) {        throw new IllegalStateException("Server could not be started", e);    }    started = System.currentTimeMillis();    running = true;    LOG.info("Started Nutch Server on {}:{} at {}", new Object[] { host, port, started });}
c8a035ab91df8cbc7ea5c3777035e40a701d03099a7f842cba3126d9b3768932
getClasses
private List<Class<?>> getClasses()
{    List<Class<?>> resources = new ArrayList<>();    resources.add(JobResource.class);    resources.add(ConfigResource.class);    resources.add(DbResource.class);    resources.add(AdminResource.class);    resources.add(SeedResource.class);    resources.add(ReaderResouce.class);    resources.add(ServicesResource.class);    return resources;}
8ff2b815147f1573310d1cf5b78a85ff3724216d49e8d9330ba4b95291db7687
getResourceProviders
private List<ResourceProvider> getResourceProviders()
{    List<ResourceProvider> resourceProviders = new ArrayList<>();    resourceProviders.add(new SingletonResourceProvider(getConfManager()));    return resourceProviders;}
f576387c4dad89b90fae0d4cfe8ac9d20ba8d24ce3cf0e7a0b40e3f98d486427
getConfManager
public ConfManager getConfManager()
{    return configManager;}
9f8762ca8eaa1fa5bddbce2b11fb3d44d1f38f37f84a831875387738894ee3bd
getJobManager
public JobManager getJobManager()
{    return jobManager;}
2a876052c2b10f1ddf0840d49cb9e72693fe8cd7106bc7eb85913aa36d96abdb
getSeedManager
public SeedManager getSeedManager()
{    return seedManager;}
49ed1e1d65a1ce62b0ceddd4079bd5f7097d0924fa41927ef3421fd7064caebe
getFetchNodeDb
public FetchNodeDb getFetchNodeDb()
{    return fetchNodeDb;}
1cd1b470351cc164620985e84951745a66160c6782dec39e46562afc0eaa2246
isRunning
public boolean isRunning()
{    return running;}
0be0b53fdde9c392dc8d85dd864c7b75e6799c1013ca512b3ede204a5b34c7ca
getStarted
public long getStarted()
{    return started;}
9a1806abf647d7394bdbd1503e874c2896aee3c3c69d74cf293f3dae16a058c0
main
public static void main(String[] args) throws ParseException
{    CommandLineParser parser = new PosixParser();    Options options = createOptions();    CommandLine commandLine = parser.parse(options, args);    if (commandLine.hasOption(CMD_HELP)) {        HelpFormatter formatter = new HelpFormatter();        formatter.printHelp("NutchServer", options, true);        return;    }    if (commandLine.hasOption(CMD_PORT)) {        port = Integer.parseInt(commandLine.getOptionValue(CMD_PORT));    }    if (commandLine.hasOption(CMD_HOST)) {        host = commandLine.getOptionValue(CMD_HOST);    }    startServer();}
d4c0adf3f7086be93daee19078bb573297f260bf62b6bd3bea5b78de78201057
createOptions
private static Options createOptions()
{    Options options = new Options();    OptionBuilder.withDescription("Show this help");    options.addOption(OptionBuilder.create(CMD_HELP));    OptionBuilder.withArgName("port");    OptionBuilder.hasOptionalArg();    OptionBuilder.withDescription("The port to run the Nutch Server. Default port 8081");    options.addOption(OptionBuilder.create(CMD_PORT));    OptionBuilder.withArgName("host");    OptionBuilder.hasOptionalArg();    OptionBuilder.withDescription("The host to bind the Nutch Server to. Default is localhost.");    options.addOption(OptionBuilder.create(CMD_HOST));    return options;}
ebb43bcdaef8415d60e7a2cd0118a614e0b089de4ced30c5ef51034588c03d19
canStop
public boolean canStop(boolean force)
{    if (force)        return true;    Collection<JobInfo> jobs = getJobManager().list(null, State.RUNNING);    return jobs.isEmpty();}
c9c0ee173289ee37136f000355d6ccc05321ec0da9a0b73ce7e5292b344a9d55
setPort
protected static void setPort(int port)
{    NutchServer.port = port;}
eedb587f68470407e820d49bf6bb9be573d78555382d32a0743e8fea8ced15d6
getPort
public int getPort()
{    return port;}
4e5c4125627f8fae3fcb8fa1c2fa25ff160d3eec452770c97bbb601a580fe141
stop
public void stop()
{    System.exit(0);}
eeed8aaf3c38f721855d78e44a93e40088bed6f39517bc12f3c70f7fbafa5cdb
throwBadRequestException
protected void throwBadRequestException(String message)
{    throw new WebApplicationException(Response.status(Status.BAD_REQUEST).entity(message).build());}
d5bc28b46ecc152324f3920ba042bb80ae78c0bf44f8e1e615317cf13f9a1f41
getServerStatus
public NutchServerInfo getServerStatus()
{    NutchServerInfo serverInfo = new NutchServerInfo();    serverInfo.setConfiguration(configManager.list());    serverInfo.setStartDate(new Date(server.getStarted()));    serverInfo.setJobs(jobManager.list(null, State.ANY));    serverInfo.setRunningJobs(jobManager.list(null, State.RUNNING));    return serverInfo;}
98f8e376ed99666b22ef779715be7fc1a12a755160f3dabac0f9458258232541
stopServer
public String stopServer(@QueryParam("force") boolean force)
{    if (!server.canStop(force)) {        return "Jobs still running -- Cannot stop server now";    }    scheduleServerStop();    return "Stopping in server on port " + server.getPort();}
81343141f1f0b602e7592039723cfb0d2f3c6d4917a1f4e628b0ae509d60e4d3
scheduleServerStop
private void scheduleServerStop()
{    LOG.info("Shutting down server in {} sec", DELAY_SEC);    Thread thread = new Thread() {        public void run() {            try {                Thread.sleep(DELAY_SEC * 1000);            } catch (InterruptedException e) {                Thread.currentThread().interrupt();            }            server.stop();            LOG.info("Service stopped.");        }    };    thread.setDaemon(true);    thread.start();    LOG.info("Service shutting down...");}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        Thread.sleep(DELAY_SEC * 1000);    } catch (InterruptedException e) {        Thread.currentThread().interrupt();    }    server.stop();    LOG.info("Service stopped.");}
4020b0cd509376a3dfe26cc7f05c951ab888b8dd99585ffa6721485d422e5386
getConfigs
public Set<String> getConfigs()
{    return configManager.list();}
7ea2ce5b5c94f07744dade563a6597eee034ab4c28c4a0b5842b1f91a260b528
getConfig
public Map<String, String> getConfig(@PathParam("configId") String configId)
{    return configManager.getAsMap(configId);}
1bf69eeb42f2279c8e6ac6b88ee20a56c90f42aff3bccedff599806f76bbbecc
getProperty
public String getProperty(@PathParam("configId") String configId, @PathParam("propertyId") String propertyId)
{    return configManager.getAsMap(configId).get(propertyId);}
b1bbb133791ea151805bcb6453d75d198b2e574036c3db69e3961e5780d2eb29
deleteConfig
public void deleteConfig(@PathParam("configId") String configId)
{    configManager.delete(configId);}
410618e2cddd712fd2d1f8f61d375cf613e7bd5b8ccda4396fbca85bbc08b3c8
createConfig
public Response createConfig(NutchConfig newConfig)
{    if (newConfig == null) {        return Response.status(400).entity("Nutch configuration cannot be empty!").build();    }    try {        configManager.create(newConfig);    } catch (Exception e) {        return Response.status(400).entity(e.getMessage()).build();    }    return Response.ok(newConfig.getConfigId()).build();}
c1b0575dab2bfd5433b969e7e8802f5b88afb8c0c29368fc77a7ac7a7945d67d
updateProperty
public Response updateProperty(@PathParam("configId") String confId, @PathParam("propertyId") String propertyKey, String value)
{    try {        configManager.setProperty(confId, propertyKey, value);    } catch (Exception e) {        return Response.status(400).entity(e.getMessage()).build();    }    return Response.ok().build();}
0b02b8197e18d304e79d6386d136f14977fed157cddba828fc79d7af9fb201d5
readdb
public Response readdb(DbQuery dbQuery)
{    if (dbQuery == null)        return Response.status(Status.BAD_REQUEST).build();    Configuration conf = configManager.get(dbQuery.getConfId());    if (conf == null) {        conf = configManager.get(ConfigResource.DEFAULT);    }    if (dbQuery.getCrawlId() == null || dbQuery.getType() == null) {        return Response.status(Status.BAD_REQUEST).build();    }    String type = dbQuery.getType();    if (type.equalsIgnoreCase("stats")) {        return crawlDbStats(conf, dbQuery.getArgs(), dbQuery.getCrawlId());    }    if (type.equalsIgnoreCase("dump")) {        return crawlDbDump(conf, dbQuery.getArgs(), dbQuery.getCrawlId());    }    if (type.equalsIgnoreCase("topN")) {        return crawlDbTopN(conf, dbQuery.getArgs(), dbQuery.getCrawlId());    }    if (type.equalsIgnoreCase("url")) {        return crawlDbUrl(conf, dbQuery.getArgs(), dbQuery.getCrawlId());    }    return null;}
e323c8ed816a5877de33a1b21f9e6d574a7dcad1d9ed2a2a97cdb97ea5a33834
fetchDb
public List<FetchNodeDbInfo> fetchDb(@DefaultValue("0") @QueryParam("to") int to, @DefaultValue("0") @QueryParam("from") int from)
{    List<FetchNodeDbInfo> listOfFetchedNodes = new ArrayList<>();    Map<Integer, FetchNode> fetchNodedbMap = FetchNodeDb.getInstance().getFetchNodeDb();    if (to == 0 || to > fetchNodedbMap.size()) {        to = fetchNodedbMap.size();    }    for (int i = from; i <= to; i++) {        if (!fetchNodedbMap.containsKey(i)) {            continue;        }        FetchNode node = fetchNodedbMap.get(i);        FetchNodeDbInfo fdbInfo = new FetchNodeDbInfo();        fdbInfo.setUrl(node.getUrl().toString());        fdbInfo.setStatus(node.getStatus());        fdbInfo.setNumOfOutlinks(node.getOutlinks().length);        fdbInfo.setChildNodes(node.getOutlinks());        listOfFetchedNodes.add(fdbInfo);    }    return listOfFetchedNodes;}
ce3d6dab863e95b6c1f3c3bd01c5affabec6bddc93f69989e2a9b91d735c65a9
crawlDbStats
private Response crawlDbStats(Configuration conf, Map<String, String> args, String crawlId)
{    CrawlDbReader dbr = new CrawlDbReader();    try {        return Response.ok(dbr.query(args, conf, "stats", crawlId)).build();    } catch (Exception e) {        e.printStackTrace();        return Response.serverError().entity(e.getMessage()).type(MediaType.TEXT_PLAIN).build();    }}
fe794ecf118415b9bbfefdb6b2f90a502c8ae63204d285c9db55a8b56fbc8f43
crawlDbDump
private Response crawlDbDump(Configuration conf, Map<String, String> args, String crawlId)
{    @SuppressWarnings("resource")    CrawlDbReader dbr = new CrawlDbReader();    try {        return Response.ok(dbr.query(args, conf, "dump", crawlId), MediaType.APPLICATION_OCTET_STREAM).build();    } catch (Exception e) {        e.printStackTrace();        return Response.serverError().entity(e.getMessage()).type(MediaType.TEXT_PLAIN).build();    }}
be139239f97286fc5432dde8769dff2dd6c7affb56f1bfdd685820dd4ff21e77
crawlDbTopN
private Response crawlDbTopN(Configuration conf, Map<String, String> args, String crawlId)
{    @SuppressWarnings("resource")    CrawlDbReader dbr = new CrawlDbReader();    try {        return Response.ok(dbr.query(args, conf, "topN", crawlId), MediaType.APPLICATION_OCTET_STREAM).build();    } catch (Exception e) {        e.printStackTrace();        return Response.serverError().entity(e.getMessage()).type(MediaType.TEXT_PLAIN).build();    }}
8e41b9857bc49946e9e552ef3af54ffef517ce7d06cf82719471c64568377289
crawlDbUrl
private Response crawlDbUrl(Configuration conf, Map<String, String> args, String crawlId)
{    @SuppressWarnings("resource")    CrawlDbReader dbr = new CrawlDbReader();    try {        return Response.ok(dbr.query(args, conf, "url", crawlId)).build();    } catch (Exception e) {        e.printStackTrace();        return Response.serverError().entity(e.getMessage()).type(MediaType.TEXT_PLAIN).build();    }}
b40da758eaaf1b614b4e2e60e8366fe3ce8bd4cd3b70c35a30857f78be884388
getJobs
public Collection<JobInfo> getJobs(@QueryParam("crawlId") String crawlId)
{    return jobManager.list(crawlId, State.ANY);}
d6239199b0d9cf93641782cb4f67b3b7b9d60c40911e84d9dba4307ab156cf6c
getInfo
public JobInfo getInfo(@PathParam("id") String id, @QueryParam("crawlId") String crawlId)
{    return jobManager.get(crawlId, id);}
ec27e0a1df6a0f332e63ba6a1b4bc6f79d69aab9ddb557785d620e25c9709c07
stop
public boolean stop(@PathParam("id") String id, @QueryParam("crawlId") String crawlId)
{    return jobManager.stop(crawlId, id);}
c65e5a4443068ebdaf6a1d1c942b5e7d65d578c0c97cee35c73eccc0f6939ff8
abort
public boolean abort(@PathParam("id") String id, @QueryParam("crawlId") String crawlId)
{    return jobManager.abort(crawlId, id);}
2fdc6939a28963ca44bf816ffb49e7952c633291f1e833394cec5a3057c498eb
create
public JobInfo create(JobConfig config)
{    if (config == null) {        throwBadRequestException("Job configuration is required!");    }    return jobManager.create(config);}
60ea6eb4dc0a7f1f0ca2a5f6cf65aad69b0dbcb1db3ee24b045c84be90e8ea69
seqRead
public Response seqRead(ReaderConfig readerConf, @DefaultValue("-1") @QueryParam("nrows") int nrows, @DefaultValue("-1") @QueryParam("start") int start, @QueryParam("end") int end, @QueryParam("count") boolean count)
{    NutchReader reader = new SequenceReader();    String path = readerConf.getPath();    return performRead(reader, path, nrows, start, end, count);}
f461508c2afa873d108b1d5b1bdd6dcc9f8925174b70cb58b0115fe4363302f8
linkRead
public Response linkRead()
{    HashMap<String, String> schema = new HashMap<>();    schema.put("key_url", "string");    schema.put("timestamp", "int");    schema.put("score", "float");    schema.put("anchor", "string");    schema.put("linktype", "string");    schema.put("url", "string");    return Response.ok(schema).type(MediaType.APPLICATION_JSON).build();}
e7e74710edd472056fabe6432b42afe1e799b0cdcc2173b8af8002303f7900cc
linkRead
public Response linkRead(ReaderConfig readerConf, @DefaultValue("-1") @QueryParam("nrows") int nrows, @DefaultValue("-1") @QueryParam("start") int start, @QueryParam("end") int end, @QueryParam("count") boolean count)
{    NutchReader reader = new LinkReader();    String path = readerConf.getPath();    return performRead(reader, path, nrows, start, end, count);}
2eecd0be17315296b0dda7e7f26d3d195388bf92e860f64c8cf1d6d81a7da80a
nodeRead
public Response nodeRead()
{    HashMap<String, String> schema = new HashMap<>();    schema.put("key_url", "string");    schema.put("num_inlinks", "int");    schema.put("num_outlinks", "int");    schema.put("inlink_score", "float");    schema.put("outlink_score", "float");    schema.put("metadata", "string");    return Response.ok(schema).type(MediaType.APPLICATION_JSON).build();}
2def2ee332880ba22b3685534897f92932361a160255444d255e9294df7a08f3
nodeRead
public Response nodeRead(ReaderConfig readerConf, @DefaultValue("-1") @QueryParam("nrows") int nrows, @DefaultValue("-1") @QueryParam("start") int start, @QueryParam("end") int end, @QueryParam("count") boolean count)
{    NutchReader reader = new NodeReader();    String path = readerConf.getPath();    return performRead(reader, path, nrows, start, end, count);}
359f79247c28e3f7310d5d997fe226a0520c46ebe28aa9a49e3d3d1e847aafb7
performRead
private Response performRead(NutchReader reader, String path, int nrows, int start, int end, boolean count)
{    Object result;    try {        if (count) {            result = reader.count(path);            return Response.ok(result).type(MediaType.TEXT_PLAIN).build();        } else if (start > -1 && end > 0) {            result = reader.slice(path, start, end);        } else if (nrows > -1) {            result = reader.head(path, nrows);        } else {            result = reader.read(path);        }        return Response.ok(result).type(MediaType.APPLICATION_JSON).build();    } catch (Exception e) {        return Response.status(Status.BAD_REQUEST).entity("File not found").build();    }}
bfead718190e9847ff1d0b0dfa5b064027152f0156777ff2e507de93a92202eb
getSeedLists
public Response getSeedLists()
{    Map<String, SeedList> seeds = NutchServer.getInstance().getSeedManager().getSeeds();    if (seeds != null) {        return Response.ok(seeds).build();    } else {        return Response.ok().build();    }}
59bb9ca7b9e0880c08047b8fcf2907815fea764924466df2351c8dce252c6687
createSeedFile
public Response createSeedFile(SeedList seedList)
{    try {        if (seedList == null) {            return Response.status(Status.BAD_REQUEST).entity("Seed list cannot be empty!").build();        }        Collection<SeedUrl> seedUrls = seedList.getSeedUrls();        String seedFilePath = writeToSeedFile(seedUrls);        seedList.setSeedFilePath(seedFilePath);        NutchServer.getInstance().getSeedManager().setSeedList(seedList.getName(), seedList);        return Response.ok().entity(seedFilePath).build();    } catch (Exception e) {        LOG.warn("Error while creating seed : {}", e.getMessage());    }    return Response.serverError().build();}
bbe0e4dfe806d9ac271aeac016ecf2c48c52e96ff785e2e48468dfc5e35e80fe
writeToSeedFile
private String writeToSeedFile(Collection<SeedUrl> seedUrls) throws Exception
{    String seedFilePath = "seedFiles/seed-" + System.currentTimeMillis();    org.apache.hadoop.fs.Path seedFolder = new org.apache.hadoop.fs.Path(seedFilePath);    FileSystem fs = FileSystem.get(new Configuration());    if (!fs.exists(seedFolder)) {        if (!fs.mkdirs(seedFolder)) {            throw new Exception("Could not create seed folder at : " + seedFolder);        }    }    String filename = seedFilePath + System.getProperty("file.separator") + "urls";    org.apache.hadoop.fs.Path seedPath = new org.apache.hadoop.fs.Path(filename);    OutputStream os = fs.create(seedPath);    if (CollectionUtils.isNotEmpty(seedUrls)) {        for (SeedUrl seedUrl : seedUrls) {            os.write(seedUrl.getUrl().getBytes());            os.write("\n".getBytes());        }    }    os.close();    return seedPath.getParent().toString();}
d09de9ebf3e631501b49685d8115cac5f3041983d00ef5fa24e3dc0afd4b8fca
listDumpPaths
public Response listDumpPaths(@PathParam("crawlId") String crawlId)
{    File dumpFilePath = new File(crawlId + File.separator + "dump/");    File[] dumpFileList = dumpFilePath.listFiles();    List<String> fileNames = new ArrayList<>();    if (dumpFileList != null) {        for (File f : dumpFileList) {            fileNames.add(f.getPath());        }    }    ServiceInfo info = new ServiceInfo();    info.setDumpPaths(fileNames);    return Response.ok().entity(info).type(MediaType.APPLICATION_JSON).build();}
242738b6b235047ef7fd243a315c4969832464bfe9a595ad44d58258fb079b16
commoncrawlDump
public Response commoncrawlDump(ServiceConfig serviceConfig)
{    String crawlId = serviceConfig.getCrawlId();    String outputDir = crawlId + File.separator + "dump" + File.separator + "commoncrawl-" + sdf.format(System.currentTimeMillis());    Map<String, Object> args = serviceConfig.getArgs();    args.put("outputDir", outputDir);    if (!args.containsKey(Nutch.ARG_SEGMENTDIR)) {        args.put("segment", crawlId + File.separator + "segments");    }    serviceConfig.setArgs(args);    ServiceWorker worker = new ServiceWorker(serviceConfig, new CommonCrawlDataDumper());    worker.run();    return Response.ok(outputDir).type(MediaType.TEXT_PLAIN).build();}
e675b8848a8830a3035b1836521346796b7612b780465a761bdbd54ad22f1652
getJsonData
public String getJsonData(String url, Content content, Metadata metadata) throws IOException
{    this.url = url;    this.content = content;    this.metadata = metadata;    return this.getJsonData();}
1435491b460827c726e1967a8573b810dd4ff8c3edab4b9e710738249a4530fd
getJsonData
public String getJsonData(String url, Content content, Metadata metadata, ParseData parseData) throws IOException
{        throw new NotImplementedException();}
93d58885906e998892568e298b244e49679628bb82a36310f65115b066ae181b
getJsonData
public String getJsonData() throws IOException
{    try {        startObject(null);                writeKeyValue("url", getUrl());                writeKeyValue("timestamp", getTimestamp());                startObject("request");        writeKeyValue("method", getMethod());        startObject("client");        writeKeyValue("hostname", getRequestHostName());        writeKeyValue("address", getRequestHostAddress());        writeKeyValue("software", getRequestSoftware());        writeKeyValue("robots", getRequestRobots());        startObject("contact");        writeKeyValue("name", getRequestContactName());        writeKeyValue("email", getRequestContactEmail());        closeObject("contact");        closeObject("client");                startHeaders("headers", false, true);        writeKeyValueWrapper("Accept", getRequestAccept());        writeKeyValueWrapper("Accept-Encoding", getRequestAcceptEncoding());        writeKeyValueWrapper("Accept-Language", getRequestAcceptLanguage());        writeKeyValueWrapper("User-Agent", getRequestUserAgent());                closeHeaders("headers", false, true);        writeKeyNull("body");        closeObject("request");                startObject("response");        writeKeyValue("status", getResponseStatus());        startObject("server");        writeKeyValue("hostname", getResponseHostName());        writeKeyValue("address", getResponseAddress());        closeObject("server");                startHeaders("headers", false, true);        writeKeyValueWrapper("Content-Encoding", getResponseContentEncoding());        writeKeyValueWrapper("Content-Type", getResponseContentType());        writeKeyValueWrapper("Date", getResponseDate());        writeKeyValueWrapper("Server", getResponseServer());        for (String name : metadata.names()) {            if (name.equalsIgnoreCase("Content-Encoding") || name.equalsIgnoreCase("Content-Type") || name.equalsIgnoreCase("Date") || name.equalsIgnoreCase("Server")) {                continue;            }            writeKeyValueWrapper(name, metadata.get(name));        }        closeHeaders("headers", false, true);        writeKeyValue("body", getResponseContent());        closeObject("response");                if (!this.keyPrefix.isEmpty()) {            this.keyPrefix += "-";        }        writeKeyValue("key", this.keyPrefix + getKey());                writeKeyValue("imported", getImported());        if (getInLinks() != null) {            startArray("inlinks", false, true);            for (String link : getInLinks()) {                writeArrayValue(link);            }            closeArray("inlinks", false, true);        }        closeObject(null);        return generateJson();    } catch (IOException ioe) {        LOG.warn("Error in processing file " + url + ": " + ioe.getMessage());        throw new IOException("Error in generating JSON:" + ioe.getMessage());    }}
c52a9e95cb73ca0af006a79ebc086ffac1c6ece926ca83713f4780c272ac6766
getUrl
protected String getUrl()
{    try {        return URIUtil.encodePath(url);    } catch (URIException e) {        LOG.error("Can't encode URL " + url);    }    return url;}
528675df28e8ce1c6e5e343eb959912bbc8a4cd3f3dd1378ef4413afa1f424c5
getTimestamp
protected String getTimestamp()
{    if (this.simpleDateFormat) {        String timestamp = null;        try {            long epoch = new SimpleDateFormat("EEE, d MMM yyyy HH:mm:ss z").parse(ifNullString(metadata.get(Metadata.LAST_MODIFIED))).getTime();            timestamp = String.valueOf(epoch);        } catch (ParseException pe) {            LOG.warn(pe.getMessage());        }        return timestamp;    } else {        return ifNullString(metadata.get(Metadata.LAST_MODIFIED));    }}
dbebf458315de5c611b13e473541789813f3fd44ab03aa8601d789b43724f048
getMethod
protected String getMethod()
{    return new String("GET");}
c76320ca3d53fc1e404746978a521fee9cd263d0e0d5def69656b46096718e03
getRequestHostName
protected String getRequestHostName()
{    String hostName = "";    try {        hostName = InetAddress.getLocalHost().getHostName();    } catch (UnknownHostException uhe) {    }    return hostName;}
d20df3879c5ec0fb580ecf4dc7516cbf640d4a08d89258fd33db5079fb49e4ba
getRequestHostAddress
protected String getRequestHostAddress()
{    String hostAddress = "";    try {        hostAddress = InetAddress.getLocalHost().getHostAddress();    } catch (UnknownHostException uhe) {    }    return hostAddress;}
1fd90eb485e3220bf16034c4dbe9dbae0f12f3e3246babac6f205a2105b458d9
getRequestSoftware
protected String getRequestSoftware()
{    return conf.get("http.agent.version", "");}
87ffd8ad0ac22a555d12a7f6899914ef5e601603354ae5a17b7f624026e904c3
getRequestRobots
protected String getRequestRobots()
{    return new String("CLASSIC");}
c1c21da3954f62ae7adcf4b93641bf7c5fecb482eea87cbe9f2c5bd1cda91769
getRequestContactName
protected String getRequestContactName()
{    return conf.get("http.agent.name", "");}
003bb318fc14363ee66c4ea5b0644d69c2d1927310598d23cdd6876d3458aa5b
getRequestContactEmail
protected String getRequestContactEmail()
{    return conf.get("http.agent.email", "");}
9cabdcbe8be205a551aa25aa24b82258a23079bc9cd21e2cee31818199008848
getRequestAccept
protected String getRequestAccept()
{    return conf.get("http.accept", "");}
2f5c341255473557cc8b7fd592fd661887c110fa7c6bda85da67e798452326d6
getRequestAcceptEncoding
protected String getRequestAcceptEncoding()
{        return new String("");}
8fa6455595e7a4fd41872ae5a02abf143e0f05676a0ba9aa76711b4d06cae70d
getRequestAcceptLanguage
protected String getRequestAcceptLanguage()
{    return conf.get("http.accept.language", "");}
352699d8da62a4d4d3367505d9bd0c13a7b6acc2584cda61fc09ebcccce671d6
getRequestUserAgent
protected String getRequestUserAgent()
{    return conf.get("http.robots.agents", "");}
4477e5cc024e263d9ec33377f0ee414fce4ecceb266fea45e053dd9e6f5d14d7
getResponseStatus
protected String getResponseStatus()
{    return ifNullString(metadata.get("status"));}
d7a18c8beafb5af2428363f245d9b48ce457223555f91d7e7b9175b692dc4ce7
getResponseHostName
protected String getResponseHostName()
{    return URLUtil.getHost(url);}
88afb7c88aaca9af9f7b1e526f080553274cdc62a40c33a6b56270f9a8eab68b
getResponseAddress
protected String getResponseAddress()
{    return ifNullString(metadata.get("_ip_"));}
0ddbce391ebd985262cf9fe806ba3deb58d0b76bc2941a63b20c8881332ec2da
getResponseContentEncoding
protected String getResponseContentEncoding()
{    return ifNullString(metadata.get("Content-Encoding"));}
4c417dd4b7939469cd7924f07600f3631cdd69ae234a9e9c513bc349be98e176
getResponseContentType
protected String getResponseContentType()
{    return ifNullString(metadata.get("Content-Type"));}
d4836fc784af70e762de79c28313042975fce70dc66e4b7955b918754cdb47b7
getInLinks
public List<String> getInLinks()
{    return inLinks;}
31340a2ff5c28b68e204c4b13c6a74cb049b07091bc2442cf0e583ac8dd673c4
setInLinks
public void setInLinks(List<String> inLinks)
{    this.inLinks = inLinks;}
ae38a4053c17963be84353118053f8d80562e95c9af62a2d5e4cebb6e4732682
getResponseDate
protected String getResponseDate()
{    if (this.simpleDateFormat) {        String timestamp = null;        try {            long epoch = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss z").parse(ifNullString(metadata.get("Date"))).getTime();            timestamp = String.valueOf(epoch);        } catch (ParseException pe) {            LOG.warn(pe.getMessage());        }        return timestamp;    } else {        return ifNullString(metadata.get("Date"));    }}
e2cfaaf0a38e5f2c15987c9c47e1f5a693df9822411b660b28319ea0ef45e221
getResponseServer
protected String getResponseServer()
{    return ifNullString(metadata.get("Server"));}
b03c01e64d8be350b6cda99bca18e59b043023da20b9d67bb732476ec14b49ee
getResponseContent
protected String getResponseContent()
{    return new String(content.getContent());}
b319097c37cfea7929236fd05f25d6986015de931500dd38095ee8348d6228f1
getKey
protected String getKey()
{    if (this.reverseKey) {        return this.reverseKeyValue;    } else {        return url;    }}
9248cbfe83ca4ac24189663a99119af0528617bb525b7475826c9ee0a5f4d8d0
getImported
protected String getImported()
{    if (this.simpleDateFormat) {        String timestamp = null;        try {            long epoch = new SimpleDateFormat("EEE, d MMM yyyy HH:mm:ss z").parse(ifNullString(metadata.get("Date"))).getTime();            timestamp = String.valueOf(epoch);        } catch (ParseException pe) {            LOG.warn(pe.getMessage());        }        return timestamp;    } else {        return ifNullString(metadata.get("Date"));    }}
c53ed26f1bb3aa4cbf97055863371e6389dba6e43fc9e01b89ac6ba72c93e2d4
ifNullString
private static String ifNullString(String value)
{    return (value != null) ? value : "";}
4ed1b5de6a361c1e6e43a3fc8bd4be939728a2ec011a33413d1126e2561be8e8
startHeaders
private void startHeaders(String key, boolean nested, boolean newline) throws IOException
{    if (this.jsonArray) {        startArray(key, nested, newline);    } else {        startObject(key);    }}
7ac0bf2f0c596b0fc30827acb5661d124e2138e844abc494bfdc67a54378f1d9
closeHeaders
private void closeHeaders(String key, boolean nested, boolean newline) throws IOException
{    if (this.jsonArray) {        closeArray(key, nested, newline);    } else {        closeObject(key);    }}
f24e7e1a9c3e6a309e0cf36439b07ca8bc13bbace37e26b816d301b6657bcf1d
writeKeyValueWrapper
private void writeKeyValueWrapper(String key, String value) throws IOException
{    if (this.jsonArray) {        startArray(null, true, false);        writeArrayValue(key);        writeArrayValue(value);        closeArray(null, true, false);    } else {        writeKeyValue(key, value);    }}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{}
257f8ebf20c2452aa1b8bda31ff402577e1a720f3cb7d301a6168ab6ec385c69
createRecordReader
public RecordReader<Text, BytesWritable> createRecordReader(InputSplit split, TaskAttemptContext context)
{    return new SequenceFileRecordReader<Text, BytesWritable>();}
581c98ca06149e8a5a47661ad9543a74471c4938829a5d88918d1d21c1152e27
getRecordReader
public RecordReader<Text, BytesWritable> getRecordReader(InputSplit split, Job job, Context context) throws IOException
{    context.setStatus(split.toString());    Configuration conf = job.getConfiguration();    return new ArcRecordReader(conf, (FileSplit) split);}
c367229ae0f0fc30a44e7adba9b38712970bcee8a8d346ae5c9625d592b7e5ed
isMagic
public static boolean isMagic(byte[] input)
{        if (input == null || input.length != MAGIC.length) {        return false;    }        for (int i = 0; i < MAGIC.length; i++) {        if (MAGIC[i] != input[i]) {            return false;        }    }        return true;}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    this.in.close();}
7bedc625521f341c3528178b629e8c2c53322b88fa6ebc73414d70092712211d
createKey
public Text createKey()
{    return ReflectionUtils.newInstance(Text.class, conf);}
f054d767d4e77534655aca2d6d900f98a59272de018e13a4d8d32b2fcfeafbdb
createValue
public BytesWritable createValue()
{    return ReflectionUtils.newInstance(BytesWritable.class, conf);}
5800a0f531c192e683ef74c0c5de6015daf6261d1f8e5c0ce6d8e043b01926c7
getPos
public long getPos() throws IOException
{    return in.getPos();}
46dc59cbf7e4d6aafe0869ef2726ed2c5c897b673d9e37f94ab9b0e962f65f7f
getProgress
public float getProgress() throws IOException
{        if (splitEnd == splitStart) {        return 0.0f;    } else {                return Math.min(1.0f, (getPos() - splitStart) / (float) splitLen);    }}
e99c52c1fd619589a5430f0e30462227c0567ba05a7c2f3e7f0c499befa28b86
getCurrentValue
public BytesWritable getCurrentValue()
{    return new BytesWritable();}
eb59369d3867061f66f8b47b2591be7079168068a6ff46e700fac22564deac0f
getCurrentKey
public Text getCurrentKey()
{    return new Text();}
e54f90c585dcdd34f8c67cbc0dd7a90e094b3a7f9e889c8d1beeae2b9a8487ce
nextKeyValue
public boolean nextKeyValue()
{    return false;}
3ab06d0195092fb2ca7f28d301fb239eef0e72a5bfae5ed8436a8037b3844295
initialize
public void initialize(InputSplit split, TaskAttemptContext context)
{}
87642a3ed34a9cfd3dbdea9a4a845c8f49804a2f8832dd67857851a04e990633
next
public boolean next(Text key, BytesWritable value) throws IOException
{    try {                long startRead = in.getPos();        byte[] magicBuffer = null;                while (true) {                        if (startRead >= splitEnd) {                return false;            }                        boolean foundStart = false;            while (!foundStart) {                                                startRead = in.getPos();                magicBuffer = new byte[1024];                int read = in.read(magicBuffer);                if (read < 0) {                    break;                }                                for (int i = 0; i < read - 1; i++) {                    byte[] testMagic = new byte[2];                    System.arraycopy(magicBuffer, i, testMagic, 0, 2);                    if (isMagic(testMagic)) {                                                startRead += i;                        foundStart = true;                        break;                    }                }            }                        in.seek(startRead);            ByteArrayOutputStream baos = null;            int totalRead = 0;            try {                                byte[] buffer = new byte[4096];                GZIPInputStream zin = new GZIPInputStream(in);                int gzipRead = -1;                baos = new ByteArrayOutputStream();                while ((gzipRead = zin.read(buffer, 0, buffer.length)) != -1) {                    baos.write(buffer, 0, gzipRead);                    totalRead += gzipRead;                }            } catch (Exception e) {                                                                System.out.println("Ignoring position: " + (startRead));                if (startRead + 1 < fileLen) {                    in.seek(startRead + 1);                }                continue;            }                        byte[] content = baos.toByteArray();                        int eol = 0;            for (int i = 0; i < content.length; i++) {                if (i > 0 && content[i] == '\n') {                    eol = i;                    break;                }            }                        String header = new String(content, 0, eol).trim();            byte[] raw = new byte[(content.length - eol) - 1];            System.arraycopy(content, eol + 1, raw, 0, raw.length);                        Text keyText = key;            keyText.set(header);            BytesWritable valueBytes = value;            valueBytes.set(raw, 0, raw.length);                        if (startRead + 1 < fileLen) {                in.seek(startRead + 1);            }                        return true;        }    } catch (Exception e) {        LOG.error("Failed reading ARC record: ", e);    }        return false;}
636853d50e42ca3167c3f9f4053c592451b2ed973e114fc90783bacdc1fa1353
generateSegmentName
public static synchronized String generateSegmentName()
{    try {        Thread.sleep(1000);    } catch (Throwable t) {    }    return sdf.format(new Date(System.currentTimeMillis()));}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{}
22329dd70a6d2c550fc8c3514bfb41f03a0c7a7dc722757f5f72895dc081620c
logError
private static void logError(Text url, Throwable t)
{    if (LOG.isInfoEnabled()) {        LOG.info("Conversion of " + url + " failed with: " + StringUtils.stringifyException(t));    }}
be433d62cff7653240db9b15dd2ccdde1e7ee28cc35d93d789961c1be4537625
output
private ParseStatus output(Context context, String segmentName, Text key, CrawlDatum datum, Content content, ProtocolStatus pstatus, int status) throws InterruptedException
{        datum.setStatus(status);    datum.setFetchTime(System.currentTimeMillis());    if (pstatus != null)        datum.getMetaData().put(Nutch.WRITABLE_PROTO_STATUS_KEY, pstatus);    ParseResult parseResult = null;    if (content != null) {        Metadata metadata = content.getMetadata();                metadata.set(Nutch.SEGMENT_NAME_KEY, segmentName);                try {            scfilters.passScoreBeforeParsing(key, datum, content);        } catch (Exception e) {            if (LOG.isWarnEnabled()) {                LOG.warn("Couldn't pass score, url " + key + " (" + e + ")");            }        }        try {                        parseResult = parseUtil.parse(content);        } catch (Exception e) {            LOG.warn("Error parsing: " + key + ": " + StringUtils.stringifyException(e));        }                if (parseResult == null) {            byte[] signature = SignatureFactory.getSignature(conf).calculate(content, new ParseStatus().getEmptyParse(conf));            datum.setSignature(signature);        }        if (parseResult == null) {            byte[] signature = SignatureFactory.getSignature(conf).calculate(content, new ParseStatus().getEmptyParse(conf));            datum.setSignature(signature);        }        try {            context.write(key, new NutchWritable(datum));            context.write(key, new NutchWritable(content));            if (parseResult != null) {                for (Entry<Text, Parse> entry : parseResult) {                    Text url = entry.getKey();                    Parse parse = entry.getValue();                    ParseStatus parseStatus = parse.getData().getStatus();                    if (!parseStatus.isSuccess()) {                        LOG.warn("Error parsing: " + key + ": " + parseStatus);                        parse = parseStatus.getEmptyParse(conf);                    }                                        byte[] signature = SignatureFactory.getSignature(conf).calculate(content, parse);                                        parse.getData().getContentMeta().set(Nutch.SEGMENT_NAME_KEY, segmentName);                    parse.getData().getContentMeta().set(Nutch.SIGNATURE_KEY, StringUtil.toHexString(signature));                                        parse.getData().getContentMeta().set(Nutch.FETCH_TIME_KEY, Long.toString(datum.getFetchTime()));                    if (url.equals(key))                        datum.setSignature(signature);                    try {                        scfilters.passScoreAfterParsing(url, content, parse);                    } catch (Exception e) {                        if (LOG.isWarnEnabled()) {                            LOG.warn("Couldn't pass score, url " + key + " (" + e + ")");                        }                    }                    context.write(url, new NutchWritable(new ParseImpl(new ParseText(parse.getText()), parse.getData(), parse.isCanonical())));                }            }        } catch (IOException e) {            if (LOG.isErrorEnabled()) {                LOG.error("ArcSegmentCreator caught:" + StringUtils.stringifyException(e));            }        }        if (parseResult != null && !parseResult.isEmpty()) {            Parse p = parseResult.get(content.getUrl());            if (p != null) {                return p.getData().getStatus();            }        }    }    return null;}
486161b7b0e7eac9bf7a058810b6e3d5a97b91a5f03e211a4dee704c49ac837f
setup
public void setup(Mapper<Text, BytesWritable, Text, NutchWritable>.Context context)
{            conf = context.getConfiguration();    urlFilters = new URLFilters(conf);    scfilters = new ScoringFilters(conf);    parseUtil = new ParseUtil(conf);    normalizers = new URLNormalizers(conf, URLNormalizers.SCOPE_FETCHER);    interval = conf.getInt("db.fetch.interval.default", 2592000);}
46b1b16246f575a4b1f28a4599360ddb154b22f0ecca1ef6c4707a9addad6583
map
public void map(Text key, BytesWritable bytes, Context context) throws IOException, InterruptedException
{    String[] headers = key.toString().split("\\s+");    String urlStr = headers[0];    String version = headers[2];    String contentType = headers[3];        if (urlStr.startsWith("filedesc://")) {        LOG.info("Ignoring file header: " + urlStr);        return;    }    LOG.info("Processing: " + urlStr);        Text url = new Text();    CrawlDatum datum = new CrawlDatum(CrawlDatum.STATUS_DB_FETCHED, interval, 1.0f);    String segmentName = conf.get(Nutch.SEGMENT_NAME_KEY);        try {        urlStr = normalizers.normalize(urlStr, URLNormalizers.SCOPE_FETCHER);                urlStr = urlFilters.filter(urlStr);    } catch (Exception e) {        if (LOG.isWarnEnabled()) {            LOG.warn("Skipping " + url + ":" + e);        }        urlStr = null;    }        if (urlStr != null) {        url.set(urlStr);        try {                                                            ProtocolStatus status = ProtocolStatus.STATUS_SUCCESS;            Content content = new Content(urlStr, urlStr, bytes.getBytes(), contentType, new Metadata(), conf);                        content.getMetadata().set(URL_VERSION, version);            @SuppressWarnings("unused")            ParseStatus pstatus = null;            pstatus = output(context, segmentName, url, datum, content, status, CrawlDatum.STATUS_FETCH_SUCCESS);            context.progress();        } catch (Throwable t) {                        logError(url, t);            output(context, segmentName, url, datum, null, null, CrawlDatum.STATUS_FETCH_RETRY);        }    }}
afc21f053fb445b08d89e2794efa1aa420fbd84ef72391b892775b2f4f796078
createSegments
public void createSegments(Path arcFiles, Path segmentsOutDir) throws IOException, InterruptedException, ClassNotFoundException
{    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    long start = System.currentTimeMillis();    if (LOG.isInfoEnabled()) {        LOG.info("ArcSegmentCreator: starting at " + sdf.format(start));        LOG.info("ArcSegmentCreator: arc files dir: " + arcFiles);    }    Job job = NutchJob.getInstance(getConf());    Configuration conf = job.getConfiguration();    job.setJobName("ArcSegmentCreator " + arcFiles);    String segName = generateSegmentName();    conf.set(Nutch.SEGMENT_NAME_KEY, segName);    FileInputFormat.addInputPath(job, arcFiles);    job.setInputFormatClass(ArcInputFormat.class);    job.setJarByClass(ArcSegmentCreator.class);    job.setMapperClass(ArcSegmentCreator.ArcSegmentCreatorMapper.class);    FileOutputFormat.setOutputPath(job, new Path(segmentsOutDir, segName));    job.setOutputFormatClass(FetcherOutputFormat.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(NutchWritable.class);    try {        boolean success = job.waitForCompletion(true);        if (!success) {            String message = "ArcSegmentCreator job did not succeed, job status:" + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);            throw new RuntimeException(message);        }    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error(StringUtils.stringifyException(e));        throw e;    }    long end = System.currentTimeMillis();    LOG.info("ArcSegmentCreator: finished at " + sdf.format(end) + ", elapsed: " + TimingUtil.elapsedTime(start, end));}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int res = ToolRunner.run(NutchConfiguration.create(), new ArcSegmentCreator(), args);    System.exit(res);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    String usage = "Usage: ArcSegmentCreator <arcFiles> <segmentsOutDir>";    if (args.length < 2) {        System.err.println(usage);        return -1;    }        Path arcFiles = new Path(args[0]);    Path segmentsOutDir = new Path(args[1]);    try {                createSegments(arcFiles, segmentsOutDir);        return 0;    } catch (Exception e) {        LOG.error("ArcSegmentCreator: " + StringUtils.stringifyException(e));        return -1;    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    Configuration conf = NutchConfiguration.create();    int res = ToolRunner.run(conf, new Benchmark(), args);    System.exit(res);}
aa41a6a8ce7bb9eec70ed7463c35ac161fbd44fcd0504b7bf056dbdace0168aa
getDate
private static String getDate()
{    return new SimpleDateFormat("yyyyMMddHHmmss").format(new Date(System.currentTimeMillis()));}
13a9796c38d8f55dd2b7cdbd2006fdcf09c0b4832e70640fe61f1a5724ef8739
createSeeds
private void createSeeds(FileSystem fs, Path seedsDir, int count) throws Exception
{    OutputStream os = fs.create(new Path(seedsDir, "seeds"));    for (int i = 0; i < count; i++) {        String url = "http://www.test-" + i + ".com/\r\n";        os.write(url.getBytes());    }    os.flush();    os.close();}
f3a8c0877ed9596ab797b05d13709e1ab73387f934d17251f230827dac102074
addTiming
public void addTiming(String stage, String run, long timing)
{    if (!runs.contains(run)) {        runs.add(run);    }    if (!stages.contains(stage)) {        stages.add(stage);    }    Map<String, Long> t = timings.get(stage);    if (t == null) {        t = new HashMap<>();        timings.put(stage, t);    }    t.put(run, timing);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder();    sb.append("* Plugins:\t" + plugins + "\n");    sb.append("* Seeds:\t" + seeds + "\n");    sb.append("* Depth:\t" + depth + "\n");    sb.append("* Threads:\t" + threads + "\n");    sb.append("* TopN:\t" + topN + "\n");    sb.append("* Delete:\t" + delete + "\n");    sb.append("* TOTAL ELAPSED:\t" + elapsed + "\n");    for (String stage : stages) {        Map<String, Long> timing = timings.get(stage);        if (timing == null)            continue;        sb.append("- stage: " + stage + "\n");        for (String r : runs) {            Long Time = timing.get(r);            if (Time == null) {                continue;            }            sb.append("\trun " + r + "\t" + Time + "\n");        }    }    return sb.toString();}
1f5ab2871b334522c6d753561a24db3fa70ccb7be0d6491554f94d864d42da87
getStages
public List<String> getStages()
{    return stages;}
1228d9bd27c3a6799b9e7764df06af5de54e5cfd172c798b731a955fbc0bd974
getRuns
public List<String> getRuns()
{    return runs;}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    String plugins = "protocol-http|parse-tika|scoring-opic|urlfilter-regex|urlnormalizer-pass";    int seeds = 1;    int depth = 10;    int threads = 10;    boolean delete = true;    long topN = Long.MAX_VALUE;    if (args.length == 0) {        System.err.println("Usage: Benchmark [-seeds NN] [-depth NN] [-threads NN] [-keep] [-maxPerHost NN] [-plugins <regex>]");        System.err.println("\t-seeds NN\tcreate NN unique hosts in a seed list (default: 1)");        System.err.println("\t-depth NN\tperform NN crawl cycles (default: 10)");        System.err.println("\t-threads NN\tuse NN threads per Fetcher task (default: 10)");        System.err.println("\t-keep\tkeep segment data (default: delete after updatedb)");        System.err.println("\t-plugins <regex>\toverride 'plugin.includes'.");        System.err.println("\tNOTE: if not specified, this is reset to: " + plugins);        System.err.println("\tNOTE: if 'default' is specified then a value set in nutch-default/nutch-site is used.");        System.err.println("\t-maxPerHost NN\tmax. # of URLs per host in a fetchlist");        return -1;    }    int maxPerHost = Integer.MAX_VALUE;    for (int i = 0; i < args.length; i++) {        if (args[i].equals("-seeds")) {            seeds = Integer.parseInt(args[++i]);        } else if (args[i].equals("-threads")) {            threads = Integer.parseInt(args[++i]);        } else if (args[i].equals("-depth")) {            depth = Integer.parseInt(args[++i]);        } else if (args[i].equals("-keep")) {            delete = false;        } else if (args[i].equals("-plugins")) {            plugins = args[++i];        } else if (args[i].equalsIgnoreCase("-maxPerHost")) {            maxPerHost = Integer.parseInt(args[++i]);        } else {            LOG.fatal("Invalid argument: '" + args[i] + "'");            return -1;        }    }    BenchmarkResults res = benchmark(seeds, depth, threads, maxPerHost, topN, delete, plugins);    System.out.println(res);    return 0;}
ab1fceede67ef4ab39e3b79f980a46109de94cb7fa2ae198cd8658aebc3ef4c6
benchmark
public BenchmarkResults benchmark(int seeds, int depth, int threads, int maxPerHost, long topN, boolean delete, String plugins) throws Exception
{    Configuration conf = getConf();    conf.set("http.proxy.host", "localhost");    conf.setInt("http.proxy.port", 8181);    conf.set("http.agent.name", "test");    conf.set("http.robots.agents", "test,*");    if (!plugins.equals("default")) {        conf.set("plugin.includes", plugins);    }    conf.setInt(Generator.GENERATOR_MAX_COUNT, maxPerHost);    conf.set(Generator.GENERATOR_COUNT_MODE, Generator.GENERATOR_COUNT_VALUE_HOST);    @SuppressWarnings("unused")    Job job = NutchJob.getInstance(getConf());    FileSystem fs = FileSystem.get(conf);    Path dir = new Path(getConf().get("hadoop.tmp.dir"), "bench-" + System.currentTimeMillis());    fs.mkdirs(dir);    Path rootUrlDir = new Path(dir, "seed");    fs.mkdirs(rootUrlDir);    createSeeds(fs, rootUrlDir, seeds);    if (LOG.isInfoEnabled()) {        LOG.info("crawl started in: " + dir);        LOG.info("rootUrlDir = " + rootUrlDir);        LOG.info("threads = " + threads);        LOG.info("depth = " + depth);    }    BenchmarkResults res = new BenchmarkResults();    res.delete = delete;    res.depth = depth;    res.plugins = plugins;    res.seeds = seeds;    res.threads = threads;    res.topN = topN;    Path crawlDb = new Path(dir + "/crawldb");    Path linkDb = new Path(dir + "/linkdb");    Path segments = new Path(dir + "/segments");    res.elapsed = System.currentTimeMillis();    Injector injector = new Injector(getConf());    Generator generator = new Generator(getConf());    Fetcher fetcher = new Fetcher(getConf());    ParseSegment parseSegment = new ParseSegment(getConf());    CrawlDb crawlDbTool = new CrawlDb(getConf());    LinkDb linkDbTool = new LinkDb(getConf());        long start = System.currentTimeMillis();    injector.inject(crawlDb, rootUrlDir);    long delta = System.currentTimeMillis() - start;    res.addTiming("inject", "0", delta);    int i;    for (i = 0; i < depth; i++) {                start = System.currentTimeMillis();        Path[] segs = generator.generate(crawlDb, segments, -1, topN, System.currentTimeMillis());        delta = System.currentTimeMillis() - start;        res.addTiming("generate", i + "", delta);        if (segs == null) {            LOG.info("Stopping at depth=" + i + " - no more URLs to fetch.");            break;        }        start = System.currentTimeMillis();                fetcher.fetch(segs[0], threads);        delta = System.currentTimeMillis() - start;        res.addTiming("fetch", i + "", delta);        if (!Fetcher.isParsing(conf)) {            start = System.currentTimeMillis();                        parseSegment.parse(segs[0]);            delta = System.currentTimeMillis() - start;            res.addTiming("parse", i + "", delta);        }        start = System.currentTimeMillis();                crawlDbTool.update(crawlDb, segs, true, true);        delta = System.currentTimeMillis() - start;        res.addTiming("update", i + "", delta);        start = System.currentTimeMillis();                linkDbTool.invert(linkDb, segs, true, true, false);        delta = System.currentTimeMillis() - start;        res.addTiming("invert", i + "", delta);                if (delete) {            for (Path p : segs) {                fs.delete(p, true);            }        }    }    if (i == 0) {        LOG.warn("No URLs to fetch - check your seed list and URL filters.");    }    if (LOG.isInfoEnabled()) {        LOG.info("crawl finished: " + dir);    }    res.elapsed = System.currentTimeMillis() - res.elapsed;    @SuppressWarnings("resource")    CrawlDbReader dbreader = new CrawlDbReader();    dbreader.processStatJob(crawlDb.toString(), conf, false);    return res;}
7092f2bfd9272f11652c648404b89c7e63ad68ee70676c5c65c586f97eb63c5d
init
private void init(InputStream stream)
{    if (stream == null) {        return;    }    Properties properties = new Properties();    try {        properties.load(stream);    } catch (IOException e) {        } finally {        try {            stream.close();        } catch (IOException e) {                }    }    setKeyPrefix(properties.getProperty("keyPrefix", ""));    setSimpleDateFormat(Boolean.parseBoolean(properties.getProperty("simpleDateFormat", "False")));    setJsonArray(Boolean.parseBoolean(properties.getProperty("jsonArray", "False")));    setReverseKey(Boolean.parseBoolean(properties.getProperty("reverseKey", "False")));}
066b2b12f44c7197a3b353368290e56370982630364b03fde5afa8a04a7412ff
setKeyPrefix
public void setKeyPrefix(String keyPrefix)
{    this.keyPrefix = keyPrefix;}
0a605054e202d3edefdb8c276c32727d762a64bef587eb54287169d32218cf4c
setSimpleDateFormat
public void setSimpleDateFormat(boolean simpleDateFormat)
{    this.simpleDateFormat = simpleDateFormat;}
6bc58bd9767b8733a109d61373399ff48498607e6635a12ec905c614787ec24a
setJsonArray
public void setJsonArray(boolean jsonArray)
{    this.jsonArray = jsonArray;}
e2e6c4e505f88155a487afe01d4cd70335befdf97720c5b8fa68c50ec66ef88b
setReverseKey
public void setReverseKey(boolean reverseKey)
{    this.reverseKey = reverseKey;}
b1d93c5944f34d9ae6af889bfad50635d7a5b84d86e95f4fd377cbe76f146945
setReverseKeyValue
public void setReverseKeyValue(String reverseKeyValue)
{    this.reverseKeyValue = reverseKeyValue;}
d5bd0b581181bffea5db4c9f008f54caa501548386de3b99b196ce1cef1afe08
getKeyPrefix
public String getKeyPrefix()
{    return this.keyPrefix;}
6364ca34bc3d0fa0934f420aadb9c20294086a3818e871faa3b821bfcdb648f9
getSimpleDateFormat
public boolean getSimpleDateFormat()
{    return this.simpleDateFormat;}
653e6f4324ac93c805622c37a308e1500baf06d260e03e26760ba8a538f38da5
getJsonArray
public boolean getJsonArray()
{    return this.jsonArray;}
97413eda5812064b39c4cabeafd65750f258f1eb89945bc1a21f98bd2b3b978b
getReverseKey
public boolean getReverseKey()
{    return this.reverseKey;}
a3d47591c763bfccb872b9bc50f1d3858135022c789953816a032aebe27e361d
getReverseKeyValue
public String getReverseKeyValue()
{    return this.reverseKeyValue;}
b58d85dfcbc498f11ead6b1ebd07cb907ada2747e6957b213106eca22f0de6d0
isCompressed
public boolean isCompressed()
{    return compressed;}
084bea17bf14182c0b74ff29e0cdc8a8df86853d5185f382e509e72cde75f95c
setCompressed
public void setCompressed(boolean compressed)
{    this.compressed = compressed;}
c956cb667474eec443d2eb43dc98e172c275a3bd947f44f51e2448f982b606f2
getWarcSize
public long getWarcSize()
{    return warcSize;}
6af262282eb2d2120066ffb19aa932c7d5909d97f5aceaef6d7643a9ca6ebed9
setWarcSize
public void setWarcSize(long warcSize)
{    this.warcSize = warcSize;}
fb5778a6c9371883e9958802e95a22a048d210718c37b905284e17a58a506d2b
getOutputDir
public String getOutputDir()
{    return outputDir;}
3dca522f0f4d2d8a4a767bd9f8ffe3f27c1d5332842c99c2733cda83590901be
setOutputDir
public void setOutputDir(String outputDir)
{    this.outputDir = outputDir;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    Configuration conf = NutchConfiguration.create();    int res = ToolRunner.run(conf, new CommonCrawlDataDumper(), args);    System.exit(res);}
81b6b91dfd47fb1a817f831f159f88c6b2dbf3ded83edf1981bd2efa62aa4db4
dump
public void dump(File outputDir, File segmentRootDir, File linkdb, boolean gzip, String[] mimeTypes, boolean epochFilename, String extension, boolean warc) throws Exception
{    if (gzip) {        LOG.info("Gzipping CBOR data has been skipped");    }        Map<String, Integer> typeCounts = new HashMap<>();        Map<String, Integer> filteredCounts = new HashMap<>();    Configuration nutchConfig = NutchConfiguration.create();    Path segmentRootPath = new Path(segmentRootDir.toString());    FileSystem fs = segmentRootPath.getFileSystem(nutchConfig);        List<Path> parts = new ArrayList<>();    RemoteIterator<LocatedFileStatus> files = fs.listFiles(segmentRootPath, true);    String partPattern = ".*" + File.separator + Content.DIR_NAME + File.separator + "part-[0-9]{5}" + File.separator + "data";    while (files.hasNext()) {        LocatedFileStatus next = files.next();        if (next.isFile()) {            Path path = next.getPath();            if (path.toString().matches(partPattern)) {                parts.add(path);            }        }    }    LinkDbReader linkDbReader = null;    if (linkdb != null) {        linkDbReader = new LinkDbReader(nutchConfig, new Path(linkdb.toString()));    }    if (parts == null || parts.size() == 0) {        LOG.error("No segment directories found in {} ", segmentRootDir.getAbsolutePath());        System.exit(1);    }    LOG.info("Found {} segment parts", parts.size());    if (gzip && !warc) {        fileList = new ArrayList<>();        constructNewStream(outputDir);    }    for (Path segmentPart : parts) {        LOG.info("Processing segment Part : [ {} ]", segmentPart);        try {            SequenceFile.Reader reader = new SequenceFile.Reader(nutchConfig, SequenceFile.Reader.file(segmentPart));            Writable key = (Writable) reader.getKeyClass().getConstructor().newInstance();            Content content = null;            while (reader.next(key)) {                content = new Content();                reader.getCurrentValue(content);                Metadata metadata = content.getMetadata();                String url = key.toString();                String baseName = FilenameUtils.getBaseName(url);                String extensionName = FilenameUtils.getExtension(url);                if (!extension.isEmpty()) {                    extensionName = extension;                } else if ((extensionName == null) || extensionName.isEmpty()) {                    extensionName = "html";                }                String outputFullPath = null;                String outputRelativePath = null;                String filename = null;                String timestamp = null;                String reverseKey = null;                if (epochFilename || config.getReverseKey()) {                    try {                        long epoch = new SimpleDateFormat("EEE, d MMM yyyy HH:mm:ss z").parse(getDate(metadata.get("Date"))).getTime();                        timestamp = String.valueOf(epoch);                    } catch (ParseException pe) {                        LOG.warn(pe.getMessage());                    }                    reverseKey = reverseUrl(url);                    config.setReverseKeyValue(reverseKey.replace("/", "_") + "_" + DigestUtils.sha1Hex(url) + "_" + timestamp);                }                if (!warc) {                    if (epochFilename) {                        outputFullPath = DumpFileUtil.createFileNameFromUrl(outputDir.getAbsolutePath(), reverseKey, url, timestamp, extensionName, !gzip);                        outputRelativePath = outputFullPath.substring(0, outputFullPath.lastIndexOf(File.separator) - 1);                        filename = content.getMetadata().get(Metadata.DATE) + "." + extensionName;                    } else {                        String md5Ofurl = DumpFileUtil.getUrlMD5(url);                        String fullDir = DumpFileUtil.createTwoLevelsDirectory(outputDir.getAbsolutePath(), md5Ofurl, !gzip);                        filename = DumpFileUtil.createFileName(md5Ofurl, baseName, extensionName);                        outputFullPath = String.format("%s/%s", fullDir, filename);                        String[] fullPathLevels = fullDir.split(Pattern.quote(File.separator));                        String firstLevelDirName = fullPathLevels[fullPathLevels.length - 2];                        String secondLevelDirName = fullPathLevels[fullPathLevels.length - 1];                        outputRelativePath = firstLevelDirName + secondLevelDirName;                    }                }                                Boolean filter = (mimeTypes == null);                String jsonData = "";                try {                    String mimeType = new Tika().detect(content.getContent());                                                            Set<String> inUrls = null;                    if (linkDbReader != null) {                        Inlinks inlinks = linkDbReader.getInlinks((Text) key);                        if (inlinks != null) {                            Iterator<Inlink> iterator = inlinks.iterator();                            inUrls = new LinkedHashSet<>();                            while (inUrls.size() <= MAX_INLINKS && iterator.hasNext()) {                                inUrls.add(iterator.next().getFromUrl());                            }                        }                    }                                        try (CommonCrawlFormat format = CommonCrawlFormatFactory.getCommonCrawlFormat(warc ? "WARC" : "JACKSON", nutchConfig, config)) {                        if (inUrls != null) {                            format.setInLinks(new ArrayList<>(inUrls));                        }                        jsonData = format.getJsonData(url, content, metadata);                    }                    collectStats(typeCounts, mimeType);                                        if ((mimeType != null) && (mimeTypes != null) && Arrays.asList(mimeTypes).contains(mimeType)) {                        collectStats(filteredCounts, mimeType);                        filter = true;                    }                } catch (IOException ioe) {                    LOG.error("Fatal error in creating JSON data: " + ioe.getMessage());                    return;                }                if (!warc) {                    if (filter) {                        byte[] byteData = serializeCBORData(jsonData);                        if (!gzip) {                            File outputFile = new File(outputFullPath);                            if (outputFile.exists()) {                                LOG.info("Skipping writing: [" + outputFullPath + "]: file already exists");                            } else {                                LOG.info("Writing: [" + outputFullPath + "]");                                IOUtils.copy(new ByteArrayInputStream(byteData), new FileOutputStream(outputFile));                            }                        } else {                            if (fileList.contains(outputFullPath)) {                                LOG.info("Skipping compressing: [" + outputFullPath + "]: file already exists");                            } else {                                fileList.add(outputFullPath);                                LOG.info("Compressing: [" + outputFullPath + "]");                                                                TarArchiveEntry tarEntry = new TarArchiveEntry(outputRelativePath + File.separator + filename);                                tarEntry.setSize(byteData.length);                                tarOutput.putArchiveEntry(tarEntry);                                tarOutput.write(byteData);                                tarOutput.closeArchiveEntry();                            }                        }                    }                }            }            reader.close();        } catch (Exception e) {            LOG.warn("SKIPPED: {} Because : {}", segmentPart, e.getMessage());        } finally {            fs.close();        }    }    if (gzip && !warc) {        closeStream();    }    if (!typeCounts.isEmpty()) {        LOG.info("CommonsCrawlDataDumper File Stats: " + DumpFileUtil.displayFileTypes(typeCounts, filteredCounts));    }}
ca954a847c19c962858d094f8baedb7185bf754cc67c7711d382b8347aae296b
closeStream
private void closeStream()
{    try {        tarOutput.finish();        tarOutput.close();        gzipOutput.close();        bufOutput.close();        fileOutput.close();    } catch (IOException ioe) {        LOG.warn("Error in closing stream: " + ioe.getMessage());    }}
2df731a2e2543f74f22a2963c498cd6ec7c5d64c8d9f98ec2d8de7e069ca818f
constructNewStream
private void constructNewStream(File outputDir) throws IOException
{    String archiveName = new SimpleDateFormat("yyyyMMddhhmm'.tar.gz'").format(new Date());    LOG.info("Creating a new gzip archive: " + archiveName);    fileOutput = new FileOutputStream(new File(outputDir + File.separator + archiveName));    bufOutput = new BufferedOutputStream(fileOutput);    gzipOutput = new GzipCompressorOutputStream(bufOutput);    tarOutput = new TarArchiveOutputStream(gzipOutput);    tarOutput.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);}
3fc956fe28fd0fd972bb91a33bcd85937f989d848440338ed7c983b76079c90b
writeMagicHeader
private void writeMagicHeader(CBORGenerator generator) throws IOException
{                byte[] header = new byte[3];    header[0] = (byte) 0xd9;    header[1] = (byte) 0xd9;    header[2] = (byte) 0xf7;    generator.writeBytes(header, 0, header.length);}
10bea6d7d6c7ef72d8f19af46e59e077d64659aa2b56d0c37d1558c68155ebd8
serializeCBORData
private byte[] serializeCBORData(String jsonData)
{    CBORFactory factory = new CBORFactory();    CBORGenerator generator = null;    ByteArrayOutputStream stream = null;    try {        stream = new ByteArrayOutputStream();        generator = factory.createGenerator(stream);                writeMagicHeader(generator);        generator.writeString(jsonData);        generator.flush();        stream.flush();        return stream.toByteArray();    } catch (Exception e) {        LOG.warn("CBOR encoding failed: " + e.getMessage());    } finally {        try {            generator.close();            stream.close();        } catch (IOException e) {                }    }    return null;}
979aca2c0c5f38d1e2334f86841d363b39fd0f4c3300974a092fd04ff65299fd
collectStats
private void collectStats(Map<String, Integer> typeCounts, String mimeType)
{    typeCounts.put(mimeType, typeCounts.containsKey(mimeType) ? typeCounts.get(mimeType) + 1 : 1);}
98671f95cba509fbf8d19234eb4159ee794bc90a378a73353e17417df9bc647d
getDate
private String getDate(String timestamp)
{    if (timestamp == null || timestamp.isEmpty()) {        DateFormat dateFormat = new SimpleDateFormat("EEE, d MMM yyyy HH:mm:ss z");        timestamp = dateFormat.format(new Date());    }    return timestamp;}
fa96b622a54a7a0a5459abc564e3d4b5a3f0a304155f2b5bd0241576ecfd58a7
reverseUrl
public static String reverseUrl(String urlString)
{    URL url;    String reverseKey = null;    try {        url = new URL(urlString);        String[] hostPart = url.getHost().replace('.', '/').split("/");        StringBuilder sb = new StringBuilder();        sb.append(hostPart[hostPart.length - 1]);        for (int i = hostPart.length - 2; i >= 0; i--) {            sb.append("/" + hostPart[i]);        }        reverseKey = sb.toString();    } catch (MalformedURLException e) {        LOG.error("Failed to parse URL: {}", urlString);    }    return reverseKey;}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    Option helpOpt = new Option("h", "help", false, "show this help message.");        @SuppressWarnings("static-access")    Option outputOpt = OptionBuilder.withArgName("outputDir").hasArg().withDescription("output directory (which will be created) to host the CBOR data.").create("outputDir");        Option warcOpt = new Option("warc", "export to a WARC file");    @SuppressWarnings("static-access")    Option segOpt = OptionBuilder.withArgName("segment").hasArgs().withDescription("the segment or directory containing segments to use").create("segment");        @SuppressWarnings("static-access")    Option mimeOpt = OptionBuilder.isRequired(false).withArgName("mimetype").hasArgs().withDescription("an optional list of mimetypes to dump, excluding all others. Defaults to all.").create("mimetype");    @SuppressWarnings("static-access")    Option gzipOpt = OptionBuilder.withArgName("gzip").hasArg(false).withDescription("an optional flag indicating whether to additionally gzip the data.").create("gzip");    @SuppressWarnings("static-access")    Option keyPrefixOpt = OptionBuilder.withArgName("keyPrefix").hasArg(true).withDescription("an optional prefix for key in the output format.").create("keyPrefix");    @SuppressWarnings("static-access")    Option simpleDateFormatOpt = OptionBuilder.withArgName("SimpleDateFormat").hasArg(false).withDescription("an optional format for timestamp in GMT epoch milliseconds.").create("SimpleDateFormat");    @SuppressWarnings("static-access")    Option epochFilenameOpt = OptionBuilder.withArgName("epochFilename").hasArg(false).withDescription("an optional format for output filename.").create("epochFilename");    @SuppressWarnings("static-access")    Option jsonArrayOpt = OptionBuilder.withArgName("jsonArray").hasArg(false).withDescription("an optional format for JSON output.").create("jsonArray");    @SuppressWarnings("static-access")    Option reverseKeyOpt = OptionBuilder.withArgName("reverseKey").hasArg(false).withDescription("an optional format for key value in JSON output.").create("reverseKey");    @SuppressWarnings("static-access")    Option extensionOpt = OptionBuilder.withArgName("extension").hasArg(true).withDescription("an optional file extension for output documents.").create("extension");    @SuppressWarnings("static-access")    Option sizeOpt = OptionBuilder.withArgName("warcSize").hasArg(true).withType(Number.class).withDescription("an optional file size in bytes for the WARC file(s)").create("warcSize");    @SuppressWarnings("static-access")    Option linkDbOpt = OptionBuilder.withArgName("linkdb").hasArg(true).withDescription("an optional linkdb parameter to include inlinks in dump files").isRequired(false).create("linkdb");        Options options = new Options();    options.addOption(helpOpt);    options.addOption(outputOpt);    options.addOption(segOpt);        options.addOption(warcOpt);    options.addOption(mimeOpt);    options.addOption(gzipOpt);        options.addOption(keyPrefixOpt);        options.addOption(simpleDateFormatOpt);    options.addOption(epochFilenameOpt);    options.addOption(jsonArrayOpt);    options.addOption(reverseKeyOpt);    options.addOption(extensionOpt);    options.addOption(sizeOpt);    options.addOption(linkDbOpt);    CommandLineParser parser = new GnuParser();    try {        CommandLine line = parser.parse(options, args);        if (line.hasOption("help") || !line.hasOption("outputDir") || (!line.hasOption("segment"))) {            HelpFormatter formatter = new HelpFormatter();            formatter.printHelp(CommonCrawlDataDumper.class.getName(), options, true);            return 0;        }        File outputDir = new File(line.getOptionValue("outputDir"));        File segmentRootDir = new File(line.getOptionValue("segment"));        String[] mimeTypes = line.getOptionValues("mimetype");        boolean gzip = line.hasOption("gzip");        boolean epochFilename = line.hasOption("epochFilename");        String keyPrefix = line.getOptionValue("keyPrefix", "");        boolean simpleDateFormat = line.hasOption("SimpleDateFormat");        boolean jsonArray = line.hasOption("jsonArray");        boolean reverseKey = line.hasOption("reverseKey");        String extension = line.getOptionValue("extension", "");        boolean warc = line.hasOption("warc");        long warcSize = 0;        if (line.getParsedOptionValue("warcSize") != null) {            warcSize = (Long) line.getParsedOptionValue("warcSize");        }        String linkdbPath = line.getOptionValue("linkdb");        File linkdb = linkdbPath == null ? null : new File(linkdbPath);        CommonCrawlConfig config = new CommonCrawlConfig();        config.setKeyPrefix(keyPrefix);        config.setSimpleDateFormat(simpleDateFormat);        config.setJsonArray(jsonArray);        config.setReverseKey(reverseKey);        config.setCompressed(gzip);        config.setWarcSize(warcSize);        config.setOutputDir(line.getOptionValue("outputDir"));        if (!outputDir.exists()) {            LOG.warn("Output directory: [" + outputDir.getAbsolutePath() + "]: does not exist, creating it.");            if (!outputDir.mkdirs())                throw new Exception("Unable to create: [" + outputDir.getAbsolutePath() + "]");        }        CommonCrawlDataDumper dumper = new CommonCrawlDataDumper(config);        dumper.dump(outputDir, segmentRootDir, linkdb, gzip, mimeTypes, epochFilename, extension, warc);    } catch (Exception e) {        LOG.error(CommonCrawlDataDumper.class.getName() + ": " + StringUtils.stringifyException(e));        e.printStackTrace();        return -1;    }    return 0;}
084523121ab64bd9486b37875e438171d2b2467ace02bce8523551b0ce84ace4
run
public Map<String, Object> run(Map<String, Object> args, String crawlId) throws Exception
{    String keyPrefix = args.containsKey("keyPrefix") ? (String) args.get("keyPrefix") : "";    File outputDir = new File((String) args.get("outputDir"));    File segmentRootDir = new File((String) args.get(Nutch.ARG_SEGMENTDIR));    ArrayList<String> mimeTypesList = args.containsKey("mimetypes") ? (ArrayList<String>) args.get("mimetypes") : null;    String[] mimeTypes = null;    if (mimeTypesList != null) {        mimeTypes = new String[mimeTypesList.size()];        int i = 0;        for (String m : mimeTypesList) mimeTypes[i++] = m;    }    boolean gzip = args.containsKey("gzip") ? (boolean) args.get("gzip") : false;    boolean epochFilename = args.containsKey("epochFilename") ? (boolean) args.get("epochFilename") : false;    boolean simpleDateFormat = args.containsKey("simpleDateFormat") ? (boolean) args.get("simpleDateFormat") : false;    boolean jsonArray = args.containsKey("jsonArray") ? (boolean) args.get("jsonArray") : false;    boolean reverseKey = args.containsKey("reverseKey") ? (boolean) args.get("reverseKey") : false;    String extension = args.containsKey("extension") ? (String) args.get("extension") : "";    boolean warc = args.containsKey("warc") ? (boolean) args.get("warc") : false;    long warcSize = args.containsKey("warcSize") ? (Long) args.get("warcSize") : 0;    CommonCrawlConfig config = new CommonCrawlConfig();    config.setKeyPrefix(keyPrefix);    config.setSimpleDateFormat(simpleDateFormat);    config.setJsonArray(jsonArray);    config.setReverseKey(reverseKey);    config.setCompressed(gzip);    config.setWarcSize(warcSize);    config.setOutputDir((String) args.get("outputDir"));    if (!outputDir.exists()) {        if (!outputDir.mkdirs())            throw new Exception("Unable to create: [" + outputDir.getAbsolutePath() + "]");    }    CommonCrawlDataDumper dumper = new CommonCrawlDataDumper(config);    dumper.dump(outputDir, segmentRootDir, null, gzip, mimeTypes, epochFilename, extension, warc);    return null;}
aa466508e80497aec9fffb8642dccd7b919878fd887dfc01b24a49c695514e58
getCommonCrawlFormat
public static CommonCrawlFormat getCommonCrawlFormat(String formatType, String url, Content content, Metadata metadata, Configuration nutchConf, CommonCrawlConfig config) throws IOException
{    if (formatType == null) {        return null;    }    if (formatType.equalsIgnoreCase("jackson")) {        return new CommonCrawlFormatJackson(url, content, metadata, nutchConf, config);    } else if (formatType.equalsIgnoreCase("jettinson")) {        return new CommonCrawlFormatJettinson(url, content, metadata, nutchConf, config);    } else if (formatType.equalsIgnoreCase("simple")) {        return new CommonCrawlFormatSimple(url, content, metadata, nutchConf, config);    }    return null;}
d634c33e490df64ebc330024831ed5f69c56895c8beaba0450f71a3c896ef4e6
getCommonCrawlFormat
public static CommonCrawlFormat getCommonCrawlFormat(String formatType, Configuration nutchConf, CommonCrawlConfig config) throws IOException
{    if (formatType.equalsIgnoreCase("WARC")) {        return new CommonCrawlFormatWARC(nutchConf, config);    }    if (formatType.equalsIgnoreCase("JACKSON")) {        return new CommonCrawlFormatJackson(nutchConf, config);    }    return null;}
b38a3ced3ac0c8bcce071e87cac154498d4bd6e75ae002e81c7468df8faf7c5e
writeKeyValue
protected void writeKeyValue(String key, String value) throws IOException
{    generator.writeFieldName(key);    generator.writeString(value);}
726ea61a5b1b96d83528d355834b0f6f405a45ad7792b7e6e54647ecc061f3fb
writeKeyNull
protected void writeKeyNull(String key) throws IOException
{    generator.writeFieldName(key);    generator.writeNull();}
dbb6fbfddb764f0b0873edc7366608ae297c2c5c00c4678b270e602a975cf739
startArray
protected void startArray(String key, boolean nested, boolean newline) throws IOException
{    if (key != null) {        generator.writeFieldName(key);    }    generator.writeStartArray();}
733ad03d5579fddf0ff2e94f940de7f984a9e504ddf4508145db318e6ccaa7d0
closeArray
protected void closeArray(String key, boolean nested, boolean newline) throws IOException
{    generator.writeEndArray();}
3b8f9294ebcea1fd9e841684b2849a0117d7c76a1a0c12943570166b52b08297
writeArrayValue
protected void writeArrayValue(String value) throws IOException
{    generator.writeString(value);}
3dd74faff298eee36bfda58164a057cefa2c207b3fc615c97c9c139eea0c8056
startObject
protected void startObject(String key) throws IOException
{    if (key != null) {        generator.writeFieldName(key);    }    generator.writeStartObject();}
8776948a45757aa6827a148c3af37e8eba731f4f75204c0e18c99dd81ac60477
closeObject
protected void closeObject(String key) throws IOException
{    generator.writeEndObject();}
b3aedc24582f9f9c7a7cdd5ea8549582c87229bad9480f191e678c7805eba6b2
generateJson
protected String generateJson() throws IOException
{    this.generator.flush();    return this.out.toString();}
b38a3ced3ac0c8bcce071e87cac154498d4bd6e75ae002e81c7468df8faf7c5e
writeKeyValue
protected void writeKeyValue(String key, String value) throws IOException
{    try {        stackObjects.getFirst().put(key, value);    } catch (JSONException jsone) {        throw new IOException(jsone.getMessage());    }}
726ea61a5b1b96d83528d355834b0f6f405a45ad7792b7e6e54647ecc061f3fb
writeKeyNull
protected void writeKeyNull(String key) throws IOException
{    try {        stackObjects.getFirst().put(key, JSONObject.NULL);    } catch (JSONException jsone) {        throw new IOException(jsone.getMessage());    }}
dbb6fbfddb764f0b0873edc7366608ae297c2c5c00c4678b270e602a975cf739
startArray
protected void startArray(String key, boolean nested, boolean newline) throws IOException
{    JSONArray array = new JSONArray();    stackArrays.push(array);}
733ad03d5579fddf0ff2e94f940de7f984a9e504ddf4508145db318e6ccaa7d0
closeArray
protected void closeArray(String key, boolean nested, boolean newline) throws IOException
{    try {        if (stackArrays.size() > 1) {            JSONArray array = stackArrays.pop();            if (nested) {                stackArrays.getFirst().put(array);            } else {                stackObjects.getFirst().put(key, array);            }        }    } catch (JSONException jsone) {        throw new IOException(jsone.getMessage());    }}
3b8f9294ebcea1fd9e841684b2849a0117d7c76a1a0c12943570166b52b08297
writeArrayValue
protected void writeArrayValue(String value) throws IOException
{    if (stackArrays.size() > 1) {        stackArrays.getFirst().put(value);    }}
3dd74faff298eee36bfda58164a057cefa2c207b3fc615c97c9c139eea0c8056
startObject
protected void startObject(String key) throws IOException
{    JSONObject object = new JSONObject();    stackObjects.push(object);}
8776948a45757aa6827a148c3af37e8eba731f4f75204c0e18c99dd81ac60477
closeObject
protected void closeObject(String key) throws IOException
{    try {        if (stackObjects.size() > 1) {            JSONObject object = stackObjects.pop();            stackObjects.getFirst().put(key, object);        }    } catch (JSONException jsone) {        throw new IOException(jsone.getMessage());    }}
b3aedc24582f9f9c7a7cdd5ea8549582c87229bad9480f191e678c7805eba6b2
generateJson
protected String generateJson() throws IOException
{    try {        return stackObjects.getFirst().toString(2);    } catch (JSONException jsone) {        throw new IOException(jsone.getMessage());    }}
b38a3ced3ac0c8bcce071e87cac154498d4bd6e75ae002e81c7468df8faf7c5e
writeKeyValue
protected void writeKeyValue(String key, String value) throws IOException
{    sb.append(printTabs() + "\"" + key + "\": " + quote(value) + ",\n");}
726ea61a5b1b96d83528d355834b0f6f405a45ad7792b7e6e54647ecc061f3fb
writeKeyNull
protected void writeKeyNull(String key) throws IOException
{    sb.append(printTabs() + "\"" + key + "\": null,\n");}
dbb6fbfddb764f0b0873edc7366608ae297c2c5c00c4678b270e602a975cf739
startArray
protected void startArray(String key, boolean nested, boolean newline) throws IOException
{    String name = (key != null) ? "\"" + key + "\": " : "";    String nl = (newline) ? "\n" : "";    sb.append(printTabs() + name + "[" + nl);    if (newline) {        this.tabCount++;    }}
733ad03d5579fddf0ff2e94f940de7f984a9e504ddf4508145db318e6ccaa7d0
closeArray
protected void closeArray(String key, boolean nested, boolean newline) throws IOException
{    if (sb.charAt(sb.length() - 1) == ',') {                sb.deleteCharAt(sb.length() - 1);    } else if (sb.charAt(sb.length() - 2) == ',') {                sb.deleteCharAt(sb.length() - 2);    }    String nl = (newline) ? printTabs() : "";    if (newline) {        this.tabCount++;    }    sb.append(nl + "],\n");}
b6597ccd1ac7d07e9587fdbd4f1afa03dafc37413e5764762887699b3502e3dc
writeArrayValue
protected void writeArrayValue(String value)
{    sb.append("\"" + value + "\",");}
3dd74faff298eee36bfda58164a057cefa2c207b3fc615c97c9c139eea0c8056
startObject
protected void startObject(String key) throws IOException
{    String name = "";    if (key != null) {        name = "\"" + key + "\": ";    }    sb.append(printTabs() + name + "{\n");    this.tabCount++;}
8776948a45757aa6827a148c3af37e8eba731f4f75204c0e18c99dd81ac60477
closeObject
protected void closeObject(String key) throws IOException
{    if (sb.charAt(sb.length() - 2) == ',') {                sb.deleteCharAt(sb.length() - 2);    }    this.tabCount--;    sb.append(printTabs() + "},\n");}
b3aedc24582f9f9c7a7cdd5ea8549582c87229bad9480f191e678c7805eba6b2
generateJson
protected String generateJson() throws IOException
{        sb.deleteCharAt(sb.length() - 1);        sb.deleteCharAt(sb.length() - 1);    return sb.toString();}
06e5711f20a2a5f6f97d4f4e4a61682b9f7b8a3d48899d547c1108c11e39ca43
printTabs
private String printTabs()
{    StringBuilder sb = new StringBuilder();    for (int i = 0; i < this.tabCount; i++) {        sb.append("\t");    }    return sb.toString();}
c358c3f309df0261260f57be3d1876f77fa761321a1c4e4dc873cc7add3c3f45
quote
private static String quote(String string) throws IOException
{    StringBuilder sb = new StringBuilder();    if (string == null || string.length() == 0) {        sb.append("\"\"");        return sb.toString();    }    char b;    char c = 0;    String hhhh;    int i;    int len = string.length();    sb.append('"');    for (i = 0; i < len; i += 1) {        b = c;        c = string.charAt(i);        switch(c) {            case '\\':            case '"':                sb.append('\\');                sb.append(c);                break;            case '/':                if (b == '<') {                    sb.append('\\');                }                sb.append(c);                break;            case '\b':                sb.append("\\b");                break;            case '\t':                sb.append("\\t");                break;            case '\n':                sb.append("\\n");                break;            case '\f':                sb.append("\\f");                break;            case '\r':                sb.append("\\r");                break;            default:                if (c < ' ' || (c >= '\u0080' && c < '\u00a0') || (c >= '\u2000' && c < '\u2100')) {                    sb.append("\\u");                    hhhh = Integer.toHexString(c);                    sb.append("0000", 0, 4 - hhhh.length());                    sb.append(hhhh);                } else {                    sb.append(c);                }        }    }    sb.append('"');    return sb.toString();}
1435491b460827c726e1967a8573b810dd4ff8c3edab4b9e710738249a4530fd
getJsonData
public String getJsonData(String url, Content content, Metadata metadata, ParseData parseData) throws IOException
{    this.url = url;    this.content = content;    this.metadata = metadata;    this.parseData = parseData;    return this.getJsonData();}
93d58885906e998892568e298b244e49679628bb82a36310f65115b066ae181b
getJsonData
public String getJsonData() throws IOException
{    long position = writer.getPosition();    try {                        writer.checkSize();        if (writer.getPosition() != position) {                        position = writer.getPosition();        }                URI id = writeResponse();        if (StringUtils.isNotBlank(metadata.get("_request_"))) {                        writeRequest(id);        }    } catch (IOException e) {                throw e;    } catch (ParseException e) {                        LOG.error("Can't get a valid date from: {}", url);    }    return null;}
7ea7ec44e24df4816e4f8f01adcd84633953a6cc43e214b19115a8845e44b271
writeResponse
protected URI writeResponse() throws IOException, ParseException
{    WARCRecordInfo record = new WARCRecordInfo();    record.setType(WARCConstants.WARCRecordType.response);    record.setUrl(getUrl());    record.setCreate14DigitDate(DateUtils.getLog14Date(Long.parseLong(metadata.get("nutch.fetch.time"))));    record.setMimetype(WARCConstants.HTTP_RESPONSE_MIMETYPE);    record.setRecordId(GENERATOR.getRecordID());    String IP = getResponseAddress();    if (StringUtils.isNotBlank(IP))        record.addExtraHeader(WARCConstants.HEADER_KEY_IP, IP);    if (ParseSegment.isTruncated(content))        record.addExtraHeader(WARCConstants.HEADER_KEY_TRUNCATED, "unspecified");    ByteArrayOutputStream output = new ByteArrayOutputStream();    String httpHeaders = metadata.get("_response.headers_");    httpHeaders = WARCUtils.fixHttpHeaders(httpHeaders, content.getContent().length);    if (StringUtils.isNotBlank(httpHeaders)) {        output.write(httpHeaders.getBytes());    } else {                        record.setType(WARCConstants.WARCRecordType.resource);        record.setMimetype(content.getContentType());    }    output.write(getResponseContent().getBytes());    record.setContentLength(output.size());    record.setContentStream(new ByteArrayInputStream(output.toByteArray()));    if (output.size() > 0) {                        writer.writeRecord(record);    }    return record.getRecordId();}
a9bf14cc0ebe1ac4679267f7a1e3cfdc8a09b87bdec360893776b763e5dfd582
writeRequest
protected URI writeRequest(URI id) throws IOException, ParseException
{    WARCRecordInfo record = new WARCRecordInfo();    record.setType(WARCConstants.WARCRecordType.request);    record.setUrl(getUrl());    record.setCreate14DigitDate(DateUtils.getLog14Date(Long.parseLong(metadata.get("nutch.fetch.time"))));    record.setMimetype(WARCConstants.HTTP_REQUEST_MIMETYPE);    record.setRecordId(GENERATOR.getRecordID());    if (id != null) {        ANVLRecord headers = new ANVLRecord();        headers.addLabelValue(WARCConstants.HEADER_KEY_CONCURRENT_TO, '<' + id.toString() + '>');        record.setExtraHeaders(headers);    }    ByteArrayOutputStream output = new ByteArrayOutputStream();    output.write(metadata.get("_request_").getBytes());    record.setContentLength(output.size());    record.setContentStream(new ByteArrayInputStream(output.toByteArray()));    writer.writeRecord(record);    return record.getRecordId();}
b3aedc24582f9f9c7a7cdd5ea8549582c87229bad9480f191e678c7805eba6b2
generateJson
protected String generateJson() throws IOException
{    return null;}
b38a3ced3ac0c8bcce071e87cac154498d4bd6e75ae002e81c7468df8faf7c5e
writeKeyValue
protected void writeKeyValue(String key, String value) throws IOException
{    throw new NotImplementedException();}
726ea61a5b1b96d83528d355834b0f6f405a45ad7792b7e6e54647ecc061f3fb
writeKeyNull
protected void writeKeyNull(String key) throws IOException
{    throw new NotImplementedException();}
dbb6fbfddb764f0b0873edc7366608ae297c2c5c00c4678b270e602a975cf739
startArray
protected void startArray(String key, boolean nested, boolean newline) throws IOException
{    throw new NotImplementedException();}
733ad03d5579fddf0ff2e94f940de7f984a9e504ddf4508145db318e6ccaa7d0
closeArray
protected void closeArray(String key, boolean nested, boolean newline) throws IOException
{    throw new NotImplementedException();}
3b8f9294ebcea1fd9e841684b2849a0117d7c76a1a0c12943570166b52b08297
writeArrayValue
protected void writeArrayValue(String value) throws IOException
{    throw new NotImplementedException();}
3dd74faff298eee36bfda58164a057cefa2c207b3fc615c97c9c139eea0c8056
startObject
protected void startObject(String key) throws IOException
{    throw new NotImplementedException();}
8776948a45757aa6827a148c3af37e8eba731f4f75204c0e18c99dd81ac60477
closeObject
protected void closeObject(String key) throws IOException
{    throw new NotImplementedException();}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    if (writer != null)        try {            writer.close();        } catch (IOException e) {            throw new RuntimeException(e);        }}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    int c = in.read();    int value = c;    if (    c != -1 && !(XMLChar.isValid(c)))        value = 'X';    else if (lastBad && c == '<') {                in.mark(1);        if (in.read() != '/')            value = 'X';        in.reset();    }    lastBad = (c == 65533);    return value;}
5b278cce8f760eeae625892d05dbf15b58becec33f0ffc51fc725304dfbf2bf9
read
public int read(char[] cbuf, int off, int len) throws IOException
{    int n = in.read(cbuf, off, len);    if (n != -1) {        for (int i = 0; i < n; i++) {            char c = cbuf[off + i];            char value = c;            if (            !(XMLChar.isValid(c)))                value = 'X';            else if (lastBad && c == '<') {                                if (i != n - 1 && cbuf[off + i + 1] != '/')                    value = 'X';            }            lastBad = (c == 65533);            cbuf[off + i] = value;        }    }    return n;}
686b4f1a06a8bb9630ac6477ed7787995e6d98e9f8bf860cc6884714382ca53f
startElement
public void startElement(String namespaceURI, String localName, String qName, Attributes atts) throws SAXException
{    if ("Topic".equals(qName)) {        curSection = atts.getValue("r:id");    } else if ("ExternalPage".equals(qName)) {                if ((!includeAdult) && curSection.startsWith("Top/Adult")) {            return;        }        if (topicPattern != null && !topicPattern.matcher(curSection).matches()) {            return;        }                        String url = atts.getValue("about");        int hashValue = MD5Hash.digest(url).hashCode();        hashValue = Math.abs(hashValue ^ hashSkew);        if ((hashValue % subsetDenom) != 0) {            return;        }                curURL = url;    } else if (curURL != null && "d:Title".equals(qName)) {        titlePending = true;    } else if (curURL != null && "d:Description".equals(qName)) {        descPending = true;    }}
288bdea956d5ad9f7d7abbdafcb750e640e9b01ef5a9e105b9e85fee7da2988e
characters
public void characters(char[] ch, int start, int length)
{    if (titlePending) {        title.append(ch, start, length);    } else if (descPending) {        desc.append(ch, start, length);    }}
99a81544fa424df96dc7c289f6b1759363cfe8602fc9b0a515859e7204002e41
endElement
public void endElement(String namespaceURI, String localName, String qName) throws SAXException
{    if (curURL != null) {        if ("ExternalPage".equals(qName)) {                                                            System.out.println(curURL);            pages++;                        if (title.length() > 0) {                title.delete(0, title.length());            }            if (desc.length() > 0) {                desc.delete(0, desc.length());            }                        curURL = null;        } else if ("d:Title".equals(qName)) {            titlePending = false;        } else if ("d:Description".equals(qName)) {            descPending = false;        }    }}
650acbeff5b3daebebc4c8c0d528218d43656649fb7f6a54b9a4ab05e8a4ab18
startDocument
public void startDocument()
{    LOG.info("Begin parse");}
727579c273ae7aba0964d48ccd50031831708046cce09a494fa75c4f78f075c4
endDocument
public void endDocument()
{    LOG.info("Completed parse.  Found " + pages + " pages.");}
b2f272e09c1cb5e2753e1336905f73e1c5d739510484927f3d8899c5a6c3e63f
setDocumentLocator
public void setDocumentLocator(Locator locator)
{    location = locator;}
91eb17f40d4ab1872cae3bd263875d7e73a689648a2f45a534356b86f0066865
error
public void error(SAXParseException spe)
{    if (LOG.isErrorEnabled()) {        LOG.error("Error: " + spe.toString() + ": " + spe.getMessage());    }}
251f92d8b2b1eaf246af246693587802a08624d0e66a9643250c2244b1b5ddf0
warning
public void warning(SAXParseException spe)
{    if (LOG.isWarnEnabled()) {        LOG.warn("Warning: " + spe.toString() + ": " + spe.getMessage());    }}
001fbd752f2090fe2bd7f5725c60afdb1b86a02bd7897cee38fa2f0f549d8b3e
parseDmozFile
public void parseDmozFile(File dmozFile, int subsetDenom, boolean includeAdult, int skew, Pattern topicPattern) throws IOException, SAXException, ParserConfigurationException
{    SAXParserFactory parserFactory = SAXParserFactory.newInstance();    SAXParser parser = parserFactory.newSAXParser();    XMLReader reader = parser.getXMLReader();        RDFProcessor rp = new RDFProcessor(reader, subsetDenom, includeAdult, skew, topicPattern);    reader.setContentHandler(rp);    reader.setErrorHandler(rp);    LOG.info("skew = " + rp.hashSkew);        try (XMLCharFilter in = new XMLCharFilter(new BufferedReader(new InputStreamReader(new BufferedInputStream(new FileInputStream(dmozFile)), "UTF-8")))) {        InputSource is = new InputSource(in);        reader.parse(is);    } catch (Exception e) {        if (LOG.isErrorEnabled()) {            LOG.error(e.toString());        }        System.exit(0);    }}
48ec415947807ca09e7a713c452782b99d52d0a0ef29bd6d0ae335e11c540726
addTopicsFromFile
private static void addTopicsFromFile(String topicFile, Vector<String> topics) throws IOException
{    try (BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(topicFile), "UTF-8"))) {        String line = null;        while ((line = in.readLine()) != null) {            topics.addElement(line);        }    } catch (Exception e) {        if (LOG.isErrorEnabled()) {            LOG.error(e.toString());        }        System.exit(0);    }}
6538d76a086933ae50b4ee6e131d43b17cf0047fe2ae644bcffc294ff69a38d9
main
public static void main(String[] argv) throws Exception
{    if (argv.length < 1) {        System.err.println("Usage: DmozParser <dmoz_file> [-subset <subsetDenominator>] [-includeAdultMaterial] [-skew skew] [-topicFile <topic list file>] [-topic <topic> [-topic <topic> [...]]]");        return;    }                    int subsetDenom = 1;    int skew = 0;    String dmozFile = argv[0];    boolean includeAdult = false;    Pattern topicPattern = null;    Vector<String> topics = new Vector<>();    Configuration conf = NutchConfiguration.create();    try (FileSystem fs = FileSystem.get(conf)) {        for (int i = 1; i < argv.length; i++) {            if ("-includeAdultMaterial".equals(argv[i])) {                includeAdult = true;            } else if ("-subset".equals(argv[i])) {                subsetDenom = Integer.parseInt(argv[i + 1]);                i++;            } else if ("-topic".equals(argv[i])) {                topics.addElement(argv[i + 1]);                i++;            } else if ("-topicFile".equals(argv[i])) {                addTopicsFromFile(argv[i + 1], topics);                i++;            } else if ("-skew".equals(argv[i])) {                skew = Integer.parseInt(argv[i + 1]);                i++;            }        }        DmozParser parser = new DmozParser();        if (!topics.isEmpty()) {            String regExp = "^(";            int j = 0;            for (; j < topics.size() - 1; ++j) {                regExp = regExp.concat(topics.get(j));                regExp = regExp.concat("|");            }            regExp = regExp.concat(topics.get(j));            regExp = regExp.concat(").*");            LOG.info("Topic selection pattern = " + regExp);            topicPattern = Pattern.compile(regExp);        }        parser.parseDmozFile(new File(dmozFile), subsetDenom, includeAdult, skew, topicPattern);    }}
cac3c50415b658beff33b1219fff5554fd9b0a7bbe1c95cd265e27098140bc91
dump
public void dump(File outputDir, File segmentRootDir, String[] mimeTypes, boolean flatDir, boolean mimeTypeStats, boolean reverseURLDump) throws Exception
{    if (mimeTypes == null)        LOG.info("Accepting all mimetypes.");        Map<String, Integer> typeCounts = new HashMap<>();        Map<String, Integer> filteredCounts = new HashMap<>();    Configuration conf = NutchConfiguration.create();    int fileCount = 0;    File[] segmentDirs = segmentRootDir.listFiles(file -> file.canRead() && file.isDirectory());    if (segmentDirs == null) {        LOG.error("No segment directories found in [" + segmentRootDir.getAbsolutePath() + "]");        return;    }    for (File segment : segmentDirs) {        LOG.info("Processing segment: [" + segment.getAbsolutePath() + "]");        DataOutputStream doutputStream = null;        Map<String, String> filenameToUrl = new HashMap<String, String>();        File segmentDir = new File(segment.getAbsolutePath(), Content.DIR_NAME);        File[] partDirs = segmentDir.listFiles(file -> file.canRead() && file.isDirectory());        if (partDirs == null) {            LOG.warn("Skipping Corrupt Segment: [{}]", segment.getAbsolutePath());            continue;        }        for (File partDir : partDirs) {            try (FileSystem fs = FileSystem.get(conf)) {                String segmentPath = partDir + "/data";                Path file = new Path(segmentPath);                if (!new File(file.toString()).exists()) {                    LOG.warn("Skipping segment: [" + segmentPath + "]: no data directory present");                    continue;                }                SequenceFile.Reader reader = new SequenceFile.Reader(conf, SequenceFile.Reader.file(file));                Writable key = (Writable) reader.getKeyClass().getConstructor().newInstance();                Content content = null;                while (reader.next(key)) {                    content = new Content();                    reader.getCurrentValue(content);                    String url = key.toString();                    String baseName = FilenameUtils.getBaseName(url);                    String extension = FilenameUtils.getExtension(url);                    if (extension == null || (extension != null && extension.equals(""))) {                        extension = "html";                    }                    ByteArrayInputStream bas = null;                    Boolean filter = false;                    try {                        bas = new ByteArrayInputStream(content.getContent());                        String mimeType = new Tika().detect(content.getContent());                        collectStats(typeCounts, mimeType);                        if (mimeType != null) {                            if (mimeTypes == null || Arrays.asList(mimeTypes).contains(mimeType)) {                                collectStats(filteredCounts, mimeType);                                filter = true;                            }                        }                    } catch (Exception e) {                        e.printStackTrace();                        LOG.warn("Tika is unable to detect type for: [" + url + "]");                    } finally {                        if (bas != null) {                            try {                                bas.close();                            } catch (Exception ignore) {                            }                        }                    }                    if (filter) {                        if (!mimeTypeStats) {                            String md5Ofurl = DumpFileUtil.getUrlMD5(url);                            String fullDir = outputDir.getAbsolutePath();                            if (!flatDir && !reverseURLDump) {                                fullDir = DumpFileUtil.createTwoLevelsDirectory(fullDir, md5Ofurl);                            }                            if (!Strings.isNullOrEmpty(fullDir)) {                                String outputFullPath;                                if (reverseURLDump) {                                    String[] reversedURL = TableUtil.reverseUrl(url).split(":");                                    reversedURL[0] = reversedURL[0].replace('.', '/');                                    String reversedURLPath = reversedURL[0] + "/" + DigestUtils.sha256Hex(url).toUpperCase();                                    outputFullPath = String.format("%s/%s", fullDir, reversedURLPath);                                                                        String[] splitPath = outputFullPath.split("/");                                    File fullOutputDir = new File(org.apache.commons.lang3.StringUtils.join(Arrays.copyOf(splitPath, splitPath.length - 1), "/"));                                    if (!fullOutputDir.exists()) {                                        fullOutputDir.mkdirs();                                    }                                } else {                                    outputFullPath = String.format("%s/%s", fullDir, DumpFileUtil.createFileName(md5Ofurl, baseName, extension));                                }                                filenameToUrl.put(outputFullPath, url);                                File outputFile = new File(outputFullPath);                                if (!outputFile.exists()) {                                    LOG.info("Writing: [" + outputFullPath + "]");                                                                        FileOutputStream output = null;                                    try {                                        output = new FileOutputStream(outputFile);                                        IOUtils.write(content.getContent(), output);                                    } catch (Exception e) {                                        LOG.warn("Write Error: [" + outputFullPath + "]");                                        e.printStackTrace();                                    } finally {                                        if (output != null) {                                            output.flush();                                            try {                                                output.close();                                            } catch (Exception ignore) {                                            }                                        }                                    }                                    fileCount++;                                } else {                                    LOG.info("Skipping writing: [" + outputFullPath + "]: file already exists");                                }                            }                        }                    }                }                reader.close();            } finally {                if (doutputStream != null) {                    try {                        doutputStream.close();                    } catch (Exception ignore) {                    }                }            }        }                String filenameToUrlFilePath = String.format("%s/%s_filenameToUrl.json", outputDir.getAbsolutePath(), segment.getName());        new ObjectMapper().writeValue(new File(filenameToUrlFilePath), filenameToUrl);    }    LOG.info("Dumper File Stats: " + DumpFileUtil.displayFileTypes(typeCounts, filteredCounts));    if (mimeTypeStats) {        System.out.println("Dumper File Stats: " + DumpFileUtil.displayFileTypes(typeCounts, filteredCounts));    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{        Option helpOpt = new Option("h", "help", false, "show this help message");        @SuppressWarnings("static-access")    Option outputOpt = OptionBuilder.withArgName("outputDir").hasArg().withDescription("output directory (which will be created) to host the raw data").create("outputDir");    @SuppressWarnings("static-access")    Option segOpt = OptionBuilder.withArgName("segment").hasArgs().withDescription("the segment(s) to use").create("segment");    @SuppressWarnings("static-access")    Option mimeOpt = OptionBuilder.withArgName("mimetype").hasArgs().withDescription("an optional list of mimetypes to dump, excluding all others. Defaults to all.").create("mimetype");    @SuppressWarnings("static-access")    Option mimeStat = OptionBuilder.withArgName("mimeStats").withDescription("only display mimetype stats for the segment(s) instead of dumping file.").create("mimeStats");    @SuppressWarnings("static-access")    Option dirStructureOpt = OptionBuilder.withArgName("flatdir").withDescription("optionally specify that the output directory should only contain files.").create("flatdir");    @SuppressWarnings("static-access")    Option reverseURLOutput = OptionBuilder.withArgName("reverseUrlDirs").withDescription("optionally specify to use reverse URL folders for output structure.").create("reverseUrlDirs");        Options options = new Options();    options.addOption(helpOpt);    options.addOption(outputOpt);    options.addOption(segOpt);    options.addOption(mimeOpt);    options.addOption(mimeStat);    options.addOption(dirStructureOpt);    options.addOption(reverseURLOutput);    CommandLineParser parser = new GnuParser();    try {        CommandLine line = parser.parse(options, args);        if (line.hasOption("help") || !line.hasOption("outputDir") || (!line.hasOption("segment"))) {            HelpFormatter formatter = new HelpFormatter();            formatter.printHelp("FileDumper", options, true);            return;        }        File outputDir = new File(line.getOptionValue("outputDir"));        File segmentRootDir = new File(line.getOptionValue("segment"));        String[] mimeTypes = line.getOptionValues("mimetype");        boolean flatDir = line.hasOption("flatdir");        boolean shouldDisplayStats = false;        if (line.hasOption("mimeStats"))            shouldDisplayStats = true;        boolean reverseURLDump = false;        if (line.hasOption("reverseUrlDirs"))            reverseURLDump = true;        if (!outputDir.exists()) {            LOG.warn("Output directory: [" + outputDir.getAbsolutePath() + "]: does not exist, creating it.");            if (!shouldDisplayStats) {                if (!outputDir.mkdirs())                    throw new Exception("Unable to create: [" + outputDir.getAbsolutePath() + "]");            }        }        FileDumper dumper = new FileDumper();        dumper.dump(outputDir, segmentRootDir, mimeTypes, flatDir, shouldDisplayStats, reverseURLDump);    } catch (Exception e) {        LOG.error("FileDumper: " + StringUtils.stringifyException(e));        e.printStackTrace();        return;    }}
979aca2c0c5f38d1e2334f86841d363b39fd0f4c3300974a092fd04ff65299fd
collectStats
private void collectStats(Map<String, Integer> typeCounts, String mimeType)
{    typeCounts.put(mimeType, typeCounts.containsKey(mimeType) ? typeCounts.get(mimeType) + 1 : 1);}
a3dc3e81487bb799f6347e12dbd00ad08d543d6c0fada2cea56cb3520c0eaf7b
setup
public void setup(Mapper<WritableComparable<?>, Text, Text, Generator.SelectorEntry>.Context context)
{    Configuration conf = context.getConfiguration();    defaultInterval = conf.getInt("db.fetch.interval.default", 0);    scfilters = new ScoringFilters(conf);    if (conf.getBoolean(FILTER_KEY, false)) {        filters = new URLFilters(conf);    }    if (conf.getBoolean(NORMALIZE_KEY, false)) {        normalizers = new URLNormalizers(conf, URLNormalizers.SCOPE_INJECT);    }}
984f2eedfb5053113f4f5747e0c8df9a363a81883e76c524d2d0962e655a0f46
map
public void map(WritableComparable<?> key, Text value, Context context) throws IOException, InterruptedException
{        String urlString = value.toString();    try {        if (normalizers != null) {            urlString = normalizers.normalize(urlString, URLNormalizers.SCOPE_INJECT);        }        if (urlString != null && filters != null) {            urlString = filters.filter(urlString);        }        if (urlString != null) {            url.set(urlString);            scfilters.injectedScore(url, datum);        }    } catch (Exception e) {        LOG.warn("Error adding url '" + value.toString() + "', skipping: " + StringUtils.stringifyException(e));        return;    }    if (urlString == null) {        if (LOG.isDebugEnabled()) {            LOG.debug("- skipping " + value.toString());        }        return;    }    entry.datum = datum;    entry.url = url;        entry.datum.setFetchInterval(defaultInterval);    context.write(url, entry);}
91ea47afebba2595608d09ce12ef675c52ed08ac3f6901b09afc6400d067b31c
reduce
public void reduce(Text key, Iterable<Generator.SelectorEntry> values, Context context) throws IOException, InterruptedException
{            HashMap<Text, CrawlDatum> unique = new HashMap<>();    for (Generator.SelectorEntry entry : values) {        unique.put(entry.url, entry.datum);    }        for (Entry<Text, CrawlDatum> e : unique.entrySet()) {        context.write(e.getKey(), e.getValue());    }}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    if (args.length < 2) {        System.err.println("Usage: FreeGenerator <inputDir> <segmentsDir> [-filter] [-normalize]");        System.err.println("\tinputDir\tinput directory containing one or more input files.");        System.err.println("\t\tEach text file contains a list of URLs, one URL per line");        System.err.println("\tsegmentsDir\toutput directory, where new segment will be created");        System.err.println("\t-filter\trun current URLFilters on input URLs");        System.err.println("\t-normalize\trun current URLNormalizers on input URLs");        return -1;    }    boolean filter = false;    boolean normalize = false;    if (args.length > 2) {        for (int i = 2; i < args.length; i++) {            if (args[i].equals("-filter")) {                filter = true;            } else if (args[i].equals("-normalize")) {                normalize = true;            } else {                LOG.error("Unknown argument: " + args[i] + ", exiting ...");                return -1;            }        }    }    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    long start = System.currentTimeMillis();    LOG.info("FreeGenerator: starting at " + sdf.format(start));    Job job = NutchJob.getInstance(getConf());    Configuration conf = job.getConfiguration();    conf.setBoolean(FILTER_KEY, filter);    conf.setBoolean(NORMALIZE_KEY, normalize);    FileInputFormat.addInputPath(job, new Path(args[0]));    job.setInputFormatClass(TextInputFormat.class);    job.setJarByClass(FG.class);    job.setMapperClass(FG.FGMapper.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(Generator.SelectorEntry.class);    job.setPartitionerClass(URLPartitioner.class);    job.setReducerClass(FG.FGReducer.class);    String segName = Generator.generateSegmentName();    job.setNumReduceTasks(Integer.parseInt(conf.get("mapreduce.job.maps")));    job.setOutputFormatClass(SequenceFileOutputFormat.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(CrawlDatum.class);    job.setSortComparatorClass(Generator.HashComparator.class);    FileOutputFormat.setOutputPath(job, new Path(args[1], new Path(segName, CrawlDatum.GENERATE_DIR_NAME)));    try {        boolean success = job.waitForCompletion(true);        if (!success) {            String message = "FreeGenerator job did not succeed, job status:" + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);            throw new RuntimeException(message);        }    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error("FAILED: " + StringUtils.stringifyException(e));        return -1;    }    long end = System.currentTimeMillis();    LOG.info("FreeGenerator: finished at " + sdf.format(end) + ", elapsed: " + TimingUtil.elapsedTime(start, end));    return 0;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int res = ToolRunner.run(NutchConfiguration.create(), new FreeGenerator(), args);    System.exit(res);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    numTotal.incrementAndGet();    String host = URLUtil.getHost(url);    long start = System.currentTimeMillis();    try {                        InetAddress.getByName(host);        LOG.info("Resolved: " + host);        numResolved.incrementAndGet();    } catch (Exception uhe) {        LOG.info("Error Resolving: " + host);        numErrored.incrementAndGet();    }    long end = System.currentTimeMillis();    long total = (end - start);    totalTime.addAndGet(total);    LOG.info(", " + total + " millis");}
646e2180ff8b6a4f5aee019b1d11d7fba99445286525acae3ec3bd9926a5901c
resolveUrls
public void resolveUrls()
{    try {                pool = Executors.newFixedThreadPool(numThreads);                BufferedReader buffRead = new BufferedReader(new FileReader(new File(urlsFile)));        String urlStr = null;        while ((urlStr = buffRead.readLine()) != null) {                        LOG.info("Starting: " + urlStr);            pool.execute(new ResolverThread(urlStr));        }                        buffRead.close();        pool.awaitTermination(60, TimeUnit.SECONDS);    } catch (Exception e) {                pool.shutdownNow();        LOG.info(StringUtils.stringifyException(e));    }        pool.shutdown();    LOG.info("Total: " + numTotal.get() + ", Resovled: " + numResolved.get() + ", Errored: " + numErrored.get() + ", Average Time: " + totalTime.get() / numTotal.get());}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    Options options = new Options();    OptionBuilder.withArgName("help");    OptionBuilder.withDescription("show this help message");    Option helpOpts = OptionBuilder.create("help");    options.addOption(helpOpts);    OptionBuilder.withArgName("urls");    OptionBuilder.hasArg();    OptionBuilder.withDescription("the urls file to check");    Option urlOpts = OptionBuilder.create("urls");    options.addOption(urlOpts);    OptionBuilder.withArgName("numThreads");    OptionBuilder.hasArgs();    OptionBuilder.withDescription("the number of threads to use");    Option numThreadOpts = OptionBuilder.create("numThreads");    options.addOption(numThreadOpts);    CommandLineParser parser = new GnuParser();    try {                CommandLine line = parser.parse(options, args);        if (line.hasOption("help") || !line.hasOption("urls")) {            HelpFormatter formatter = new HelpFormatter();            formatter.printHelp("ResolveUrls", options);            return;        }                String urls = line.getOptionValue("urls");        int numThreads = 100;        String numThreadsStr = line.getOptionValue("numThreads");        if (numThreadsStr != null) {            numThreads = Integer.parseInt(numThreadsStr);        }        ResolveUrls resolve = new ResolveUrls(urls, numThreads);        resolve.resolveUrls();    } catch (Exception e) {        LOG.error("ResolveUrls: " + StringUtils.stringifyException(e));    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{}
828efea1a07a16b05f247248072a0d2d0eb481455453c583f4002cb29e76342d
setup
public void setup(Mapper<Text, Writable, Text, NutchWritable>.Context context)
{}
4c9ec82e8777bee39c94eaffbd42f3bf891ce1ff9da91c3080a6b85972806e5d
map
public void map(Text key, Writable value, Context context) throws IOException, InterruptedException
{    context.write(key, new NutchWritable(value));}
949e1c8251926ca82f17b33e3b7ac94a31ce4f15358dd8eebc86c27f35dff72b
setup
public void setup(Reducer<Text, NutchWritable, NullWritable, WARCWritable>.Context context)
{}
3a173d62b9c64632e8a5b3717dd7b139e87082c27f02e1c5ea40d48edc27b47b
reduce
public void reduce(Text key, Iterable<NutchWritable> values, Context context) throws IOException, InterruptedException
{    Content content = null;    CrawlDatum cd = null;    SimpleDateFormat warcdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'", Locale.ENGLISH);        for (NutchWritable val : values) {                final Writable value = val.get();        if (value instanceof Content) {            content = (Content) value;            continue;        }        if (value instanceof CrawlDatum) {            cd = (CrawlDatum) value;            continue;        }    }        if (content == null) {        LOG.info("Missing content for {}", key);        context.getCounter("WARCExporter", "missing content").increment(1);        return;    }    if (cd == null) {        LOG.info("Missing fetch datum for {}", key);        context.getCounter("WARCExporter", "missing metadata").increment(1);        return;    }        String headersVerbatim = content.getMetadata().get("_response.headers_");    headersVerbatim = WARCUtils.fixHttpHeaders(headersVerbatim, content.getContent().length);    byte[] httpheaders = new byte[0];    if (StringUtils.isNotBlank(headersVerbatim)) {                if (!headersVerbatim.endsWith(CRLF + CRLF)) {            headersVerbatim += CRLF + CRLF;        }        httpheaders = headersVerbatim.getBytes();    }    StringBuilder buffer = new StringBuilder();    buffer.append(WARCRecord.WARC_VERSION);    buffer.append(CRLF);    buffer.append("WARC-Record-ID").append(": ").append("<urn:uuid:").append(UUID.randomUUID().toString()).append(">").append(CRLF);    int contentLength = 0;    if (content != null) {        contentLength = content.getContent().length;    }        contentLength += httpheaders.length;    buffer.append("Content-Length").append(": ").append(Integer.toString(contentLength)).append(CRLF);    Date fetchedDate = new Date(cd.getFetchTime());    buffer.append("WARC-Date").append(": ").append(warcdf.format(fetchedDate)).append(CRLF);            String WARCTypeValue = "resource";    if (StringUtils.isNotBlank(headersVerbatim)) {        WARCTypeValue = "response";    }    buffer.append("WARC-Type").append(": ").append(WARCTypeValue).append(CRLF);        String IP = content.getMetadata().get("_ip_");    if (StringUtils.isNotBlank(IP)) {        buffer.append("WARC-IP-Address").append(": ").append("IP").append(CRLF);    }        String status = CrawlDatum.getStatusName(cd.getStatus());    if (status.equalsIgnoreCase("STATUS_FETCH_SUCCESS") && ParseSegment.isTruncated(content)) {        buffer.append("WARC-Truncated").append(": ").append("unspecified").append(CRLF);    }        try {        String normalised = key.toString().replaceAll(" ", "%20");        URI uri = URI.create(normalised);        buffer.append("WARC-Target-URI").append(": ").append(uri.toASCIIString()).append(CRLF);    } catch (Exception e) {        LOG.error("Invalid URI {} ", key);        context.getCounter("WARCExporter", "invalid URI").increment(1);        return;    }        if (WARCTypeValue.equals("response")) {        buffer.append("Content-Type: application/http; msgtype=response").append(CRLF);    }        ByteArrayOutputStream bos = new ByteArrayOutputStream();        bos.write(buffer.toString().getBytes("UTF-8"));    bos.write(CRLF_BYTES);        bos.write(httpheaders);        if (content.getContent() != null) {        bos.write(content.getContent());    }    bos.write(CRLF_BYTES);    bos.write(CRLF_BYTES);    try {        DataInput in = new DataInputStream(new ByteArrayInputStream(bos.toByteArray()));        WARCRecord record = new WARCRecord(in);        context.write(NullWritable.get(), new WARCWritable(record));        context.getCounter("WARCExporter", "records generated").increment(1);    } catch (IOException | IllegalStateException exception) {        LOG.error("Exception when generating WARC record for {} : {}", key, exception.getMessage());        context.getCounter("WARCExporter", "exception").increment(1);    }}
253aa263f85b203b991e430c62be4dc017c47966587a2266584d3102066ed8bb
generateWARC
public int generateWARC(String output, List<Path> segments) throws IOException
{    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    long start = System.currentTimeMillis();    LOG.info("WARCExporter: starting at {}", sdf.format(start));    final Job job = NutchJob.getInstance(getConf());    job.setJobName("warc-exporter " + output);    for (final Path segment : segments) {        LOG.info("warc-exporter: adding segment: {}", segment);        FileInputFormat.addInputPath(job, new Path(segment, Content.DIR_NAME));        FileInputFormat.addInputPath(job, new Path(segment, CrawlDatum.FETCH_DIR_NAME));    }    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setJarByClass(WARCMapReduce.class);    job.setMapperClass(WARCMapReduce.WARCMapper.class);    job.setReducerClass(WARCMapReduce.WARCReducer.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(NutchWritable.class);    FileOutputFormat.setOutputPath(job, new Path(output));        job.setOutputFormatClass(WARCOutputFormat.class);    job.setOutputKeyClass(NullWritable.class);    job.setOutputValueClass(WARCWritable.class);    try {        boolean success = job.waitForCompletion(true);        if (!success) {            String message = "WARCExporter job did not succeed, job status:" + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);            throw new RuntimeException(message);        }        LOG.info(job.getCounters().toString());        long end = System.currentTimeMillis();        LOG.info("WARCExporter: finished at {}, elapsed: {}", sdf.format(end), TimingUtil.elapsedTime(start, end));    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error("WARCExporter job failed: {}", e.getMessage());        return -1;    }    return 0;}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    if (args.length < 2) {        System.err.println("Usage: WARCExporter <output> (<segment> ... | -dir <segments>)");        return -1;    }    final List<Path> segments = new ArrayList<>();    for (int i = 1; i < args.length; i++) {        if (args[i].equals("-dir")) {            Path dir = new Path(args[++i]);            FileSystem fs = dir.getFileSystem(getConf());            FileStatus[] fstats = fs.listStatus(dir, HadoopFSUtil.getPassDirectoriesFilter(fs));            Path[] files = HadoopFSUtil.getPaths(fstats);            for (Path p : files) {                segments.add(p);            }        } else {            segments.add(new Path(args[i]));        }    }    return generateWARC(args[0], segments);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    final int res = ToolRunner.run(NutchConfiguration.create(), new WARCExporter(), args);    System.exit(res);}
8b8ecc75f4422ba53be12d06af868ff5af3c2bb7be7a7004c6988a57927c942c
getWARCInfoContent
public static final ANVLRecord getWARCInfoContent(Configuration conf)
{    ANVLRecord record = new ANVLRecord();        record.addLabelValue(FORMAT, "WARC File Format 1.0");    record.addLabelValue(CONFORMS_TO, "http://bibnum.bnf.fr/WARC/WARC_ISO_28500_version1_latestdraft.pdf");    record.addLabelValue(SOFTWARE, conf.get("http.agent.name", ""));    record.addLabelValue(HTTP_HEADER_USER_AGENT, getAgentString(conf.get("http.agent.name", ""), conf.get("http.agent.version", ""), conf.get("http.agent.description", ""), conf.get("http.agent.url", ""), conf.get("http.agent.email", "")));    record.addLabelValue(HTTP_HEADER_FROM, conf.get("http.agent.email", ""));    try {        record.addLabelValue(HOSTNAME, getHostname(conf));        record.addLabelValue(IP, getIPAddress(conf));    } catch (UnknownHostException ignored) {        }        record.addLabelValue(ROBOTS, "classic");    record.addLabelValue(OPERATOR, conf.get("http.agent.email", ""));    return record;}
026d5c3519515329546516f5378999c3310111041710bb35cb5d83984351e6ad
getHostname
public static final String getHostname(Configuration conf) throws UnknownHostException
{    return StringUtil.isEmpty(conf.get("http.agent.host", "")) ? InetAddress.getLocalHost().getHostName() : conf.get("http.agent.host");}
6095107feca3dfa0955c88d094dd4d4b11377c43bd5db90cb4a27885ea82b988
getIPAddress
public static final String getIPAddress(Configuration conf) throws UnknownHostException
{    return InetAddress.getLocalHost().getHostAddress();}
8886fd22e9383f6826068952cdbb437e4a39b1f75f648b63f60d8d97da28e847
toByteArray
public static final byte[] toByteArray(HttpHeaders headers) throws IOException
{    ByteArrayOutputStream out = new ByteArrayOutputStream();    headers.write(out);    return out.toByteArray();}
1527d8cebf00f57fa903ffadf4ddc7dacad2908a5c8dd5980c7c140bdc2b7fe5
getAgentString
public static final String getAgentString(String name, String version, String description, String URL, String email)
{    StringBuffer buf = new StringBuffer();    buf.append(name);    if (version != null) {        buf.append("/").append(version);    }    if (((description != null) && (description.length() != 0)) || ((email != null) && (email.length() != 0)) || ((URL != null) && (URL.length() != 0))) {        buf.append(" (");        if ((description != null) && (description.length() != 0)) {            buf.append(description);            if ((URL != null) || (email != null))                buf.append("; ");        }        if ((URL != null) && (URL.length() != 0)) {            buf.append(URL);            if (email != null)                buf.append("; ");        }        if ((email != null) && (email.length() != 0))            buf.append(email);        buf.append(")");    }    return buf.toString();}
8891c2129aa633d0eebe22681ea6d2460f14eebe01ec58ca98590fb72338b772
docToMetadata
public static final WARCRecordInfo docToMetadata(NutchDocument doc) throws UnsupportedEncodingException
{    WARCRecordInfo record = new WARCRecordInfo();    record.setType(WARCConstants.WARCRecordType.metadata);    record.setUrl((String) doc.getFieldValue("id"));    record.setCreate14DigitDate(DateUtils.get14DigitDate((Date) doc.getFieldValue("tstamp")));    record.setMimetype("application/warc-fields");    record.setRecordId(generator.getRecordID());        ANVLRecord metadata = new ANVLRecord();    for (String field : doc.getFieldNames()) {        List<Object> values = doc.getField(field).getValues();        for (Object value : values) {            if (value instanceof Date) {                metadata.addLabelValue(field, DateUtils.get14DigitDate());            } else {                metadata.addLabelValue(field, (String) value);            }        }    }    record.setContentLength(metadata.getLength());    record.setContentStream(new ByteArrayInputStream(metadata.getUTF8Bytes()));    return record;}
1503f60b010f0f3f600722455dbf007ac3a2cf2dc1b9881f5bd1a5438b13bdb9
fixHttpHeaders
public static final String fixHttpHeaders(String headers, int contentLength)
{    if (headers == null) {        return null;    }    int start = 0, lineEnd = 0, last = 0, trailingCrLf = 0;    StringBuilder replace = new StringBuilder();    while (start < headers.length()) {        lineEnd = headers.indexOf(CRLF, start);        trailingCrLf = 1;        if (lineEnd == -1) {            lineEnd = headers.length();            trailingCrLf = 0;        }        int colonPos = -1;        for (int i = start; i < lineEnd; i++) {            if (headers.charAt(i) == ':') {                colonPos = i;                break;            }        }        if (colonPos == -1) {            boolean valid = true;            if (start == 0) {                                    } else if ((lineEnd + 4) == headers.length() && headers.endsWith(CRLF + CRLF)) {                                trailingCrLf = 2;            } else {                valid = false;            }            if (!valid) {                if (last < start) {                    replace.append(headers.substring(last, start));                }                last = lineEnd + 2 * trailingCrLf;            }            start = lineEnd + 2 * trailingCrLf;            /*         * skip over invalid header line, no further check for problematic         * headers required         */            continue;        }        String name = headers.substring(start, colonPos);        if (PROBLEMATIC_HEADERS.matcher(name).matches()) {            boolean needsFix = true;            if (name.equalsIgnoreCase("content-length")) {                String value = headers.substring(colonPos + 1, lineEnd).trim();                try {                    int l = Integer.parseInt(value);                    if (l == contentLength) {                        needsFix = false;                    }                } catch (NumberFormatException e) {                                }            }            if (needsFix) {                if (last < start) {                    replace.append(headers.substring(last, start));                }                last = lineEnd + 2 * trailingCrLf;                replace.append(X_HIDE_HEADER).append(headers.substring(start, lineEnd + 2 * trailingCrLf));                if (trailingCrLf == 0) {                    replace.append(CRLF);                    trailingCrLf = 1;                }                if (name.equalsIgnoreCase("content-length")) {                                        replace.append("Content-Length").append(COLONSP).append(contentLength).append(CRLF);                }            }        }        start = lineEnd + 2 * trailingCrLf;    }    if (last > 0 || trailingCrLf != 2) {        if (last < headers.length()) {                        replace.append(headers.substring(last));        }        while (trailingCrLf < 2) {            replace.append(CRLF);            trailingCrLf++;        }        return replace.toString();    }    return headers;}
35ed4a510440c7c16c919f89f9d93d05c28026c71971505e4a7fb946a50761ff
parseArgs
protected int parseArgs(String[] args, int i)
{    if (args[i].equals("-listen")) {        tcpPort = Integer.parseInt(args[++i]);        return 2;    } else if (args[i].equals("-keepClientCnxOpen")) {        keepClientCnxOpen = true;        return 1;    } else if (args[i].equals("-stdin")) {        stdin = true;        return 1;    }    return 0;}
836a5572f315e9135ea474c2d3f0e71bd5d6ab429448e77da99e14a2324cf5b5
run
protected int run() throws Exception
{        if (tcpPort != -1) {        processTCP(tcpPort);        return 0;    } else if (stdin) {        return processStdin();    }        return -1;}
c376592ef52cadb76ca6a2e7a482875eefd33ba692cd557e8ebc5724f31f573b
processSingle
protected int processSingle(String input) throws Exception
{    StringBuilder output = new StringBuilder();    int ret = process(input, output);    System.out.println(output);    return ret;}
fe140b8a8d26673528980d2daaa07ae845317551bfb53e903ddc4253e3354615
processStdin
protected int processStdin() throws Exception
{    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));    String line;    while ((line = in.readLine()) != null) {        StringBuilder output = new StringBuilder();        @SuppressWarnings("unused")        int ret = process(line, output);        System.out.println(output);    }    return 0;}
8734681cb5f5afe7eec30f0aa144d25b2458389dec4a18f2109ad6962301dc1c
processTCP
protected void processTCP(int tcpPort) throws Exception
{    ServerSocket server = null;    try {        server = new ServerSocket();        server.bind(new InetSocketAddress(tcpPort));        LOG.info(server.toString());    } catch (Exception e) {        LOG.error("Could not listen on port " + tcpPort, e);        System.exit(-1);    }    while (true) {        Worker worker;        try {            worker = new Worker(server.accept());            Thread thread = new Thread(worker);            thread.start();        } catch (Exception e) {            LOG.error("Accept failed: " + tcpPort, e);            System.exit(-1);        }    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{        BufferedReader in = null;    OutputStream out = null;    try {        in = new BufferedReader(new InputStreamReader(client.getInputStream()));        out = client.getOutputStream();    } catch (IOException e) {        LOG.error("Failed initializing streams: ", e);        return;    }        if (keepClientCnxOpen) {        try {                        while (readWrite(in, out)) {            }        } catch (Exception e) {            LOG.error("Read/Write failed: ", e);        }    } else {        try {            readWrite(in, out);        } catch (Exception e) {            LOG.error("Read/Write failed: ", e);        }    }    try {                client.close();    } catch (Exception e) {        LOG.error(e.toString());    }}
cb839fb6fd40e2eeeb439f7f68793f6a592e15795abd8c5e538ef827b9233cc0
readWrite
protected boolean readWrite(BufferedReader in, OutputStream out) throws Exception
{    String line = in.readLine();    if (line == null) {                return false;    }    if (line.trim().length() > 1) {                StringBuilder output = new StringBuilder();        process(line, output);        output.append("\n");        out.write(output.toString().getBytes(StandardCharsets.UTF_8));    }    return true;}
9b88aafa3283f4f91c75b037fc3166bd6e7db5a92d19bf1ab72017c593448606
getProtocolOutput
protected ProtocolOutput getProtocolOutput(String url, CrawlDatum datum) throws Exception
{    ProtocolFactory factory = new ProtocolFactory(getConf());    Protocol protocol = factory.getProtocol(url);    Text turl = new Text(url);    return protocol.getProtocolOutput(turl, datum);}
88bc0975abe976e8e48444c0801d5309ff2fb52ebdcaf3d18df2ad693f89e1fb
getExitValue
public int getExitValue()
{    return _xit;}
2d57b467cbf5463315322ab3e61712c5cf6f292e574dc2ccdf3cdd5e438aeef2
setCommand
public void setCommand(String s)
{    _command = s;}
1ff8ab376c470e3ba8b2811633435b5556ac959d0795e9752c296a86c8405913
getCommand
public String getCommand()
{    return _command;}
5b37a1672c342c9cdea3117f9d6ecea1a4468ae6339267b5d3948842af72aa68
setInputStream
public void setInputStream(InputStream is)
{    _stdin = is;}
0feb92045e1542c4408984cb017a6288c3169c6a531a1eb83eaf5e1c39e8468f
setStdOutputStream
public void setStdOutputStream(OutputStream os)
{    _stdout = os;}
7903e27e7483e8155f6944a3e69d19b90669d77a64ef0f6e18d1b04e18177e43
setStdErrorStream
public void setStdErrorStream(OutputStream os)
{    _stderr = os;}
6e24894f61664f275556a8ccea9e30a609f61db4e8a0f05934fe140d26a0b471
evaluate
public void evaluate() throws IOException
{    this.exec();}
adcfc54a6caa509a53f9d2c64195ed3bc44430bc5e1af64a4e4170e71dcb1a27
exec
public int exec() throws IOException
{    Process proc = Runtime.getRuntime().exec(_command);    _barrier = new CyclicBarrier(3 + ((_stdin != null) ? 1 : 0));    PullerThread so = new PullerThread("STDOUT", proc.getInputStream(), _stdout);    so.setDaemon(true);    so.start();    PullerThread se = new PullerThread("STDERR", proc.getErrorStream(), _stderr);    se.setDaemon(true);    se.start();    PusherThread si = null;    if (_stdin != null) {        si = new PusherThread("STDIN", _stdin, proc.getOutputStream());        si.setDaemon(true);        si.start();    }    boolean _timedout = false;    long end = System.currentTimeMillis() + _timeout * 1000;    try {        if (_timeout == 0) {            _barrier.await();        } else {            _barrier.await(_timeout, TimeUnit.SECONDS);        }    } catch (TimeoutException ex) {        _timedout = true;    } catch (BrokenBarrierException bbe) {    /* IGNORE */    } catch (InterruptedException e) {    /* IGNORE */    }        if (si != null) {        si.interrupt();    }    so.interrupt();    se.interrupt();    _xit = -1;    if (!_timedout) {        if (_waitForExit) {            do {                try {                    Thread.sleep(1000);                    _xit = proc.exitValue();                } catch (InterruptedException ie) {                    if (Thread.interrupted()) {                                                break;                    } else {                        continue;                    }                } catch (IllegalThreadStateException iltse) {                    continue;                }                break;            } while (!(_timedout = (System.currentTimeMillis() > end)));        } else {            try {                _xit = proc.exitValue();            } catch (IllegalThreadStateException iltse) {                _timedout = true;            }        }    }    if (_waitForExit) {        proc.destroy();    }    return _xit;}
05f5f6d215b5b1383263476e8b37f578052da57785891f72de4a8d075006e52c
getThrownError
public Throwable getThrownError()
{    return _thrownError;}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        byte[] buf = new byte[BUF];        int read = 0;        while (!isInterrupted() && (read = _is.read(buf)) != -1) {            if (read == 0)                continue;            _os.write(buf, 0, read);            _os.flush();        }    } catch (InterruptedIOException iioe) {        } catch (Throwable t) {        _thrownError = t;    } finally {        try {            if (_closeInput) {                _is.close();            } else {                _os.close();            }        } catch (IOException ioe) {        /* IGNORE */        }    }    try {        _barrier.await();    } catch (InterruptedException ie) {    /* IGNORE */    } catch (BrokenBarrierException bbe) {    /* IGNORE */    }}
2c9177cd8b47bdfcc60afb6594715b20a3d24726d258bdf44bfb0787f6856413
getTimeout
public int getTimeout()
{    return _timeout;}
c664289d9c6d38c192909efb8d5d4b660482cde67deb7d1661597d2725f7f027
setTimeout
public void setTimeout(int timeout)
{    _timeout = timeout;}
c03b3ce26d8f24699dd8558251ab661ae9686cb6a8dd48bb53a61c0237374bbc
getWaitForExit
public boolean getWaitForExit()
{    return _waitForExit;}
02d22d8efd6ab429ee260888bb316f4fa24d6c2e9dd107648d3c41927e1d4c42
setWaitForExit
public void setWaitForExit(boolean waitForExit)
{    _waitForExit = waitForExit;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    String commandPath = null;    String filePath = null;    int timeout = 10;    String usage = "Usage: CommandRunner [-timeout timeoutSecs] commandPath filePath";    if (args.length < 2) {        System.err.println(usage);        System.exit(-1);    }    for (int i = 0; i < args.length; i++) {        if (args[i].equals("-timeout")) {            timeout = Integer.parseInt(args[++i]);        } else if (i != args.length - 2) {            System.err.println(usage);            System.exit(-1);        } else {            commandPath = args[i];            filePath = args[++i];        }    }    CommandRunner cr = new CommandRunner();    cr.setCommand(commandPath);    cr.setInputStream(new java.io.FileInputStream(filePath));    cr.setStdErrorStream(System.err);    cr.setStdOutputStream(System.out);    cr.setTimeout(timeout);    cr.evaluate();    System.err.println("output value: " + cr.getExitValue());}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    Option helpOpt = new Option("h", "help", false, "Show this message");    @SuppressWarnings("static-access")    Option inDirs = OptionBuilder.withArgName("inputDirs").isRequired().withDescription("Comma separated list of crawl directories (e.g., \"./crawl1,./crawl2\")").hasArgs().create("inputDirs");    @SuppressWarnings("static-access")    Option outDir = OptionBuilder.withArgName("outputDir").isRequired().withDescription("Output directory where results should be dumped").hasArgs().create("outputDir");    @SuppressWarnings("static-access")    Option modeOpt = OptionBuilder.withArgName("mode").isRequired().withDescription("Set statistics gathering mode (by 'host' or by 'domain')").hasArgs().create("mode");    @SuppressWarnings("static-access")    Option numReducers = OptionBuilder.withArgName("numReducers").withDescription("Optional number of reduce jobs to use. Defaults to 1").hasArgs().create("numReducers");    Options options = new Options();    options.addOption(helpOpt);    options.addOption(inDirs);    options.addOption(outDir);    options.addOption(modeOpt);    options.addOption(numReducers);    CommandLineParser parser = new GnuParser();    CommandLine cli;    try {        cli = parser.parse(options, args);    } catch (MissingOptionException e) {        HelpFormatter formatter = new HelpFormatter();        formatter.printHelp("CrawlCompletionStats", options, true);        return 1;    }    if (cli.hasOption("help")) {        HelpFormatter formatter = new HelpFormatter();        formatter.printHelp("CrawlCompletionStats", options, true);        return 1;    }    String inputDir = cli.getOptionValue("inputDirs");    String outputDir = cli.getOptionValue("outputDir");    int numOfReducers = 1;    if (cli.hasOption("numReducers")) {        numOfReducers = Integer.parseInt(args[3]);    }    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    long start = System.currentTimeMillis();    LOG.info("CrawlCompletionStats: starting at {}", sdf.format(start));    int mode = 0;    String jobName = "CrawlCompletionStats";    if (cli.getOptionValue("mode").equals("host")) {        jobName = "Host CrawlCompletionStats";        mode = MODE_HOST;    } else if (cli.getOptionValue("mode").equals("domain")) {        jobName = "Domain CrawlCompletionStats";        mode = MODE_DOMAIN;    }    Configuration conf = getConf();    conf.setInt("domain.statistics.mode", mode);    conf.setBoolean("mapreduce.fileoutputcommitter.marksuccessfuljobs", false);    Job job = Job.getInstance(conf, jobName);    job.setJarByClass(CrawlCompletionStats.class);    String[] inputDirsSpecs = inputDir.split(",");    for (int i = 0; i < inputDirsSpecs.length; i++) {        File completeInputPath = new File(new File(inputDirsSpecs[i]), "crawldb/current");        FileInputFormat.addInputPath(job, new Path(completeInputPath.toString()));    }    job.setInputFormatClass(SequenceFileInputFormat.class);    FileOutputFormat.setOutputPath(job, new Path(outputDir));    job.setOutputFormatClass(TextOutputFormat.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(LongWritable.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(LongWritable.class);    job.setMapperClass(CrawlCompletionStatsMapper.class);    job.setReducerClass(CrawlCompletionStatsReducer.class);    job.setCombinerClass(CrawlCompletionStatsCombiner.class);    job.setNumReduceTasks(numOfReducers);    try {        boolean success = job.waitForCompletion(true);        if (!success) {            String message = jobName + " job did not succeed, job status: " + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);                        throw new RuntimeException(message);        }    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error(jobName + " job failed");        throw e;    }    long end = System.currentTimeMillis();    LOG.info("CrawlCompletionStats: finished at {}, elapsed: {}", sdf.format(end), TimingUtil.elapsedTime(start, end));    return 0;}
5cea2a7c4e1f15509b5030e71609dca919138d48d1aebe9efc31435a268ea192
setup
public void setup(Context context)
{    mode = context.getConfiguration().getInt("domain.statistics.mode", MODE_DOMAIN);}
c6269931e31a8dc94866a3677403449fa242bd9850253c33ecad44d2e65429f9
map
public void map(Text urlText, CrawlDatum datum, Context context) throws IOException, InterruptedException
{    URL url = new URL(urlText.toString());    String out = "";    switch(mode) {        case MODE_HOST:            out = url.getHost();            break;        case MODE_DOMAIN:            out = URLUtil.getDomainName(url);            break;    }    if (datum.getStatus() == CrawlDatum.STATUS_DB_FETCHED || datum.getStatus() == CrawlDatum.STATUS_DB_NOTMODIFIED) {        context.write(new Text(out + " FETCHED"), new LongWritable(1));    } else {        context.write(new Text(out + " UNFETCHED"), new LongWritable(1));    }}
8f445d7a50d60bc0e03a6c7a84a91342429188f7c21933677bb53751bf0afa10
reduce
public void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException
{    long total = 0;    for (LongWritable val : values) {        total += val.get();    }    context.write(new LongWritable(total), key);}
8f445d7a50d60bc0e03a6c7a84a91342429188f7c21933677bb53751bf0afa10
reduce
public void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException
{    long total = 0;    for (LongWritable val : values) {        total += val.get();    }    context.write(key, new LongWritable(total));}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(NutchConfiguration.create(), new CrawlCompletionStats(), args);}
1dd1651c4e45dae6cdbc4de33371ac5268c880fb5e52a6e04cb2b8432a8e94af
inflateBestEffort
public static final byte[] inflateBestEffort(byte[] in)
{    return inflateBestEffort(in, Integer.MAX_VALUE);}
e9020ac98fa7ef7e24bfb9f914dc9566fdf4ba7fb01bd5e735d52da2052f3bdc
inflateBestEffort
public static final byte[] inflateBestEffort(byte[] in, int sizeLimit)
{        ByteArrayOutputStream outStream = new ByteArrayOutputStream(EXPECTED_COMPRESSION_RATIO * in.length);        Inflater inflater = new Inflater(true);    InflaterInputStream inStream = new InflaterInputStream(new ByteArrayInputStream(in), inflater);    byte[] buf = new byte[BUF_SIZE];    int written = 0;    while (true) {        try {            int size = inStream.read(buf);            if (size <= 0)                break;            if ((written + size) > sizeLimit) {                outStream.write(buf, 0, sizeLimit - written);                break;            }            outStream.write(buf, 0, size);            written += size;        } catch (Exception e) {            LOG.info("Caught Exception in inflateBestEffort", e);            break;        }    }    try {        outStream.close();    } catch (IOException e) {    }    return outStream.toByteArray();}
b128090e033a813045861bdb5f6faf039f08fab2a522ee278531fa153b99f8fd
inflate
public static final byte[] inflate(byte[] in) throws IOException
{        ByteArrayOutputStream outStream = new ByteArrayOutputStream(EXPECTED_COMPRESSION_RATIO * in.length);    InflaterInputStream inStream = new InflaterInputStream(new ByteArrayInputStream(in));    byte[] buf = new byte[BUF_SIZE];    while (true) {        int size = inStream.read(buf);        if (size <= 0)            break;        outStream.write(buf, 0, size);    }    outStream.close();    return outStream.toByteArray();}
2307c22ef163fa9fdc8d75306b2bed3c64226320a36acf59f8f01ed0877c1836
deflate
public static final byte[] deflate(byte[] in)
{        ByteArrayOutputStream byteOut = new ByteArrayOutputStream(in.length / EXPECTED_COMPRESSION_RATIO);    DeflaterOutputStream outStream = new DeflaterOutputStream(byteOut);    try {        outStream.write(in);    } catch (Exception e) {        LOG.error("Error compressing: ", e);    }    try {        outStream.close();    } catch (IOException e) {        LOG.error("Error closing: ", e);    }    return byteOut.toByteArray();}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    if (args.length < 3) {        System.err.println("Usage: DomainStatistics inputDirs outDir mode [numOfReducer]");        System.err.println("\tinputDirs\tComma separated list of crawldb input directories");        System.err.println("\t\t\tE.g.: crawl/crawldb/");        System.err.println("\toutDir\t\tOutput directory where results should be dumped");        System.err.println("\tmode\t\tSet statistics gathering mode");        System.err.println("\t\t\t\thost\tGather statistics by host");        System.err.println("\t\t\t\tdomain\tGather statistics by domain");        System.err.println("\t\t\t\tsuffix\tGather statistics by suffix");        System.err.println("\t\t\t\ttld\tGather statistics by top level directory");        System.err.println("\t[numOfReducers]\tOptional number of reduce jobs to use. Defaults to 1.");        return 1;    }    String inputDir = args[0];    String outputDir = args[1];    int numOfReducers = 1;    if (args.length > 3) {        numOfReducers = Integer.parseInt(args[3]);    }    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    long start = System.currentTimeMillis();    LOG.info("DomainStatistics: starting at " + sdf.format(start));    int mode = 0;    String jobName = "DomainStatistics";    if (args[2].equals("host")) {        jobName = "Host statistics";        mode = MODE_HOST;    } else if (args[2].equals("domain")) {        jobName = "Domain statistics";        mode = MODE_DOMAIN;    } else if (args[2].equals("suffix")) {        jobName = "Suffix statistics";        mode = MODE_SUFFIX;    } else if (args[2].equals("tld")) {        jobName = "TLD statistics";        mode = MODE_TLD;    }    Configuration conf = getConf();    conf.setInt("domain.statistics.mode", mode);    conf.setBoolean("mapreduce.fileoutputcommitter.marksuccessfuljobs", false);    Job job = Job.getInstance(conf, jobName);    job.setJarByClass(DomainStatistics.class);    String[] inputDirsSpecs = inputDir.split(",");    for (int i = 0; i < inputDirsSpecs.length; i++) {        File completeInputPath = new File(new File(inputDirsSpecs[i]), "current");        FileInputFormat.addInputPath(job, new Path(completeInputPath.toString()));    }    job.setInputFormatClass(SequenceFileInputFormat.class);    FileOutputFormat.setOutputPath(job, new Path(outputDir));    job.setOutputFormatClass(TextOutputFormat.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(LongWritable.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(LongWritable.class);    job.setMapperClass(DomainStatisticsMapper.class);    job.setReducerClass(DomainStatisticsReducer.class);    job.setCombinerClass(DomainStatisticsCombiner.class);    job.setNumReduceTasks(numOfReducers);    try {        boolean success = job.waitForCompletion(true);        if (!success) {            String message = "Injector job did not succeed, job status: " + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);                        throw new RuntimeException(message);        }    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error(jobName + " job failed", e);        throw e;    }    long end = System.currentTimeMillis();    LOG.info("DomainStatistics: finished at " + sdf.format(end) + ", elapsed: " + TimingUtil.elapsedTime(start, end));    return 0;}
5cea2a7c4e1f15509b5030e71609dca919138d48d1aebe9efc31435a268ea192
setup
public void setup(Context context)
{    mode = context.getConfiguration().getInt("domain.statistics.mode", MODE_DOMAIN);}
c6269931e31a8dc94866a3677403449fa242bd9850253c33ecad44d2e65429f9
map
public void map(Text urlText, CrawlDatum datum, Context context) throws IOException, InterruptedException
{    if (datum.getStatus() == CrawlDatum.STATUS_DB_FETCHED || datum.getStatus() == CrawlDatum.STATUS_DB_NOTMODIFIED) {        try {            URL url = new URL(urlText.toString());            String out = null;            switch(mode) {                case MODE_HOST:                    out = url.getHost();                    break;                case MODE_DOMAIN:                    out = URLUtil.getDomainName(url);                    break;                case MODE_SUFFIX:                    out = URLUtil.getDomainSuffix(url).getDomain();                    break;                case MODE_TLD:                    out = URLUtil.getTopLevelDomainName(url);                    break;            }            if (out.trim().equals("")) {                LOG.info("url : " + url);                context.getCounter(MyCounter.EMPTY_RESULT).increment(1);            }            context.write(new Text(out), new LongWritable(1));        } catch (Exception ex) {        }        context.getCounter(MyCounter.FETCHED).increment(1);        context.write(FETCHED_TEXT, new LongWritable(1));    } else {        context.getCounter(MyCounter.NOT_FETCHED).increment(1);        context.write(NOT_FETCHED_TEXT, new LongWritable(1));    }}
8f445d7a50d60bc0e03a6c7a84a91342429188f7c21933677bb53751bf0afa10
reduce
public void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException
{    long total = 0;    for (LongWritable val : values) {        total += val.get();    }    context.write(new LongWritable(total), key);}
8f445d7a50d60bc0e03a6c7a84a91342429188f7c21933677bb53751bf0afa10
reduce
public void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException
{    long total = 0;    for (LongWritable val : values) {        total += val.get();    }    context.write(key, new LongWritable(total));}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(NutchConfiguration.create(), new DomainStatistics(), args);}
313e57c1be1e53c3ca27c7c5dbe49808d3145421a933669a6d99d52a16beb97b
getDomain
public String getDomain()
{    return domain;}
843c8032c501b67e4f06fb37a137d075fb1b43c9fe50cee5773f8aa3ad7960dc
getStatus
public Status getStatus()
{    return status;}
83bc8b6f9f3a3965915bca13823ff9c6a4ee6f5daa779a5c911bafab426fd449
getBoost
public float getBoost()
{    return boost;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return domain;}
bd20308aee6d728d21946a6c7ff826bcb092daf34fe0af0d88f7eb694eada147
getInstance
public static DomainSuffixes getInstance()
{    if (instance == null) {        instance = new DomainSuffixes();    }    return instance;}
35165e39d45a0a085b4d5d7fe6da07d31b709da6d982f724a69259acfd2d7393
addDomainSuffix
 void addDomainSuffix(DomainSuffix tld)
{    domains.put(tld.getDomain(), tld);}
aa0f6e5a9aa1426fe929e4d59938d853709f78c3357f71a3decb48ae3967be0a
isDomainSuffix
public boolean isDomainSuffix(String extension)
{    return domains.containsKey(extension);}
b9c26cd8e71f81b234c6908ee03602e580ba96b822b093d91639899fd8998946
get
public DomainSuffix get(String extension)
{    return domains.get(extension);}
d704dada6171f95e81d7dd6e0399dd756bf3a87f3194643828fa60a87e1ef860
read
 void read(DomainSuffixes tldEntries, InputStream input) throws IOException
{    try {        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();        factory.setIgnoringComments(true);        DocumentBuilder builder = factory.newDocumentBuilder();        Document document = builder.parse(new InputSource(input));        Element root = document.getDocumentElement();        if (root != null && root.getTagName().equals("domains")) {            Element tlds = (Element) root.getElementsByTagName("tlds").item(0);            Element suffixes = (Element) root.getElementsByTagName("suffixes").item(0);                        readITLDs(tldEntries, (Element) tlds.getElementsByTagName("itlds").item(0));            readGTLDs(tldEntries, (Element) tlds.getElementsByTagName("gtlds").item(0));            readCCTLDs(tldEntries, (Element) tlds.getElementsByTagName("cctlds").item(0));            readSuffixes(tldEntries, suffixes);        } else {            throw new IOException("xml file is not valid");        }    } catch (ParserConfigurationException ex) {        LOG.warn(StringUtils.stringifyException(ex));        throw new IOException(ex.getMessage());    } catch (SAXException ex) {        LOG.warn(StringUtils.stringifyException(ex));        throw new IOException(ex.getMessage());    }}
53070788248ca2b0671343e0184dd1ad61aeb602eb400dcd68be049985aae23e
readITLDs
 void readITLDs(DomainSuffixes tldEntries, Element el)
{    NodeList children = el.getElementsByTagName("tld");    for (int i = 0; i < children.getLength(); i++) {        tldEntries.addDomainSuffix(readGTLD((Element) children.item(i), Type.INFRASTRUCTURE));    }}
8edab9511dc76c959baffe65157e3d94b446ce5af9369635f090a23548f24445
readGTLDs
 void readGTLDs(DomainSuffixes tldEntries, Element el)
{    NodeList children = el.getElementsByTagName("tld");    for (int i = 0; i < children.getLength(); i++) {        tldEntries.addDomainSuffix(readGTLD((Element) children.item(i), Type.GENERIC));    }}
21ece4190e635e3520be1510bdc99a110b1c5fa05526cda591154a3a3177878e
readCCTLDs
 void readCCTLDs(DomainSuffixes tldEntries, Element el) throws IOException
{    NodeList children = el.getElementsByTagName("tld");    for (int i = 0; i < children.getLength(); i++) {        tldEntries.addDomainSuffix(readCCTLD((Element) children.item(i)));    }}
386f715671a4c92ab6e650143fd6bc8dea123e01007ccb73b0609d7ded9ea263
readGTLD
 TopLevelDomain readGTLD(Element el, Type type)
{    String domain = el.getAttribute("domain");    Status status = readStatus(el);    float boost = readBoost(el);    return new TopLevelDomain(domain, type, status, boost);}
eeabe38346802deb604e1542da5d184089876143567518e660da898f1b1ee20a
readCCTLD
 TopLevelDomain readCCTLD(Element el) throws IOException
{    String domain = el.getAttribute("domain");    Status status = readStatus(el);    float boost = readBoost(el);    String countryName = readCountryName(el);    return new TopLevelDomain(domain, status, boost, countryName);}
a1b7e1317d48c5e054ca027d9ba0c2fc6e7f8ab6fdf8f47d0c78e976ab692114
readStatus
 Status readStatus(Element el)
{    NodeList list = el.getElementsByTagName("status");    if (list == null || list.getLength() == 0)        return DomainSuffix.DEFAULT_STATUS;    return Status.valueOf(list.item(0).getFirstChild().getNodeValue());}
1e8dc139c300e669a70a7fc08af8065ad86080188b4ab8f3a6c640ef56ce9b80
readBoost
 float readBoost(Element el)
{    NodeList list = el.getElementsByTagName("boost");    if (list == null || list.getLength() == 0)        return DomainSuffix.DEFAULT_BOOST;    return Float.parseFloat(list.item(0).getFirstChild().getNodeValue());}
be87eb5cdfaf8882d7041c7dbeed592e4d10f5111e6030a8cfe29a128dd5330d
readCountryName
 String readCountryName(Element el) throws IOException
{    NodeList list = el.getElementsByTagName("country");    if (list == null || list.getLength() == 0)        throw new IOException("Country name should be given");    return list.item(0).getNodeValue();}
661472d656354ddd5b086e14b864fdef7450a47351455d47caee3869f16dca00
readSuffixes
 void readSuffixes(DomainSuffixes tldEntries, Element el)
{    NodeList children = el.getElementsByTagName("suffix");    for (int i = 0; i < children.getLength(); i++) {        tldEntries.addDomainSuffix(readSuffix((Element) children.item(i)));    }}
6445f773ac8a28ba99998f43fb8a11495fb1d091664b9fe03ce7df43f28a9487
readSuffix
 DomainSuffix readSuffix(Element el)
{    String domain = el.getAttribute("domain");    Status status = readStatus(el);    float boost = readBoost(el);    return new DomainSuffix(domain, status, boost);}
b36c0cb78d388571653840506cba5d90e12b262c755658912fc2224c314bcbf6
getType
public Type getType()
{    return type;}
c98e5960d730382bdbfc55c579984e36a1b88f26321e52e3b8f20539475932fb
getCountryName
public String getCountryName()
{    return countryName;}
fde7e19bd6f673224b4da7a8717f4ce565839bb0df30471692c43cb37f5d444c
getDom
public static Element getDom(InputStream is)
{    Element element = null;    DOMParser parser = new DOMParser();    InputSource input;    try {        input = new InputSource(is);        input.setEncoding("UTF-8");        parser.parse(input);        int i = 0;        while (!(parser.getDocument().getChildNodes().item(i) instanceof Element)) {            i++;        }        element = (Element) parser.getDocument().getChildNodes().item(i);    } catch (FileNotFoundException e) {        LOG.error("Error: ", e);    } catch (SAXException e) {        LOG.error("Error: ", e);    } catch (IOException e) {        LOG.error("Error: ", e);    }    return element;}
6b12c698601e2e1db733879511d800287b2e8adec5e304c2d3b457c641846b04
saveDom
public static void saveDom(OutputStream os, Element e)
{    DOMSource source = new DOMSource(e);    TransformerFactory transFactory = TransformerFactory.newInstance();    Transformer transformer;    try {        transformer = transFactory.newTransformer();        transformer.setOutputProperty("indent", "yes");        StreamResult result = new StreamResult(os);        transformer.transform(source, result);        os.flush();    } catch (UnsupportedEncodingException e1) {        LOG.error("Error: ", e1);    } catch (IOException e1) {        LOG.error("Error: ", e1);    } catch (TransformerConfigurationException e2) {        LOG.error("Error: ", e2);    } catch (TransformerException ex) {        LOG.error("Error: ", ex);    }}
fce909c8314591571c434cec74b364177ffdaac371f7104d11c31f359e5b40da
saveDom
public static void saveDom(OutputStream os, DocumentFragment doc)
{    NodeList docChildren = doc.getChildNodes();    for (int i = 0; i < docChildren.getLength(); i++) {        saveDom(os, (Element) docChildren.item(i));    }}
00d2ee5587fb0198b631072a8ebbe3cd9e290114909a95afd98df21663146ecd
getUrlMD5
public static String getUrlMD5(String url)
{    byte[] digest = MD5Hash.digest(url).getDigest();    StringBuffer sb = new StringBuffer();    for (byte b : digest) {        sb.append(String.format("%02x", b & 0xff));    }    return sb.toString();}
7be9f091bc500c97fb72024b2979456695e93a5977e9c80daa7c71c692f61446
createTwoLevelsDirectory
public static String createTwoLevelsDirectory(String basePath, String md5, boolean makeDir)
{    String firstLevelDirName = new StringBuilder().append(md5.charAt(0)).append(md5.charAt(8)).toString();    String secondLevelDirName = new StringBuilder().append(md5.charAt(16)).append(md5.charAt(24)).toString();    String fullDirPath = String.format(DIR_PATTERN, basePath, firstLevelDirName, secondLevelDirName);    if (makeDir) {        try {            FileUtils.forceMkdir(new File(fullDirPath));        } catch (IOException e) {            LOG.error("Failed to create dir: {}", fullDirPath);            fullDirPath = null;        }    }    return fullDirPath;}
d291f6b933b2b5f1b9ffdeb3032163462c930cc0deba914e4213f5cb189c08c6
createTwoLevelsDirectory
public static String createTwoLevelsDirectory(String basePath, String md5)
{    return createTwoLevelsDirectory(basePath, md5, true);}
d914fa0e09505be73e8b97fa8df4567eb769cb2e556feeab43ffbd98a5b9df6a
createFileName
public static String createFileName(String md5, String fileBaseName, String fileExtension)
{    if (fileBaseName.length() > MAX_LENGTH_OF_FILENAME) {        LOG.info("File name is too long. Truncated to {} characters.", MAX_LENGTH_OF_FILENAME);        fileBaseName = StringUtils.substring(fileBaseName, 0, MAX_LENGTH_OF_FILENAME);    }    if (fileExtension.length() > MAX_LENGTH_OF_EXTENSION) {        LOG.info("File extension is too long. Truncated to {} characters.", MAX_LENGTH_OF_EXTENSION);        fileExtension = StringUtils.substring(fileExtension, 0, MAX_LENGTH_OF_EXTENSION);    }        fileBaseName = fileBaseName.replaceAll("\\?", "");    fileExtension = fileExtension.replaceAll("\\?", "");    return String.format(FILENAME_PATTERN, md5, fileBaseName, fileExtension);}
7c31fa0457cf2da53e43bad449424c05166d69210f699b60b717eeda44c8b6d1
createFileNameFromUrl
public static String createFileNameFromUrl(String basePath, String reverseKey, String urlString, String epochScrapeTime, String fileExtension, boolean makeDir)
{    String fullDirPath = basePath + File.separator + reverseKey + File.separator + DigestUtils.sha1Hex(urlString);    if (makeDir) {        try {            FileUtils.forceMkdir(new File(fullDirPath));        } catch (IOException e) {            LOG.error("Failed to create dir: {}", fullDirPath);            fullDirPath = null;        }    }    if (fileExtension.length() > MAX_LENGTH_OF_EXTENSION) {        LOG.info("File extension is too long. Truncated to {} characters.", MAX_LENGTH_OF_EXTENSION);        fileExtension = StringUtils.substring(fileExtension, 0, MAX_LENGTH_OF_EXTENSION);    }    String outputFullPath = fullDirPath + File.separator + epochScrapeTime + "." + fileExtension;    return outputFullPath;}
4fc8fdf82632c9bd80ece42caeea5d188579e1912939af6d66bd7a74ee470935
displayFileTypes
public static String displayFileTypes(Map<String, Integer> typeCounts, Map<String, Integer> filteredCounts)
{    StringBuilder builder = new StringBuilder();        builder.append("\nTOTAL Stats:\n");    builder.append("[\n");    int mimetypeCount = 0;    for (String mimeType : typeCounts.keySet()) {        builder.append("    {\"mimeType\":\"");        builder.append(mimeType);        builder.append("\",\"count\":\"");        builder.append(typeCounts.get(mimeType));        builder.append("\"}\n");        mimetypeCount += typeCounts.get(mimeType);    }    builder.append("]\n");    builder.append("Total count: " + mimetypeCount + "\n");        mimetypeCount = 0;    if (!filteredCounts.isEmpty()) {        builder.append("\nFILTERED Stats:\n");        builder.append("[\n");        for (String mimeType : filteredCounts.keySet()) {            builder.append("    {\"mimeType\":\"");            builder.append(mimeType);            builder.append("\",\"count\":\"");            builder.append(filteredCounts.get(mimeType));            builder.append("\"}\n");            mimetypeCount += filteredCounts.get(mimeType);        }        builder.append("]\n");        builder.append("Total filtered count: " + mimetypeCount + "\n");    }    return builder.toString();}
c544784f026afebea24caaff889181a15292a98786506cbfc66814257976c7b9
getSource
public String getSource()
{    return source;}
3ffb3c74afa5355644c1f0bfdb5098954de2d3a057f971596bdb7110ccb67b1b
getValue
public String getValue()
{    return value;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return value + " (" + source + ((confidence >= 0) ? ", " + confidence + "% confidence" : "") + ")";}
803915e853382ad445a6e2333fabb8beb8e4acd70e908a0d818400f7baac42af
isEmpty
public boolean isEmpty()
{    return (value == null || "".equals(value));}
5ced41a4b011189f7b26c1241cc66df27fb45032035b858a91334b471c8d7b94
meetsThreshold
public boolean meetsThreshold()
{    return (confidence < 0 || (minConfidence >= 0 && confidence >= minConfidence));}
9691997bc7a6b1a19c23c77bcebf476bf26bf6bbca13f5c883a0c153c1c79092
autoDetectClues
public void autoDetectClues(Content content, boolean filter)
{    byte[] data = content.getContent();    if (minConfidence >= 0 && DETECTABLES.contains(content.getContentType()) && data.length > MIN_LENGTH) {        CharsetMatch[] matches = null;                try {            detector.enableInputFilter(filter);            detector.setText(data);            matches = detector.detectAll();        } catch (Exception e) {            LOG.debug("Exception from ICU4J (ignoring): ", e);        }        if (matches != null) {            for (CharsetMatch match : matches) {                addClue(match.getName(), "detect", match.getConfidence());            }        }    }        addClue(parseCharacterEncoding(content.getMetadata().get(Response.CONTENT_TYPE)), "header");}
832577fb850f293d12ed825080ace796c44e3f01647ebfc663daae5ce82302bc
addClue
public void addClue(String value, String source, int confidence)
{    if (value == null || "".equals(value)) {        return;    }    value = resolveEncodingAlias(value);    if (value != null) {        clues.add(new EncodingClue(value, source, confidence));    }}
955fcbed5e83122a01d4384cdb3a15a75c4b74ccc96ce804195b25262f465c1c
addClue
public void addClue(String value, String source)
{    addClue(value, source, NO_THRESHOLD);}
06b9a2ef17bdd285b48b0e582cf1206f1aa377076279a8b3844c9961c123a055
guessEncoding
public String guessEncoding(Content content, String defaultValue)
{    /*     * This algorithm could be replaced by something more sophisticated; ideally     * we would gather a bunch of data on where various clues (autodetect, HTTP     * headers, HTML meta tags, etc.) disagree, tag each with the correct     * answer, and use machine learning/some statistical method to generate a     * better heuristic.     */    String base = content.getBaseUrl();    if (LOG.isTraceEnabled()) {        findDisagreements(base, clues);    }    /*     * Go down the list of encoding "clues". Use a clue if: 1. Has a confidence     * value which meets our confidence threshold, OR 2. Doesn't meet the     * threshold, but is the best try, since nothing else is available.     */    EncodingClue defaultClue = new EncodingClue(defaultValue, "default");    EncodingClue bestClue = defaultClue;    for (EncodingClue clue : clues) {        if (LOG.isTraceEnabled()) {            LOG.trace(base + ": charset " + clue);        }        String charset = clue.value;        if (minConfidence >= 0 && clue.confidence >= minConfidence) {            if (LOG.isTraceEnabled()) {                LOG.trace(base + ": Choosing encoding: " + charset + " with confidence " + clue.confidence);            }            return resolveEncodingAlias(charset).toLowerCase();        } else if (clue.confidence == NO_THRESHOLD && bestClue == defaultClue) {            bestClue = clue;        }    }    if (LOG.isTraceEnabled()) {        LOG.trace(base + ": Choosing encoding: " + bestClue);    }    return bestClue.value.toLowerCase();}
6fd97a85d9a3548e4d6def9ddfc2c34c419203e9114c97e74602bcee68345237
clearClues
public void clearClues()
{    clues.clear();}
10b89db1cf88241aab3e263d1732d59fda84073d99a692907c0667df11d46267
findDisagreements
private void findDisagreements(String url, List<EncodingClue> newClues)
{    HashSet<String> valsSeen = new HashSet<>();    HashSet<String> sourcesSeen = new HashSet<>();    boolean disagreement = false;    for (int i = 0; i < newClues.size(); i++) {        EncodingClue clue = newClues.get(i);        if (!clue.isEmpty() && !sourcesSeen.contains(clue.source)) {            if (valsSeen.size() > 0 && !valsSeen.contains(clue.value) && clue.meetsThreshold()) {                disagreement = true;            }            if (clue.meetsThreshold()) {                valsSeen.add(clue.value);            }            sourcesSeen.add(clue.source);        }    }    if (disagreement) {                StringBuffer sb = new StringBuffer();        sb.append("Disagreement: " + url + "; ");        for (int i = 0; i < newClues.size(); i++) {            if (i > 0) {                sb.append(", ");            }            sb.append(newClues.get(i));        }        LOG.trace(sb.toString());    }}
57d2bf057b52269968d95ce46c1f69b8fd430557785b8347637e1b75398c6a07
resolveEncodingAlias
public static String resolveEncodingAlias(String encoding)
{    try {        if (encoding == null || !Charset.isSupported(encoding))            return null;        String canonicalName = new String(Charset.forName(encoding).name());        return ALIASES.containsKey(canonicalName) ? ALIASES.get(canonicalName) : canonicalName;    } catch (Exception e) {        LOG.warn("Invalid encoding " + encoding + " detected, using default.");        return null;    }}
ce855595424a2bb0166a397b4528b1e87ed23faa75c8945eb3abfc8f76288d3d
parseCharacterEncoding
public static String parseCharacterEncoding(String contentType)
{    if (contentType == null)        return (null);    int start = contentType.indexOf("charset=");    if (start < 0)        return (null);    String encoding = contentType.substring(start + 8);    int end = encoding.indexOf(';');    if (end >= 0)        encoding = encoding.substring(0, end);    encoding = encoding.trim();    if ((encoding.length() > 2) && (encoding.startsWith("\"")) && (encoding.endsWith("\"")))        encoding = encoding.substring(1, encoding.length() - 1);    return (encoding.trim());}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    if (args.length != 1) {        System.err.println("Usage: EncodingDetector <file>");        System.exit(1);    }    Configuration conf = NutchConfiguration.create();    EncodingDetector detector = new EncodingDetector(NutchConfiguration.create());        @SuppressWarnings("resource")    BufferedInputStream istr = new BufferedInputStream(new FileInputStream(args[0]));    ByteArrayOutputStream ostr = new ByteArrayOutputStream();    byte[] bytes = new byte[1000];    boolean more = true;    while (more) {        int len = istr.read(bytes);        if (len < bytes.length) {            more = false;            if (len > 0) {                ostr.write(bytes, 0, len);            }        } else {            ostr.write(bytes);        }    }    byte[] data = ostr.toByteArray();        Content content = new Content("", "", data, "text/html", new Metadata(), conf);    detector.autoDetectClues(content, true);    String encoding = detector.guessEncoding(content, conf.get("parser.character.encoding.default"));    System.out.println("Guessed encoding: " + encoding);}
6f8fd45deddac8d745dda2d69579d9d4d7fb583454fa26bb405f19e32da72a5a
replace
public static void replace(FileSystem fs, Path current, Path replacement, boolean removeOld) throws IOException
{        Path old = new Path(current + ".old");    if (fs.exists(current)) {        fs.rename(current, old);    }        fs.rename(replacement, current);    if (fs.exists(old) && removeOld) {        fs.delete(old, true);    }}
05c3c96d7089c25af6fddebee3b6134ac7fe0fe2c616477ed5cff28b9b672994
closeReaders
public static void closeReaders(SequenceFile.Reader[] readers) throws IOException
{        if (readers != null) {        for (int i = 0; i < readers.length; i++) {            SequenceFile.Reader reader = readers[i];            if (reader != null) {                reader.close();            }        }    }}
c386a0e2537f4ae28aae0e87af676a5831c9a8fcbc5272c8176e8bed5286ac2b
closeReaders
public static void closeReaders(MapFile.Reader[] readers) throws IOException
{        if (readers != null) {        for (int i = 0; i < readers.length; i++) {            MapFile.Reader reader = readers[i];            if (reader != null) {                reader.close();            }        }    }}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    byte type = in.readByte();    Class<?> clazz = getTypes()[type];    try {        set((Writable) clazz.getConstructor().newInstance());    } catch (Exception e) {        e.printStackTrace();        throw new IOException("Cannot initialize the class: " + clazz);    }    Writable w = get();    if (w instanceof Configurable)        ((Configurable) w).setConf(conf);    w.readFields(in);}
a35a4b46dd399e0f2a2c0244272f576d5b933c47096e54d7f74ae7037b3e60c7
unzipBestEffort
public static final byte[] unzipBestEffort(byte[] in)
{    return unzipBestEffort(in, Integer.MAX_VALUE);}
9e05c2ef458dea881d7e1b5cf00d2eb0bc08d0015a445615f499275227435272
unzipBestEffort
public static final byte[] unzipBestEffort(byte[] in, int sizeLimit)
{    try {                ByteArrayOutputStream outStream = new ByteArrayOutputStream(EXPECTED_COMPRESSION_RATIO * in.length);        GZIPInputStream inStream = new GZIPInputStream(new ByteArrayInputStream(in));        byte[] buf = new byte[BUF_SIZE];        int written = 0;        while (true) {            try {                int size = inStream.read(buf);                if (size <= 0)                    break;                if ((written + size) > sizeLimit) {                    outStream.write(buf, 0, sizeLimit - written);                    break;                }                outStream.write(buf, 0, size);                written += size;            } catch (Exception e) {                break;            }        }        try {            outStream.close();        } catch (IOException e) {        }        return outStream.toByteArray();    } catch (IOException e) {        return null;    }}
11345a94dbd7204c5e5a896d2627bf55a8a5a3216e1ac9d4d2a5a5851e4c11f1
unzip
public static final byte[] unzip(byte[] in) throws IOException
{        ByteArrayOutputStream outStream = new ByteArrayOutputStream(EXPECTED_COMPRESSION_RATIO * in.length);    GZIPInputStream inStream = new GZIPInputStream(new ByteArrayInputStream(in));    byte[] buf = new byte[BUF_SIZE];    while (true) {        int size = inStream.read(buf);        if (size <= 0)            break;        outStream.write(buf, 0, size);    }    outStream.close();    return outStream.toByteArray();}
ff93a9aae6e908926b60bbfd8ac36a6455867191e58cadbeb44dec3f24efa01a
zip
public static final byte[] zip(byte[] in)
{    try {                ByteArrayOutputStream byteOut = new ByteArrayOutputStream(in.length / EXPECTED_COMPRESSION_RATIO);        GZIPOutputStream outStream = new GZIPOutputStream(byteOut);        try {            outStream.write(in);        } catch (Exception e) {            LOG.error("Error writing outStream: ", e);        }        try {            outStream.close();        } catch (IOException e) {            LOG.error("Error closing outStream: ", e);        }        return byteOut.toByteArray();    } catch (IOException e) {        LOG.error("Error: ", e);        return null;    }}
baebef493b42ec823f6a013fa4c313f1e9a0692d01d69d70220d7c4e7387ebe3
getPassAllFilter
public static PathFilter getPassAllFilter()
{    return arg0 -> true;}
ed4ca0600de6abe8780d34221ed305ca993f6aada20ae1a7fea5f457fdebc93d
getPassDirectoriesFilter
public static PathFilter getPassDirectoriesFilter(final FileSystem fs)
{    return path -> {        try {            return fs.getFileStatus(path).isDirectory();        } catch (IOException ioe) {            return false;        }    };}
3fb0e8f30ae32280fb5dc0ce6176e180976565d78d1f7399791a75b5078e0fca
getPaths
public static Path[] getPaths(FileStatus[] stats)
{    if (stats == null) {        return null;    }    if (stats.length == 0) {        return new Path[0];    }    Path[] res = new Path[stats.length];    for (int i = 0; i < stats.length; i++) {        res[i] = stats[i].getPath();    }    return res;}
987695969e8e8cfdc55df44f008201de70ac08216b375413aa7f31020a6a47d5
parseExpression
public static Expression parseExpression(String expr)
{    if (expr == null)        return null;    try {                        Matcher matcher = DATE_PATTERN.matcher(expr);        if (matcher.find()) {            String date = matcher.group();                        Date parsedDate = DateUtils.parseDateStrictly(date, new String[] { "yyyy-MM-dd'T'HH:mm:ss'Z'" });            long time = parsedDate.getTime();                        expr = expr.replace(date, Long.toString(time));        }        JexlEngine jexl = new JexlEngine();        jexl.setSilent(true);        jexl.setStrict(true);        return jexl.createExpression(expr);    } catch (Exception e) {        LOG.error(e.getMessage());    }    return null;}
3ea6c7323863ab7dec9893472cabaeb9a8afabb1446a47feef4f88561bbc48c8
createLockFile
public static void createLockFile(FileSystem fs, Path lockFile, boolean accept) throws IOException
{    if (fs.exists(lockFile)) {        if (!accept)            throw new IOException("lock file " + lockFile + " already exists.");        if (fs.getFileStatus(lockFile).isDirectory())            throw new IOException("lock file " + lockFile + " already exists and is a directory.");        } else {                fs.mkdirs(lockFile.getParent());        fs.createNewFile(lockFile);    }}
0fe1f921cbc497c46adad96ab73f7b6a073e0be557c13358c021ff2986a4c501
createLockFile
public static void createLockFile(Configuration conf, Path lockFile, boolean accept) throws IOException
{    FileSystem fs = lockFile.getFileSystem(conf);    createLockFile(fs, lockFile, accept);}
e1cdefe68d311cbca41f0d8bb6cc1a35e1bddb327a36ae868205270ab2a4563b
removeLockFile
public static boolean removeLockFile(FileSystem fs, Path lockFile) throws IOException
{    if (!fs.exists(lockFile))        return false;    if (fs.getFileStatus(lockFile).isDirectory())        throw new IOException("lock file " + lockFile + " exists but is a directory!");    return fs.delete(lockFile, false);}
40190adc00b5c356dca15ea913e15ef0ffd020394f706345d34ce4250d6cb3be
removeLockFile
public static boolean removeLockFile(Configuration conf, Path lockFile) throws IOException
{    FileSystem fs = lockFile.getFileSystem(conf);    return removeLockFile(fs, lockFile);}
a1d2757cc321d7590d53115911b8dc293d6ac02ece6f1755b97880b90c712126
cleanMimeType
public static String cleanMimeType(String origType)
{    if (origType == null)        return null;        String[] tokenizedMimeType = origType.split(SEPARATOR);    if (tokenizedMimeType.length > 1) {                return tokenizedMimeType[0];    } else {                return origType;    }}
f51e65265b8278eff682c49f13b12960a9c767b69965728ba3be4a73d992bdea
autoResolveContentType
public String autoResolveContentType(String typeName, String url, byte[] data)
{    String retType = null;    MimeType type = null;    String cleanedMimeType = null;    cleanedMimeType = MimeUtil.cleanMimeType(typeName);        if (cleanedMimeType != null) {        try {            type = mimeTypes.forName(cleanedMimeType);            cleanedMimeType = type.getName();        } catch (MimeTypeException mte) {                        cleanedMimeType = null;        }    }        if (type == null || type.getName().equals(MimeTypes.OCTET_STREAM)) {                try {            retType = tika.detect(url) != null ? tika.detect(url) : null;        } catch (Exception e) {            String message = "Problem loading default Tika configuration";            LOG.error(message, e);            throw new RuntimeException(e);        }    } else {        retType = type.getName();    }        if (this.mimeMagic) {        String magicType = null;                Metadata tikaMeta = new Metadata();        tikaMeta.add(Metadata.RESOURCE_NAME_KEY, url);        tikaMeta.add(Metadata.CONTENT_TYPE, (cleanedMimeType != null ? cleanedMimeType : typeName));        try {            try (InputStream stream = TikaInputStream.get(data)) {                magicType = mimeTypes.detect(stream, tikaMeta).toString();            }        } catch (IOException ignore) {        }        if (magicType != null && !magicType.equals(MimeTypes.OCTET_STREAM) && retType != null && !retType.equals(magicType)) {                                    retType = magicType;        }                if (retType == null) {            try {                retType = MimeTypes.OCTET_STREAM;            } catch (Exception ignore) {            }        }    }    return retType;}
fba4c99e05cdc87a07af64472853661eb1893a338fce864b746fd6ba6bfdcb28
getMimeType
public String getMimeType(String url)
{    return tika.detect(url);}
ae813d2a49585628767e92148137593c36debc0edf2d3ddf274fcaff9173253b
forName
public String forName(String name)
{    try {        return this.mimeTypes.forName(name).toString();    } catch (MimeTypeException e) {        LOG.error("Exception getting mime type by name: [" + name + "]: Message: " + e.getMessage());        return null;    }}
898b0c9810b6afbe6836bf39603218fe91eab25b0e112595aac5843922d9754d
getMimeType
public String getMimeType(File f)
{    try {        return tika.detect(f);    } catch (Exception e) {        LOG.error("Exception getting mime type for file: [" + f.getPath() + "]: Message: " + e.getMessage());        return null;    }}
73e8c411f712afdf4d5d93033ddaaebc48de81644fbb7dfe6617f2c0c83c00a7
nextNode
public Node nextNode()
{        if (!hasNext()) {        return null;    }            currentNode = nodes.pop();    currentChildren = currentNode.getChildNodes();    int childLen = (currentChildren != null) ? currentChildren.getLength() : 0;        for (int i = childLen - 1; i >= 0; i--) {        nodes.add(currentChildren.item(i));    }    return currentNode;}
78ccf646daf08950c02f680a24efc0c80637e1dd58994fb3afde61aa38223202
skipChildren
public void skipChildren()
{    int childLen = (currentChildren != null) ? currentChildren.getLength() : 0;    for (int i = 0; i < childLen; i++) {        Node child = nodes.peek();        if (child.equals(currentChildren.item(i))) {            nodes.pop();        }    }}
cd87f0106ae1380c56420905fa929abe227dd7c9a9fdd631978dc402a703cbbd
getCurrentNode
public Node getCurrentNode()
{    return currentNode;}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return (nodes.size() > 0);}
5627347e21ae4d61ac6bbbb379f43dafa37caaf30b46ed8c78ed063937457c3c
setUUID
private static void setUUID(Configuration conf)
{    UUID uuid = UUID.randomUUID();    conf.set(UUID_KEY, uuid.toString());}
92be258cb749bc3f8127baf14628757ce290a6084fd72c801dfe902f45b18075
getUUID
public static String getUUID(Configuration conf)
{    return conf.get(UUID_KEY);}
b4d20aa3ccacc467e329bf1bd8ca306e4ee739dc731f1a91cf2737f5b41afe37
create
public static Configuration create()
{    Configuration conf = new Configuration();    setUUID(conf);    addNutchResources(conf);    return conf;}
bd0e37e2ff6605654f3ba80b7c87d33a9c4e15e1280fe6045104fb7bd8877adc
create
public static Configuration create(boolean addNutchResources, Properties nutchProperties)
{    Configuration conf = new Configuration();    setUUID(conf);    if (addNutchResources) {        addNutchResources(conf);    }    for (Entry<Object, Object> e : nutchProperties.entrySet()) {        conf.set(e.getKey().toString(), e.getValue().toString());    }    return conf;}
ccd5533f535399c909b25504fcff7126a70f3dbe5ec9254c3c3b91a1f2bd1abb
addNutchResources
private static Configuration addNutchResources(Configuration conf)
{    conf.addResource("nutch-default.xml");    conf.addResource("nutch-site.xml");    return conf;}
94d326d95a0c12cfe44e6f495ea1133bf83784bf09d188abbac4e468d4e3b3b3
getInstance
public static Job getInstance(Configuration conf) throws IOException
{    return Job.getInstance(conf);}
ea44adb3f184d0bac723e99a40a8e2e027c547ee64d08f3b42b6d72e92be5100
cleanupAfterFailure
public static void cleanupAfterFailure(Path tempDir, Path lock, FileSystem fs) throws IOException
{    try {        if (fs.exists(tempDir)) {            fs.delete(tempDir, true);        }        LockUtil.removeLockFile(fs, lock);    } catch (IOException e) {        LOG.error("NutchJob cleanup failed: {}", e.getMessage());        throw e;    }}
e060dbfd6a3be1c0dc88e28d6f6317d6dff52708f9487eee73f51b4c1b3e85d1
getProgress
public float getProgress()
{    float res = 0;    if (currentJob != null) {        try {            res = (currentJob.mapProgress() + currentJob.reduceProgress()) / 2.0f;        } catch (IOException e) {            e.printStackTrace();            res = 0;        } catch (IllegalStateException ile) {            ile.printStackTrace();            res = 0;        }    }        if (numJobs > 1) {        res = (currentJobNum + res) / (float) numJobs;    }    status.put(Nutch.STAT_PROGRESS, res);    return res;}
0efa71af8c9cfd7df539256e85655e30f123836f7654e3849b326ffdd82ea171
getStatus
public Map<String, Object> getStatus()
{    return status;}
66912ff35c2df56836487b4d9c2704e1aeefcc2a434b4bb36033392fafd2ae5f
stopJob
public boolean stopJob() throws Exception
{    return killJob();}
9417355c9205ca3060a7ca9fd9165eb460d2950e128e66df5f121a191a273ccf
killJob
public boolean killJob() throws Exception
{    if (currentJob != null && !currentJob.isComplete()) {        try {            currentJob.killJob();            return true;        } catch (Exception e) {            e.printStackTrace();            return false;        }    }    return false;}
19293893a64ba1f7de733a7f32efe3f7a0474905c0760ea5b84eb7c5bdc9975b
get
public static synchronized ObjectCache get(Configuration conf)
{    ObjectCache objectCache = CACHE.get(conf);    if (objectCache == null) {        LOG.debug("No object cache found for conf=" + conf + ", instantiating a new object cache");        objectCache = new ObjectCache();        CACHE.put(conf, objectCache);    }    return objectCache;}
c4443088bd61b8e9b083373546e03e46a0a131fe04ea72fafdad821d1a733a03
getObject
public synchronized Object getObject(String key)
{    return objectMap.get(key);}
763e3cc44ecbfa2acc6f2b731dbb3c74e962c1c9853a7002a40a34153300044f
hasObject
public boolean hasObject(String key)
{    return objectMap.containsKey(key);}
8f3e1a582eb49cd5068cfc2a24584fcd3e454217764bf79855fdc2d476ac0f4f
setObject
public synchronized void setObject(String key, Object value)
{    objectMap.put(key, value);}
102e1445f9324924dff273927c0650e246ee5f7634b43f52b1b623758493b9ac
matches
public boolean matches(String input)
{    TrieNode node = root;    for (int i = 0; i < input.length(); i++) {        node = node.getChild(input.charAt(i));        if (node == null)            return false;        if (node.isTerminal())            return true;    }    return false;}
8cd888159e5f96b0f55c564f58f538fcab3daadfb128a72ef93141a03a34c567
shortestMatch
public String shortestMatch(String input)
{    TrieNode node = root;    for (int i = 0; i < input.length(); i++) {        node = node.getChild(input.charAt(i));        if (node == null)            return null;        if (node.isTerminal())            return input.substring(0, i + 1);    }    return null;}
8a56653a81d51afd6025595a6f60a433a0a882eaf13a8b14d03518ea73957d9c
longestMatch
public String longestMatch(String input)
{    TrieNode node = root;    String result = null;    for (int i = 0; i < input.length(); i++) {        node = node.getChild(input.charAt(i));        if (node == null)            break;        if (node.isTerminal())            result = input.substring(0, i + 1);    }    return result;}
e892d92f448b2cc05ef03daab91adec9f708c1b5d13320d6e9eb01b96e1965c3
main
public static final void main(String[] argv)
{    String[] prefixes = new String[] { "abcd", "abc", "aac", "baz", "foo", "foobar" };    PrefixStringMatcher matcher = new PrefixStringMatcher(prefixes);    String[] tests = { "a", "ab", "abc", "abcdefg", "apple", "aa", "aac", "aaccca", "abaz", "baz", "bazooka", "fo", "foobar", "kite" };    for (int i = 0; i < tests.length; i++) {        System.out.println("testing: " + tests[i]);        System.out.println("   matches: " + matcher.matches(tests[i]));        System.out.println("  shortest: " + matcher.shortestMatch(tests[i]));        System.out.println("   longest: " + matcher.longestMatch(tests[i]));    }    int iterations = 1000;    System.out.println("Testing thread-safety (NUTCH-2585) with " + iterations + " iterations:");    List<String> testsList = Arrays.asList(tests);    for (int i = 0; i < iterations; i++) {        matcher = new PrefixStringMatcher(prefixes);        Collections.shuffle(testsList);        try {            long count = testsList.parallelStream().filter(matcher::matches).count();            System.out.print(String.format("Cycle %4d : %d matches\r", i, count));        } catch (Exception e) {                        System.out.println("");            throw e;        }    }    System.out.println("");}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    if (args.length < 2) {        System.err.println("Usage: ProtocolStatistics inputDirs outDir [numOfReducer]");        System.err.println("\tinputDirs\tComma separated list of crawldb input directories");        System.err.println("\t\t\tE.g.: crawl/crawldb/");        System.err.println("\toutDir\t\tOutput directory where results should be dumped");        System.err.println("\t[numOfReducers]\tOptional number of reduce jobs to use. Defaults to 1.");        return 1;    }    String inputDir = args[0];    String outputDir = args[1];    int numOfReducers = 1;    if (args.length > 3) {        numOfReducers = Integer.parseInt(args[3]);    }    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");    long start = System.currentTimeMillis();    LOG.info("ProtocolStatistics: starting at " + sdf.format(start));    String jobName = "ProtocolStatistics";    Configuration conf = getConf();    conf.setBoolean("mapreduce.fileoutputcommitter.marksuccessfuljobs", false);    Job job = Job.getInstance(conf, jobName);    job.setJarByClass(ProtocolStatusStatistics.class);    String[] inputDirsSpecs = inputDir.split(",");    for (int i = 0; i < inputDirsSpecs.length; i++) {        File completeInputPath = new File(new File(inputDirsSpecs[i]), "current");        FileInputFormat.addInputPath(job, new Path(completeInputPath.toString()));    }    job.setInputFormatClass(SequenceFileInputFormat.class);    FileOutputFormat.setOutputPath(job, new Path(outputDir));    job.setOutputFormatClass(TextOutputFormat.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(LongWritable.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(LongWritable.class);    job.setMapperClass(ProtocolStatusStatisticsMapper.class);    job.setReducerClass(ProtocolStatusStatisticsReducer.class);    job.setCombinerClass(ProtocolStatusStatisticsCombiner.class);    job.setNumReduceTasks(numOfReducers);    try {        boolean success = job.waitForCompletion(true);        if (!success) {            String message = jobName + " job did not succeed, job status: " + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);                        throw new RuntimeException(message);        }    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error(jobName + " job failed", e);        throw e;    }    long end = System.currentTimeMillis();    LOG.info("ProtocolStatistics: finished at " + sdf.format(end) + ", elapsed: " + TimingUtil.elapsedTime(start, end));    return 0;}
c6269931e31a8dc94866a3677403449fa242bd9850253c33ecad44d2e65429f9
map
public void map(Text urlText, CrawlDatum datum, Context context) throws IOException, InterruptedException
{    if (datum.getMetaData().containsKey(Nutch.PROTOCOL_STATUS_CODE_KEY)) {        context.write((Text) datum.getMetaData().get(Nutch.PROTOCOL_STATUS_CODE_KEY), new LongWritable(1));    } else {        context.write(UNFETCHED_TEXT, new LongWritable(1));    }}
8f445d7a50d60bc0e03a6c7a84a91342429188f7c21933677bb53751bf0afa10
reduce
public void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException
{    long total = 0;    for (LongWritable val : values) {        total += val.get();    }    context.write(new LongWritable(total), key);}
8f445d7a50d60bc0e03a6c7a84a91342429188f7c21933677bb53751bf0afa10
reduce
public void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException
{    long total = 0;    for (LongWritable val : values) {        total += val.get();    }    context.write(key, new LongWritable(total));}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(NutchConfiguration.create(), new ProtocolStatusStatistics(), args);}
a577a70238368377d7929d72b6c89165f4401024e0f02ed938d67ddb6419e963
getReaders
public static SequenceFile.Reader[] getReaders(Path dir, Configuration conf) throws IOException
{    FileSystem fs = dir.getFileSystem(conf);    Path[] names = FileUtil.stat2Paths(fs.listStatus(dir));    Arrays.sort(names);    SequenceFile.Reader[] parts = new SequenceFile.Reader[names.length];    for (int i = 0; i < names.length; i++) {        parts[i] = new SequenceFile.Reader(conf, SequenceFile.Reader.file(names[i]));    }    return parts;}
5cea2a7c4e1f15509b5030e71609dca919138d48d1aebe9efc31435a268ea192
setup
public void setup(Context context)
{    Configuration conf = context.getConfiguration();    this.protocolFactory = new ProtocolFactory(conf);    this.filter = conf.getBoolean(SITEMAP_URL_FILTERING, true);    this.normalize = conf.getBoolean(SITEMAP_URL_NORMALIZING, true);    this.strict = conf.getBoolean(SITEMAP_STRICT_PARSING, true);    this.tryDefaultSitemapXml = conf.getBoolean(SITEMAP_ALWAYS_TRY_SITEMAPXML_ON_ROOT, true);    this.maxRedir = conf.getInt(SITEMAP_REDIR_MAX, 3);    this.parser = new SiteMapParser(strict);    if (filter) {        filters = new URLFilters(conf);    }    if (normalize) {        normalizers = new URLNormalizers(conf, URLNormalizers.SCOPE_DEFAULT);    }}
4c9ec82e8777bee39c94eaffbd42f3bf891ce1ff9da91c3080a6b85972806e5d
map
public void map(Text key, Writable value, Context context) throws IOException, InterruptedException
{    String url;    try {        if (value instanceof CrawlDatum) {                        context.write(key, (CrawlDatum) value);        } else if (value instanceof HostDatum) {            generateSitemapsFromHostname(key.toString(), context);        } else if (value instanceof Text) {                        url = key.toString();            if (url.startsWith("http://") || url.startsWith("https://") || url.startsWith("ftp://") || url.startsWith("file:/")) {                                if ((url = filterNormalize(url)) == null) {                    context.getCounter("Sitemap", "filtered_records").increment(1);                    return;                }                context.getCounter("Sitemap", "sitemap_seeds").increment(1);                generateSitemapUrlDatum(protocolFactory.getProtocol(url), url, context);            } else {                LOG.info("generateSitemapsFromHostname: " + key.toString());                generateSitemapsFromHostname(key.toString(), context);            }        }    } catch (Exception e) {        LOG.warn("Exception for record {} : {}", key.toString(), StringUtils.stringifyException(e));    }}
2b889bbf73ce3ba54b81471a74e4af72862f38b422f959d769f98655dfab46a5
filterNormalize
private String filterNormalize(String url)
{    try {        if (normalizers != null)            url = normalizers.normalize(url, URLNormalizers.SCOPE_DEFAULT);        if (filters != null)            url = filters.filter(url);    } catch (Exception e) {        return null;    }    return url;}
c67c9645f3fcee5b9641a249c247eca29d3c562259ab9d1bb38ac03e69621026
generateSitemapsFromHostname
private void generateSitemapsFromHostname(String host, Context context)
{    try {                                String url;        if ((url = filterNormalize("http://" + host + "/")) == null && (url = filterNormalize("https://" + host + "/")) == null && (url = filterNormalize("ftp://" + host + "/")) == null && (url = filterNormalize("file:/" + host + "/")) == null) {            context.getCounter("Sitemap", "filtered_records").increment(1);            return;        }                BaseRobotRules rules = protocolFactory.getProtocol(url).getRobotRules(new Text(url), datum, null);        List<String> sitemaps = rules.getSitemaps();        if (tryDefaultSitemapXml && sitemaps.size() == 0) {            sitemaps.add(url + "sitemap.xml");        }        for (String sitemap : sitemaps) {            context.getCounter("Sitemap", "sitemaps_from_hostname").increment(1);            sitemap = filterNormalize(sitemap);            if (sitemap == null) {                context.getCounter("Sitemap", "filtered_sitemaps_from_hostname").increment(1);            } else {                generateSitemapUrlDatum(protocolFactory.getProtocol(sitemap), sitemap, context);            }        }    } catch (Exception e) {        LOG.warn("Exception for record {} : {}", host, StringUtils.stringifyException(e));    }}
7c2a14203902f95c43d31c1ebb71982ba85f1f5b05d4a78f2a6b20be1149438b
generateSitemapUrlDatum
private void generateSitemapUrlDatum(Protocol protocol, String url, Context context) throws Exception
{    ProtocolOutput output = protocol.getProtocolOutput(new Text(url), datum);    ProtocolStatus status = output.getStatus();    Content content = output.getContent();        int maxRedir = this.maxRedir;    while (!output.getStatus().isSuccess() && output.getStatus().isRedirect() && maxRedir > 0) {        String[] stuff = output.getStatus().getArgs();        url = filterNormalize(stuff[0]);                if (url == null) {            break;        }        output = protocol.getProtocolOutput(new Text(url), datum);        status = output.getStatus();        content = output.getContent();        maxRedir--;    }    if (status.getCode() != ProtocolStatus.SUCCESS) {                        context.getCounter("Sitemap", "failed_fetches").increment(1);        LOG.error("Error while fetching the sitemap. Status code: {} for {}", status.getCode(), url);        return;    }    AbstractSiteMap asm = parser.parseSiteMap(content.getContentType(), content.getContent(), new URL(url));    if (asm instanceof SiteMap) {        LOG.info("Parsing sitemap file: {}", asm.getUrl().toString());        SiteMap sm = (SiteMap) asm;        Collection<SiteMapURL> sitemapUrls = sm.getSiteMapUrls();        for (SiteMapURL sitemapUrl : sitemapUrls) {                        if (!strict || sitemapUrl.isValid()) {                String key = filterNormalize(sitemapUrl.getUrl().toString());                if (key != null) {                    CrawlDatum sitemapUrlDatum = new CrawlDatum();                    sitemapUrlDatum.setStatus(CrawlDatum.STATUS_INJECTED);                    sitemapUrlDatum.setScore((float) sitemapUrl.getPriority());                    if (sitemapUrl.getChangeFrequency() != null) {                        int fetchInterval = -1;                        switch(sitemapUrl.getChangeFrequency()) {                            case ALWAYS:                                fetchInterval = 1;                                break;                                                        case HOURLY:                                fetchInterval = 3600;                                break;                                                        case DAILY:                                fetchInterval = 86400;                                break;                                                        case WEEKLY:                                fetchInterval = 604800;                                break;                                                        case MONTHLY:                                fetchInterval = 2592000;                                break;                                                        case YEARLY:                                fetchInterval = 31536000;                                break;                                                        case NEVER:                                fetchInterval = Integer.MAX_VALUE;                                break;                        }                        sitemapUrlDatum.setFetchInterval(fetchInterval);                    }                    if (sitemapUrl.getLastModified() != null) {                        sitemapUrlDatum.setModifiedTime(sitemapUrl.getLastModified().getTime());                    }                    context.write(new Text(key), sitemapUrlDatum);                }            }        }    } else if (asm instanceof SiteMapIndex) {        SiteMapIndex index = (SiteMapIndex) asm;        Collection<AbstractSiteMap> sitemapUrls = index.getSitemaps();        if (sitemapUrls.isEmpty()) {            return;        }        LOG.info("Parsing sitemap index file: {}", index.getUrl().toString());        for (AbstractSiteMap sitemap : sitemapUrls) {            String sitemapUrl = filterNormalize(sitemap.getUrl().toString());            if (sitemapUrl != null) {                generateSitemapUrlDatum(protocol, sitemapUrl, context);            }        }    }}
5cea2a7c4e1f15509b5030e71609dca919138d48d1aebe9efc31435a268ea192
setup
public void setup(Context context)
{    Configuration conf = context.getConfiguration();    this.overwriteExisting = conf.getBoolean(SITEMAP_OVERWRITE_EXISTING, false);}
dfa33bb74c8851fea1ca7d1879839d7b539c5564809dc8824a9b4ec385276528
reduce
public void reduce(Text key, Iterable<CrawlDatum> values, Context context) throws IOException, InterruptedException
{    sitemapDatum = null;    originalDatum = null;    for (CrawlDatum curr : values) {        if (curr.getStatus() == CrawlDatum.STATUS_INJECTED) {            sitemapDatum = new CrawlDatum();            sitemapDatum.set(curr);        } else {            originalDatum = new CrawlDatum();            originalDatum.set(curr);        }    }    if (originalDatum != null) {                if (sitemapDatum != null && overwriteExisting) {            originalDatum.setScore(sitemapDatum.getScore());            originalDatum.setFetchInterval(sitemapDatum.getFetchInterval());            originalDatum.setModifiedTime(sitemapDatum.getModifiedTime());        }        context.getCounter("Sitemap", "existing_sitemap_entries").increment(1);        context.write(key, originalDatum);    } else if (sitemapDatum != null) {                context.getCounter("Sitemap", "new_sitemap_entries").increment(1);        sitemapDatum.setStatus(CrawlDatum.STATUS_DB_UNFETCHED);        context.write(key, sitemapDatum);    }}
286f7f5d84c935e8a70319fa2cfe94ba80f557bec1a58e16b0a451c1d7499ef0
sitemap
public void sitemap(Path crawldb, Path hostdb, Path sitemapUrlDir, boolean strict, boolean filter, boolean normalize, int threads) throws Exception
{    long start = System.currentTimeMillis();    if (LOG.isInfoEnabled()) {        LOG.info("SitemapProcessor: Starting at {}", sdf.format(start));    }    FileSystem fs = crawldb.getFileSystem(getConf());    Path old = new Path(crawldb, "old");    Path current = new Path(crawldb, "current");    Path tempCrawlDb = new Path(crawldb, "crawldb-" + Integer.toString(new Random().nextInt(Integer.MAX_VALUE)));        Path lock = new Path(crawldb, LOCK_NAME);    if (!fs.exists(current))        fs.mkdirs(current);    LockUtil.createLockFile(fs, lock, false);    Configuration conf = getConf();    conf.setBoolean(SITEMAP_STRICT_PARSING, strict);    conf.setBoolean(SITEMAP_URL_FILTERING, filter);    conf.setBoolean(SITEMAP_URL_NORMALIZING, normalize);    conf.setBoolean("mapreduce.fileoutputcommitter.marksuccessfuljobs", false);    Job job = Job.getInstance(conf, "SitemapProcessor_" + crawldb.toString());    job.setJarByClass(SitemapProcessor.class);        MultipleInputs.addInputPath(job, current, SequenceFileInputFormat.class);    if (sitemapUrlDir != null)        MultipleInputs.addInputPath(job, sitemapUrlDir, KeyValueTextInputFormat.class);    if (hostdb != null)        MultipleInputs.addInputPath(job, new Path(hostdb, CURRENT_NAME), SequenceFileInputFormat.class);    FileOutputFormat.setOutputPath(job, tempCrawlDb);    job.setOutputFormatClass(MapFileOutputFormat.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(CrawlDatum.class);    job.setMapperClass(MultithreadedMapper.class);    MultithreadedMapper.setMapperClass(job, SitemapMapper.class);    MultithreadedMapper.setNumberOfThreads(job, threads);    job.setReducerClass(SitemapReducer.class);    try {        boolean success = job.waitForCompletion(true);        if (!success) {            String message = "SitemapProcessor_" + crawldb.toString() + " job did not succeed, job status: " + job.getStatus().getState() + ", reason: " + job.getStatus().getFailureInfo();            LOG.error(message);            NutchJob.cleanupAfterFailure(tempCrawlDb, lock, fs);                        throw new RuntimeException(message);        }        boolean preserveBackup = conf.getBoolean("db.preserve.backup", true);        if (!preserveBackup && fs.exists(old))            fs.delete(old, true);        else            FSUtils.replace(fs, old, current, true);        FSUtils.replace(fs, current, tempCrawlDb, true);        LockUtil.removeLockFile(fs, lock);        if (LOG.isInfoEnabled()) {            long filteredRecords = job.getCounters().findCounter("Sitemap", "filtered_records").getValue();            long fromHostname = job.getCounters().findCounter("Sitemap", "sitemaps_from_hostname").getValue();            long fromSeeds = job.getCounters().findCounter("Sitemap", "sitemap_seeds").getValue();            long failedFetches = job.getCounters().findCounter("Sitemap", "failed_fetches").getValue();            long newSitemapEntries = job.getCounters().findCounter("Sitemap", "new_sitemap_entries").getValue();            LOG.info("SitemapProcessor: Total records rejected by filters: {}", filteredRecords);            LOG.info("SitemapProcessor: Total sitemaps from host name: {}", fromHostname);            LOG.info("SitemapProcessor: Total sitemaps from seed urls: {}", fromSeeds);            LOG.info("SitemapProcessor: Total failed sitemap fetches: {}", failedFetches);            LOG.info("SitemapProcessor: Total new sitemap entries added: {}", newSitemapEntries);            long end = System.currentTimeMillis();            LOG.info("SitemapProcessor: Finished at {}, elapsed: {}", sdf.format(end), TimingUtil.elapsedTime(start, end));        }    } catch (IOException | InterruptedException | ClassNotFoundException e) {        LOG.error("SitemapProcessor_" + crawldb.toString(), e);        NutchJob.cleanupAfterFailure(tempCrawlDb, lock, fs);        throw e;    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int res = ToolRunner.run(NutchConfiguration.create(), new SitemapProcessor(), args);    System.exit(res);}
1e82056621d635d12463c037e4a1c08f0c60e85b1c55b2b115dfecea0da0b696
usage
public static void usage()
{    System.err.println("Usage:\n SitemapProcessor <crawldb> [-hostdb <hostdb>] [-sitemapUrls <url_dir>] " + "[-threads <threads>] [-force] [-noStrict] [-noFilter] [-noNormalize]\n");    System.err.println("\t<crawldb>\t\tpath to crawldb where the sitemap urls would be injected");    System.err.println("\t-hostdb <hostdb>\tpath of a hostdb. Sitemap(s) from these hosts would be downloaded");    System.err.println("\t-sitemapUrls <url_dir>\tpath to directory with sitemap urls or hostnames");    System.err.println("\t-threads <threads>\tNumber of threads created per mapper to fetch sitemap urls (default: 8)");    System.err.println("\t-force\t\t\tforce update even if CrawlDb appears to be locked (CAUTION advised)");    System.err.println("\t-noStrict\t\tBy default Sitemap parser rejects invalid urls. '-noStrict' disables that.");    System.err.println("\t-noFilter\t\tturn off URLFilters on urls (optional)");    System.err.println("\t-noNormalize\t\tturn off URLNormalizer on urls (optional)");}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    if (args.length < 3) {        usage();        return -1;    }    Path crawlDb = new Path(args[0]);    Path hostDb = null;    Path urlDir = null;    boolean strict = true;    boolean filter = true;    boolean normalize = true;    int threads = 8;    for (int i = 1; i < args.length; i++) {        if (args[i].equals("-hostdb")) {            hostDb = new Path(args[++i]);            LOG.info("SitemapProcessor: hostdb: {}", hostDb);        } else if (args[i].equals("-sitemapUrls")) {            urlDir = new Path(args[++i]);            LOG.info("SitemapProcessor: sitemap urls dir: {}", urlDir);        } else if (args[i].equals("-threads")) {            threads = Integer.valueOf(args[++i]);            LOG.info("SitemapProcessor: threads: {}", threads);        } else if (args[i].equals("-noStrict")) {            LOG.info("SitemapProcessor: 'strict' parsing disabled");            strict = false;        } else if (args[i].equals("-noFilter")) {            LOG.info("SitemapProcessor: filtering disabled");            filter = false;        } else if (args[i].equals("-noNormalize")) {            LOG.info("SitemapProcessor: normalizing disabled");            normalize = false;        } else {            LOG.info("SitemapProcessor: Found invalid argument \"{}\"\n", args[i]);            usage();            return -1;        }    }    try {        sitemap(crawlDb, hostDb, urlDir, strict, filter, normalize, threads);        return 0;    } catch (Exception e) {        LOG.error("SitemapProcessor: {}", StringUtils.stringifyException(e));        return -1;    }}
a9a290424f3deca39ebd4260fc07dcf23435cd962d264876a3523c2d8d7fd9bc
rightPad
public static String rightPad(String s, int length)
{    StringBuffer sb = new StringBuffer(s);    for (int i = length - s.length(); i > 0; i--) sb.append(" ");    return sb.toString();}
562816b304bdec41c677be4d5d8f49cc0b49dc2d49bceba031368b87e7a389ed
leftPad
public static String leftPad(String s, int length)
{    StringBuffer sb = new StringBuffer();    for (int i = length - s.length(); i > 0; i--) sb.append(" ");    sb.append(s);    return sb.toString();}
3892c47b64cd589a9ef7ca00ad7f476927e321083a2ac6c061c9e78284a8b4c1
toHexString
public static String toHexString(byte[] buf)
{    return toHexString(buf, null, Integer.MAX_VALUE);}
f526f1eefedb8087f65f6ffc3a216089eb6b292e360c9517464d6134ec1aa074
toHexString
public static String toHexString(byte[] buf, String sep, int lineLen)
{    if (buf == null)        return null;    if (lineLen <= 0)        lineLen = Integer.MAX_VALUE;    StringBuffer res = new StringBuffer(buf.length * 2);    for (int i = 0; i < buf.length; i++) {        int b = buf[i];        res.append(HEX_DIGITS[(b >> 4) & 0xf]);        res.append(HEX_DIGITS[b & 0xf]);        if (i > 0 && (i % lineLen) == 0)            res.append('\n');        else if (sep != null && i < lineLen - 1)            res.append(sep);    }    return res.toString();}
f2ad64623a27cde5dc70d03fb0fa50df80c297613996c882ba3327cbb66be188
fromHexString
public static byte[] fromHexString(String text)
{    text = text.trim();    if (text.length() % 2 != 0)        text = "0" + text;    int resLen = text.length() / 2;    int loNibble, hiNibble;    byte[] res = new byte[resLen];    for (int i = 0; i < resLen; i++) {        int j = i << 1;        hiNibble = charToNibble(text.charAt(j));        loNibble = charToNibble(text.charAt(j + 1));        if (loNibble == -1 || hiNibble == -1)            return null;        res[i] = (byte) (hiNibble << 4 | loNibble);    }    return res;}
63ab4f8d2acf81586f252621b21e98e41ca0491bdbe5f4f07d4fed506d3a2071
charToNibble
private static final int charToNibble(char c)
{    if (c >= '0' && c <= '9') {        return c - '0';    } else if (c >= 'a' && c <= 'f') {        return 0xa + (c - 'a');    } else if (c >= 'A' && c <= 'F') {        return 0xA + (c - 'A');    } else {        return -1;    }}
c1bebd808b9a2e1c65e5d75f5f2a0df27ab80fc39f23365534752cd950fe9564
isEmpty
public static boolean isEmpty(String str)
{    return (str == null) || (str.equals(""));}
f20282e34103bd1413eae18af2115ef7ad67b7ff560be625870bffe8190b56d3
cleanField
public static String cleanField(String value)
{    return value.replaceAll("", "");}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    if (args.length != 1)        System.out.println("Usage: StringUtil <encoding name>");    else        System.out.println(args[0] + " is resolved to " + EncodingDetector.resolveEncodingAlias(args[0]));}
102e1445f9324924dff273927c0650e246ee5f7634b43f52b1b623758493b9ac
matches
public boolean matches(String input)
{    TrieNode node = root;    for (int i = input.length() - 1; i >= 0; i--) {        node = node.getChild(input.charAt(i));        if (node == null)            return false;        if (node.isTerminal())            return true;    }    return false;}
8cd888159e5f96b0f55c564f58f538fcab3daadfb128a72ef93141a03a34c567
shortestMatch
public String shortestMatch(String input)
{    TrieNode node = root;    for (int i = input.length() - 1; i >= 0; i--) {        node = node.getChild(input.charAt(i));        if (node == null)            return null;        if (node.isTerminal())            return input.substring(i);    }    return null;}
8a56653a81d51afd6025595a6f60a433a0a882eaf13a8b14d03518ea73957d9c
longestMatch
public String longestMatch(String input)
{    TrieNode node = root;    String result = null;    for (int i = input.length() - 1; i >= 0; i--) {        node = node.getChild(input.charAt(i));        if (node == null)            break;        if (node.isTerminal())            result = input.substring(i);    }    return result;}
e892d92f448b2cc05ef03daab91adec9f708c1b5d13320d6e9eb01b96e1965c3
main
public static final void main(String[] argv)
{    SuffixStringMatcher matcher = new SuffixStringMatcher(new String[] { "a", "abcd", "bcd", "bcdefg", "defg", "aac", "baz", "foo", "foobar" });    String[] tests = { "a", "ac", "abcd", "abcdefg", "apple", "aa", "aac", "aaccca", "abaz", "baz", "bazooka", "fo", "foobar", "kite" };    for (int i = 0; i < tests.length; i++) {        System.out.println("testing: " + tests[i]);        System.out.println("   matches: " + matcher.matches(tests[i]));        System.out.println("  shortest: " + matcher.shortestMatch(tests[i]));        System.out.println("   longest: " + matcher.longestMatch(tests[i]));    }}
034c5fc78438ecd94207e31a1b946141fa2cb3569ea80eca97663f6a5df0382d
reverseUrl
public static String reverseUrl(String urlString) throws MalformedURLException
{    return reverseUrl(new URL(urlString));}
79d63a394bcc3ba48203fc0778aa3405b82eb86b90e37a1d37cd280d89e8b9fb
reverseUrl
public static String reverseUrl(URL url)
{    String host = url.getHost();    String file = url.getFile();    String protocol = url.getProtocol();    int port = url.getPort();    StringBuilder buf = new StringBuilder();    /* reverse host */    reverseAppendSplits(host, buf);    /* add protocol */    buf.append(':');    buf.append(protocol);    /* add port if necessary */    if (port != -1) {        buf.append(':');        buf.append(port);    }    /* add path */    if (file.length() > 0 && '/' != file.charAt(0)) {        buf.append('/');    }    buf.append(file);    return buf.toString();}
dd29332d5057413967179a1330a4f763eb491374249b174586429a2ec4e6d1ca
unreverseUrl
public static String unreverseUrl(String reversedUrl)
{    StringBuilder buf = new StringBuilder(reversedUrl.length() + 2);    int pathBegin = reversedUrl.indexOf('/');    if (pathBegin == -1)        pathBegin = reversedUrl.length();    String sub = reversedUrl.substring(0, pathBegin);        String[] splits = StringUtils.splitPreserveAllTokens(sub, ':');                    buf.append(splits[1]);    buf.append("://");        reverseAppendSplits(splits[0], buf);        if (splits.length == 3) {                buf.append(':');        buf.append(splits[2]);    }    buf.append(reversedUrl.substring(pathBegin));    return buf.toString();}
f21bfe5972706a6dfe3db51b0dbcec3174edf9626091989ecc052608b6acf24a
getReversedHost
public static String getReversedHost(String reversedUrl)
{    return reversedUrl.substring(0, reversedUrl.indexOf(':'));}
b86f788ee77a4d045c1c62b5601ed71befab5d34d0df0f602ca07b951556ea53
reverseAppendSplits
private static void reverseAppendSplits(String string, StringBuilder buf)
{    String[] splits = StringUtils.split(string, '.');    if (splits.length > 0) {        for (int i = splits.length - 1; i > 0; i--) {            buf.append(splits[i]);            buf.append('.');        }        buf.append(splits[0]);    } else {        buf.append(string);    }}
608ec655e397ce0b0bfe138cb4c117170dd605d9e2673fc4a5cac73e2fec811b
reverseHost
public static String reverseHost(String hostName)
{    StringBuilder buf = new StringBuilder();    reverseAppendSplits(hostName, buf);    return buf.toString();}
50ffa052d9353dacbfb02a0a9894ae6b14efe4a457029db15f13fc656f3d088f
unreverseHost
public static String unreverseHost(String reversedHostName)
{        return reverseHost(reversedHostName);}
c222349a78410e6ab4d3bc1cbe9b1182ede7fe895948e4716d6d660eb43c23ee
toString
public static String toString(CharSequence utf8)
{    return (utf8 == null ? null : StringUtil.cleanField(utf8.toString()));}
6339e4b728d557dcf8c04416a87b64c81aa7f22ee547ee0645bb073d9f8c0e3b
logDateMillis
public static String logDateMillis(long millis)
{    return logDateFormat.format(LocalDateTime.ofInstant(Instant.ofEpochMilli(millis), ZoneId.systemDefault()));}
fca23b64f5fa333450017d3f7d6286bc871e639ce2cbc7cc80ba557b8184e3ba
elapsedTime
public static String elapsedTime(long start, long end)
{    if (start > end) {        return null;    }    return secondsToHMS((end - start) / 1000);}
645d021f26ba85769b4c9584fb81b82139bf249886027d52db3b25fe05a8502a
secondsToHMS
public static String secondsToHMS(long seconds)
{    long hours = TimeUnit.SECONDS.toHours(seconds);    long minutes = TimeUnit.SECONDS.toMinutes(seconds) % TimeUnit.HOURS.toMinutes(1);    seconds = TimeUnit.SECONDS.toSeconds(seconds) % TimeUnit.MINUTES.toSeconds(1);    return String.format("%02d:%02d:%02d", hours, minutes, seconds);}
57e400aee2e6eaa77b3f0f63367ef4bdcf4291e5f2c58499ca8b522c3bca2f66
secondsToDaysHMS
public static String secondsToDaysHMS(long seconds)
{    long days = TimeUnit.SECONDS.toDays(seconds);    if (days == 0)        return secondsToHMS(seconds);    String hhmmss = secondsToHMS(seconds % TimeUnit.DAYS.toSeconds(1));    return String.format("%d days, %s", days, hhmmss);}
2d9168d2cf2ff635f31478b3da2de0be3dcf5aa7800cfdb4dbf51453a444f91d
isTerminal
 boolean isTerminal()
{    return terminal;}
b4f02d40fd42f2cf50bbd08e2dae0cfc29f6984f114551553a390b8946c49dd1
getChildAddIfNotPresent
 TrieNode getChildAddIfNotPresent(char nextChar, boolean isTerminal)
{    if (childrenList == null) {        childrenList = new LinkedList<>();        childrenList.addAll(Arrays.asList(children));        children = null;    }    if (childrenList.size() == 0) {        TrieNode newNode = new TrieNode(nextChar, isTerminal);        childrenList.add(newNode);        return newNode;    }    ListIterator<TrieNode> iter = childrenList.listIterator();    TrieNode node = iter.next();    while ((node.nodeChar < nextChar) && iter.hasNext()) node = iter.next();    if (node.nodeChar == nextChar) {        node.terminal = node.terminal | isTerminal;        return node;    }    if (node.nodeChar > nextChar)        iter.previous();    TrieNode newNode = new TrieNode(nextChar, isTerminal);    iter.add(newNode);    return newNode;}
fd556de0527f51bf65efb5c84e9fef49777563f16977e9946a48ad8247c666ea
getChild
 TrieNode getChild(char nextChar)
{    if (children == null) {        compile();    }    int min = 0;    int max = children.length - 1;    int mid = 0;    while (min < max) {        mid = (min + max) / 2;        if (children[mid].nodeChar == nextChar)            return children[mid];        if (children[mid].nodeChar < nextChar)            min = mid + 1;        else                        max = mid - 1;    }    if (min == max)        if (children[min].nodeChar == nextChar)            return children[min];    return null;}
fa4b0bd4c7c95c3e3b11d2d13c1d39c770e5fc8df77d64d188db1e1d3254226b
compareTo
public int compareTo(TrieNode other)
{    if (this.nodeChar < other.nodeChar)        return -1;    if (this.nodeChar == other.nodeChar)        return 0;        return 1;}
f3a37afdfae8fcb70a4c2e7852cb73000540eb59c23aebfe4c7b6718cd606015
compile
 synchronized void compile()
{    if (childrenList != null) {        children = childrenList.toArray(new TrieNode[childrenList.size()]);        childrenList = null;        Arrays.sort(children);    }}
b516f57724b9c2cded6b10dec4a00001259644dbe13bc29df0bd64b5cf0966cb
matchChar
protected final TrieNode matchChar(TrieNode node, String s, int idx)
{    return node.getChild(s.charAt(idx));}
360cb2e8972322c149b3a161e5f23aa2c57be2733b0107fde5a7526426ddb9b4
addPatternForward
protected final void addPatternForward(String s)
{    TrieNode node = root;    int stop = s.length() - 1;    int i;    if (s.length() > 0) {        for (i = 0; i < stop; i++) node = node.getChildAddIfNotPresent(s.charAt(i), false);        node = node.getChildAddIfNotPresent(s.charAt(i), true);    }}
501ed33ad2f06be5bd4fc169435e2701a1909a41e86267bb78f1732e42b8fd16
addPatternBackward
protected final void addPatternBackward(String s)
{    TrieNode node = root;    if (s.length() > 0) {        for (int i = s.length() - 1; i > 0; i--) node = node.getChildAddIfNotPresent(s.charAt(i), false);        node = node.getChildAddIfNotPresent(s.charAt(0), true);    }}
4c57a784bf05bcc9e5f36eae2ccbb47b3d40db75df947449f1a09b4f7b82590c
resolveURL
public static URL resolveURL(URL base, String target) throws MalformedURLException
{    target = target.trim();        if (target.startsWith("?")) {        return fixPureQueryTargets(base, target);    }    return new URL(base, target);}
69b9319d48dee03fbec39d6db4d05273e2a13501f8dea848f6fae4a6cb770cf6
fixPureQueryTargets
 static URL fixPureQueryTargets(URL base, String target) throws MalformedURLException
{    if (!target.startsWith("?"))        return new URL(base, target);    String basePath = base.getPath();    String baseRightMost = "";    int baseRightMostIdx = basePath.lastIndexOf("/");    if (baseRightMostIdx != -1) {        baseRightMost = basePath.substring(baseRightMostIdx + 1);    }    if (target.startsWith("?"))        target = baseRightMost + target;    return new URL(base, target);}
85b255b84333ffde43831aea0ea724424fb766fcaa4deaf73f24ca02f2c83a00
getDomainName
public static String getDomainName(URL url)
{    DomainSuffixes tlds = DomainSuffixes.getInstance();    String host = url.getHost();        if (host.endsWith("."))        host = host.substring(0, host.length() - 1);    if (IP_PATTERN.matcher(host).matches())        return host;    int index = 0;    String candidate = host;    for (; index >= 0; ) {        index = candidate.indexOf('.');        String subCandidate = candidate.substring(index + 1);        if (tlds.isDomainSuffix(subCandidate)) {            return candidate;        }        candidate = subCandidate;    }    return candidate;}
12b87e1aab55a9e5bc35f520104082bc6a26e0ccd817b9c3697405e09f00c25e
getDomainName
public static String getDomainName(String url) throws MalformedURLException
{    return getDomainName(new URL(url));}
435405590f81d81e8e8b39ff3bc69214e11769c413872e4cd6e5da2e9fdc1245
getTopLevelDomainName
public static String getTopLevelDomainName(URL url) throws MalformedURLException
{    String suffix = getDomainSuffix(url).toString();    int idx = suffix.lastIndexOf(".");    if (idx != -1) {        return suffix.substring(idx + 1);    } else {        return suffix;    }}
55df5cf20c803fb64fc9efa31661b139412e32b3482bb85f09ecd44fb5cbd002
getTopLevelDomainName
public static String getTopLevelDomainName(String url) throws MalformedURLException
{    return getTopLevelDomainName(new URL(url));}
49998f84742e34c36d328c416fb8bf1ef0a14ff38bd6f1a96ced9b289dc7928a
isSameDomainName
public static boolean isSameDomainName(URL url1, URL url2)
{    return getDomainName(url1).equalsIgnoreCase(getDomainName(url2));}
7873edf56984c36514c2ee8de740bdcdfed3be0584e3f587107a0ccde83b6544
isSameDomainName
public static boolean isSameDomainName(String url1, String url2) throws MalformedURLException
{    return isSameDomainName(new URL(url1), new URL(url2));}
bf4874297de32ef8c42bc47ce06e7a322bb383d89c3d631669e7ae3f8e8e53ff
getDomainSuffix
public static DomainSuffix getDomainSuffix(URL url)
{    DomainSuffixes tlds = DomainSuffixes.getInstance();    String host = url.getHost();    if (IP_PATTERN.matcher(host).matches())        return null;    int index = 0;    String candidate = host;    for (; index >= 0; ) {        index = candidate.indexOf('.');        String subCandidate = candidate.substring(index + 1);        DomainSuffix d = tlds.get(subCandidate);        if (d != null) {            return d;        }        candidate = subCandidate;    }    return null;}
6c4036012d0ecfec9aa2b819e07c16c351e67f7217d109fb63ee315513d8502e
getDomainSuffix
public static DomainSuffix getDomainSuffix(String url) throws MalformedURLException
{    return getDomainSuffix(new URL(url));}
601680f05ab430140df7a8cc7c3acac8f8e4cfa968433f793a55c7e289f385a5
getHostSegments
public static String[] getHostSegments(URL url)
{    String host = url.getHost();        if (IP_PATTERN.matcher(host).matches())        return new String[] { host };    return host.split("\\.");}
2b40d055b8ce8e5a0ad8c7bf0eaf7a7fa765f4c0d040cb4a7c6dbdb348e9a197
getHostSegments
public static String[] getHostSegments(String url) throws MalformedURLException
{    return getHostSegments(new URL(url));}
2c14d717762df7446b3dcfe5d331419d9f832d83446be007e9f15d0f227ebd4d
chooseRepr
public static String chooseRepr(String src, String dst, boolean temp)
{        URL srcUrl;    URL dstUrl;    try {        srcUrl = new URL(src);        dstUrl = new URL(dst);    } catch (MalformedURLException e) {        return dst;    }        String srcDomain = URLUtil.getDomainName(srcUrl);    String dstDomain = URLUtil.getDomainName(dstUrl);    String srcHost = srcUrl.getHost();    String dstHost = dstUrl.getHost();    String srcFile = srcUrl.getFile();    String dstFile = dstUrl.getFile();        boolean srcRoot = (srcFile.equals("/") || srcFile.length() == 0);    boolean destRoot = (dstFile.equals("/") || dstFile.length() == 0);        if (!srcDomain.equals(dstDomain)) {        return dst;    }        if (!temp) {                if (srcRoot) {            return src;        } else {            return dst;        }    } else {                if (srcRoot && !destRoot) {            return src;        } else if (!srcRoot && destRoot) {                        return dst;        } else if (!srcRoot && !destRoot && (srcHost.equals(dstHost))) {                        int numSrcPaths = srcFile.split("/").length;            int numDstPaths = dstFile.split("/").length;            if (numSrcPaths != numDstPaths) {                return (numDstPaths < numSrcPaths ? dst : src);            } else {                int srcPathLength = srcFile.length();                int dstPathLength = dstFile.length();                return (dstPathLength < srcPathLength ? dst : src);            }        } else {                        int numSrcSubs = srcHost.split("\\.").length;            int numDstSubs = dstHost.split("\\.").length;            return (numDstSubs < numSrcSubs ? dst : src);        }    }}
1b27887b38eded83684a9488c63eeda449b687676821b1fca226cc14a8beef63
getHost
public static String getHost(String url)
{    try {        return new URL(url).getHost().toLowerCase();    } catch (MalformedURLException e) {        return null;    }}
31b66308459cbc445f4f7a1f28882c5f91c9a8035877316d425996d2b87bdead
getPage
public static String getPage(String url)
{    try {                url = url.toLowerCase();        String queryStr = new URL(url).getQuery();        return (queryStr != null) ? url.replace("?" + queryStr, "") : url;    } catch (MalformedURLException e) {        return null;    }}
e8b15ab89f1809c45641b29d78ad74cbfddfba120487557df4cb774a6d5f0d70
getProtocol
public static String getProtocol(String url)
{    try {        return getProtocol(new URL(url));    } catch (Exception e) {        return null;    }}
c257e1fca739430fe00723c2c4bf652c7add313f3dfcee4be37bab15a0f4dc83
getProtocol
public static String getProtocol(URL url)
{    return url.getProtocol();}
f63b8bc584c214a873b3ed0f4fbd821353244904f9587792dadeb3a299ff5094
toASCII
public static String toASCII(String url)
{    try {        URL u = new URL(url);        String host = u.getHost();        if (host == null || host.isEmpty()) {                        return url;        }        URI p = new URI(u.getProtocol(), u.getUserInfo(), IDN.toASCII(host), u.getPort(), u.getPath(), u.getQuery(), u.getRef());        return p.toString();    } catch (Exception e) {        return null;    }}
c34bcb2e7bd6a94c2b62284cf5bdfd805eeef427f0ceea95fcf470d1692bbb8a
toUNICODE
public static String toUNICODE(String url)
{    try {        URL u = new URL(url);        String host = u.getHost();        if (host == null || host.isEmpty()) {                        return url;        }        StringBuilder sb = new StringBuilder();        sb.append(u.getProtocol());        sb.append("://");        if (u.getUserInfo() != null) {            sb.append(u.getUserInfo());            sb.append('@');        }        sb.append(IDN.toUnicode(host));        if (u.getPort() != -1) {            sb.append(':');            sb.append(u.getPort());        }                sb.append(u.getFile());        if (u.getRef() != null) {            sb.append('#');            sb.append(u.getRef());        }        return sb.toString();    } catch (Exception e) {        return null;    }}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    if (args.length != 1) {        System.err.println("Usage : URLUtil <url>");        return;    }    String url = args[0];    try {        System.out.println(URLUtil.getDomainName(new URL(url)));    } catch (MalformedURLException ex) {        ex.printStackTrace();    }}
95aa10bd69a893a6edce6091316902d7644c4caed139121bf1c66e2374be5e7a
executeCrawlCycle
public synchronized void executeCrawlCycle()
{    listener.crawlingStarted(crawl);    for (RemoteCommand command : remoteCommands) {        JobInfo jobInfo = executor.executeRemoteJob(command);        command.setJobInfo(jobInfo);        LOG.info("Executed remote command data: {}", command);        if (jobInfo.getState() == State.FAILED) {            listener.onCrawlError(crawl, jobInfo.getMsg());            return;        }        executedCommands.add(command);        listener.commandExecuted(crawl, command, calculateProgress());    }    listener.crawlingFinished(crawl);}
16cdc89d7d833a46966d7ba135a2d86ab25ce19b580a3238d36a5f02a3731d93
calculateProgress
private int calculateProgress()
{    if (CollectionUtils.isEmpty(remoteCommands)) {        return 0;    }    return (int) ((float) executedCommands.size() / (float) remoteCommands.size() * 100);}
a7389a348ef7cb9c106b42d934120367b59a64bf8511e5f84cfc3b7d76898ec1
createClient
public void createClient()
{    ClientConfig clientConfig = new DefaultClientConfig();    clientConfig.getFeatures().put(JSONConfiguration.FEATURE_POJO_MAPPING, true);    this.client = Client.create(clientConfig);    this.nutchResource = client.resource(instance.getUrl());}
66a9d5fd521374cf660a392f48ee671c9d22a2e4eb57db77b89321bbabb17262
getNutchStatus
public NutchStatus getNutchStatus()
{    return nutchResource.path("/admin").type(APPLICATION_JSON).get(NutchStatus.class);}
dfe225918e2c33dcea5748e386559583c9e8f0b59e50a0054d1eb200baa7ec72
getConnectionStatus
public ConnectionStatus getConnectionStatus()
{    getNutchStatus();    return ConnectionStatus.CONNECTED;}
15aebffe767cd90a1135d9a09523b326ad3040db5c3394b340dfd271fc2c7435
executeJob
public String executeJob(JobConfig jobConfig)
{    JobInfo jobInfo = nutchResource.path("/job/create").type(APPLICATION_JSON).post(JobInfo.class, jobConfig);    return jobInfo.getId();}
372fe2ed05bfc3fb86f53f18a2d6c357f938781c9b4d5b2fd7aa9b191ad4cfe3
getJobInfo
public JobInfo getJobInfo(String jobId)
{    return nutchResource.path("/job/" + jobId).type(APPLICATION_JSON).get(JobInfo.class);}
366ada2fa31915a2758c1f68a9452531e5a7fe540afccebaae6f4ad5165c82af
getNutchInstance
public NutchInstance getNutchInstance()
{    return instance;}
307cc2b62f6b2166a8e8e2f02556ef21500f2ed211d3cf6612e9c078be6ce04a
getNutchConfig
public Map<String, String> getNutchConfig(String config)
{    return nutchResource.path("/config/" + config).type(APPLICATION_JSON).get(Map.class);}
33c998779612932d443f249681e296f3d4799f15efa5738b24652369d811cc2f
createSeed
public String createSeed(SeedList seedList)
{    return nutchResource.path("/seed/create").type(APPLICATION_JSON).post(String.class, seedList);}
e7cde0e08a1f76144cdcd9ee16f31e469f027e7ac367ea0f6f2f1ec19df55bf1
getJobConfig
public JobConfig getJobConfig()
{    return jobConfig;}
cf5a59741476a9d0521ffae5c9b0696ec96b26d3d0f205f8c12c4a813d1a825e
setJobConfig
public void setJobConfig(JobConfig jobConfig)
{    this.jobConfig = jobConfig;}
b9ef202ca655a540c78572c97b37947cda191166078f5699f883596e32358733
getJobInfo
public JobInfo getJobInfo()
{    return jobInfo;}
160dd5ff8d0fab010dd33a8ff0da472dfb8824a01c9950073c16be58249a44ce
setJobInfo
public void setJobInfo(JobInfo jobInfo)
{    this.jobInfo = jobInfo;}
623d8f138f8c4c76bb9e778cbbfef39cbd657b17797a8b35e204be014ef056be
getTimeout
public Duration getTimeout()
{    return timeout;}
0a2b9e24c2b6c6b9b32cb00ab5ce3ba2d38b266b47e48d367c1693228d231fed
setTimeout
public void setTimeout(Duration timeout)
{    this.timeout = timeout;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    String statusInfo = StringUtils.EMPTY;    if (jobInfo != null) {        statusInfo = MessageFormat.format("{0}", jobInfo.getState());    }    return MessageFormat.format("{0} status: {1}", jobConfig.getType(), statusInfo);}
f6115a4286d432b36e965af9243913df5f343af0ae214e1589fa49968ae8077f
instance
public static RemoteCommandBuilder instance(JobType jobType)
{    return new RemoteCommandBuilder().withJobType(jobType);}
c79d0da50436deaf48230745704a0a8b58d3659499249be4df6f543b12f355cc
withJobType
public RemoteCommandBuilder withJobType(JobType jobType)
{    jobConfig.setType(jobType);    return this;}
ac5950351c4460b5952c6687b1466107c263630fba783beaef3178b48d07c21a
withConfigId
public RemoteCommandBuilder withConfigId(String configId)
{    jobConfig.setConfId(configId);    return this;}
79535bc3e6a9b1e8a559a6902ed9156062357de4ad2feefb1709973093f10c8d
withCrawlId
public RemoteCommandBuilder withCrawlId(String crawlId)
{    jobConfig.setCrawlId(crawlId);    return this;}
b55dd9f372b1e963efd574a006f1d52f4095a55ab3c246807b95d4443d5bf24b
withArgument
public RemoteCommandBuilder withArgument(String key, String value)
{    jobConfig.setArgument(key, value);    return this;}
26f4e36af7d44dd60d7bfb2426a56153fcd319d3912cffc18a5b63ad5832b98e
withTimeout
public RemoteCommandBuilder withTimeout(Duration timeout)
{    this.timeout = timeout;    return this;}
e5424c4b618efbe6ec7634d41ee579914bdf42b302ac5b7125d9b86303921f62
build
public RemoteCommand build()
{    RemoteCommand remoteCommand = new RemoteCommand(jobConfig);    remoteCommand.setTimeout(timeout);    return remoteCommand;}
fe27bc0c6afa724212579834b18ee4cdbf36eb62a8c4e52f0d0134e0d3a1fb4c
executeRemoteJob
public JobInfo executeRemoteJob(RemoteCommand command)
{    try {        String jobId = client.executeJob(command.getJobConfig());        Future<JobInfo> chekerFuture = executor.submit(new JobStateChecker(jobId));        return chekerFuture.get(getTimeout(command), TimeUnit.MILLISECONDS);    } catch (Exception e) {        LOG.error("Remote command failed", e);        JobInfo jobInfo = new JobInfo();        jobInfo.setState(State.FAILED);        jobInfo.setMsg(ExceptionUtils.getStackTrace(e));        return jobInfo;    }}
8397572c5cf31a3370ff06cc16e8b3e2db330af86b37b96c0e14a60192e6dced
getTimeout
private long getTimeout(RemoteCommand command)
{    if (command.getTimeout() == null) {        return DEFAULT_TIMEOUT_SEC * DateTimeConstants.MILLIS_PER_SECOND;    }    return command.getTimeout().getMillis();}
d015acff5a9265b407aea7b19174b2877b1268a48b3d0e3d1e387b1f37e8071a
setRequestDelay
public void setRequestDelay(Duration requestDelay)
{    this.requestDelay = requestDelay;}
80769a79f889a83b9d56f75847229be1f0179d55aa658c4a402948e8d2c34f5a
call
public JobInfo call() throws Exception
{    while (!Thread.interrupted()) {        JobInfo jobInfo = client.getJobInfo(jobId);        checkState(jobInfo != null, "Cannot get job info!");        State state = jobInfo.getState();        checkState(state != null, "Unknown job state!");        if (state == State.RUNNING || state == State.ANY || state == State.IDLE) {            Thread.sleep(requestDelay.getMillis());            continue;        }        return jobInfo;    }    return null;}
da690019188a79e5207231cba23071f14da08ea3a9ce56648019201f3dbb52ab
createCommands
public List<RemoteCommand> createCommands(Crawl crawl)
{    this.crawl = crawl;    this.remoteCommands = Lists.newArrayList();    remoteCommands.add(inject());    for (int i = 0; i < crawl.getNumberOfRounds(); i++) {        remoteCommands.addAll(createBatchCommands());    }    return remoteCommands;}
b721d18f6ff1a0857d45db45cd5fb31bf4f3af9547d78aaf899675ebed76b5c6
createBatchCommands
private List<RemoteCommand> createBatchCommands()
{    this.batchId = UUID.randomUUID().toString();    List<RemoteCommand> batchCommands = Lists.newArrayList();    batchCommands.add(createGenerateCommand());    batchCommands.add(createFetchCommand());    batchCommands.add(createParseCommand());    batchCommands.add(createUpdateDbCommand());    batchCommands.add(createIndexCommand());    return batchCommands;}
aa67a7a7437d5296362b7f7a9426daee2af9af1f30d0c04eefcf0044dc8f589d
inject
private RemoteCommand inject()
{    RemoteCommandBuilder builder = RemoteCommandBuilder.instance(JobType.INJECT).withCrawlId(crawl.getCrawlId()).withArgument("url_dir", crawl.getSeedDirectory());    return builder.build();}
b644b2c383fc19113dbe070465dee667bcd3bac2c80d803c7194a1907ec5ccc9
createGenerateCommand
private RemoteCommand createGenerateCommand()
{    return createBuilder(JobType.GENERATE).build();}
6cfd47c779bee30a63162b61cb4ffba0bc1a95396ebfb4e8d1ed9b0f63983d9d
createFetchCommand
private RemoteCommand createFetchCommand()
{    return createBuilder(JobType.FETCH).withTimeout(Duration.standardSeconds(50)).build();}
789f959e749bb2035f55b63bf2c38a45902df78b08238583003d3861d8d01784
createParseCommand
private RemoteCommand createParseCommand()
{    return createBuilder(JobType.PARSE).build();}
abcd7b162cfcc3d4168d33464e5a567ad2d111572ef67289a10c877ec7fcf99e
createIndexCommand
private RemoteCommand createIndexCommand()
{    return createBuilder(JobType.INDEX).build();}
0d132c2d498b88b2d5b16e06c62efa3895b299020a50c7d325f6b94ebe1a4f29
createUpdateDbCommand
private RemoteCommand createUpdateDbCommand()
{    return createBuilder(JobType.UPDATEDB).build();}
8f2469c2a9d47f45b7a328fcc7ce70f90803a3b60d57251b955a698d56e20795
createBuilder
private RemoteCommandBuilder createBuilder(JobType jobType)
{    return RemoteCommandBuilder.instance(jobType).withCrawlId(crawl.getCrawlId()).withArgument("batch", batchId);}
5c1bea25bfafaaaab33ceed2677352e2df82370ba1cfd8454a30eb44c2951dfd
getNumberOfRounds
public Integer getNumberOfRounds()
{    return numberOfRounds;}
7975473328637e8b92396521b339f8c1b5aa3d754a6127d788c66c62823dd976
setNumberOfRounds
public void setNumberOfRounds(Integer numberOfRounds)
{    this.numberOfRounds = numberOfRounds;}
b7482d498c7b22fc604b0b48eb53a91e8ead98ec6e3f7cc14a3a793cd7fe10f5
getCrawlId
public String getCrawlId()
{    return crawlId;}
ccbfead7f316723a5f535c4a186c2e469b383dfa2da2301e832c8fe94ff39f8c
setCrawlId
public void setCrawlId(String crawlId)
{    this.crawlId = crawlId;}
d73c3d9a687716327c27c3bc96ef85ef5fa0faf8da1130a7fe6bd25237a21ca6
getStatus
public CrawlStatus getStatus()
{    return status;}
91641352927a7880bcc65ab57b9ed59648599a27aeef7bc44ce85a99f06d5a55
setStatus
public void setStatus(CrawlStatus status)
{    this.status = status;}
828ee655c73a6e6fd968628514e9fe6dd89f85d717c2eeb1429904230c956bcd
getCrawlName
public String getCrawlName()
{    return crawlName;}
40997cc2b3bfdab7363e5a5632a34f60f43757d3ddbe28dbc97268058850da22
setCrawlName
public void setCrawlName(String crawlName)
{    this.crawlName = crawlName;}
73f3d3052a702eb3ef8401812dc8df9d826a3d021ac5ea90a81aeceebdb2acf0
getSeedList
public SeedList getSeedList()
{    return seedList;}
4fd1171b31fed3e24da42b85162b2c8bf763cc6db708c9a35f93f9ce714984b9
setSeedList
public void setSeedList(SeedList seedList)
{    this.seedList = seedList;}
f734c2eebae9a730cc7699b15559fb359d3fde242fc8d95d883eb6e678db260e
getId
public Long getId()
{    return id;}
f244308ce1625e52b4f2d91f9d304d40b50af7d199f0957560887f734910fbdf
setId
public void setId(Long id)
{    this.id = id;}
73861b6cb72f11f4f3a6a6a175223fa1a27f9985bf674697931f1b2a72b9653a
getSeedDirectory
public String getSeedDirectory()
{    return seedDirectory;}
49588247184d17ce1a9998734210f1f6c367ca86d86311e5001f28e2595a66ea
setSeedDirectory
public void setSeedDirectory(String seedDirectory)
{    this.seedDirectory = seedDirectory;}
f7bcdc8feb1586c48509e106d69f5bf8a945398f44a7d087a273a997eda15616
getProgress
public int getProgress()
{    return progress;}
981ed32c7b03d241d7520fbda106c2e3e2764b1d5a9520f90e701df86f5ac0ac
setProgress
public void setProgress(int progress)
{    this.progress = progress;}
0d6d4998040c804375924665324fffa9257f416311eb537ec6917382036c610a
setArgument
public void setArgument(String key, String value)
{    args.put(key, value);}
b7482d498c7b22fc604b0b48eb53a91e8ead98ec6e3f7cc14a3a793cd7fe10f5
getCrawlId
public String getCrawlId()
{    return crawlId;}
ccbfead7f316723a5f535c4a186c2e469b383dfa2da2301e832c8fe94ff39f8c
setCrawlId
public void setCrawlId(String crawlId)
{    this.crawlId = crawlId;}
4cbb3c04c2494e74cfd1e91b057fb4f4f8e88e55c6ec5fb363e683d40e015632
getType
public JobType getType()
{    return type;}
a451ec17772a76e4e462aa1698a67c082b8b23faf4a02917e56b03f25700dda8
setType
public void setType(JobType type)
{    this.type = type;}
d726d439acbb486b0bcc34ef94adc962f6a73fd68ff1149a7e31aaa8c58d0a42
getConfId
public String getConfId()
{    return confId;}
1d6e336afe4461fa7024c33fec9b59f98a177447f3975354c8db4ff0e39931a3
setConfId
public void setConfId(String confId)
{    this.confId = confId;}
b89f717d1c2ccf000ae99377b7c8ddb5164d7e6a8cc65662a01c3271ccb9352c
getArgs
public Map<String, Object> getArgs()
{    return Collections.unmodifiableMap(args);}
1f52953b823b923cf7c59ae2d932cfb4b2d828b1a01e63cdb2685bd7abec655d
setArgs
public void setArgs(Map<String, Object> args)
{    this.args = args;}
a87ca441585fc8ea037fb5ca01a0d223c81219d837acae14f1417d5f53dcf33b
getJobClassName
public String getJobClassName()
{    return jobClassName;}
120b3e2af60cf29a690ac934713ef6651a55dadf8a5ee014bd6f30de0828af8c
setJobClassName
public void setJobClassName(String jobClass)
{    this.jobClassName = jobClass;}
ee3c7c9f25e95b8615126f38a4151371e1123750674266d188e844ed092015d7
getMsg
public String getMsg()
{    return msg;}
9ac61442c3646e8121175908076f09a081755340dc832804af4aff146b4d9eda
setMsg
public void setMsg(String msg)
{    this.msg = msg;}
25732bf4689a2f9e30b003ed7ca49c4862da4931f831c5d1f6b63d803ca45d30
getState
public State getState()
{    return state;}
625a3338b65461ce0c036e446c5b196367e621720863da9c1300ea7977052a01
setState
public void setState(State state)
{    this.state = state;}
3d6097c074ca9c7fd4f17f773b785364ca528870d61eb65dcddc4dc18ae42c15
getResult
public Map<String, Object> getResult()
{    return result;}
54144c51dd9579335c4347fa1a39e606e0b1ae3f46fba451f9f8640fb4586c10
setResult
public void setResult(Map<String, Object> result)
{    this.result = result;}
b89f717d1c2ccf000ae99377b7c8ddb5164d7e6a8cc65662a01c3271ccb9352c
getArgs
public Map<String, Object> getArgs()
{    return args;}
1f52953b823b923cf7c59ae2d932cfb4b2d828b1a01e63cdb2685bd7abec655d
setArgs
public void setArgs(Map<String, Object> args)
{    this.args = args;}
d726d439acbb486b0bcc34ef94adc962f6a73fd68ff1149a7e31aaa8c58d0a42
getConfId
public String getConfId()
{    return confId;}
1d6e336afe4461fa7024c33fec9b59f98a177447f3975354c8db4ff0e39931a3
setConfId
public void setConfId(String confId)
{    this.confId = confId;}
09e8f13a9a603d31d64bb498b77d15572483824d843d0e82a570643192f62186
getId
public String getId()
{    return id;}
ef03857fdefb7c5e949826b070dcbdc52b14cca8f50e0c7e1f5da4ee7e390f1a
setId
public void setId(String id)
{    this.id = id;}
b7482d498c7b22fc604b0b48eb53a91e8ead98ec6e3f7cc14a3a793cd7fe10f5
getCrawlId
public String getCrawlId()
{    return crawlId;}
ccbfead7f316723a5f535c4a186c2e469b383dfa2da2301e832c8fe94ff39f8c
setCrawlId
public void setCrawlId(String crawlId)
{    this.crawlId = crawlId;}
624f725337dde847c4a699397a02f1b5558c709c88374adb10e603d835f48c88
getType
public String getType()
{    return type;}
8ab53042064bb8f4e31355121ce5a5ccc6f3b8e9227cceb605ae26d51b21bddd
setType
public void setType(String type)
{    this.type = type;}
9487044afac901905d396f0e67d984e4d2335428bebf9888c09bb43beb3db0a9
getStartDate
public Date getStartDate()
{    return startDate;}
13e1b2b3e832ce3c80e11b892dc23ce14e32bd325574a4b2cbdc660721a2c1c1
setStartDate
public void setStartDate(Date startDate)
{    this.startDate = startDate;}
5ba6d6eaba81f00592dacf3dc511ecbc0f608c5ed6c75fb12cacb59bfb2dfc21
getConfiguration
public Set<String> getConfiguration()
{    return configuration;}
b1fc27741f5dd43628ba6c4702c2dcda54f5ceefbedd41858c6da20129ad322b
setConfiguration
public void setConfiguration(Set<String> configuration)
{    this.configuration = configuration;}
98745bd382f7517a9315624f424aa802c57930e214d1140b931435cd4146dbb8
getJobs
public Collection<JobInfo> getJobs()
{    return jobs;}
2896e1bcb28f1af17ecfb5b6eb8a5de0ca8621c352b3f278aee671f36fdecf1b
setJobs
public void setJobs(Collection<JobInfo> jobs)
{    this.jobs = jobs;}
26f539f2fc53e38dfacb464be2b5fb2337ac64dcd4dd961ee904d83f55d11e87
getRunningJobs
public Collection<JobInfo> getRunningJobs()
{    return runningJobs;}
f622645992ac994dc58c1153a36909d29cb0f3f14c3b3758de4934ca1a311055
setRunningJobs
public void setRunningJobs(Collection<JobInfo> runningJobs)
{    this.runningJobs = runningJobs;}
4891d1815abe5d8c8f57c3bc8b2e9b30ab0870e781a3b1a4a3b702a145543688
getClient
public NutchClient getClient(NutchInstance instance)
{    try {        return cache.get(instance);    } catch (ExecutionException e) {        throw new IllegalStateException(e);    }}
c4b3ad98df362b8a9ce5e1f8aa7aa635799a3660fe0425420d660c55d57cd2fe
load
public NutchClient load(NutchInstance key) throws Exception
{    return new NutchClientImpl(key);}
d612853b2593635453b087c68b08b4aa0aa52fe924cd0ec9ee0c3de8a9b77cae
createDao
public Dao<T, ID> createDao(Class<T> clazz)
{    try {        Dao<T, ID> dao = DaoFactory.createDao(connectionSource, clazz);        register(dao);        return dao;    } catch (SQLException e) {        throw new RuntimeException(e);    }}
f14bb4bf88375b8878d0306a3558a67da36d60ba4ebf4647d242517cb0272189
register
private void register(Dao<T, ID> dao)
{    synchronized (registredDaos) {        registredDaos.add(dao);    }}
43d60444abd8e73a9971c9befb10240a928c3f913e7a780d1c2ef21fa200f05f
getCreatedDaos
public List<Dao<?, ?>> getCreatedDaos()
{    synchronized (registredDaos) {        return Collections.unmodifiableList(registredDaos);    }}
4b0c70ad42dae4af1fb4648403f83dc15d9331ab4d2a15cdd4d8233ec1ba447c
initialize
private void initialize()
{    if (configuredDaos == null) {        throw new IllegalStateException("configuredDaos was not set in " + getClass().getSimpleName());    }    for (Dao<?, ?> dao : configuredDaos) {        createTableForDao(dao);    }}
5ecf991b812a04915e2e1934b59c4745e7f20dd2df4dd7c25761827934f67f1d
createTableForDao
private void createTableForDao(Dao<?, ?> dao)
{    DatabaseTableConfig<?> tableConfig = getTableConfig(dao);    createTableIfNotExists(tableConfig);}
c5765ca09baaacec226e25accbd76825848237028f932fcdcfa184cc2c3d8597
getTableConfig
private DatabaseTableConfig<?> getTableConfig(Dao<?, ?> dao)
{    Class<?> clazz = dao.getDataClass();    DatabaseTableConfig<?> tableConfig = null;    if (dao instanceof BaseDaoImpl) {        tableConfig = ((BaseDaoImpl<?, ?>) dao).getTableConfig();    }    if (tableConfig == null) {        return getConfigFromClass(clazz);    }    return tableConfig;}
6cc5ca6a772f647bcf19c76f1fbb28a38eb66ea6954826819816f230ce5debc4
getConfigFromClass
private DatabaseTableConfig<?> getConfigFromClass(Class<?> clazz)
{    try {        return DatabaseTableConfig.fromClass(connectionSource, clazz);    } catch (SQLException e) {        throw new RuntimeException(e);    }}
2c19e8743d54885a0d1ac45d5d99eb9932d3b338f82c9e92fa3efbbab829bd61
createTableIfNotExists
private void createTableIfNotExists(DatabaseTableConfig<?> tableConfig)
{    try {        TableUtils.createTableIfNotExists(connectionSource, tableConfig);    } catch (SQLException e) {        throw new RuntimeException(e);    }}
bf79c940d92e17ba4759476fc45a71530693b6dd9ba4534b1dc1de44c32b9f3e
getInstances
public List<NutchInstance> getInstances()
{    return instances;}
10a331a6fe5a8abe658a0c834a9a60b88729423eb0e514ee0646cc296cff0300
setInstances
public void setInstances(List<NutchInstance> instances)
{    this.instances = instances;}
9a796521310074c2330e0bab90891b3824a9683bd047ffb75f459a02569b88b4
getAsyncExecutor
public Executor getAsyncExecutor()
{        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();    executor.setCorePoolSize(7);    executor.setMaxPoolSize(42);    executor.setQueueCapacity(11);    executor.setThreadNamePrefix("SpringExecutor-");    executor.initialize();    return executor;}
1726502450bd09492fd518f8ad9773e87581bfcaf552e8f4bcea0ad3349c6535
getConnectionSource
public JdbcConnectionSource getConnectionSource() throws SQLException
{    JdbcConnectionSource source = new JdbcConnectionSource("jdbc:h2:~/.nutch/config", new H2DatabaseType());    source.initialize();    return source;}
d6a710fb34fffb533f10a590f24396fba6731ac49c284e0a9eb37ef2d4be5e29
getDaoFactory
public CustomDaoFactory getDaoFactory() throws SQLException
{    return new CustomDaoFactory(getConnectionSource());}
40e11470becd0fbfb1d32056dfec93efbccbd32dedd8fc4ba2023b7692fa4bf2
createNutchDao
public Dao<NutchInstance, Long> createNutchDao() throws SQLException
{    return getDaoFactory().createDao(NutchInstance.class);}
23ce678f2e1c8d7f83208e9af5d0b4776040ea3b6bb9e274c91c81c4d486baaa
createSeedListDao
public Dao<SeedList, Long> createSeedListDao() throws SQLException
{    return getDaoFactory().createDao(SeedList.class);}
e17cfbf4c131767006c0344799f4a19a68b5f5c8cf1a350ac2dc1f63e1d073d3
createSeedUrlDao
public Dao<SeedUrl, Long> createSeedUrlDao() throws SQLException
{    return getDaoFactory().createDao(SeedUrl.class);}
0c4230dbd639685e813b4d649f6c085b38525d0d8fc382185cef4c24911878ee
createCrawlDao
public Dao<Crawl, Long> createCrawlDao() throws SQLException
{    return getDaoFactory().createDao(Crawl.class);}
ce2b494e15d361ec878ab9ae324b5b1cafcdebc0c9091525bdf8864513c58417
createTableCreator
public CustomTableCreator createTableCreator() throws SQLException
{    return new CustomTableCreator(getConnectionSource(), getDaoFactory().getCreatedDaos());}
f498f22eaf0816bf385a43365651d1b6d0455905fdd2d6be01ceefeb84e8f432
setName
public void setName(String name)
{    this.name = name;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return this.name;}
3ffb3c74afa5355644c1f0bfdb5098954de2d3a057f971596bdb7110ccb67b1b
getValue
public String getValue()
{    return value;}
e711c8f2effc698edc71bd6b3e96530dc7034c8c55d38ce9f9541bf3f17925af
setValue
public void setValue(String value)
{    this.value = value;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
f498f22eaf0816bf385a43365651d1b6d0455905fdd2d6be01ceefeb84e8f432
setName
public void setName(String name)
{    this.name = name;}
165b1c9352ad3d309866d5286d1a7fd8eae4d022cb5ad661b1269ac75c218ebb
getHost
public String getHost()
{    return host;}
2aa36d46562fccb437a954b773807392e01e3ad0d16cffa4fd33a5c48073160b
setUsername
public void setUsername(String username)
{    this.username = username;}
6a70299d74b1ed8da0ff8fec5a1c89ba0dff9b5b133bb2544a0bc6abb19bcee7
getUsername
public String getUsername()
{    return username;}
975df858cc36ca4ae96e66da70c7651a9608d19019688712f418ff1b046d6911
setHost
public void setHost(String host)
{    this.host = host;}
286ac11a7c0c169929d6406e0293873a24296d28a94301df226e0d8700dcead6
getPort
public Integer getPort()
{    return port;}
d1833e4abe1e8a94c12e1d97bc6e0b171d97cef5f9e057d18da167639bb11b93
setPort
public void setPort(Integer port)
{    this.port = port;}
dfe225918e2c33dcea5748e386559583c9e8f0b59e50a0054d1eb200baa7ec72
getConnectionStatus
public ConnectionStatus getConnectionStatus()
{    return connectionStatus;}
a8e7772372d4c26e8a767688c18f122f6934ffd842441a3c642cb740ac7feb3b
setConnectionStatus
public void setConnectionStatus(ConnectionStatus connectionStatus)
{    this.connectionStatus = connectionStatus;}
fad8f943156bb2dfda34464c7f078ab327496d6c9f6c994d23f9d943ba64f0fc
getUrl
public URI getUrl()
{    try {        return new URI("http", null, host, port, null, null, null);    } catch (URISyntaxException e) {        throw new IllegalStateException("Cannot parse url parameters", e);    }}
84dc993e9ee2454a836a462d555136356e8d932d11a2a18b6c05e86764987456
getPassword
public String getPassword()
{    return password;}
a3fc85e095b71ade6f23516e300582f2daf9dc9c17a00077a31a992f77c08289
setPassword
public void setPassword(String password)
{    this.password = password;}
f734c2eebae9a730cc7699b15559fb359d3fde242fc8d95d883eb6e678db260e
getId
public Long getId()
{    return id;}
f244308ce1625e52b4f2d91f9d304d40b50af7d199f0957560887f734910fbdf
setId
public void setId(Long id)
{    this.id = id;}
f734c2eebae9a730cc7699b15559fb359d3fde242fc8d95d883eb6e678db260e
getId
public Long getId()
{    return id;}
f244308ce1625e52b4f2d91f9d304d40b50af7d199f0957560887f734910fbdf
setId
public void setId(Long id)
{    this.id = id;}
6a44a4ae854f746e7b745357cc2ae29e96fe72eb7734d967383f4d4553552eca
getSeedUrlsCount
public int getSeedUrlsCount()
{    if (CollectionUtils.isEmpty(seedUrls)) {        return 0;    }    return seedUrls.size();}
06c160d2c24eb06ff7b9488c400a6ca3f696309f70dcc8157ef409bdb19e4ac1
getSeedUrls
public Collection<SeedUrl> getSeedUrls()
{    return seedUrls;}
9bd7d75bc9343faf37d83de812f75afa2b1ec476e356cad23e6aa4072ed92aa2
setSeedUrls
public void setSeedUrls(Collection<SeedUrl> seedUrls)
{    this.seedUrls = seedUrls;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
f498f22eaf0816bf385a43365651d1b6d0455905fdd2d6be01ceefeb84e8f432
setName
public void setName(String name)
{    this.name = name;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    final int prime = 31;    int result = 1;    result = prime * result + ((id == null) ? 0 : id.hashCode());    return result;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj)        return true;    if (obj == null)        return false;    if (getClass() != obj.getClass())        return false;    SeedList other = (SeedList) obj;    if (id == null) {        if (other.id != null)            return false;    } else if (!id.equals(other.id))        return false;    return true;}
f734c2eebae9a730cc7699b15559fb359d3fde242fc8d95d883eb6e678db260e
getId
public Long getId()
{    return id;}
f244308ce1625e52b4f2d91f9d304d40b50af7d199f0957560887f734910fbdf
setId
public void setId(Long id)
{    this.id = id;}
354afe66bbdb19ee4d620955bbb214ebf9b5aa09359dea30ffb867002b5a25bd
getUrl
public String getUrl()
{    return url;}
c3d2ee14b0a87d91276b6034d452ebbd50ed47914948b9edaea83747da585af6
setUrl
public void setUrl(String url)
{    this.url = url;}
73f3d3052a702eb3ef8401812dc8df9d826a3d021ac5ea90a81aeceebdb2acf0
getSeedList
public SeedList getSeedList()
{    return seedList;}
4fd1171b31fed3e24da42b85162b2c8bf763cc6db708c9a35f93f9ce714984b9
setSeedList
public void setSeedList(SeedList seedList)
{    this.seedList = seedList;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    final int prime = 31;    int result = 1;    result = prime * result + ((id == null) ? 0 : id.hashCode());    return result;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj)        return true;    if (obj == null)        return false;    if (getClass() != obj.getClass())        return false;    SeedUrl other = (SeedUrl) obj;    if (id == null) {        if (other.id != null)            return false;    } else if (!id.equals(other.id))        return false;    return true;}
31dd0724ab9f7a58477aebd280dde5d4f3efc9aa35ad814ad3502e7a2a8ba143
getHomePage
public Class<? extends WebPage> getHomePage()
{    return DashboardPage.class;}
b2d7f0e8ddf1c02514ed19a5257c1cadcd6107187b0b8ba4b341193a7d69dfea
init
public void init()
{    super.init();    BootstrapSettings settings = new BootstrapSettings();    Bootstrap.install(this, settings);    configureTheme(settings);    getComponentInstantiationListeners().add(new SpringComponentInjector(this, context));}
6087af0f9fcd7bc70614824cca4f13e809ba9427f7571b74dee307a4d13a78c4
configureTheme
private void configureTheme(BootstrapSettings settings)
{    Theme theme = new Theme(THEME_NAME, BootstrapCssReference.instance(), FontAwesomeCssReference.instance(), NutchUiCssReference.instance());    settings.setThemeProvider(new SingleThemeProvider(theme));}
5af8de8813ad5161277f0a9a4d5cbd5438347dfd52943cc232ace26ff6244246
setApplicationContext
public void setApplicationContext(ApplicationContext applicationContext) throws BeansException
{    this.context = applicationContext;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    CommandLineParser parser = new GnuParser();    Options options = createWebAppOptions();    CommandLine commandLine = null;    HelpFormatter formatter = new HelpFormatter();    try {        commandLine = parser.parse(options, args);    } catch (Exception e) {        formatter.printHelp("NutchUiServer", options, true);        StringUtils.stringifyException(e);    }    if (commandLine.hasOption("help")) {        formatter.printHelp("NutchUiServer", options, true);        return;    }    if (commandLine.hasOption(CMD_PORT)) {        port = Integer.parseInt(commandLine.getOptionValue(CMD_PORT));    }    startServer();}
7d125773dd906ee1961b333db221da0a370a04543b3c38ecc097174caab27e73
startServer
private static void startServer() throws Exception, InterruptedException
{    Server server = new Server(port);    Context context = new Context(server, "/", Context.SESSIONS);    context.addServlet(DefaultServlet.class, "/*");    context.addEventListener(new ContextLoaderListener(getContext()));    context.addEventListener(new RequestContextListener());    WicketFilter filter = new WicketFilter();    filter.setFilterPath("/");    FilterHolder holder = new FilterHolder(filter);    holder.setInitParameter("applicationFactoryClassName", APP_FACTORY_NAME);    context.addFilter(holder, "/*", Handler.DEFAULT);    server.setHandler(context);    server.start();    server.join();}
391ecefb3d95610aa882285eba6a744f4cb83c573fc1ac7cea5c9fe6fec298ec
getContext
private static WebApplicationContext getContext()
{    AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();    context.setConfigLocation(CONFIG_LOCATION);    return context;}
3455c619b7617af569e14d655660b0b57a7bc30784f169c77dd449e20be241f0
createWebAppOptions
private static Options createWebAppOptions()
{    Options options = new Options();    Option helpOpt = new Option("h", "help", false, "show this help message");    OptionBuilder.withDescription("Port to run the WebApplication on.");    OptionBuilder.hasOptionalArg();    OptionBuilder.withArgName("port number");    options.addOption(OptionBuilder.create(CMD_PORT));    options.addOption(helpOpt);    return options;}
b619b396a40292dbfc658cd2d38dc96966c0706e15d1dbc4618295f740359f45
addUserMenu
protected Component addUserMenu()
{    DropDownButton userMenu = new NavbarDropDownButton(Model.of("Username")) {        /**         */        private static final long serialVersionUID = 1L;        @Override        protected List<AbstractLink> newSubMenuButtons(final String buttonMarkupId) {            List<AbstractLink> subMenu = Lists.newArrayList();            subMenu.add(new MenuBookmarkablePageLink<Void>(UserSettingsPage.class, new ResourceModel("navbar.userMenu.settings")).setIconType(FontAwesomeIconType.gear));            subMenu.add(new MenuDivider());            subMenu.add(new MenuBookmarkablePageLink<Void>(LogOutPage.class, new ResourceModel("navbar.userMenu.logout")).setIconType(FontAwesomeIconType.power_off));            return subMenu;        }    }.setIconType(FontAwesomeIconType.user);    return userMenu;}
beb0ecb30343e60fad8a3660df17ac7945f6b8858b2d0997c9ce1bb1dd7c6dea
newSubMenuButtons
protected List<AbstractLink> newSubMenuButtons(final String buttonMarkupId)
{    List<AbstractLink> subMenu = Lists.newArrayList();    subMenu.add(new MenuBookmarkablePageLink<Void>(UserSettingsPage.class, new ResourceModel("navbar.userMenu.settings")).setIconType(FontAwesomeIconType.gear));    subMenu.add(new MenuDivider());    subMenu.add(new MenuBookmarkablePageLink<Void>(LogOutPage.class, new ResourceModel("navbar.userMenu.logout")).setIconType(FontAwesomeIconType.power_off));    return subMenu;}
fa836d047b7b019d0395e5f35d4c26159c2c537556dc03ca601ea46435e3bf8a
addInstancesMenuMenu
protected Component addInstancesMenuMenu()
{    IModel<String> instanceName = PropertyModel.of(currentInstance, "name");    DropDownButton instancesMenu = new NavbarDropDownButton(instanceName) {        /**         */        private static final long serialVersionUID = 1L;        @Override        protected List<AbstractLink> newSubMenuButtons(String buttonMarkupId) {            List<NutchInstance> instances = instanceService.getInstances();            List<AbstractLink> subMenu = Lists.newArrayList();            for (NutchInstance instance : instances) {                subMenu.add(new Link<NutchInstance>(buttonMarkupId, Model.of(instance)) {                    /**                     */                    private static final long serialVersionUID = 1L;                    @Override                    public void onClick() {                        currentInstance.setObject(getModelObject());                        setResponsePage(DashboardPage.class);                    }                }.setBody(Model.of(instance.getName())));            }            return subMenu;        }    }.setIconType(FontAwesomeIconType.gears);    return instancesMenu;}
6c96a086a4684a1b61b53ba687915b406a176d487cfa56b49f6138c017bd766d
newSubMenuButtons
protected List<AbstractLink> newSubMenuButtons(String buttonMarkupId)
{    List<NutchInstance> instances = instanceService.getInstances();    List<AbstractLink> subMenu = Lists.newArrayList();    for (NutchInstance instance : instances) {        subMenu.add(new Link<NutchInstance>(buttonMarkupId, Model.of(instance)) {            /**             */            private static final long serialVersionUID = 1L;            @Override            public void onClick() {                currentInstance.setObject(getModelObject());                setResponsePage(DashboardPage.class);            }        }.setBody(Model.of(instance.getName())));    }    return subMenu;}
f2631e53f65ea23339646ab94c4eee72e850332af9673cddde9a4c8696ecbe56
onClick
public void onClick()
{    currentInstance.setObject(getModelObject());    setResponsePage(DashboardPage.class);}
fcc1c4b2413c8644fb9556f821b13254f9bd50b229d4c362e4459cee058e3a60
addMenuItem
private void addMenuItem(Class<P> page, String label, IconType icon)
{    Component button = new NavbarButton<Void>(page, Model.of(getString(label))).setIconType(icon);    navbar.addComponents(NavbarComponents.transform(LEFT, button));}
976a3214454e147f1821de3a1e4b3544b05d5ea04b38f60b7b7d65220efbe570
getCurrentInstance
protected NutchInstance getCurrentInstance()
{    return currentInstance.getObject();}
1c1c85602d864c130f80b0f464d631836141697f7bc2aeb9eb694b04f28197ad
setObject
public void setObject(NutchInstance instance)
{    super.setObject(instance);    getSession().setAttribute("instanceId", instance.getId());}
7a35026323ea99cf86a1b9c6db7046696e69560cb6919cfa03a649cc5397d94f
load
protected NutchInstance load()
{    Long instanceId = (Long) getSession().getAttribute("instanceId");    if (instanceId == null) {        return getFirstInstance();    }    return instanceService.getInstance(instanceId);}
f8ad80e2d127a1bf33e3eee05c2757e2d02024f3b057fdc1b5c66d84f6d8d9aa
getFirstInstance
private NutchInstance getFirstInstance()
{    return Iterables.getFirst(instanceService.getInstances(), null);}
925db3c851f88707b945d7fb9dcf695ba81b723686499160465d6576c345b0bd
instance
public static NutchUiCssReference instance()
{    return INSTANCE;}
550633c86f2bc7e89dcdfd8bc712338ee0e5739d1c173fd383e5d229d349b1d9
onInitialize
protected void onInitialize()
{    super.onInitialize();    setOutputMarkupId(true);    add(new LabelBehavior(new EnumCssModel(getModel())));}
b454f50a449664c6014a147b06b901b54a958618685ad29dceb6f35806dce371
getObject
public LabelType getObject()
{    LabelType labelType = labelTypeMap.get(model.getObject());    if (labelType == null) {        return LabelType.Default;    }    return labelType;}
0634f71772f887b0b0027a5b0c95daa4069989d75fba6ea28c05515b65f1759a
getBuilder
public static ColorEnumLabelBuilder<E> getBuilder(String id)
{    return new ColorEnumLabelBuilder<>(id);}
d21c1bd7e175c6855f12a003608a15e0178848b8dd326db576bf845917c4ad6c
withModel
public ColorEnumLabelBuilder<E> withModel(IModel<E> model)
{    this.model = model;    return this;}
e0135ae26f11fa3e3fada78e6e84ce99dd5064e3240cbb0a0e62b75c623a86c9
withEnumColor
public ColorEnumLabelBuilder<E> withEnumColor(E e, LabelType type)
{    labelTypeMap.put(e, type);    return this;}
f362bb8a64c474881ca3d8e218563d3b6c4e81e7907271f54f6104c26db1aa68
build
public ColorEnumLabel<E> build()
{    return new ColorEnumLabel<>(id, model, labelTypeMap);}
2f94b49b7cd467921a21869c4d6d6e15d7506fc5d09b0b002889f67604ac0900
model
protected IModel<T> model(T object)
{    return new CompoundPropertyModel<>(object);}
7d04f22266e12201b088e9211f84f2c608f37843782b085cba1999de76cd33bf
onSubmit
protected void onSubmit(AjaxRequestTarget target, Form<?> ajaxForm)
{    crawlService.saveCrawl(form.getModelObject());    target.add(this.getPage());}
c7eff6a34f5d8fa8cefdb58f78605c92755288b0c16d4491e79b39e81197406d
onError
protected void onError(AjaxRequestTarget target, Form<?> form)
{    target.add(notificationPanel);}
bffb5e6787e24423681a693b300334913859c56c95222ff98730a29e7548d544
setModel
public void setModel(IModel<Crawl> model)
{    form.setModel(model);}
1986e7050a2b3eb1f3b49a8fb484ac1a11ed3230205fc83e679770ab9d7d1cc9
getNumbersOfRounds
private List<Integer> getNumbersOfRounds()
{    List<Integer> numbers = Lists.newArrayList();    for (int i = 1; i <= MAX_ROUNDS; i++) {        numbers.add(i);    }    return numbers;}
d7477f39806b6f1510d21a21eb00fb84602d63f7a83d4c6e046bd5e138a841e2
getItemModels
protected Iterator<IModel<Crawl>> getItemModels()
{    return new CpmIteratorAdapter<>(crawlService.getCrawls());}
44d0e200e8505aa8f1d7ff7006761e62d7dc620522eeceb306f26e796a173edf
populateItem
protected void populateItem(Item<Crawl> item)
{    populateCrawlRow(item);}
61e6ee6aa2e38df8f4555423af3b8681070db189244690224962372b9175e988
onClick
public void onClick(AjaxRequestTarget target)
{    editCrawl(target, new CompoundPropertyModel<>(createNewCrawl()));}
9ac76ae77caa1eb0b12f9d5472bee349f15c1ebfe0c747bd8e4d5fa0c0b20897
populateCrawlRow
private void populateCrawlRow(Item<Crawl> item)
{    item.add(new AjaxLink<Crawl>("edit", item.getModel()) {        @Override        public void onClick(AjaxRequestTarget target) {            editCrawl(target, getModel());        }    }.add(new Label("crawlName")));    item.add(new Label("seedList.name"));    item.add(new Label("progress"));    item.add(createStatusLabel());    item.add(new Link<Crawl>("start", item.getModel()) {        @Override        public void onClick() {            crawlService.startCrawl(getModelObject().getId(), getCurrentInstance());        }    });    item.add(new Link<Crawl>("delete", item.getModel()) {        @Override        public void onClick() {            crawlService.deleteCrawl(getModelObject().getId());        }    });}
61e6ee6aa2e38df8f4555423af3b8681070db189244690224962372b9175e988
onClick
public void onClick(AjaxRequestTarget target)
{    editCrawl(target, getModel());}
f2631e53f65ea23339646ab94c4eee72e850332af9673cddde9a4c8696ecbe56
onClick
public void onClick()
{    crawlService.startCrawl(getModelObject().getId(), getCurrentInstance());}
f2631e53f65ea23339646ab94c4eee72e850332af9673cddde9a4c8696ecbe56
onClick
public void onClick()
{    crawlService.deleteCrawl(getModelObject().getId());}
3c5d27cb3bbd607f4eb971f16b70cfa779270dff25c9ad8c3fec85c49cba25ef
editCrawl
private void editCrawl(AjaxRequestTarget target, IModel<Crawl> model)
{    crawlPanel.setModel(model);    target.add(crawlPanel);    crawlPanel.appendShowDialogJavaScript(target);}
b72f3f71ba5ef9914c16126d2fca50a0edaba5b21fd9f8119134219f22389531
createNewCrawl
private Crawl createNewCrawl()
{    return new Crawl();}
dacd37fd13d28836a2eb9b4482c5b72aa74626bdcf9d7eeebebda1ac8e6ecee3
createStatusLabel
private EnumLabel<CrawlStatus> createStatusLabel()
{    return new ColorEnumLabelBuilder<CrawlStatus>("status").withEnumColor(NEW, Default).withEnumColor(ERROR, Danger).withEnumColor(FINISHED, Success).withEnumColor(CRAWLING, Info).build();}
1cdd1fa3ce87b557bed182cec87a58548a95848afda818d68dd1481cb275f92c
load
protected Integer load()
{    NutchInstance currentInstance = getCurrentInstance();    Long id = currentInstance.getId();    NutchStatus nutchStatus = nutchService.getNutchStatus(id);    return nutchStatus.getRunningJobs().size();}
7d04f22266e12201b088e9211f84f2c608f37843782b085cba1999de76cd33bf
onSubmit
protected void onSubmit(AjaxRequestTarget target, Form<?> ajaxForm)
{    instanceService.saveInstance(form.getModelObject());    target.add(this.getPage());}
c7eff6a34f5d8fa8cefdb58f78605c92755288b0c16d4491e79b39e81197406d
onError
protected void onError(AjaxRequestTarget target, Form<?> form)
{    target.add(notificationPanel);}
2e818368fea01af2cfcd03c25c9ae276d8dec91debe5ec16e175b23045ad222d
setModel
public void setModel(IModel<NutchInstance> model)
{    form.setModel(model);}
164e42d76ab4e9331ef9491af10778491a3f1349d5582523e792d1e5f2aaa736
refreshingView
private RefreshingView<NutchInstance> refreshingView()
{    RefreshingView<NutchInstance> instances = new RefreshingView<NutchInstance>("instances") {        @Override        protected Iterator<IModel<NutchInstance>> getItemModels() {            return new CpmIteratorAdapter<>(instanceService.getInstances());        }        @Override        protected void populateItem(Item<NutchInstance> item) {            populateInstanceRow(item);        }    };    return instances;}
b58397e5f13a51a1d20b94e2db51dec1458d83db56514ef6549d15f648100627
getItemModels
protected Iterator<IModel<NutchInstance>> getItemModels()
{    return new CpmIteratorAdapter<>(instanceService.getInstances());}
0b05835923d09b66a64fb42311f310dc90e72fd146fb8ab83c97e65d3dc7b937
populateItem
protected void populateItem(Item<NutchInstance> item)
{    populateInstanceRow(item);}
b0279bc328dd4e014f34d8faac4329c4f6746d713bdc63745fdbd44b9f83cb23
addInstanceButton
private AjaxLink<NutchInstance> addInstanceButton()
{    return new AjaxLink<NutchInstance>("addInstance") {        @Override        public void onClick(AjaxRequestTarget target) {            instancePanel.setModel(new CompoundPropertyModel<>(new NutchInstance()));            target.add(instancePanel);            instancePanel.appendShowDialogJavaScript(target);        }    };}
61e6ee6aa2e38df8f4555423af3b8681070db189244690224962372b9175e988
onClick
public void onClick(AjaxRequestTarget target)
{    instancePanel.setModel(new CompoundPropertyModel<>(new NutchInstance()));    target.add(instancePanel);    instancePanel.appendShowDialogJavaScript(target);}
c49ee527379827f723769da1de310a89c6a3e5a115347349845113fbb4f86ce2
populateInstanceRow
private void populateInstanceRow(final Item<NutchInstance> item)
{    item.add(new AjaxLink<NutchInstance>("editInstance") {        @Override        public void onClick(AjaxRequestTarget target) {            instancePanel.setModel(item.getModel());            target.add(instancePanel);            instancePanel.appendShowDialogJavaScript(target);        }    }.add(new Label("name")));    item.add(new Label("host"));    item.add(new Label("username"));    item.add(createStatusLabel());    item.add(new AjaxLink<NutchInstance>("instanceDelete", item.getModel()) {        @Override        public void onClick(AjaxRequestTarget target) {            instanceService.removeInstance(getModelObject().getId());            target.add(instancesTable);        }    });}
61e6ee6aa2e38df8f4555423af3b8681070db189244690224962372b9175e988
onClick
public void onClick(AjaxRequestTarget target)
{    instancePanel.setModel(item.getModel());    target.add(instancePanel);    instancePanel.appendShowDialogJavaScript(target);}
61e6ee6aa2e38df8f4555423af3b8681070db189244690224962372b9175e988
onClick
public void onClick(AjaxRequestTarget target)
{    instanceService.removeInstance(getModelObject().getId());    target.add(instancesTable);}
fdab8ddc52f984621189f12074f2103e53204d8ce5069ec1f71162d3358cbf2f
createStatusLabel
private ColorEnumLabel<ConnectionStatus> createStatusLabel()
{    return new ColorEnumLabelBuilder<ConnectionStatus>("connectionStatus").withEnumColor(CONNECTED, Success).withEnumColor(CONNECTING, Info).withEnumColor(DISCONNECTED, Danger).build();}
3e97e7459a494c64c5968c0efcf270edce36b26ebaaf6313c73ad0f7bc2d6e0b
getItemModels
protected Iterator<IModel<SeedList>> getItemModels()
{    return new CpmIteratorAdapter<>(seedListService.findAll());}
80f4e4aa75d149bb6ddf6046e6bd480c5b2a06a9c7674bd4bad15da13788ddc0
populateItem
protected void populateItem(final Item<SeedList> item)
{    PageParameters params = new PageParameters();    params.add("id", item.getModelObject().getId());    Link<Void> edit = new BookmarkablePageLink<>("edit", SeedPage.class, params);    edit.add(new Label("name"));    item.add(edit);    item.add(new Label("seedUrlsCount"));    item.add(new Link<SeedList>("delete", item.getModel()) {        @Override        public void onClick() {            seedListService.delete(item.getModelObject().getId());        }    });}
f2631e53f65ea23339646ab94c4eee72e850332af9673cddde9a4c8696ecbe56
onClick
public void onClick()
{    seedListService.delete(item.getModelObject().getId());}
9d24af35bde61cc592c8493241cbabe3e4f770401edd4eddf065ab0a59942e93
load
protected SeedList load()
{    Long seedListId = parameters.get("id").toLongObject();    return seedListService.getSeedList(seedListId);}
692f0031b139f926202519abc888e589311935a9ff5529ea84c710e1ad6849e7
initPage
public void initPage(IModel<SeedList> model)
{    setModel(new CompoundPropertyModel<>(model));    addBaseForm();    addSeedUrlsList();    addUrlForm();}
ffbaa230fd60f210c45728f9a6ba0c823b120359fe40ef1b362456627d2e00e8
addBaseForm
private void addBaseForm()
{    Form<SeedList> form = new Form<SeedList>("seedList", getModel()) {        @Override        protected void onSubmit() {            seedListService.save(getModelObject());            setResponsePage(SeedListsPage.class);        }    };    form.add(new TextField<String>("name"));    add(form);}
8702664dccd6202167632938b5cf723b7b5c04742b6f6b70518575a39d925d07
onSubmit
protected void onSubmit()
{    seedListService.save(getModelObject());    setResponsePage(SeedListsPage.class);}
6208b017839677c7b7441b25d40107b22555371fc54cffa00aa2dd4d6b29f05c
addSeedUrlsList
private void addSeedUrlsList()
{    seedUrlsTable = new WebMarkupContainer("seedUrlsTable");    seedUrlsTable.setOutputMarkupId(true);    RefreshingView<SeedUrl> seedUrls = new RefreshingView<SeedUrl>("seedUrls") {        @Override        protected Iterator<IModel<SeedUrl>> getItemModels() {            return new CpmIteratorAdapter<>(getModelObject().getSeedUrls());        }        @Override        protected void populateItem(Item<SeedUrl> item) {            item.add(new Label("url"));            item.add(new AjaxLink<SeedUrl>("delete", item.getModel()) {                @Override                public void onClick(AjaxRequestTarget target) {                    deleteSeedUrl(getModelObject());                    target.add(seedUrlsTable);                }            });        }    };    seedUrlsTable.add(seedUrls);    add(seedUrlsTable);}
e763fdd5ab59e58e5068bb7e27e61d20ded912af6096d3b1c7167d6e23cafdba
getItemModels
protected Iterator<IModel<SeedUrl>> getItemModels()
{    return new CpmIteratorAdapter<>(getModelObject().getSeedUrls());}
24c345c96b3981fe4db0b105b420f23e77c64f532bbacbbdc9dbb31f4cd53028
populateItem
protected void populateItem(Item<SeedUrl> item)
{    item.add(new Label("url"));    item.add(new AjaxLink<SeedUrl>("delete", item.getModel()) {        @Override        public void onClick(AjaxRequestTarget target) {            deleteSeedUrl(getModelObject());            target.add(seedUrlsTable);        }    });}
61e6ee6aa2e38df8f4555423af3b8681070db189244690224962372b9175e988
onClick
public void onClick(AjaxRequestTarget target)
{    deleteSeedUrl(getModelObject());    target.add(seedUrlsTable);}
4e84e04efab106cf16a94fe8018abc6834aeed0cfb252d2e203103a4d1fad27f
addUrlForm
private void addUrlForm()
{    urlForm = new Form<>("urlForm", CompoundPropertyModel.of(Model.of(new SeedUrl())));    urlForm.setOutputMarkupId(true);    urlForm.add(new TextField<String>("url"));    urlForm.add(new AjaxSubmitLink("addUrl", urlForm) {        @Override        protected void onSubmit(AjaxRequestTarget target, Form<?> form) {            addSeedUrl();            urlForm.setModelObject(new SeedUrl());            target.add(urlForm);            target.add(seedUrlsTable);        }    });    add(urlForm);}
10e76909531fbfea9537e62f89a9658def13acaded08f4e85584bd62343ee1db
onSubmit
protected void onSubmit(AjaxRequestTarget target, Form<?> form)
{    addSeedUrl();    urlForm.setModelObject(new SeedUrl());    target.add(urlForm);    target.add(seedUrlsTable);}
a9fad705fc986493541ed8f90d551f389fa5dc619b496b3482fa3a581e84cc0a
addSeedUrl
private void addSeedUrl()
{    SeedUrl url = urlForm.getModelObject();    SeedList seedList = getModelObject();    url.setSeedList(seedList);    seedList.getSeedUrls().add(url);}
f1948ee1cc9f2e2e163248769119b380f47e5f488f99930dd490a72ed97eb8de
deleteSeedUrl
private void deleteSeedUrl(SeedUrl url)
{    SeedList seedList = getModelObject();    seedList.getSeedUrls().remove(url);}
81c4db5d75e9485370221262dc361a5cf68bd1b20ab937d8dbc817f090f3f13b
getItemModels
protected Iterator<IModel<NutchConfig>> getItemModels()
{    return new CpmIteratorAdapter<>(convertNutchConfig(nutchService.getNutchConfig(getCurrentInstance().getId())));}
3f9856fa70d4338583d1a57c148ff55f410823b96c37bfb9e854454f1b83cfee
populateItem
protected void populateItem(Item<NutchConfig> item)
{    item.add(new Label("name"));    item.add(new TextField<String>("value"));}
7f89daf0132460f7669631f8067df8ecbb80a23c1f51f6b97b12e1a081229ef6
convertNutchConfig
private List<NutchConfig> convertNutchConfig(Map<String, String> map)
{    List<NutchConfig> listNutchConfigs = new LinkedList<>();    for (String key : map.keySet()) {        NutchConfig conf = new NutchConfig();        conf.setName(key);        conf.setValue(map.get(key));        listNutchConfigs.add(conf);    }    return listNutchConfigs;}
1fdf81b908c7627320ee6db8a41b554c489cd0583eb0797f02463df7c2c9b643
startCrawl
public void startCrawl(Long crawlId, NutchInstance instance)
{    Crawl crawl = null;    try {        crawl = crawlDao.queryForId(crawlId);        if (crawl.getCrawlId() == null) {            crawl.setCrawlId("crawl-" + crawlId.toString());        }        NutchClient client = nutchClientFactory.getClient(instance);        String seedDirectory = client.createSeed(crawl.getSeedList());        crawl.setSeedDirectory(seedDirectory);        List<RemoteCommand> commands = commandFactory.createCommands(crawl);        RemoteCommandExecutor executor = new RemoteCommandExecutor(client);        CrawlingCycle cycle = new CrawlingCycle(this, executor, crawl, commands);        cycle.executeCrawlCycle();    } catch (Exception e) {        crawl.setStatus(CrawlStatus.ERROR);        saveCrawl(crawl);        LOG.error("exception occured", e);    }}
e26b8b5b5fd53e22ade9b57373da58781157dcdfa9bdbf701e07accc9b659017
getCrawls
public List<Crawl> getCrawls()
{    try {        return crawlDao.queryForAll();    } catch (SQLException e) {        throw new RuntimeException(e);    }}
d55b38c8b80da3c005f02cb78dc0d9acd0be7aba01627d01f67b4fba30778364
saveCrawl
public void saveCrawl(Crawl crawl)
{    try {        crawlDao.createOrUpdate(crawl);    } catch (SQLException e) {        throw new RuntimeException(e);    }}
a8da10af25505639634ac4a20ab9bed27ab9b8bef49f872cd65007e2ebb3e37a
deleteCrawl
public void deleteCrawl(Long crawlId)
{    try {        crawlDao.deleteById(crawlId);    } catch (SQLException e) {        throw new RuntimeException(e);    }}
7fd3d77fad80a6f863bee4131c93ad3d12dd2e85c39e3940ff1549a72ea79eae
crawlingStarted
public void crawlingStarted(Crawl crawl)
{    crawl.setStatus(CrawlStatus.CRAWLING);    crawl.setProgress(0);    saveCrawl(crawl);}
fb36bc40a5a2ec3c646a39b5348082bf6cfe899d77d1bc526fcc720c282f982d
onCrawlError
public void onCrawlError(Crawl crawl, String msg)
{    crawl.setStatus(CrawlStatus.ERROR);    saveCrawl(crawl);}
c0b450656e0744a96182072566dc2041a8207accbc7c158d1ca069384d51397b
commandExecuted
public void commandExecuted(Crawl crawl, RemoteCommand command, int progress)
{    crawl.setProgress(progress);    saveCrawl(crawl);}
c72e787d06b23f27b9eff190d677e9ddb0cd50654a4e0831ee948604903c85be
crawlingFinished
public void crawlingFinished(Crawl crawl)
{    crawl.setStatus(CrawlStatus.FINISHED);    saveCrawl(crawl);}
bf79c940d92e17ba4759476fc45a71530693b6dd9ba4534b1dc1de44c32b9f3e
getInstances
public List<NutchInstance> getInstances()
{    try {        return instancesDao.queryForAll();    } catch (SQLException e) {        throw new RuntimeException(e);    }}
87c6ea8b1b66f779d1979444622c8e00030e1eb2e941027f52b33d0002a48d2d
getInstance
public NutchInstance getInstance(Long id)
{    try {        return instancesDao.queryForId(id);    } catch (SQLException e) {        throw new RuntimeException(e);    }}
24fe6c1e211caa76029a31afd396211ccdd70f4bd62a2e78c19169908d5a17bd
saveInstance
public void saveInstance(NutchInstance instance)
{    try {        instancesDao.createOrUpdate(instance);    } catch (SQLException e) {        throw new RuntimeException(e);    }}
e78197bed3f5fe54056a18e45f000cf06399ae81dca7befce542001d8dd3cc19
removeInstance
public void removeInstance(Long id)
{    try {        instancesDao.deleteById(id);    } catch (SQLException e) {        throw new RuntimeException(e);    }}
06e255fa90c3bc13b398694f758678e76e1c43105f4cfab1882aa6a531f91696
getConnectionStatus
public ConnectionStatus getConnectionStatus(Long instanceId)
{    NutchInstance instance = instanceService.getInstance(instanceId);    try {        NutchStatus nutchStatus = nutchClientFactory.getClient(instance).getNutchStatus();        if (nutchStatus.getStartDate() != null) {            return ConnectionStatus.CONNECTED;        }    } catch (Exception e) {        if (e.getCause() instanceof ConnectException) {            return ConnectionStatus.DISCONNECTED;        }        LOG.error("Cannot connect to nutch server!", e);    }    return null;}
1c288d71fe16deded8d975e418b0cfe3b1e2c89c35d23c808398dd9ae72ebc18
getNutchConfig
public Map<String, String> getNutchConfig(Long instanceId)
{    NutchInstance instance = instanceService.getInstance(instanceId);    try {        return nutchClientFactory.getClient(instance).getNutchConfig("default");    } catch (ClientHandlerException exception) {        return Collections.emptyMap();    }}
960d581999aac0a414ff45bb756be07c053792a8c1b7dd95f5e7360b188abbc4
getNutchStatus
public NutchStatus getNutchStatus(Long instanceId)
{    NutchInstance instance = instanceService.getInstance(instanceId);    return nutchClientFactory.getClient(instance).getNutchStatus();}
ad29ea52c307c8746def4d72709c63901c5594577437ab023ac3e475db35cc59
save
public void save(SeedList seedList)
{    try {        seedListDao.createOrUpdate(seedList);    } catch (SQLException e) {        throw new RuntimeException(e);    }}
26632600b796ee39211e68e3b11d72f269264201770c189a8aab2edcc49ee339
delete
public void delete(Long seedListId)
{    try {        seedListDao.deleteById(seedListId);    } catch (SQLException e) {        throw new RuntimeException(e);    }}
ca565d92cbf39216a29e39fd495d1d5ec43167b2b4b99167709f7465e284c564
findAll
public List<SeedList> findAll()
{    try {        return seedListDao.queryForAll();    } catch (SQLException e) {        throw new RuntimeException(e);    }}
cfb1a59e1210f667c6b1dd68045653e9481a474570d8656daec0b04c8fe362c1
getSeedList
public SeedList getSeedList(Long seedListId)
{    try {        return seedListDao.queryForId(seedListId);    } catch (SQLException e) {        throw new RuntimeException(e);    }}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
8fa98404280fecfd497ce9400c07196998fbeaf2ee8524779c09bd3c220d4ea9
filter
public NutchDocument filter(NutchDocument doc, Parse parse, Text url, CrawlDatum datum, Inlinks inlinks) throws IndexingException
{    String[] metadata = parse.getData().getParseMeta().getValues(Any23ParseFilter.ANY23_TRIPLES);    if (metadata != null) {        for (String triple : metadata) {            Pattern pattern = Pattern.compile("^([^ ]+) ([^ ]+) (.+) \\.");            Matcher matcher = pattern.matcher(triple);            if (matcher.find()) {                Map<String, String> map = new HashMap<>();                map.put("node", matcher.group(1));                map.put("key", matcher.group(2));                map.put("short_key", keyToShortKey(matcher.group(2)));                map.put("value", matcher.group(3));                doc.add("structured_data", map);            } else {                LOG.warn("Unsupported triple format " + triple);            }        }    }    return doc;}
25e72c0788bafa7aa9264cfc6cb05b8e3f91c5d8f680031928d4a0cba1267e41
keyToShortKey
private String keyToShortKey(String key)
{    if (key.startsWith("<") && key.endsWith(">")) {        key = key.substring(1, key.length() - 1);    }    String[] keyParts = key.split("/");    String[] keySubParts = keyParts[keyParts.length - 1].split("#");    return keySubParts[keySubParts.length - 1];}
3ac41217ee54416aab68b8fcf2d1ebafddd7ae97a07ae2ce2b660eb1e37cb7ca
getTriples
private Set<String> getTriples()
{    return triples;}
39e3ceb085d1cb18245551f5eaa32c23b9ef6f55ed4819918c83dbc038d9f9b1
parse
private void parse(String url, String htmlContent, String contentType, String... extractorNames) throws URISyntaxException, IOException, TripleHandlerException
{    Any23 any23 = new Any23(extractorNames);    any23.setMIMETypeDetector(null);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    try {        TripleHandler tHandler = new NTriplesWriter(baos);        BenchmarkTripleHandler bHandler = new BenchmarkTripleHandler(tHandler);        try {            any23.extract(htmlContent, url, contentType, "UTF-8", bHandler);        } catch (IOException e) {            LOG.error("Error while reading the source", e);        } catch (ExtractionException e) {            LOG.error("Error while extracting structured data", e);        } finally {            tHandler.close();            bHandler.close();        }        LOG.debug("Any23 BenchmarkTripleHandler.report: " + bHandler.report());        String n3 = baos.toString("UTF-8");        String[] triplesStrings = n3.split("\n");        Collections.addAll(triples, triplesStrings);    } catch (IOException e) {        LOG.error("Unexpected IOException", e);    }}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
9ff841f3d46425f0defcf4346027b52742d29abc435829a9bc29d5c88e553a7b
filter
public ParseResult filter(Content content, ParseResult parseResult, HTMLMetaTags metaTags, DocumentFragment doc)
{    String[] extractorNames = conf.getStrings(ANY_23_EXTRACTORS_CONF, "html-head-meta");    String[] supportedContentTypes = conf.getStrings(ANY_23_CONTENT_TYPES_CONF, "text/html", "application/xhtml+xml");    String contentType = content.getContentType();    if (supportedContentTypes != null && !Arrays.asList(supportedContentTypes).contains(contentType)) {        LOG.debug("Ignoring document at {} because it has an unsupported Content-Type {}", content.getUrl(), contentType);        return parseResult;    }    Any23Parser parser;    try {        String htmlContent = new String(content.getContent(), Charset.forName("UTF-8"));        parser = new Any23Parser(content.getUrl(), htmlContent, contentType, extractorNames);    } catch (TripleHandlerException e) {        throw new RuntimeException("Error running Any23 parser: " + e.getMessage());    }    Set<String> triples = parser.getTriples();    Parse parse = parseResult.get(content.getUrl());    Metadata metadata = parse.getData().getParseMeta();    for (String triple : triples) {        metadata.add(ANY23_TRIPLES, triple);    }    return parseResult;}
9aebeb51b603df86163ebb1915e68387ee5a3a090811c83ce9469e408c3dfe85
testAny23TriplesFields
public void testAny23TriplesFields() throws Exception
{    Configuration conf = NutchConfiguration.create();    Any23IndexingFilter filter = new Any23IndexingFilter();    filter.setConf(conf);    Assert.assertNotNull(filter);    NutchDocument doc = new NutchDocument();    ParseData parseData = new ParseData(ParseStatus.STATUS_SUCCESS, "The Foo Page", new Outlink[] {}, new Metadata());    ParseImpl parse = new ParseImpl("test page", parseData);    String[] triples = new String[] { "<http://dbpedia.org/resource/Z\u00FCrich> <http://www.w3.org/2002/07/owl#sameAs> <http://rdf.freebase.com/ns/m.08966> .", "<http://dbpedia.org/resource/Z\u00FCrich> <http://dbpedia.org/property/yearHumidity> \"77\" .", "<http://dbpedia.org/resource/Z\u00FCrich> <http://www.w3.org/2000/01/rdf-schema#label> \"Zurique\"@pt ." };    for (String triple : triples) {        parse.getData().getParseMeta().add(Any23ParseFilter.ANY23_TRIPLES, triple);    }    try {        doc = filter.filter(doc, parse, new Text("http://nutch.apache.org/"), new CrawlDatum(), new Inlinks());    } catch (Exception e) {        e.printStackTrace();        Assert.fail(e.getMessage());    }    List<Object> docTriples = doc.getField(Any23IndexingFilter.STRUCTURED_DATA).getValues();    Assert.assertEquals(docTriples.size(), triples.length);    Object triple = docTriples.get(0);    Assert.assertTrue(triple instanceof Map<?, ?>);    @SuppressWarnings("unchecked")    Map<String, String> structuredData = (Map<String, String>) triple;    Assert.assertEquals(structuredData.get("node"), "<http://dbpedia.org/resource/Z\u00FCrich>");    Assert.assertEquals(structuredData.get("key"), "<http://www.w3.org/2002/07/owl#sameAs>");    Assert.assertEquals(structuredData.get("short_key"), "sameAs");    Assert.assertEquals(structuredData.get("value"), "<http://rdf.freebase.com/ns/m.08966>");    triple = docTriples.get(1);    Assert.assertTrue(triple instanceof Map<?, ?>);    structuredData = (Map<String, String>) triple;    Assert.assertEquals(structuredData.get("node"), "<http://dbpedia.org/resource/Z\u00FCrich>");    Assert.assertEquals(structuredData.get("key"), "<http://dbpedia.org/property/yearHumidity>");    Assert.assertEquals(structuredData.get("short_key"), "yearHumidity");    Assert.assertEquals(structuredData.get("value"), "\"77\"");}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    this.conf = NutchConfiguration.create();    conf.set("file.content.limit", "-1");    conf.set("parser.timeout", "-1");    conf.set(Any23ParseFilter.ANY_23_EXTRACTORS_CONF, "html-embedded-jsonld,html-head-icbm,html-head-links," + "html-head-meta,html-head-title,html-mf-adr,html-mf-geo,html-mf-hcalendar,html-mf-hcard," + "html-mf-hlisting,html-mf-hrecipe,html-mf-hresume,html-mf-hreview,html-mf-hreview-aggregate," + "html-mf-license,html-mf-species,html-mf-xfn,html-microdata,html-rdfa11,html-xpath");    conf.set(Any23ParseFilter.ANY_23_CONTENT_TYPES_CONF, "text/html");}
6c221073f427fa95684eed8bc93f463aaee82cd3150360f9c37763fa8f8e8e53
testExtractTriplesFromHTML
public void testExtractTriplesFromHTML() throws IOException, ParserNotFound, ParseException
{    String[] triplesArray = getTriples(file1);    Assert.assertEquals("We expect 117 tab-separated triples extracted by the filter", EXPECTED_TRIPLES_1, triplesArray.length);}
1340d12f73013ed0e27e3a12c2ace573a50a0f2e73c75e102395b4ed6c1ee770
extractMicroDataFromHTML
public void extractMicroDataFromHTML() throws ParserNotFound, IOException, ParseException
{    String[] triplesArray = getTriples(file2);    Assert.assertEquals("We expect 40 tab-separated triples extracted by the filter", EXPECTED_TRIPLES_2, triplesArray.length);}
a78fb82995df7de2d347acd61fb7113f7655fe58cc9733996cbf2b8f363f4fdf
ignoreUnsupported
public void ignoreUnsupported() throws ParserNotFound, IOException, ParseException
{    String[] triplesArray = getTriples(file1, "application/pdf");    Assert.assertEquals("We expect no triples extracted by the filter since content-type should be ignored", 0, triplesArray.length);}
9ffc6fda66c2e580d968a5c2765a795ff98d66d0e7d94093de235b6633d1e211
extract
public String[] extract(String urlString, File file, String contentType)
{    try {        System.out.println(urlString);        Protocol protocol = new ProtocolFactory(conf).getProtocol(urlString);        Content content = protocol.getProtocolOutput(new Text(urlString), new CrawlDatum()).getContent();        content.setContentType(contentType);        Parse parse = new ParseUtil(conf).parse(content).get(content.getUrl());        return parse.getData().getParseMeta().getValues(Any23ParseFilter.ANY23_TRIPLES);    } catch (Exception e) {        e.printStackTrace();        Assert.fail(e.toString());    }    return null;}
26d6b7a9482731933370f0f048e4772dee21a1ec33bb0e1d415b407896159e77
getTriples
private String[] getTriples(String fileName)
{    return getTriples(fileName, "text/html");}
fd5a1c7d3f5d504d13b4cb632f2b526a997220c7f31331e72cfa92d5144c50c4
getTriples
private String[] getTriples(String fileName, String contentType)
{    String urlString = "file:" + sampleDir + fileSeparator + fileName;    File file = new File(sampleDir + fileSeparator + fileName);    return extract(urlString, file, contentType);}
8fa98404280fecfd497ce9400c07196998fbeaf2ee8524779c09bd3c220d4ea9
filter
public NutchDocument filter(NutchDocument doc, Parse parse, Text url, CrawlDatum datum, Inlinks inlinks) throws IndexingException
{    Metadata metadata = parse.getData().getParseMeta();        String licenseUrl = metadata.get(CreativeCommons.LICENSE_URL);    if (licenseUrl != null) {        if (LOG.isInfoEnabled()) {            LOG.info("CC: indexing " + licenseUrl + " for: " + url.toString());        }                addFeature(doc, "license=" + licenseUrl);                addUrlFeatures(doc, licenseUrl);    }        String licenseLocation = metadata.get(CreativeCommons.LICENSE_LOCATION);    if (licenseLocation != null) {        addFeature(doc, "meta=" + licenseLocation);    }        String workType = metadata.get(CreativeCommons.WORK_TYPE);    if (workType != null) {        addFeature(doc, workType);    }    return doc;}
3f950fae1d1f37ca69ff8b35ab24b3af6a07ff5ff0ad9ce07ca7ccdf27b872a5
addUrlFeatures
public void addUrlFeatures(NutchDocument doc, String urlString)
{    try {        URL url = new URL(urlString);                StringTokenizer names = new StringTokenizer(url.getPath(), "/-");        if (names.hasMoreTokens())                        names.nextToken();                while (names.hasMoreTokens()) {            String feature = names.nextToken();            addFeature(doc, feature);        }    } catch (MalformedURLException e) {        if (LOG.isWarnEnabled()) {            LOG.warn("CC: failed to parse url: " + urlString + " : " + e);        }    }}
8ea7e3b9dabe0271f29b2c722ff5cc0c9884e05d8570432b24722807211d45dc
addFeature
private void addFeature(NutchDocument doc, String feature)
{    doc.add(FIELD, feature);}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
f71fcd6d4702b3862b573783b289cf796419681bd3d5e7e0b2a13c786485e15a
walk
public static void walk(Node doc, URL base, Metadata metadata, Configuration conf) throws ParseException
{        Walker walker = new Walker(base);    walker.walk(doc);        String licenseUrl = null;    String licenseLocation = null;    if (walker.rdfLicense != null) {                licenseLocation = "rdf";        licenseUrl = walker.rdfLicense;    } else if (walker.relLicense != null) {                licenseLocation = "rel";        licenseUrl = walker.relLicense.toString();    } else if (walker.anchorLicense != null) {                licenseLocation = "a";        licenseUrl = walker.anchorLicense.toString();    } else if (conf.getBoolean("creativecommons.exclude.unlicensed", false)) {        throw new ParseException("No CC license.  Excluding.");    }        if (licenseUrl != null) {        if (LOG.isInfoEnabled()) {            LOG.info("CC: found " + licenseUrl + " in " + licenseLocation + " of " + base);        }        metadata.add(CreativeCommons.LICENSE_URL, licenseUrl);        metadata.add(CreativeCommons.LICENSE_LOCATION, licenseLocation);    }    if (walker.workType != null) {        if (LOG.isInfoEnabled()) {            LOG.info("CC: found " + walker.workType + " in " + base);        }        metadata.add(CreativeCommons.WORK_TYPE, walker.workType);    }}
c8bf50411fdc33de67ed05464eb9781e2946d7ce9bc517e19422aa708d47ddd3
walk
private void walk(Node node)
{        if (node instanceof Element) {        findLicenseUrl((Element) node);    }        if (node instanceof Comment) {        findRdf(((Comment) node).getData());    }        NodeList children = node.getChildNodes();    for (int i = 0; children != null && i < children.getLength(); i++) {        walk(children.item(i));    }}
22499b1821c263e2b1472ea9e9281dc0552f1f69f052e245d530bfc98d079188
findLicenseUrl
private void findLicenseUrl(Element element)
{        if (!"a".equalsIgnoreCase(element.getTagName()))        return;        String href = element.getAttribute("href");    if (href == null)        return;    try {                URL url = new URL(base, href);                if ("http".equalsIgnoreCase(url.getProtocol()) && "creativecommons.org".equalsIgnoreCase(url.getHost()) && url.getPath() != null && url.getPath().startsWith("/licenses/") && url.getPath().length() > "/licenses/".length()) {                        String rel = element.getAttribute("rel");            if (rel != null && "license".equals(rel) && this.relLicense == null) {                                this.relLicense = url;            } else if (this.anchorLicense == null) {                                this.anchorLicense = url;            }        }    } catch (MalformedURLException e) {        }}
3916f154bcc8c79af721248c5698187e892d1a79dac992795641e5bd91c9556f
findRdf
private void findRdf(String comment)
{        int rdfPosition = comment.indexOf("RDF");    if (rdfPosition < 0)                return;    int nsPosition = comment.indexOf(CC_NS);    if (nsPosition < 0)                return;        Document doc;    try {        DocumentBuilder parser = FACTORY.newDocumentBuilder();        doc = parser.parse(new InputSource(new StringReader(comment)));    } catch (Exception e) {        if (LOG.isWarnEnabled()) {            LOG.warn("CC: Failed to parse RDF in " + base + ": " + e);        }        return;    }        NodeList roots = doc.getElementsByTagNameNS(RDF_NS, "RDF");    if (roots.getLength() != 1) {        if (LOG.isWarnEnabled()) {            LOG.warn("CC: No RDF root in " + base);        }        return;    }    Element rdf = (Element) roots.item(0);        NodeList licenses = rdf.getElementsByTagNameNS(CC_NS, "License");    for (int i = 0; i < licenses.getLength(); i++) {        Element l = (Element) licenses.item(i);                this.rdfLicense = l.getAttributeNodeNS(RDF_NS, "about").getValue();                NodeList predicates = l.getChildNodes();        for (int j = 0; j < predicates.getLength(); j++) {            Node predicateNode = predicates.item(j);            if (!(predicateNode instanceof Element))                continue;            Element predicateElement = (Element) predicateNode;                        if (!CC_NS.equals(predicateElement.getNamespaceURI())) {                continue;            }        }    }        NodeList works = rdf.getElementsByTagNameNS(CC_NS, "Work");    for (int i = 0; i < works.getLength(); i++) {                NodeList types = rdf.getElementsByTagNameNS(DC_NS, "type");        for (int j = 0; j < types.getLength(); j++) {            Element type = (Element) types.item(j);            String workUri = type.getAttributeNodeNS(RDF_NS, "resource").getValue();            this.workType = WORK_TYPE_NAMES.get(workUri);        }    }}
9ff841f3d46425f0defcf4346027b52742d29abc435829a9bc29d5c88e553a7b
filter
public ParseResult filter(Content content, ParseResult parseResult, HTMLMetaTags metaTags, DocumentFragment doc)
{        Parse parse = parseResult.get(content.getUrl());        URL base;    try {        base = new URL(content.getBaseUrl());    } catch (MalformedURLException e) {        Parse emptyParse = new ParseStatus(e).getEmptyParse(getConf());        parseResult.put(content.getUrl(), new ParseText(emptyParse.getText()), emptyParse.getData());        return parseResult;    }    try {                Walker.walk(doc, base, parse.getData().getParseMeta(), getConf());    } catch (ParseException e) {        Parse emptyParse = new ParseStatus(e).getEmptyParse(getConf());        parseResult.put(content.getUrl(), new ParseText(emptyParse.getText()), emptyParse.getData());        return parseResult;    }    return parseResult;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
2d885c5768d61b98fefb41e32f87d6a1b21686c79877f77ef3234ca2afc85451
testPages
public void testPages() throws Exception
{    pageTest(new File(testDir, "anchor.html"), "http://foo.com/", "http://creativecommons.org/licenses/by-nc-sa/1.0", "a", null);            pageTest(new File(testDir, "rel.html"), "http://foo.com/", "http://creativecommons.org/licenses/by-nc/2.0", "rel", null);            pageTest(new File(testDir, "rdf.html"), "http://foo.com/", "http://creativecommons.org/licenses/by-nc/1.0", "rdf", "text");}
18a9f801331c1b0bbb7ec0d33b144a936dc8f24c875ed1d771a1c297db710635
pageTest
public void pageTest(File file, String url, String license, String location, String type) throws Exception
{    String contentType = "text/html";    InputStream in = new FileInputStream(file);    ByteArrayOutputStream out = new ByteArrayOutputStream((int) file.length());    byte[] buffer = new byte[1024];    int i;    while ((i = in.read(buffer)) != -1) {        out.write(buffer, 0, i);    }    in.close();    byte[] bytes = out.toByteArray();    Configuration conf = NutchConfiguration.create();    Content content = new Content(url, url, bytes, contentType, new Metadata(), conf);    Parse parse = new ParseUtil(conf).parse(content).get(content.getUrl());    Metadata metadata = parse.getData().getParseMeta();    Assert.assertEquals(license, metadata.get("License-Url"));    Assert.assertEquals(location, metadata.get("License-Location"));    Assert.assertEquals(type, metadata.get("Work-Type"));}
45c2bdeed031c5f7fe4ad59513fd13f349cfca1e76f62fe695a3f7945985700b
open
public void open(Map<String, String> parameters)
{    expression = JexlUtil.parseExpression(parameters.get(EXPRESSION_KEY));}
6892b0d3b3d4a16069879df576e19082411377f96dbf47aa3ae68d051b986ddf
match
public boolean match(NutchDocument doc)
{        JexlContext jexlContext = new MapContext();    jexlContext.set("doc", doc);    try {        if (Boolean.TRUE.equals(expression.evaluate(jexlContext))) {            return true;        }    } catch (Exception ignored) {    }    return false;}
9c9813ec5150aa99c66b8c22257a531dd5cb8d663ffd85cbd6891bf6890819a8
setConf
public void setConf(Configuration configuration)
{    this.conf = configuration;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
8fa98404280fecfd497ce9400c07196998fbeaf2ee8524779c09bd3c220d4ea9
filter
public NutchDocument filter(NutchDocument doc, Parse parse, Text url, CrawlDatum datum, Inlinks inlinks) throws IndexingException
{    ParseData parseData = parse.getData();    Metadata parseMeta = parseData.getParseMeta();    String[] authors = parseMeta.getValues(Feed.FEED_AUTHOR);    String[] tags = parseMeta.getValues(Feed.FEED_TAGS);    String published = parseMeta.get(Feed.FEED_PUBLISHED);    String updated = parseMeta.get(Feed.FEED_UPDATED);    String feed = parseMeta.get(Feed.FEED);    if (authors != null) {        for (String author : authors) {            doc.add(Feed.FEED_AUTHOR, author);        }    }    if (tags != null) {        for (String tag : tags) {            doc.add(Feed.FEED_TAGS, tag);        }    }    if (feed != null)        doc.add(Feed.FEED, feed);    if (published != null) {        Date date = new Date(Long.parseLong(published));        doc.add(PUBLISHED_DATE, date);    }    if (updated != null) {        Date date = new Date(Long.parseLong(updated));        doc.add(UPDATED_DATE, date);    }    return doc;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
74c073cf714c8a8285642be67ae2f28cd713bfd23722543918cc25b506734fed
getParse
public ParseResult getParse(Content content)
{    SyndFeed feed = null;    ParseResult parseResult = new ParseResult(content.getUrl());    EncodingDetector detector = new EncodingDetector(conf);    detector.autoDetectClues(content, true);    String encoding = detector.guessEncoding(content, defaultEncoding);    try {        InputSource input = new InputSource(new ByteArrayInputStream(content.getContent()));        input.setEncoding(encoding);        SyndFeedInput feedInput = new SyndFeedInput();        feed = feedInput.build(input);    } catch (Exception e) {                LOG.warn("Parse failed: url: " + content.getUrl() + ", exception: " + StringUtils.stringifyException(e));        return new ParseStatus(e).getEmptyParseResult(content.getUrl(), getConf());    }    String feedLink = feed.getLink();    try {        feedLink = normalizers.normalize(feedLink, URLNormalizers.SCOPE_OUTLINK);        if (feedLink != null)            feedLink = filters.filter(feedLink);    } catch (Exception e) {        feedLink = null;    }    List<?> entries = feed.getEntries();    for (Object entry : entries) {        addToMap(parseResult, feed, feedLink, (SyndEntry) entry, content);    }    String feedDesc = stripTags(feed.getDescriptionEx());    String feedTitle = stripTags(feed.getTitleEx());    parseResult.put(content.getUrl(), new ParseText(feedDesc), new ParseData(new ParseStatus(ParseStatus.SUCCESS), feedTitle, new Outlink[0], content.getMetadata()));    return parseResult;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    this.parserFactory = new ParserFactory(conf);    this.normalizers = new URLNormalizers(conf, URLNormalizers.SCOPE_OUTLINK);    this.filters = new URLFilters(conf);    this.defaultEncoding = conf.get("parser.character.encoding.default", "windows-1252");}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    if (args.length != 1) {        System.err.println("Usage: FeedParser <feed>");        System.exit(1);    }    String name = args[0];    String url = "file:" + name;    Configuration conf = NutchConfiguration.create();    FeedParser parser = new FeedParser();    parser.setConf(conf);    File file = new File(name);    byte[] bytes = new byte[(int) file.length()];    DataInputStream in = new DataInputStream(new FileInputStream(file));    in.readFully(bytes);    in.close();    ParseResult parseResult = parser.getParse(new Content(url, url, bytes, "application/rss+xml", new Metadata(), conf));    for (Entry<Text, Parse> entry : parseResult) {        System.out.println("key: " + entry.getKey());        Parse parse = entry.getValue();        System.out.println("data: " + parse.getData());        System.out.println("text: " + parse.getText() + "\n");    }}
9e6d2e1b3dcb5100caa6a7cef480f8312a9fd56718460b631ca5de0c8818e426
addToMap
private void addToMap(ParseResult parseResult, SyndFeed feed, String feedLink, SyndEntry entry, Content content)
{    String link = entry.getLink(), text = null, title = null;    Metadata parseMeta = new Metadata(), contentMeta = content.getMetadata();    Parse parse = null;    SyndContent description = entry.getDescription();    try {        link = normalizers.normalize(link, URLNormalizers.SCOPE_OUTLINK);        if (link != null)            link = filters.filter(link);    } catch (Exception e) {        e.printStackTrace();        return;    }    if (link == null)        return;    title = stripTags(entry.getTitleEx());    if (feedLink != null)        parseMeta.set("feed", feedLink);    addFields(parseMeta, contentMeta, feed, entry);                String contentType = contentMeta.get(Response.CONTENT_TYPE);    if (description != null)        text = description.getValue();    if (text == null) {        List<?> contents = entry.getContents();        StringBuilder buf = new StringBuilder();        for (Object syndContent : contents) {            buf.append(((SyndContent) syndContent).getValue());        }        text = buf.toString();    }    try {        Parser parser = parserFactory.getParsers(contentType, link)[0];        parse = parser.getParse(new Content(link, link, text.getBytes(), contentType, contentMeta, conf)).get(link);    } catch (ParserNotFound e) {    /* ignore */    }    if (parse != null) {        ParseData data = parse.getData();        data.getContentMeta().remove(Response.CONTENT_TYPE);        mergeMetadata(data.getParseMeta(), parseMeta);        parseResult.put(link, new ParseText(parse.getText()), new ParseData(ParseStatus.STATUS_SUCCESS, title, data.getOutlinks(), data.getContentMeta(), data.getParseMeta()));    } else {        contentMeta.remove(Response.CONTENT_TYPE);        parseResult.put(link, new ParseText(text), new ParseData(ParseStatus.STATUS_FAILURE, title, new Outlink[0], contentMeta, parseMeta));    }}
7f5b05ebd1faabb669fab3fee8e5ba6580786757a15220ef7b7a1f0a7bcdb5cc
stripTags
private static String stripTags(SyndContent c)
{    if (c == null)        return "";    String value = c.getValue();    String[] parts = value.split("<[^>]*>");    StringBuffer buf = new StringBuffer();    for (String part : parts) buf.append(part);    return buf.toString().trim();}
35f048640b09a93e82f2b2d84113970a4f8cfbc32095f2df632c9a78aae37b1e
addFields
private void addFields(Metadata parseMeta, Metadata contentMeta, SyndFeed feed, SyndEntry entry)
{    List<?> authors = entry.getAuthors(), categories = entry.getCategories();    Date published = entry.getPublishedDate(), updated = entry.getUpdatedDate();    String contentType = null;    if (authors != null) {        for (Object o : authors) {            SyndPerson author = (SyndPerson) o;            String authorName = author.getName();            if (checkString(authorName)) {                parseMeta.add(Feed.FEED_AUTHOR, authorName);            }        }    } else {                        String authorName = entry.getAuthor();        if (checkString(authorName)) {            parseMeta.set(Feed.FEED_AUTHOR, authorName);        }    }    for (Object i : categories) {        parseMeta.add(Feed.FEED_TAGS, ((SyndCategory) i).getName());    }    if (published != null) {        parseMeta.set(Feed.FEED_PUBLISHED, Long.toString(published.getTime()));    }    if (updated != null) {        parseMeta.set(Feed.FEED_UPDATED, Long.toString(updated.getTime()));    }    SyndContent description = entry.getDescription();    if (description != null) {        contentType = description.getType();    } else {                List<?> contents = entry.getContents();        if (contents.size() > 0) {            contentType = ((SyndContent) contents.get(0)).getType();        }    }    if (checkString(contentType)) {                if (contentType.equals("html"))            contentType = "text/html";        else if (contentType.equals("xhtml"))            contentType = "text/xhtml";        contentMeta.set(Response.CONTENT_TYPE, contentType + "; " + CHARSET_UTF8);    } else {        contentMeta.set(Response.CONTENT_TYPE, TEXT_PLAIN_CONTENT_TYPE);    }}
57a9e0e2f3712cadbde216a0aec024f04355d4d8017c0ef0ac85a51c1e89be87
mergeMetadata
private void mergeMetadata(Metadata first, Metadata second)
{    for (String name : second.names()) {        String[] values = second.getValues(name);        for (String value : values) {            first.add(name, value);        }    }}
3e9c6d830fc07784b2cfe32b9d6cdebee690c5d895dc70ad2f10451dc97fd456
checkString
private boolean checkString(String s)
{    return s != null && !s.equals("");}
8d3c70a5d2984be05099b100eb8bb72ff8797c43fad2e8f937039e0214505c27
testParseFetchChannel
public void testParseFetchChannel() throws ProtocolNotFound, ParseException
{    String urlString;    Protocol protocol;    Content content;    ParseResult parseResult;    Configuration conf = NutchConfiguration.create();    for (int i = 0; i < sampleFiles.length; i++) {        urlString = "file:" + sampleDir + fileSeparator + sampleFiles[i];        urlString = urlString.replace('\\', '/');        protocol = new ProtocolFactory(conf).getProtocol(urlString);        content = protocol.getProtocolOutput(new Text(urlString), new CrawlDatum()).getContent();        parseResult = new ParseUtil(conf).parseByExtensionId("feed", content);        Assert.assertEquals(3, parseResult.size());        boolean hasLink1 = false, hasLink2 = false, hasLink3 = false;        for (Iterator<Map.Entry<Text, Parse>> j = parseResult.iterator(); j.hasNext(); ) {            Map.Entry<Text, Parse> entry = j.next();            if (entry.getKey().toString().equals("http://www-scf.usc.edu/~mattmann/")) {                hasLink1 = true;            } else if (entry.getKey().toString().equals("http://www.nutch.org/")) {                hasLink2 = true;            } else if (entry.getKey().toString().equals(urlString)) {                hasLink3 = true;            }            Assert.assertNotNull(entry.getValue());            Assert.assertNotNull(entry.getValue().getData());        }        if (!hasLink1 || !hasLink2 || !hasLink3) {            Assert.fail("Outlinks read from sample rss file are not correct!");        }    }}
9ff841f3d46425f0defcf4346027b52742d29abc435829a9bc29d5c88e553a7b
filter
public ParseResult filter(Content content, ParseResult parseResult, HTMLMetaTags metaTags, DocumentFragment doc)
{    Parse parse = parseResult.get(content.getUrl());    for (int i = 0; headings != null && i < headings.length; i++) {        List<String> discoveredHeadings = getElement(doc, headings[i]);        if (discoveredHeadings.size() > 0) {            for (String heading : discoveredHeadings) {                if (heading != null) {                    heading = heading.trim();                    if (heading.length() > 0) {                        parse.getData().getParseMeta().add(headings[i], heading);                    }                }            }        }    }    return parseResult;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    headings = conf.getStrings("headings");    multiValued = conf.getBoolean("headings.multivalued", false);}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
89480c081606cb142cdb922489f949e2aea5a72a868bfc7103c47d4d602782aa
getElement
protected List<String> getElement(DocumentFragment doc, String element)
{    List<String> headings = new ArrayList<>();    NodeWalker walker = new NodeWalker(doc);    while (walker.hasNext()) {        Node currentNode = walker.nextNode();        if (currentNode.getNodeType() == Node.ELEMENT_NODE) {            if (element.equalsIgnoreCase(currentNode.getNodeName())) {                headings.add(getNodeValue(currentNode));                                if (!multiValued) {                    break;                }            }        }    }    return headings;}
4a123194b2f2fa031114331e05ff2ce22896c6fdf731cde1081156e2c5418f4a
getNodeValue
protected static String getNodeValue(Node node)
{    StringBuilder buffer = new StringBuilder();    NodeWalker walker = new NodeWalker(node);    while (walker.hasNext()) {        final Node n = walker.nextNode();        if (n.getNodeType() == Node.TEXT_NODE) {            buffer.append(n.getNodeValue());        }    }        Matcher matcher = whitespacePattern.matcher(buffer.toString().trim());    return matcher.replaceAll(" ").trim();}
b56900b9b659f2d8b5db17757efab02deed44f70e4853e0623d9036ca1075b9a
testExtractHeadingFromNestedNodes
public void testExtractHeadingFromNestedNodes() throws IOException, SAXException
{    conf.setStrings("headings", "h1", "h2");    HtmlParseFilter filter = new HeadingsParseFilter();    filter.setConf(conf);    Content content = new Content("http://www.foo.com/", "http://www.foo.com/", "".getBytes("UTF8"), "text/html; charset=UTF-8", new Metadata(), conf);    ParseImpl parse = new ParseImpl("foo bar", new ParseData());    ParseResult parseResult = ParseResult.createParseResult("http://www.foo.com/", parse);    HTMLMetaTags metaTags = new HTMLMetaTags();    DOMFragmentParser parser = new DOMFragmentParser();    DocumentFragment node = new HTMLDocumentImpl().createDocumentFragment();    parser.parse(new InputSource(new ByteArrayInputStream(("<html><head><title>test header with span element</title></head><body><h1>header with <span>span element</span></h1></body></html>").getBytes())), node);    parseResult = filter.filter(content, parseResult, metaTags, node);    Assert.assertEquals("The h1 tag must include the content of the inner span node", "header with span element", parseResult.get(content.getUrl()).getData().getParseMeta().get("h1"));}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    deduplicate = conf.getBoolean("anchorIndexingFilter.deduplicate", false);    LOG.info("Anchor deduplication is: " + (deduplicate ? "on" : "off"));}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
8fa98404280fecfd497ce9400c07196998fbeaf2ee8524779c09bd3c220d4ea9
filter
public NutchDocument filter(NutchDocument doc, Parse parse, Text url, CrawlDatum datum, Inlinks inlinks) throws IndexingException
{    String[] anchors = (inlinks != null ? inlinks.getAnchors() : new String[0]);    HashSet<String> set = null;    for (int i = 0; i < anchors.length; i++) {        if (deduplicate) {            if (set == null)                set = new HashSet<String>();            String lcAnchor = anchors[i].toLowerCase();                        if (!set.contains(lcAnchor)) {                doc.add("anchor", anchors[i]);                                set.add(lcAnchor);            }        } else {            doc.add("anchor", anchors[i]);        }    }    return doc;}
87821d52bea33854f79b25ef707a761a663e98b376f2788ead273d3001c955d4
testDeduplicateAnchor
public void testDeduplicateAnchor() throws Exception
{    Configuration conf = NutchConfiguration.create();    conf.setBoolean("anchorIndexingFilter.deduplicate", true);    AnchorIndexingFilter filter = new AnchorIndexingFilter();    filter.setConf(conf);    Assert.assertNotNull(filter);    NutchDocument doc = new NutchDocument();    ParseImpl parse = new ParseImpl("foo bar", new ParseData());    Inlinks inlinks = new Inlinks();    inlinks.add(new Inlink("http://test1.com/", "text1"));    inlinks.add(new Inlink("http://test2.com/", "text2"));    inlinks.add(new Inlink("http://test3.com/", "text2"));    try {        filter.filter(doc, parse, new Text("http://nutch.apache.org/index.html"), new CrawlDatum(), inlinks);    } catch (Exception e) {        e.printStackTrace();        Assert.fail(e.getMessage());    }    Assert.assertNotNull(doc);    Assert.assertTrue("test if there is an anchor at all", doc.getFieldNames().contains("anchor"));    Assert.assertEquals("test dedup, we expect 2", 2, doc.getField("anchor").getValues().size());}
8fa98404280fecfd497ce9400c07196998fbeaf2ee8524779c09bd3c220d4ea9
filter
public NutchDocument filter(NutchDocument doc, Parse parse, Text url, CrawlDatum datum, Inlinks inlinks) throws IndexingException
{    Text reprUrl = (Text) datum.getMetaData().get(Nutch.WRITABLE_REPR_URL_KEY);    String reprUrlString = reprUrl != null ? reprUrl.toString() : null;    String urlString = url.toString();    String host = null;    try {        URL u;        if (reprUrlString != null) {            u = new URL(reprUrlString);        } else {            u = new URL(urlString);        }        if (addDomain) {            doc.add("domain", URLUtil.getDomainName(u));        }        host = u.getHost();    } catch (MalformedURLException e) {        throw new IndexingException(e);    }    if (host != null) {        doc.add("host", host);    }    doc.add("url", reprUrlString == null ? urlString : reprUrlString);        String content = parse.getText();    if (MAX_CONTENT_LENGTH > -1 && content.length() > MAX_CONTENT_LENGTH) {        content = content.substring(0, MAX_CONTENT_LENGTH);    }    doc.add("content", StringUtil.cleanField(content));        String title = parse.getData().getTitle();    if (MAX_TITLE_LENGTH > -1 && title.length() > MAX_TITLE_LENGTH) {                                        title = title.substring(0, MAX_TITLE_LENGTH);    }    if (title.length() > 0) {                doc.add("title", StringUtil.cleanField(title));    }        String caching = parse.getData().getMeta(Nutch.CACHING_FORBIDDEN_KEY);    if (caching != null && !caching.equals(Nutch.CACHING_FORBIDDEN_NONE)) {        doc.add("cache", caching);    }        doc.add("tstamp", new Date(datum.getFetchTime()));    return doc;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    this.MAX_TITLE_LENGTH = conf.getInt("indexer.max.title.length", 100);    this.addDomain = conf.getBoolean("indexer.add.domain", false);    this.MAX_CONTENT_LENGTH = conf.getInt("indexer.max.content.length", -1);}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
cb37c8d7a4d899d471dbb29f74585c329a0dd52b1afafd1828fd1c7ebc8f62fe
testBasicIndexingFilter
public void testBasicIndexingFilter() throws Exception
{    Configuration conf = NutchConfiguration.create();    conf.setInt("indexer.max.title.length", 10);    conf.setBoolean("indexer.add.domain", true);    conf.setInt("indexer.max.content.length", 20);    BasicIndexingFilter filter = new BasicIndexingFilter();    filter.setConf(conf);    Assert.assertNotNull(filter);    NutchDocument doc = new NutchDocument();    String title = "The Foo Page";    Outlink[] outlinks = new Outlink[] { new Outlink("http://foo.com/", "Foo") };    Metadata metaData = new Metadata();    metaData.add("Language", "en/us");    ParseData parseData = new ParseData(ParseStatus.STATUS_SUCCESS, title, outlinks, metaData);    ParseImpl parse = new ParseImpl("this is a sample foo bar page. hope you enjoy it.", parseData);    CrawlDatum crawlDatum = new CrawlDatum();    crawlDatum.setFetchTime(100L);    Inlinks inlinks = new Inlinks();    try {        filter.filter(doc, parse, new Text("http://nutch.apache.org/index.html"), crawlDatum, inlinks);    } catch (Exception e) {        e.printStackTrace();        Assert.fail(e.getMessage());    }    Assert.assertNotNull(doc);    Assert.assertEquals("test title, expect \"The Foo Pa\"", "The Foo Pa", doc.getField("title").getValues().get(0));    Assert.assertEquals("test domain, expect \"apache.org\"", "apache.org", doc.getField("domain").getValues().get(0));    Assert.assertEquals("test host, expect \"nutch.apache.org\"", "nutch.apache.org", doc.getField("host").getValues().get(0));    Assert.assertEquals("test url, expect \"http://nutch.apache.org/index.html\"", "http://nutch.apache.org/index.html", doc.getField("url").getValues().get(0));    Assert.assertEquals("test content", "this is a sample foo", doc.getField("content").getValues().get(0));    Assert.assertEquals("test fetch time", new Date(100L), (Date) doc.getField("tstamp").getValues().get(0));}
031c8e39efb3d279ddd538bb05cd14630adfe0d9d09bb69159b5a59f94ab54c4
addIfNotNull
public static void addIfNotNull(NutchDocument doc, String name, String value)
{    if (value != null) {        doc.add(name, value);    }}
5cee7d003abde46102f89a6a3565dc410238f2364e0d2f3bd04e828751edd762
addIfNotNull
public static void addIfNotNull(NutchDocument doc, String name, Integer value)
{    if (value != null) {        doc.add(name, value);    }}
49f5bcb78cc8cd1515b578684c1ca6afec9ff46c2a67e8b34c02a17ac9abf70d
createDocFromInsightsService
public static NutchDocument createDocFromInsightsService(String serverIp, NutchDocument doc, WebServiceClient client) throws UnknownHostException, IOException, GeoIp2Exception
{    addIfNotNull(doc, "ip", serverIp);    InsightsResponse response = client.insights(InetAddress.getByName(serverIp));        City city = response.getCity();        addIfNotNull(doc, "cityName", city.getName());        addIfNotNull(doc, "cityConfidence", city.getConfidence());    addIfNotNull(doc, "cityGeoNameId", city.getGeoNameId());    Continent continent = response.getContinent();    addIfNotNull(doc, "continentCode", continent.getCode());    addIfNotNull(doc, "continentGeoNameId", continent.getGeoNameId());    addIfNotNull(doc, "continentName", continent.getName());    Country country = response.getCountry();        addIfNotNull(doc, "countryIsoCode", country.getIsoCode());        addIfNotNull(doc, "countryName", country.getName());        addIfNotNull(doc, "countryConfidence", country.getConfidence());    addIfNotNull(doc, "countryGeoName", country.getGeoNameId());    Location location = response.getLocation();        addIfNotNull(doc, "latLon", location.getLatitude() + "," + location.getLongitude());            addIfNotNull(doc, "accRadius", location.getAccuracyRadius());        addIfNotNull(doc, "timeZone", location.getTimeZone());    addIfNotNull(doc, "metroCode", location.getMetroCode());    Postal postal = response.getPostal();        addIfNotNull(doc, "postalCode", postal.getCode());        addIfNotNull(doc, "postalConfidence", postal.getConfidence());    RepresentedCountry rCountry = response.getRepresentedCountry();    addIfNotNull(doc, "countryType", rCountry.getType());    Subdivision subdivision = response.getMostSpecificSubdivision();        addIfNotNull(doc, "subDivName", subdivision.getName());        addIfNotNull(doc, "subDivIdoCode", subdivision.getIsoCode());        addIfNotNull(doc, "subDivConfidence", subdivision.getConfidence());    addIfNotNull(doc, "subDivGeoNameId", subdivision.getGeoNameId());    Traits traits = response.getTraits();    addIfNotNull(doc, "autonSystemNum", traits.getAutonomousSystemNumber());    addIfNotNull(doc, "autonSystemOrg", traits.getAutonomousSystemOrganization());    addIfNotNull(doc, "domain", traits.getDomain());    addIfNotNull(doc, "isp", traits.getIsp());    addIfNotNull(doc, "org", traits.getOrganization());    addIfNotNull(doc, "userType", traits.getUserType());            addIfNotNull(doc, "isAnonProxy", String.valueOf(traits.isAnonymousProxy()));    return doc;}
793ee80a13ee5424c6e7f85d2cd0d933a53743756c5eb2a5e52a17d992ff10e9
createDocFromCityService
public static NutchDocument createDocFromCityService(String serverIp, NutchDocument doc, WebServiceClient client) throws UnknownHostException, IOException, GeoIp2Exception
{    CityResponse response = client.city(InetAddress.getByName(serverIp));    return doc;}
c7b1b77a8f2de1534e47ac37e705bda400d85f460df21ff7944b44c443fb9c17
createDocFromCountryService
public static NutchDocument createDocFromCountryService(String serverIp, NutchDocument doc, WebServiceClient client) throws UnknownHostException, IOException, GeoIp2Exception
{    CountryResponse response = client.country(InetAddress.getByName(serverIp));    return doc;}
4c127be9c87ff126d6e19efb70d9af8b7ab5205b941ddc4bb6115b607b70f92c
createDocFromIspDb
public static NutchDocument createDocFromIspDb(String serverIp, NutchDocument doc, DatabaseReader reader) throws UnknownHostException, IOException, GeoIp2Exception
{    IspResponse response = reader.isp(InetAddress.getByName(serverIp));    addIfNotNull(doc, "ip", serverIp);    addIfNotNull(doc, "autonSystemNum", response.getAutonomousSystemNumber());    addIfNotNull(doc, "autonSystemOrg", response.getAutonomousSystemOrganization());    addIfNotNull(doc, "isp", response.getIsp());    addIfNotNull(doc, "org", response.getOrganization());    return doc;}
371644633518af5483b45bebca133ec2a59fd2b6b97f6ff4a3bf32ee1ae337c3
createDocFromDomainDb
public static NutchDocument createDocFromDomainDb(String serverIp, NutchDocument doc, DatabaseReader reader) throws UnknownHostException, IOException, GeoIp2Exception
{    DomainResponse response = reader.domain(InetAddress.getByName(serverIp));    addIfNotNull(doc, "ip", serverIp);    addIfNotNull(doc, "domain", response.getDomain());    return doc;}
4cb70ab1e18c3d0d3b811355dd3c54ab66105b1cce666be9be0882e3781d575a
createDocFromConnectionDb
public static NutchDocument createDocFromConnectionDb(String serverIp, NutchDocument doc, DatabaseReader reader) throws UnknownHostException, IOException, GeoIp2Exception
{    ConnectionTypeResponse response = reader.connectionType(InetAddress.getByName(serverIp));    addIfNotNull(doc, "ip", serverIp);    addIfNotNull(doc, "connType", response.getConnectionType().toString());    return doc;}
62fbd9114547f1a9ce77603cd432897c74901b445d72ce21131edc09f80a12f2
createDocFromCityDb
public static NutchDocument createDocFromCityDb(String serverIp, NutchDocument doc, DatabaseReader reader) throws UnknownHostException, IOException, GeoIp2Exception
{    addIfNotNull(doc, "ip", serverIp);    CityResponse response = reader.city(InetAddress.getByName(serverIp));    City city = response.getCity();        addIfNotNull(doc, "cityName", city.getName());        addIfNotNull(doc, "cityConfidence", city.getConfidence());    addIfNotNull(doc, "cityGeoNameId", city.getGeoNameId());    Continent continent = response.getContinent();    addIfNotNull(doc, "continentCode", continent.getCode());    addIfNotNull(doc, "continentGeoNameId", continent.getGeoNameId());    addIfNotNull(doc, "continentName", continent.getName());    Country country = response.getCountry();        addIfNotNull(doc, "countryIsoCode", country.getIsoCode());        addIfNotNull(doc, "countryName", country.getName());        addIfNotNull(doc, "countryConfidence", country.getConfidence());    addIfNotNull(doc, "countryGeoName", country.getGeoNameId());    Location location = response.getLocation();        addIfNotNull(doc, "latLon", location.getLatitude() + "," + location.getLongitude());            addIfNotNull(doc, "accRadius", location.getAccuracyRadius());        addIfNotNull(doc, "timeZone", location.getTimeZone());    addIfNotNull(doc, "metroCode", location.getMetroCode());    Postal postal = response.getPostal();        addIfNotNull(doc, "postalCode", postal.getCode());        addIfNotNull(doc, "postalConfidence", postal.getConfidence());    RepresentedCountry rCountry = response.getRepresentedCountry();    addIfNotNull(doc, "countryType", rCountry.getType());    Subdivision subdivision = response.getMostSpecificSubdivision();        addIfNotNull(doc, "subDivName", subdivision.getName());        addIfNotNull(doc, "subDivIdoCode", subdivision.getIsoCode());        addIfNotNull(doc, "subDivConfidence", subdivision.getConfidence());    addIfNotNull(doc, "subDivGeoNameId", subdivision.getGeoNameId());    return doc;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    usage = conf.get("index.geoip.usage", "insightsService");    LOG.debug("GeoIP usage medium set to: {}", usage);    if (usage.equalsIgnoreCase("insightsService")) {        client = new WebServiceClient.Builder(conf.getInt("index.geoip.userid", 12345), conf.get("index.geoip.licensekey")).build();    } else {        String db = null;        if (usage.equalsIgnoreCase("cityDatabase")) {            db = "GeoIP2-City.mmdb";        } else if (usage.equalsIgnoreCase("connectionTypeDatabase")) {            db = "GeoIP2-Connection-Type.mmdb";        } else if (usage.equalsIgnoreCase("domainDatabase")) {            db = "GeoIP2-Domain.mmdb";        } else if (usage.equalsIgnoreCase("ispDatabase")) {            db = "GeoIP2-ISP.mmdb";        }        URL dbFileUrl = conf.getResource(db);        if (dbFileUrl == null) {            LOG.error("GeoDb file {} not found on classpath", db);        } else {            try {                buildDb(new File(dbFileUrl.getFile()));            } catch (Exception e) {                LOG.error("Failed to read geoDb file {}: ", db, e);            }        }    }    if (!conf.getBoolean("store.ip.address", false)) {        LOG.warn("Plugin index-geoip is active but IP address is not stored" + "(store.ip.address == false)");    }}
f8b8aa41b6ba5d450752e662f6cbeab74c9144bd18ca0eec9b0b31b457953bd0
buildDb
private void buildDb(File geoDb)
{    try {        reader = new DatabaseReader.Builder(geoDb).build();    } catch (IOException e) {        LOG.error("Failed to build geoDb:", e);    }}
8fa98404280fecfd497ce9400c07196998fbeaf2ee8524779c09bd3c220d4ea9
filter
public NutchDocument filter(NutchDocument doc, Parse parse, Text url, CrawlDatum datum, Inlinks inlinks) throws IndexingException
{    return addServerGeo(doc, parse.getData(), url.toString());}
e48f76eb53df5fd774259068147ea3f9dec726762d7be0f543f2a5329defe69a
addServerGeo
private NutchDocument addServerGeo(NutchDocument doc, ParseData data, String url)
{    String serverIp = data.getContentMeta().get("_ip_");    if (serverIp != null && reader != null) {        try {            if (usage.equalsIgnoreCase("cityDatabase")) {                doc = GeoIPDocumentCreator.createDocFromCityDb(serverIp, doc, reader);            } else if (usage.equalsIgnoreCase("connectionTypeDatabase")) {                doc = GeoIPDocumentCreator.createDocFromConnectionDb(serverIp, doc, reader);            } else if (usage.equalsIgnoreCase("domainDatabase")) {                doc = GeoIPDocumentCreator.createDocFromDomainDb(serverIp, doc, reader);            } else if (usage.equalsIgnoreCase("ispDatabase")) {                doc = GeoIPDocumentCreator.createDocFromIspDb(serverIp, doc, reader);            } else if (usage.equalsIgnoreCase("insightsService")) {                doc = GeoIPDocumentCreator.createDocFromInsightsService(serverIp, doc, client);            }        } catch (Exception e) {            LOG.error("Failed to determine geoip:", e);        }    }    return doc;}
8fa98404280fecfd497ce9400c07196998fbeaf2ee8524779c09bd3c220d4ea9
filter
public NutchDocument filter(NutchDocument doc, Parse parse, Text url, CrawlDatum datum, Inlinks inlinks) throws IndexingException
{        JexlContext jcontext = new MapContext();    jcontext.set("status", CrawlDatum.getStatusName(datum.getStatus()));    jcontext.set("fetchTime", (long) (datum.getFetchTime()));    jcontext.set("modifiedTime", (long) (datum.getModifiedTime()));    jcontext.set("retries", datum.getRetriesSinceFetch());    jcontext.set("interval", Integer.valueOf(datum.getFetchInterval()));    jcontext.set("score", datum.getScore());    jcontext.set("signature", StringUtil.toHexString(datum.getSignature()));    jcontext.set("url", url.toString());    jcontext.set("text", parse.getText());    jcontext.set("title", parse.getData().getTitle());    JexlContext httpStatusContext = new MapContext();    httpStatusContext.set("majorCode", parse.getData().getStatus().getMajorCode());    httpStatusContext.set("minorCode", parse.getData().getStatus().getMinorCode());    httpStatusContext.set("message", parse.getData().getStatus().getMessage());    jcontext.set("httpStatus", httpStatusContext);    jcontext.set("documentMeta", metadataToContext(doc.getDocumentMeta()));    jcontext.set("contentMeta", metadataToContext(parse.getData().getContentMeta()));    jcontext.set("parseMeta", metadataToContext(parse.getData().getParseMeta()));    JexlContext context = new MapContext();    for (Entry<String, NutchField> entry : doc) {        List<Object> values = entry.getValue().getValues();        context.set(entry.getKey(), values.size() > 1 ? values : values.get(0));    }    jcontext.set("doc", context);    try {        if (Boolean.TRUE.equals(expr.evaluate(jcontext))) {            return doc;        }    } catch (Exception e) {        LOG.warn("Failed evaluating JEXL {}", expr.getExpression(), e);    }    return null;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    String strExpr = conf.get("index.jexl.filter");    if (strExpr == null) {        LOG.error("The property index.jexl.filter must have a value when index-jexl-filter is used. You can use 'true' or 'false' to index all/none");        throw new RuntimeException("The property index.jexl.filter must have a value when index-jexl-filter is used. You can use 'true' or 'false' to index all/none");    }    expr = JexlUtil.parseExpression(strExpr);    if (expr == null) {        LOG.error("Failed parsing JEXL from index.jexl.filter: {}", strExpr);        throw new RuntimeException("Failed parsing JEXL from index.jexl.filter");    }}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
0b29f3a840d759d2e4749643ce5fea4e8cdc7c27e7c27e39f1456bec13496ab4
metadataToContext
private JexlContext metadataToContext(Metadata metadata)
{    JexlContext context = new MapContext();    for (String name : metadata.names()) {        String[] values = metadata.getValues(name);        context.set(name, values.length > 1 ? values : values[0]);    }    return context;}
8453a929fe9a6c7fd0099c22ee54119222797c2df95891f7963177db38052093
testAllowMatchingDocument
public void testAllowMatchingDocument() throws Exception
{    Configuration conf = NutchConfiguration.create();    conf.set("index.jexl.filter", "doc.lang=='en'");    JexlIndexingFilter filter = new JexlIndexingFilter();    filter.setConf(conf);    Assert.assertNotNull(filter);    NutchDocument doc = new NutchDocument();    String title = "The Foo Page";    Outlink[] outlinks = new Outlink[] { new Outlink("http://foo.com/", "Foo") };    Metadata metaData = new Metadata();    metaData.add("Language", "en/us");    ParseData parseData = new ParseData(ParseStatus.STATUS_SUCCESS, title, outlinks, metaData);    ParseImpl parse = new ParseImpl("this is a sample foo bar page. hope you enjoy it.", parseData);    CrawlDatum crawlDatum = new CrawlDatum();    crawlDatum.setFetchTime(100L);    Inlinks inlinks = new Inlinks();    doc.add("lang", "en");    NutchDocument result = filter.filter(doc, parse, new Text("http://nutch.apache.org/index.html"), crawlDatum, inlinks);    Assert.assertNotNull(result);    Assert.assertEquals(doc, result);}
eccfa812a678c6da46dd065c25566cf3d55cc1efb8f0e1a15272dfbc3f88816e
testBlockNotMatchingDocuments
public void testBlockNotMatchingDocuments() throws Exception
{    Configuration conf = NutchConfiguration.create();    conf.set("index.jexl.filter", "doc.lang=='en'");    JexlIndexingFilter filter = new JexlIndexingFilter();    filter.setConf(conf);    Assert.assertNotNull(filter);    NutchDocument doc = new NutchDocument();    String title = "The Foo Page";    Outlink[] outlinks = new Outlink[] { new Outlink("http://foo.com/", "Foo") };    Metadata metaData = new Metadata();    metaData.add("Language", "en/us");    ParseData parseData = new ParseData(ParseStatus.STATUS_SUCCESS, title, outlinks, metaData);    ParseImpl parse = new ParseImpl("this is a sample foo bar page. hope you enjoy it.", parseData);    CrawlDatum crawlDatum = new CrawlDatum();    crawlDatum.setFetchTime(100L);    Inlinks inlinks = new Inlinks();    doc.add("lang", "ru");    NutchDocument result = filter.filter(doc, parse, new Text("http://nutch.apache.org/index.html"), crawlDatum, inlinks);    Assert.assertNull(result);}
90b6e47168afa11356b32f153d223e443f23ada91d4d0cb95f97772c923196c6
testMissingConfiguration
public void testMissingConfiguration() throws Exception
{    Configuration conf = NutchConfiguration.create();    JexlIndexingFilter filter = new JexlIndexingFilter();    thrown.expect(RuntimeException.class);    filter.setConf(conf);}
603eae0b8732f5b83d6e93ccffa5a572a47923dd1033916772fda7eb406d1a85
testInvalidExpression
public void testInvalidExpression() throws Exception
{    Configuration conf = NutchConfiguration.create();    conf.set("index.jexl.filter", "doc.lang=<>:='en'");    JexlIndexingFilter filter = new JexlIndexingFilter();    thrown.expect(RuntimeException.class);    filter.setConf(conf);}
8fa98404280fecfd497ce9400c07196998fbeaf2ee8524779c09bd3c220d4ea9
filter
public NutchDocument filter(NutchDocument doc, Parse parse, Text url, CrawlDatum datum, Inlinks inlinks) throws IndexingException
{        Outlink[] outlinks = parse.getData().getOutlinks();    if (outlinks != null) {        Set<String> hosts = new HashSet<String>();        for (Outlink outlink : outlinks) {            try {                String linkUrl = outlink.getToUrl();                String outHost = new URL(linkUrl).getHost().toLowerCase();                if (indexHost) {                    linkUrl = outHost;                    if (hosts.contains(linkUrl))                        continue;                    hosts.add(linkUrl);                }                addFilteredLink("outlinks", url.toString(), linkUrl, outHost, filterOutlinks, doc);            } catch (MalformedURLException e) {                LOG.error("Malformed URL in {}: {}", url, e.getMessage());            }        }    }        if (null != inlinks) {        Iterator<Inlink> iterator = inlinks.iterator();        Set<String> inlinkHosts = new HashSet<String>();        while (iterator.hasNext()) {            try {                Inlink link = iterator.next();                String linkUrl = link.getFromUrl();                String inHost = new URL(linkUrl).getHost().toLowerCase();                if (indexHost) {                    linkUrl = inHost;                    if (inlinkHosts.contains(linkUrl))                        continue;                    inlinkHosts.add(linkUrl);                }                addFilteredLink("inlinks", url.toString(), linkUrl, inHost, filterInlinks, doc);            } catch (MalformedURLException e) {                LOG.error("Malformed URL in {}: {}", url, e.getMessage());            }        }    }    return doc;}
39d8696d3997007429eff210dd549ce089eae3fa3bb9cdd730e0c110b0db506d
addFilteredLink
private void addFilteredLink(String fieldName, String url, String linkUrl, String urlHost, boolean filter, NutchDocument doc) throws MalformedURLException
{    if (filter) {        String host = new URL(url.toString()).getHost().toLowerCase();        if (!host.equalsIgnoreCase(urlHost)) {            doc.add(fieldName, linkUrl);        }    } else {        doc.add(fieldName, linkUrl);    }}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    filterOutlinks = conf.getBoolean(LINKS_OUTLINKS_HOST, false);    filterInlinks = conf.getBoolean(LINKS_INLINKS_HOST, false);    indexHost = conf.getBoolean(LINKS_ONLY_HOSTS, false);}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    metadata.add(Response.CONTENT_TYPE, "text/html");}
c826ae9abdf83c4c8944b3e0bd1de5012fc531caaed1231ba9da7b74557eeeed
generateOutlinks
private Outlink[] generateOutlinks() throws Exception
{    return generateOutlinks(false);}
11733066aaaf012cba183b508e31d6b5802b5786404b1042ed31f71c767ad97e
generateOutlinks
private Outlink[] generateOutlinks(boolean parts) throws Exception
{    Outlink[] outlinks = new Outlink[2];    outlinks[0] = new Outlink("http://www.test.com", "test");    outlinks[1] = new Outlink("http://www.example.com", "example");    if (parts) {        outlinks[0] = new Outlink(outlinks[0].getToUrl() + "/index.php?param=1", "test");        outlinks[1] = new Outlink(outlinks[1].getToUrl() + "/index.php?param=2", "test");    }    return outlinks;}
a486c3e9d3d12f4bcdf170fba17443024e9c9fff4580610732c727fa35b516d6
testFilterOutlinks
public void testFilterOutlinks() throws Exception
{    conf.set(LinksIndexingFilter.LINKS_OUTLINKS_HOST, "true");    filter.setConf(conf);    Outlink[] outlinks = generateOutlinks();    NutchDocument doc = filter.filter(new NutchDocument(), new ParseImpl("text", new ParseData(new ParseStatus(), "title", outlinks, metadata)), new Text("http://www.example.com/"), new CrawlDatum(), new Inlinks());    Assert.assertEquals(1, doc.getField("outlinks").getValues().size());    Assert.assertEquals("Filter outlinks, allow only those from a different host", outlinks[0].getToUrl(), doc.getFieldValue("outlinks"));}
db95554dcf73f41a77d7e8a0ac98dd21329c385c34eb4cca0517d0f160e7e0e7
testFilterInlinks
public void testFilterInlinks() throws Exception
{    conf.set(LinksIndexingFilter.LINKS_INLINKS_HOST, "true");    filter.setConf(conf);    Inlinks inlinks = new Inlinks();    inlinks.add(new Inlink("http://www.test.com", "test"));    inlinks.add(new Inlink("http://www.example.com", "example"));    NutchDocument doc = filter.filter(new NutchDocument(), new ParseImpl("text", new ParseData(new ParseStatus(), "title", new Outlink[0], metadata)), new Text("http://www.example.com/"), new CrawlDatum(), inlinks);    Assert.assertEquals(1, doc.getField("inlinks").getValues().size());    Assert.assertEquals("Filter inlinks, allow only those from a different host", "http://www.test.com", doc.getFieldValue("inlinks"));}
257fcd6b952a1b18dfb664b78bfb09298a8f2f8d63bff654926e5c15679590ec
testNoFilterOutlinks
public void testNoFilterOutlinks() throws Exception
{    filter.setConf(conf);    Outlink[] outlinks = generateOutlinks();    NutchDocument doc = filter.filter(new NutchDocument(), new ParseImpl("text", new ParseData(new ParseStatus(), "title", outlinks, metadata)), new Text("http://www.example.com/"), new CrawlDatum(), new Inlinks());    Assert.assertEquals("All outlinks must be indexed even those from the same host", outlinks.length, doc.getField("outlinks").getValues().size());}
07d63d5d732f616ed5495dc3e5deb1a99e10a918b7db7d4b079a463644bde3dc
testNoFilterInlinks
public void testNoFilterInlinks() throws Exception
{    conf.set(LinksIndexingFilter.LINKS_INLINKS_HOST, "false");    filter.setConf(conf);    Inlinks inlinks = new Inlinks();    inlinks.add(new Inlink("http://www.test.com", "test"));    inlinks.add(new Inlink("http://www.example.com", "example"));    NutchDocument doc = filter.filter(new NutchDocument(), new ParseImpl("text", new ParseData(new ParseStatus(), "title", new Outlink[0], metadata)), new Text("http://www.example.com/"), new CrawlDatum(), inlinks);    Assert.assertEquals("All inlinks must be indexed even those from the same host", inlinks.size(), doc.getField("inlinks").getValues().size());}
791e362efd0c41af99bb64320b980033a58acdd26026718e98130a737cc268ad
testIndexOnlyHostPart
public void testIndexOnlyHostPart() throws Exception
{    conf.set(LinksIndexingFilter.LINKS_INLINKS_HOST, "true");    conf.set(LinksIndexingFilter.LINKS_OUTLINKS_HOST, "true");    conf.set(LinksIndexingFilter.LINKS_ONLY_HOSTS, "true");    filter.setConf(conf);    Outlink[] outlinks = generateOutlinks(true);    Inlinks inlinks = new Inlinks();    inlinks.add(new Inlink("http://www.test.com/one-awesome-page", "test"));    inlinks.add(new Inlink("http://www.test.com/other-awesome-page", "test"));    inlinks.add(new Inlink("http://www.example.com/my-first-awesome-example", "example"));    NutchDocument doc = filter.filter(new NutchDocument(), new ParseImpl("text", new ParseData(new ParseStatus(), "title", outlinks, metadata)), new Text("http://www.example.com/"), new CrawlDatum(), inlinks);    NutchField docOutlinks = doc.getField("outlinks");    Assert.assertEquals("Only the host portion of the outlink URL must be indexed", new URL("http://www.test.com").getHost(), docOutlinks.getValues().get(0));    Assert.assertEquals("The inlinks coming from the same host must count only once", 1, doc.getField("inlinks").getValues().size());    Assert.assertEquals("Only the host portion of the inlinks URL must be indexed", new URL("http://www.test.com").getHost(), doc.getFieldValue("inlinks"));}
586577c3f8403e7228801026608f89e36989fd99e2410a5796534eea0a6a61b1
testIndexHostsOnlyAndFilterOutlinks
public void testIndexHostsOnlyAndFilterOutlinks() throws Exception
{    conf = NutchConfiguration.create();    conf.set(LinksIndexingFilter.LINKS_ONLY_HOSTS, "true");    conf.set(LinksIndexingFilter.LINKS_OUTLINKS_HOST, "true");    Outlink[] outlinks = generateOutlinks(true);    filter.setConf(conf);    NutchDocument doc = filter.filter(new NutchDocument(), new ParseImpl("text", new ParseData(new ParseStatus(), "title", outlinks, metadata)), new Text("http://www.example.com/"), new CrawlDatum(), new Inlinks());    Assert.assertEquals(1, doc.getField("outlinks").getValues().size());    Assert.assertEquals("Index only the host portion of the outlinks after filtering", new URL("http://www.test.com").getHost(), doc.getFieldValue("outlinks"));}
43c3d3bb5d2cadf18f8f47a89f2e4120458d3b70df846feb0ce17e3d6ab16a40
testIndexHostsOnlyAndFilterInlinks
public void testIndexHostsOnlyAndFilterInlinks() throws Exception
{    conf = NutchConfiguration.create();    conf.set(LinksIndexingFilter.LINKS_ONLY_HOSTS, "true");    conf.set(LinksIndexingFilter.LINKS_INLINKS_HOST, "true");    filter.setConf(conf);    Inlinks inlinks = new Inlinks();    inlinks.add(new Inlink("http://www.test.com", "test"));    inlinks.add(new Inlink("http://www.example.com", "example"));    NutchDocument doc = filter.filter(new NutchDocument(), new ParseImpl("text", new ParseData(new ParseStatus(), "title", new Outlink[0], metadata)), new Text("http://www.example.com/"), new CrawlDatum(), inlinks);    Assert.assertEquals(1, doc.getField("inlinks").getValues().size());    Assert.assertEquals("Index only the host portion of the inlinks after filtering", new URL("http://www.test.com").getHost(), doc.getFieldValue("inlinks"));}
8fa98404280fecfd497ce9400c07196998fbeaf2ee8524779c09bd3c220d4ea9
filter
public NutchDocument filter(NutchDocument doc, Parse parse, Text url, CrawlDatum datum, Inlinks inlinks) throws IndexingException
{        if (doc == null)        return doc;        if (dbFieldnames != null) {        for (String metatag : dbFieldnames) {            Writable metadata = datum.getMetaData().get(new Text(metatag));            if (metadata != null)                add(doc, metatag, metadata.toString());        }    }        if (parseFieldnames != null) {        for (String metatag : parseFieldnames.keySet()) {            for (String value : parse.getData().getParseMeta().getValues(metatag)) {                if (value != null)                    add(doc, parseFieldnames.get(metatag), value);            }        }    }        if (contentFieldnames != null) {        for (String metatag : contentFieldnames) {            for (String value : parse.getData().getContentMeta().getValues(metatag)) {                if (value != null)                    add(doc, metatag, value);            }        }    }    return doc;}
29905e53f241ddead7a433e321ba83122c4d512a883b9e28cefc5aaa30ef4d06
add
protected void add(NutchDocument doc, String key, String value)
{    if (separator == null || value.indexOf(separator) == -1 || !mvFields.contains(key)) {        value = value.trim();        if (!value.isEmpty()) {            doc.add(key, value);        }    } else {        String[] parts = value.split(separator);        for (String part : parts) {            part = part.trim();            if (!part.isEmpty()) {                doc.add(key, part);            }        }    }}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    dbFieldnames = conf.getStrings(db_CONF_PROPERTY);    parseFieldnames = new HashMap<String, String>();    for (String metatag : conf.getStrings(parse_CONF_PROPERTY)) {        parseFieldnames.put(metatag.toLowerCase(Locale.ROOT), metatag);    }    contentFieldnames = conf.getStrings(content_CONF_PROPERTY);    separator = conf.get(separator_CONF_PROPERTY, null);    mvFields = new HashSet(Arrays.asList(conf.getStrings(mvfields_CONF_PROPERTY, new String[0])));}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
8fa98404280fecfd497ce9400c07196998fbeaf2ee8524779c09bd3c220d4ea9
filter
public NutchDocument filter(NutchDocument doc, Parse parse, Text url, CrawlDatum datum, Inlinks inlinks) throws IndexingException
{    String url_s = url.toString();    addTime(doc, parse.getData(), url_s, datum);    addLength(doc, parse.getData(), url_s);    addType(doc, parse.getData(), url_s, datum);    resetTitle(doc, parse.getData(), url_s);    return doc;}
ecad7914f098beefda73ecc5bfeeeef78965dd63cbeefb9d03dc75b67094d0eb
addTime
private NutchDocument addTime(NutchDocument doc, ParseData data, String url, CrawlDatum datum)
{    long time = -1;    String lastModified = data.getMeta(Metadata.LAST_MODIFIED);    if (lastModified != null) {                        time = getTime(lastModified, url);                if (time > -1) {            doc.add("lastModified", new Date(time));        }    }    if (time == -1) {                        time = datum.getModifiedTime();        if (time <= 0) {                                    time = datum.getFetchTime();                }    }        doc.add("date", new Date(time));    return doc;}
df3064d96d7b49ddf03bb225f937aaf1bde4183f00f145dd182db78e367394f9
getTime
private long getTime(String date, String url)
{    long time = -1;    try {        time = HttpDateFormat.toLong(date);    } catch (ParseException e) {                try {            Date parsedDate = DateUtils.parseDate(date, new String[] { "EEE MMM dd HH:mm:ss yyyy", "EEE MMM dd HH:mm:ss yyyy zzz", "EEE MMM dd HH:mm:ss zzz yyyy", "EEE, MMM dd HH:mm:ss yyyy zzz", "EEE, dd MMM yyyy HH:mm:ss zzz", "EEE,dd MMM yyyy HH:mm:ss zzz", "EEE, dd MMM yyyy HH:mm:sszzz", "EEE, dd MMM yyyy HH:mm:ss", "EEE, dd-MMM-yy HH:mm:ss zzz", "yyyy/MM/dd HH:mm:ss.SSS zzz", "yyyy/MM/dd HH:mm:ss.SSS", "yyyy/MM/dd HH:mm:ss zzz", "yyyy/MM/dd", "yyyy.MM.dd HH:mm:ss", "yyyy-MM-dd HH:mm", "MMM dd yyyy HH:mm:ss. zzz", "MMM dd yyyy HH:mm:ss zzz", "dd.MM.yyyy HH:mm:ss zzz", "dd MM yyyy HH:mm:ss zzz", "dd.MM.yyyy; HH:mm:ss", "dd.MM.yyyy HH:mm:ss", "dd.MM.yyyy zzz", "yyyy-MM-dd'T'HH:mm:ssXXX" });            time = parsedDate.getTime();                                } catch (Exception e2) {            if (LOG.isWarnEnabled()) {                LOG.warn(url + ": can't parse erroneous date: " + date);            }        }    }    return time;}
1a0b9e1c0ec46047f0bed646832536c8b29168ebce1dac6e85c25d852e453fbb
addLength
private NutchDocument addLength(NutchDocument doc, ParseData data, String url)
{    String contentLength = data.getMeta(Response.CONTENT_LENGTH);    if (contentLength != null) {                String trimmed = contentLength.toString().trim();        if (!trimmed.isEmpty())            doc.add("contentLength", trimmed);    }    return doc;}
0c9e0d9d3ff15e49f319eb860efc6a6f1c89ac245bb7d476f72192cfccdf4441
addType
private NutchDocument addType(NutchDocument doc, ParseData data, String url, CrawlDatum datum)
{    String mimeType = null;    String contentType = null;    Writable tcontentType = datum.getMetaData().get(new Text(Response.CONTENT_TYPE));    if (tcontentType != null) {        contentType = tcontentType.toString();    } else        contentType = data.getMeta(Response.CONTENT_TYPE);    if (contentType == null) {                                                                                                mimeType = tika.detect(url);    } else {        mimeType = MIME.forName(MimeUtil.cleanMimeType(contentType));    }        if (mimeType == null) {        return doc;    }        if (mapMimes) {                if (mimeMap.containsKey(mimeType)) {            if (mapFieldName != null) {                doc.add(mapFieldName, mimeMap.get(mimeType));            } else {                mimeType = mimeMap.get(mimeType);            }        }    }    contentType = mimeType;    doc.add("type", contentType);        if (conf.getBoolean("moreIndexingFilter.indexMimeTypeParts", true)) {        String[] parts = getParts(contentType);        for (String part : parts) {            doc.add("type", part);        }    }    return doc;}
57c521569a3dee6e729c2a1c0c8c041a976a7c10ee7e4bc980f78524131f1325
getParts
 static String[] getParts(String mimeType)
{    return mimeType.split("/");}
5aaf1ce73bc031ed9426bfaaaf4a58b8605f1b03bca02dee49aa68bc253e48dd
resetTitle
private NutchDocument resetTitle(NutchDocument doc, ParseData data, String url)
{    String contentDisposition = data.getMeta(Metadata.CONTENT_DISPOSITION);    if (contentDisposition == null || doc.getFieldValue("title") != null)        return doc;    for (int i = 0; i < patterns.length; i++) {        Matcher matcher = patterns[i].matcher(contentDisposition);        if (matcher.find()) {            doc.add("title", matcher.group(1));            break;        }    }    return doc;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    MIME = new MimeUtil(conf);    if (conf.getBoolean("moreIndexingFilter.mapMimeTypes", false)) {        mapMimes = true;        mapFieldName = conf.get("moreIndexingFilter.mapMimeTypes.field");                try {            readConfiguration();        } catch (Exception e) {            LOG.error(org.apache.hadoop.util.StringUtils.stringifyException(e));        }    }}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
46ba285da6dce650365e84a47e8231826e7a3e9cdb7741af5b11ec2f202ed9c9
readConfiguration
private void readConfiguration() throws IOException
{    LOG.info("Reading content type mappings from file contenttype-mapping.txt");    BufferedReader reader = new BufferedReader(conf.getConfResourceAsReader("contenttype-mapping.txt"));    String line;    String[] parts;    boolean formatWarningShown = false;    mimeMap = new HashMap<String, String>();    while ((line = reader.readLine()) != null) {        if (StringUtils.isNotBlank(line) && !line.startsWith("#")) {            line = line.trim();            parts = line.split("\t");                        if (parts.length > 1) {                for (int i = 1; i < parts.length; i++) {                    mimeMap.put(parts[i].trim(), parts[0].trim());                }            } else {                LOG.warn("Wrong format of line: {}", line);                if (!formatWarningShown) {                    LOG.warn("Expected format: <target type> <tab> <type1> [<tab> <type2> ...]");                    formatWarningShown = true;                }            }        }    }}
a90351cd4e53e86b3610ea3d53b7825f994ca67399c751ed13563a8a8cb4f287
testContentType
public void testContentType() throws IndexingException
{    Configuration conf = NutchConfiguration.create();    assertContentType(conf, "text/html", "text/html");    assertContentType(conf, "text/html; charset=UTF-8", "text/html");}
4ede6b95424931cab6fdca49f30ff18925feaa2d4b34312f9d5a76a6e5cfe45e
testGetParts
public void testGetParts()
{    String[] parts = MoreIndexingFilter.getParts("text/html");    assertParts(parts, 2, "text", "html");}
061ad2c44166c503a4a4bf6f725d288f8c1003827551747c7e70c3a38c5108b6
testNoParts
public void testNoParts()
{    Configuration conf = NutchConfiguration.create();    conf.setBoolean("moreIndexingFilter.indexMimeTypeParts", false);    MoreIndexingFilter filter = new MoreIndexingFilter();    filter.setConf(conf);    Assert.assertNotNull(filter);    NutchDocument doc = new NutchDocument();    ParseImpl parse = new ParseImpl("foo bar", new ParseData());    try {        filter.filter(doc, parse, new Text("http://nutch.apache.org/index.html"), new CrawlDatum(), new Inlinks());    } catch (Exception e) {        e.printStackTrace();        Assert.fail(e.getMessage());    }    Assert.assertNotNull(doc);    Assert.assertTrue(doc.getFieldNames().contains("type"));    Assert.assertEquals(1, doc.getField("type").getValues().size());    Assert.assertEquals("text/html", doc.getFieldValue("type"));}
2e661cd311ba3a4666fa0b2af9db844d69eca276718d3ac839bb36f848c10b8b
testContentDispositionTitle
public void testContentDispositionTitle() throws IndexingException
{    Configuration conf = NutchConfiguration.create();    Metadata metadata = new Metadata();    metadata.add(Response.CONTENT_DISPOSITION, "filename=filename.ext");    MoreIndexingFilter filter = new MoreIndexingFilter();    filter.setConf(conf);    Text url = new Text("http://www.example.com/");    ParseImpl parseImpl = new ParseImpl("text", new ParseData(new ParseStatus(), "title", new Outlink[0], metadata));    NutchDocument doc = new NutchDocument();    doc = filter.filter(doc, parseImpl, url, new CrawlDatum(), new Inlinks());    Assert.assertEquals("content-disposition not detected", "filename.ext", doc.getFieldValue("title"));    /* NUTCH-1140: do not add second title to avoid a multi-valued title field */    doc = new NutchDocument();    doc.add("title", "title");    doc = filter.filter(doc, parseImpl, url, new CrawlDatum(), new Inlinks());    Assert.assertEquals("do not add second title by content-disposition", "title", doc.getFieldValue("title"));}
f73e28fc1e9f32e9304f69a67c06aee2c79f35c6470b96b5c57bb8c77f6c8e52
assertParts
private void assertParts(String[] parts, int count, String... expected)
{    Assert.assertEquals(count, parts.length);    for (int i = 0; i < expected.length; i++) {        Assert.assertEquals(expected[i], parts[i]);    }}
08f2d49a32025e64dd089671480a0b6689f6f18935d5e0663617edba1943086e
assertContentType
private void assertContentType(Configuration conf, String source, String expected) throws IndexingException
{    Metadata metadata = new Metadata();    metadata.add(Response.CONTENT_TYPE, source);    MoreIndexingFilter filter = new MoreIndexingFilter();    filter.setConf(conf);    NutchDocument doc = filter.filter(new NutchDocument(), new ParseImpl("text", new ParseData(new ParseStatus(), "title", new Outlink[0], metadata)), new Text("http://www.example.com/"), new CrawlDatum(), new Inlinks());    Assert.assertEquals("mime type not detected", expected, doc.getFieldValue("type"));}
62c3ff028058cc8d55a8c618376e6ef7059aa68ea8adca0b177a4375a66e25c9
testDates
public void testDates() throws IndexingException
{    Configuration conf = NutchConfiguration.create();    Metadata metadata = new Metadata();    MoreIndexingFilter filter = new MoreIndexingFilter();    filter.setConf(conf);    Text url = new Text("http://www.example.com/");    ParseImpl parseImpl = new ParseImpl("text", new ParseData(new ParseStatus(), "title", new Outlink[0], metadata));    CrawlDatum fetchDatum = new CrawlDatum();    NutchDocument doc = new NutchDocument();        long dateEpocheSeconds = 1537898340;    fetchDatum.setModifiedTime(dateEpocheSeconds * 1000);        fetchDatum.setFetchTime((dateEpocheSeconds + 30 * 24 * 60 * 60) * 1000);                doc = filter.filter(doc, parseImpl, url, fetchDatum, new Inlinks());    Assert.assertEquals("last fetch date not extracted", new Date(dateEpocheSeconds * 1000), doc.getFieldValue("date"));        Date lastModifiedDate = new Date((dateEpocheSeconds - 7 * 24 * 60 * 60) * 1000);    String lastModifiedDateStr = DateTimeFormatter.ISO_INSTANT.format(lastModifiedDate.toInstant());    parseImpl.getData().getParseMeta().set(Metadata.LAST_MODIFIED, lastModifiedDateStr);    doc = filter.filter(doc, parseImpl, url, fetchDatum, new Inlinks());    Assert.assertEquals("last-modified date not extracted", lastModifiedDate, doc.getFieldValue("lastModified"));}
68f4afd0e3cff42097dd5b6508fea1f7952d6d93f52ded3c1deea7186fff780c
getFieldName
public String getFieldName()
{    return this.fieldName;}
5e0db3b98deb5050b0f57fdd2bd0ec60bb989f119d3a5ae34a9b9b3681499b09
getToFieldName
public String getToFieldName()
{    return this.toFieldName;}
8978247cd0d17dd138c974d3be56e5bc8d59405bedad02e9acdd0c16b9463f37
getPattern
public Pattern getPattern()
{    return this.pattern;}
83a08927d2f741517473e6492ca3bf73abbd86d510603dfd729ef2f8f214fa3a
getReplacement
public String getReplacement()
{    return this.replacement;}
5d7e7426cc3979089b19a726ac0ddfcf063e2e361e313de81396724c2e017b02
isValid
public boolean isValid()
{    return this.isValid;}
c1829d5ac581cd32daacd424b15b4aeba351c733004aac97f4b7e34399a3a5a3
replace
public String replace(String value)
{    if (this.isValid) {        return this.pattern.matcher(value).replaceAll(replacement);    } else {        return value;    }}
173a9acee915a08586ff45f0c15acc8dfff1be32a234f69520647df8176abc89
checkAndReplace
public String checkAndReplace(String fieldName, String value)
{    if (this.fieldName.equals(fieldName)) {        if (value != null && value.length() > 0) {            if (this.isValid) {                Matcher m = this.pattern.matcher(value);                if (m.find()) {                    return m.replaceAll(this.replacement);                }            }        }    }    return null;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    FIELDREPLACERS_BY_HOST.clear();    FIELDREPLACERS_BY_URL.clear();    String value = conf.get("index.replace.regexp", null);    if (value != null) {        LOG.debug("Parsing index.replace.regexp property");        this.parseConf(value);    }}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
b20a85b7ae20c638cf35df1ffb46df8fa73bd8fa335ffea853568318930a7230
parseConf
private void parseConf(String propertyValue)
{    if (propertyValue == null || propertyValue.trim().length() == 0) {        return;    }        Pattern hostPattern = Pattern.compile(".*");    Pattern urlPattern = null;        Matcher lineMatcher = LINE_SPLIT.matcher(propertyValue);    while (lineMatcher.find()) {        String line = lineMatcher.group();        if (line != null && line.length() > 0) {                        Matcher nameValueMatcher = NAME_VALUE_SPLIT.matcher(line.trim());            if (nameValueMatcher.find()) {                String fieldName = nameValueMatcher.group(1).trim();                String value = nameValueMatcher.group(2);                if (fieldName != null && value != null) {                                        if (HOSTMATCH.equals(fieldName)) {                        urlPattern = null;                        try {                            hostPattern = Pattern.compile(value);                        } catch (PatternSyntaxException pse) {                            LOG.error("hostmatch pattern " + value + " does not compile: " + pse.getMessage());                                                        hostPattern = Pattern.compile("willnotmatchanyhost");                        }                    } else if (URLMATCH.equals(fieldName)) {                        try {                            urlPattern = Pattern.compile(value);                        } catch (PatternSyntaxException pse) {                            LOG.error("urlmatch pattern " + value + " does not compile: " + pse.getMessage());                                                        urlPattern = Pattern.compile("willnotmatchanyurl");                        }                    } else if (value.length() > 3) {                        String toFieldName = fieldName;                                                if (fieldName.indexOf(':') > 0) {                            toFieldName = fieldName.substring(fieldName.indexOf(':') + 1);                            fieldName = fieldName.substring(0, fieldName.indexOf(':'));                        }                        String sep = value.substring(0, 1);                                                value = value.substring(1);                        if (!value.contains(sep)) {                            LOG.error("Pattern '" + line + "', not parseable.  Missing separator " + sep);                            continue;                        }                        String pattern = value.substring(0, value.indexOf(sep));                        value = value.substring(pattern.length() + 1);                        String replacement = value;                        if (value.contains(sep)) {                            replacement = value.substring(0, value.indexOf(sep));                        }                        int flags = 0;                        if (value.length() > replacement.length() + 1) {                            value = value.substring(replacement.length() + 1).trim();                            try {                                flags = Integer.parseInt(value);                            } catch (NumberFormatException e) {                                LOG.error("Pattern " + line + ", has invalid flags component");                                continue;                            }                        }                        Integer iFlags = (flags > 0) ? Integer.valueOf(flags) : null;                                                FieldReplacer fr = new FieldReplacer(fieldName, toFieldName, pattern, replacement, iFlags);                                                if (urlPattern != null) {                            List<FieldReplacer> lfp = FIELDREPLACERS_BY_URL.get(urlPattern);                            if (lfp == null) {                                lfp = new ArrayList<FieldReplacer>();                            }                            lfp.add(fr);                            FIELDREPLACERS_BY_URL.put(urlPattern, lfp);                        } else {                            List<FieldReplacer> lfp = FIELDREPLACERS_BY_HOST.get(hostPattern);                            if (lfp == null) {                                lfp = new ArrayList<FieldReplacer>();                            }                            lfp.add(fr);                            FIELDREPLACERS_BY_HOST.put(hostPattern, lfp);                        }                    }                }            }        }    }}
8fa98404280fecfd497ce9400c07196998fbeaf2ee8524779c09bd3c220d4ea9
filter
public NutchDocument filter(NutchDocument doc, Parse parse, Text url, CrawlDatum datum, Inlinks inlinks) throws IndexingException
{    if (doc != null) {        if (FIELDREPLACERS_BY_HOST.size() > 0) {            this.doReplace(doc, "host", FIELDREPLACERS_BY_HOST);        }        if (FIELDREPLACERS_BY_URL.size() > 0) {            this.doReplace(doc, "url", FIELDREPLACERS_BY_URL);        }    }    return doc;}
4c5193dc1cbcf989d159c9ca95d709a7cb5cf9b96dc2023fbd2a391c975f69d2
doReplace
private void doReplace(NutchDocument doc, String keyName, Map<Pattern, List<FieldReplacer>> replaceMap)
{    if (doc == null || replaceMap.size() == 0) {        return;    }    Collection<String> docFieldNames = doc.getFieldNames();    NutchField keyField = doc.getField(keyName);    if (keyField == null) {                return;    }    List<Object> keyFieldValues = keyField.getValues();    if (keyFieldValues.size() == 0) {                return;    }        for (Object oKeyFieldValue : keyFieldValues) {        if (oKeyFieldValue != null && oKeyFieldValue instanceof java.lang.String) {            String keyFieldValue = (String) oKeyFieldValue;                        for (Map.Entry<Pattern, List<FieldReplacer>> entries : replaceMap.entrySet()) {                                if (entries.getKey().matcher(keyFieldValue).find()) {                                        for (FieldReplacer fp : entries.getValue()) {                        String fieldName = fp.getFieldName();                                                if (docFieldNames.contains(fieldName)) {                            NutchField docField = doc.getField(fieldName);                            List<Object> fieldValues = docField.getValues();                            ArrayList<String> newFieldValues = new ArrayList<String>();                                                        for (Object oFieldValue : fieldValues) {                                if (oFieldValue != null && oFieldValue instanceof java.lang.String) {                                    String fieldValue = (String) oFieldValue;                                    String newValue = fp.replace(fieldValue);                                    newFieldValues.add(newValue);                                }                            }                                                        String targetFieldName = fp.getToFieldName();                            doc.removeField(targetFieldName);                            for (String newFieldValue : newFieldValues) {                                doc.add(targetFieldName, newFieldValue);                            }                        }                    }                }            }        }    }}
3e0ad503aae27ecd2303f1cac08f46774cc683887c1b0641028a4d6a1bca5c92
parseAndFilterFile
public NutchDocument parseAndFilterFile(String fileName, Configuration conf)
{    NutchDocument doc = new NutchDocument();    BasicIndexingFilter basicIndexer = new BasicIndexingFilter();    basicIndexer.setConf(conf);    Assert.assertNotNull(basicIndexer);    MetadataIndexer metaIndexer = new MetadataIndexer();    metaIndexer.setConf(conf);    Assert.assertNotNull(basicIndexer);    ReplaceIndexer replaceIndexer = new ReplaceIndexer();    replaceIndexer.setConf(conf);    Assert.assertNotNull(replaceIndexer);    try {        String urlString = "file:" + sampleDir + fileSeparator + fileName;        Text text = new Text(urlString);        CrawlDatum crawlDatum = new CrawlDatum();        Protocol protocol = new ProtocolFactory(conf).getProtocol(urlString);        Content content = protocol.getProtocolOutput(text, crawlDatum).getContent();        Parse parse = new ParseUtil(conf).parse(content).get(content.getUrl());        crawlDatum.setFetchTime(100L);        Inlinks inlinks = new Inlinks();        doc = basicIndexer.filter(doc, parse, text, crawlDatum, inlinks);        doc = metaIndexer.filter(doc, parse, text, crawlDatum, inlinks);        doc = replaceIndexer.filter(doc, parse, text, crawlDatum, inlinks);    } catch (Exception e) {        e.printStackTrace();        Assert.fail(e.toString());    }    return doc;}
fcbb74b5a571a3b3e6738557c51d49dae561572b29205b7dc8dd75dd4800a268
testPropertyParse
public void testPropertyParse()
{    Configuration conf = NutchConfiguration.create();    String indexReplaceProperty = "  metatag.description=/this(.*)plugin/this awesome plugin/2\n" + "  metatag.keywords=/\\,/\\!/\n" + "  hostmatch=.*.com\n" + "  metatag.keywords=/\\,/\\?/\n" + "  metatag.author:dc_author=/\\s+/ David /\n" + "  urlmatch=.*.html\n" + "  metatag.keywords=/\\,/\\./\n" + "  metatag.author=/\\s+/ D. /\n";    conf.set(INDEX_REPLACE_PROPERTY, indexReplaceProperty);    ReplaceIndexer rp = new ReplaceIndexer();    try {        rp.setConf(conf);    } catch (RuntimeException ohno) {        Assert.fail("Unable to parse a valid index.replace.regexp property! " + ohno.getMessage());    }    Configuration parsedConf = rp.getConf();        Assert.assertEquals(indexReplaceProperty, parsedConf.get(INDEX_REPLACE_PROPERTY));}
5c71fffaae83b93207473408d61f820c5ea352e6c0a8bbb5502b15b1577cc735
testGlobalReplacement
public void testGlobalReplacement()
{    String expectedDescription = "With this awesome plugin, I control the description! Bwuhuhuhaha!";    String expectedKeywords = "Breathtaking! Riveting! Two Thumbs Up!";    String expectedAuthor = "Peter D. Ciuffetti";    String indexReplaceProperty = "  metatag.description=/this(.*)plugin/this awesome plugin/\n" + "  metatag.keywords=/\\,/\\!/\n" + "  metatag.author=/\\s+/ D. /\n";    Configuration conf = NutchConfiguration.create();    conf.set("plugin.includes", "protocol-file|urlfilter-regex|parse-(html|metatags)|index-(basic|anchor|metadata|static|replace)|urlnormalizer-(pass|regex|basic)");    conf.set(INDEX_REPLACE_PROPERTY, indexReplaceProperty);    conf.set("metatags.names", "author,description,keywords");    conf.set("index.parse.md", "metatag.author,metatag.description,metatag.keywords");        conf.set("http.timeout", "99999999999");        NutchDocument doc = parseAndFilterFile(sampleFile, conf);    Assert.assertEquals(expectedDescription, doc.getFieldValue("metatag.description"));    Assert.assertEquals(expectedKeywords, doc.getFieldValue("metatag.keywords"));    Assert.assertEquals(expectedAuthor, doc.getFieldValue("metatag.author"));}
745e586a0327c8adbb596d7e94c7cfa843ab47f9d6bf6fc8986956b690595c18
testInvalidPatterns
public void testInvalidPatterns()
{    String expectedDescription = "With this plugin, I control the description! Bwuhuhuhaha!";    String expectedKeywords = "Breathtaking, Riveting, Two Thumbs Up!";    String expectedAuthor = "Peter Ciuffetti";        String indexReplaceProperty = "  metatag.description=/this\\s+**plugin/this awesome plugin/\n" + "  metatag.keywords=/\\,/\\!/what\n" + " metatag.author=#notcomplete";    Configuration conf = NutchConfiguration.create();    conf.set("plugin.includes", "protocol-file|urlfilter-regex|parse-(html|metatags)|index-(basic|anchor|metadata|static|replace)|urlnormalizer-(pass|regex|basic)");    conf.set(INDEX_REPLACE_PROPERTY, indexReplaceProperty);    conf.set("metatags.names", "author,description,keywords");    conf.set("index.parse.md", "metatag.author,metatag.description,metatag.keywords");        conf.set("http.timeout", "99999999999");        NutchDocument doc = parseAndFilterFile(sampleFile, conf);        Assert.assertEquals(expectedDescription, doc.getFieldValue("metatag.description"));    Assert.assertEquals(expectedKeywords, doc.getFieldValue("metatag.keywords"));    Assert.assertEquals(expectedAuthor, doc.getFieldValue("metatag.author"));}
79df0d99f4b4a147d0ddbc6787b51da06b3f35f9d90d912a49b8811e970b8464
testUrlMatchesPattern
public void testUrlMatchesPattern()
{    String expectedDescription = "With this awesome plugin, I control the description! Bwuhuhuhaha!";    String expectedKeywords = "Breathtaking! Riveting! Two Thumbs Up!";    String expectedAuthor = "Peter D. Ciuffetti";    String indexReplaceProperty = " urlmatch=.*.html\n" + "  metatag.description=/this(.*)plugin/this awesome plugin/\n" + "  metatag.keywords=/\\,/\\!/\n" + "  metatag.author=/\\s+/ D. /\n";    Configuration conf = NutchConfiguration.create();    conf.set("plugin.includes", "protocol-file|urlfilter-regex|parse-(html|metatags)|index-(basic|anchor|metadata|static|replace)|urlnormalizer-(pass|regex|basic)");    conf.set(INDEX_REPLACE_PROPERTY, indexReplaceProperty);    conf.set("metatags.names", "author,description,keywords");    conf.set("index.parse.md", "metatag.author,metatag.description,metatag.keywords");        conf.set("http.timeout", "99999999999");        NutchDocument doc = parseAndFilterFile(sampleFile, conf);        Assert.assertEquals(expectedDescription, doc.getFieldValue("metatag.description"));    Assert.assertEquals(expectedKeywords, doc.getFieldValue("metatag.keywords"));    Assert.assertEquals(expectedAuthor, doc.getFieldValue("metatag.author"));}
3e64ccd6eff4cc4716b3a9ad5e5c46631f1c84985a0e400ea5e4d7f92600a762
testUrlNotMatchesPattern
public void testUrlNotMatchesPattern()
{    String expectedDescription = "With this plugin, I control the description! Bwuhuhuhaha!";    String expectedKeywords = "Breathtaking, Riveting, Two Thumbs Up!";    String expectedAuthor = "Peter Ciuffetti";    String indexReplaceProperty = " urlmatch=.*.xml\n" + "  metatag.description=/this(.*)plugin/this awesome plugin/\n" + "  metatag.keywords=/\\,/\\!/\n" + "  metatag.author=/\\s+/ D. /\n";    Configuration conf = NutchConfiguration.create();    conf.set("plugin.includes", "protocol-file|urlfilter-regex|parse-(html|metatags)|index-(basic|anchor|metadata|static|replace)|urlnormalizer-(pass|regex|basic)");    conf.set(INDEX_REPLACE_PROPERTY, indexReplaceProperty);    conf.set("metatags.names", "author,description,keywords");    conf.set("index.parse.md", "metatag.author,metatag.description,metatag.keywords");        conf.set("http.timeout", "99999999999");        NutchDocument doc = parseAndFilterFile(sampleFile, conf);        Assert.assertEquals(expectedDescription, doc.getFieldValue("metatag.description"));    Assert.assertEquals(expectedKeywords, doc.getFieldValue("metatag.keywords"));    Assert.assertEquals(expectedAuthor, doc.getFieldValue("metatag.author"));}
1be88aa549588ba38ec9e0ffe3a78e8951ff1c264a1e4c6d2e605ada5fdaad5f
testGlobalAndUrlMatchesPattern
public void testGlobalAndUrlMatchesPattern()
{    String expectedDescription = "With this awesome plugin, I control the description! Bwuhuhuhaha!";    String expectedKeywords = "Breathtaking! Riveting! Two Thumbs Up!";    String expectedAuthor = "Peter D. Ciuffetti";    String indexReplaceProperty = "  metatag.description=/this(.*)plugin/this$1awesome$1plugin/\n" + "  urlmatch=.*.html\n" + "  metatag.keywords=/\\,/\\!/\n" + "  metatag.author=/\\s+/ D. /\n";    Configuration conf = NutchConfiguration.create();    conf.set("plugin.includes", "protocol-file|urlfilter-regex|parse-(html|metatags)|index-(basic|anchor|metadata|static|replace)|urlnormalizer-(pass|regex|basic)");    conf.set(INDEX_REPLACE_PROPERTY, indexReplaceProperty);    conf.set("metatags.names", "author,description,keywords");    conf.set("index.parse.md", "metatag.author,metatag.description,metatag.keywords");        conf.set("http.timeout", "99999999999");        NutchDocument doc = parseAndFilterFile(sampleFile, conf);        Assert.assertEquals(expectedDescription, doc.getFieldValue("metatag.description"));    Assert.assertEquals(expectedKeywords, doc.getFieldValue("metatag.keywords"));    Assert.assertEquals(expectedAuthor, doc.getFieldValue("metatag.author"));}
a4811694ec51721dd780882186444defde0254f6f9fa104cb50f4cf7baac5025
testGlobalAndUrlNotMatchesPattern
public void testGlobalAndUrlNotMatchesPattern()
{    String expectedDescription = "With this awesome plugin, I control the description! Bwuhuhuhaha!";    String expectedKeywords = "Breathtaking, Riveting, Two Thumbs Up!";    String expectedAuthor = "Peter Ciuffetti";    String indexReplaceProperty = "  metatag.description=/this(.*)plugin/this$1awesome$1plugin/\n" + "  urlmatch=.*.xml\n" + "  metatag.keywords=/\\,/\\!/\n" + "  metatag.author=/\\s+/ D. /\n";    Configuration conf = NutchConfiguration.create();    conf.set("plugin.includes", "protocol-file|urlfilter-regex|parse-(html|metatags)|index-(basic|anchor|metadata|static|replace)|urlnormalizer-(pass|regex|basic)");    conf.set(INDEX_REPLACE_PROPERTY, indexReplaceProperty);    conf.set("metatags.names", "author,description,keywords");    conf.set("index.parse.md", "metatag.author,metatag.description,metatag.keywords");        conf.set("http.timeout", "99999999999");        NutchDocument doc = parseAndFilterFile(sampleFile, conf);        Assert.assertEquals(expectedDescription, doc.getFieldValue("metatag.description"));    Assert.assertEquals(expectedKeywords, doc.getFieldValue("metatag.keywords"));    Assert.assertEquals(expectedAuthor, doc.getFieldValue("metatag.author"));}
d90370c02f8baf9c0ee207847168ef6e33e1fc0e7031854865a9f1909b4517b5
testReplacementsRunInSpecifedOrder
public void testReplacementsRunInSpecifedOrder()
{    String expectedDescription = "With this awesome plugin, I control the description! Bwuhuhuhaha!";    String indexReplaceProperty = "  metatag.description=/this plugin/this amazing plugin/\n" + "  metatag.description=/this amazing plugin/this valuable plugin/\n" + "  metatag.description=/this valuable plugin/this cool plugin/\n" + "  metatag.description=/this cool plugin/this wicked plugin/\n" + "  metatag.description=/this wicked plugin/this awesome plugin/\n";    Configuration conf = NutchConfiguration.create();    conf.set("plugin.includes", "protocol-file|urlfilter-regex|parse-(html|metatags)|index-(basic|anchor|metadata|static|replace)|urlnormalizer-(pass|regex|basic)");    conf.set(INDEX_REPLACE_PROPERTY, indexReplaceProperty);    conf.set("metatags.names", "author,description,keywords");    conf.set("index.parse.md", "metatag.author,metatag.description,metatag.keywords");        conf.set("http.timeout", "99999999999");        NutchDocument doc = parseAndFilterFile(sampleFile, conf);        Assert.assertEquals(expectedDescription, doc.getFieldValue("metatag.description"));}
3f5a127c53307e9f21b60e8087ed902d505c9ef06ed5491da9d9ee4c00d3bf01
testReplacementsWithFlags
public void testReplacementsWithFlags()
{    String expectedDescription = "With this awesome plugin, I control the description! Bwuhuhuhaha!";    String indexReplaceProperty = "  metatag.description=/THIS PLUGIN/this awesome plugin/2";    Configuration conf = NutchConfiguration.create();    conf.set("plugin.includes", "protocol-file|urlfilter-regex|parse-(html|metatags)|index-(basic|anchor|metadata|static|replace)|urlnormalizer-(pass|regex|basic)");    conf.set(INDEX_REPLACE_PROPERTY, indexReplaceProperty);    conf.set("metatags.names", "author,description,keywords");    conf.set("index.parse.md", "metatag.author,metatag.description,metatag.keywords");        conf.set("http.timeout", "99999999999");        NutchDocument doc = parseAndFilterFile(sampleFile, conf);            Assert.assertEquals(expectedDescription, doc.getFieldValue("metatag.description"));}
ba0547d5b97d386414a98f39e15cc6b26add90a4aeb078ac71bdd9d7d8a6a358
testReplacementsDifferentTarget
public void testReplacementsDifferentTarget()
{    String expectedDescription = "With this plugin, I control the description! Bwuhuhuhaha!";    String expectedTargetDescription = "With this awesome plugin, I control the description! Bwuhuhuhaha!";    String indexReplaceProperty = "  metatag.description:new=/this plugin/this awesome plugin/";    Configuration conf = NutchConfiguration.create();    conf.set("plugin.includes", "protocol-file|urlfilter-regex|parse-(html|metatags)|index-(basic|anchor|metadata|static|replace)|urlnormalizer-(pass|regex|basic)");    conf.set(INDEX_REPLACE_PROPERTY, indexReplaceProperty);    conf.set("metatags.names", "author,description,keywords");    conf.set("index.parse.md", "metatag.author,metatag.description,metatag.keywords");        conf.set("http.timeout", "99999999999");        NutchDocument doc = parseAndFilterFile(sampleFile, conf);        Assert.assertEquals(expectedDescription, doc.getFieldValue("metatag.description"));        Assert.assertEquals(expectedTargetDescription, doc.getFieldValue("new"));}
8fa98404280fecfd497ce9400c07196998fbeaf2ee8524779c09bd3c220d4ea9
filter
public NutchDocument filter(NutchDocument doc, Parse parse, Text url, CrawlDatum datum, Inlinks inlinks) throws IndexingException
{    if (this.addStaticFields == true) {        for (Entry<String, String[]> entry : this.fields.entrySet()) {            for (String val : entry.getValue()) {                doc.add(entry.getKey(), val);            }        }    }    return doc;}
75954ab5970f959134b99170d7bd39f89a2952c573db675029f61ffa53c850cf
parseFields
private HashMap<String, String[]> parseFields(String fieldsString)
{    HashMap<String, String[]> fields = new HashMap<String, String[]>();    /*     * The format is very easy, it's a comma-separated list of fields in the     * form <name>:<value>     */    for (String field : fieldsString.split(this.fieldSep)) {        String[] entry = field.split(this.kevSep);        if (entry.length == 2)            fields.put(entry[0].trim(), entry[1].trim().split(this.valueSep));    }    return fields;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;        this.fieldSep = this.regexEscape(conf.get("index.static.fieldsep", ","));    this.kevSep = this.regexEscape(conf.get("index.static.keysep", ":"));    this.valueSep = this.regexEscape(conf.get("index.static.valuesep", " "));    String fieldsString = conf.get("index.static", null);    if (fieldsString != null) {        this.addStaticFields = true;        this.fields = parseFields(fieldsString);    }}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
86202eaa5a954e942ffefa4f344a72839f0b74234d9b9dc72eb112e35c681d77
regexEscape
protected String regexEscape(String in)
{    String result = in;    if (in != null) {        StringBuffer sb = new StringBuffer();        for (int i = 0; i < in.length(); i++) {            CharSequence c = in.subSequence(i, i + 1);            if ("<([{\\^-=$!|]})?*+.>".contains(c)) {                sb.append('\\');            }            sb.append(c);        }        result = sb.toString();    }    return result;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    conf = NutchConfiguration.create();    parse = new ParseImpl();    url = new Text("http://nutch.apache.org/index.html");    crawlDatum = new CrawlDatum();    inlinks = new Inlinks();    filter = new StaticFieldIndexer();}
405f2896564212c3d92a2e281d90fca1980b934a770a21e4dc52693a6c1c415a
testEmptyIndexStatic
public void testEmptyIndexStatic() throws Exception
{    Assert.assertNotNull(filter);    filter.setConf(conf);    NutchDocument doc = new NutchDocument();    try {        filter.filter(doc, parse, url, crawlDatum, inlinks);    } catch (Exception e) {        e.printStackTrace();        Assert.fail(e.getMessage());    }    Assert.assertNotNull(doc);    Assert.assertTrue("tests if no field is set for empty index.static", doc.getFieldNames().isEmpty());}
c329aaaf08ef3e3752ef0189d626cbcecb7e61f9da36012fa8987ba4bf5a6a91
testNormalScenario
public void testNormalScenario() throws Exception
{    conf.set("index.static", "field1:val1, field2    :      val2 val3     , field3, field4 :val4 , ");    Assert.assertNotNull(filter);    filter.setConf(conf);    NutchDocument doc = new NutchDocument();    try {        filter.filter(doc, parse, url, crawlDatum, inlinks);    } catch (Exception e) {        e.printStackTrace();        Assert.fail(e.getMessage());    }    Assert.assertNotNull(doc);    Assert.assertFalse("test if doc is not empty", doc.getFieldNames().isEmpty());    Assert.assertEquals("test if doc has 3 fields", 3, doc.getFieldNames().size());    Assert.assertTrue("test if doc has field1", doc.getField("field1").getValues().contains("val1"));    Assert.assertTrue("test if doc has field2", doc.getField("field2").getValues().contains("val2"));    Assert.assertTrue("test if doc has field4", doc.getField("field4").getValues().contains("val4"));}
e7d82e4584f752e62afd64956312bb705d4f6bacddd118ca58339c7749871772
testCustomDelimiters
public void testCustomDelimiters() throws Exception
{    conf.set("index.static.fieldsep", ">");    conf.set("index.static.keysep", "=");    conf.set("index.static.valuesep", "|");    conf.set("index.static", "field1=val1>field2    =      val2|val3     >field3>field4 =val4 > ");    Assert.assertNotNull(filter);    filter.setConf(conf);    NutchDocument doc = new NutchDocument();    try {        filter.filter(doc, parse, url, crawlDatum, inlinks);    } catch (Exception e) {        e.printStackTrace();        Assert.fail(e.getMessage());    }    Assert.assertNotNull(doc);    Assert.assertFalse("test if doc is not empty", doc.getFieldNames().isEmpty());    Assert.assertEquals("test if doc has 3 fields", 3, doc.getFieldNames().size());    Assert.assertTrue("test if doc has field1", doc.getField("field1").getValues().contains("val1"));    Assert.assertTrue("test if doc has field2", doc.getField("field2").getValues().contains("val2"));    Assert.assertTrue("test if doc has field4", doc.getField("field4").getValues().contains("val4"));}
b13a03f8bb071b2e379b11b96507bb2920adc90602f9c6152efbc19116675f09
testCustomMulticharacterDelimiters
public void testCustomMulticharacterDelimiters() throws Exception
{    conf.set("index.static.fieldsep", "\n\n");    conf.set("index.static.keysep", "\t\t");    conf.set("index.static.valuesep", "***");    conf.set("index.static", "field1\t\tval1\n\n" + "field2\t\tval2***val3\n\n" + "field3\n\n" + "field4\t\tval4\n\n\n\n");    Assert.assertNotNull(filter);    filter.setConf(conf);    NutchDocument doc = new NutchDocument();    try {        filter.filter(doc, parse, url, crawlDatum, inlinks);    } catch (Exception e) {        e.printStackTrace();        Assert.fail(e.getMessage());    }    Assert.assertNotNull(doc);    Assert.assertFalse("test if doc is not empty", doc.getFieldNames().isEmpty());    Assert.assertEquals("test if doc has 3 fields", 3, doc.getFieldNames().size());    Assert.assertTrue("test if doc has field1", doc.getField("field1").getValues().contains("val1"));    Assert.assertTrue("test if doc has field2", doc.getField("field2").getValues().contains("val2"));    Assert.assertTrue("test if doc has field4", doc.getField("field4").getValues().contains("val4"));}
18802229aeca38b5cc61ddfa505a9bf38ba2840d5872fa162a646fc53b96b5ec
open
public void open(Configuration conf, String name) throws IOException
{}
9746fe850d12df7589dd17844620372be3034171f9d6cd0d0e0b5dccf4fd0244
open
public void open(IndexWriterParams parameters) throws IOException
{        endpoint = parameters.get(CloudSearchConstants.ENDPOINT);    dumpBatchFilesToTemp = parameters.getBoolean(CloudSearchConstants.BATCH_DUMP, false);    this.regionName = parameters.get(CloudSearchConstants.REGION);    if (StringUtils.isBlank(endpoint) && !dumpBatchFilesToTemp) {        String message = "Missing CloudSearch endpoint. Should set it set via -D " + CloudSearchConstants.ENDPOINT + " or in nutch-site.xml";        message += "\n" + describe();        LOG.error(message);        throw new RuntimeException(message);    }    maxDocsInBatch = parameters.getInt(CloudSearchConstants.MAX_DOCS_BATCH, -1);    buffer = new StringBuffer(MAX_SIZE_BATCH_BYTES).append('[');    if (dumpBatchFilesToTemp) {                return;    }    if (StringUtils.isBlank(endpoint)) {        throw new RuntimeException("endpoint not set for CloudSearch");    }    AmazonCloudSearchClient cl = new AmazonCloudSearchClient();    if (StringUtils.isNotBlank(regionName)) {        cl.setRegion(RegionUtils.getRegion(regionName));    }    String domainName = null;        DescribeDomainsResult domains = cl.describeDomains(new DescribeDomainsRequest());    Iterator<DomainStatus> dsiter = domains.getDomainStatusList().iterator();    while (dsiter.hasNext()) {        DomainStatus ds = dsiter.next();        if (ds.getDocService().getEndpoint().equals(endpoint)) {            domainName = ds.getDomainName();            break;        }    }        if (StringUtils.isBlank(domainName)) {        throw new RuntimeException("No domain name found for CloudSearch endpoint");    }    DescribeIndexFieldsResult indexDescription = cl.describeIndexFields(new DescribeIndexFieldsRequest().withDomainName(domainName));    for (IndexFieldStatus ifs : indexDescription.getIndexFields()) {        String indexname = ifs.getOptions().getIndexFieldName();        String indextype = ifs.getOptions().getIndexFieldType();        LOG.info("CloudSearch index name {} of type {}", indexname, indextype);        csfields.put(indexname, indextype);    }    client = new AmazonCloudSearchDomainClient();    client.setEndpoint(endpoint);}
7d6d2abb7eee5891ae596f31ca167e73e2ea74b84c0df71e5049cf6fb44dcc22
delete
public void delete(String url) throws IOException
{    try {        JSONObject doc_builder = new JSONObject();        doc_builder.put("type", "delete");                String ID = CloudSearchUtils.getID(url);        doc_builder.put("id", ID);                addToBatch(doc_builder.toString(2), url);    } catch (JSONException e) {        LOG.error("Exception caught while building JSON object", e);    }}
7b17c91d90b92c38f88e0fd76dcf4a9477e38972e89e874237b0ee939c14c40d
update
public void update(NutchDocument doc) throws IOException
{    write(doc);}
74ee4a060942b9a364cf3176d078a605623c67f28d08d73cb9323276cbd56798
write
public void write(NutchDocument doc) throws IOException
{    try {        JSONObject doc_builder = new JSONObject();        doc_builder.put("type", "add");        String url = doc.getField("url").toString();                String ID = CloudSearchUtils.getID(url);        doc_builder.put("id", ID);        JSONObject fields = new JSONObject();        for (final Entry<String, NutchField> e : doc) {            String fieldname = cleanFieldName(e.getKey());            String type = csfields.get(fieldname);                        if (!dumpBatchFilesToTemp && type == null) {                LOG.info("Field {} not defined in CloudSearch domain for {} - skipping.", fieldname, url);                continue;            }            List<Object> values = e.getValue().getValues();                        for (Object value : values) {                                if (value instanceof Date) {                    Date d = (Date) value;                    value = DATE_FORMAT.format(d);                } else                 if (value instanceof String) {                    value = CloudSearchUtils.stripNonCharCodepoints((String) value);                }                fields.accumulate(fieldname, value);            }        }        doc_builder.put("fields", fields);        addToBatch(doc_builder.toString(2), url);    } catch (JSONException e) {        LOG.error("Exception caught while building JSON object", e);    }}
72924adf46a8ed74e09981954b6e963b81249211a03195f48d73e9b69d83746e
addToBatch
private void addToBatch(String currentDoc, String url) throws IOException
{    int currentDocLength = currentDoc.getBytes(StandardCharsets.UTF_8).length;        if (currentDocLength > MAX_SIZE_DOC_BYTES) {        LOG.error("Doc too large. currentDoc.length {} : {}", currentDocLength, url);        return;    }    int currentBufferLength = buffer.toString().getBytes(StandardCharsets.UTF_8).length;    LOG.debug("currentDoc.length {}, buffer length {}", currentDocLength, currentBufferLength);        if (currentDocLength + 2 + currentBufferLength < MAX_SIZE_BATCH_BYTES) {        if (numDocsInBatch != 0)            buffer.append(',');        buffer.append(currentDoc);        numDocsInBatch++;    } else     {        commit();        buffer.append(currentDoc);        numDocsInBatch++;    }        if (maxDocsInBatch > 0 && numDocsInBatch == maxDocsInBatch) {        commit();    }}
9686b51f14ae68fc049f472c7635d5385053dc8384dae21aaed20cdf86644fa0
commit
public void commit() throws IOException
{        if (numDocsInBatch == 0) {        return;    }        buffer.append(']');    LOG.info("Sending {} docs to CloudSearch", numDocsInBatch);    byte[] bb = buffer.toString().getBytes(StandardCharsets.UTF_8);    if (dumpBatchFilesToTemp) {        try {            File temp = File.createTempFile("CloudSearch_", ".json");            FileUtils.writeByteArrayToFile(temp, bb);            LOG.info("Wrote batch file {}", temp.getName());        } catch (IOException e1) {            LOG.error("Exception while generating batch file", e1);        } finally {                        buffer = new StringBuffer(MAX_SIZE_BATCH_BYTES).append('[');            numDocsInBatch = 0;        }        return;    }        try (InputStream inputStream = new ByteArrayInputStream(bb)) {        UploadDocumentsRequest batch = new UploadDocumentsRequest();        batch.setContentLength((long) bb.length);        batch.setContentType(ContentType.Applicationjson);        batch.setDocuments(inputStream);        @SuppressWarnings("unused")        UploadDocumentsResult result = client.uploadDocuments(batch);    } catch (Exception e) {        LOG.error("Exception while sending batch", e);        LOG.error(buffer.toString());    } finally {                buffer = new StringBuffer(MAX_SIZE_BATCH_BYTES).append('[');        numDocsInBatch = 0;    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{        commit();        if (client != null) {        client.shutdown();    }}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
acc15217d72b673533075a36521acb189a4f8630982257977ac2085164b86ddf
describe
public Map<String, Entry<String, Object>> describe()
{    Map<String, Map.Entry<String, Object>> properties = new LinkedHashMap<>();    properties.put(CloudSearchConstants.ENDPOINT, new AbstractMap.SimpleEntry<>("Endpoint where service requests should be submitted.", this.endpoint));    properties.put(CloudSearchConstants.REGION, new AbstractMap.SimpleEntry<>("Region name.", this.regionName));    properties.put(CloudSearchConstants.BATCH_DUMP, new AbstractMap.SimpleEntry<>("true to send documents to a local file.", this.dumpBatchFilesToTemp));    properties.put(CloudSearchConstants.MAX_DOCS_BATCH, new AbstractMap.SimpleEntry<>("Maximum number of documents to send as a batch to CloudSearch.", this.maxDocsInBatch));    return properties;}
3e9a073c9ad9a9cf0af07a874a4893a26b2c79644d23eea5405142ca5daed70d
cleanFieldName
 String cleanFieldName(String name)
{    String lowercase = name.toLowerCase();    return lowercase.replaceAll("[^a-z_0-9]", "_");}
dccbf92510a3fff903b69dcfc74bcbdc52257decb790046d07100ccb84f0f980
getID
public static String getID(String url)
{                                byte[] dig = digester.digest(url.getBytes(StandardCharsets.UTF_8));    String ID = Hex.encodeHexString(dig);        if (ID.length() > 128) {        throw new RuntimeException("ID larger than max 128 chars");    }    return ID;}
9d86ad76426f7da21762ab371a5b5e2263740f786ce1c05a36eb102996c77baa
stripNonCharCodepoints
public static String stripNonCharCodepoints(String input)
{    StringBuilder retval = new StringBuilder();    char ch;    for (int i = 0; i < input.length(); i++) {        ch = input.charAt(i);                if ((ch == 0x9 || ch == 0xa || ch == 0xd) || (ch >= 0x20 && ch <= 0xFFFD)) {            retval.append(ch);        }    }    return retval.toString();}
7ad3153d9133cfadf9df2d89aa3a1f286fe19c5bf88aa7d4953e7f1cacbee9a3
set
protected void set(String str)
{    if (str != null) {        sepStr = str;        if (str.length() == 0) {                        chars = new char[0];        } else {            chars = str.toCharArray();        }    }        bytes = sepStr.getBytes(encoding);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder();    for (char c : chars) {        if (c == '\n') {            sb.append("\\n");        } else if (c == '\r') {            sb.append("\\r");        } else if (c == '\t') {            sb.append("\\t");        } else if (c >= 0x7f || c <= 0x20) {            sb.append(String.format("\\u%04x", (int) c));        } else {            sb.append(c);        }    }    return sb.toString();}
2c91f8ad8a55dfad528f5e4b6996586b7fa05b69ad09af3ac9f284c317038cf3
setFromConf
protected void setFromConf(IndexWriterParams parameters, String property)
{    setFromConf(parameters, property, false);}
2a1338a0431cbaf745bdc0567134a5743f6388f74afa097fffaa6cc5415d050e
setFromConf
protected void setFromConf(IndexWriterParams parameters, String property, boolean isChar)
{    String str = parameters.get(property);    if (isChar && str != null && !str.isEmpty()) {        LOG.warn("Separator " + property + " must be a char, only the first character '" + str.charAt(0) + "' of \"" + str + "\" is used");        str = str.substring(0, 1);    }    set(str);    LOG.info(property + " = " + toString());}
8579e1b77c10a34ce6aefd2cc477f7970e83e9bd06c8a1baa2a98d9faf75356f
find
protected int find(String value, int start)
{    if (chars.length == 0)        return -1;    if (chars.length == 1)        return value.indexOf(chars[0], start);    int index;    for (char c : chars) {        if ((index = value.indexOf(c, start)) >= 0) {            return index;        }    }    return -1;}
18802229aeca38b5cc61ddfa505a9bf38ba2840d5872fa162a646fc53b96b5ec
open
public void open(Configuration conf, String name) throws IOException
{}
9746fe850d12df7589dd17844620372be3034171f9d6cd0d0e0b5dccf4fd0244
open
public void open(IndexWriterParams parameters) throws IOException
{    outputPath = parameters.get(CSVConstants.CSV_OUTPATH, outputPath);    String charset = parameters.get(CSVConstants.CSV_CHARSET);    if (charset != null) {        encoding = Charset.forName(charset);    }    fieldSeparator.setFromConf(parameters, CSVConstants.CSV_FIELD_SEPARATOR);    quoteCharacter.setFromConf(parameters, CSVConstants.CSV_QUOTECHARACTER, true);    escapeCharacter.setFromConf(parameters, CSVConstants.CSV_ESCAPECHARACTER, true);    valueSeparator.setFromConf(parameters, CSVConstants.CSV_VALUESEPARATOR);    withHeader = parameters.getBoolean(CSVConstants.CSV_WITHHEADER, true);    maxFieldLength = parameters.getInt(CSVConstants.CSV_MAXFIELDLENGTH, maxFieldLength);    LOG.info(CSVConstants.CSV_MAXFIELDLENGTH + " = " + maxFieldLength);    maxFieldValues = parameters.getInt(CSVConstants.CSV_MAXFIELDVALUES, maxFieldValues);    LOG.info(CSVConstants.CSV_MAXFIELDVALUES + " = " + maxFieldValues);    fields = parameters.getStrings(CSVConstants.CSV_FIELDS, "id", "title", "content");    LOG.info("fields =");    for (String f : fields) {        LOG.info("\t" + f);    }    fs = FileSystem.get(config);    LOG.info("Writing output to {}", outputPath);    Path outputDir = new Path(outputPath);    fs = outputDir.getFileSystem(config);    csvLocalOutFile = new Path(outputDir, "nutch.csv");    if (!fs.exists(outputDir)) {        fs.mkdirs(outputDir);    }    if (fs.exists(csvLocalOutFile)) {                LOG.warn("Removing existing output path {}", csvLocalOutFile);        fs.delete(csvLocalOutFile, true);    }    csvout = fs.create(csvLocalOutFile);    if (withHeader) {        for (int i = 0; i < fields.length; i++) {            if (i > 0)                csvout.write(fieldSeparator.bytes);            csvout.write(fields[i].getBytes(encoding));        }    }    csvout.write(recordSeparator.bytes);}
74ee4a060942b9a364cf3176d078a605623c67f28d08d73cb9323276cbd56798
write
public void write(NutchDocument doc) throws IOException
{    for (int i = 0; i < fields.length; i++) {        if (i > 0) {            csvout.write(fieldSeparator.bytes);        }        NutchField field = doc.getField(fields[i]);        if (field != null) {            List<Object> values = field.getValues();            int nValues = values.size();            if (nValues > maxFieldValues) {                nValues = maxFieldValues;            }            if (nValues > 1) {                                csvout.write(quoteCharacter.bytes);            }            ListIterator<Object> it = values.listIterator();            int j = 0;            while (it.hasNext() && j <= nValues) {                Object objval = it.next();                String value;                if (objval == null) {                    continue;                } else if (objval instanceof Date) {                                        value = objval.toString();                } else {                    value = (String) objval;                }                if (nValues > 1) {                                        writeEscaped(value);                    if (it.hasNext()) {                        csvout.write(valueSeparator.bytes);                    }                } else {                    writeQuoted(value);                }            }            if (nValues > 1) {                                csvout.write(quoteCharacter.bytes);            }        }    }    csvout.write(recordSeparator.bytes);}
2d23d200588a1063476b33637154ce3e20c9ad0ebac74372f4c48283f448ef29
delete
public void delete(String key)
{}
7b17c91d90b92c38f88e0fd76dcf4a9477e38972e89e874237b0ee939c14c40d
update
public void update(NutchDocument doc) throws IOException
{    write(doc);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    csvout.close();    LOG.info("Finished CSV index in {}", csvLocalOutFile);}
609962ed3c13286966d937afa9c301e49ddab59023e4f4c7704fb7ba9630b243
commit
public void commit()
{}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return config;}
9cff91000036512f05d409feb972bf85fa9ea8b92b401fe5769452ea0ea9ff2e
describe
public Map<String, Map.Entry<String, Object>> describe()
{    Map<String, Map.Entry<String, Object>> properties = new LinkedHashMap<>();    properties.put(CSVConstants.CSV_FIELDS, new AbstractMap.SimpleEntry<>("Ordered list of fields (columns) in the CSV file", this.fields == null ? "" : String.join(",", this.fields)));    properties.put(CSVConstants.CSV_FIELD_SEPARATOR, new AbstractMap.SimpleEntry<>("Separator between fields (columns), default: , (U+002C, comma)", this.fieldSeparator));    properties.put(CSVConstants.CSV_QUOTECHARACTER, new AbstractMap.SimpleEntry<>("Quote character used to quote fields containing separators or quotes, default: \" (U+0022, quotation mark)", this.quoteCharacter));    properties.put(CSVConstants.CSV_ESCAPECHARACTER, new AbstractMap.SimpleEntry<>("Escape character used to escape a quote character, default: \" (U+0022, quotation mark)", this.escapeCharacter));    properties.put(CSVConstants.CSV_VALUESEPARATOR, new AbstractMap.SimpleEntry<>("Separator between multiple values of one field, default: | (U+007C)", this.valueSeparator));    properties.put(CSVConstants.CSV_MAXFIELDVALUES, new AbstractMap.SimpleEntry<>("Max. number of values of one field, useful for, e.g., the anchor texts field, default: 12", this.maxFieldValues));    properties.put(CSVConstants.CSV_MAXFIELDLENGTH, new AbstractMap.SimpleEntry<>("Max. length of a single field value in characters, default: 4096", this.maxFieldLength));    properties.put(CSVConstants.CSV_CHARSET, new AbstractMap.SimpleEntry<>("Encoding of CSV file, default: UTF-8", this.encoding));    properties.put(CSVConstants.CSV_WITHHEADER, new AbstractMap.SimpleEntry<>("Write CSV column headers, default: true", this.withHeader));    properties.put(CSVConstants.CSV_OUTPATH, new AbstractMap.SimpleEntry<>("Output path / directory, default: csvindexwriter. ", this.outputPath));    return properties;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    config = conf;}
94ca7571b6bbe92668c64664609f9a0294971f8e9ec80e098875cfbff3a6b65b
writeQuoted
private void writeQuoted(String value) throws IOException
{    int nextQuoteChar;    if (quoteCharacter.chars.length > 0 && (((nextQuoteChar = quoteCharacter.find(value, 0)) >= 0) || (fieldSeparator.find(value, 0) >= 0) || (recordSeparator.find(value, 0) >= 0))) {                csvout.write(quoteCharacter.bytes);        writeEscaped(value, nextQuoteChar);        csvout.write(quoteCharacter.bytes);    } else {        if (value.length() > maxFieldLength) {            csvout.write(value.substring(0, maxFieldLength).getBytes(encoding));        } else {            csvout.write(value.getBytes(encoding));        }    }}
c021c24159551ba538dc3692cd65e5a0656ed1d5cf1ed6afc529618b7e0e649e
writeEscaped
private void writeEscaped(String value, int nextQuoteChar) throws IOException
{    int start = 0;    int max = value.length();    if (max > maxFieldLength) {        max = maxFieldLength;    }    while (nextQuoteChar > 0 && nextQuoteChar < max) {        csvout.write(value.substring(start, nextQuoteChar).getBytes(encoding));        csvout.write(escapeCharacter.bytes);        csvout.write(quoteCharacter.bytes);        start = nextQuoteChar + 1;        nextQuoteChar = quoteCharacter.find(value, start);        if (nextQuoteChar > max)            break;    }    csvout.write(value.substring(start, max).getBytes(encoding));}
d8c88d18e29649f17594e4f15202f6169c8555cc743215cfa581d54731d3f622
writeEscaped
private void writeEscaped(String value) throws IOException
{    int nextQuoteChar = quoteCharacter.find(value, 0);    writeEscaped(value, nextQuoteChar);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    final int res = ToolRunner.run(NutchConfiguration.create(), new IndexingJob(), args);    System.exit(res);}
9746fe850d12df7589dd17844620372be3034171f9d6cd0d0e0b5dccf4fd0244
open
public void open(IndexWriterParams parameters) throws IOException
{    super.open(parameters);    byteBuffer = new ByteArrayOutputStream();    fsStats = new FileSystem.Statistics("testCSVIndexWriter");    csvout = new FSDataOutputStream(byteBuffer, fsStats);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{}
78718c6bce9a328e3e99e403141b8da2560dded1e0ae67d5e01f0e8d7120b582
getData
public String getData()
{    try {        return byteBuffer.toString(encoding.name());    } catch (UnsupportedEncodingException e) {        return "";    }}
a5d969f0ff4033a159cd650343746ec1d16e59e00aec6f7f243890a1e6e8e15e
getCSV
private String getCSV(final String[] configParams, NutchDocument[] docs) throws IOException
{    Configuration conf = NutchConfiguration.create();    IndexWriterParams params = new IndexWriterParams(new HashMap<>());    for (int i = 0; i < configParams.length; i += 2) {        params.put(configParams[i], configParams[i + 1]);    }    CSVByteArrayIndexWriter out = new CSVByteArrayIndexWriter();    out.setConf(conf);    out.open(params);    for (NutchDocument doc : docs) {        out.write(doc);    }    out.close();    String csv = out.getData();    LOG.info(csv);    return csv;}
4e543c73885b280b9f5d42f934b698eb003ff58afa92a9c218b4fa843e245d06
getCSV
private String getCSV(final String[] configParams, final String[] fieldContent) throws IOException
{    NutchDocument[] docs = new NutchDocument[1];    docs[0] = new NutchDocument();    for (int i = 0; i < fieldContent.length; i += 2) {        docs[0].add(fieldContent[i], fieldContent[i + 1]);    }    return getCSV(configParams, docs);}
6f500d2e974a4dff346c6c0217e0a8d355d058c21da42df7e65700e9a13724fe
testCSVdefault
public void testCSVdefault() throws IOException
{    String[] fields = { "id", "http://nutch.apache.org/", "title", "Welcome to Apache Nutch", "content", "Apache Nutch is an open source web-search software project. ..." };    String csv = getCSV(new String[0], fields);    for (int i = 0; i < fields.length; i += 2) {        assertTrue("Testing field " + i + " (" + fields[i] + ")", csv.contains(fields[i + 1]));    }}
16637c919b5c06047ac7e0743a1dbfc6cd5c2fdd96734739ca7a78fc5cea195e
testCSVquoteFieldSeparators
public void testCSVquoteFieldSeparators() throws IOException
{    String[] params = { CSVConstants.CSV_FIELDS, "test,test2" };    String[] fields = { "test", "a,b", "test2", "c,d" };    String csv = getCSV(params, fields);    assertEquals("If field contains a fields separator, it must be quoted", "\"a,b\",\"c,d\"", csv.trim());}
1e38999951743b780fac040838336b0ff7b69eabf06d43c96637c48cbb72817e
testCSVquoteRecordSeparators
public void testCSVquoteRecordSeparators() throws IOException
{    String[] params = { CSVConstants.CSV_FIELDS, "test" };    String[] fields = { "test", "a\nb" };    String csv = getCSV(params, fields);    assertEquals("If field contains a fields separator, it must be quoted", "\"a\nb\"", csv.trim());}
a5a7c9881f97d37f7bc1fdc4419181afc4c6a8cc1f19076b8da0c6f79b85530c
testCSVescapeQuotes
public void testCSVescapeQuotes() throws IOException
{    String[] params = { CSVConstants.CSV_FIELDS, "test" };    String[] fields = { "test", "a,b:\"quote\",c" };    String csv = getCSV(params, fields);    assertEquals("Quotes inside a quoted field must be escaped", "\"a,b:\"\"quote\"\",c\"", csv.trim());}
0362b678d0b2e46d162c2723f76e03c6affc057465f9a4662bbb19e9b5e0595c
testCSVclipMaxLength
public void testCSVclipMaxLength() throws IOException
{    String[] params = { CSVConstants.CSV_FIELDS, "test", CSVConstants.CSV_MAXFIELDLENGTH, "8" };    String[] fields = { "test", "0123456789" };    String csv = getCSV(params, fields);    assertEquals("Field clipped to max. length = 8", "01234567", csv.trim());}
a9243f95369d510ef0196db1544d26ad65051d866cd905efe35b19513cda831c
testCSVclipMaxLengthQuote
public void testCSVclipMaxLengthQuote() throws IOException
{    String[] params = { CSVConstants.CSV_FIELDS, "test", CSVConstants.CSV_MAXFIELDLENGTH, "7" };    String[] fields = { "test", "1,\"2\",3,\"4\"" };    String csv = getCSV(params, fields);    assertEquals("Field clipped to max. length = 7", "\"1,\"\"2\"\",3\"", csv.trim());}
0fdd260ad141434ee17347c1920fe48b06b81129aba47a0531384cc447f82dd6
testCSVmultiValueFields
public void testCSVmultiValueFields() throws IOException
{    String[] params = { CSVConstants.CSV_FIELDS, "test", CSVConstants.CSV_VALUESEPARATOR, "|", CSVConstants.CSV_QUOTECHARACTER, "" };    String[] fields = { "test", "abc", "test", "def" };    String csv = getCSV(params, fields);    assertEquals("Values of multi-value fields are concatenated by |", "abc|def", csv.trim());}
458143274f18ca6011d02093349ac86cd76e443ab4f1fb544ecd66f7300438b5
testCSVEncoding
public void testCSVEncoding() throws IOException
{    String[] charsets = { "iso-8859-1",     "\u00e4\u00f6\u00fc\u00df\u00e9\u00f4\u00ee",     "iso-8859-2",     "\u0161\u010d\u0159\u016f",     "iso-8859-5",     "\u0430\u0441\u0434\u0444" };    for (int i = 0; i < charsets.length; i += 2) {        String charset = charsets[i];        String test = charsets[i + 1];        String[] params = { CSVConstants.CSV_FIELDS, "test", CSVConstants.CSV_CHARSET, charset };        String[] fields = { "test", test };        String csv = getCSV(params, fields);        assertEquals("wrong charset conversion", test, csv.trim());    }}
c8759c902bf0ccd69f7f2ff6e32a9f1cf9b812beb287a45c9cb7ef1559e2530f
testCSVEncodingSeparator
public void testCSVEncodingSeparator() throws IOException
{    String[] params = { CSVConstants.CSV_FIELDS, "test", CSVConstants.CSV_CHARSET, "iso-8859-1",     CSVConstants.CSV_VALUESEPARATOR,     "\u00a6", CSVConstants.CSV_QUOTECHARACTER, "" };    String[] fields = { "test", "abc", "test", "def" };    String csv = getCSV(params, fields);    assertEquals("Values of multi-value fields are concatenated by ", "abc\u00a6def", csv.trim());}
9e9e4f110dba17d858790518b9d28f05d25df4766723cb82f40912ea9f2a730b
testCSVtabSeparated
public void testCSVtabSeparated() throws IOException
{    String[] params = { CSVConstants.CSV_FIELDS, "1,2,3", CSVConstants.CSV_FIELD_SEPARATOR, "\t", CSVConstants.CSV_QUOTECHARACTER, "" };    NutchDocument[] docs = new NutchDocument[2];    docs[0] = new NutchDocument();    docs[0].add("1", "a");    docs[0].add("1", "b");    docs[0].add("2", "a\"2\"b");    docs[0].add("3", "c,d");    docs[1] = new NutchDocument();    docs[1].add("1", "A");    docs[1].add("2", "B");    docs[1].add("3", "C");    String csv = getCSV(params, docs);    String[] records = csv.trim().split("\\r\\n");    assertEquals("tab-separated output", "a|b\ta\"2\"b\tc,d", records[0]);    assertEquals("tab-separated output", "A\tB\tC", records[1]);}
b7bb78da8e9951e36c8be2a395dd868f44140094680bb189e0234c363c2e4c62
testCSVdateField
public void testCSVdateField() throws IOException
{    TimeZone.setDefault(TimeZone.getTimeZone("UTC"));    String[] params = { CSVConstants.CSV_FIELDS, "date" };    NutchDocument[] docs = new NutchDocument[1];    docs[0] = new NutchDocument();        docs[0].add("date", new Date(0));    String csv = getCSV(params, docs);    assertTrue("date conversion", csv.contains("1970"));}
18802229aeca38b5cc61ddfa505a9bf38ba2840d5872fa162a646fc53b96b5ec
open
public void open(Configuration conf, String name) throws IOException
{}
9746fe850d12df7589dd17844620372be3034171f9d6cd0d0e0b5dccf4fd0244
open
public void open(IndexWriterParams parameters) throws IOException
{    delete = parameters.getBoolean(DummyConstants.DELETE, false);    path = parameters.get(DummyConstants.PATH, "/");    if (path == null) {        String message = "Missing path.";        message += "\n" + describe();        LOG.error(message);        throw new RuntimeException(message);    }    if (writer != null) {        LOG.warn("Dummy index file already open for writing");        return;    }    try {        LOG.debug("Opening dummy index file {}", path);        writer = new BufferedWriter(new FileWriter(path));    } catch (IOException ex) {        LOG.error("Failed to open index file {}: {}", path, StringUtils.stringifyException(ex));    }}
dea506e2ed0c9b5f5198b693294dc12a256d914241f20c24393244b56d304554
delete
public void delete(String key) throws IOException
{    if (delete) {        writer.write("delete\t" + key + "\n");    }}
7b17c91d90b92c38f88e0fd76dcf4a9477e38972e89e874237b0ee939c14c40d
update
public void update(NutchDocument doc) throws IOException
{    writer.write("update\t" + doc.getFieldValue("id") + "\n");}
74ee4a060942b9a364cf3176d078a605623c67f28d08d73cb9323276cbd56798
write
public void write(NutchDocument doc) throws IOException
{    writer.write("add\t" + doc.getFieldValue("id") + "\n");}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    LOG.debug("Closing dummy index file");    writer.flush();    writer.close();}
9686b51f14ae68fc049f472c7635d5385053dc8384dae21aaed20cdf86644fa0
commit
public void commit() throws IOException
{    writer.write("commit\n");}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return config;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    config = conf;}
9cff91000036512f05d409feb972bf85fa9ea8b92b401fe5769452ea0ea9ff2e
describe
public Map<String, Map.Entry<String, Object>> describe()
{    Map<String, Map.Entry<String, Object>> properties = new LinkedHashMap<>();    properties.put(DummyConstants.DELETE, new AbstractMap.SimpleEntry<>("If delete operations should be written to the file.", this.delete));    properties.put(DummyConstants.PATH, new AbstractMap.SimpleEntry<>("Path where the file will be created.", this.path));    return properties;}
18802229aeca38b5cc61ddfa505a9bf38ba2840d5872fa162a646fc53b96b5ec
open
public void open(Configuration conf, String name) throws IOException
{}
9746fe850d12df7589dd17844620372be3034171f9d6cd0d0e0b5dccf4fd0244
open
public void open(IndexWriterParams parameters) throws IOException
{    cluster = parameters.get(ElasticConstants.CLUSTER);    String hosts = parameters.get(ElasticConstants.HOSTS);    if (StringUtils.isBlank(cluster) && StringUtils.isBlank(hosts)) {        String message = "Missing elastic.cluster and elastic.host. At least one of them should be set in index-writers.xml ";        message += "\n" + describe();        LOG.error(message);        throw new RuntimeException(message);    }    bulkCloseTimeout = parameters.getLong(ElasticConstants.BULK_CLOSE_TIMEOUT, DEFAULT_BULK_CLOSE_TIMEOUT);    defaultIndex = parameters.get(ElasticConstants.INDEX, DEFAULT_INDEX);    maxBulkDocs = parameters.getInt(ElasticConstants.MAX_BULK_DOCS, DEFAULT_MAX_BULK_DOCS);    maxBulkLength = parameters.getInt(ElasticConstants.MAX_BULK_LENGTH, DEFAULT_MAX_BULK_LENGTH);    expBackoffMillis = parameters.getInt(ElasticConstants.EXPONENTIAL_BACKOFF_MILLIS, DEFAULT_EXP_BACKOFF_MILLIS);    expBackoffRetries = parameters.getInt(ElasticConstants.EXPONENTIAL_BACKOFF_RETRIES, DEFAULT_EXP_BACKOFF_RETRIES);    client = makeClient(parameters);    LOG.debug("Creating BulkProcessor with maxBulkDocs={}, maxBulkLength={}", maxBulkDocs, maxBulkLength);    bulkProcessor = BulkProcessor.builder(client, bulkProcessorListener()).setBulkActions(maxBulkDocs).setBulkSize(new ByteSizeValue(maxBulkLength, ByteSizeUnit.BYTES)).setConcurrentRequests(1).setBackoffPolicy(BackoffPolicy.exponentialBackoff(TimeValue.timeValueMillis(expBackoffMillis), expBackoffRetries)).build();}
2d0ff35eb5f9f2a759adef9a93f86353ae49aa60c1b44386891d8d93e1400f7d
makeClient
protected Client makeClient(IndexWriterParams parameters) throws IOException
{    hosts = parameters.getStrings(ElasticConstants.HOSTS);    port = parameters.getInt(ElasticConstants.PORT, DEFAULT_PORT);    Settings.Builder settingsBuilder = Settings.builder();    String options = parameters.get(ElasticConstants.OPTIONS);    if (options != null) {        String[] lines = options.trim().split(",");        for (String line : lines) {            if (StringUtils.isNotBlank(line)) {                String[] parts = line.trim().split("=");                if (parts.length == 2) {                    settingsBuilder.put(parts[0].trim(), parts[1].trim());                }            }        }    }        if (StringUtils.isNotBlank(cluster)) {        settingsBuilder.put("cluster.name", cluster);    }    Settings settings = settingsBuilder.build();    Client client = null;        if (hosts != null && port > 1) {        @SuppressWarnings("resource")        TransportClient transportClient = new PreBuiltTransportClient(settings);        for (String host : hosts) transportClient.addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(host), port));        client = transportClient;    } else if (cluster != null) {        node = new Node(settings);        client = node.client();    }    return client;}
d2f9b81b3967fd6262461fa5cfc17f367995df17c4a2c98bc27dd6edf7964539
bulkProcessorListener
protected BulkProcessor.Listener bulkProcessorListener()
{    return new BulkProcessor.Listener() {        @Override        public void beforeBulk(long executionId, BulkRequest request) {        }        @Override        public void afterBulk(long executionId, BulkRequest request, Throwable failure) {            throw new RuntimeException(failure);        }        @Override        public void afterBulk(long executionId, BulkRequest request, BulkResponse response) {            if (response.hasFailures()) {                LOG.warn("Failures occurred during bulk request");            }        }    };}
cc0682d9c13ce3a8fede8c8aacd4382c37c1aa8640757eaa0222480c60774e89
beforeBulk
public void beforeBulk(long executionId, BulkRequest request)
{}
eb853b976d9a67407f7f77eb05e2026c27863b6a9224f6d6b6cc017e0d6cd55c
afterBulk
public void afterBulk(long executionId, BulkRequest request, Throwable failure)
{    throw new RuntimeException(failure);}
c8ed96f654ff1b9bf9864488fbf36fd9043ff7faeeed5938e921368c8dc0f849
afterBulk
public void afterBulk(long executionId, BulkRequest request, BulkResponse response)
{    if (response.hasFailures()) {        LOG.warn("Failures occurred during bulk request");    }}
74ee4a060942b9a364cf3176d078a605623c67f28d08d73cb9323276cbd56798
write
public void write(NutchDocument doc) throws IOException
{    String id = (String) doc.getFieldValue("id");    String type = doc.getDocumentMeta().get("type");    if (type == null)        type = "doc";        Map<String, Object> source = new HashMap<String, Object>();    for (final Map.Entry<String, NutchField> e : doc) {        final List<Object> values = e.getValue().getValues();        if (values.size() > 1) {            source.put(e.getKey(), values);        } else {            source.put(e.getKey(), values.get(0));        }    }    IndexRequest request = new IndexRequest(defaultIndex, type, id).source(source);    bulkProcessor.add(request);}
dea506e2ed0c9b5f5198b693294dc12a256d914241f20c24393244b56d304554
delete
public void delete(String key) throws IOException
{    DeleteRequest request = new DeleteRequest(defaultIndex, "doc", key);    bulkProcessor.add(request);}
7b17c91d90b92c38f88e0fd76dcf4a9477e38972e89e874237b0ee939c14c40d
update
public void update(NutchDocument doc) throws IOException
{    write(doc);}
9686b51f14ae68fc049f472c7635d5385053dc8384dae21aaed20cdf86644fa0
commit
public void commit() throws IOException
{    bulkProcessor.flush();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{        try {        bulkProcessor.awaitClose(bulkCloseTimeout, TimeUnit.SECONDS);    } catch (InterruptedException e) {        LOG.warn("interrupted while waiting for BulkProcessor to complete ({})", e.getMessage());    }    client.close();    if (node != null) {        node.close();    }}
9cff91000036512f05d409feb972bf85fa9ea8b92b401fe5769452ea0ea9ff2e
describe
public Map<String, Map.Entry<String, Object>> describe()
{    Map<String, Map.Entry<String, Object>> properties = new LinkedHashMap<>();    properties.put(ElasticConstants.CLUSTER, new AbstractMap.SimpleEntry<>("The cluster name to discover. Either host and port must be defined or cluster.", this.cluster));    properties.put(ElasticConstants.HOSTS, new AbstractMap.SimpleEntry<>("Ordered list of fields (columns) in the CSV fileComma-separated list of " + "hostnames to send documents to using TransportClient. " + "Either host and port must be defined or cluster.", this.hosts == null ? "" : String.join(",", hosts)));    properties.put(ElasticConstants.PORT, new AbstractMap.SimpleEntry<>("The port to connect to using TransportClient.", this.port));    properties.put(ElasticConstants.INDEX, new AbstractMap.SimpleEntry<>("Default index to send documents to.", this.defaultIndex));    properties.put(ElasticConstants.MAX_BULK_DOCS, new AbstractMap.SimpleEntry<>("Maximum size of the bulk in number of documents.", this.maxBulkDocs));    properties.put(ElasticConstants.MAX_BULK_LENGTH, new AbstractMap.SimpleEntry<>("Maximum size of the bulk in bytes.", this.maxBulkLength));    properties.put(ElasticConstants.EXPONENTIAL_BACKOFF_MILLIS, new AbstractMap.SimpleEntry<>("Initial delay for the BulkProcessor exponential backoff policy.", this.expBackoffMillis));    properties.put(ElasticConstants.EXPONENTIAL_BACKOFF_RETRIES, new AbstractMap.SimpleEntry<>("Number of times the BulkProcessor exponential backoff policy should retry bulk operations.", this.expBackoffRetries));    properties.put(ElasticConstants.BULK_CLOSE_TIMEOUT, new AbstractMap.SimpleEntry<>("Number of seconds allowed for the BulkProcessor to complete its last operation.", this.bulkCloseTimeout));    return properties;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    config = conf;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return config;}
5ff0b8f7d2b080bcc6214fa5f91be74727145ea81cacb63a99c8d0f3106c089f
setup
public void setup()
{    conf = NutchConfiguration.create();    conf.addResource("nutch-site-test.xml");    bulkRequestSuccessful = false;    clusterSaturated = false;    curNumFailures = 0;    maxNumFailures = 0;    Settings settings = Settings.builder().build();    ThreadPool threadPool = new ThreadPool(settings);        client = new AbstractClient(settings, threadPool) {        @Override        public void close() {        }        @Override        protected <Request extends ActionRequest, Response extends ActionResponse, RequestBuilder extends ActionRequestBuilder<Request, Response, RequestBuilder>> void doExecute(Action<Request, Response, RequestBuilder> action, Request request, ActionListener<Response> listener) {            BulkResponse response = null;            if (clusterSaturated) {                                curNumFailures++;                if (curNumFailures >= maxNumFailures) {                                        clusterSaturated = false;                }                                BulkItemResponse failed = new BulkItemResponse(0, OpType.INDEX, new BulkItemResponse.Failure("nutch", "index", "failure0", new EsRejectedExecutionException("saturated")));                response = new BulkResponse(new BulkItemResponse[] { failed }, 0);            } else {                                BulkItemResponse success = new BulkItemResponse(0, OpType.INDEX, new IndexResponse(new ShardId("nutch", UUID.randomUUID().toString(), 0), "index", "index0", 0, true));                response = new BulkResponse(new BulkItemResponse[] { success }, 0);            }            listener.onResponse((Response) response);        }    };        testIndexWriter = new ElasticIndexWriter() {        @Override        protected Client makeClient(IndexWriterParams parameters) {            return client;        }        @Override        protected BulkProcessor.Listener bulkProcessorListener() {            return new BulkProcessor.Listener() {                @Override                public void afterBulk(long executionId, BulkRequest request, BulkResponse response) {                    if (!response.hasFailures()) {                        bulkRequestSuccessful = true;                    }                }                @Override                public void afterBulk(long executionId, BulkRequest request, Throwable failure) {                }                @Override                public void beforeBulk(long executionId, BulkRequest request) {                }            };        }    };}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{}
e62f6a5c4d43f3e8a0c0cf761ee7071d5bd0af8184f35fdb89adbad3c6b0b6e6
doExecute
protected void doExecute(Action<Request, Response, RequestBuilder> action, Request request, ActionListener<Response> listener)
{    BulkResponse response = null;    if (clusterSaturated) {                curNumFailures++;        if (curNumFailures >= maxNumFailures) {                        clusterSaturated = false;        }                BulkItemResponse failed = new BulkItemResponse(0, OpType.INDEX, new BulkItemResponse.Failure("nutch", "index", "failure0", new EsRejectedExecutionException("saturated")));        response = new BulkResponse(new BulkItemResponse[] { failed }, 0);    } else {                BulkItemResponse success = new BulkItemResponse(0, OpType.INDEX, new IndexResponse(new ShardId("nutch", UUID.randomUUID().toString(), 0), "index", "index0", 0, true));        response = new BulkResponse(new BulkItemResponse[] { success }, 0);    }    listener.onResponse((Response) response);}
acb2ee4b1e213e1bc7138b2b3d49b85791e6b170b446e20c48d97110948d1f78
makeClient
protected Client makeClient(IndexWriterParams parameters)
{    return client;}
d2f9b81b3967fd6262461fa5cfc17f367995df17c4a2c98bc27dd6edf7964539
bulkProcessorListener
protected BulkProcessor.Listener bulkProcessorListener()
{    return new BulkProcessor.Listener() {        @Override        public void afterBulk(long executionId, BulkRequest request, BulkResponse response) {            if (!response.hasFailures()) {                bulkRequestSuccessful = true;            }        }        @Override        public void afterBulk(long executionId, BulkRequest request, Throwable failure) {        }        @Override        public void beforeBulk(long executionId, BulkRequest request) {        }    };}
c8ed96f654ff1b9bf9864488fbf36fd9043ff7faeeed5938e921368c8dc0f849
afterBulk
public void afterBulk(long executionId, BulkRequest request, BulkResponse response)
{    if (!response.hasFailures()) {        bulkRequestSuccessful = true;    }}
eb853b976d9a67407f7f77eb05e2026c27863b6a9224f6d6b6cc017e0d6cd55c
afterBulk
public void afterBulk(long executionId, BulkRequest request, Throwable failure)
{}
cc0682d9c13ce3a8fede8c8aacd4382c37c1aa8640757eaa0222480c60774e89
beforeBulk
public void beforeBulk(long executionId, BulkRequest request)
{}
1ed9d1bc5bf4ec591559e60b8bfdf70c03c620331048f364c4b6ccc0ba74670d
testBulkMaxDocs
public void testBulkMaxDocs() throws IOException
{    int numDocs = 10;    conf.setInt(ElasticConstants.MAX_BULK_DOCS, numDocs);    @SuppressWarnings("unused")    Job job = Job.getInstance(conf);    Map<String, String> parameters = new HashMap<>();    parameters.put(ElasticConstants.CLUSTER, "nutch");    parameters.put(ElasticConstants.MAX_BULK_DOCS, String.valueOf(numDocs));    testIndexWriter.setConf(conf);    testIndexWriter.open(new IndexWriterParams(parameters));    NutchDocument doc = new NutchDocument();    doc.add("id", "http://www.example.com");    Assert.assertFalse(bulkRequestSuccessful);    for (int i = 0; i < numDocs; i++) {        testIndexWriter.write(doc);    }    testIndexWriter.close();    Assert.assertTrue(bulkRequestSuccessful);}
01947162dd7ebf27030b7882f22f56bb82da96f435b7bdf76d7665cfefca12a4
testBulkMaxLength
public void testBulkMaxLength() throws IOException
{    String key = "id";    String value = "http://www.example.com";    int defaultMaxBulkLength = conf.getInt(ElasticConstants.MAX_BULK_LENGTH, 2500500);        int testMaxBulkLength = defaultMaxBulkLength / 10;                int numDocs = testMaxBulkLength / (key.length() + value.length());    conf.setInt(ElasticConstants.MAX_BULK_LENGTH, testMaxBulkLength);    @SuppressWarnings("unused")    Job job = Job.getInstance(conf);    Map<String, String> parameters = new HashMap<>();    parameters.put(ElasticConstants.CLUSTER, "nutch");    parameters.put(ElasticConstants.MAX_BULK_LENGTH, String.valueOf(testMaxBulkLength));    testIndexWriter.setConf(conf);    testIndexWriter.open(new IndexWriterParams(parameters));    NutchDocument doc = new NutchDocument();    doc.add(key, value);    Assert.assertFalse(bulkRequestSuccessful);    for (int i = 0; i < numDocs; i++) {        testIndexWriter.write(doc);    }    testIndexWriter.close();    Assert.assertTrue(bulkRequestSuccessful);}
337ef3e3867b964309442edc69b6d1b82a6ca8cd7809d8e8e6f23ebdc137308f
testBackoffPolicy
public void testBackoffPolicy() throws IOException
{        maxNumFailures = 5;    conf.setInt(ElasticConstants.EXPONENTIAL_BACKOFF_RETRIES, maxNumFailures);    int numDocs = 10;    conf.setInt(ElasticConstants.MAX_BULK_DOCS, numDocs);    @SuppressWarnings("unused")    Job job = Job.getInstance(conf);    Map<String, String> parameters = new HashMap<>();    parameters.put(ElasticConstants.CLUSTER, "nutch");    parameters.put(ElasticConstants.EXPONENTIAL_BACKOFF_RETRIES, String.valueOf(maxNumFailures));    parameters.put(ElasticConstants.MAX_BULK_DOCS, String.valueOf(numDocs));    testIndexWriter.setConf(conf);    testIndexWriter.open(new IndexWriterParams(parameters));    NutchDocument doc = new NutchDocument();    doc.add("id", "http://www.example.com");        clusterSaturated = true;    Assert.assertFalse(bulkRequestSuccessful);        for (int i = 0; i < numDocs; i++) {        testIndexWriter.write(doc);    }    testIndexWriter.close();        Assert.assertTrue(bulkRequestSuccessful);}
18802229aeca38b5cc61ddfa505a9bf38ba2840d5872fa162a646fc53b96b5ec
open
public void open(Configuration conf, String name) throws IOException
{}
9746fe850d12df7589dd17844620372be3034171f9d6cd0d0e0b5dccf4fd0244
open
public void open(IndexWriterParams parameters) throws IOException
{    host = parameters.get(ElasticRestConstants.HOST);    if (StringUtils.isBlank(host)) {        String message = "Missing host. It should be set in index-writers.xml";        message += "\n" + describe();        LOG.error(message);        throw new RuntimeException(message);    }    port = parameters.getInt(ElasticRestConstants.PORT, 9200);    user = parameters.get(ElasticRestConstants.USER);    password = parameters.get(ElasticRestConstants.PASSWORD);    https = parameters.getBoolean(ElasticRestConstants.HTTPS, false);    trustAllHostnames = parameters.getBoolean(ElasticRestConstants.HOSTNAME_TRUST, false);    languages = parameters.getStrings(ElasticRestConstants.LANGUAGES);    separator = parameters.get(ElasticRestConstants.SEPARATOR, DEFAULT_SEPARATOR);    sink = parameters.get(ElasticRestConstants.SINK, DEFAULT_SINK);        SSLContext sslContext = null;    try {        sslContext = new SSLContextBuilder().loadTrustMaterial(new TrustStrategy() {            public boolean isTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {                return true;            }        }).build();    } catch (NoSuchAlgorithmException | KeyManagementException | KeyStoreException e) {        LOG.error("Failed to instantiate sslcontext object: \n{}", ExceptionUtils.getStackTrace(e));        throw new SecurityException();    }        HostnameVerifier hostnameVerifier = null;    if (trustAllHostnames) {        hostnameVerifier = NoopHostnameVerifier.INSTANCE;    } else {        hostnameVerifier = new DefaultHostnameVerifier();    }    SSLConnectionSocketFactory sslSocketFactory = new SSLConnectionSocketFactory(sslContext);    SchemeIOSessionStrategy httpsIOSessionStrategy = new SSLIOSessionStrategy(sslContext, hostnameVerifier);    JestClientFactory jestClientFactory = new JestClientFactory();    URL urlOfElasticsearchNode = new URL(https ? "https" : "http", host, port, "");    if (host != null && port > 1) {        HttpClientConfig.Builder builder = new HttpClientConfig.Builder(urlOfElasticsearchNode.toString()).multiThreaded(true).connTimeout(300000).readTimeout(300000);        if (https) {            if (user != null && password != null) {                builder.defaultCredentials(user, password);            }            builder.defaultSchemeForDiscoveredNodes("https").sslSocketFactory(            sslSocketFactory).httpsIOSessionStrategy(            httpsIOSessionStrategy);        }        jestClientFactory.setHttpClientConfig(builder.build());    } else {        throw new IllegalStateException("No host or port specified. Please set the host and port in nutch-site.xml");    }    client = jestClientFactory.getObject();    defaultIndex = parameters.get(ElasticRestConstants.INDEX, "nutch");    defaultType = parameters.get(ElasticRestConstants.TYPE, "doc");    maxBulkDocs = parameters.getInt(ElasticRestConstants.MAX_BULK_DOCS, DEFAULT_MAX_BULK_DOCS);    maxBulkLength = parameters.getInt(ElasticRestConstants.MAX_BULK_LENGTH, DEFAULT_MAX_BULK_LENGTH);    bulkBuilder = new Bulk.Builder().defaultIndex(defaultIndex).defaultType(defaultType);}
f7026b5119fff35c6baaa4262f619057ce5721ba60a7e9fd664273b0b7467451
isTrusted
public boolean isTrusted(X509Certificate[] arg0, String arg1) throws CertificateException
{    return true;}
f2155fc203a08e055aa5ff34fdd2731e8d0b71490eba0b68727175906c41c714
normalizeValue
private static Object normalizeValue(Object value)
{    if (value == null) {        return null;    }    if (value instanceof Map || value instanceof Date) {        return value;    }    return value.toString();}
74ee4a060942b9a364cf3176d078a605623c67f28d08d73cb9323276cbd56798
write
public void write(NutchDocument doc) throws IOException
{    String id = (String) doc.getFieldValue("id");    String type = doc.getDocumentMeta().get("type");    if (type == null) {        type = defaultType;    }    Map<String, Object> source = new HashMap<String, Object>();        for (String fieldName : doc.getFieldNames()) {        Set<Object> allFieldValues = new LinkedHashSet<>(doc.getField(fieldName).getValues());        if (allFieldValues.size() > 1) {            Object[] normalizedFieldValues = allFieldValues.stream().map(ElasticRestIndexWriter::normalizeValue).toArray();                        for (Object value : normalizedFieldValues) {                bulkLength += value.toString().length();            }            source.put(fieldName, normalizedFieldValues);        } else if (allFieldValues.size() == 1) {            Object normalizedFieldValue = normalizeValue(allFieldValues.iterator().next());            source.put(fieldName, normalizedFieldValue);            bulkLength += normalizedFieldValue.toString().length();        }    }    String index;    if (languages != null && languages.length > 0) {        String language = (String) doc.getFieldValue("lang");        boolean exists = false;        for (String lang : languages) {            if (lang.equals(language)) {                exists = true;                break;            }        }        if (exists) {            index = getLanguageIndexName(language);        } else {            index = getSinkIndexName();        }    } else {        index = defaultIndex;    }    Index indexRequest = new Index.Builder(source).index(index).type(type).id(id).build();        bulkBuilder.addAction(indexRequest);    indexedDocs++;    bulkDocs++;    if (bulkDocs >= maxBulkDocs || bulkLength >= maxBulkLength) {        LOG.info("Processing bulk request [docs = {}, length = {}, total docs = {}, last doc in bulk = '{}']", bulkDocs, bulkLength, indexedDocs, id);                createNewBulk = true;        commit();    }}
dea506e2ed0c9b5f5198b693294dc12a256d914241f20c24393244b56d304554
delete
public void delete(String key) throws IOException
{    try {        if (languages != null && languages.length > 0) {            Bulk.Builder bulkBuilder = new Bulk.Builder().defaultType(defaultType);            for (String lang : languages) {                bulkBuilder.addAction(new Delete.Builder(key).index(getLanguageIndexName(lang)).type(defaultType).build());            }            bulkBuilder.addAction(new Delete.Builder(key).index(getSinkIndexName()).type(defaultType).build());            client.execute(bulkBuilder.build());        } else {            client.execute(new Delete.Builder(key).index(defaultIndex).type(defaultType).build());        }    } catch (IOException e) {        LOG.error(ExceptionUtils.getStackTrace(e));        throw e;    }}
7b17c91d90b92c38f88e0fd76dcf4a9477e38972e89e874237b0ee939c14c40d
update
public void update(NutchDocument doc) throws IOException
{    try {        write(doc);    } catch (IOException e) {        LOG.error(ExceptionUtils.getStackTrace(e));        throw e;    }}
9686b51f14ae68fc049f472c7635d5385053dc8384dae21aaed20cdf86644fa0
commit
public void commit() throws IOException
{    if (basicFuture != null) {                long beforeWait = System.currentTimeMillis();        try {            JestResult result = basicFuture.get();            if (result == null) {                throw new RuntimeException();            }            long msWaited = System.currentTimeMillis() - beforeWait;            LOG.info("Previous took in ms {}, including wait {}", millis, msWaited);        } catch (InterruptedException | ExecutionException e) {            LOG.error("Error waiting for result ", e);        }        basicFuture = null;    }    if (bulkBuilder != null) {        if (bulkDocs > 0) {                        basicFuture = new BasicFuture<>(null);            millis = System.currentTimeMillis();            client.executeAsync(bulkBuilder.build(), new JestResultHandler<BulkResult>() {                @Override                public void completed(BulkResult bulkResult) {                    basicFuture.completed(bulkResult);                    millis = System.currentTimeMillis() - millis;                }                @Override                public void failed(Exception e) {                    basicFuture.completed(null);                    LOG.error("Failed result: ", e);                }            });        }        bulkBuilder = null;    }    if (createNewBulk) {                bulkBuilder = new Bulk.Builder().defaultIndex(defaultIndex).defaultType(defaultType);        bulkDocs = 0;        bulkLength = 0;    }}
ec0f28477a4de38ff01921872ea96396034bbe33df8475e5c47b3bddcfc189f9
completed
public void completed(BulkResult bulkResult)
{    basicFuture.completed(bulkResult);    millis = System.currentTimeMillis() - millis;}
c541dfe707013692e5ed6bf34c24fbf415df0ec01543867bccf879c3dc4fb637
failed
public void failed(Exception e)
{    basicFuture.completed(null);    LOG.error("Failed result: ", e);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{        LOG.info("Processing remaining requests [docs = {}, length = {}, total docs = {}]", bulkDocs, bulkLength, indexedDocs);    createNewBulk = false;    commit();        LOG.info("Processing to finalize last execute");    createNewBulk = false;    commit();        client.shutdownClient();}
9cff91000036512f05d409feb972bf85fa9ea8b92b401fe5769452ea0ea9ff2e
describe
public Map<String, Map.Entry<String, Object>> describe()
{    Map<String, Map.Entry<String, Object>> properties = new LinkedHashMap<>();    properties.put(ElasticRestConstants.HOST, new AbstractMap.SimpleEntry<>("The hostname or a list of comma separated hostnames to send documents " + "to using Elasticsearch Jest. Both host and port must be defined.", this.host));    properties.put(ElasticRestConstants.PORT, new AbstractMap.SimpleEntry<>("The port to connect to using Elasticsearch Jest.", this.port));    properties.put(ElasticRestConstants.INDEX, new AbstractMap.SimpleEntry<>("Default index to send documents to.", this.defaultIndex));    properties.put(ElasticRestConstants.MAX_BULK_DOCS, new AbstractMap.SimpleEntry<>("Maximum size of the bulk in number of documents.", this.maxBulkDocs));    properties.put(ElasticRestConstants.MAX_BULK_LENGTH, new AbstractMap.SimpleEntry<>("Maximum size of the bulk in bytes.", this.maxBulkLength));    properties.put(ElasticRestConstants.USER, new AbstractMap.SimpleEntry<>("Username for auth credentials (only used when https is enabled)", this.user));    properties.put(ElasticRestConstants.PASSWORD, new AbstractMap.SimpleEntry<>("Password for auth credentials (only used when https is enabled)", this.password));    properties.put(ElasticRestConstants.TYPE, new AbstractMap.SimpleEntry<>("Default type to send documents to.", this.defaultType));    properties.put(ElasticRestConstants.HTTPS, new AbstractMap.SimpleEntry<>("true to enable https, false to disable https. If you've disabled http " + "access (by forcing https), be sure to set this to true, otherwise " + "you might get \"connection reset by peer\".", this.https));    properties.put(ElasticRestConstants.HOSTNAME_TRUST, new AbstractMap.SimpleEntry<>("true to trust elasticsearch server's certificate even if its listed " + "domain name does not match the domain they are hosted or false " + "to check if the elasticsearch server's certificate's listed " + "domain is the same domain that it is hosted on, and if " + "it doesn't, then fail to index (only used when https is enabled)", this.trustAllHostnames));    properties.put(ElasticRestConstants.LANGUAGES, new AbstractMap.SimpleEntry<>("A list of strings denoting the supported languages (e.g. en, de, fr, it). " + "If this value is empty all documents will be sent to index property. " + "If not empty the Rest client will distribute documents in different " + "indices based on their languages property. Indices are named with the " + "following schema: index separator language (e.g. nutch_de). " + "Entries with an unsupported languages value will be added to " + "index index separator sink (e.g. nutch_others).", this.languages == null ? "" : String.join(",", languages)));    properties.put(ElasticRestConstants.SEPARATOR, new AbstractMap.SimpleEntry<>("Is used only if languages property is defined to build the index name " + "(i.e. index separator lang).", this.separator));    properties.put(ElasticRestConstants.SINK, new AbstractMap.SimpleEntry<>("Is used only if languages property is defined to build the index name " + "where to store documents with unsupported languages " + "(i.e. index separator sink).", this.sink));    return properties;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    config = conf;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return config;}
773c8842ecbda221c304d21fca8f353b692b656c5897d409b41f84d6dd632272
getLanguageIndexName
private String getLanguageIndexName(String lang)
{    return getComposedIndexName(defaultIndex, lang);}
1a2292c247a5d4a68fcf354b28113731b3068659bb47edbe7fc2e6dff03d2461
getSinkIndexName
private String getSinkIndexName()
{    return getComposedIndexName(defaultIndex, sink);}
66df53e10f359adecd8c2be166b3965a6bc6ddb9aa9244f4c846162bda6aece6
getComposedIndexName
private String getComposedIndexName(String prefix, String postfix)
{    return prefix + separator + postfix;}
4824c2ffd56dc3ee95f66cdf32259e9aab2a1d00086cde42bbfede97513c4b75
open
public void open(Configuration job, String name) throws IOException
{}
6d4a25e9e94670bd80a3ccd0ce7d1da9cd54b81a709578e748b8f8b084a5c419
open
public void open(IndexWriterParams params) throws IOException
{    host = params.get(KafkaConstants.HOST);    port = params.getInt(KafkaConstants.PORT, 9092);    keySerializer = params.get(KafkaConstants.KEY_SERIALIZER, "org.apache.kafka.common.serialization.ByteArraySerializer");    valueSerializer = params.get(KafkaConstants.VALUE_SERIALIZER, "org.apache.kafka.connect.json.JsonSerializer");    topic = params.get(KafkaConstants.TOPIC);    maxDocCount = params.getInt(KafkaConstants.MAX_DOC_COUNT, 100);    inputDocs = new ArrayList<ProducerRecord<String, JsonNode>>(maxDocCount);    if (StringUtils.isBlank(host)) {        String message = "Missing host. It should be set in index-writers.xml";        message += "\n" + describe();        LOG.error(message);        throw new RuntimeException(message);    }    Properties configProperties = new Properties();    configProperties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, host + ":" + port);    configProperties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, keySerializer);    configProperties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, valueSerializer);    Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader());    producer = new KafkaProducer<String, JsonNode>(configProperties);}
74ee4a060942b9a364cf3176d078a605623c67f28d08d73cb9323276cbd56798
write
public void write(NutchDocument doc) throws IOException
{    Map<String, Object> source = new HashMap<String, Object>();        for (String fieldName : doc.getFieldNames()) {        Set<String> allFieldValues = new HashSet<String>();        for (Object value : doc.getField(fieldName).getValues()) {            allFieldValues.add(value.toString());        }        String[] fieldValues = allFieldValues.toArray(new String[allFieldValues.size()]);        source.put(fieldName, fieldValues);    }    try {        jsonString = new ObjectMapper().writeValueAsString(source);        json = new ObjectMapper().readTree(jsonString);        data = new ProducerRecord<String, JsonNode>(topic, json);        inputDocs.add(data);        if (inputDocs.size() == maxDocCount) {            commit();        }    } catch (NullPointerException e) {        LOG.info("Data is empty, all messages have been sent");    }}
dea506e2ed0c9b5f5198b693294dc12a256d914241f20c24393244b56d304554
delete
public void delete(String key) throws IOException
{}
7b17c91d90b92c38f88e0fd76dcf4a9477e38972e89e874237b0ee939c14c40d
update
public void update(NutchDocument doc) throws IOException
{    try {        write(doc);    } catch (IOException e) {        LOG.error(ExceptionUtils.getStackTrace(e));        throw e;    }}
9686b51f14ae68fc049f472c7635d5385053dc8384dae21aaed20cdf86644fa0
commit
public void commit() throws IOException
{    try {        for (ProducerRecord<String, JsonNode> datum : inputDocs) {            producer.send(datum);        }        inputDocs.clear();    } catch (NullPointerException e) {        LOG.info("All records have been sent to Kakfa on topic {}", topic);    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    commit();    producer.close();}
9cff91000036512f05d409feb972bf85fa9ea8b92b401fe5769452ea0ea9ff2e
describe
public Map<String, Map.Entry<String, Object>> describe()
{    Map<String, Map.Entry<String, Object>> properties = new LinkedHashMap<>();    properties.put(KafkaConstants.HOST, new AbstractMap.SimpleEntry<>("Location of the host Kafka cluster to connect to using producerConfig", this.host));    properties.put(KafkaConstants.PORT, new AbstractMap.SimpleEntry<>("The port to connect to using the producerConfig", this.port));    properties.put(KafkaConstants.TOPIC, new AbstractMap.SimpleEntry<>("Default index to attach to documents", this.topic));    properties.put(KafkaConstants.KEY_SERIALIZER, new AbstractMap.SimpleEntry<>("instruct how to turn the key object the user provides with their ProducerRecord into bytes", this.keySerializer));    properties.put(KafkaConstants.VALUE_SERIALIZER, new AbstractMap.SimpleEntry<>("instruct how to turn the value object the user provides with their ProducerRecord into bytes", this.valueSerializer));    properties.put(KafkaConstants.MAX_DOC_COUNT, new AbstractMap.SimpleEntry<>("Maximum number of documents before a commit is forced", this.maxDocCount));    return properties;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    config = conf;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return config;}
8650812d25b012c87d4b5ca186566e8b2776827b5c5d3c5f5f7fed3bb351efa3
getFields
 List<RabbitDocumentField> getFields()
{    return fields;}
17ef3ab5a48ea6a31caefdc08d3145485a4423421e44f4498ca5c9fc74f6522b
setDocumentBoost
 void setDocumentBoost(float documentBoost)
{    this.documentBoost = documentBoost;}
3cb34dd4ced35566f12f27c0ac74d43456409cd96bff94c3731e043c1766784d
addField
 void addField(RabbitDocumentField field)
{    fields.add(field);}
322b556d6b6be351984ae699ef56a78052e54de31d99ac5e00a1f107d7cd4995
getBytes
 byte[] getBytes()
{    Gson gson = new Gson();    return gson.toJson(this).getBytes();}
71dcee8caa732fdfbbc9042fbd951dc9dfd911ed9a4cabf0966856ac5de53dfc
getKey
public String getKey()
{    return key;}
76b6456b4fd6bdb2e44bd7bf7e9dd35e8cae33d4ea82d162fd99f4dc247e8bc3
getValues
public List<Object> getValues()
{    return values;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return config;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    config = conf;}
18802229aeca38b5cc61ddfa505a9bf38ba2840d5872fa162a646fc53b96b5ec
open
public void open(Configuration conf, String name) throws IOException
{}
9746fe850d12df7589dd17844620372be3034171f9d6cd0d0e0b5dccf4fd0244
open
public void open(IndexWriterParams parameters) throws IOException
{    exchange = parameters.get(RabbitMQConstants.EXCHANGE_NAME);    routingKey = parameters.get(RabbitMQConstants.ROUTING_KEY);    commitSize = parameters.getInt(RabbitMQConstants.COMMIT_SIZE, 250);    commitMode = parameters.get(RabbitMQConstants.COMMIT_MODE, "multiple");    headersStatic = parameters.get(RabbitMQConstants.HEADERS_STATIC, "");    headersDynamic = Arrays.asList(parameters.getStrings(RabbitMQConstants.HEADERS_DYNAMIC, ""));    uri = parameters.get(RabbitMQConstants.SERVER_URI);    client = new RabbitMQClient(uri);    client.openChannel();    binding = parameters.getBoolean(RabbitMQConstants.BINDING, false);    if (binding) {        queueName = parameters.get(RabbitMQConstants.QUEUE_NAME);        queueOptions = parameters.get(RabbitMQConstants.QUEUE_OPTIONS);        exchangeOptions = parameters.get(RabbitMQConstants.EXCHANGE_OPTIONS);        bindingArguments = parameters.get(RabbitMQConstants.BINDING_ARGUMENTS, "");        client.bind(exchange, exchangeOptions, queueName, queueOptions, routingKey, bindingArguments);    }}
74ee4a060942b9a364cf3176d078a605623c67f28d08d73cb9323276cbd56798
write
public void write(NutchDocument doc) throws IOException
{    RabbitDocument rabbitDocument = new RabbitDocument();    for (final Map.Entry<String, NutchField> e : doc) {        RabbitDocument.RabbitDocumentField field = new RabbitDocument.RabbitDocumentField(e.getKey(), e.getValue().getWeight(), e.getValue().getValues());        rabbitDocument.addField(field);    }    rabbitDocument.setDocumentBoost(doc.getWeight());    rabbitMessage.addDocToWrite(rabbitDocument);    if (rabbitMessage.size() >= commitSize) {        commit();    }}
7d6d2abb7eee5891ae596f31ca167e73e2ea74b84c0df71e5049cf6fb44dcc22
delete
public void delete(String url) throws IOException
{    rabbitMessage.addDocToDelete(url);    if (rabbitMessage.size() >= commitSize) {        commit();    }}
7b17c91d90b92c38f88e0fd76dcf4a9477e38972e89e874237b0ee939c14c40d
update
public void update(NutchDocument doc) throws IOException
{    RabbitDocument rabbitDocument = new RabbitDocument();    for (final Map.Entry<String, NutchField> e : doc) {        RabbitDocument.RabbitDocumentField field = new RabbitDocument.RabbitDocumentField(e.getKey(), e.getValue().getWeight(), e.getValue().getValues());        rabbitDocument.addField(field);    }    rabbitDocument.setDocumentBoost(doc.getWeight());    rabbitMessage.addDocToUpdate(rabbitDocument);    if (rabbitMessage.size() >= commitSize) {        commit();    }}
9686b51f14ae68fc049f472c7635d5385053dc8384dae21aaed20cdf86644fa0
commit
public void commit() throws IOException
{    if (!rabbitMessage.isEmpty()) {        if ("single".equals(commitMode)) {                        for (String s : rabbitMessage.getDocsToDelete()) {                RabbitMQMessage message = new RabbitMQMessage();                message.setBody(s.getBytes());                message.setHeaders(headersStatic);                message.addHeader("action", "delete");                client.publish(exchange, routingKey, message);            }                        for (RabbitDocument rabbitDocument : rabbitMessage.getDocsToUpdate()) {                RabbitMQMessage message = new RabbitMQMessage();                message.setBody(rabbitDocument.getBytes());                addHeaders(message, rabbitDocument);                message.addHeader("action", "update");                client.publish(exchange, routingKey, message);            }                        for (RabbitDocument rabbitDocument : rabbitMessage.getDocsToWrite()) {                RabbitMQMessage message = new RabbitMQMessage();                message.setBody(rabbitDocument.getBytes());                addHeaders(message, rabbitDocument);                message.addHeader("action", "write");                client.publish(exchange, routingKey, message);            }        } else {            RabbitMQMessage message = new RabbitMQMessage();            message.setBody(rabbitMessage.getBytes());            message.setHeaders(headersStatic);            client.publish(exchange, routingKey, message);        }    }    rabbitMessage.clear();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{        commit();    client.close();}
9cff91000036512f05d409feb972bf85fa9ea8b92b401fe5769452ea0ea9ff2e
describe
public Map<String, Map.Entry<String, Object>> describe()
{    Map<String, Map.Entry<String, Object>> properties = new LinkedHashMap<>();    properties.put(RabbitMQConstants.SERVER_URI, new AbstractMap.SimpleEntry<>("URI with connection parameters in the form amqp://<username>:<password>@<hostname>:<port>/<virtualHost>", this.uri));    properties.put(RabbitMQConstants.BINDING, new AbstractMap.SimpleEntry<>("Whether the relationship between an exchange and a queue is created automatically. " + "NOTE: Binding between exchanges is not supported.", this.binding));    properties.put(RabbitMQConstants.BINDING_ARGUMENTS, new AbstractMap.SimpleEntry<>("Arguments used in binding. It must have the form key1=value1,key2=value2. " + "This value is only used when the exchange's type is headers and " + "the value of binding property is true. In other cases is ignored.", this.bindingArguments));    properties.put(RabbitMQConstants.EXCHANGE_NAME, new AbstractMap.SimpleEntry<>("Name for the exchange where the messages will be sent.", this.exchange));    properties.put(RabbitMQConstants.EXCHANGE_OPTIONS, new AbstractMap.SimpleEntry<>("Options used when the exchange is created. Only used when the value of binding property is true. " + "It must have the form type=<type>,durable=<durable>", this.exchangeOptions));    properties.put(RabbitMQConstants.QUEUE_NAME, new AbstractMap.SimpleEntry<>("Name of the queue used to create the binding. Only used when the value " + "of binding property is true.", this.queueName));    properties.put(RabbitMQConstants.QUEUE_OPTIONS, new AbstractMap.SimpleEntry<>("Options used when the queue is created. Only used when the value of " + "binding property is true. It must have the form " + "durable=<durable>,exclusive=<exclusive>,auto-delete=<auto-delete>,arguments=<arguments>", this.queueOptions));    properties.put(RabbitMQConstants.ROUTING_KEY, new AbstractMap.SimpleEntry<>("The routing key used to route messages in the exchange. " + "It only makes sense when the exchange type is topic or direct.", this.routingKey));    properties.put(RabbitMQConstants.COMMIT_MODE, new AbstractMap.SimpleEntry<>("single if a message contains only one document. " + "In this case, a header with the action (write, update or delete) will be added. " + "multiple if a message contains all documents.", this.commitMode));    properties.put(RabbitMQConstants.COMMIT_SIZE, new AbstractMap.SimpleEntry<>("Amount of documents to send into each message if the value of commit.mode " + "property is multiple. In single mode this value represents " + "the amount of messages to be sent.", this.commitSize));    properties.put(RabbitMQConstants.HEADERS_STATIC, new AbstractMap.SimpleEntry<>("Headers to add to each message. It must have the form key1=value1,key2=value2.", this.headersStatic));    properties.put(RabbitMQConstants.HEADERS_DYNAMIC, new AbstractMap.SimpleEntry<>("Document's fields to add as headers to each message. " + "It must have the form field1,field2. " + "Only used when the value of commit.mode property is single", this.headersDynamic));    return properties;}
b4b9ce1ca0a38907042db661861eee06f3e3730e9684847882d62fd55d067f02
addHeaders
private void addHeaders(final RabbitMQMessage message, RabbitDocument document)
{    message.setHeaders(headersStatic);    for (RabbitDocument.RabbitDocumentField rabbitDocumentField : document.getFields()) {        if (headersDynamic.contains(rabbitDocumentField.getKey())) {            message.addHeader(rabbitDocumentField.getKey(), rabbitDocumentField.getValues().get(0));        }    }}
b61e7cbcb89303969fa964f2553107ad355a313a7f48f9554ec791499e51e839
addDocToWrite
 boolean addDocToWrite(RabbitDocument doc)
{    return docsToWrite.add(doc);}
8fe5ecbc16b9045c416621ddcdee5b63f35c671f46cab543bea691e49bb5aca7
addDocToUpdate
 boolean addDocToUpdate(RabbitDocument doc)
{    return docsToUpdate.add(doc);}
dc46eb1c5cb700c3ac9a0a037a066232be1138751892c7796e801e0c8a6b4977
addDocToDelete
 boolean addDocToDelete(String url)
{    return docsToDelete.add(url);}
322b556d6b6be351984ae699ef56a78052e54de31d99ac5e00a1f107d7cd4995
getBytes
 byte[] getBytes()
{    Gson gson = new Gson();    return gson.toJson(this).getBytes();}
d022d4c8e30dae80d047906393039bcb0807c3aec2567ce5ef0b40afeca60b65
isEmpty
 boolean isEmpty()
{    return docsToWrite.isEmpty() && docsToUpdate.isEmpty() && docsToDelete.isEmpty();}
fc348a48e0c2920424ad3f023b347879ee0b7f1149e88e46308646ee3f609211
getDocsToWrite
public List<RabbitDocument> getDocsToWrite()
{    return docsToWrite;}
96f42f3de895d532a61a4261df3ad9ec2778a6bde45d4aefbf81efd2dc5e5268
getDocsToUpdate
public List<RabbitDocument> getDocsToUpdate()
{    return docsToUpdate;}
ccd205258d33ff888270f1e7915d4aea14f3f5e768c5b8f8d707de4deea8a780
getDocsToDelete
public List<String> getDocsToDelete()
{    return docsToDelete;}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return docsToWrite.size() + docsToUpdate.size() + docsToDelete.size();}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    docsToWrite.clear();    docsToUpdate.clear();    docsToDelete.clear();}
74796c2bf6441a92e85f86b518809ea254fa4ec996a71c7ba55f4bace25e0696
open
public void open(Configuration conf, String name)
{}
7442a943738a1ba8766012e090ac3c341962861bb8563e9ccd06005c45f3273e
open
public void open(IndexWriterParams parameters)
{    this.type = parameters.get(SolrConstants.SERVER_TYPE, "http");    this.urls = parameters.getStrings(SolrConstants.SERVER_URLS);    this.collection = parameters.get(SolrConstants.COLLECTION);    if (urls == null) {        String message = "Missing SOLR URL.\n" + describe();        LOG.error(message);        throw new RuntimeException(message);    }    this.auth = parameters.getBoolean(SolrConstants.USE_AUTH, false);    this.username = parameters.get(SolrConstants.USERNAME);    this.password = parameters.get(SolrConstants.PASSWORD);    this.solrClients = new ArrayList<>();    switch(type) {        case "http":            for (String url : urls) {                solrClients.add(SolrUtils.getHttpSolrClient(url));            }            break;        case "cloud":            CloudSolrClient sc = this.auth ? SolrUtils.getCloudSolrClient(Arrays.asList(urls), this.username, this.password) : SolrUtils.getCloudSolrClient(Arrays.asList(urls));            sc.setDefaultCollection(this.collection);            solrClients.add(sc);            break;        case "concurrent":                        throw new UnsupportedOperationException("The type \"concurrent\" is not yet supported.");        case "lb":                        throw new UnsupportedOperationException("The type \"lb\" is not yet supported.");        default:            throw new IllegalArgumentException("The type \"" + type + "\" is not supported.");    }    init(parameters);}
6b9ff1a249554cf9c6fb5a3b1eec9ad02272b7c10c1f2674aeda6fb3c367addd
init
private void init(IndexWriterParams properties)
{    batchSize = properties.getInt(SolrConstants.COMMIT_SIZE, 1000);    delete = config.getBoolean(IndexerMapReduce.INDEXER_DELETE, false);    weightField = properties.get(SolrConstants.WEIGHT_FIELD, "");        params = new ModifiableSolrParams();    String paramString = config.get(IndexerMapReduce.INDEXER_PARAMS);    if (paramString != null) {        String[] values = paramString.split("&");        for (String v : values) {            String[] kv = v.split("=");            if (kv.length < 2) {                continue;            }            params.add(kv[0], kv[1]);        }    }}
dea506e2ed0c9b5f5198b693294dc12a256d914241f20c24393244b56d304554
delete
public void delete(String key) throws IOException
{        key = key.replaceAll("!", "\\!");    if (delete) {        deleteIds.add(key);        totalDeletes++;    }    if (deleteIds.size() >= batchSize) {        push();    }}
7b17c91d90b92c38f88e0fd76dcf4a9477e38972e89e874237b0ee939c14c40d
update
public void update(NutchDocument doc) throws IOException
{    write(doc);}
74ee4a060942b9a364cf3176d078a605623c67f28d08d73cb9323276cbd56798
write
public void write(NutchDocument doc) throws IOException
{    final SolrInputDocument inputDoc = new SolrInputDocument();    for (final Entry<String, NutchField> e : doc) {        for (final Object val : e.getValue().getValues()) {                        Object val2 = val;            if (val instanceof Date) {                val2 = DateTimeFormatter.ISO_INSTANT.format(((Date) val).toInstant());            }            if (e.getKey().equals("content") || e.getKey().equals("title")) {                val2 = SolrUtils.stripNonCharCodepoints((String) val);            }            inputDoc.addField(e.getKey(), val2);        }    }    if (!weightField.isEmpty()) {        inputDoc.addField(weightField, doc.getWeight());    }    inputDocs.add(inputDoc);    totalAdds++;    if (inputDocs.size() + numDeletes >= batchSize) {        push();    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    commit();    for (SolrClient solrClient : solrClients) {        solrClient.close();    }}
9686b51f14ae68fc049f472c7635d5385053dc8384dae21aaed20cdf86644fa0
commit
public void commit() throws IOException
{    push();    try {        for (SolrClient solrClient : solrClients) {            if (this.auth) {                UpdateRequest req = new UpdateRequest();                req.setAction(UpdateRequest.ACTION.COMMIT, true, true);                req.setBasicAuthCredentials(this.username, this.password);                solrClient.request(req);            } else {                solrClient.commit();            }        }    } catch (final SolrServerException e) {        LOG.error("Failed to commit solr connection: " + e.getMessage());    }}
d7802ed9371793d9d7845a3fca4d4363ccd9fd8d83a087582637cf95e3a495d0
push
private void push() throws IOException
{    if (inputDocs.size() > 0) {        try {            LOG.info("Indexing " + Integer.toString(inputDocs.size()) + "/" + Integer.toString(totalAdds) + " documents");            LOG.info("Deleting " + Integer.toString(numDeletes) + " documents");            numDeletes = 0;            UpdateRequest req = new UpdateRequest();            req.add(inputDocs);            req.setAction(UpdateRequest.ACTION.OPTIMIZE, false, false);            req.setParams(params);            if (this.auth) {                req.setBasicAuthCredentials(this.username, this.password);            }            for (SolrClient solrClient : solrClients) {                solrClient.request(req);            }        } catch (final SolrServerException e) {            throw makeIOException(e);        }        inputDocs.clear();    }    if (deleteIds.size() > 0) {        try {            LOG.info("SolrIndexer: deleting " + Integer.toString(deleteIds.size()) + "/" + Integer.toString(totalDeletes) + " documents");            UpdateRequest req = new UpdateRequest();            req.deleteById(deleteIds);            req.setAction(UpdateRequest.ACTION.OPTIMIZE, false, false);            req.setParams(params);            if (this.auth) {                req.setBasicAuthCredentials(this.username, this.password);            }            for (SolrClient solrClient : solrClients) {                solrClient.request(req);            }        } catch (final SolrServerException e) {            LOG.error("Error deleting: " + deleteIds);            throw makeIOException(e);        }        deleteIds.clear();    }}
6c589f5337cd28727c952aca7f7ac67e4990a5495c709cbc888fbe17e4b84d64
makeIOException
private static IOException makeIOException(SolrServerException e)
{    return new IOException(e);}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return config;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    config = conf;}
acc15217d72b673533075a36521acb189a4f8630982257977ac2085164b86ddf
describe
public Map<String, Entry<String, Object>> describe()
{    Map<String, Entry<String, Object>> properties = new LinkedHashMap<>();    properties.put(SolrConstants.SERVER_TYPE, new AbstractMap.SimpleEntry<>("Specifies the SolrClient implementation to use. This is a string value of one of the following \"cloud\" or \"http\"." + " The values represent CloudSolrServer or HttpSolrServer respectively.", this.type));    properties.put(SolrConstants.SERVER_URLS, new AbstractMap.SimpleEntry<>("Defines the fully qualified URL of Solr into which data should be indexed. Multiple URL can be provided using comma as a delimiter." + " When the value of type property is cloud, the URL should not include any collections or cores; just the root Solr path.", this.urls == null ? "" : String.join(",", urls)));    properties.put(SolrConstants.COLLECTION, new AbstractMap.SimpleEntry<>("The collection used in requests. Only used when the value of type property is cloud.", this.collection));    properties.put(SolrConstants.COMMIT_SIZE, new AbstractMap.SimpleEntry<>("Defines the number of documents to send to Solr in a single update batch. " + "Decrease when handling very large documents to prevent Nutch from running out of memory.\n" + "Note: It does not explicitly trigger a server side commit.", this.batchSize));    properties.put(SolrConstants.WEIGHT_FIELD, new AbstractMap.SimpleEntry<>("Field's name where the weight of the documents will be written. If it is empty no field will be used.", this.weightField));    properties.put(SolrConstants.USE_AUTH, new AbstractMap.SimpleEntry<>("Whether to enable HTTP basic authentication for communicating with Solr. Use the username and password properties to configure your credentials.", this.auth));    properties.put(SolrConstants.USERNAME, new AbstractMap.SimpleEntry<>("The username of Solr server.", this.username));    properties.put(SolrConstants.PASSWORD, new AbstractMap.SimpleEntry<>("The password of Solr server.", this.password));    return properties;}
4e8f07f7c7f56621ccc4a4775a0b40e20bd260e80dfa3ca3ce5bb10a2c660c61
getCloudSolrClient
 static CloudSolrClient getCloudSolrClient(List<String> urls)
{    CloudSolrClient sc = new CloudSolrClient.Builder(urls).withParallelUpdates(true).build();    sc.connect();    return sc;}
401cdfd13e47be0293b89398373420a001e19ea343ca3fa8c0f7cf42ef328d2e
getCloudSolrClient
 static CloudSolrClient getCloudSolrClient(List<String> urls, String username, String password)
{        CredentialsProvider provider = new BasicCredentialsProvider();    UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(username, password);    provider.setCredentials(AuthScope.ANY, credentials);    HttpClient client = HttpClientBuilder.create().setDefaultCredentialsProvider(provider).build();        CloudSolrClient sc = new CloudSolrClient.Builder(urls).withParallelUpdates(true).withHttpClient(client).build();    sc.connect();    return sc;}
a2d439b49fee4188d0f0fbc9bcd058ccf5df964dbc4b18e96e19be8b211a409b
getHttpSolrClient
 static SolrClient getHttpSolrClient(String url)
{    return new HttpSolrClient.Builder(url).build();}
f0cea5bf44f9628ca7ffb301116071e9f7cdc288334c8b161ac39f83931f603c
stripNonCharCodepoints
 static String stripNonCharCodepoints(String input)
{    StringBuilder retval = new StringBuilder();    char ch;    for (int i = 0; i < input.length(); i++) {        ch = input.charAt(i);                if (        ch % 0x10000 != 0xffff &&         ch % 0x10000 != 0xfffe &&         (ch <= 0xfdd0 || ch >= 0xfdef) && (ch > 0x1F || ch == 0x9 || ch == 0xa || ch == 0xd)) {            retval.append(ch);        }    }    return retval.toString();}
9ff841f3d46425f0defcf4346027b52742d29abc435829a9bc29d5c88e553a7b
filter
public ParseResult filter(Content content, ParseResult parseResult, HTMLMetaTags metaTags, DocumentFragment doc)
{    String lang = null;    Parse parse = parseResult.get(content.getUrl());    if (detect >= 0 && identify < 0) {        lang = detectLanguage(parse, doc);    } else if (detect < 0 && identify >= 0) {        lang = identifyLanguage(parse);    } else if (detect < identify) {        lang = detectLanguage(parse, doc);        if (lang == null) {            lang = identifyLanguage(parse);        }    } else if (identify < detect) {        lang = identifyLanguage(parse);        if (lang == null) {            lang = detectLanguage(parse, doc);        }    } else {        LOG.warn("No configuration for language extraction policy is provided");        return parseResult;    }    if (lang != null) {        parse.getData().getParseMeta().set(Metadata.LANGUAGE, lang);        return parseResult;    }    return parseResult;}
c6dfdde419420e3c3d31e8a4be77b8db40e888bbfa19536d7be1abced0118ebb
detectLanguage
private String detectLanguage(Parse page, DocumentFragment doc)
{    String lang = getLanguageFromMetadata(page.getData().getParseMeta());    if (lang == null) {        LanguageParser parser = new LanguageParser(doc);        lang = parser.getLanguage();    }    if (lang != null) {        return lang;    }    lang = page.getData().getContentMeta().get(Response.CONTENT_LANGUAGE);    return lang;}
fd91c87191b15ae76dca94025d29364fbd1ddcdb6054255db871ec5583a9de14
identifyLanguage
private String identifyLanguage(Parse parse)
{    StringBuilder text = new StringBuilder();    if (parse == null)        return null;    String title = parse.getData().getTitle();    if (title != null) {        text.append(title.toString());    }    String content = parse.getText();    if (content != null) {        text.append(" ").append(content.toString());    }        String titleandcontent = text.toString();    if (this.contentMaxlength != -1 && titleandcontent.length() > this.contentMaxlength)        titleandcontent = titleandcontent.substring(0, contentMaxlength);    LanguageIdentifier identifier = new LanguageIdentifier(titleandcontent);    if (onlyCertain) {        if (identifier.isReasonablyCertain())            return identifier.getLanguage();        else            return null;    }    return identifier.getLanguage();}
678e0b53f4dc41359d7c1f0a94255d0f9c51160abf18afb42d1cae0088dfab4a
getLanguageFromMetadata
private static String getLanguageFromMetadata(Metadata meta)
{    if (meta == null)        return null;        String lang = meta.get("dc.language");    if (lang != null)        return lang;        lang = meta.get("content-language");    if (lang != null)        return lang;        return meta.get("lang");}
f6e56bf8835066507f032fdb29d8880da4e91ed3fb09470ad5a7157db113748e
getLanguage
 String getLanguage()
{    return language;}
ba2e270469884db16e4cfefa467e78f3b6ab6655009696df30749de12c84322f
parse
 void parse(Node node)
{    NodeWalker walker = new NodeWalker(node);    while (walker.hasNext()) {        Node currentNode = walker.nextNode();        String nodeName = currentNode.getNodeName();        short nodeType = currentNode.getNodeType();        if (nodeType == Node.ELEMENT_NODE) {                        if (htmlAttribute == null) {                htmlAttribute = parseLanguage(((Element) currentNode).getAttribute("lang"));            }                        if ("meta".equalsIgnoreCase(nodeName)) {                NamedNodeMap attrs = currentNode.getAttributes();                                if (dublinCore == null) {                    for (int i = 0; i < attrs.getLength(); i++) {                        Node attrnode = attrs.item(i);                        if ("name".equalsIgnoreCase(attrnode.getNodeName())) {                            if ("dc.language".equalsIgnoreCase(attrnode.getNodeValue())) {                                Node valueattr = attrs.getNamedItem("content");                                if (valueattr != null) {                                    dublinCore = parseLanguage(valueattr.getNodeValue());                                }                            }                        }                    }                }                                if (httpEquiv == null) {                    for (int i = 0; i < attrs.getLength(); i++) {                        Node attrnode = attrs.item(i);                        if ("http-equiv".equalsIgnoreCase(attrnode.getNodeName())) {                            if ("content-language".equals(attrnode.getNodeValue().toLowerCase())) {                                Node valueattr = attrs.getNamedItem("content");                                if (valueattr != null) {                                    httpEquiv = parseLanguage(valueattr.getNodeValue());                                }                            }                        }                    }                }            }        }        if ((dublinCore != null) && (htmlAttribute != null) && (httpEquiv != null)) {            return;        }    }}
1a43da4143bd182e0dfd95ad03341a0ba101a345beb8138ddb1eecdb5a7b02b2
parseLanguage
 static final String parseLanguage(String lang)
{    if (lang == null) {        return null;    }    String code = null;    String language = null;        String[] langs = lang.split(",| |;|\\.|\\(|\\)|=", -1);    int i = 0;    while ((language == null) && (i < langs.length)) {                code = langs[i].split("-")[0];        code = code.split("_")[0];                language = (String) LANGUAGES_MAP.get(code.toLowerCase());        i++;    }    return language;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    contentMaxlength = conf.getInt("lang.analyze.max.length", -1);    onlyCertain = conf.getBoolean("lang.identification.only.certain", false);    String[] policy = conf.getStrings("lang.extraction.policy");    for (int i = 0; i < policy.length; i++) {        if (policy[i].equals("detect")) {            detect = i;        } else if (policy[i].equals("identify")) {            identify = i;        }    }}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
8fa98404280fecfd497ce9400c07196998fbeaf2ee8524779c09bd3c220d4ea9
filter
public NutchDocument filter(NutchDocument doc, Parse parse, Text url, CrawlDatum datum, Inlinks inlinks) throws IndexingException
{        String lang = parse.getData().getParseMeta().get(Metadata.LANGUAGE);        if (lang == null) {        lang = parse.getData().getContentMeta().get(Response.CONTENT_LANGUAGE);    }    if (lang == null || lang.length() == 0) {        lang = "unknown";    }    if (!indexLangs.isEmpty() && !indexLangs.contains(lang)) {        return null;    }    doc.add("lang", lang);    return doc;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    indexLangs = new HashSet<>(conf.getStringCollection("lang.index.languages"));}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
acd99a2536c0afb48b1c5fb9eed3ee3b4ef7d889ba536333d7e32f08120cef15
testMetaHTMLParsing
public void testMetaHTMLParsing()
{    try {        ParseUtil parser = new ParseUtil(NutchConfiguration.create());        /* loop through the test documents and validate result */        for (int t = 0; t < docs.length; t++) {            Content content = getContent(docs[t]);            Parse parse = parser.parse(content).get(content.getUrl());            Assert.assertEquals(metalanguages[t], (String) parse.getData().getParseMeta().get(Metadata.LANGUAGE));        }    } catch (Exception e) {        e.printStackTrace(System.out);        Assert.fail(e.toString());    }}
9bfdf2884a8bff4e4766e21a850469c80af6d5d4d458c77dfacf35348fffd287
testParseLanguage
public void testParseLanguage()
{    String[][] tests = { { "(SCHEME=ISO.639-1) sv", "sv" }, { "(SCHEME=RFC1766) sv-FI", "sv" }, { "(SCHEME=Z39.53) SWE", "sv" }, { "EN_US, SV, EN, EN_UK", "en" }, { "English Swedish", "en" }, { "English, swedish", "en" }, { "English,Swedish", "en" }, { "Other (Svenska)", "sv" }, { "SE", "se" }, { "SV", "sv" }, { "SV charset=iso-8859-1", "sv" }, { "SV-FI", "sv" }, { "SV; charset=iso-8859-1", "sv" }, { "SVE", "sv" }, { "SW", "sw" }, { "SWE", "sv" }, { "SWEDISH", "sv" }, { "Sv", "sv" }, { "Sve", "sv" }, { "Svenska", "sv" }, { "Swedish", "sv" }, { "Swedish, svenska", "sv" }, { "en, sv", "en" }, { "sv", "sv" }, { "sv, be, dk, de, fr, no, pt, ch, fi, en", "sv" }, { "sv,en", "sv" }, { "sv-FI", "sv" }, { "sv-SE", "sv" }, { "sv-en", "sv" }, { "sv-fi", "sv" }, { "sv-se", "sv" }, { "sv; Content-Language: sv", "sv" }, { "sv_SE", "sv" }, { "sve", "sv" }, { "svenska, swedish, engelska, english", "sv" }, { "sw", "sw" }, { "swe", "sv" }, { "swe.SPR.", "sv" }, { "sweden", "sv" }, { "swedish", "sv" }, { "swedish,", "sv" }, { "text/html; charset=sv-SE", "sv" }, { "text/html; sv", "sv" }, { "torp, stuga, uthyres, bed & breakfast", null } };    for (int i = 0; i < 44; i++) {        Assert.assertEquals(tests[i][1], HTMLLanguageParser.LanguageParser.parseLanguage(tests[i][0]));    }}
49a43c8f87ca06bc187513a5afe65a64d903372ca26c860cd40126af9291c380
getContent
private Content getContent(String text)
{    Metadata meta = new Metadata();    meta.add("Content-Type", "text/html");    return new Content(URL, BASE, text.getBytes(), "text/html", meta, NutchConfiguration.create());}
71588053e5c095de32d7ab6d68059acde3784e21be909a1538a2a3cc7d9221e9
testLanguageIndentifier
public void testLanguageIndentifier()
{    try {        long total = 0;        LanguageIdentifier identifier;        BufferedReader in = new BufferedReader(new InputStreamReader(this.getClass().getResourceAsStream("test-referencial.txt")));        String line = null;        while ((line = in.readLine()) != null) {            String[] tokens = line.split(";");            if (!tokens[0].equals("")) {                StringBuilder content = new StringBuilder();                                BufferedReader testFile = new BufferedReader(new InputStreamReader(this.getClass().getResourceAsStream(tokens[0]), "UTF-8"));                String testLine = null, lang = null;                while ((testLine = testFile.readLine()) != null) {                    content.append(testLine + "\n");                    testLine = testLine.trim();                    if (testLine.length() > 256) {                        identifier = new LanguageIdentifier(testLine);                        lang = identifier.getLanguage();                        Assert.assertEquals(tokens[1], lang);                    }                }                testFile.close();                                long start = System.currentTimeMillis();                System.out.println(content.toString());                identifier = new LanguageIdentifier(content.toString());                lang = identifier.getLanguage();                System.out.println(lang);                total += System.currentTimeMillis() - start;                Assert.assertEquals(tokens[1], lang);            }        }        in.close();        System.out.println("Total Time=" + total);    } catch (Exception e) {        e.printStackTrace();        Assert.fail(e.toString());    }}
cb037c7ca498f002461150cf31713d33f415c6cd6fb0c6ce9caf80576af02e63
modifyWebClient
protected WebClient modifyWebClient(WebClient client)
{    client.getOptions().setJavaScriptEnabled(enableJavascript);    client.getOptions().setCssEnabled(enableCss);    client.getOptions().setRedirectEnabled(enableRedirect);    if (enableJavascript)        client.setJavaScriptTimeout(javascriptTimeout);    client.getOptions().setThrowExceptionOnScriptError(false);    if (enableRedirect)        client.addWebWindowListener(new HtmlUnitWebWindowListener(maxRedirects));    return client;}
ea9ade90bc02314bdb3fd81ebf045fda30aaaf3a0386e3629e45cc11c85b86b2
getDriverForPage
public static WebDriver getDriverForPage(String url, Configuration conf)
{    long pageLoadTimout = conf.getLong("page.load.delay", 3);    enableJavascript = conf.getBoolean("htmlunit.enable.javascript", true);    enableCss = conf.getBoolean("htmlunit.enable.css", false);    javascriptTimeout = conf.getLong("htmlunit.javascript.timeout", 3500);    int redirects = Integer.parseInt(conf.get("http.redirect.max", "0"));    enableRedirect = redirects <= 0 ? false : true;    maxRedirects = redirects;    WebDriver driver = null;    try {        driver = new HtmlUnitWebDriver();        driver.manage().timeouts().pageLoadTimeout(pageLoadTimout, TimeUnit.SECONDS);        driver.get(url);    } catch (Exception e) {        if (e instanceof TimeoutException) {            LOG.debug("HtmlUnit WebDriver: Timeout Exception: Capturing whatever loaded so far...");            return driver;        }        cleanUpDriver(driver);        throw new RuntimeException(e);    }    return driver;}
cc10745c8cbd091e02d0436621bdd2ff7bfa3832e0d7e7607e826bfa7356d831
getHTMLContent
public static String getHTMLContent(WebDriver driver, Configuration conf)
{    try {        if (conf.getBoolean("take.screenshot", false))            takeScreenshot(driver, conf);        String innerHtml = "";        if (enableJavascript) {            WebElement body = driver.findElement(By.tagName("body"));            innerHtml = (String) ((JavascriptExecutor) driver).executeScript("return arguments[0].innerHTML;", body);        } else            innerHtml = driver.getPageSource().replaceAll("&amp;", "&");        return innerHtml;    } catch (Exception e) {        TemporaryFilesystem.getDefaultTmpFS().deleteTemporaryFiles();        cleanUpDriver(driver);        throw new RuntimeException(e);    }}
1df26b115c0f455f42fa7b844b720a561e4ef4026a9159f02090622ae9005591
cleanUpDriver
public static void cleanUpDriver(WebDriver driver)
{    if (driver != null) {        try {            driver.close();            driver.quit();            TemporaryFilesystem.getDefaultTmpFS().deleteTemporaryFiles();        } catch (Exception e) {            throw new RuntimeException(e);        }    }}
27b38cd0ec02b76eda771e4bac8b13a1d8ea9d1a4625de015523ed664123fb2e
getHtmlPage
public static String getHtmlPage(String url, Configuration conf)
{    WebDriver driver = getDriverForPage(url, conf);    try {        if (conf.getBoolean("take.screenshot", false))            takeScreenshot(driver, conf);        String innerHtml = "";        if (enableJavascript) {            WebElement body = driver.findElement(By.tagName("body"));            innerHtml = (String) ((JavascriptExecutor) driver).executeScript("return arguments[0].innerHTML;", body);        } else            innerHtml = driver.getPageSource().replaceAll("&amp;", "&");        return innerHtml;    } catch (Exception e) {        TemporaryFilesystem.getDefaultTmpFS().deleteTemporaryFiles();        throw new RuntimeException(e);    } finally {        cleanUpDriver(driver);    }}
91f77c6cebe06b339e4cfcd7ee9d65132bd97ff7995b138bfbbbbc7dae12621d
takeScreenshot
private static void takeScreenshot(WebDriver driver, Configuration conf)
{    try {        String url = driver.getCurrentUrl();        File srcFile = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);        LOG.debug("In-memory screenshot taken of: {}", url);        FileSystem fs = FileSystem.get(conf);        if (conf.get("screenshot.location") != null) {            Path screenshotPath = new Path(conf.get("screenshot.location") + "/" + srcFile.getName());            OutputStream os = null;            if (!fs.exists(screenshotPath)) {                LOG.debug("No existing screenshot already exists... creating new file at {} {}.", screenshotPath, srcFile.getName());                os = fs.create(screenshotPath);            }            InputStream is = new BufferedInputStream(new FileInputStream(srcFile));            IOUtils.copyBytes(is, os, conf);            LOG.debug("Screenshot for {} successfully saved to: {} {}", url, screenshotPath, srcFile.getName());        } else {            LOG.warn("Screenshot for {} not saved to HDFS (subsequently disgarded) as value for " + "'screenshot.location' is absent from nutch-site.xml.", url);        }    } catch (Exception e) {        cleanUpDriver(driver);        throw new RuntimeException(e);    }}
a12b91dd8f10446a6172ec161857ab1ff29f880bf1329b14002b987b395e630d
webWindowOpened
public void webWindowOpened(WebWindowEvent event)
{}
57965b97f159628a0c6059ea827e190f2fdcd2ef5ebf83580d60c8ad41e582ad
webWindowContentChanged
public void webWindowContentChanged(WebWindowEvent event)
{    redirectCount++;    if (redirectCount > maxRedirects)        throw new RuntimeException("Redirect Count: " + redirectCount + " exceeded the Maximum Redirects allowed: " + maxRedirects);}
1d1ea1d8c64d0a211b11ee6335a574807944bcd302a66eb66a628519db89e89d
webWindowClosed
public void webWindowClosed(WebWindowEvent event)
{}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    this.proxyHost = conf.get("http.proxy.host");    this.proxyPort = conf.getInt("http.proxy.port", 8080);    this.proxyType = Proxy.Type.valueOf(conf.get("http.proxy.type", "HTTP"));    this.proxyException = arrayToMap(conf.getStrings("http.proxy.exception.list"));    this.useProxy = (proxyHost != null && proxyHost.length() > 0);    this.timeout = conf.getInt("http.timeout", 10000);    this.maxContent = conf.getInt("http.content.limit", 1024 * 1024);    this.maxDuration = conf.getInt("http.time.limit", -1);    this.partialAsTruncated = conf.getBoolean("http.partial.truncated", false);    this.userAgent = getAgentString(conf.get("http.agent.name"), conf.get("http.agent.version"), conf.get("http.agent.description"), conf.get("http.agent.url"), conf.get("http.agent.email"));    this.acceptLanguage = conf.get("http.accept.language", acceptLanguage).trim();    this.acceptCharset = conf.get("http.accept.charset", acceptCharset).trim();    this.accept = conf.get("http.accept", accept).trim();    this.mimeTypes = new MimeUtil(conf);        this.useHttp11 = conf.getBoolean("http.useHttp11", true);    this.useHttp2 = conf.getBoolean("http.useHttp2", false);    this.tlsCheckCertificate = conf.getBoolean("http.tls.certificates.check", false);    this.responseTime = conf.getBoolean("http.store.responsetime", true);    this.storeIPAddress = conf.getBoolean("store.ip.address", false);    this.storeHttpRequest = conf.getBoolean("store.http.request", false);    this.storeHttpHeaders = conf.getBoolean("store.http.headers", false);    this.enableIfModifiedsinceHeader = conf.getBoolean("http.enable.if.modified.since.header", true);    this.enableCookieHeader = conf.getBoolean("http.enable.cookie.header", true);    this.robots.setConf(conf);    this.logUtil.setConf(conf);        if (conf.getBoolean("http.agent.rotate", false)) {        String agentsFile = conf.get("http.agent.rotate.file", "agents.txt");        BufferedReader br = null;        try {            Reader reader = conf.getConfResourceAsReader(agentsFile);            br = new BufferedReader(reader);            userAgentNames = new ArrayList<String>();            String word = "";            while ((word = br.readLine()) != null) {                if (!word.trim().isEmpty())                    userAgentNames.add(word.trim());            }            if (userAgentNames.size() == 0) {                logger.warn("Empty list of user agents in http.agent.rotate.file {}", agentsFile);                userAgentNames = null;            }        } catch (Exception e) {            logger.warn("Failed to read http.agent.rotate.file {}: {}", agentsFile, StringUtils.stringifyException(e));            userAgentNames = null;        } finally {            if (br != null) {                try {                    br.close();                } catch (IOException e) {                                }            }        }        if (userAgentNames == null) {            logger.warn("Falling back to fixed user agent set via property http.agent.name");        }    }        if (enableCookieHeader) {        String cookieFile = conf.get("http.agent.host.cookie.file", "cookies.txt");        BufferedReader br = null;        try {            Reader reader = conf.getConfResourceAsReader(cookieFile);            br = new BufferedReader(reader);            hostCookies = new HashMap<String, String>();            String word = "";            while ((word = br.readLine()) != null) {                if (!word.trim().isEmpty()) {                    if (word.indexOf("#") == -1) {                                                String[] parts = word.split("\t");                        if (parts.length == 2) {                            hostCookies.put(parts[0], parts[1]);                        } else {                            LOG.warn("Unable to parse cookie file correctly at: " + word);                        }                    }                }            }        } catch (Exception e) {            logger.warn("Failed to read http.agent.host.cookie.file {}: {}", cookieFile, StringUtils.stringifyException(e));            hostCookies = null;        } finally {            if (br != null) {                try {                    br.close();                } catch (IOException e) {                                }            }        }    }    String[] protocols = conf.getStrings("http.tls.supported.protocols", "TLSv1.2", "TLSv1.1", "TLSv1", "SSLv3");    String[] ciphers = conf.getStrings("http.tls.supported.cipher.suites", "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", "TLS_RSA_WITH_AES_256_CBC_SHA256", "TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384", "TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384", "TLS_DHE_RSA_WITH_AES_256_CBC_SHA256", "TLS_DHE_DSS_WITH_AES_256_CBC_SHA256", "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA", "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA", "TLS_RSA_WITH_AES_256_CBC_SHA", "TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA", "TLS_ECDH_RSA_WITH_AES_256_CBC_SHA", "TLS_DHE_RSA_WITH_AES_256_CBC_SHA", "TLS_DHE_DSS_WITH_AES_256_CBC_SHA", "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", "TLS_RSA_WITH_AES_128_CBC_SHA256", "TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256", "TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256", "TLS_DHE_RSA_WITH_AES_128_CBC_SHA256", "TLS_DHE_DSS_WITH_AES_128_CBC_SHA256", "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", "TLS_RSA_WITH_AES_128_CBC_SHA", "TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA", "TLS_ECDH_RSA_WITH_AES_128_CBC_SHA", "TLS_DHE_RSA_WITH_AES_128_CBC_SHA", "TLS_DHE_DSS_WITH_AES_128_CBC_SHA", "TLS_ECDHE_ECDSA_WITH_RC4_128_SHA", "TLS_ECDHE_RSA_WITH_RC4_128_SHA", "SSL_RSA_WITH_RC4_128_SHA", "TLS_ECDH_ECDSA_WITH_RC4_128_SHA", "TLS_ECDH_RSA_WITH_RC4_128_SHA", "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA", "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA", "SSL_RSA_WITH_3DES_EDE_CBC_SHA", "TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA", "TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA", "SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA", "SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA", "SSL_RSA_WITH_RC4_128_MD5", "TLS_EMPTY_RENEGOTIATION_INFO_SCSV", "TLS_RSA_WITH_NULL_SHA256", "TLS_ECDHE_ECDSA_WITH_NULL_SHA", "TLS_ECDHE_RSA_WITH_NULL_SHA", "SSL_RSA_WITH_NULL_SHA", "TLS_ECDH_ECDSA_WITH_NULL_SHA", "TLS_ECDH_RSA_WITH_NULL_SHA", "SSL_RSA_WITH_NULL_MD5", "SSL_RSA_WITH_DES_CBC_SHA", "SSL_DHE_RSA_WITH_DES_CBC_SHA", "SSL_DHE_DSS_WITH_DES_CBC_SHA", "TLS_KRB5_WITH_RC4_128_SHA", "TLS_KRB5_WITH_RC4_128_MD5", "TLS_KRB5_WITH_3DES_EDE_CBC_SHA", "TLS_KRB5_WITH_3DES_EDE_CBC_MD5", "TLS_KRB5_WITH_DES_CBC_SHA", "TLS_KRB5_WITH_DES_CBC_MD5");    tlsPreferredProtocols = new HashSet<String>(Arrays.asList(protocols));    tlsPreferredCipherSuites = new HashSet<String>(Arrays.asList(ciphers));    logConf();}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
6d413a80163f4d7e678657d3c1ba04fedc25050e6e7590618feec8814211d7b3
getProtocolOutput
public ProtocolOutput getProtocolOutput(Text url, CrawlDatum datum)
{    String urlString = url.toString();    try {        URL u = new URL(urlString);        long startTime = System.currentTimeMillis();                Response response = getResponse(u, datum, false);        if (this.responseTime) {            int elapsedTime = (int) (System.currentTimeMillis() - startTime);            datum.getMetaData().put(RESPONSE_TIME, new IntWritable(elapsedTime));        }        int code = response.getCode();        datum.getMetaData().put(Nutch.PROTOCOL_STATUS_CODE_KEY, new Text(Integer.toString(code)));        byte[] content = response.getContent();        Content c = new Content(u.toString(), u.toString(), (content == null ? EMPTY_CONTENT : content), response.getHeader("Content-Type"), response.getHeaders(), mimeTypes);        if (code == 200) {                        return new ProtocolOutput(c);        } else if (code >= 300 && code < 400) {                        String location = response.getHeader("Location");                        if (location == null)                location = response.getHeader("location");            if (location == null)                location = "";            u = new URL(u, location);            int protocolStatusCode;            switch(code) {                case                 300:                    protocolStatusCode = ProtocolStatus.MOVED;                    break;                                case 301:                case                 305:                    protocolStatusCode = ProtocolStatus.MOVED;                    break;                                case 302:                                case 303:                case                 307:                    protocolStatusCode = ProtocolStatus.TEMP_MOVED;                    break;                case                 304:                    protocolStatusCode = ProtocolStatus.NOTMODIFIED;                    break;                default:                    protocolStatusCode = ProtocolStatus.MOVED;            }                        return new ProtocolOutput(c, new ProtocolStatus(protocolStatusCode, u));        } else if (code == 400) {                        if (logger.isTraceEnabled()) {                logger.trace("400 Bad request: " + u);            }            return new ProtocolOutput(c, new ProtocolStatus(ProtocolStatus.GONE, u));        } else if (code == 401) {                        if (logger.isTraceEnabled()) {                logger.trace("401 Authentication Required");            }            return new ProtocolOutput(c, new ProtocolStatus(ProtocolStatus.ACCESS_DENIED, "Authentication required: " + urlString));        } else if (code == 404) {            return new ProtocolOutput(c, new ProtocolStatus(ProtocolStatus.NOTFOUND, u));        } else if (code == 410) {                        return new ProtocolOutput(c, new ProtocolStatus(ProtocolStatus.GONE, "Http: " + code + " url=" + u));        } else {            return new ProtocolOutput(c, new ProtocolStatus(ProtocolStatus.EXCEPTION, "Http code=" + code + ", url=" + u));        }    } catch (Throwable e) {        if (logger.isDebugEnabled() || !logUtil.logShort(e)) {            logger.error("Failed to get protocol output", e);        } else {            logger.error("Failed to get protocol output: {}", e.getClass().getName());        }        return new ProtocolOutput(null, new ProtocolStatus(e));    }}
74fe3c677fd3587af70dd616561871664083d4120345974b7163a45f2a2a95b7
getProxyHost
public String getProxyHost()
{    return proxyHost;}
a9856e1d456416992f329c340c652a41122f11dd6d39a10441319d41ef28148d
getProxyPort
public int getProxyPort()
{    return proxyPort;}
50909605cede5a96894c84a47c0b0bfdca7dfa64e268691c3b4d454a53cbb48a
useProxy
public boolean useProxy(URL url)
{    return useProxy(url.getHost());}
a277093b7c32af78d0025bee94091c5dc2a9b8098d1e05d291887c9f5e70f2d1
useProxy
public boolean useProxy(URI uri)
{    return useProxy(uri.getHost());}
7240dbdbb3d65ee6bf5668a993752571045d9269f4e73a4ecd3843454d87f408
useProxy
public boolean useProxy(String host)
{    if (useProxy && proxyException.containsKey(host)) {        return false;    }    return useProxy;}
2c9177cd8b47bdfcc60afb6594715b20a3d24726d258bdf44bfb0787f6856413
getTimeout
public int getTimeout()
{    return timeout;}
3da73beaa4febd7c8b877232debbae0a765b1ae506397c5c8af89aa23ee77f09
isIfModifiedSinceEnabled
public boolean isIfModifiedSinceEnabled()
{    return enableIfModifiedsinceHeader;}
7f11e3ef82efdff2d24e6ff69c155e6de5656e61a1ec378476aa47da3ba25a57
isCookieEnabled
public boolean isCookieEnabled()
{    return enableCookieHeader;}
523e1a39905426f23ae89d7366e444349445838f3b634cff477d9d9cbfa06ea2
isStoreIPAddress
public boolean isStoreIPAddress()
{    return storeIPAddress;}
9dd52072f46a27dd5ca1e7f04eb15742ddf7e942779522eb1319ec8506bd2aa7
isStoreHttpRequest
public boolean isStoreHttpRequest()
{    return storeHttpRequest;}
22ed520821ca4341bcb69cd2f59e828b3009f545ca4204d8ab0e1fd2c7fbe467
isStoreHttpHeaders
public boolean isStoreHttpHeaders()
{    return storeHttpHeaders;}
18d18ee3ffc2cf8ee1fb261c403bb9c677d56d95db63433c977622b3ef5149f2
getMaxContent
public int getMaxContent()
{    return maxContent;}
4d63117dfb29fe32c8025aca384f8e0d4085c9ffd39abee8e4b23943d53e991e
getMaxDuration
public int getMaxDuration()
{    return maxDuration;}
8e5e1061d5a0d7e62cf2f945c7d24a1589bd11c220ba3f49fbe751e7f81c9bcd
isStorePartialAsTruncated
public boolean isStorePartialAsTruncated()
{    return partialAsTruncated;}
d340dc4c0fdc531ec3b7a77eabaf9d081ba846765a2caec98eb7de318305a949
getUserAgent
public String getUserAgent()
{    if (userAgentNames != null) {        return userAgentNames.get(ThreadLocalRandom.current().nextInt(userAgentNames.size()));    }    return userAgent;}
9f0421d68c61e4d44e5ff868f3e3556c06c9d4dba5698ecbcf0eb87f36e4e325
getCookie
public String getCookie(URL url)
{    if (hostCookies != null) {        return hostCookies.get(url.getHost());    }    return null;}
26d6d07665ae3e428edeeb727f8b3eb129a297e0e49545b4bd7bf9247b32047b
getAcceptLanguage
public String getAcceptLanguage()
{    return acceptLanguage;}
a5e094a5932abb8ca44d700dea5c7a859b82d9ef3376ce5494a7a13f4f5a8212
getAcceptCharset
public String getAcceptCharset()
{    return acceptCharset;}
d2a41233d89dedec9776aadca633379259a991a40ae10dc0d5bb9dab588b8832
getAccept
public String getAccept()
{    return accept;}
5a9a7d570e849044de46297da79e6865dee026431dd1c32a8648efb13c12cebe
getUseHttp11
public boolean getUseHttp11()
{    return useHttp11;}
e428e6abd593f7da4fb692069e8e9e6cd69a03995e441190ddbb484958c563d8
isTlsCheckCertificates
public boolean isTlsCheckCertificates()
{    return tlsCheckCertificate;}
698c9ba71fc4011cac216c9f211a24544003e609eba016957753322d05c72510
getTlsPreferredCipherSuites
public Set<String> getTlsPreferredCipherSuites()
{    return tlsPreferredCipherSuites;}
0a3f83bab66381a884682ed0fc738fea1d25d7df3eeea903a3730373a789e900
getTlsPreferredProtocols
public Set<String> getTlsPreferredProtocols()
{    return tlsPreferredProtocols;}
18c33a0b68831d8c09fe6bc93e014dc8bb40b3bae3fe3ad3d292441cf450382c
getAgentString
private static String getAgentString(String agentName, String agentVersion, String agentDesc, String agentURL, String agentEmail)
{    if ((agentName == null) || (agentName.trim().length() == 0)) {                if (LOG.isErrorEnabled()) {            LOG.error("No User-Agent string set (http.agent.name)!");        }    }    StringBuffer buf = new StringBuffer();    buf.append(agentName);    if (agentVersion != null && !agentVersion.trim().isEmpty()) {        buf.append("/");        buf.append(agentVersion);    }    if (((agentDesc != null) && (agentDesc.length() != 0)) || ((agentEmail != null) && (agentEmail.length() != 0)) || ((agentURL != null) && (agentURL.length() != 0))) {        buf.append(" (");        if ((agentDesc != null) && (agentDesc.length() != 0)) {            buf.append(agentDesc);            if ((agentURL != null) || (agentEmail != null))                buf.append("; ");        }        if ((agentURL != null) && (agentURL.length() != 0)) {            buf.append(agentURL);            if (agentEmail != null)                buf.append("; ");        }        if ((agentEmail != null) && (agentEmail.length() != 0))            buf.append(agentEmail);        buf.append(")");    }    return buf.toString();}
f76125c53790b7d078cd93bfa2453198cf5235a3cf618d371618fa35a2cc9a4c
logConf
protected void logConf()
{    if (logger.isInfoEnabled()) {        logger.info("http.proxy.host = " + proxyHost);        logger.info("http.proxy.port = " + proxyPort);        logger.info("http.proxy.exception.list = " + useProxy);        logger.info("http.timeout = " + timeout);        logger.info("http.content.limit = " + maxContent);        logger.info("http.agent = " + userAgent);        logger.info("http.accept.language = " + acceptLanguage);        logger.info("http.accept = " + accept);        logger.info("http.enable.cookie.header = " + isCookieEnabled());    }}
a28abfb64fa94489ba7011abafd6fdf70da6ac9bf1dc5069efb1a9263036d836
processGzipEncoded
public byte[] processGzipEncoded(byte[] compressed, URL url) throws IOException
{    if (LOG.isTraceEnabled()) {        LOG.trace("uncompressing....");    }        if (compressed.length == 0)        return compressed;    byte[] content;    if (getMaxContent() >= 0) {        content = GZIPUtils.unzipBestEffort(compressed, getMaxContent());    } else {        content = GZIPUtils.unzipBestEffort(compressed);    }    if (content == null)        throw new IOException("unzipBestEffort returned null");    if (LOG.isTraceEnabled()) {        LOG.trace("fetched " + compressed.length + " bytes of compressed content (expanded to " + content.length + " bytes) from " + url);    }    return content;}
0ba4f9d8541fb870420a79e11fc55276e163cc325514c8102daee22b516111aa
processDeflateEncoded
public byte[] processDeflateEncoded(byte[] compressed, URL url) throws IOException
{        if (compressed.length == 0)        return compressed;    if (LOG.isTraceEnabled()) {        LOG.trace("inflating....");    }    byte[] content;    if (getMaxContent() >= 0) {        content = DeflateUtils.inflateBestEffort(compressed, getMaxContent());    } else {        content = DeflateUtils.inflateBestEffort(compressed);    }    if (content == null)        throw new IOException("inflateBestEffort returned null");    if (LOG.isTraceEnabled()) {        LOG.trace("fetched " + compressed.length + " bytes of compressed content (expanded to " + content.length + " bytes) from " + url);    }    return content;}
43b18fc937930e2b2b183ff8cde5c6097b93dcfef711991de2f7dd060a6ed6e3
main
protected static void main(HttpBase http, String[] args) throws Exception
{    String url = null;    String usage = "Usage: Http [-verbose] [-timeout N] url";    if (args.length == 0) {        System.err.println(usage);        System.exit(-1);    }    for (int i = 0; i < args.length; i++) {                if (args[i].equals("-timeout")) {                        http.timeout = Integer.parseInt(args[++i]) * 1000;        } else if (args[i].equals("-verbose")) {                } else if (i != args.length - 1) {            System.err.println(usage);            System.exit(-1);        } else                        url = args[i];    }    ProtocolOutput out = http.getProtocolOutput(new Text(url), new CrawlDatum());    Content content = out.getContent();    System.out.println("Status: " + out.getStatus());    if (content != null) {        System.out.println("Content Type: " + content.getContentType());        System.out.println("Content Length: " + content.getMetadata().get(Response.CONTENT_LENGTH));        System.out.println("Content:");        String text = new String(content.getContent());        System.out.println(text);    }}
7f90f3c3a9c578d789339dc31e965bfefda78f244aac7037bd5e441fb313996a
getRobotRules
public BaseRobotRules getRobotRules(Text url, CrawlDatum datum, List<Content> robotsTxtContent)
{    return robots.getRobotRulesSet(this, url, robotsTxtContent);}
748f2267caebaf6b5abf4d3c61ecaea6c4994621152cf1523319e51fcfaac115
arrayToMap
private HashMap<String, String> arrayToMap(String[] input)
{    if (input == null || input.length == 0) {        return new HashMap<String, String>();    }    HashMap<String, String> hm = new HashMap<>();    for (int i = 0; i < input.length; i++) {        if (!"".equals(input[i].trim())) {            hm.put(input[i], input[i]);        }    }    return hm;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    super.setConf(conf);    allowForbidden = conf.getBoolean("http.robots.403.allow", true);}
f0bdf2cde98595a637e8cc336806f9dbebf2c7ff87621758ed407c6e96522253
getCacheKey
protected static String getCacheKey(URL url)
{        String protocol = url.getProtocol().toLowerCase();            String host = url.getHost().toLowerCase();    int port = url.getPort();    if (port == -1) {        port = url.getDefaultPort();    }    /*     * Robot rules apply only to host, protocol, and port where robots.txt is     * hosted (cf. NUTCH-1752). Consequently     */    String cacheKey = protocol + ":" + host + ":" + port;    return cacheKey;}
7325febcde439a0af504d8a5770f8352e9a7a25ff9e612f096816ef0c69dea7a
getRobotRulesSet
public BaseRobotRules getRobotRulesSet(Protocol http, URL url, List<Content> robotsTxtContent)
{    if (LOG.isTraceEnabled() && isWhiteListed(url)) {        LOG.trace("Ignoring robots.txt (host is whitelisted) for URL: {}", url);    }    String cacheKey = getCacheKey(url);    BaseRobotRules robotRules = CACHE.get(cacheKey);    if (robotRules != null) {                return robotRules;    } else if (LOG.isTraceEnabled()) {        LOG.trace("cache miss " + url);    }    boolean cacheRule = true;    URL redir = null;    if (isWhiteListed(url)) {                        robotRules = EMPTY_RULES;        LOG.info("Whitelisted host found for: {}", url);        LOG.info("Ignoring robots.txt for all URLs from whitelisted host: {}", url.getHost());    } else {        try {            URL robotsUrl = new URL(url, "/robots.txt");            Response response = ((HttpBase) http).getResponse(robotsUrl, new CrawlDatum(), true);            if (robotsTxtContent != null) {                addRobotsContent(robotsTxtContent, robotsUrl, response);            }                        if (response.getCode() == 301 || response.getCode() == 302) {                String redirection = response.getHeader("Location");                if (redirection == null) {                                        redirection = response.getHeader("location");                }                if (redirection != null) {                    if (!redirection.startsWith("http")) {                                                redir = new URL(url, redirection);                    } else {                        redir = new URL(redirection);                    }                    response = ((HttpBase) http).getResponse(redir, new CrawlDatum(), true);                    if (robotsTxtContent != null) {                        addRobotsContent(robotsTxtContent, redir, response);                    }                }            }            if (            response.getCode() == 200)                robotRules = parseRules(url.toString(), response.getContent(), response.getHeader("Content-Type"), agentNames);            else if ((response.getCode() == 403) && (!allowForbidden))                                robotRules = FORBID_ALL_RULES;            else if (response.getCode() >= 500) {                                cacheRule = false;                robotRules = EMPTY_RULES;            } else                                robotRules = EMPTY_RULES;        } catch (Throwable t) {            if (LOG.isInfoEnabled()) {                LOG.info("Couldn't get robots.txt for " + url + ": " + t.toString());            }                        cacheRule = false;            robotRules = EMPTY_RULES;        }    }    if (cacheRule) {                CACHE.put(cacheKey, robotRules);        if (redir != null && !redir.getHost().equalsIgnoreCase(url.getHost()) && "/robots.txt".equals(redir.getFile())) {                                    CACHE.put(getCacheKey(redir), robotRules);        }    }    return robotRules;}
9f11cfde9646f5f4c35a4212ee702b61776467663c11d02cb79e67399066e63e
addRobotsContent
protected void addRobotsContent(List<Content> robotsTxtContent, URL robotsUrl, Response robotsResponse)
{    byte[] robotsBytes = robotsResponse.getContent();    if (robotsBytes == null)        robotsBytes = new byte[0];    Content content = new Content(robotsUrl.toString(), robotsUrl.toString(), robotsBytes, robotsResponse.getHeader("Content-Type"), robotsResponse.getHeaders(), getConf());    robotsTxtContent.add(content);}
7b8bfc800c42e5d4cd627a1e74c3ba3839e422c932285ffc29c28d897bd22a87
testRobotsAgent
public void testRobotsAgent()
{    rules = parser.parseRules("testRobotsAgent", ROBOTS_STRING.getBytes(), CONTENT_TYPE, SINGLE_AGENT);    for (int counter = 0; counter < TEST_PATHS.length; counter++) {        Assert.assertTrue("testing on agent (" + SINGLE_AGENT + "), and " + "path " + TEST_PATHS[counter] + " got " + rules.isAllowed(TEST_PATHS[counter]), rules.isAllowed(TEST_PATHS[counter]) == RESULTS[counter]);    }    rules = parser.parseRules("testRobotsAgent", ROBOTS_STRING.getBytes(), CONTENT_TYPE, MULTIPLE_AGENTS);    for (int counter = 0; counter < TEST_PATHS.length; counter++) {        Assert.assertTrue("testing on agents (" + MULTIPLE_AGENTS + "), and " + "path " + TEST_PATHS[counter] + " got " + rules.isAllowed(TEST_PATHS[counter]), rules.isAllowed(TEST_PATHS[counter]) == RESULTS[counter]);    }}
7a3a9a9addcbe5e084165f31e81b8dfec2d184a7165b316082a40f7ff57565a3
testCrawlDelay
public void testCrawlDelay()
{            rules = parser.parseRules("testCrawlDelay", ROBOTS_STRING.getBytes(), CONTENT_TYPE, SINGLE_AGENT);    Assert.assertTrue("testing crawl delay for agent " + SINGLE_AGENT + " : ", (rules.getCrawlDelay() == 10000));        rules = parser.parseRules("testCrawlDelay", ROBOTS_STRING.getBytes(), CONTENT_TYPE, UNKNOWN_AGENT);    Assert.assertTrue("testing crawl delay for agent " + UNKNOWN_AGENT + " : ", (rules.getCrawlDelay() == Long.MIN_VALUE));}
38b90e6ad7d8c09447b2cdeeb62cf73642a9ba7e0ea4538a453a9f82a3f60a6f
openChannel
public void openChannel() throws IOException
{    channel = connection.createChannel();}
a8b881bd83625527ace150011a8cacecc1833472b5400e9691c638e67cbb0217
bind
public void bind(String exchangeName, String exchangeOptions, String queueName, String queueOptions, String bindingKey, String bindingArguments) throws IOException
{    String exchangeType = exchangeDeclare(exchangeName, exchangeOptions);    queueDeclare(queueName, queueOptions);    switch(exchangeType) {        case "fanout":            channel.queueBind(queueName, exchangeName, "");            break;        case "direct":            channel.queueBind(queueName, exchangeName, getValue(bindingKey, DEFAULT_ROUTING_KEY));            break;        case "headers":            channel.queueBind(queueName, exchangeName, "", RabbitMQOptionParser.parseOptionAndConvertValue(bindingArguments));            break;        case "topic":            channel.queueBind(queueName, exchangeName, getValue(bindingKey, DEFAULT_ROUTING_KEY));            break;        default:            break;    }}
fa8c719e9a9b026039a4d706fe94ca95766c5319c3d371e2b90ca1bc559b6711
publish
public void publish(String exchangeName, String routingKey, RabbitMQMessage message) throws IOException
{    channel.basicPublish(getValue(exchangeName, DEFAULT_EXCHANGE_NAME), getValue(routingKey, DEFAULT_ROUTING_KEY), new AMQP.BasicProperties.Builder().contentType(message.getContentType()).headers(message.getHeaders()).build(), message.getBody());}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    try {        channel.close();        connection.close();    } catch (TimeoutException e) {        throw makeIOException(e);    }}
97a58ce7c0f5ac043818d55025612bfa43bfeb73adc4fc8526f5f89ad6effca4
exchangeDeclare
private String exchangeDeclare(String name, String options) throws IOException
{    Map<String, String> values = RabbitMQOptionParser.parseOption(options);    String type = values.getOrDefault("type", DEFAULT_EXCHANGE_TYPE);    channel.exchangeDeclare(getValue(name, DEFAULT_EXCHANGE_NAME), type, Boolean.parseBoolean(values.getOrDefault("durable", DEFAULT_EXCHANGE_DURABLE)));    return type;}
28d6fec229793fc08d2e266afeaa5ef8716bd572c4ae48e98c63035656c24f8f
queueDeclare
private void queueDeclare(String name, String options) throws IOException
{    Map<String, String> values = RabbitMQOptionParser.parseOption(options);    channel.queueDeclare(getValue(name, DEFAULT_QUEUE_NAME), Boolean.parseBoolean(values.getOrDefault("durable", DEFAULT_QUEUE_DURABLE)), Boolean.parseBoolean(values.getOrDefault("exclusive", DEFAULT_QUEUE_EXCLUSIVE)), Boolean.parseBoolean(values.getOrDefault("auto-delete", DEFAULT_QUEUE_AUTO_DELETE)), RabbitMQOptionParser.parseSubOption(values.getOrDefault("arguments", DEFAULT_QUEUE_ARGUMENTS)));}
45df9514a1f59b3d2d9f127498e96c8a8d7500ccb8f58b258679b49308504463
getValue
private static String getValue(String value, String defaultValue)
{    if (value == null || value.trim().isEmpty()) {        return defaultValue;    }    return value;}
f9067af10ca11b67df9dd54f8c988d6ac566c5cc8601f1fe8c1a640c38c758af
getValue
private static Integer getValue(Integer value, Integer defaultValue)
{    if (value == null) {        return defaultValue;    }    return value;}
be4db9d9b330e9043a4178587b868ed703ab4d0c36925dcc6eef9cf79c600e38
makeIOException
private static IOException makeIOException(Exception e)
{    return new IOException(e);}
f35cfbfea0e72de2c7a5fc0a03bc5eb7700eccf62ce3f8f0c0f0678a8156dd86
getHeaders
public Map<String, Object> getHeaders()
{    return headers;}
a90d43d35a14c9ccd9b7787670cd61f79192ba2f7e45a0ffeaf95f20ff88fa62
setHeaders
public void setHeaders(final Map<String, Object> headers)
{    this.headers = headers;}
ab8d88251184c0b15ddf6a5d3a377aba128a9148f1e0125c51b9f09332fc1979
setHeaders
public void setHeaders(final String headers)
{    this.headers = RabbitMQOptionParser.parseOptionAndConvertValue(headers);}
0507990db8691462535a27bb0745b797eb2957264dfcee15e09cd41f6d7b2802
addHeader
public void addHeader(final String key, final Object value)
{    this.headers.put(key, value);}
a624aa1b85808a74c9f320025ea600169bd6e4692611a44ef53a1970442ef820
getBody
public byte[] getBody()
{    return body;}
cae2fd695bf1b84ea60bbe7f18541d2b366b4fc23d8d5c28bda38b9b6de2db45
setBody
public void setBody(final byte[] body)
{    this.body = body;}
baea39c86756a5efaaec8e2f01175d687e0a60e86379d9b91d98a3d4089abf86
getContentType
public String getContentType()
{    return contentType;}
b2303ad6014ea74762dc266d1738cadcbb403ca81e967ce42b52b972dc4f755c
setContentType
public void setContentType(final String contentType)
{    this.contentType = contentType;}
8c981cb6594f8b78b9eb00a72c2f1e7ec9a23522854ff43f32d37a36f501c629
parseOption
 static Map<String, String> parseOption(final String option)
{    Map<String, String> values = new HashMap<>();    if (option.isEmpty()) {        return values;    }    String[] split = option.split(",");    for (String s : split) {        String[] ss = s.split("=");        values.put(ss[0], ss[1]);    }    return values;}
b3c7a4aeb4fc3bb1ca4a5f26e1d1b0bf3caadefe4fbe42b1b4e16105d1577218
parseOptionAndConvertValue
 static Map<String, Object> parseOptionAndConvertValue(final String option)
{    Map<String, Object> values = new HashMap<>();    if (option.isEmpty()) {        return values;    }    String[] split = option.split(",");    for (String s : split) {        String[] ss = s.split("=");        values.put(ss[0], convert(ss[1]));    }    return values;}
f475c9fe334fc99c8c0949a7194e5d2df11e6033231ba7a99513e27b3b8768f1
parseSubOption
 static Map<String, Object> parseSubOption(final String subOption)
{    Map<String, Object> values = new HashMap<>();    if (subOption.isEmpty()) {        return values;    }    String[] split = subOption.replaceAll("\\{|}", "").split(";");    for (String s : split) {        String[] ss = s.split(":");        values.put(ss[0], convert(ss[1]));    }    return values;}
6e46dc7da777e4f54e8041f1b810f268af8a38ed13b1573cf5b56e15b4be5e76
convert
private static Object convert(String s)
{    try {        return Integer.parseInt(s);    } catch (Exception ex) {        }    try {        return Float.parseFloat(s);    } catch (Exception ex) {        }    if (s.equalsIgnoreCase("true") || s.equalsIgnoreCase("false")) {        return Boolean.parseBoolean(s);    }    return s;}
4fdae2bd80bdfb72681eefe2d6e84e91dcef4659ec79dd911a6662a7bd40c05b
accept
protected boolean accept()
{    return sign;}
153896457d2093c45a01124da7d0db3d2fede7b02f12da5a89910b083e969a8f
hostOrDomain
protected String hostOrDomain()
{    return hostOrDomain;}
be6412312dc61ff762d0ce9c837b565146019541e8c24168ec28fdfc4e168a5c
regex
protected String regex()
{    return regex;}
9391d90f04c089d100b5d360c687d3724caed389f84cf9a30c69d36ed624f185
filter
public String filter(String url)
{    String host = null;    String domain = null;    if (hasHostDomainRules) {        host = URLUtil.getHost(url);        try {            domain = URLUtil.getDomainName(url);        } catch (MalformedURLException e) {                }        LOG.debug("URL belongs to host {} and domain {}", host, domain);    }    for (RegexRule rule : rules) {                if (rule.hostOrDomain() != null && !rule.hostOrDomain().equals(host) && !rule.hostOrDomain().equals(domain)) {            LOG.debug("Skipping rule [{}] for host: {}", rule.regex(), rule.hostOrDomain());            continue;        }        LOG.debug("Applying rule [{}] for host {} and domain {}", rule.regex(), host, domain);        if (rule.match(url)) {            return rule.accept() ? url : null;        }    }    ;    return null;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    Reader reader = null;    try {        reader = getRulesReader(conf);    } catch (Exception e) {        if (LOG.isErrorEnabled()) {            LOG.error(e.getMessage());        }        throw new RuntimeException(e.getMessage(), e);    }    try {        rules = readRules(reader);    } catch (IOException e) {        if (LOG.isErrorEnabled()) {            LOG.error(e.getMessage());        }        throw new RuntimeException(e.getMessage(), e);    }}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
804f7f1f0dcf259a86fb69e949930cbe89336520c364bd3c0929e59f8dc224e7
readRules
private List<RegexRule> readRules(Reader reader) throws IOException, IllegalArgumentException
{    BufferedReader in = new BufferedReader(reader);    List<RegexRule> rules = new ArrayList<RegexRule>();    String line;    String hostOrDomain = null;    while ((line = in.readLine()) != null) {        if (line.length() == 0) {            continue;        }        char first = line.charAt(0);        boolean sign = false;        switch(first) {            case '+':                sign = true;                break;            case '-':                sign = false;                break;            case ' ':            case '\n':            case             '#':                continue;            case '>':                hostOrDomain = line.substring(1).trim();                hasHostDomainRules = true;                continue;            case '<':                hostOrDomain = null;                continue;            default:                throw new IOException("Invalid first character: " + line);        }        String regex = line.substring(1);        if (LOG.isTraceEnabled()) {            LOG.trace("Adding rule [" + regex + "] for " + hostOrDomain);        }        RegexRule rule = createRule(sign, regex, hostOrDomain);        rules.add(rule);    }    return rules;}
5bee55e50e295c565032217b84b719372f468300b22ee2a3a46ae3445cdc5560
main
public static void main(RegexURLFilterBase filter, String[] args) throws IOException, IllegalArgumentException
{    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));    String line;    while ((line = in.readLine()) != null) {        String out = filter.filter(line);        if (out != null) {            System.out.print("+");            System.out.println(out);        } else {            System.out.print("-");            System.out.println(line);        }    }}
aa254496c5f249d0a06b8fb273c7c34f72856fe353ad1ea501c2411ccfbfc085
bench
protected void bench(int loops, String file)
{    try {        bench(loops, new FileReader(SAMPLES + SEPARATOR + file + ".rules"), new FileReader(SAMPLES + SEPARATOR + file + ".urls"));    } catch (Exception e) {        Assert.fail(e.toString());    }}
23503da3739c1fc1c50d20b4b3d5fab7254204f3fcc9f6e354ff3ab9687f5b76
bench
protected void bench(int loops, Reader rules, Reader urls)
{    long start = System.currentTimeMillis();    try {        URLFilter filter = getURLFilter(rules);        FilteredURL[] expected = readURLFile(urls);        for (int i = 0; i < loops; i++) {            test(filter, expected);        }    } catch (Exception e) {        Assert.fail(e.toString());    }    LOG.info("bench time (" + loops + ") " + (System.currentTimeMillis() - start) + "ms");}
676a6e209ceec2175d6d428881950e4b611ae8227d83c3008e8e86e7d93e2aa2
bench
protected void bench(int loops, String rulesFile, String urlsFile)
{    try {        bench(loops, new FileReader(SAMPLES + SEPARATOR + rulesFile), new FileReader(SAMPLES + SEPARATOR + urlsFile));    } catch (Exception e) {        Assert.fail(e.toString());    }}
dfded52cfbb5bc7ebb212d105c63dde390a3a44e413a9e40e0fb7e7e98becade
test
protected void test(String rulesFile, String urlsFile)
{    try {        test(new FileReader(SAMPLES + SEPARATOR + rulesFile), new FileReader(SAMPLES + SEPARATOR + urlsFile));    } catch (Exception e) {        Assert.fail(e.toString());    }}
b644b1611d3ff7d15b749e0ce415e5da63512cb2abe1e7938835f6d8985f2097
test
protected void test(String file)
{    try {        test(new FileReader(SAMPLES + SEPARATOR + file + ".rules"), new FileReader(SAMPLES + SEPARATOR + file + ".urls"));    } catch (Exception e) {        Assert.fail(e.toString());    }}
5103294745869d4fec7ae988b493c2b7b89390a234d0dfe60bca74f3992bf9be
test
protected void test(Reader rules, Reader urls)
{    try {        test(getURLFilter(rules), readURLFile(urls));    } catch (Exception e) {        Assert.fail(e.toString());    }}
c9467a2c2fe3fb4f0d8e09cf492d718f64718c9dc41553f227dcaea395ec521b
test
protected void test(URLFilter filter, FilteredURL[] expected)
{    for (int i = 0; i < expected.length; i++) {        String result = filter.filter(expected[i].url);        if (result != null) {            Assert.assertTrue(expected[i].url, expected[i].sign);        } else {            Assert.assertFalse(expected[i].url, expected[i].sign);        }    }}
91eed9365243a3f7dcd10b8b15ceabb8bb07775f69ff9d08754021d8f6e972db
readURLFile
private static FilteredURL[] readURLFile(Reader reader) throws IOException
{    BufferedReader in = new BufferedReader(reader);    List<FilteredURL> list = new ArrayList<FilteredURL>();    String line;    while ((line = in.readLine()) != null) {        if (line.length() != 0) {            list.add(new FilteredURL(line));        }    }    return (FilteredURL[]) list.toArray(new FilteredURL[list.size()]);}
ea9ade90bc02314bdb3fd81ebf045fda30aaaf3a0386e3629e45cc11c85b86b2
getDriverForPage
public static WebDriver getDriverForPage(String url, Configuration conf)
{    WebDriver driver = null;    long pageLoadWait = conf.getLong("page.load.delay", 3);    try {        String driverType = conf.get("selenium.driver", "firefox");        boolean enableHeadlessMode = conf.getBoolean("selenium.enable.headless", false);        switch(driverType) {            case "firefox":                String geckoDriverPath = conf.get("selenium.grid.binary", "/root/geckodriver");                driver = createFirefoxWebDriver(geckoDriverPath, enableHeadlessMode);                break;            case "chrome":                String chromeDriverPath = conf.get("selenium.grid.binary", "/root/chromedriver");                driver = createChromeWebDriver(chromeDriverPath, enableHeadlessMode);                break;                        case "remote":                String seleniumHubHost = conf.get("selenium.hub.host", "localhost");                int seleniumHubPort = Integer.parseInt(conf.get("selenium.hub.port", "4444"));                String seleniumHubPath = conf.get("selenium.hub.path", "/wd/hub");                String seleniumHubProtocol = conf.get("selenium.hub.protocol", "http");                URL seleniumHubUrl = new URL(seleniumHubProtocol, seleniumHubHost, seleniumHubPort, seleniumHubPath);                String seleniumGridDriver = conf.get("selenium.grid.driver", "firefox");                switch(seleniumGridDriver) {                    case "firefox":                        driver = createFirefoxRemoteWebDriver(seleniumHubUrl, enableHeadlessMode);                        break;                    case "chrome":                        driver = createChromeRemoteWebDriver(seleniumHubUrl, enableHeadlessMode);                        break;                    case "random":                        driver = createRandomRemoteWebDriver(seleniumHubUrl, enableHeadlessMode);                        break;                    default:                        LOG.error("The Selenium Grid WebDriver choice {} is not available... defaulting to FirefoxDriver().", driverType);                        driver = createDefaultRemoteWebDriver(seleniumHubUrl, enableHeadlessMode);                        break;                }                break;            default:                LOG.error("The Selenium WebDriver choice {} is not available... defaulting to FirefoxDriver().", driverType);                FirefoxOptions options = new FirefoxOptions();                driver = new FirefoxDriver(options);                break;        }        LOG.debug("Selenium {} WebDriver selected.", driverType);        driver.manage().timeouts().pageLoadTimeout(pageLoadWait, TimeUnit.SECONDS);        driver.get(url);    } catch (Exception e) {        if (e instanceof TimeoutException) {            LOG.error("Selenium WebDriver: Timeout Exception: Capturing whatever loaded so far...");            return driver;        } else {            LOG.error(e.toString());        }        cleanUpDriver(driver);        throw new RuntimeException(e);    }    return driver;}
9ce7a8a87e6e0a7019b4b925acbf3358f23239fd36f163e86f0403890d3d41ed
createFirefoxWebDriver
public static WebDriver createFirefoxWebDriver(String firefoxDriverPath, boolean enableHeadlessMode)
{    System.setProperty("webdriver.gecko.driver", firefoxDriverPath);    FirefoxOptions firefoxOptions = new FirefoxOptions();    if (enableHeadlessMode) {        firefoxOptions.addArguments("--headless");    }    WebDriver driver = new FirefoxDriver(firefoxOptions);    return driver;}
b02b89b72ef2ad659a416b427ef2364c09960f716aa3c9b81cebf7f48687a953
createChromeWebDriver
public static WebDriver createChromeWebDriver(String chromeDriverPath, boolean enableHeadlessMode)
{        System.setProperty("webdriver.chrome.driver", chromeDriverPath);    ChromeOptions chromeOptions = new ChromeOptions();    chromeOptions.addArguments("--no-sandbox");    chromeOptions.addArguments("--disable-extensions");        if (enableHeadlessMode) {        chromeOptions.addArguments("--headless");    }    WebDriver driver = new ChromeDriver(chromeOptions);    return driver;}
6a653a6606931c86dc1995b9a0b91e2b75faf0d2dd808666caea985205455bf7
createOperaWebDriver
public static WebDriver createOperaWebDriver(String operaDriverPath, boolean enableHeadlessMode)
{        System.setProperty("webdriver.opera.driver", operaDriverPath);    OperaOptions operaOptions = new OperaOptions();        operaOptions.addArguments("--no-sandbox");    operaOptions.addArguments("--disable-extensions");        if (enableHeadlessMode) {        operaOptions.addArguments("--headless");    }    WebDriver driver = new OperaDriver(operaOptions);    return driver;}
4cdbe5f585f0d598838dd9e5186c52789f95ceda5dc0e81ef8dfc550d367cf15
createFirefoxRemoteWebDriver
public static RemoteWebDriver createFirefoxRemoteWebDriver(URL seleniumHubUrl, boolean enableHeadlessMode)
{    FirefoxOptions firefoxOptions = new FirefoxOptions();    if (enableHeadlessMode) {        firefoxOptions.setHeadless(true);    }    RemoteWebDriver driver = new RemoteWebDriver(seleniumHubUrl, firefoxOptions);    return driver;}
3d61ec1a710deb63ae12138bed18785b286a86b68462e1524bb578a263a7e883
createChromeRemoteWebDriver
public static RemoteWebDriver createChromeRemoteWebDriver(URL seleniumHubUrl, boolean enableHeadlessMode)
{    ChromeOptions chromeOptions = new ChromeOptions();    if (enableHeadlessMode) {        chromeOptions.setHeadless(true);    }    RemoteWebDriver driver = new RemoteWebDriver(seleniumHubUrl, chromeOptions);    return driver;}
061c29d982121c83218b4b71d423c23aff3301cc968207b0b764f1ab4453ff3d
createRandomRemoteWebDriver
public static RemoteWebDriver createRandomRemoteWebDriver(URL seleniumHubUrl, boolean enableHeadlessMode)
{                Random r = new Random();    int min = 0;                                int max = 1;    int num = r.nextInt((max - min) + 1) + min;    if (num == 0) {        return createFirefoxRemoteWebDriver(seleniumHubUrl, enableHeadlessMode);    }    return createChromeRemoteWebDriver(seleniumHubUrl, enableHeadlessMode);}
985e95070ce22fddfe3c7452817a0b0f60b633a020e24e5810a2665c7649e9fb
createDefaultRemoteWebDriver
public static RemoteWebDriver createDefaultRemoteWebDriver(URL seleniumHubUrl, boolean enableHeadlessMode)
{    return createFirefoxRemoteWebDriver(seleniumHubUrl, enableHeadlessMode);}
1df26b115c0f455f42fa7b844b720a561e4ef4026a9159f02090622ae9005591
cleanUpDriver
public static void cleanUpDriver(WebDriver driver)
{    if (driver != null) {        try {                        driver.quit();            TemporaryFilesystem.getDefaultTmpFS().deleteTemporaryFiles();        } catch (Exception e) {            LOG.error(e.toString());                }    }}
27b38cd0ec02b76eda771e4bac8b13a1d8ea9d1a4625de015523ed664123fb2e
getHtmlPage
public static String getHtmlPage(String url, Configuration conf)
{    WebDriver driver = getDriverForPage(url, conf);    try {        if (conf.getBoolean("take.screenshot", false)) {            takeScreenshot(driver, conf);        }        String innerHtml = driver.findElement(By.tagName("body")).getAttribute("innerHTML");        return innerHtml;            } catch (Exception e) {        TemporaryFilesystem.getDefaultTmpFS().deleteTemporaryFiles();                LOG.error("getHtmlPage(url, conf): " + e.toString());        throw new RuntimeException(e);    } finally {        cleanUpDriver(driver);    }}
71b8f2571db0531e0456dc1e00fae01ad93ffd774633a2dbf65c488117185b95
getHtmlPage
public static String getHtmlPage(String url)
{    return getHtmlPage(url, null);}
91f77c6cebe06b339e4cfcd7ee9d65132bd97ff7995b138bfbbbbc7dae12621d
takeScreenshot
private static void takeScreenshot(WebDriver driver, Configuration conf)
{    try {        String url = driver.getCurrentUrl();        File srcFile = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);        LOG.debug("In-memory screenshot taken of: {}", url);        FileSystem fs = FileSystem.get(conf);        if (conf.get("screenshot.location") != null) {            Path screenshotPath = new Path(conf.get("screenshot.location") + "/" + srcFile.getName());            OutputStream os = null;            if (!fs.exists(screenshotPath)) {                LOG.debug("No existing screenshot already exists... creating new file at {} {}.", screenshotPath, srcFile.getName());                os = fs.create(screenshotPath);            }            InputStream is = new BufferedInputStream(new FileInputStream(srcFile));            IOUtils.copyBytes(is, os, conf);            LOG.debug("Screenshot for {} successfully saved to: {} {}", url, screenshotPath, srcFile.getName());        } else {            LOG.warn("Screenshot for {} not saved to HDFS (subsequently disgarded) as value for " + "'screenshot.location' is absent from nutch-site.xml.", url);        }    } catch (Exception e) {        LOG.error("Error taking screenshot: ", e);        cleanUpDriver(driver);        throw new RuntimeException(e);    }}
8fa98404280fecfd497ce9400c07196998fbeaf2ee8524779c09bd3c220d4ea9
filter
public NutchDocument filter(NutchDocument doc, Parse parse, Text url, CrawlDatum datum, Inlinks inlinks) throws IndexingException
{        String[] tags = parse.getData().getParseMeta().getValues(RelTagParser.REL_TAG);    if (tags != null) {        for (int i = 0; i < tags.length; i++) {            doc.add("tag", tags[i]);        }    }    return doc;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
9ff841f3d46425f0defcf4346027b52742d29abc435829a9bc29d5c88e553a7b
filter
public ParseResult filter(Content content, ParseResult parseResult, HTMLMetaTags metaTags, DocumentFragment doc)
{        Parse parse = parseResult.get(content.getUrl());        Parser parser = new Parser(doc);    Set<?> tags = parser.getRelTags();    Iterator<?> iter = tags.iterator();    Metadata metadata = parse.getData().getParseMeta();    while (iter.hasNext()) metadata.add(REL_TAG, (String) iter.next());    return parseResult;}
5964eeb730bed6d833c5dfbb42288383519d46306112928ea8b0f3e259d0b1b5
getRelTags
 Set<String> getRelTags()
{    return tags;}
ba2e270469884db16e4cfefa467e78f3b6ab6655009696df30749de12c84322f
parse
 void parse(Node node)
{    if (node.getNodeType() == Node.ELEMENT_NODE) {                if ("a".equalsIgnoreCase(node.getNodeName())) {            NamedNodeMap attrs = node.getAttributes();            Node hrefNode = attrs.getNamedItem("href");                        if (hrefNode != null) {                Node relNode = attrs.getNamedItem("rel");                                if (relNode != null) {                                        if ("tag".equalsIgnoreCase(relNode.getNodeValue())) {                        String tag = parseTag(hrefNode.getNodeValue());                        if (!StringUtil.isEmpty(tag)) {                            if (!tags.contains(tag)) {                                tags.add(tag);                                LOG.debug("Adding tag: " + tag + " to tag set.");                            }                        }                    }                }            }        }    }        NodeList children = node.getChildNodes();    for (int i = 0; children != null && i < children.getLength(); i++) parse(children.item(i));}
9721fd48bc1d2302aa163920e752e6b5468860be5db1c772702e79a061d979e9
parseTag
private static final String parseTag(String url)
{    String tag = null;    try {        URL u = new URL(url);        String path = u.getPath();        tag = URLDecoder.decode(path.substring(path.lastIndexOf('/') + 1), "UTF-8");    } catch (Exception e) {                tag = null;    }    return tag;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
8fa98404280fecfd497ce9400c07196998fbeaf2ee8524779c09bd3c220d4ea9
filter
public NutchDocument filter(NutchDocument doc, Parse parse, Text url, CrawlDatum datum, Inlinks inlinks) throws IndexingException
{    String mimeType;    String contentType;    Writable tcontentType = datum.getMetaData().get(new Text(Response.CONTENT_TYPE));    if (tcontentType != null) {        contentType = tcontentType.toString();    } else {        contentType = parse.getData().getMeta(Response.CONTENT_TYPE);    }    if (contentType == null) {        mimeType = tika.detect(url.toString());    } else {        mimeType = MIME.forName(MimeUtil.cleanMimeType(contentType));    }    contentType = mimeType;    if (LOG.isInfoEnabled()) {        LOG.info(String.format("[%s] %s", contentType, url));    }    if (trie != null) {        if (trie.shortestMatch(contentType) == null) {                        if (acceptMode) {                return doc;            }            return null;        } else {                        if (acceptMode) {                return null;            }        }    }    return doc;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    MIME = new MimeUtil(conf);        String file = conf.get(MIMEFILTER_REGEX_FILE, "");    if (file != null) {        if (file.isEmpty()) {            LOG.warn(String.format("Missing %s property, ALL mimetypes will be allowed", MIMEFILTER_REGEX_FILE));        } else {            Reader reader = conf.getConfResourceAsReader(file);            try {                readConfiguration(reader);            } catch (IOException e) {                if (LOG.isErrorEnabled()) {                    LOG.error(e.getMessage());                }                throw new RuntimeException(e.getMessage(), e);            }        }    }}
92728a9e13d7b87282ad47620c35b5bf2b5cfa0b41b20255ea468e49ab72e069
readConfiguration
private void readConfiguration(Reader reader) throws IOException
{    BufferedReader in = new BufferedReader(reader);    String line;    List<String> rules = new ArrayList<String>();    while (null != (line = in.readLine())) {        if (line.length() == 0) {            continue;        }        char first = line.charAt(0);        switch(first) {            case ' ':            case '\n':            case             '#':                break;            case '+':                acceptMode = true;                break;            case '-':                acceptMode = false;                break;            default:                rules.add(line);                break;        }    }    trie = new PrefixStringMatcher(rules);}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
c42d422af125340bb29218edfef092175460ee2904ec199ff5d26900b76864e2
main
public static void main(String[] args) throws IOException, IndexingException
{    Option helpOpt = new Option("h", "help", false, "show this help message");    @SuppressWarnings("static-access")    Option rulesOpt = OptionBuilder.withArgName("file").hasArg().withDescription("Rules file to be used in the tests relative to the conf directory").isRequired().create("rules");    Options options = new Options();    options.addOption(helpOpt).addOption(rulesOpt);    CommandLineParser parser = new GnuParser();    HelpFormatter formatter = new HelpFormatter();    String rulesFile;    try {        CommandLine line = parser.parse(options, args);        if (line.hasOption("help") || !line.hasOption("rules")) {            formatter.printHelp("org.apache.nutch.indexer.filter.MimeTypeIndexingFilter", options, true);            return;        }        rulesFile = line.getOptionValue("rules");    } catch (UnrecognizedOptionException e) {        formatter.printHelp("org.apache.nutch.indexer.filter.MimeTypeIndexingFilter", options, true);        return;    } catch (Exception e) {        LOG.error(StringUtils.stringifyException(e));        e.printStackTrace();        return;    }    MimeTypeIndexingFilter filter = new MimeTypeIndexingFilter();    Configuration conf = NutchConfiguration.create();    conf.set(MimeTypeIndexingFilter.MIMEFILTER_REGEX_FILE, rulesFile);    filter.setConf(conf);    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));    String line;    while ((line = in.readLine()) != null && !line.isEmpty()) {        Metadata metadata = new Metadata();        metadata.set(Response.CONTENT_TYPE, line);        ParseImpl parse = new ParseImpl("text", new ParseData(new ParseStatus(), "title", new Outlink[0], metadata));        NutchDocument doc = filter.filter(new NutchDocument(), parse, new Text("http://www.example.com/"), new CrawlDatum(), new Inlinks());        if (doc != null) {            System.out.print("+ ");            System.out.println(line);        } else {            System.out.print("- ");            System.out.println(line);        }    }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    for (int i = 0; i < MIME_TYPES.length; i++) {        Metadata metadata = new Metadata();        metadata.add(Response.CONTENT_TYPE, MIME_TYPES[i]);        ParseImpl parse = new ParseImpl("text", new ParseData(new ParseStatus(), "title", new Outlink[0], metadata));        parses[i] = parse;    }}
a990ea4e0739b18e567ebd293737020460e48c7bedd1761d641bd625f63ceb4b
testMissingConfigFile
public void testMissingConfigFile() throws Exception
{    String file = conf.get(MimeTypeIndexingFilter.MIMEFILTER_REGEX_FILE, "");    Assert.assertEquals(String.format("Property %s must not be present in the the configuration file", MimeTypeIndexingFilter.MIMEFILTER_REGEX_FILE), "", file);    filter.setConf(conf);        for (int i = 0; i < parses.length; i++) {        NutchDocument doc = filter.filter(new NutchDocument(), parses[i], new Text("http://www.example.com/"), new CrawlDatum(), new Inlinks());        Assert.assertNotNull("All documents must be allowed by default", doc);    }}
37fc7507bcfa74af8cfeb4b5ef99051cd06acb3722a5a50442bcfc27aeea5b7c
testAllowOnlyImages
public void testAllowOnlyImages() throws Exception
{    conf.set(MimeTypeIndexingFilter.MIMEFILTER_REGEX_FILE, "allow-images.txt");    filter.setConf(conf);    for (int i = 0; i < parses.length; i++) {        NutchDocument doc = filter.filter(new NutchDocument(), parses[i], new Text("http://www.example.com/"), new CrawlDatum(), new Inlinks());        if (MIME_TYPES[i].contains("image")) {            Assert.assertNotNull("Allow only images", doc);        } else {            Assert.assertNull("Block everything else", doc);        }    }}
77cf4325f123cbd2b23a02d232f5e00c0c817fc7ae927ad0730abf122d578280
testBlockHTML
public void testBlockHTML() throws Exception
{    conf.set(MimeTypeIndexingFilter.MIMEFILTER_REGEX_FILE, "block-html.txt");    filter.setConf(conf);    for (int i = 0; i < parses.length; i++) {        NutchDocument doc = filter.filter(new NutchDocument(), parses[i], new Text("http://www.example.com/"), new CrawlDatum(), new Inlinks());        if (MIME_TYPES[i].contains("html")) {            Assert.assertNull("Block only HTML documents", doc);        } else {            Assert.assertNotNull("Allow everything else", doc);        }    }}
74c073cf714c8a8285642be67ae2f28cd713bfd23722543918cc25b506734fed
getParse
public ParseResult getParse(Content content)
{    String contentType = content.getContentType();    String[] params = (String[]) TYPE_PARAMS_MAP.get(contentType);    if (params == null)        return new ParseStatus(ParseStatus.FAILED, "No external command defined for contentType: " + contentType).getEmptyParseResult(content.getUrl(), getConf());    String command = params[0];    int timeout = Integer.parseInt(params[1]);    String encoding = params[2];    if (LOG.isTraceEnabled()) {        LOG.trace("Use " + command + " with timeout=" + timeout + "secs");    }    String text = null;    String title = null;    try {        byte[] raw = content.getContent();        String contentLength = content.getMetadata().get(Response.CONTENT_LENGTH);        if (contentLength != null && raw.length != Integer.parseInt(contentLength)) {            return new ParseStatus(ParseStatus.FAILED, ParseStatus.FAILED_TRUNCATED, "Content truncated at " + raw.length + " bytes. Parser can't handle incomplete " + contentType + " file.").getEmptyParseResult(content.getUrl(), getConf());        }        ByteArrayOutputStream os = new ByteArrayOutputStream(BUFFER_SIZE);        ByteArrayOutputStream es = new ByteArrayOutputStream(BUFFER_SIZE / 4);        CommandRunner cr = new CommandRunner();        cr.setCommand(command + " " + contentType);        cr.setInputStream(new ByteArrayInputStream(raw));        cr.setStdOutputStream(os);        cr.setStdErrorStream(es);        cr.setTimeout(timeout);        cr.evaluate();        if (cr.getExitValue() != 0)            return new ParseStatus(ParseStatus.FAILED, "External command " + command + " failed with error: " + es.toString()).getEmptyParseResult(content.getUrl(), getConf());        text = os.toString(encoding);    } catch (Exception e) {                return new ParseStatus(e).getEmptyParseResult(content.getUrl(), getConf());    }    if (text == null)        text = "";    if (title == null)        title = "";        Outlink[] outlinks = OutlinkExtractor.getOutlinks(text, getConf());    ParseData parseData = new ParseData(ParseStatus.STATUS_SUCCESS, title, outlinks, content.getMetadata());    return ParseResult.createParseResult(content.getUrl(), new ParseImpl(text, parseData));}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    Extension[] extensions = PluginRepository.get(conf).getExtensionPoint("org.apache.nutch.parse.Parser").getExtensions();    String contentType, command, timeoutString, encoding;    for (int i = 0; i < extensions.length; i++) {        Extension extension = extensions[i];                if (!extension.getDescriptor().getPluginId().equals("parse-ext"))            continue;        contentType = extension.getAttribute("contentType");        if (contentType == null || contentType.equals(""))            continue;        command = extension.getAttribute("command");        if (command == null || command.equals(""))            continue;                encoding = extension.getAttribute("encoding");        if (encoding == null)            encoding = Charset.defaultCharset().name();        timeoutString = extension.getAttribute("timeout");        if (timeoutString == null || timeoutString.equals(""))            timeoutString = "" + TIMEOUT_DEFAULT;        TYPE_PARAMS_MAP.put(contentType, new String[] { command, timeoutString, encoding });    }}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
72c8aa905bdfb81b136bdc053fc5615fe4b4a936a6a06d188b3e29c166e00168
setUp
protected void setUp() throws ProtocolException, IOException
{            String path = System.getProperty("test.data");    if (path != null) {        File tempDir = new File(path);        if (!tempDir.exists())            tempDir.mkdir();        tempFile = File.createTempFile("nutch.test.plugin.ExtParser.", ".txt", tempDir);    } else {                tempFile = File.createTempFile("nutch.test.plugin.ExtParser.", ".txt");    }    urlString = tempFile.toURI().toURL().toString();    FileOutputStream fos = new FileOutputStream(tempFile);    fos.write(expectedText.getBytes());    fos.close();        Protocol protocol = new ProtocolFactory(NutchConfiguration.create()).getProtocol(urlString);    content = protocol.getProtocolOutput(new Text(urlString), new CrawlDatum()).getContent();    protocol = null;}
31fe9734dd8390e227fab018acc57467d6c42e7ab19b1bd22b996f56833e8512
tearDown
protected void tearDown()
{        content = null;}
483150fd494d6a3b766d3cd3b294147b229e48982cde78a0ce4bcf0d02e6736f
testIt
public void testIt() throws ParseException
{    String contentType;        if (!System.getProperty("os.name").equalsIgnoreCase("linux")) {        System.err.println("Current OS is " + System.getProperty("os.name") + ".");        System.err.println("No test is run on OS other than linux.");        return;    }    Configuration conf = NutchConfiguration.create();        for (int i = 0; i < 10; i++) {                contentType = "application/vnd.nutch.example.cat";        content.setContentType(contentType);        parse = new ParseUtil(conf).parseByExtensionId("parse-ext", content).get(content.getUrl());        Assert.assertEquals(expectedText, parse.getText());                contentType = "application/vnd.nutch.example.md5sum";        content.setContentType(contentType);        parse = new ParseUtil(conf).parseByExtensionId("parse-ext", content).get(content.getUrl());        Assert.assertTrue(parse.getText().startsWith(expectedMD5sum));    }}
e8859bd6249d425d0d6873d73bcf29436797c378eb9a2a95122ed1b117a88297
getRootNode
public Node getRootNode()
{    return (null != m_docFrag) ? (Node) m_docFrag : (Node) m_doc;}
cd87f0106ae1380c56420905fa929abe227dd7c9a9fdd631978dc402a703cbbd
getCurrentNode
public Node getCurrentNode()
{    return m_currentNode;}
151106e7015d697eaefac09869054eeda2dbd0d0262d28915cdaa0d8b852f1e1
getWriter
public java.io.Writer getWriter()
{    return null;}
f75a4336d1f10b71ffeca0725d5b35cf5ae5a7660e73b4556b49575378ab197d
append
protected void append(Node newNode) throws org.xml.sax.SAXException
{    Node currentNode = m_currentNode;    if (null != currentNode) {        currentNode.appendChild(newNode);        } else if (null != m_docFrag) {        m_docFrag.appendChild(newNode);    } else {        boolean ok = true;        short type = newNode.getNodeType();        if (type == Node.TEXT_NODE) {            String data = newNode.getNodeValue();            if ((null != data) && (data.trim().length() > 0)) {                throw new org.xml.sax.SAXException("Warning: can't output text before document element!  Ignoring...");            }            ok = false;        } else if (type == Node.ELEMENT_NODE) {            if (m_doc.getDocumentElement() != null) {                throw new org.xml.sax.SAXException("Can't have more than one root on a DOM!");            }        }        if (ok)            m_doc.appendChild(newNode);    }}
b2f272e09c1cb5e2753e1336905f73e1c5d739510484927f3d8899c5a6c3e63f
setDocumentLocator
public void setDocumentLocator(Locator locator)
{}
d715c5bb3f7aef8c165f489b6a9ca99285c1ae49770e68917f0ff4facb17d4c3
startDocument
public void startDocument() throws org.xml.sax.SAXException
{}
1a3098bd1fa9516c83b2c1c558e73929c0a860cb2305aa0f59472ba76bbe34ca
endDocument
public void endDocument() throws org.xml.sax.SAXException
{}
01c36c9aa4800334f1a56cf4a327ada41b268f083d3e1367f9caab5c3e767e5d
startElement
public void startElement(String ns, String localName, String name, Attributes atts) throws org.xml.sax.SAXException
{    Element elem;        if ((null == ns) || (ns.length() == 0))        elem = m_doc.createElementNS(null, name);    else        elem = m_doc.createElementNS(ns, name);    append(elem);    try {        int nAtts = atts.getLength();        if (0 != nAtts) {            for (int i = 0; i < nAtts; i++) {                                if (atts.getType(i).equalsIgnoreCase("ID"))                    setIDAttribute(atts.getValue(i), elem);                String attrNS = atts.getURI(i);                if ("".equals(attrNS))                                        attrNS = null;                                                                String attrQName = atts.getQName(i);                                if (attrQName.startsWith("xmlns:"))                    attrNS = "http://www.w3.org/2000/xmlns/";                                elem.setAttributeNS(attrNS, attrQName, atts.getValue(i));            }        }                m_elemStack.push(elem);        m_currentNode = elem;        } catch (java.lang.Exception de) {                throw new org.xml.sax.SAXException(de);    }}
5830b626746f78da6836b288e5d33c4b4211989ead97e86f0e21e6d4208ce053
endElement
public void endElement(String ns, String localName, String name) throws org.xml.sax.SAXException
{    m_elemStack.pop();    m_currentNode = m_elemStack.isEmpty() ? null : (Node) m_elemStack.peek();}
30b57deb275508e5b475fb5672520d80b9616977c0a1d6f925d8a4f89d119fdd
setIDAttribute
public void setIDAttribute(String id, Element elem)
{}
3f0cf929d8c00e3e6c466564001c48c498db84e4fd83bbf9a63bda4b3d6d3409
characters
public void characters(char[] ch, int start, int length) throws org.xml.sax.SAXException
{    if (isOutsideDocElem() && XMLCharacterRecognizer.isWhiteSpace(ch, start, length))                return;    if (m_inCData) {        cdata(ch, start, length);        return;    }    String s = new String(ch, start, length);    Node childNode;    childNode = m_currentNode != null ? m_currentNode.getLastChild() : null;    if (childNode != null && childNode.getNodeType() == Node.TEXT_NODE) {        ((Text) childNode).appendData(s);    } else {        Text text = m_doc.createTextNode(s);        append(text);    }}
ad59be00c4249d62e43524910a52a28809055e6a1819ffcd3ff3412836872021
charactersRaw
public void charactersRaw(char[] ch, int start, int length) throws org.xml.sax.SAXException
{    if (isOutsideDocElem() && XMLCharacterRecognizer.isWhiteSpace(ch, start, length))                return;    String s = new String(ch, start, length);    append(m_doc.createProcessingInstruction("xslt-next-is-raw", "formatter-to-dom"));    append(m_doc.createTextNode(s));}
2cae08649aabee7dde275c91f52d6a20aeccc85f5aceb12ffcd4498194106601
startEntity
public void startEntity(String name) throws org.xml.sax.SAXException
{}
dc4a85a9fc2f03a78fea0feaf7ae779b60183832c958cfbc1e48b33ae51fec9d
endEntity
public void endEntity(String name) throws org.xml.sax.SAXException
{}
df93be66203db8d2bebdfb4f122696d4c0e407c9d19885fb8b63f1557854bdf4
entityReference
public void entityReference(String name) throws org.xml.sax.SAXException
{    append(m_doc.createEntityReference(name));}
b758e825d1b35f0652451692fdf06105a0e852004bacfbe0a5f0d58740c338f4
ignorableWhitespace
public void ignorableWhitespace(char[] ch, int start, int length) throws org.xml.sax.SAXException
{    if (isOutsideDocElem())                return;    String s = new String(ch, start, length);    append(m_doc.createTextNode(s));}
84c553d5ddd3738c942cd3f8c9bc7907c35ed17fdd5f21672781d99ca716be32
isOutsideDocElem
private boolean isOutsideDocElem()
{    return (null == m_docFrag) && m_elemStack.size() == 0 && (null == m_currentNode || m_currentNode.getNodeType() == Node.DOCUMENT_NODE);}
880954d30ada7db21e140b7909c66964d6c8558030bb47d9d777172535aa26e9
processingInstruction
public void processingInstruction(String target, String data) throws org.xml.sax.SAXException
{    append(m_doc.createProcessingInstruction(target, data));}
8681ca2eabafb7d3162ce44e45391c02c2ef361ee57225ae447e2288a3905b1e
comment
public void comment(char[] ch, int start, int length) throws org.xml.sax.SAXException
{        if (ch == null || start < 0 || length >= (ch.length - start) || length < 0)        return;    append(m_doc.createComment(new String(ch, start, length)));}
6d8cdf13d098ccb3e4e2595c9ae3fbb204783212e0711b727a54be759c780253
startCDATA
public void startCDATA() throws org.xml.sax.SAXException
{    m_inCData = true;    append(m_doc.createCDATASection(""));}
a1619921b85f4308471f958f3831637315c68de1de59913697a567c836d45da5
endCDATA
public void endCDATA() throws org.xml.sax.SAXException
{    m_inCData = false;}
2a4eefacb0baab183a41e7f866051bbc64a3cc26e98d4164a840aefd0b7186a6
cdata
public void cdata(char[] ch, int start, int length) throws org.xml.sax.SAXException
{    if (isOutsideDocElem() && XMLCharacterRecognizer.isWhiteSpace(ch, start, length))                return;    String s = new String(ch, start, length);        Node n = m_currentNode.getLastChild();    if (n instanceof CDATASection)        ((CDATASection) n).appendData(s);    else if (n instanceof Comment)        ((Comment) n).appendData(s);}
901e293ed61766b19e850453e0bad6112d1df9bfb60d177da259173f15767d7f
startDTD
public void startDTD(String name, String publicId, String systemId) throws org.xml.sax.SAXException
{}
ee9dc9d04a7aba5005443daa6011f144e76e8920bb61cdbe385e9a49e4888ae3
endDTD
public void endDTD() throws org.xml.sax.SAXException
{}
6d89eda534570b43340ef3a34da9b1dafb3cbc2a1474f5d167f83bbc8b72f4a5
startPrefixMapping
public void startPrefixMapping(String prefix, String uri) throws org.xml.sax.SAXException
{/*     *      * if((null != m_currentNode) && (m_currentNode.getNodeType() ==     * Node.ELEMENT_NODE)) { String qname; if(((null != prefix) &&     * (prefix.length() == 0)) || (null == prefix)) qname = "xmlns"; else qname     * = "xmlns:"+prefix;     *      * Element elem = (Element)m_currentNode; String val =     * elem.getAttribute(qname);      * { elem.setAttributeNS("http://www.w3.org/XML/1998/namespace", qname,     * uri); } }     */}
515059befe06ad3c7c406e65a3ad795b61aca73d84ddc5a1d24c5389a54084a7
endPrefixMapping
public void endPrefixMapping(String prefix) throws org.xml.sax.SAXException
{}
a3a00f157591c5447f0fa4e676cc00c7ef6cd40f6252c856b5f6e227bcd97e57
skippedEntity
public void skippedEntity(String name) throws org.xml.sax.SAXException
{}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "LP[el=" + elName + ",attr=" + attrName + ",len=" + childLen + "]";}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{        Collection<String> forceTags = new ArrayList<String>(1);    this.conf = conf;    linkParams.clear();    linkParams.put("a", new LinkParams("a", "href", 1));    linkParams.put("area", new LinkParams("area", "href", 0));    if (conf.getBoolean("parser.html.form.use_action", true)) {        linkParams.put("form", new LinkParams("form", "action", 1));        if (conf.get("parser.html.form.use_action") != null)            forceTags.add("form");    }    linkParams.put("frame", new LinkParams("frame", "src", 0));    linkParams.put("iframe", new LinkParams("iframe", "src", 0));    linkParams.put("script", new LinkParams("script", "src", 0));    linkParams.put("link", new LinkParams("link", "href", 0));    linkParams.put("img", new LinkParams("img", "src", 0));    linkParams.put("source", new LinkParams("source", "src", 0));        String[] ignoreTags = conf.getStrings("parser.html.outlinks.ignore_tags");    for (int i = 0; ignoreTags != null && i < ignoreTags.length; i++) {        if (!forceTags.contains(ignoreTags[i]))            linkParams.remove(ignoreTags[i]);    }        srcTagMetaName = this.conf.get("parser.html.outlinks.htmlnode_metadata_name");    keepNodenames = (srcTagMetaName != null && srcTagMetaName.length() > 0);    blockNodes = new HashSet<>(conf.getTrimmedStringCollection("parser.html.line.separators"));}
6a0c27243075d26c1a15cb63ea0f0a49f58153d565c45042ce0b5d7b1031b998
getText
public boolean getText(StringBuffer sb, Node node, boolean abortOnNestedAnchors)
{    if (getTextHelper(sb, node, abortOnNestedAnchors, 0)) {        return true;    }    return false;}
fa5c2fd99144833795a789f0a86ca0aa1dac28ff556181facdf39b76439a0d67
getText
public void getText(StringBuffer sb, Node node)
{    getText(sb, node, false);}
c534cb80681ec5dfd7e15e9e4d995bf4f832b5d81ade734d23557260982ff92b
getTextHelper
private boolean getTextHelper(StringBuffer sb, Node node, boolean abortOnNestedAnchors, int anchorDepth)
{    boolean abort = false;    NodeWalker walker = new NodeWalker(node);    while (walker.hasNext()) {        Node currentNode = walker.nextNode();        String nodeName = currentNode.getNodeName();        short nodeType = currentNode.getNodeType();        Node previousSibling = currentNode.getPreviousSibling();        if (previousSibling != null && blockNodes.contains(previousSibling.getNodeName().toLowerCase())) {            appendParagraphSeparator(sb);        } else if (blockNodes.contains(nodeName.toLowerCase())) {            appendParagraphSeparator(sb);        }        if ("script".equalsIgnoreCase(nodeName)) {            walker.skipChildren();        }        if ("style".equalsIgnoreCase(nodeName)) {            walker.skipChildren();        }        if (abortOnNestedAnchors && "a".equalsIgnoreCase(nodeName)) {            anchorDepth++;            if (anchorDepth > 1) {                abort = true;                break;            }        }        if (nodeType == Node.COMMENT_NODE) {            walker.skipChildren();        }        if (nodeType == Node.TEXT_NODE) {                        String text = currentNode.getNodeValue();            text = text.replaceAll("\\s+", " ");            text = text.trim();            if (text.length() > 0) {                appendSpace(sb);                sb.append(text);            } else {                appendParagraphSeparator(sb);            }        }    }    return abort;}
b014d2637ad782bf6eb0fa6afedd7ca624f5a75981ae04d8338d88e5d37ba280
appendParagraphSeparator
private void appendParagraphSeparator(StringBuffer buffer)
{    if (buffer.length() == 0) {        return;    }    char lastChar = buffer.charAt(buffer.length() - 1);    if ('\n' != lastChar) {                while (lastChar == ' ') {            buffer.deleteCharAt(buffer.length() - 1);            lastChar = buffer.charAt(buffer.length() - 1);        }        if ('\n' != lastChar) {            buffer.append('\n');        }    }}
7ababbb6c381d37488ee71a114da7887fbe8a08f8223200c289bb4ea2bd640c4
appendSpace
private void appendSpace(StringBuffer buffer)
{    if (buffer.length() == 0) {        return;    }    char lastChar = buffer.charAt(buffer.length() - 1);    if (' ' != lastChar && '\n' != lastChar) {        buffer.append(' ');    }}
1705c1e4d1924b65c9b6fec717f754f4c94daa22932da745ce60e65e3d9c9b21
getTitle
public boolean getTitle(StringBuffer sb, Node node)
{    NodeWalker walker = new NodeWalker(node);    while (walker.hasNext()) {        Node currentNode = walker.nextNode();        String nodeName = currentNode.getNodeName();        short nodeType = currentNode.getNodeType();        if ("body".equalsIgnoreCase(nodeName)) {                        return false;        }        if (nodeType == Node.ELEMENT_NODE) {            if ("title".equalsIgnoreCase(nodeName)) {                getText(sb, currentNode);                return true;            }        }    }    return false;}
60c3b32eef11a5d274fda6242e3ef47e2c05007aeafdc638635c67a720729058
getBase
public String getBase(Node node)
{    NodeWalker walker = new NodeWalker(node);    while (walker.hasNext()) {        Node currentNode = walker.nextNode();        String nodeName = currentNode.getNodeName();        short nodeType = currentNode.getNodeType();                if (nodeType == Node.ELEMENT_NODE) {            if ("body".equalsIgnoreCase(nodeName)) {                                return null;            }            if ("base".equalsIgnoreCase(nodeName)) {                NamedNodeMap attrs = currentNode.getAttributes();                for (int i = 0; i < attrs.getLength(); i++) {                    Node attr = attrs.item(i);                    if ("href".equalsIgnoreCase(attr.getNodeName())) {                        return attr.getNodeValue();                    }                }            }        }    }        return null;}
0d718c3a945ee55c8038c90419a3b234bfb96eaffae8623add1e290cee4ee6e0
hasOnlyWhiteSpace
private boolean hasOnlyWhiteSpace(Node node)
{    String val = node.getNodeValue();    for (int i = 0; i < val.length(); i++) {        if (!Character.isWhitespace(val.charAt(i)))            return false;    }    return true;}
746c5d23ecbe0e1c93a246750f4b8d55373fcb0833277ea3248b88a2d1c1f148
shouldThrowAwayLink
private boolean shouldThrowAwayLink(Node node, NodeList children, int childLen, LinkParams params)
{    if (childLen == 0) {                if (params.childLen == 0)            return false;        else            return true;    } else if ((childLen == 1) && (children.item(0).getNodeType() == Node.ELEMENT_NODE) && (params.elName.equalsIgnoreCase(children.item(0).getNodeName()))) {                return true;    } else if (childLen == 2) {        Node c0 = children.item(0);        Node c1 = children.item(1);        if ((c0.getNodeType() == Node.ELEMENT_NODE) && (params.elName.equalsIgnoreCase(c0.getNodeName())) && (c1.getNodeType() == Node.TEXT_NODE) && hasOnlyWhiteSpace(c1)) {                        return true;        }        if ((c1.getNodeType() == Node.ELEMENT_NODE) && (params.elName.equalsIgnoreCase(c1.getNodeName())) && (c0.getNodeType() == Node.TEXT_NODE) && hasOnlyWhiteSpace(c0)) {                        return true;        }    } else if (childLen == 3) {        Node c0 = children.item(0);        Node c1 = children.item(1);        Node c2 = children.item(2);        if ((c1.getNodeType() == Node.ELEMENT_NODE) && (params.elName.equalsIgnoreCase(c1.getNodeName())) && (c0.getNodeType() == Node.TEXT_NODE) && (c2.getNodeType() == Node.TEXT_NODE) && hasOnlyWhiteSpace(c0) && hasOnlyWhiteSpace(c2)) {                        return true;        }    }    return false;}
9103b9ae5f158e7cad8775492cb5f4d6dbfb21469fe4969a00f91c9ff4e1a72c
getOutlinks
public void getOutlinks(URL base, ArrayList<Outlink> outlinks, Node node)
{    NodeWalker walker = new NodeWalker(node);    while (walker.hasNext()) {        Node currentNode = walker.nextNode();        String nodeName = currentNode.getNodeName();        short nodeType = currentNode.getNodeType();        NodeList children = currentNode.getChildNodes();        int childLen = (children != null) ? children.getLength() : 0;        if (nodeType == Node.ELEMENT_NODE) {            nodeName = nodeName.toLowerCase();            LinkParams params = (LinkParams) linkParams.get(nodeName);            if (params != null) {                if (!shouldThrowAwayLink(currentNode, children, childLen, params)) {                    StringBuffer linkText = new StringBuffer();                    getText(linkText, currentNode, true);                    if (linkText.toString().trim().length() == 0) {                                                NodeWalker subWalker = new NodeWalker(currentNode);                        while (subWalker.hasNext()) {                            Node subNode = subWalker.nextNode();                            if (subNode.getNodeType() == Node.ELEMENT_NODE) {                                if (subNode.getNodeName().toLowerCase().equals("img")) {                                    NamedNodeMap subAttrs = subNode.getAttributes();                                    Node alt = subAttrs.getNamedItem("alt");                                    if (alt != null) {                                        String altTxt = alt.getTextContent();                                        if (altTxt != null && altTxt.trim().length() > 0) {                                            if (linkText.length() > 0)                                                linkText.append(' ');                                            linkText.append(altTxt);                                        }                                    }                                } else {                                                                }                            } else if (subNode.getNodeType() == Node.TEXT_NODE) {                                String txt = subNode.getTextContent();                                if (txt != null && txt.length() > 0) {                                    if (linkText.length() > 0)                                        linkText.append(' ');                                    linkText.append(txt);                                }                            }                        }                    }                    NamedNodeMap attrs = currentNode.getAttributes();                    String target = null;                    boolean noFollow = false;                    boolean post = false;                    for (int i = 0; i < attrs.getLength(); i++) {                        Node attr = attrs.item(i);                        String attrName = attr.getNodeName();                        if (params.attrName.equalsIgnoreCase(attrName)) {                            target = attr.getNodeValue();                        } else if ("rel".equalsIgnoreCase(attrName) && "nofollow".equalsIgnoreCase(attr.getNodeValue())) {                            noFollow = true;                        } else if ("method".equalsIgnoreCase(attrName) && "post".equalsIgnoreCase(attr.getNodeValue())) {                            post = true;                        }                    }                    if (target != null && !noFollow && !post)                        try {                            URL url = URLUtil.resolveURL(base, target);                            Outlink outlink = new Outlink(url.toString(), linkText.toString().trim());                            outlinks.add(outlink);                                                        if (keepNodenames) {                                MapWritable metadata = new MapWritable();                                metadata.put(new Text(srcTagMetaName), new Text(nodeName));                                outlink.setMetadata(metadata);                            }                        } catch (MalformedURLException e) {                                                }                }                                if (params.childLen == 0)                    continue;            }        }    }}
b14e53eb4b14c89fffbf896087639efa5b9c184996992348e942f00e2940b80c
getMetaTags
public static final void getMetaTags(HTMLMetaTags metaTags, Node node, URL currURL)
{    metaTags.reset();    getMetaTagsHelper(metaTags, node, currURL);}
9bcb2c1e4e9d4b425e6b4dfa653b3ec3e3894af09be7459fd48bcb4806ce4af9
getMetaTagsHelper
private static final void getMetaTagsHelper(HTMLMetaTags metaTags, Node node, URL currURL)
{    if (node.getNodeType() == Node.ELEMENT_NODE) {        if ("body".equalsIgnoreCase(node.getNodeName())) {                        return;        }        if ("meta".equalsIgnoreCase(node.getNodeName())) {            NamedNodeMap attrs = node.getAttributes();            Node nameNode = null;            Node equivNode = null;            Node contentNode = null;                        for (int i = 0; i < attrs.getLength(); i++) {                Node attr = attrs.item(i);                String attrName = attr.getNodeName().toLowerCase();                if (attrName.equals("name")) {                    nameNode = attr;                } else if (attrName.equals("http-equiv")) {                    equivNode = attr;                } else if (attrName.equals("content")) {                    contentNode = attr;                }            }            if (nameNode != null) {                if (contentNode != null) {                    String name = nameNode.getNodeValue().toLowerCase();                    metaTags.getGeneralTags().add(name, contentNode.getNodeValue());                    if ("robots".equals(name)) {                        String directives = contentNode.getNodeValue().toLowerCase();                        int index = directives.indexOf("none");                        if (index >= 0) {                            metaTags.setNoIndex();                            metaTags.setNoFollow();                        }                        index = directives.indexOf("all");                        if (index >= 0) {                                                }                        index = directives.indexOf("noindex");                        if (index >= 0) {                            metaTags.setNoIndex();                        }                        index = directives.indexOf("nofollow");                        if (index >= 0) {                            metaTags.setNoFollow();                        }                        index = directives.indexOf("noarchive");                        if (index >= 0) {                            metaTags.setNoCache();                        }                    }                                }            }            if (equivNode != null) {                if (contentNode != null) {                    String name = equivNode.getNodeValue().toLowerCase();                    String content = contentNode.getNodeValue();                    metaTags.getHttpEquivTags().setProperty(name, content);                    if ("pragma".equals(name)) {                        content = content.toLowerCase();                        int index = content.indexOf("no-cache");                        if (index >= 0)                            metaTags.setNoCache();                    } else if ("refresh".equals(name)) {                        int idx = content.indexOf(';');                        String time = null;                        if (idx == -1) {                                                        time = content;                        } else                            time = content.substring(0, idx);                        try {                            metaTags.setRefreshTime(Integer.parseInt(time));                                                        metaTags.setRefresh(true);                        } catch (Exception e) {                            ;                        }                        URL refreshUrl = null;                        if (metaTags.getRefresh() && idx != -1) {                                                        idx = content.toLowerCase().indexOf("url=");                            if (idx == -1) {                                                                                                idx = content.indexOf(';') + 1;                            } else                                idx += 4;                            if (idx != -1) {                                String url = content.substring(idx);                                try {                                    refreshUrl = new URL(url);                                } catch (Exception e) {                                                                        try {                                        refreshUrl = new URL(currURL, url);                                    } catch (Exception e1) {                                        refreshUrl = null;                                    }                                }                            }                        }                        if (metaTags.getRefresh()) {                            if (refreshUrl == null) {                                                                                                refreshUrl = currURL;                            }                            metaTags.setRefreshHref(refreshUrl);                        }                    }                }            }        } else if ("base".equalsIgnoreCase(node.getNodeName())) {            NamedNodeMap attrs = node.getAttributes();            Node hrefNode = attrs.getNamedItem("href");            if (hrefNode != null) {                String urlString = hrefNode.getNodeValue();                URL url = null;                try {                    if (currURL == null)                        url = new URL(urlString);                    else                        url = new URL(currURL, urlString);                } catch (Exception e) {                    ;                }                if (url != null)                    metaTags.setBaseHref(url);            }        }    }    NodeList children = node.getChildNodes();    if (children != null) {        int len = children.getLength();        for (int i = 0; i < len; i++) {            getMetaTagsHelper(metaTags, children.item(i), currURL);        }    }}
0684c7deeaaaabdab956bca4171703c65cb24a7d8b4dfcae9a92d479dbb8ea54
sniffCharacterEncoding
private static String sniffCharacterEncoding(byte[] content)
{    int length = content.length < CHUNK_SIZE ? content.length : CHUNK_SIZE;                    String str = new String(content, 0, length, StandardCharsets.US_ASCII);    Matcher metaMatcher = metaPattern.matcher(str);    String encoding = null;    if (metaMatcher.find()) {        Matcher charsetMatcher = charsetPattern.matcher(metaMatcher.group(1));        if (charsetMatcher.find())            encoding = charsetMatcher.group(1);    }    if (encoding == null) {                metaMatcher = charsetPatternHTML5.matcher(str);        if (metaMatcher.find()) {            encoding = metaMatcher.group(1);        }    }    if (encoding == null) {                if (content.length >= 3 && content[0] == (byte) 0xEF && content[1] == (byte) 0xBB && content[2] == (byte) 0xBF) {            encoding = "UTF-8";        } else if (content.length >= 2) {            if (content[0] == (byte) 0xFF && content[1] == (byte) 0xFE) {                encoding = "UTF-16LE";            } else if (content[0] == (byte) 0xFE && content[1] == (byte) 0xFF) {                encoding = "UTF-16BE";            }        }    }    return encoding;}
74c073cf714c8a8285642be67ae2f28cd713bfd23722543918cc25b506734fed
getParse
public ParseResult getParse(Content content)
{    HTMLMetaTags metaTags = new HTMLMetaTags();    URL base;    try {        base = new URL(content.getBaseUrl());    } catch (MalformedURLException e) {        return new ParseStatus(e).getEmptyParseResult(content.getUrl(), getConf());    }    String text = "";    String title = "";    Outlink[] outlinks = new Outlink[0];    Metadata metadata = new Metadata();        DocumentFragment root;    try {        byte[] contentInOctets = content.getContent();        InputSource input = new InputSource(new ByteArrayInputStream(contentInOctets));        EncodingDetector detector = new EncodingDetector(conf);        detector.autoDetectClues(content, true);        detector.addClue(sniffCharacterEncoding(contentInOctets), "sniffed");        String encoding = detector.guessEncoding(content, defaultCharEncoding);        metadata.set(Metadata.ORIGINAL_CHAR_ENCODING, encoding);        metadata.set(Metadata.CHAR_ENCODING_FOR_CONVERSION, encoding);        input.setEncoding(encoding);        if (LOG.isTraceEnabled()) {            LOG.trace("Parsing...");        }        root = parse(input);    } catch (IOException e) {        return new ParseStatus(e).getEmptyParseResult(content.getUrl(), getConf());    } catch (DOMException e) {        return new ParseStatus(e).getEmptyParseResult(content.getUrl(), getConf());    } catch (SAXException e) {        return new ParseStatus(e).getEmptyParseResult(content.getUrl(), getConf());    } catch (Exception e) {        LOG.error("Error: ", e);        return new ParseStatus(e).getEmptyParseResult(content.getUrl(), getConf());    }        HTMLMetaProcessor.getMetaTags(metaTags, root, base);        metadata.addAll(metaTags.getGeneralTags());    if (LOG.isTraceEnabled()) {        LOG.trace("Meta tags for " + base + ": " + metaTags.toString());    }        if (!metaTags.getNoIndex()) {                StringBuffer sb = new StringBuffer();        if (LOG.isTraceEnabled()) {            LOG.trace("Getting text...");        }                utils.getText(sb, root);        text = sb.toString();        sb.setLength(0);        if (LOG.isTraceEnabled()) {            LOG.trace("Getting title...");        }                utils.getTitle(sb, root);        title = sb.toString().trim();    }    if (!metaTags.getNoFollow()) {                        ArrayList<Outlink> l = new ArrayList<Outlink>();        URL baseTag = base;        String baseTagHref = utils.getBase(root);        if (baseTagHref != null) {            try {                baseTag = new URL(base, baseTagHref);            } catch (MalformedURLException e) {                baseTag = base;            }        }        if (LOG.isTraceEnabled()) {            LOG.trace("Getting links...");        }        utils.getOutlinks(baseTag, l, root);        outlinks = l.toArray(new Outlink[l.size()]);        if (LOG.isTraceEnabled()) {            LOG.trace("found " + outlinks.length + " outlinks in " + content.getUrl());        }    }    ParseStatus status = new ParseStatus(ParseStatus.SUCCESS);    if (metaTags.getRefresh()) {        status.setMinorCode(ParseStatus.SUCCESS_REDIRECT);        status.setArgs(new String[] { metaTags.getRefreshHref().toString(), Integer.toString(metaTags.getRefreshTime()) });    }    ParseData parseData = new ParseData(status, title, outlinks, content.getMetadata(), metadata);    ParseResult parseResult = ParseResult.createParseResult(content.getUrl(), new ParseImpl(text, parseData));        ParseResult filteredParse = this.htmlParseFilters.filter(content, parseResult, metaTags, root);    if (metaTags.getNoCache()) {                for (Map.Entry<org.apache.hadoop.io.Text, Parse> entry : filteredParse) entry.getValue().getData().getParseMeta().set(Nutch.CACHING_FORBIDDEN_KEY, cachingPolicy);    }    return filteredParse;}
7855b1db7842b728ede90e5e4d00384f800ede8d5f09cffb232a397845ed5521
parse
private DocumentFragment parse(InputSource input) throws Exception
{    if ("tagsoup".equalsIgnoreCase(parserImpl))        return parseTagSoup(input);    else        return parseNeko(input);}
23efd273fde1e5b3055ef865ed08217a50e77ff25cdf8a460c5d7b8b1663681c
parseTagSoup
private DocumentFragment parseTagSoup(InputSource input) throws Exception
{    HTMLDocumentImpl doc = new HTMLDocumentImpl();    DocumentFragment frag = doc.createDocumentFragment();    DOMBuilder builder = new DOMBuilder(doc, frag);    org.ccil.cowan.tagsoup.Parser reader = new org.ccil.cowan.tagsoup.Parser();    reader.setContentHandler(builder);    reader.setFeature(org.ccil.cowan.tagsoup.Parser.ignoreBogonsFeature, true);    reader.setFeature(org.ccil.cowan.tagsoup.Parser.bogonsEmptyFeature, false);    reader.setProperty("http://xml.org/sax/properties/lexical-handler", builder);    reader.parse(input);    return frag;}
9cf6a25b9518be00346059cf5dc6a0ccac03d832e36f39ca1784c55e13d79079
parseNeko
private DocumentFragment parseNeko(InputSource input) throws Exception
{    DOMFragmentParser parser = new DOMFragmentParser();    try {        parser.setFeature("http://cyberneko.org/html/features/scanner/allow-selfclosing-iframe", true);        parser.setFeature("http://cyberneko.org/html/features/augmentations", true);        parser.setProperty("http://cyberneko.org/html/properties/default-encoding", defaultCharEncoding);        parser.setFeature("http://cyberneko.org/html/features/scanner/ignore-specified-charset", true);        parser.setFeature("http://cyberneko.org/html/features/balance-tags/ignore-outside-content", false);        parser.setFeature("http://cyberneko.org/html/features/balance-tags/document-fragment", true);        parser.setFeature("http://cyberneko.org/html/features/report-errors", LOG.isTraceEnabled());    } catch (SAXException e) {    }        HTMLDocumentImpl doc = new HTMLDocumentImpl();    doc.setErrorChecking(false);    DocumentFragment res = doc.createDocumentFragment();    DocumentFragment frag = doc.createDocumentFragment();    parser.parse(input, frag);    res.appendChild(frag);    try {        while (true) {            frag = doc.createDocumentFragment();            parser.parse(input, frag);            if (!frag.hasChildNodes())                break;            if (LOG.isInfoEnabled()) {                LOG.info(" - new frag, " + frag.getChildNodes().getLength() + " nodes.");            }            res.appendChild(frag);        }    } catch (Exception e) {        LOG.error("Error: ", e);    }    ;    return res;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    String name = args[0];    String url = "file:" + name;    File file = new File(name);    byte[] bytes = new byte[(int) file.length()];    @SuppressWarnings("resource")    DataInputStream in = new DataInputStream(new FileInputStream(file));    in.readFully(bytes);    Configuration conf = NutchConfiguration.create();    HtmlParser parser = new HtmlParser();    parser.setConf(conf);    Parse parse = parser.getParse(new Content(url, url, bytes, "text/html", new Metadata(), conf)).get(url);    System.out.println("data: " + parse.getData());    System.out.println("text: " + parse.getText());}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    this.htmlParseFilters = new HtmlParseFilters(getConf());    this.parserImpl = getConf().get("parser.html.impl", "neko");    this.defaultCharEncoding = getConf().get("parser.character.encoding.default", "windows-1252");    this.utils = new DOMContentUtils(conf);    this.cachingPolicy = getConf().get("parser.caching.forbidden.policy", Nutch.CACHING_FORBIDDEN_CONTENT);}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
6ddc28e886774e02e40e04cb6b0607a25196c901489e0329ce4b951e2b12438f
isWhiteSpace
public static boolean isWhiteSpace(char ch)
{    return (ch == 0x20) || (ch == 0x09) || (ch == 0xD) || (ch == 0xA);}
5f6e8bf8d8bcc1d40dc3c6ed9ce9a6f2494e02825ceabcb6cb50e1c5340657af
isWhiteSpace
public static boolean isWhiteSpace(char[] ch, int start, int length)
{    int end = start + length;    for (int s = start; s < end; s++) {        if (!isWhiteSpace(ch[s]))            return false;    }    return true;}
c648fa632c7827d2f1188caaa6432e58bcfde81f34cb62511efafd6e6fe9b035
isWhiteSpace
public static boolean isWhiteSpace(StringBuffer buf)
{    int n = buf.length();    for (int i = 0; i < n; i++) {        if (!isWhiteSpace(buf.charAt(i)))            return false;    }    return true;}
6bbfbda78c7e36ac2ca1b1a626a04c3a9992a68c3c641a2978995ba9e11f784a
isWhiteSpace
public static boolean isWhiteSpace(String s)
{    if (null != s) {        int n = s.length();        for (int i = 0; i < n; i++) {            if (!isWhiteSpace(s.charAt(i)))                return false;        }    }    return true;}
5ff0b8f7d2b080bcc6214fa5f91be74727145ea81cacb63a99c8d0f3106c089f
setup
public void setup()
{    conf = NutchConfiguration.create();    conf.setBoolean("parser.html.form.use_action", true);    utils = new DOMContentUtils(conf);    DOMFragmentParser parser = new DOMFragmentParser();    try {        parser.setFeature("http://cyberneko.org/html/features/scanner/allow-selfclosing-iframe", true);    } catch (SAXException e) {    }    for (int i = 0; i < testPages.length; i++) {        DocumentFragment node = new HTMLDocumentImpl().createDocumentFragment();        try {            parser.parse(new InputSource(new ByteArrayInputStream(testPages[i].getBytes())), node);            testBaseHrefURLs[i] = new URL(testBaseHrefs[i]);        } catch (Exception e) {            Assert.assertTrue("caught exception: " + e, false);        }        testDOMs[i] = node;    }    try {        answerOutlinks = new Outlink[][] { { new Outlink("http://www.nutch.org", "anchor") }, { new Outlink("http://www.nutch.org/", "home"), new Outlink("http://www.nutch.org/docs/bot.html", "bots") }, { new Outlink("http://www.nutch.org/", "separate this"), new Outlink("http://www.nutch.org/docs/ok", "from this") }, { new Outlink("http://www.nutch.org/", "home"), new Outlink("http://www.nutch.org/docs/1", "1"), new Outlink("http://www.nutch.org/docs/2", "2") }, { new Outlink("http://www.nutch.org/frames/top.html", ""), new Outlink("http://www.nutch.org/frames/left.html", ""), new Outlink("http://www.nutch.org/frames/invalid.html", ""), new Outlink("http://www.nutch.org/frames/right.html", "") }, { new Outlink("http://www.nutch.org/maps/logo.gif", ""), new Outlink("http://www.nutch.org/index.html", ""), new Outlink("http://www.nutch.org/maps/#bottom", ""), new Outlink("http://www.nutch.org/bot.html", ""), new Outlink("http://www.nutch.org/docs/index.html", "") }, { new Outlink("http://www.nutch.org/index.html", "whitespace test") }, {}, { new Outlink("http://www.nutch.org/dummy.jsp", "test2") }, {}, { new Outlink("http://www.nutch.org/;x", "anchor1"), new Outlink("http://www.nutch.org/g;x", "anchor2"), new Outlink("http://www.nutch.org/g;x?y#s", "anchor3") }, {         new Outlink("http://www.nutch.org/g", "anchor1"), new Outlink("http://www.nutch.org/g?y#s", "anchor2"), new Outlink("http://www.nutch.org/;something?y=1", "anchor3"), new Outlink("http://www.nutch.org/;something?y=1#s", "anchor4"), new Outlink("http://www.nutch.org/;something?y=1;somethingelse", "anchor5") }, { new Outlink("http://www.nutch.org/g", ""), new Outlink("http://www.nutch.org/g1", ""), new Outlink("http://www.nutch.org/g2", "bla bla"), new Outlink("http://www.nutch.org/test.gif", "bla bla") }, { new Outlink("http://www.nutch.org/movie.mp4", "") } };    } catch (MalformedURLException e) {    }}
ac425a9e5f3767c9c53f24ac867336433e49b74281fa213cfc12c1b8f381d073
equalsIgnoreWhitespace
private static boolean equalsIgnoreWhitespace(String s1, String s2)
{    StringTokenizer st1 = new StringTokenizer(s1);    StringTokenizer st2 = new StringTokenizer(s2);    while (st1.hasMoreTokens()) {        if (!st2.hasMoreTokens())            return false;        if (!st1.nextToken().equals(st2.nextToken()))            return false;    }    if (st2.hasMoreTokens())        return false;    return true;}
493d12ba7e43168a12b6531fe05e66cf24afd4176e0bfe303044cdc537e8b909
testGetText
public void testGetText()
{    if (testDOMs[0] == null)        setup();    for (int i = 0; i < testPages.length; i++) {        StringBuffer sb = new StringBuffer();        utils.getText(sb, testDOMs[i]);        String text = sb.toString();        Assert.assertTrue("expecting text: " + answerText[i] + System.getProperty("line.separator") + System.getProperty("line.separator") + "got text: " + text, equalsIgnoreWhitespace(answerText[i], text));    }}
5eb5aee56d7035ea97b56d81cf7d74f041cbcec8e5ec2f5ba5aad30426c4874e
testGetTitle
public void testGetTitle()
{    if (testDOMs[0] == null)        setup();    for (int i = 0; i < testPages.length; i++) {        StringBuffer sb = new StringBuffer();        utils.getTitle(sb, testDOMs[i]);        String text = sb.toString();        Assert.assertTrue("expecting text: " + answerText[i] + System.getProperty("line.separator") + System.getProperty("line.separator") + "got text: " + text, equalsIgnoreWhitespace(answerTitle[i], text));    }}
3b09fd38df37e09744d76bb048d6982ee74f6f0e306126ee99357e686aadebbf
testGetOutlinks
public void testGetOutlinks()
{    if (testDOMs[0] == null)        setup();    for (int i = 0; i < testPages.length; i++) {        ArrayList<Outlink> outlinks = new ArrayList<Outlink>();        if (i == SKIP) {            conf.setBoolean("parser.html.form.use_action", false);            utils.setConf(conf);        } else {            conf.setBoolean("parser.html.form.use_action", true);            utils.setConf(conf);        }        utils.getOutlinks(testBaseHrefURLs[i], outlinks, testDOMs[i]);        Outlink[] outlinkArr = new Outlink[outlinks.size()];        outlinkArr = (Outlink[]) outlinks.toArray(outlinkArr);        compareOutlinks(answerOutlinks[i], outlinkArr);    }}
6559447b281797e3386f6c83b2d2beba3702f57636aeb945bc44463331dd8c55
appendOutlinks
private static final void appendOutlinks(StringBuffer sb, Outlink[] o)
{    for (int i = 0; i < o.length; i++) {        sb.append(o[i].toString());        sb.append(System.getProperty("line.separator"));    }}
b5760eb17e87ef9bb77639841852251ad2e10bc5bbb7126765d6852178059057
outlinksString
private static final String outlinksString(Outlink[] o)
{    StringBuffer sb = new StringBuffer();    appendOutlinks(sb, o);    return sb.toString();}
948777d56f9851037784c925838a439cc798900a6923bf003221abeb913c00a3
compareOutlinks
private static final void compareOutlinks(Outlink[] o1, Outlink[] o2)
{    if (o1.length != o2.length) {        Assert.assertTrue("got wrong number of outlinks (expecting " + o1.length + ", got " + o2.length + ")" + System.getProperty("line.separator") + "answer: " + System.getProperty("line.separator") + outlinksString(o1) + System.getProperty("line.separator") + "got: " + System.getProperty("line.separator") + outlinksString(o2) + System.getProperty("line.separator"), false);    }    for (int i = 0; i < o1.length; i++) {        if (!o1[i].equals(o2[i])) {            Assert.assertTrue("got wrong outlinks at position " + i + System.getProperty("line.separator") + "answer: " + System.getProperty("line.separator") + "'" + o1[i].getToUrl() + "', anchor: '" + o1[i].getAnchor() + "'" + System.getProperty("line.separator") + "got: " + System.getProperty("line.separator") + "'" + o2[i].getToUrl() + "', anchor: '" + o2[i].getAnchor() + "'", false);        }    }}
06d447c076c2d00cc2bf0eb565b5d49f76e0952d23504524992886533ebeb04e
parse
protected Parse parse(byte[] contentBytes)
{    String dummyUrl = "http://example.com/";    return parser.getParse(new Content(dummyUrl, dummyUrl, contentBytes, "text/html", new Metadata(), conf)).get(dummyUrl);}
683a48e3108b654e11fffe4c463780827a5c8a2bb051f9ccd5b967a979824a6b
testEncodingDetection
public void testEncodingDetection()
{    for (String[] testPage : encodingTestPages) {        String name = testPage[0];        Charset charset = Charset.forName(testPage[1]);        byte[] contentBytes = testPage[2].getBytes(charset);        Parse parse = parse(contentBytes);        String text = parse.getText();        String title = parse.getData().getTitle();        String keywords = parse.getData().getMeta("keywords");        LOG.info(name);        LOG.info("title:\t" + title);        LOG.info("keywords:\t" + keywords);        LOG.info("text:\t" + text);        Assert.assertEquals("Title not extracted properly (" + name + ")", encodingTestKeywords, title);        for (String keyword : encodingTestKeywords.split(",\\s*")) {            Assert.assertTrue(keyword + " not found in text (" + name + ")", text.contains(keyword));        }        Assert.assertNotNull("No keywords extracted", keywords);        Assert.assertEquals("Keywords not extracted properly (" + name + ")", encodingTestKeywords, keywords);    }}
dc56467aa55b796d0e70001f5746d7c32f47eedf17e9c1d5502f4e0b12f28b24
testResolveBaseUrl
public void testResolveBaseUrl()
{    byte[] contentBytes = resolveBaseUrlTestContent.getBytes(StandardCharsets.UTF_8);        Parse parse = parse(contentBytes);    LOG.info(parse.getData().toString());    Outlink[] outlinks = parse.getData().getOutlinks();    Assert.assertEquals(1, outlinks.length);    Assert.assertEquals("http://www.example.com/index.html", outlinks[0].getToUrl());}
7b701e8d772d10800b92a5003da7437a4804fe9bb4d42d8e13833ddc2e831eeb
testRobotsMetaProcessor
public void testRobotsMetaProcessor()
{    DOMFragmentParser parser = new DOMFragmentParser();    ;    try {        currURLsAndAnswers = new URL[][] { { new URL("http://www.nutch.org"), null }, { new URL("http://www.nutch.org"), null }, { new URL("http://www.nutch.org"), null }, { new URL("http://www.nutch.org"), null }, { new URL("http://www.nutch.org"), null }, { new URL("http://www.nutch.org"), null }, { new URL("http://www.nutch.org"), null }, { new URL("http://www.nutch.org/foo/"), new URL("http://www.nutch.org/") }, { new URL("http://www.nutch.org"), new URL("http://www.nutch.org/base/") } };    } catch (Exception e) {        Assert.assertTrue("couldn't make test URLs!", false);    }    for (int i = 0; i < tests.length; i++) {        byte[] bytes = tests[i].getBytes();        DocumentFragment node = new HTMLDocumentImpl().createDocumentFragment();        try {            parser.parse(new InputSource(new ByteArrayInputStream(bytes)), node);        } catch (Exception e) {            e.printStackTrace();        }        HTMLMetaTags robotsMeta = new HTMLMetaTags();        HTMLMetaProcessor.getMetaTags(robotsMeta, node, currURLsAndAnswers[i][0]);        Assert.assertTrue("got index wrong on test " + i, robotsMeta.getNoIndex() == answers[i][0]);        Assert.assertTrue("got follow wrong on test " + i, robotsMeta.getNoFollow() == answers[i][1]);        Assert.assertTrue("got cache wrong on test " + i, robotsMeta.getNoCache() == answers[i][2]);        Assert.assertTrue("got base href wrong on test " + i + " (got " + robotsMeta.getBaseHref() + ")", ((robotsMeta.getBaseHref() == null) && (currURLsAndAnswers[i][1] == null)) || ((robotsMeta.getBaseHref() != null) && robotsMeta.getBaseHref().equals(currURLsAndAnswers[i][1])));    }}
9ff841f3d46425f0defcf4346027b52742d29abc435829a9bc29d5c88e553a7b
filter
public ParseResult filter(Content content, ParseResult parseResult, HTMLMetaTags metaTags, DocumentFragment doc)
{    Parse parse = parseResult.get(content.getUrl());    String url = content.getBaseUrl();    ArrayList<Outlink> outlinks = new ArrayList<Outlink>();    walk(doc, parse, metaTags, url, outlinks);    if (outlinks.size() > 0) {        Outlink[] old = parse.getData().getOutlinks();        String title = parse.getData().getTitle();        List<Outlink> list = Arrays.asList(old);        outlinks.addAll(list);        ParseStatus status = parse.getData().getStatus();        String text = parse.getText();        Outlink[] newlinks = (Outlink[]) outlinks.toArray(new Outlink[outlinks.size()]);        ParseData parseData = new ParseData(status, title, newlinks, parse.getData().getContentMeta(), parse.getData().getParseMeta());                parseResult.put(content.getUrl(), new ParseText(text), parseData);    }    return parseResult;}
5b7b7844f574b9f3516636ac94de64bb8ba95acb5a51ac06c85ade27786e4d2f
walk
private void walk(Node n, Parse parse, HTMLMetaTags metaTags, String base, List<Outlink> outlinks)
{    if (n instanceof Element) {        String name = n.getNodeName();        if (name.equalsIgnoreCase("script")) {            /*         * String lang = null; Node lNode =         * n.getAttributes().getNamedItem("language"); if (lNode == null) lang =         * "javascript"; else lang = lNode.getNodeValue();         */            StringBuffer script = new StringBuffer();            NodeList nn = n.getChildNodes();            if (nn.getLength() > 0) {                for (int i = 0; i < nn.getLength(); i++) {                    if (i > 0)                        script.append('\n');                    script.append(nn.item(i).getNodeValue());                }                                                                                Outlink[] links = getJSLinks(script.toString(), "", base);                if (links != null && links.length > 0)                    outlinks.addAll(Arrays.asList(links));                                return;            }        } else {                        NamedNodeMap attrs = n.getAttributes();            int len = attrs.getLength();            for (int i = 0; i < len; i++) {                                                                                                Node anode = attrs.item(i);                Outlink[] links = null;                if (anode.getNodeName().startsWith("on")) {                    links = getJSLinks(anode.getNodeValue(), "", base);                } else if (anode.getNodeName().equalsIgnoreCase("href")) {                    String val = anode.getNodeValue();                    if (val != null && val.toLowerCase().indexOf("javascript:") != -1) {                        links = getJSLinks(val, "", base);                    }                }                if (links != null && links.length > 0)                    outlinks.addAll(Arrays.asList(links));            }        }    }    NodeList nl = n.getChildNodes();    for (int i = 0; i < nl.getLength(); i++) {        walk(nl.item(i), parse, metaTags, base, outlinks);    }}
9b3e7b8f878015859eefa9ffec8fd99756ee11820ee4643b646a30d27d86bc88
getParse
public ParseResult getParse(Content c)
{    String script = new String(c.getContent());    Outlink[] outlinks = getJSLinks(script, "", c.getUrl());    if (outlinks == null)        outlinks = new Outlink[0];        String title;    int idx = script.indexOf('\n');    if (idx != -1) {        if (idx > MAX_TITLE_LEN)            idx = MAX_TITLE_LEN;        title = script.substring(0, idx);    } else {        idx = Math.min(MAX_TITLE_LEN, script.length());        title = script.substring(0, idx);    }    ParseData pd = new ParseData(ParseStatus.STATUS_SUCCESS, title, outlinks, c.getMetadata());    return ParseResult.createParseResult(c.getUrl(), new ParseImpl(script, pd));}
39509632215ebb877df7ff8e7ed82f2d6feaacba74329379eadf292641f1315c
getJSLinks
private Outlink[] getJSLinks(String plainText, String anchor, String base)
{    final List<Outlink> outlinks = new ArrayList<Outlink>();    URL baseURL = null;    try {        baseURL = new URL(base);    } catch (Exception e) {        if (LOG.isErrorEnabled()) {            LOG.error("error assigning base URL", e);        }    }    try {        Matcher matcher = STRING_PATTERN.matcher(plainText);        String url;        while (matcher.find()) {            url = matcher.group(2);            Matcher matcherUri = URI_PATTERN.matcher(url);            if (!matcherUri.matches()) {                continue;            }            if (url.startsWith("www.")) {                url = "http://" + url;            } else {                                try {                    url = new URL(baseURL, url).toString();                } catch (MalformedURLException ex) {                    if (LOG.isTraceEnabled()) {                        LOG.trace(" - failed URL parse '" + url + "' and baseURL '" + baseURL + "'", ex);                    }                    continue;                }            }            url = url.replaceAll("&amp;", "&");            if (LOG.isTraceEnabled()) {                LOG.trace(" - outlink from JS: '" + url + "'");            }            outlinks.add(new Outlink(url, anchor));        }    } catch (Exception ex) {                if (LOG.isErrorEnabled()) {            LOG.error(" - invalid or malformed URL", ex);        }    }    final Outlink[] retval;        if (outlinks != null && outlinks.size() > 0) {        retval = outlinks.toArray(new Outlink[0]);    } else {        retval = new Outlink[0];    }    return retval;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    if (args.length < 2) {        System.err.println(JSParseFilter.class.getName() + " file.js baseURL");        return;    }    InputStream in = new FileInputStream(args[0]);    BufferedReader br = new BufferedReader(new InputStreamReader(in, "UTF-8"));    StringBuffer sb = new StringBuffer();    String line = null;    while ((line = br.readLine()) != null) sb.append(line + "\n");    br.close();    JSParseFilter parseFilter = new JSParseFilter();    parseFilter.setConf(NutchConfiguration.create());    Outlink[] links = parseFilter.getJSLinks(sb.toString(), "", args[1]);    System.out.println("Outlinks extracted: " + links.length);    for (int i = 0; i < links.length; i++) System.out.println(" - " + links[i]);}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    conf = NutchConfiguration.create();    conf.set("file.content.limit", "-1");    conf.set("plugin.includes", "protocol-file|parse-(html|js)");}
c4a07a355b0853e4f83c92adcdf36e1f64faf1b0c94bdea4e415e7edf0138e7d
getOutlinks
public Outlink[] getOutlinks(String sampleFile) throws ProtocolException, ParseException, IOException
{    String urlString;    Parse parse;    urlString = "file:" + sampleDir + fileSeparator + sampleFile;    LOG.info("Parsing {}", urlString);    Protocol protocol = new ProtocolFactory(conf).getProtocol(urlString);    Content content = protocol.getProtocolOutput(new Text(urlString), new CrawlDatum()).getContent();    parse = new ParseUtil(conf).parse(content).get(content.getUrl());    LOG.info(parse.getData().toString());    return parse.getData().getOutlinks();}
d72ec9afa8b632e23446c309bc807285a8df9f74c49e634aabdf93f65c89ad1f
testJavaScriptOutlinkExtraction
public void testJavaScriptOutlinkExtraction() throws ProtocolException, ParseException, IOException
{    String[] filenames = new File(sampleDir).list();    for (int i = 0; i < filenames.length; i++) {        Outlink[] outlinks = getOutlinks(filenames[i]);        if (filenames[i].endsWith("parse_pure_js_test.js")) {            assertEquals("number of outlinks in .js test file should be X", 2, outlinks.length);            assertEquals("http://search.lucidimagination.com/p:nutch", outlinks[0].getToUrl());            assertEquals("http://search-lucene.com/nutch", outlinks[1].getToUrl());        } else {            assertTrue("number of outlinks in .html file should be at least 2", outlinks.length >= 2);            Set<String> outlinkSet = new TreeSet<>();            for (Outlink o : outlinks) {                outlinkSet.add(o.getToUrl());            }            assertTrue("http://search.lucidimagination.com/p:nutch not in outlinks", outlinkSet.contains("http://search.lucidimagination.com/p:nutch"));            assertTrue("http://search-lucene.com/nutch not in outlinks", outlinkSet.contains("http://search-lucene.com/nutch"));        }    }}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;            String[] values = conf.getStrings("metatags.names", "*");    for (String val : values) {        metatagset.add(val.toLowerCase(Locale.ROOT));    }}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
0c62caa27551e0e8a53e00248f3fdc45bc91489652d5b4ef6ef61b11221b7f69
addIndexedMetatags
private void addIndexedMetatags(Metadata metadata, String metatag, String value)
{    String lcMetatag = metatag.toLowerCase(Locale.ROOT);    if (metatagset.contains("*") || metatagset.contains(lcMetatag)) {        if (LOG.isDebugEnabled()) {            LOG.debug("Found meta tag: " + lcMetatag + "\t" + value);        }        metadata.add("metatag." + lcMetatag, value);    }}
81bd0323fe9f21d9804e7e3d6dce6af5c5aaff8e7c74406ce88a74ce91efc7a8
addIndexedMetatags
private void addIndexedMetatags(Metadata metadata, String metatag, String[] values)
{    String lcMetatag = metatag.toLowerCase(Locale.ROOT);    if (metatagset.contains("*") || metatagset.contains(lcMetatag)) {        for (String value : values) {            if (LOG.isDebugEnabled()) {                LOG.debug("Found meta tag: " + lcMetatag + "\t" + value);            }            metadata.add("metatag." + lcMetatag, value);        }    }}
9ff841f3d46425f0defcf4346027b52742d29abc435829a9bc29d5c88e553a7b
filter
public ParseResult filter(Content content, ParseResult parseResult, HTMLMetaTags metaTags, DocumentFragment doc)
{    Parse parse = parseResult.get(content.getUrl());    Metadata metadata = parse.getData().getParseMeta();        for (String mdName : metadata.names()) {        addIndexedMetatags(metadata, mdName, metadata.getValues(mdName));    }    Metadata generalMetaTags = metaTags.getGeneralTags();    for (String tagName : generalMetaTags.names()) {        addIndexedMetatags(metadata, tagName, generalMetaTags.getValues(tagName));    }    Properties httpequiv = metaTags.getHttpEquivTags();    for (Enumeration<?> tagNames = httpequiv.propertyNames(); tagNames.hasMoreElements(); ) {        String name = (String) tagNames.nextElement();        String value = httpequiv.getProperty(name);        addIndexedMetatags(metadata, name, value);    }    return parseResult;}
99d929d9ddbae4fbe0f3edbfd4d7e2abd3d4f3e028820471af7becae8874ca39
parseMeta
public Metadata parseMeta(String fileName, Configuration conf)
{    Metadata metadata = null;    try {        String urlString = "file:" + sampleDir + fileSeparator + fileName;        Protocol protocol = new ProtocolFactory(conf).getProtocol(urlString);        Content content = protocol.getProtocolOutput(new Text(urlString), new CrawlDatum()).getContent();        Parse parse = new ParseUtil(conf).parse(content).get(content.getUrl());        metadata = parse.getData().getParseMeta();    } catch (Exception e) {        e.printStackTrace();        Assert.fail(e.toString());    }    return metadata;}
1b4a91ebefa65385070f97aea305f20cee892eaca12ae28ee32ab6ad236b8eb8
testIt
public void testIt()
{    Configuration conf = NutchConfiguration.create();        Metadata parseMeta = parseMeta(sampleFile, conf);    Assert.assertEquals(description, parseMeta.get("metatag.description"));    Assert.assertEquals(keywords, parseMeta.get("metatag.keywords"));}
c3da63db55a00d75e2676a5a66620705b680ecf16515f660822f8a96960cc6ae
testMultiValueMetatags
public void testMultiValueMetatags()
{    Configuration conf = NutchConfiguration.create();    conf.set("metatags.names", "keywords,DC.creator");    conf.set("index.parse.md", "metatag.keywords,metatag.dc.creator");    Metadata parseMeta = parseMeta(sampleFileMultival, conf);    String failMessage = "One value of metatag with multiple values is missing: ";    Set<String> valueSet = new TreeSet<String>();    for (String val : parseMeta.getValues("metatag.dc.creator")) {        valueSet.add(val);    }    String[] expectedValues1 = { "Doug Cutting", "Michael Cafarella" };    for (String val : expectedValues1) {        Assert.assertTrue(failMessage + val, valueSet.contains(val));    }    valueSet.clear();    for (String val : parseMeta.getValues("metatag.keywords")) {        valueSet.add(val);    }    String[] expectedValues2 = { "robot d'indexation", "web crawler", "Webcrawler" };    for (String val : expectedValues2) {        Assert.assertTrue(failMessage + val, valueSet.contains(val));    }}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
74c073cf714c8a8285642be67ae2f28cd713bfd23722543918cc25b506734fed
getParse
public ParseResult getParse(Content content)
{    String text = null;    Vector<Outlink> outlinks = new Vector<>();    try {        byte[] raw = content.getContent();        String contentLength = content.getMetadata().get(Response.CONTENT_LENGTH);        if (contentLength != null && raw.length != Integer.parseInt(contentLength)) {            return new ParseStatus(ParseStatus.FAILED, ParseStatus.FAILED_TRUNCATED, "Content truncated at " + raw.length + " bytes. Parser can't handle incomplete files.").getEmptyParseResult(content.getUrl(), getConf());        }        ExtractText extractor = new ExtractText();                TagParser parser = new TagParser(extractor);                                SWFReader reader = new SWFReader(parser, new InStream(raw));                reader.readFile();        text = extractor.getText();        String atext = extractor.getActionText();        if (atext != null && atext.length() > 0)            text += "\n--------\n" + atext;                String[] links = extractor.getUrls();        for (int i = 0; i < links.length; i++) {            Outlink out = new Outlink(links[i], "");            outlinks.add(out);        }        Outlink[] olinks = OutlinkExtractor.getOutlinks(text, conf);        if (olinks != null)            for (int i = 0; i < olinks.length; i++) {                outlinks.add(olinks[i]);            }    } catch (Exception e) {                LOG.error("Error, runtime exception: ", e);        return new ParseStatus(ParseStatus.FAILED, "Can't be handled as SWF document. " + e).getEmptyParseResult(content.getUrl(), getConf());    }    if (text == null)        text = "";    Outlink[] links = (Outlink[]) outlinks.toArray(new Outlink[outlinks.size()]);    ParseData parseData = new ParseData(ParseStatus.STATUS_SUCCESS, "", links, content.getMetadata());    return ParseResult.createParseResult(content.getUrl(), new ParseImpl(text, parseData));}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    FileInputStream in = new FileInputStream(args[0]);    byte[] buf = new byte[in.available()];    in.read(buf);    in.close();    SWFParser parser = new SWFParser();    ParseResult parseResult = parser.getParse(new Content("file:" + args[0], "file:" + args[0], buf, "application/x-shockwave-flash", new Metadata(), NutchConfiguration.create()));    Parse p = parseResult.get("file:" + args[0]);    System.out.println("Parse Text:");    System.out.println(p.getText());    System.out.println("Parse Data:");    System.out.println(p.getData());}
496805007af0b81862a2d8c2609ce7b43ae81205859ec65f6872584c88bc5dc7
getText
public String getText()
{    StringBuffer res = new StringBuffer();    Iterator<String> it = strings.iterator();    while (it.hasNext()) {        if (res.length() > 0)            res.append(' ');        res.append(it.next());    }    return res.toString();}
81d8f686de2fb1dfc40728451800eeba3954b430d88d06330b01039bca4551b8
getActionText
public String getActionText()
{    StringBuffer res = new StringBuffer();    String[] strings = (String[]) actionStrings.toArray(new String[actionStrings.size()]);    Arrays.sort(strings);    for (int i = 0; i < strings.length; i++) {        if (i > 0)            res.append('\n');        res.append(strings[i]);    }    return res.toString();}
48b45ac5d4a8b9ef7405e808b83687741f7d8ad4ac0e10a5b21ac346975311b3
getUrls
public String[] getUrls()
{    String[] res = new String[urls.size()];    int i = 0;    Iterator<String> it = urls.iterator();    while (it.hasNext()) {        res[i] = it.next();        i++;    }    return res;}
a3dd7488c9f234adb2ae8f3a294271432c97dfbd36a56a3a900d016d45abca9a
tagDefineFontInfo2
public void tagDefineFontInfo2(int arg0, String arg1, int arg2, int[] arg3, int arg4) throws IOException
{    tagDefineFontInfo(arg0, arg1, arg2, arg3);}
66db97fb2a382f2071ffae9fdec4c1a053bf32b3ddb578dab5340b217e80f4ab
tagDefineFontInfo
public void tagDefineFontInfo(int fontId, String fontName, int flags, int[] codes) throws IOException
{            fontCodes.put(Integer.valueOf(fontId), codes);}
e9d3d69c011c2a74b0ed36954b32b7e16fcb45ce26f4048d518aeaa03df18700
tagDefineFont2
public SWFVectors tagDefineFont2(int id, int flags, String name, int numGlyphs, int ascent, int descent, int leading, int[] codes, int[] advances, Rect[] bounds, int[] kernCodes1, int[] kernCodes2, int[] kernAdjustments) throws IOException
{    fontCodes.put(Integer.valueOf(id), (codes != null) ? codes : new int[0]);    return null;}
13ec91c9280ba26c34f059d6c4cbb1f06bf22d1a99a08578f5bf0b96f38d3fe2
tagDefineTextField
public void tagDefineTextField(int fieldId, String fieldName, String initialText, Rect boundary, int flags, AlphaColor textColor, int alignment, int fontId, int fontSize, int charLimit, int leftMargin, int rightMargin, int indentation, int lineSpacing) throws IOException
{    if (initialText != null) {        strings.add(initialText);    }}
f8f4badb6477c2a9855408d3191608ca96470bf2229db04280c2df9632066d4e
tagDefineText
public SWFText tagDefineText(int id, Rect bounds, Matrix matrix) throws IOException
{    lastBounds = curBounds;    curBounds = bounds;    return new TextDumper();}
2b0fb74202e9148308a4a4760f319a0518af17add8bcf8d266a0dcc6812b34a1
tagDefineText2
public SWFText tagDefineText2(int id, Rect bounds, Matrix matrix) throws IOException
{    lastBounds = curBounds;    curBounds = bounds;    return new TextDumper();}
8797d4ce36bf2f605d1ac1e50d49e8093473c19e7d4288caf92155fb5d88fe75
font
public void font(int fontId, int textHeight)
{    this.fontId = fontId;}
41dc06276aac33f6f97d48176bd0f353530cb937b4db9eb03540a5f0fae24982
setY
public void setY(int y)
{    if (firstY)        firstY = false;    else                strings.add("\n");}
1771b72f96ce763cb9724f993603327a69658a15eebba26ecb6266cf50ecb330
text
public void text(int[] glyphIndices, int[] glyphAdvances)
{    int[] codes = (int[]) fontCodes.get(fontId);    if (codes == null) {                strings.add("\n**** ?????????????? ****\n");        return;    }        char[] chars = new char[glyphIndices.length];    for (int i = 0; i < chars.length; i++) {        int index = glyphIndices[i];        if (        index >= codes.length) {            chars[i] = (char) index;        } else {            chars[i] = (char) (codes[index]);        }    }    strings.add(new String(chars));}
1ca0da35997c557844ceb80055b82a3fffdd019233fb73a0617f8a34ff1ee195
color
public void color(Color color)
{}
2738bdbefe5f74bbbf31d8bff4e01e36b9656d5fcd01d73b376e13111c26cfe5
setX
public void setX(int x)
{}
2cdd2e5c1905c6d5bfd67c1767ee22b68131abbf09fe5beffdd5bd8f9b6a6cff
done
public void done()
{    strings.add("\n");}
d4972223682985157f067285a0474851c54c7345809af75b41ec91b6c7617c5d
tagDoAction
public SWFActions tagDoAction() throws IOException
{    return new NutchSWFActions(actionStrings, urls);}
e2b0f897ba69494480e3ee02c1a3bb95890abfcb566b486cdedaf2d89fc8c705
tagDoInitAction
public SWFActions tagDoInitAction(int arg0) throws IOException
{    return new NutchSWFActions(actionStrings, urls);}
a7af4266488195c021e3132c328d443bef14291396a9e812575b747927ddf851
lookupTable
public void lookupTable(String[] values) throws IOException
{    for (int i = 0; i < values.length; i++) {        if (!strings.contains(values[i]))            strings.add(values[i]);    }    super.lookupTable(values);    dict = values;}
fac208c2510fc27c38e09c14c49a84f43e3dabe79568a2d6d7a5c0c1a0dcf3ac
defineLocal
public void defineLocal() throws IOException
{    stack.pop();    super.defineLocal();}
d5c69369ac675a190712351ae6b86af31c7c2c360f4cc2109326b03c1e6447d0
getURL
public void getURL(int vars, int mode)
{}
d9ff89e9e4dd901f1142ba9019ce41438d62eda3db842453346e29da8ea66105
getURL
public void getURL(String url, String target) throws IOException
{    stack.push(url);    stack.push(target);    strings.remove(url);    strings.remove(target);    urls.add(url);    super.getURL(url, target);}
d2b37c7ef31c0bd3ce5fd9e6db6a069b4e74e69192b66a738fc05903c5d2834e
_try
public SWFActionBlock.TryCatchFinally _try(String var) throws IOException
{    strings.remove(var);    return super._try(var);}
f5818e4d7b7645b9945238313225ec9b980b4186f8b22d5c597d82bf1b16b207
comment
public void comment(String var) throws IOException
{    strings.remove(var);    super.comment(var);}
33fafbe95dcd6dfeb5132c357dc996a283a3eee6d163a42f6b0055340d0126cb
goToFrame
public void goToFrame(String var) throws IOException
{    stack.push(var);    strings.remove(var);    super.gotoFrame(var);}
45461d7a2ca8684530222d9465ff262e1caaeeef737a188a4561b6dc2112d2b1
ifJump
public void ifJump(String var) throws IOException
{    strings.remove(var);    super.ifJump(var);}
64ec56eeb2bbe3491076e557f66b8bcb14c25c011417970f085e42cb6f2d92fb
jump
public void jump(String var) throws IOException
{    strings.remove(var);    super.jump(var);}
11729347e0fb4a73ef8e4ee5aa6b65178008ef99b8298f6d51dc6c7049a0924c
jumpLabel
public void jumpLabel(String var) throws IOException
{    strings.remove(var);    super.jumpLabel(var);}
33b8374e0f94c98299ffe829e7c657b0bed755b006514dd4db43f88680f557ee
lookup
public void lookup(int var) throws IOException
{    if (dict != null && var >= 0 && var < dict.length) {        stack.push(dict[var]);    }    super.lookup(var);}
33a81cc103c775b56d828f1a253c6dcf777c9f92a33026b8dcd158c360b4f2e9
push
public void push(String var) throws IOException
{    stack.push(var);    strings.remove(var);    super.push(var);}
2ff1cebf097b27845e65c61ff749b09f76c49c3a7e116f7aad55df20196c9384
setTarget
public void setTarget(String var) throws IOException
{    stack.push(var);    strings.remove(var);    super.setTarget(var);}
077cd4088f8260145087bb814f1b796d6b4c2768921ceac4567b9669ff649296
startFunction
public SWFActionBlock startFunction(String var, String[] params) throws IOException
{    stack.push(var);    strings.remove(var);    if (params != null) {        for (int i = 0; i < params.length; i++) {            strings.remove(params[i]);        }    }    return this;}
7b38a3bbddad314c4259c5082e82ad8af4b2993ab14ec9a7d38dc798a9ce8028
startFunction2
public SWFActionBlock startFunction2(String var, int arg1, int arg2, String[] params, int[] arg3) throws IOException
{    stack.push(var);    strings.remove(var);    if (params != null) {        for (int i = 0; i < params.length; i++) {            strings.remove(params[i]);        }    }    return this;}
7d8845c455eb73e1a467c37669745e2828599eb3a958d2b6a580ae5323dd0b7d
waitForFrame
public void waitForFrame(int num, String var) throws IOException
{    stack.push(var);    strings.remove(var);    super.waitForFrame(num, var);}
60099c516e6ea8e8e4ff0e23880ec50e191ea99fd6dd1d4a179404ac713c14fc
waitForFrame
public void waitForFrame(String var) throws IOException
{    stack.push(var);    strings.remove(var);    super.waitForFrame(var);}
2b7e41f68b54a2b02aa82b345c69c8c57534f0ba7527e6adfafd42727ff8b2e6
done
public void done() throws IOException
{    while (stack.size() > 0) {        strings.remove(stack.pop());    }}
10f93818bbcc6d95c0f287d4db2110505c19916108427f8bd5bd5c09e0cf16a3
start
public SWFActionBlock start(int arg0, int arg1) throws IOException
{    return this;}
f848701ea7684e5429eaae2e360aa7d339b2b3f2c80ff34a6546d6657adbb9c6
start
public SWFActionBlock start(int arg0) throws IOException
{    return this;}
ec1f7b1dd812bb4c3011954b37fc2740da7e263ddeb5a204ace3e89e5e8f8902
add
public void add() throws IOException
{    super.add();}
482814b7c478a9a3b692ddf70bf8567f5350f541b389333a9880fecfc11befee
asciiToChar
public void asciiToChar() throws IOException
{    super.asciiToChar();}
28f1a14120f67789c4af4cf58fffb39583726617ce36d183db44dd281289d347
asciiToCharMB
public void asciiToCharMB() throws IOException
{    super.asciiToCharMB();}
60009d977b4254c1b5a2be9a316c307d3abfbc7c5e694d98ad8b7328bd803287
push
public void push(int var) throws IOException
{    if (dict != null && var >= 0 && var < dict.length) {        stack.push(dict[var]);    }    super.push(var);}
de0cd8f85c0e9e54821942ab43a36433bc2adf057bb37a2e956f2cc60a135357
callFunction
public void callFunction() throws IOException
{    strings.remove(stack.pop());    super.callFunction();}
71b9bfd572fbe198dde3f8f38554747cf6eed894fc07e7f6ee200950e98c093f
callMethod
public void callMethod() throws IOException
{    strings.remove(stack.pop());    super.callMethod();}
6e7f63621089147495ff0785d2966ca25b351955398134212beb7bae29af1b7f
getMember
public void getMember() throws IOException
{        String val = (String) stack.pop();    strings.remove(val);    super.getMember();}
0eaa16a5838520fe38901c2bf66f9969ea8c6c9c90fc1db22fd282194f1db023
setMember
public void setMember() throws IOException
{            stack.pop();    String name = (String) stack.pop();    strings.remove(name);    super.setMember();}
d0a13af1f7dddc7f9fef6768780b4c96fc73cd6d668735d328fbb64eaead5c53
setProperty
public void setProperty() throws IOException
{    super.setProperty();}
a9cdd43d2c1fa443bfa20a4310fdda5b8048f2771c79019ff180c68fe39a2d7b
setVariable
public void setVariable() throws IOException
{    super.setVariable();}
06f6ba71d3309c506935d22b5591fece772dc78366c8a2f4cf8efac686595676
call
public void call() throws IOException
{    strings.remove(stack.pop());    super.call();}
51a26d88ce5c1ee58467c66d5bc7d371dd7edf84574cb103c1244d6844f870e0
setTarget
public void setTarget() throws IOException
{    strings.remove(stack.pop());    super.setTarget();}
10d5251f81ca68b0b0c03d1b80aae09faa7b69937e102fed0be48249b4c23232
pop
public void pop() throws IOException
{    strings.remove(stack.pop());    super.pop();}
fe6cb96f07a306229824ed271b6be05eb2795a6ae598ee1c361664ad1db3b89a
push
public void push(boolean arg0) throws IOException
{    stack.push("" + arg0);    super.push(arg0);}
cd3e1c2918384db4b0c413a25fe0e977ca57c04a131cfe9280570e73fe234d88
push
public void push(double arg0) throws IOException
{    stack.push("" + arg0);    super.push(arg0);}
3ca56995c1bc648e2ad7c3c0fd8f34c246ef715b1c3a82a0fd487e32d3f12409
push
public void push(float arg0) throws IOException
{    stack.push("" + arg0);    super.push(arg0);}
b7df7c5472314f44d28b1db526e1570448895fe92167de54b7b7c71afd79365b
pushNull
public void pushNull() throws IOException
{    stack.push("");    super.pushNull();}
ecb2f110b5d30387bf1321e5436f2e601ac34fcf1d3dc45b4399c4acf324d6f4
pushRegister
public void pushRegister(int arg0) throws IOException
{    stack.push("" + arg0);    super.pushRegister(arg0);}
e29f3ca0439c157e1efdb72195b26f8f551b2eb606ddbee47659daf16b41e261
pushUndefined
public void pushUndefined() throws IOException
{    stack.push("???");    super.pushUndefined();}
1b80fa969bdf887201faaa88a1c0907c5462fa2e132ce387ca9d50829a5ad5bd
getProperty
public void getProperty() throws IOException
{    stack.pop();    super.getProperty();}
ef2f77c12ef38d8c087e4365b7bee1d02f502c6d4926960539f575688183b5c5
getVariable
public void getVariable() throws IOException
{    strings.remove(stack.pop());    super.getVariable();}
20fdff696aeed5e6ad04ccca2451e5521dd5f1dd45de497345cbc48808ed28f3
gotoFrame
public void gotoFrame(boolean arg0) throws IOException
{    stack.push("" + arg0);    super.gotoFrame(arg0);}
8315d121d82f308a7c79c2fc9d9d898b257689b74c28137f4e8e009a36266eec
gotoFrame
public void gotoFrame(int arg0) throws IOException
{    stack.push("" + arg0);    super.gotoFrame(arg0);}
f5e84f6111b80e5bd95ba891c87fe16c0bbf01b8f57f2c064aef3e9dcde9dc90
gotoFrame
public void gotoFrame(String arg0) throws IOException
{    stack.push("" + arg0);    strings.remove(arg0);    super.gotoFrame(arg0);}
ae6885b8c92f6db29297b7671ad1609238b906a0ee94569ba6b353bf2d1bc53e
newObject
public void newObject() throws IOException
{    stack.pop();    super.newObject();}
22e64ff3adbfc73ca6132073038430718fd95bf6a41f6f335595b4169af9495f
startWith
public SWFActionBlock startWith() throws IOException
{    return this;}
d4ce19d35aed003082bd08adc69ad3f565115cfb99f7e782c64a2fb7487d7c82
push
public Object push(Object o)
{        if (this.size() > maxSize) {        String val = (String) remove(0);        strings.remove(val);    }    return super.push(o);}
697a058d22906cfae0e7a8bf355d1b598123726042010b47291cf614d2552605
pop
public Object pop()
{        if (this.size() == 0)        return null;    else        return super.pop();}
23535ebc1d4da03f1f5ef5ba3e83f8e2dbf0ef2db09f1e55cc401e7cd85e6561
testIt
public void testIt() throws ProtocolException, ParseException
{    String urlString;    Protocol protocol;    Content content;    Parse parse;    Configuration conf = NutchConfiguration.create();    for (int i = 0; i < sampleFiles.length; i++) {        urlString = "file:" + sampleDir + fileSeparator + sampleFiles[i];        protocol = new ProtocolFactory(conf).getProtocol(urlString);        content = protocol.getProtocolOutput(new Text(urlString), new CrawlDatum()).getContent();        parse = new ParseUtil(conf).parse(content).get(content.getUrl());        String text = parse.getText().replaceAll("[ \t\r\n]+", " ").trim();        Assert.assertTrue(sampleTexts[i].equals(text));    }}
bd09d6471036923bef2581d5335a5fef27c78a0fc3bb3f2a00fa02ce505b945c
getExtractor
public static synchronized BoilerpipeExtractor getExtractor(String boilerpipeExtractorName)
{        if (!extractorRepository.containsKey(boilerpipeExtractorName)) {                boilerpipeExtractorName = "de.l3s.boilerpipe.extractors." + boilerpipeExtractorName;                try {            ClassLoader loader = BoilerpipeExtractor.class.getClassLoader();            Class extractorClass = loader.loadClass(boilerpipeExtractorName);                        extractorRepository.put(boilerpipeExtractorName, (BoilerpipeExtractor) extractorClass.getConstructor().newInstance());        } catch (ClassNotFoundException e) {            LOG.error("BoilerpipeExtractor " + boilerpipeExtractorName + " not found!");        } catch (InstantiationException e) {            LOG.error("Could not instantiate " + boilerpipeExtractorName);        } catch (Exception e) {            LOG.error(e);        }    }    return extractorRepository.get(boilerpipeExtractorName);}
52089512420cae48c5a879c3e1a1837803fcf94998aa438b554db5f228ab2d2b
getRootNode
 Node getRootNode()
{    return (null != m_docFrag) ? (Node) m_docFrag : (Node) m_doc;}
6b1afa0dcfde2d2f501bc4dbf69adadc8cf222169adba1130e69921a8082df48
getCurrentNode
 Node getCurrentNode()
{    return m_currentNode;}
786fc9ed41628b043fda361db2ada057363d150a53a207c4d8e530dc32c0d36d
getWriter
 java.io.Writer getWriter()
{    return null;}
f75a4336d1f10b71ffeca0725d5b35cf5ae5a7660e73b4556b49575378ab197d
append
protected void append(Node newNode) throws org.xml.sax.SAXException
{    Node currentNode = m_currentNode;    if (null != currentNode) {        currentNode.appendChild(newNode);        } else if (null != m_docFrag) {        m_docFrag.appendChild(newNode);    } else {        boolean ok = true;        short type = newNode.getNodeType();        if (type == Node.TEXT_NODE) {            String data = newNode.getNodeValue();            if ((null != data) && (data.trim().length() > 0)) {                throw new org.xml.sax.SAXException("Warning: can't output text before document element!  Ignoring...");            }            ok = false;        } else if (type == Node.ELEMENT_NODE) {            if (m_doc.getDocumentElement() != null) {                throw new org.xml.sax.SAXException("Can't have more than one root on a DOM!");            }        }        if (ok)            m_doc.appendChild(newNode);    }}
b2f272e09c1cb5e2753e1336905f73e1c5d739510484927f3d8899c5a6c3e63f
setDocumentLocator
public void setDocumentLocator(Locator locator)
{}
d715c5bb3f7aef8c165f489b6a9ca99285c1ae49770e68917f0ff4facb17d4c3
startDocument
public void startDocument() throws org.xml.sax.SAXException
{}
1a3098bd1fa9516c83b2c1c558e73929c0a860cb2305aa0f59472ba76bbe34ca
endDocument
public void endDocument() throws org.xml.sax.SAXException
{}
01c36c9aa4800334f1a56cf4a327ada41b268f083d3e1367f9caab5c3e767e5d
startElement
public void startElement(String ns, String localName, String name, Attributes atts) throws org.xml.sax.SAXException
{    Element elem;    if (upperCaseElementNames)        name = name.toUpperCase();        if ((null == ns) || (ns.length() == 0) || ns.equals(defaultNamespaceURI))        elem = m_doc.createElementNS(null, name);    else        elem = m_doc.createElementNS(ns, name);    append(elem);    try {        int nAtts = atts.getLength();        if (0 != nAtts) {            for (int i = 0; i < nAtts; i++) {                                if (atts.getType(i).equalsIgnoreCase("ID"))                    setIDAttribute(atts.getValue(i), elem);                String attrNS = atts.getURI(i);                if ("".equals(attrNS))                                        attrNS = null;                                                                String attrQName = atts.getQName(i);                                if (attrQName.startsWith("xmlns:"))                    attrNS = "http://www.w3.org/2000/xmlns/";                                elem.setAttributeNS(attrNS, attrQName, atts.getValue(i));            }        }                m_elemStack.push(elem);        m_currentNode = elem;        } catch (java.lang.Exception de) {                throw new org.xml.sax.SAXException(de);    }}
5830b626746f78da6836b288e5d33c4b4211989ead97e86f0e21e6d4208ce053
endElement
public void endElement(String ns, String localName, String name) throws org.xml.sax.SAXException
{    if (!m_elemStack.isEmpty()) {        m_elemStack.pop();    }    m_currentNode = m_elemStack.isEmpty() ? null : (Node) m_elemStack.peek();}
30b57deb275508e5b475fb5672520d80b9616977c0a1d6f925d8a4f89d119fdd
setIDAttribute
public void setIDAttribute(String id, Element elem)
{}
3f0cf929d8c00e3e6c466564001c48c498db84e4fd83bbf9a63bda4b3d6d3409
characters
public void characters(char[] ch, int start, int length) throws org.xml.sax.SAXException
{    if (isOutsideDocElem() && XMLCharacterRecognizer.isWhiteSpace(ch, start, length))                return;    if (m_inCData) {        cdata(ch, start, length);        return;    }    String s = new String(ch, start, length);    Node childNode;    childNode = m_currentNode != null ? m_currentNode.getLastChild() : null;    if (childNode != null && childNode.getNodeType() == Node.TEXT_NODE) {        ((Text) childNode).appendData(s);    } else {        Text text = m_doc.createTextNode(s);        append(text);    }}
ad59be00c4249d62e43524910a52a28809055e6a1819ffcd3ff3412836872021
charactersRaw
public void charactersRaw(char[] ch, int start, int length) throws org.xml.sax.SAXException
{    if (isOutsideDocElem() && XMLCharacterRecognizer.isWhiteSpace(ch, start, length))                return;    String s = new String(ch, start, length);    append(m_doc.createProcessingInstruction("xslt-next-is-raw", "formatter-to-dom"));    append(m_doc.createTextNode(s));}
2cae08649aabee7dde275c91f52d6a20aeccc85f5aceb12ffcd4498194106601
startEntity
public void startEntity(String name) throws org.xml.sax.SAXException
{}
dc4a85a9fc2f03a78fea0feaf7ae779b60183832c958cfbc1e48b33ae51fec9d
endEntity
public void endEntity(String name) throws org.xml.sax.SAXException
{}
df93be66203db8d2bebdfb4f122696d4c0e407c9d19885fb8b63f1557854bdf4
entityReference
public void entityReference(String name) throws org.xml.sax.SAXException
{    append(m_doc.createEntityReference(name));}
b758e825d1b35f0652451692fdf06105a0e852004bacfbe0a5f0d58740c338f4
ignorableWhitespace
public void ignorableWhitespace(char[] ch, int start, int length) throws org.xml.sax.SAXException
{    if (isOutsideDocElem())                return;    String s = new String(ch, start, length);    append(m_doc.createTextNode(s));}
84c553d5ddd3738c942cd3f8c9bc7907c35ed17fdd5f21672781d99ca716be32
isOutsideDocElem
private boolean isOutsideDocElem()
{    return (null == m_docFrag) && m_elemStack.size() == 0 && (null == m_currentNode || m_currentNode.getNodeType() == Node.DOCUMENT_NODE);}
880954d30ada7db21e140b7909c66964d6c8558030bb47d9d777172535aa26e9
processingInstruction
public void processingInstruction(String target, String data) throws org.xml.sax.SAXException
{    append(m_doc.createProcessingInstruction(target, data));}
8681ca2eabafb7d3162ce44e45391c02c2ef361ee57225ae447e2288a3905b1e
comment
public void comment(char[] ch, int start, int length) throws org.xml.sax.SAXException
{        if (ch == null || start < 0 || length >= (ch.length - start) || length < 0)        return;    append(m_doc.createComment(new String(ch, start, length)));}
6d8cdf13d098ccb3e4e2595c9ae3fbb204783212e0711b727a54be759c780253
startCDATA
public void startCDATA() throws org.xml.sax.SAXException
{    m_inCData = true;    append(m_doc.createCDATASection(""));}
a1619921b85f4308471f958f3831637315c68de1de59913697a567c836d45da5
endCDATA
public void endCDATA() throws org.xml.sax.SAXException
{    m_inCData = false;}
2a4eefacb0baab183a41e7f866051bbc64a3cc26e98d4164a840aefd0b7186a6
cdata
public void cdata(char[] ch, int start, int length) throws org.xml.sax.SAXException
{    if (isOutsideDocElem() && XMLCharacterRecognizer.isWhiteSpace(ch, start, length))                return;    String s = new String(ch, start, length);        Node n = m_currentNode.getLastChild();    if (n instanceof CDATASection)        ((CDATASection) n).appendData(s);    else if (n instanceof Comment)        ((Comment) n).appendData(s);}
901e293ed61766b19e850453e0bad6112d1df9bfb60d177da259173f15767d7f
startDTD
public void startDTD(String name, String publicId, String systemId) throws org.xml.sax.SAXException
{}
ee9dc9d04a7aba5005443daa6011f144e76e8920bb61cdbe385e9a49e4888ae3
endDTD
public void endDTD() throws org.xml.sax.SAXException
{}
6d89eda534570b43340ef3a34da9b1dafb3cbc2a1474f5d167f83bbc8b72f4a5
startPrefixMapping
public void startPrefixMapping(String prefix, String uri) throws org.xml.sax.SAXException
{/*     *      * if((null != m_currentNode) && (m_currentNode.getNodeType() ==     * Node.ELEMENT_NODE)) { String qname; if(((null != prefix) &&     * (prefix.length() == 0)) || (null == prefix)) qname = "xmlns"; else qname     * = "xmlns:"+prefix;     *      * Element elem = (Element)m_currentNode; String val =     * elem.getAttribute(qname);      * { elem.setAttributeNS("http://www.w3.org/XML/1998/namespace", qname,     * uri); } }     */}
515059befe06ad3c7c406e65a3ad795b61aca73d84ddc5a1d24c5389a54084a7
endPrefixMapping
public void endPrefixMapping(String prefix) throws org.xml.sax.SAXException
{}
a3a00f157591c5447f0fa4e676cc00c7ef6cd40f6252c856b5f6e227bcd97e57
skippedEntity
public void skippedEntity(String name) throws org.xml.sax.SAXException
{}
d5517699adc9097d98f7f47e707b4f8090532442630ef4fbe58661c8e12511bf
isUpperCaseElementNames
public boolean isUpperCaseElementNames()
{    return upperCaseElementNames;}
27b9206358f2cc00d35db563477df8afff6e7a264d3394ed259c3678153ccc51
setUpperCaseElementNames
public void setUpperCaseElementNames(boolean upperCaseElementNames)
{    this.upperCaseElementNames = upperCaseElementNames;}
8ec93384587fcf68fc23770f6d8f03a1440ae2e4911a9e91fc811f2f00e2613d
getDefaultNamespaceURI
public String getDefaultNamespaceURI()
{    return defaultNamespaceURI;}
9c6136cc95735bf6d24123afba5fe3fe9c2fc353aa999f579017aa79597a6b12
setDefaultNamespaceURI
public void setDefaultNamespaceURI(String defaultNamespaceURI)
{    this.defaultNamespaceURI = defaultNamespaceURI;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "LP[el=" + elName + ",attr=" + attrName + ",len=" + childLen + "]";}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{        Collection<String> forceTags = new ArrayList<String>(1);    this.conf = conf;    linkParams.clear();    linkParams.put("a", new LinkParams("a", "href", 1));    linkParams.put("area", new LinkParams("area", "href", 0));    if (conf.getBoolean("parser.html.form.use_action", true)) {        linkParams.put("form", new LinkParams("form", "action", 1));        if (conf.get("parser.html.form.use_action") != null)            forceTags.add("form");    }    linkParams.put("frame", new LinkParams("frame", "src", 0));    linkParams.put("iframe", new LinkParams("iframe", "src", 0));    linkParams.put("script", new LinkParams("script", "src", 0));    linkParams.put("link", new LinkParams("link", "href", 0));    linkParams.put("img", new LinkParams("img", "src", 0));    linkParams.put("source", new LinkParams("source", "src", 0));        String[] ignoreTags = conf.getStrings("parser.html.outlinks.ignore_tags");    for (int i = 0; ignoreTags != null && i < ignoreTags.length; i++) {        ignoredTags.add(ignoreTags[i].toLowerCase());        if (!forceTags.contains(ignoreTags[i]))            linkParams.remove(ignoreTags[i]);    }        srcTagMetaName = this.conf.get("parser.html.outlinks.htmlnode_metadata_name");    keepNodenames = (srcTagMetaName != null && srcTagMetaName.length() > 0);    blockNodes = new HashSet<>(conf.getTrimmedStringCollection("parser.html.line.separators"));}
f957d409b39550435097bfe5f4b3a8b4579282668282b1959423b1cd0f9f5865
getText
private boolean getText(StringBuffer sb, Node node, boolean abortOnNestedAnchors)
{    if (getTextHelper(sb, node, abortOnNestedAnchors, 0)) {        return true;    }    return false;}
fa5c2fd99144833795a789f0a86ca0aa1dac28ff556181facdf39b76439a0d67
getText
public void getText(StringBuffer sb, Node node)
{    getText(sb, node, false);}
c534cb80681ec5dfd7e15e9e4d995bf4f832b5d81ade734d23557260982ff92b
getTextHelper
private boolean getTextHelper(StringBuffer sb, Node node, boolean abortOnNestedAnchors, int anchorDepth)
{    boolean abort = false;    NodeWalker walker = new NodeWalker(node);    while (walker.hasNext()) {        Node currentNode = walker.nextNode();        String nodeName = currentNode.getNodeName();        short nodeType = currentNode.getNodeType();        Node previousSibling = currentNode.getPreviousSibling();        if (previousSibling != null && blockNodes.contains(previousSibling.getNodeName().toLowerCase())) {            appendParagraphSeparator(sb);        } else if (blockNodes.contains(nodeName.toLowerCase())) {            appendParagraphSeparator(sb);        }        if ("script".equalsIgnoreCase(nodeName)) {            walker.skipChildren();        }        if ("style".equalsIgnoreCase(nodeName)) {            walker.skipChildren();        }        if (abortOnNestedAnchors && "a".equalsIgnoreCase(nodeName)) {            anchorDepth++;            if (anchorDepth > 1) {                abort = true;                break;            }        }        if (nodeType == Node.COMMENT_NODE) {            walker.skipChildren();        }        if (nodeType == Node.TEXT_NODE) {                        String text = currentNode.getNodeValue();            text = text.replaceAll("\\s+", " ");            text = text.trim();            if (text.length() > 0) {                appendSpace(sb);                sb.append(text);            } else {                appendParagraphSeparator(sb);            }        }    }    return abort;}
b014d2637ad782bf6eb0fa6afedd7ca624f5a75981ae04d8338d88e5d37ba280
appendParagraphSeparator
private void appendParagraphSeparator(StringBuffer buffer)
{    if (buffer.length() == 0) {        return;    }    char lastChar = buffer.charAt(buffer.length() - 1);    if ('\n' != lastChar) {                while (lastChar == ' ') {            buffer.deleteCharAt(buffer.length() - 1);            lastChar = buffer.charAt(buffer.length() - 1);        }        if ('\n' != lastChar) {            buffer.append('\n');        }    }}
7ababbb6c381d37488ee71a114da7887fbe8a08f8223200c289bb4ea2bd640c4
appendSpace
private void appendSpace(StringBuffer buffer)
{    if (buffer.length() == 0) {        return;    }    char lastChar = buffer.charAt(buffer.length() - 1);    if (' ' != lastChar && '\n' != lastChar) {        buffer.append(' ');    }}
1705c1e4d1924b65c9b6fec717f754f4c94daa22932da745ce60e65e3d9c9b21
getTitle
public boolean getTitle(StringBuffer sb, Node node)
{    NodeWalker walker = new NodeWalker(node);    while (walker.hasNext()) {        Node currentNode = walker.nextNode();        String nodeName = currentNode.getNodeName();        short nodeType = currentNode.getNodeType();        if ("body".equalsIgnoreCase(nodeName)) {                        return false;        }        if (nodeType == Node.ELEMENT_NODE) {            if ("title".equalsIgnoreCase(nodeName)) {                getText(sb, currentNode);                return true;            }        }    }    return false;}
60c3b32eef11a5d274fda6242e3ef47e2c05007aeafdc638635c67a720729058
getBase
public String getBase(Node node)
{    NodeWalker walker = new NodeWalker(node);    while (walker.hasNext()) {        Node currentNode = walker.nextNode();        String nodeName = currentNode.getNodeName();        short nodeType = currentNode.getNodeType();                if (nodeType == Node.ELEMENT_NODE) {            if ("body".equalsIgnoreCase(nodeName)) {                                return null;            }            if ("base".equalsIgnoreCase(nodeName)) {                NamedNodeMap attrs = currentNode.getAttributes();                for (int i = 0; i < attrs.getLength(); i++) {                    Node attr = attrs.item(i);                    if ("href".equalsIgnoreCase(attr.getNodeName())) {                        return attr.getNodeValue();                    }                }            }        }    }        return null;}
0d718c3a945ee55c8038c90419a3b234bfb96eaffae8623add1e290cee4ee6e0
hasOnlyWhiteSpace
private boolean hasOnlyWhiteSpace(Node node)
{    String val = node.getNodeValue();    for (int i = 0; i < val.length(); i++) {        if (!Character.isWhitespace(val.charAt(i)))            return false;    }    return true;}
746c5d23ecbe0e1c93a246750f4b8d55373fcb0833277ea3248b88a2d1c1f148
shouldThrowAwayLink
private boolean shouldThrowAwayLink(Node node, NodeList children, int childLen, LinkParams params)
{    if (childLen == 0) {                if (params.childLen == 0)            return false;        else            return true;    } else if ((childLen == 1) && (children.item(0).getNodeType() == Node.ELEMENT_NODE) && (params.elName.equalsIgnoreCase(children.item(0).getNodeName()))) {                return true;    } else if (childLen == 2) {        Node c0 = children.item(0);        Node c1 = children.item(1);        if ((c0.getNodeType() == Node.ELEMENT_NODE) && (params.elName.equalsIgnoreCase(c0.getNodeName())) && (c1.getNodeType() == Node.TEXT_NODE) && hasOnlyWhiteSpace(c1)) {                        return true;        }        if ((c1.getNodeType() == Node.ELEMENT_NODE) && (params.elName.equalsIgnoreCase(c1.getNodeName())) && (c0.getNodeType() == Node.TEXT_NODE) && hasOnlyWhiteSpace(c0)) {                        return true;        }    } else if (childLen == 3) {        Node c0 = children.item(0);        Node c1 = children.item(1);        Node c2 = children.item(2);        if ((c1.getNodeType() == Node.ELEMENT_NODE) && (params.elName.equalsIgnoreCase(c1.getNodeName())) && (c0.getNodeType() == Node.TEXT_NODE) && (c2.getNodeType() == Node.TEXT_NODE) && hasOnlyWhiteSpace(c0) && hasOnlyWhiteSpace(c2)) {                        return true;        }    }    return false;}
9103b9ae5f158e7cad8775492cb5f4d6dbfb21469fe4969a00f91c9ff4e1a72c
getOutlinks
public void getOutlinks(URL base, ArrayList<Outlink> outlinks, Node node)
{    NodeWalker walker = new NodeWalker(node);    while (walker.hasNext()) {        Node currentNode = walker.nextNode();        String nodeName = currentNode.getNodeName();        short nodeType = currentNode.getNodeType();        NodeList children = currentNode.getChildNodes();        int childLen = (children != null) ? children.getLength() : 0;        if (nodeType == Node.ELEMENT_NODE) {            nodeName = nodeName.toLowerCase();            LinkParams params = (LinkParams) linkParams.get(nodeName);            if (params != null) {                if (!shouldThrowAwayLink(currentNode, children, childLen, params)) {                    StringBuffer linkText = new StringBuffer();                    getText(linkText, currentNode, true);                    NamedNodeMap attrs = currentNode.getAttributes();                    String target = null;                    boolean noFollow = false;                    boolean post = false;                    for (int i = 0; i < attrs.getLength(); i++) {                        Node attr = attrs.item(i);                        String attrName = attr.getNodeName();                        if (params.attrName.equalsIgnoreCase(attrName)) {                            target = attr.getNodeValue();                        } else if ("rel".equalsIgnoreCase(attrName) && "nofollow".equalsIgnoreCase(attr.getNodeValue())) {                            noFollow = true;                        } else if ("method".equalsIgnoreCase(attrName) && "post".equalsIgnoreCase(attr.getNodeValue())) {                            post = true;                        }                    }                    if (target != null && !noFollow && !post)                        try {                            URL url = URLUtil.resolveURL(base, target);                            Outlink outlink = new Outlink(url.toString(), linkText.toString().trim());                            outlinks.add(outlink);                                                        if (keepNodenames) {                                MapWritable metadata = new MapWritable();                                metadata.put(new Text(srcTagMetaName), new Text(nodeName));                                outlink.setMetadata(metadata);                            }                        } catch (MalformedURLException e) {                                                }                }                                if (params.childLen == 0)                    continue;            }        }    }}
78d5d2e6e4fd471d3937b16944bb1a24d2650d58dfcd7d610952144dd9f6b39b
getOutlinks
public void getOutlinks(URL base, ArrayList<Outlink> outlinks, List<Link> tikaExtractedOutlinks)
{    String target = null;    String anchor = null;    boolean noFollow = false;    for (Link link : tikaExtractedOutlinks) {        target = link.getUri();        noFollow = (link.getRel().toLowerCase().equals("nofollow")) ? true : false;        anchor = link.getText();        if (!ignoredTags.contains(link.getType())) {            if (target != null && !noFollow) {                try {                    URL url = URLUtil.resolveURL(base, target);                                        anchor = anchor.replaceAll("\\s+", " ");                    anchor = anchor.trim();                    outlinks.add(new Outlink(url.toString(), anchor));                } catch (MalformedURLException e) {                                }            }        }    }}
b14e53eb4b14c89fffbf896087639efa5b9c184996992348e942f00e2940b80c
getMetaTags
public static final void getMetaTags(HTMLMetaTags metaTags, Node node, URL currURL)
{    metaTags.reset();    getMetaTagsHelper(metaTags, node, currURL);}
9bcb2c1e4e9d4b425e6b4dfa653b3ec3e3894af09be7459fd48bcb4806ce4af9
getMetaTagsHelper
private static final void getMetaTagsHelper(HTMLMetaTags metaTags, Node node, URL currURL)
{    if (node.getNodeType() == Node.ELEMENT_NODE) {        if ("body".equalsIgnoreCase(node.getNodeName())) {                        return;        }        if ("meta".equalsIgnoreCase(node.getNodeName())) {            NamedNodeMap attrs = node.getAttributes();            Node nameNode = null;            Node equivNode = null;            Node contentNode = null;                        for (int i = 0; i < attrs.getLength(); i++) {                Node attr = attrs.item(i);                String attrName = attr.getNodeName().toLowerCase();                if (attrName.equals("name")) {                    nameNode = attr;                } else if (attrName.equals("http-equiv")) {                    equivNode = attr;                } else if (attrName.equals("content")) {                    contentNode = attr;                }            }            if (nameNode != null) {                if (contentNode != null) {                    String name = nameNode.getNodeValue().toLowerCase();                    metaTags.getGeneralTags().add(name, contentNode.getNodeValue());                    if ("robots".equals(name)) {                        String directives = contentNode.getNodeValue().toLowerCase();                        int index = directives.indexOf("none");                        if (index >= 0) {                            metaTags.setNoIndex();                            metaTags.setNoFollow();                        }                        index = directives.indexOf("all");                        if (index >= 0) {                                                }                        index = directives.indexOf("noindex");                        if (index >= 0) {                            metaTags.setNoIndex();                        }                        index = directives.indexOf("nofollow");                        if (index >= 0) {                            metaTags.setNoFollow();                        }                        index = directives.indexOf("noarchive");                        if (index >= 0) {                            metaTags.setNoCache();                        }                    } else                     if (name.equals("pragma")) {                        String content = contentNode.getNodeValue().toLowerCase();                        if (content.contains("no-cache")) {                            metaTags.setNoCache();                        }                    } else if (name.equals("refresh")) {                        String content = contentNode.getNodeValue().toLowerCase();                        setRefresh(metaTags, content, currURL);                    } else if (name.equals("content-location")) {                        String urlString = contentNode.getNodeValue();                        URL url = null;                        try {                            if (currURL == null) {                                url = new URL(urlString);                            } else {                                url = new URL(currURL, urlString);                            }                            metaTags.setBaseHref(url);                        } catch (MalformedURLException e) {                                                }                    }                }            }            if (equivNode != null) {                if (contentNode != null) {                    String name = equivNode.getNodeValue().toLowerCase();                    String content = contentNode.getNodeValue();                    metaTags.getHttpEquivTags().setProperty(name, content);                    if ("pragma".equals(name)) {                        content = content.toLowerCase();                        int index = content.indexOf("no-cache");                        if (index >= 0)                            metaTags.setNoCache();                    } else if ("refresh".equals(name)) {                        setRefresh(metaTags, content, currURL);                    }                }            }        } else if ("base".equalsIgnoreCase(node.getNodeName())) {            NamedNodeMap attrs = node.getAttributes();            Node hrefNode = attrs.getNamedItem("href");            if (hrefNode != null) {                String urlString = hrefNode.getNodeValue();                URL url = null;                try {                    if (currURL == null)                        url = new URL(urlString);                    else                        url = new URL(currURL, urlString);                } catch (Exception e) {                    ;                }                if (url != null)                    metaTags.setBaseHref(url);            }        }    }    NodeList children = node.getChildNodes();    if (children != null) {        int len = children.getLength();        for (int i = 0; i < len; i++) {            getMetaTagsHelper(metaTags, children.item(i), currURL);        }    }}
fe81d3851a571c68848fa7b84e0eddc6b806badcc38a4941aaf7251f787eead9
setRefresh
private static void setRefresh(HTMLMetaTags metaTags, String content, URL currURL)
{    int idx = content.indexOf(';');    String time = null;    if (idx == -1) {                time = content;    } else        time = content.substring(0, idx);    try {        metaTags.setRefreshTime(Integer.parseInt(time));                metaTags.setRefresh(true);    } catch (Exception e) {        ;    }    URL refreshUrl = null;    if (metaTags.getRefresh() && idx != -1) {                idx = content.toLowerCase().indexOf("url=");        if (idx == -1) {                                    idx = content.indexOf(';') + 1;        } else            idx += 4;        if (idx != -1) {            String url = content.substring(idx);            try {                refreshUrl = new URL(url);            } catch (Exception e) {                                try {                    refreshUrl = new URL(currURL, url);                } catch (Exception e1) {                    refreshUrl = null;                }            }        }    }    if (metaTags.getRefresh()) {        if (refreshUrl == null) {                                    refreshUrl = currURL;        }        metaTags.setRefreshHref(refreshUrl);    }}
74c073cf714c8a8285642be67ae2f28cd713bfd23722543918cc25b506734fed
getParse
public ParseResult getParse(Content content)
{    HTMLDocumentImpl doc = new HTMLDocumentImpl();    doc.setErrorChecking(false);    DocumentFragment root = doc.createDocumentFragment();    return getParse(content, doc, root);}
2b887a91fee0aff7830eddd14c6599b212053dbeba3fe0991b3650b241cf6bf1
getParse
 ParseResult getParse(Content content, HTMLDocumentImpl doc, DocumentFragment root)
{    String mimeType = content.getContentType();    URL base;    try {        base = new URL(content.getBaseUrl());    } catch (MalformedURLException e) {        return new ParseStatus(e).getEmptyParseResult(content.getUrl(), getConf());    }        CompositeParser compositeParser = (CompositeParser) tikaConfig.getParser();    Parser parser = compositeParser.getParsers().get(MediaType.parse(mimeType));    if (parser == null) {        String message = "Can't retrieve Tika parser for mime-type " + mimeType;        LOG.error(message);        return new ParseStatus(ParseStatus.FAILED, message).getEmptyParseResult(content.getUrl(), getConf());    }    LOG.debug("Using Tika parser {} for mime-type {}.", parser.getClass().getName(), mimeType);    byte[] raw = content.getContent();    Metadata tikamd = new Metadata();    ContentHandler domHandler;        if (useBoilerpipe && boilerpipeMimeTypes.contains(mimeType)) {        BoilerpipeContentHandler bpHandler = new BoilerpipeContentHandler((ContentHandler) new DOMBuilder(doc, root), BoilerpipeExtractorRepository.getExtractor(boilerpipeExtractorName));        bpHandler.setIncludeMarkup(true);        domHandler = (ContentHandler) bpHandler;    } else {        DOMBuilder domBuilder = new DOMBuilder(doc, root);        domBuilder.setUpperCaseElementNames(upperCaseElementNames);        domBuilder.setDefaultNamespaceURI(XHTMLContentHandler.XHTML);        domHandler = (ContentHandler) domBuilder;    }    LinkContentHandler linkContentHandler = new LinkContentHandler();    ParseContext context = new ParseContext();    if (parseEmbedded) {        context.set(Parser.class, new AutoDetectParser(tikaConfig));    }    TeeContentHandler teeContentHandler = new TeeContentHandler(domHandler, linkContentHandler);    if (HTMLMapper != null)        context.set(HtmlMapper.class, HTMLMapper);    tikamd.set(Metadata.CONTENT_TYPE, mimeType);    try {        parser.parse(new ByteArrayInputStream(raw), (ContentHandler) teeContentHandler, tikamd, context);    } catch (Exception e) {        LOG.error("Error parsing " + content.getUrl(), e);        return new ParseStatus(ParseStatus.FAILED, e.getMessage()).getEmptyParseResult(content.getUrl(), getConf());    }    HTMLMetaTags metaTags = new HTMLMetaTags();    String text = "";    String title = "";    Outlink[] outlinks = new Outlink[0];    org.apache.nutch.metadata.Metadata nutchMetadata = new org.apache.nutch.metadata.Metadata();                HTMLMetaProcessor.getMetaTags(metaTags, root, base);    if (LOG.isTraceEnabled()) {        LOG.trace("Meta tags for " + base + ": " + metaTags.toString());    }        if (!metaTags.getNoIndex()) {                StringBuffer sb = new StringBuffer();        if (LOG.isTraceEnabled()) {            LOG.trace("Getting text...");        }                utils.getText(sb, root);        text = sb.toString();        sb.setLength(0);        if (LOG.isTraceEnabled()) {            LOG.trace("Getting title...");        }                utils.getTitle(sb, root);        title = sb.toString().trim();    }    if (!metaTags.getNoFollow()) {                        ArrayList<Outlink> l = new ArrayList<Outlink>();        URL baseTag = base;        String baseTagHref = tikamd.get("Content-Location");        if (baseTagHref != null) {            try {                baseTag = new URL(base, baseTagHref);            } catch (MalformedURLException e) {                LOG.trace("Invalid <base href=\"{}\">", baseTagHref);            }        }        if (LOG.isTraceEnabled()) {            LOG.trace("Getting links (base URL = {}) ...", baseTag);        }                                List<Link> tikaExtractedOutlinks = linkContentHandler.getLinks();        utils.getOutlinks(baseTag, l, tikaExtractedOutlinks);        outlinks = l.toArray(new Outlink[l.size()]);        if (LOG.isTraceEnabled()) {            LOG.trace("found " + outlinks.length + " outlinks in " + content.getUrl());        }    }        String[] TikaMDNames = tikamd.names();    for (String tikaMDName : TikaMDNames) {        if (tikaMDName.equalsIgnoreCase(Metadata.TITLE))            continue;        String[] values = tikamd.getValues(tikaMDName);        for (String v : values) nutchMetadata.add(tikaMDName, v);    }    if (outlinks.length == 0) {        outlinks = OutlinkExtractor.getOutlinks(text, getConf());    }    ParseStatus status = new ParseStatus(ParseStatus.SUCCESS);    if (metaTags.getRefresh()) {        status.setMinorCode(ParseStatus.SUCCESS_REDIRECT);        status.setArgs(new String[] { metaTags.getRefreshHref().toString(), Integer.toString(metaTags.getRefreshTime()) });    }    ParseData parseData = new ParseData(status, title, outlinks, content.getMetadata(), nutchMetadata);    ParseResult parseResult = ParseResult.createParseResult(content.getUrl(), new ParseImpl(text, parseData));        ParseResult filteredParse = this.htmlParseFilters.filter(content, parseResult, metaTags, root);    if (metaTags.getNoCache()) {                for (Map.Entry<org.apache.hadoop.io.Text, Parse> entry : filteredParse) entry.getValue().getData().getParseMeta().set(Nutch.CACHING_FORBIDDEN_KEY, cachingPolicy);    }    return filteredParse;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    this.tikaConfig = null;                String customConfFile = conf.get("tika.config.file");    if (customConfFile != null) {        try {                        URL customTikaConfig = conf.getResource(customConfFile);            if (customTikaConfig != null) {                tikaConfig = new TikaConfig(customTikaConfig, this.getClass().getClassLoader());            }        } catch (Exception e1) {            String message = "Problem loading custom Tika configuration from " + customConfFile;            LOG.error(message, e1);        }    }    if (tikaConfig == null) {        try {            tikaConfig = new TikaConfig(this.getClass().getClassLoader());        } catch (Exception e2) {            String message = "Problem loading default Tika configuration";            LOG.error(message, e2);        }    }        String htmlmapperClassName = conf.get("tika.htmlmapper.classname");    if (StringUtils.isNotBlank(htmlmapperClassName)) {        try {            Class<?> HTMLMapperClass = Class.forName(htmlmapperClassName);            boolean interfaceOK = HtmlMapper.class.isAssignableFrom(HTMLMapperClass);            if (!interfaceOK) {                throw new RuntimeException("Class " + htmlmapperClassName + " does not implement HtmlMapper");            }            HTMLMapper = (HtmlMapper) HTMLMapperClass.getConstructor().newInstance();        } catch (Exception e) {            String message = "Can't generate instance for class " + htmlmapperClassName;            LOG.error(message);            throw new RuntimeException(message);        }    }    htmlParseFilters = new HtmlParseFilters(conf);    utils = new DOMContentUtils(conf);    cachingPolicy = conf.get("parser.caching.forbidden.policy", Nutch.CACHING_FORBIDDEN_CONTENT);    upperCaseElementNames = conf.getBoolean("tika.uppercase.element.names", true);    useBoilerpipe = conf.get("tika.extractor", "none").equals("boilerpipe");    boilerpipeExtractorName = conf.get("tika.extractor.boilerpipe.algorithm", "ArticleExtractor");    boilerpipeMimeTypes = new HashSet<>(Arrays.asList(conf.getTrimmedStrings("tika.extractor.boilerpipe.mime.types", "text/html", "application/xhtml+xml")));    parseEmbedded = conf.getBoolean("tika.parse.embedded", true);}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
1740f56519e7414904906697685edfe652f4337571f10db7bde94e8fa6d6d6cb
isWhiteSpace
 static boolean isWhiteSpace(char ch)
{    return (ch == 0x20) || (ch == 0x09) || (ch == 0xD) || (ch == 0xA);}
01d28e52251dd78e3739d40d9e59da4fb942a6f019caf288890ca55b091133aa
isWhiteSpace
 static boolean isWhiteSpace(char[] ch, int start, int length)
{    int end = start + length;    for (int s = start; s < end; s++) {        if (!isWhiteSpace(ch[s]))            return false;    }    return true;}
d00ae145248aa9d771a82bdeffdb28721f4f4e1622cf8234a7da5ae8f9ee9676
isWhiteSpace
 static boolean isWhiteSpace(StringBuffer buf)
{    int n = buf.length();    for (int i = 0; i < n; i++) {        if (!isWhiteSpace(buf.charAt(i)))            return false;    }    return true;}
4e7877b44b767828e9ab91f082eb7cd94afd4f4aa3f54a413c850c9854f24975
isWhiteSpace
 static boolean isWhiteSpace(String s)
{    if (null != s) {        int n = s.length();        for (int i = 0; i < n; i++) {            if (!isWhiteSpace(s.charAt(i)))                return false;        }    }    return true;}
27681e68ec2a1eb903f955680ebe003ceb3707295c8aad884b692d378c6e37cf
setup
public void setup() throws Exception
{    conf = NutchConfiguration.create();    utils = new DOMContentUtils(conf);    conf.set("plugin.includes", "parse-tika");    TikaParser parser = new TikaParser();    parser.setConf(conf);    for (int i = 0; i < testPages.length; i++) {        try {            String url = testBaseHrefs[i];            testBaseHrefURLs[i] = new URL(url);            Content content = new Content(url, url, testPages[i].getBytes(StandardCharsets.UTF_8), "text/html", new Metadata(), conf);            HTMLDocumentImpl doc = new HTMLDocumentImpl();            doc.setErrorChecking(false);            DocumentFragment root = doc.createDocumentFragment();            parser.getParse(content, doc, root);            testDOMs[i] = root;        } catch (Exception e) {            Assert.assertTrue("caught exception: " + e, false);        }    }    answerOutlinks = new Outlink[][] { { new Outlink("http://www.nutch.org", "anchor") }, { new Outlink("http://www.nutch.org/", "home"), new Outlink("http://www.nutch.org/docs/bot.html", "bots") }, { new Outlink("http://www.nutch.org/", "separate this"), new Outlink("http://www.nutch.org/docs/ok", "from this") }, { new Outlink("http://www.nutch.org/", "home"), new Outlink("http://www.nutch.org/docs/1", "1"), new Outlink("http://www.nutch.org/docs/2", "2") }, { new Outlink("http://www.nutch.org/frames/top.html", ""), new Outlink("http://www.nutch.org/frames/left.html", ""), new Outlink("http://www.nutch.org/frames/invalid.html", ""), new Outlink("http://www.nutch.org/frames/right.html", "") }, { new Outlink("http://www.nutch.org/maps/logo.gif", ""), new Outlink("http://www.nutch.org/index.html", ""), new Outlink("http://www.nutch.org/maps/#bottom", ""), new Outlink("http://www.nutch.org/bot.html", ""), new Outlink("http://www.nutch.org/docs/index.html", "") }, { new Outlink("http://www.nutch.org/index.html", "whitespace test") }, {}, {}, {}, { new Outlink("http://www.nutch.org/;x", "anchor1"), new Outlink("http://www.nutch.org/g;x", "anchor2"), new Outlink("http://www.nutch.org/g;x?y#s", "anchor3") }, {     new Outlink("http://www.nutch.org/g", "anchor1"), new Outlink("http://www.nutch.org/g?y#s", "anchor2"), new Outlink("http://www.nutch.org/;something?y=1", "anchor3"), new Outlink("http://www.nutch.org/;something?y=1#s", "anchor4"), new Outlink("http://www.nutch.org/;something?y=1;somethingelse", "anchor5") }, {} };}
ac425a9e5f3767c9c53f24ac867336433e49b74281fa213cfc12c1b8f381d073
equalsIgnoreWhitespace
private static boolean equalsIgnoreWhitespace(String s1, String s2)
{    StringTokenizer st1 = new StringTokenizer(s1);    StringTokenizer st2 = new StringTokenizer(s2);    while (st1.hasMoreTokens()) {        if (!st2.hasMoreTokens())            return false;        if (!st1.nextToken().equals(st2.nextToken()))            return false;    }    if (st2.hasMoreTokens())        return false;    return true;}
27ffbb2e3abecc39db9a178f258662595b6b71eee52d79537c24ff44c3c45daf
testGetText
public void testGetText() throws Exception
{    if (testDOMs[0] == null)        setup();    for (int i = 0; i < testPages.length; i++) {        StringBuffer sb = new StringBuffer();        utils.getText(sb, testDOMs[i]);        String text = sb.toString();        Assert.assertTrue("expecting text: " + answerText[i] + System.getProperty("line.separator") + System.getProperty("line.separator") + "got text: " + text, equalsIgnoreWhitespace(answerText[i], text));    }}
a70f3af8199993e80e25e110d4ea269e2ef65f0f77df28e85eee4d1cc13baf95
testGetTitle
public void testGetTitle() throws Exception
{    if (testDOMs[0] == null)        setup();    for (int i = 0; i < testPages.length; i++) {        StringBuffer sb = new StringBuffer();        utils.getTitle(sb, testDOMs[i]);        String text = sb.toString();        Assert.assertTrue("expecting text: " + answerText[i] + System.getProperty("line.separator") + System.getProperty("line.separator") + "got text: " + text, equalsIgnoreWhitespace(answerTitle[i], text));    }}
b8740e12c8e8ebd77bab8fa29d30684ab50f6dcd9e1fb08f718bd76dfb7820e6
testGetOutlinks
public void testGetOutlinks() throws Exception
{    if (testDOMs[0] == null)        setup();    for (int i = 0; i < testPages.length; i++) {        ArrayList<Outlink> outlinks = new ArrayList<Outlink>();        if (i == SKIP) {            conf.setBoolean("parser.html.form.use_action", false);            utils.setConf(conf);        } else {            conf.setBoolean("parser.html.form.use_action", true);            utils.setConf(conf);        }        utils.getOutlinks(testBaseHrefURLs[i], outlinks, testDOMs[i]);        Outlink[] outlinkArr = new Outlink[outlinks.size()];        outlinkArr = outlinks.toArray(outlinkArr);        compareOutlinks(answerOutlinks[i], outlinkArr);    }}
6559447b281797e3386f6c83b2d2beba3702f57636aeb945bc44463331dd8c55
appendOutlinks
private static final void appendOutlinks(StringBuffer sb, Outlink[] o)
{    for (int i = 0; i < o.length; i++) {        sb.append(o[i].toString());        sb.append(System.getProperty("line.separator"));    }}
b5760eb17e87ef9bb77639841852251ad2e10bc5bbb7126765d6852178059057
outlinksString
private static final String outlinksString(Outlink[] o)
{    StringBuffer sb = new StringBuffer();    appendOutlinks(sb, o);    return sb.toString();}
948777d56f9851037784c925838a439cc798900a6923bf003221abeb913c00a3
compareOutlinks
private static final void compareOutlinks(Outlink[] o1, Outlink[] o2)
{    if (o1.length != o2.length) {        Assert.assertTrue("got wrong number of outlinks (expecting " + o1.length + ", got " + o2.length + ")" + System.getProperty("line.separator") + "answer: " + System.getProperty("line.separator") + outlinksString(o1) + System.getProperty("line.separator") + "got: " + System.getProperty("line.separator") + outlinksString(o2) + System.getProperty("line.separator"), false);    }    for (int i = 0; i < o1.length; i++) {        if (!o1[i].equals(o2[i])) {            Assert.assertTrue("got wrong outlinks at position " + i + System.getProperty("line.separator") + "answer: " + System.getProperty("line.separator") + "'" + o1[i].getToUrl() + "', anchor: '" + o1[i].getAnchor() + "'" + System.getProperty("line.separator") + "got: " + System.getProperty("line.separator") + "'" + o2[i].getToUrl() + "', anchor: '" + o2[i].getAnchor() + "'", false);        }    }}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    conf = NutchConfiguration.create();    conf.set("file.content.limit", "-1");    conf.setBoolean("tika.parse.embedded", true);}
beba5c63ef86e6b04940b7e29153129b2c26daba4d41a4d432c795a924f8b296
getTextContent
public String getTextContent(String fileName) throws ProtocolException, ParseException
{    String urlString = "file:" + sampleDir + fileSeparator + fileName;    Protocol protocol = new ProtocolFactory(conf).getProtocol(urlString);    Content content = protocol.getProtocolOutput(new Text(urlString), new CrawlDatum()).getContent();    Parse parse = new ParseUtil(conf).parseByExtensionId("parse-tika", content).get(content.getUrl());    return parse.getText();}
23535ebc1d4da03f1f5ef5ba3e83f8e2dbf0ef2db09f1e55cc401e7cd85e6561
testIt
public void testIt() throws ProtocolException, ParseException
{    for (int i = 0; i < sampleFiles.length; i++) {        String found = getTextContent(sampleFiles[i]);        Assert.assertTrue("text found : '" + found + "'", found.contains(expectedText));    }}
23535ebc1d4da03f1f5ef5ba3e83f8e2dbf0ef2db09f1e55cc401e7cd85e6561
testIt
public void testIt() throws ProtocolException, ParseException
{    String urlString;    Protocol protocol;    Content content;    Parse parse;    Configuration conf = NutchConfiguration.create();    for (int i = 0; i < sampleFiles.length; i++) {        urlString = "file:" + sampleDir + fileSeparator + sampleFiles[i];        protocol = new ProtocolFactory(conf).getProtocol(urlString);        content = protocol.getProtocolOutput(new Text(urlString), new CrawlDatum()).getContent();        parse = new ParseUtil(conf).parseByExtensionId("parse-tika", content).get(content.getUrl());                                                        ParseData theParseData = parse.getData();        Outlink[] theOutlinks = theParseData.getOutlinks();        Assert.assertTrue("There aren't 2 outlinks read!", theOutlinks.length == 2);                boolean hasLink1 = false, hasLink2 = false;        for (int j = 0; j < theOutlinks.length; j++) {            if (theOutlinks[j].getToUrl().equals("http://www-scf.usc.edu/~mattmann/")) {                hasLink1 = true;            }            if (theOutlinks[j].getToUrl().equals("http://www.nutch.org/")) {                hasLink2 = true;            }        }        if (!hasLink1 || !hasLink2) {            Assert.fail("Outlinks read from sample rss file are not correct!");        }    }}
06d447c076c2d00cc2bf0eb565b5d49f76e0952d23504524992886533ebeb04e
parse
protected Parse parse(byte[] contentBytes)
{    String dummyUrl = "http://example.com/";    return parser.getParse(new Content(dummyUrl, dummyUrl, contentBytes, "text/html", new Metadata(), conf)).get(dummyUrl);}
683a48e3108b654e11fffe4c463780827a5c8a2bb051f9ccd5b967a979824a6b
testEncodingDetection
public void testEncodingDetection()
{    for (String[] testPage : encodingTestPages) {        String name = testPage[0];        Charset charset = Charset.forName(testPage[1]);        byte[] contentBytes = testPage[2].getBytes(charset);        Parse parse = parse(contentBytes);        String text = parse.getText();        String title = parse.getData().getTitle();        String keywords = parse.getData().getMeta("keywords");        LOG.info(name);        LOG.info("title:\t" + title);        LOG.info("keywords:\t" + keywords);        LOG.info("text:\t" + text);        Assert.assertEquals("Title not extracted properly (" + name + ")", encodingTestKeywords, title);        for (String keyword : encodingTestKeywords.split(",\\s*")) {            Assert.assertTrue(keyword + " not found in text (" + name + ")", text.contains(keyword));        }        Assert.assertNotNull("No keywords extracted", keywords);        Assert.assertEquals("Keywords not extracted properly (" + name + ")", encodingTestKeywords, keywords);    }}
dc56467aa55b796d0e70001f5746d7c32f47eedf17e9c1d5502f4e0b12f28b24
testResolveBaseUrl
public void testResolveBaseUrl()
{    byte[] contentBytes = resolveBaseUrlTestContent.getBytes(StandardCharsets.UTF_8);        Parse parse = parse(contentBytes);    LOG.info(parse.getData().toString());    Outlink[] outlinks = parse.getData().getOutlinks();    Assert.assertEquals(1, outlinks.length);    Assert.assertEquals("http://www.example.com/index.html", outlinks[0].getToUrl());}
23535ebc1d4da03f1f5ef5ba3e83f8e2dbf0ef2db09f1e55cc401e7cd85e6561
testIt
public void testIt() throws ProtocolException, ParseException
{    String urlString;    Protocol protocol;    Content content;    Parse parse;    for (int i = 0; i < sampleFiles.length; i++) {        urlString = "file:" + sampleDir + fileSeparator + sampleFiles[i];        Configuration conf = NutchConfiguration.create();        protocol = new ProtocolFactory(conf).getProtocol(urlString);        content = protocol.getProtocolOutput(new Text(urlString), new CrawlDatum()).getContent();        parse = new ParseUtil(conf).parseByExtensionId("parse-tika", content).get(content.getUrl());        Assert.assertEquals("121", parse.getData().getMeta("width"));        Assert.assertEquals("48", parse.getData().getMeta("height"));    }}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    conf = NutchConfiguration.create();    conf.set("file.content.limit", "-1");}
beba5c63ef86e6b04940b7e29153129b2c26daba4d41a4d432c795a924f8b296
getTextContent
public String getTextContent(String fileName) throws ProtocolException, ParseException
{    String urlString = "file:" + sampleDir + fileSeparator + fileName;    Protocol protocol = new ProtocolFactory(conf).getProtocol(urlString);    Content content = protocol.getProtocolOutput(new Text(urlString), new CrawlDatum()).getContent();    Parse parse = new ParseUtil(conf).parseByExtensionId("parse-tika", content).get(content.getUrl());    return parse.getText();}
23535ebc1d4da03f1f5ef5ba3e83f8e2dbf0ef2db09f1e55cc401e7cd85e6561
testIt
public void testIt() throws ProtocolException, ParseException
{    for (int i = 0; i < sampleFiles.length; i++) {        String found = getTextContent(sampleFiles[i]);        Assert.assertTrue("text found : '" + found + "'", found.startsWith(expectedText));    }}
089104781545e9c5634f9af6e0102a21eb019146fa24bf89465266df18f2cdad
testOpeningDocs
public void testOpeningDocs() throws ProtocolException, ParseException
{    String[] filenames = new File(sampleDir).list();    for (int i = 0; i < filenames.length; i++) {        if (filenames[i].endsWith(".doc") == false)            continue;        Assert.assertTrue("can't read content of " + filenames[i], getTextContent(filenames[i]).length() > 0);    }}
23535ebc1d4da03f1f5ef5ba3e83f8e2dbf0ef2db09f1e55cc401e7cd85e6561
testIt
public void testIt() throws ProtocolException, ParseException
{    String urlString;    Content content;    Parse parse;    Configuration conf = NutchConfiguration.create();    Protocol protocol;    ProtocolFactory factory = new ProtocolFactory(conf);    System.out.println("Expected : " + expectedText);    for (int i = 0; i < sampleFiles.length; i++) {        urlString = "file:" + sampleDir + fileSeparator + sampleFiles[i];        if (sampleFiles[i].startsWith("ootest") == false)            continue;        protocol = factory.getProtocol(urlString);        content = protocol.getProtocolOutput(new Text(urlString), new CrawlDatum()).getContent();        parse = new ParseUtil(conf).parseByExtensionId("parse-tika", content).get(content.getUrl());        String text = parse.getText().replaceAll("[ \t\r\n]+", " ").trim();                                Assert.assertTrue(text != null && text.length() > 0);        System.out.println("Found " + sampleFiles[i] + ": " + text);    }}
23535ebc1d4da03f1f5ef5ba3e83f8e2dbf0ef2db09f1e55cc401e7cd85e6561
testIt
public void testIt() throws ProtocolException, ParseException
{    String urlString;    Protocol protocol;    Content content;    Parse parse;    for (int i = 0; i < sampleFiles.length; i++) {        urlString = "file:" + sampleDir + fileSeparator + sampleFiles[i];        Configuration conf = NutchConfiguration.create();        protocol = new ProtocolFactory(conf).getProtocol(urlString);        content = protocol.getProtocolOutput(new Text(urlString), new CrawlDatum()).getContent();        parse = new ParseUtil(conf).parseByExtensionId("parse-tika", content).get(content.getUrl());        int index = parse.getText().indexOf(expectedText);        Assert.assertTrue(index > 0);    }}
7b701e8d772d10800b92a5003da7437a4804fe9bb4d42d8e13833ddc2e831eeb
testRobotsMetaProcessor
public void testRobotsMetaProcessor()
{    Configuration conf = NutchConfiguration.create();    TikaParser parser = new TikaParser();    parser.setConf(conf);    try {        currURLsAndAnswers = new URL[][] { { new URL("http://www.nutch.org"), null }, { new URL("http://www.nutch.org"), null }, { new URL("http://www.nutch.org"), null }, { new URL("http://www.nutch.org"), null }, { new URL("http://www.nutch.org"), null }, { new URL("http://www.nutch.org"), null }, { new URL("http://www.nutch.org"), null }, { new URL("http://www.nutch.org/foo/"), new URL("http://www.nutch.org/") }, { new URL("http://www.nutch.org"), new URL("http://www.nutch.org/base/") }, { new URL("http://www.nutch.org"), null } };    } catch (Exception e) {        Assert.assertTrue("couldn't make test URLs!", false);    }    for (int i = 0; i < tests.length; i++) {        byte[] bytes = tests[i].getBytes();        HTMLDocumentImpl doc = new HTMLDocumentImpl();        doc.setErrorChecking(false);        DocumentFragment root = doc.createDocumentFragment();        String url = "http://www.nutch.org";        Content content = new Content(url, url, bytes, "text/html", new Metadata(), conf);        Parse parse = null;        try {            parse = parser.getParse(content, doc, root).get(url);        } catch (Exception e) {            e.printStackTrace();        }        HTMLMetaTags robotsMeta = new HTMLMetaTags();        HTMLMetaProcessor.getMetaTags(robotsMeta, root, currURLsAndAnswers[i][0]);        Assert.assertEquals("got noindex wrong on test " + i, answers[i][0], robotsMeta.getNoIndex());        Assert.assertEquals("got nofollow wrong on test " + i, answers[i][1], robotsMeta.getNoFollow());        Assert.assertEquals("got nocache wrong on test " + i, answers[i][2], robotsMeta.getNoCache());        Assert.assertTrue("got base href wrong on test " + i + " (got " + robotsMeta.getBaseHref() + ")", ((robotsMeta.getBaseHref() == null) && (currURLsAndAnswers[i][1] == null)) || ((robotsMeta.getBaseHref() != null) && robotsMeta.getBaseHref().equals(currURLsAndAnswers[i][1])));        if (tests[i].contains("meta-refresh redirect")) {                        URL metaRefreshUrl = robotsMeta.getRefreshHref();            Assert.assertNotNull("failed to get meta-refresh redirect", metaRefreshUrl);            Assert.assertEquals("failed to get meta-refresh redirect", "http://example.com/", metaRefreshUrl.toString());            Assert.assertEquals("failed to add meta-refresh redirect to parse status", "http://example.com/", parse.getData().getStatus().getArgs()[0]);        }    }}
23535ebc1d4da03f1f5ef5ba3e83f8e2dbf0ef2db09f1e55cc401e7cd85e6561
testIt
public void testIt() throws ProtocolException, ParseException
{    String urlString;    Protocol protocol;    Content content;    Parse parse;    Configuration conf = NutchConfiguration.create();    urlString = "file:" + sampleDir + fileSeparator + rtfFile;    protocol = new ProtocolFactory(conf).getProtocol(urlString);    content = protocol.getProtocolOutput(new Text(urlString), new CrawlDatum()).getContent();    parse = new ParseUtil(conf).parseByExtensionId("parse-tika", content).get(content.getUrl());    String text = parse.getText();    Assert.assertEquals("The quick brown fox jumps over the lazy dog", text.trim());    String title = parse.getData().getTitle();    Metadata meta = parse.getData().getParseMeta();    Assert.assertEquals("test rft document", title);    Assert.assertEquals("tests", meta.get(DublinCore.SUBJECT));}
c810d936ea9b867b32c335de012b770ec9f4f159f210bd6e61ee68b6079582df
getParse
public ParseResult getParse(final Content content)
{    String resultText = null;    String resultTitle = null;    Outlink[] outlinks = null;    List<Outlink> outLinksList = new ArrayList<Outlink>();    try {        final String contentLen = content.getMetadata().get(Response.CONTENT_LENGTH);        final int len = Integer.parseInt(contentLen);        if (LOG.isDebugEnabled()) {            LOG.debug("ziplen: " + len);        }        final byte[] contentInBytes = content.getContent();        if (contentLen != null && contentInBytes.length != len) {            return new ParseStatus(ParseStatus.FAILED, ParseStatus.FAILED_TRUNCATED, "Content truncated at " + contentInBytes.length + " bytes. Parser can't handle incomplete zip file.").getEmptyParseResult(content.getUrl(), getConf());        }        ZipTextExtractor extractor = new ZipTextExtractor(getConf());                resultText = extractor.extractText(new ByteArrayInputStream(contentInBytes), content.getUrl(), outLinksList);    } catch (Exception e) {        return new ParseStatus(ParseStatus.FAILED, "Can't be handled as Zip document. " + e).getEmptyParseResult(content.getUrl(), getConf());    }    if (resultText == null) {        resultText = "";    }    if (resultTitle == null) {        resultTitle = "";    }    outlinks = (Outlink[]) outLinksList.toArray(new Outlink[0]);    final ParseData parseData = new ParseData(ParseStatus.STATUS_SUCCESS, resultTitle, outlinks, content.getMetadata());    if (LOG.isTraceEnabled()) {        LOG.trace("Zip file parsed sucessfully !!");    }    return ParseResult.createParseResult(content.getUrl(), new ParseImpl(resultText, parseData));}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    if (args.length < 1) {        System.out.println("ZipParser <zip_file>");        System.exit(1);    }    File file = new File(args[0]);    String url = "file:" + file.getCanonicalPath();    FileInputStream in = new FileInputStream(file);    byte[] bytes = new byte[in.available()];    in.read(bytes);    in.close();    Configuration conf = NutchConfiguration.create();    ZipParser parser = new ZipParser();    parser.setConf(conf);    Metadata meta = new Metadata();    meta.add(Response.CONTENT_LENGTH, "" + file.length());    ParseResult parseResult = parser.getParse(new Content(url, url, bytes, "application/zip", meta, conf));    Parse p = parseResult.get(url);    System.out.println(parseResult.size());    System.out.println("Parse Text:");    System.out.println(p.getText());    System.out.println("Parse Data:");    System.out.println(p.getData());}
f7e5d85aca2b96469a55d93c8079d28583233e926452a57cef7a626a204d9033
extractText
public String extractText(InputStream input, String url, List<Outlink> outLinksList) throws IOException
{    String resultText = "";    ZipInputStream zin = new ZipInputStream(input);    ZipEntry entry;    while ((entry = zin.getNextEntry()) != null) {        if (!entry.isDirectory()) {            int size = (int) entry.getSize();            byte[] b = new byte[size];            for (int x = 0; x < size; x++) {                int err = zin.read();                if (err != -1) {                    b[x] = (byte) err;                }            }            String newurl = url + "/";            String fname = entry.getName();            newurl += fname;            URL aURL = new URL(newurl);            String base = aURL.toString();            int i = fname.lastIndexOf('.');            if (i != -1) {                                Tika tika = new Tika();                String contentType = tika.detect(fname);                try {                    Metadata metadata = new Metadata();                    metadata.set(Response.CONTENT_LENGTH, Long.toString(entry.getSize()));                    metadata.set(Response.CONTENT_TYPE, contentType);                    Content content = new Content(newurl, base, b, contentType, metadata, this.conf);                    Parse parse = new ParseUtil(this.conf).parse(content).get(content.getUrl());                    ParseData theParseData = parse.getData();                    Outlink[] theOutlinks = theParseData.getOutlinks();                    for (int count = 0; count < theOutlinks.length; count++) {                        outLinksList.add(new Outlink(theOutlinks[count].getToUrl(), theOutlinks[count].getAnchor()));                    }                    resultText += entry.getName() + " " + parse.getText() + " ";                } catch (ParseException e) {                    if (LOG.isInfoEnabled()) {                        LOG.info("fetch okay, but can't parse " + fname + ", reason: " + e.getMessage());                    }                }            }        }    }    return resultText;}
23535ebc1d4da03f1f5ef5ba3e83f8e2dbf0ef2db09f1e55cc401e7cd85e6561
testIt
public void testIt() throws ProtocolException, ParseException
{    String urlString;    Protocol protocol;    Content content;    Parse parse;    Configuration conf = NutchConfiguration.create();    for (int i = 0; i < sampleFiles.length; i++) {        urlString = "file:" + sampleDir + fileSeparator + sampleFiles[i];        protocol = new ProtocolFactory(conf).getProtocol(urlString);        content = protocol.getProtocolOutput(new Text(urlString), new CrawlDatum()).getContent();        parse = new ParseUtil(conf).parseByExtensionId("parse-zip", content).get(content.getUrl());        Assert.assertTrue("Extracted text does not start with <" + expectedText + ">: <" + parse.getText() + ">", parse.getText().startsWith(expectedText));    }}
799afc8c859f6ab7e9c8267554cdd36a3dcea2dc6c0fabf666f885af924bdacb
unflattenToHashmap
public static HashMap<String, Integer> unflattenToHashmap(String line)
{    HashMap<String, Integer> dict = new HashMap<String, Integer>();    String[] dictarray = line.split(",");    for (String field : dictarray) {        dict.put(field.split(":")[0], Integer.valueOf(field.split(":")[1]));    }    return dict;}
a502b1a21e6119b7212d20e5691ce99117732bcb9dbb0a58c27c6c5f989eae6e
classify
public static String classify(String line) throws IOException
{    double prob_ir = 0;    double prob_r = 0;    String result = "1";    String[] linearray = line.replaceAll("[^a-zA-Z ]", "").toLowerCase().split(" ");        if (!ismodel) {        Configuration configuration = new Configuration();        FileSystem fs = FileSystem.get(configuration);        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(fs.open(new Path("naivebayes-model"))));        uniquewords_size = Integer.valueOf(bufferedReader.readLine());        bufferedReader.readLine();        numof_ir = Integer.valueOf(bufferedReader.readLine());        numwords_ir = Integer.valueOf(bufferedReader.readLine());        wordfreq_ir = unflattenToHashmap(bufferedReader.readLine());        bufferedReader.readLine();        numof_r = Integer.valueOf(bufferedReader.readLine());        numwords_r = Integer.valueOf(bufferedReader.readLine());        wordfreq_r = unflattenToHashmap(bufferedReader.readLine());        ismodel = true;        bufferedReader.close();    }    for (String word : linearray) {        if (wordfreq_ir.containsKey(word))            prob_ir += Math.log(wordfreq_ir.get(word)) + 1 - Math.log(numwords_ir + uniquewords_size);        else            prob_ir += 1 - Math.log(numwords_ir + uniquewords_size);        if (wordfreq_r.containsKey(word))            prob_r += Math.log(wordfreq_r.get(word)) + 1 - Math.log(numwords_r + uniquewords_size);        else            prob_r += 1 - Math.log(numwords_r + uniquewords_size);    }    prob_ir += Math.log(numof_ir) - Math.log(numof_ir + numof_r);    prob_r += Math.log(numof_r) - Math.log(numof_ir + numof_r);    if (prob_ir > prob_r)        result = "0";    else        result = "1";    return result;}
330ef5fbeec10b58a83d6e1e0dc6aaebf2ae3a10fd6919524e5587c82bae4b7f
filterParse
public boolean filterParse(String text)
{    try {        return classify(text);    } catch (IOException e) {        LOG.error("Error occured while classifying:: " + text + " ::" + StringUtils.stringifyException(e));    }    return false;}
0b1dd2c3a0d500664f8c882faa8958dc391af58a5c01491fa3a2369714a09178
filterUrl
public boolean filterUrl(String url)
{    return containsWord(url, wordlist);}
aa6e7de8b3c48a97902c0cf8e2aca66f441fbd97e74cfd56024634fcad15b77f
classify
public boolean classify(String text) throws IOException
{        if (Classify.classify(text).equals("1"))        return true;    return false;}
d617b61e38752ed42120ff23a6ca73a1b5ea68243b7a1009b06e29be0fcc54ca
train
public void train() throws Exception
{        if (!FileSystem.get(conf).exists(new Path("naivebayes-model"))) {        LOG.info("Training the Naive Bayes Model");        Train.start(inputFilePath);    } else {        LOG.info("Model file already exists. Skipping training.");    }}
ee3d96f3a6606a84609069efc314151593d90365e768412d45e4d7ac03174fa6
containsWord
public boolean containsWord(String url, ArrayList<String> wordlist)
{    for (String word : wordlist) {        if (url.contains(word)) {            return true;        }    }    return false;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    inputFilePath = conf.get(TRAINFILE_MODELFILTER);    dictionaryFile = conf.get(DICTFILE_MODELFILTER);    if (inputFilePath == null || inputFilePath.trim().length() == 0 || dictionaryFile == null || dictionaryFile.trim().length() == 0) {        String message = "ParseFilter: NaiveBayes: trainfile or wordlist not set in the parsefilte.naivebayes.trainfile or parsefilte.naivebayes.wordlist";        if (LOG.isErrorEnabled()) {            LOG.error(message);        }        throw new IllegalArgumentException(message);    }    try {        if ((FileSystem.get(conf).exists(new Path(inputFilePath))) || (FileSystem.get(conf).exists(new Path(dictionaryFile)))) {            String message = "ParseFilter: NaiveBayes: " + inputFilePath + " or " + dictionaryFile + " not found!";            if (LOG.isErrorEnabled()) {                LOG.error(message);            }            throw new IllegalArgumentException(message);        }        BufferedReader br = null;        String CurrentLine;        Reader reader = conf.getConfResourceAsReader(dictionaryFile);        br = new BufferedReader(reader);        while ((CurrentLine = br.readLine()) != null) {            wordlist.add(CurrentLine);        }    } catch (IOException e) {        LOG.error(StringUtils.stringifyException(e));    }    try {        train();    } catch (Exception e) {        LOG.error("Error occured while training:: " + StringUtils.stringifyException(e));    }}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
9ff841f3d46425f0defcf4346027b52742d29abc435829a9bc29d5c88e553a7b
filter
public ParseResult filter(Content content, ParseResult parseResult, HTMLMetaTags metaTags, DocumentFragment doc)
{    Parse parse = parseResult.get(content.getUrl());    String url = content.getBaseUrl();    ArrayList<Outlink> tempOutlinks = new ArrayList<Outlink>();    String text = parse.getText();    if (!filterParse(text)) {                                LOG.info("ParseFilter: NaiveBayes: Page found irrelevant:: " + url);        LOG.info("Checking outlinks");        Outlink[] out = null;        for (int i = 0; i < parse.getData().getOutlinks().length; i++) {            LOG.info("ParseFilter: NaiveBayes: Outlink to check:: " + parse.getData().getOutlinks()[i].getToUrl());            if (filterUrl(parse.getData().getOutlinks()[i].getToUrl())) {                tempOutlinks.add(parse.getData().getOutlinks()[i]);                LOG.info("ParseFilter: NaiveBayes: found relevant");            } else {                LOG.info("ParseFilter: NaiveBayes: found irrelevant");            }        }        out = new Outlink[tempOutlinks.size()];        for (int i = 0; i < tempOutlinks.size(); i++) {            out[i] = tempOutlinks.get(i);        }        parse.getData().setOutlinks(out);    } else {        LOG.info("ParseFilter: NaiveBayes: Page found relevant:: " + url);    }    return parseResult;}
39ffdd9b790b89684a7c664b466d484b1ef357590f2bfeea4392769d315b9cb4
replacefirstoccuranceof
public static String replacefirstoccuranceof(String tomatch, String line)
{    int index = line.indexOf(tomatch);    if (index == -1) {        return line;    } else {        return line.substring(0, index) + line.substring(index + tomatch.length());    }}
c41323aa0d3141d6ec75cf10aa94f0d60077302c1bc29bb906afb7b3686a6632
updateHashMap
public static void updateHashMap(HashMap<String, Integer> dict, String key)
{    if (!key.equals("")) {        if (dict.containsKey(key))            dict.put(key, dict.get(key) + 1);        else            dict.put(key, 1);    }}
e827e3c9fb24702b5f9a2a2358b9e10232b90bc0605819f4681fcc9b961dd337
flattenHashMap
public static String flattenHashMap(HashMap<String, Integer> dict)
{    String result = "";    for (String key : dict.keySet()) {        result += key + ":" + dict.get(key) + ",";    }        result = result.substring(0, result.length() - 1);    return result;}
9656bf1cd6657179fbbb580664c15817deb705cf8097a3c71a0e554291b8fe5b
start
public static void start(String filepath) throws IOException
{                int numof_ir = 0;    int numof_r = 0;    int numwords_ir = 0;    int numwords_r = 0;    HashSet<String> uniquewords = new HashSet<String>();    HashMap<String, Integer> wordfreq_ir = new HashMap<String, Integer>();    HashMap<String, Integer> wordfreq_r = new HashMap<String, Integer>();    String line = "";    String target = "";    String[] linearray = null;        Configuration configuration = new Configuration();    FileSystem fs = FileSystem.get(configuration);    BufferedReader bufferedReader = new BufferedReader(configuration.getConfResourceAsReader(filepath));    while ((line = bufferedReader.readLine()) != null) {        target = line.split("\t")[0];        line = replacefirstoccuranceof(target + "\t", line);        linearray = line.replaceAll("[^a-zA-Z ]", "").toLowerCase().split(" ");                if (target.equals("0")) {            numof_ir += 1;            numwords_ir += linearray.length;            for (int i = 0; i < linearray.length; i++) {                uniquewords.add(linearray[i]);                updateHashMap(wordfreq_ir, linearray[i]);            }        } else {            numof_r += 1;            numwords_r += linearray.length;            for (int i = 0; i < linearray.length; i++) {                uniquewords.add(linearray[i]);                updateHashMap(wordfreq_r, linearray[i]);            }        }    }        Path path = new Path("naivebayes-model");    Writer writer = new BufferedWriter(new OutputStreamWriter(fs.create(path, true)));    writer.write(String.valueOf(uniquewords.size()) + "\n");    writer.write("0\n");    writer.write(String.valueOf(numof_ir) + "\n");    writer.write(String.valueOf(numwords_ir) + "\n");    writer.write(flattenHashMap(wordfreq_ir) + "\n");    writer.write("1\n");    writer.write(String.valueOf(numof_r) + "\n");    writer.write(String.valueOf(numwords_r) + "\n");    writer.write(flattenHashMap(wordfreq_r) + "\n");    writer.close();    bufferedReader.close();}
9ff841f3d46425f0defcf4346027b52742d29abc435829a9bc29d5c88e553a7b
filter
public ParseResult filter(Content content, ParseResult parseResult, HTMLMetaTags metaTags, DocumentFragment doc)
{    Parse parse = parseResult.get(content.getUrl());    String html = new String(content.getContent());    String text = parse.getText();    for (Map.Entry<String, RegexRule> entry : rules.entrySet()) {        String field = entry.getKey();        RegexRule regexRule = entry.getValue();        String source = null;        if (regexRule.source.equalsIgnoreCase("html")) {            source = html;        }        if (regexRule.source.equalsIgnoreCase("text")) {            source = text;        }        if (source == null) {            LOG.error("source for regex rule: " + field + " misconfigured");        }        if (matches(source, regexRule.regex)) {            parse.getData().getParseMeta().set(field, "true");        } else {            parse.getData().getParseMeta().set(field, "false");        }    }    return parseResult;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;        String pluginName = "parsefilter-regex";    Extension[] extensions = PluginRepository.get(conf).getExtensionPoint(HtmlParseFilter.class.getName()).getExtensions();    for (int i = 0; i < extensions.length; i++) {        Extension extension = extensions[i];        if (extension.getDescriptor().getPluginId().equals(pluginName)) {            attributeFile = extension.getAttribute("file");            break;        }    }        if (attributeFile != null && attributeFile.trim().equals("")) {        attributeFile = null;    }    if (attributeFile != null) {        if (LOG.isInfoEnabled()) {            LOG.info("Attribute \"file\" is defined for plugin " + pluginName + " as " + attributeFile);        }    } else {        if (LOG.isWarnEnabled()) {            LOG.warn("Attribute \"file\" is not defined in plugin.xml for plugin " + pluginName);        }    }        String file = conf.get("parsefilter.regex.file");    String stringRules = conf.get("parsefilter.regex.rules");    if (regexFile != null) {        file = regexFile;    } else if (attributeFile != null) {        file = attributeFile;    }    Reader reader = null;    if (stringRules != null) {                reader = new StringReader(stringRules);    } else {        reader = conf.getConfResourceAsReader(file);    }    try {        if (reader == null) {            reader = new FileReader(file);        }        readConfiguration(reader);    } catch (IOException e) {        LOG.error(org.apache.hadoop.util.StringUtils.stringifyException(e));    }}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
7d072f1657309e0604a1368c0d53fbf7c249894017bca4ddb625abbb19e462ad
matches
private boolean matches(String value, Pattern pattern)
{    if (value != null) {        Matcher matcher = pattern.matcher(value);        return matcher.find();    }    return false;}
8fd3b6a758013f17936e866b94a5d5896c63c1c327e621a2661e341abe4af837
readConfiguration
private synchronized void readConfiguration(Reader configReader) throws IOException
{    if (rules.size() > 0) {        return;    }    String line;    BufferedReader reader = new BufferedReader(configReader);    while ((line = reader.readLine()) != null) {        if (StringUtils.isNotBlank(line) && !line.startsWith("#")) {            line = line.trim();            String[] parts = line.split("\\s");            if (parts.length == 3) {                String field = parts[0].trim();                String source = parts[1].trim();                String regex = parts[2].trim();                rules.put(field, new RegexRule(source, regex));            } else {                LOG.info("RegexParseFilter rule is invalid. " + line);            }        }    }}
31c4986a46c4bb0affc207a26df284ee5e8e6958ec810614580e69212f042ac3
testPositiveFilter
public void testPositiveFilter() throws Exception
{    Configuration conf = NutchConfiguration.create();    String file = SAMPLES + SEPARATOR + "regex-parsefilter.txt";    RegexParseFilter filter = new RegexParseFilter(file);    filter.setConf(conf);    String url = "http://nutch.apache.org/";    String html = "<body><html><h1>nutch</h1><p>this is the extracted text blablabla</p></body></html>";    Content content = new Content(url, url, html.getBytes("UTF-8"), "text/html", new Metadata(), conf);    Parse parse = new ParseImpl("nutch this is the extracted text blablabla", new ParseData());    ParseResult result = ParseResult.createParseResult(url, parse);    result = filter.filter(content, result, null, null);    Metadata meta = parse.getData().getParseMeta();    assertEquals("true", meta.get("first"));    assertEquals("true", meta.get("second"));}
02ff06ce087f1f699a81946de64a5e76ff2e3daa58329730247f6baad0db86f4
testNegativeFilter
public void testNegativeFilter() throws Exception
{    Configuration conf = NutchConfiguration.create();    String file = SAMPLES + SEPARATOR + "regex-parsefilter.txt";    RegexParseFilter filter = new RegexParseFilter(file);    filter.setConf(conf);    String url = "http://nutch.apache.org/";    String html = "<body><html><h2>nutch</h2><p>this is the extracted text no bla</p></body></html>";    Content content = new Content(url, url, html.getBytes("UTF-8"), "text/html", new Metadata(), conf);    Parse parse = new ParseImpl("nutch this is the extracted text bla", new ParseData());    ParseResult result = ParseResult.createParseResult(url, parse);    result = filter.filter(content, result, null, null);    Metadata meta = parse.getData().getParseMeta();    assertEquals("false", meta.get("first"));    assertEquals("false", meta.get("second"));}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    this.maxContentLength = conf.getInt("file.content.limit", 1024 * 1024);    this.crawlParents = conf.getBoolean("file.crawl.parent", true);    this.symlinksAsRedirects = conf.getBoolean("file.crawl.redirect_noncanonical", true);}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
a24acef591d8d07512828c485cfbaab4890e9f564d6052bf99eef63df365364b
setMaxContentLength
public void setMaxContentLength(int maxContentLength)
{    this.maxContentLength = maxContentLength;}
6d413a80163f4d7e678657d3c1ba04fedc25050e6e7590618feec8814211d7b3
getProtocolOutput
public ProtocolOutput getProtocolOutput(Text url, CrawlDatum datum)
{    String urlString = url.toString();    try {        URL u = new URL(urlString);        int redirects = 0;        while (true) {            FileResponse response;                        response = new FileResponse(u, datum, this, getConf());                        int code = response.getCode();            if (code == 200) {                                return new ProtocolOutput(response.toContent());            } else if (code == 304) {                                return new ProtocolOutput(response.toContent(), ProtocolStatus.STATUS_NOTMODIFIED);            } else if (code == 401) {                                return new ProtocolOutput(response.toContent(), new ProtocolStatus(ProtocolStatus.ACCESS_DENIED));            } else if (code == 404) {                                return new ProtocolOutput(response.toContent(), ProtocolStatus.STATUS_NOTFOUND);            } else if (code >= 300 && code < 400) {                                u = new URL(response.getHeader("Location"));                if (LOG.isTraceEnabled()) {                    LOG.trace("redirect to " + u);                }                if (symlinksAsRedirects) {                    return new ProtocolOutput(response.toContent(), new ProtocolStatus(ProtocolStatus.MOVED, u));                } else if (redirects == MAX_REDIRECTS) {                    LOG.trace("Too many redirects: {}", url);                    return new ProtocolOutput(response.toContent(), new ProtocolStatus(ProtocolStatus.REDIR_EXCEEDED, u));                }                redirects++;            } else {                                throw new FileError(code);            }        }    } catch (Exception e) {        e.printStackTrace();        return new ProtocolOutput(null, new ProtocolStatus(e));    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int maxContentLength = Integer.MIN_VALUE;    boolean dumpContent = false;    String urlString = null;    String usage = "Usage: File [-maxContentLength L] [-dumpContent] url";    if (args.length == 0) {        System.err.println(usage);        System.exit(-1);    }    for (int i = 0; i < args.length; i++) {        if (args[i].equals("-maxContentLength")) {            maxContentLength = Integer.parseInt(args[++i]);        } else if (args[i].equals("-dumpContent")) {            dumpContent = true;        } else if (i != args.length - 1) {            System.err.println(usage);            System.exit(-1);        } else            urlString = args[i];    }    File file = new File();    file.setConf(NutchConfiguration.create());    if (    maxContentLength != Integer.MIN_VALUE)        file.setMaxContentLength(maxContentLength);            ProtocolOutput output = file.getProtocolOutput(new Text(urlString), new CrawlDatum());    Content content = output.getContent();    System.err.println("URL: " + content.getUrl());    System.err.println("Status: " + output.getStatus());    System.err.println("Content-Type: " + content.getContentType());    System.err.println("Content-Length: " + content.getMetadata().get(Response.CONTENT_LENGTH));    System.err.println("Last-Modified: " + content.getMetadata().get(Response.LAST_MODIFIED));    String redirectLocation = content.getMetadata().get("Location");    if (redirectLocation != null) {        System.err.println("Location: " + redirectLocation);    }    if (dumpContent) {        System.out.print(new String(content.getContent()));    }    file = null;}
7f90f3c3a9c578d789339dc31e965bfefda78f244aac7037bd5e441fb313996a
getRobotRules
public BaseRobotRules getRobotRules(Text url, CrawlDatum datum, List<Content> robotsTxtContent)
{    return RobotRulesParser.EMPTY_RULES;}
588bb1045d27d19035e67221e7759e40d5b8bfce3810233bea4aa4da2c496e3b
getCode
public int getCode(int code)
{    return code;}
871172d34cf47bd1ccc8d8f81877fbf834289fcf345350e529b8b4e7a6708c5d
getCode
public int getCode()
{    return code;}
ce222e9e26ff92f109221120401e746a4137a63055fa3f4c459b71bc3b9a3f7b
getHeader
public String getHeader(String name)
{    return headers.get(name);}
a724d7d22eec9af58dc1baab31eb2f9394c370706fcded02b6d254fcd56fd2b9
getContent
public byte[] getContent()
{    return content;}
430dc8a1ef9bac50a171783411e4d4f8113c40f3fddb7ceccd77c44ed77b7a04
toContent
public Content toContent()
{    return new Content(orig, base, (content != null ? content : EMPTY_CONTENT), getHeader(Response.CONTENT_TYPE), headers, this.conf);}
ca7996d7c9a577296c0bbf5b9e4fdb3da22f902178df62c2d571e14d1ae91079
getFileAsHttpResponse
private void getFileAsHttpResponse(java.io.File f) throws FileException, IOException
{            long size = f.length();    if (size > Integer.MAX_VALUE) {        throw new FileException("file is too large, size: " + size);                }        int len = (int) size;    if (this.file.maxContentLength >= 0 && len > this.file.maxContentLength)        len = this.file.maxContentLength;    this.content = new byte[len];    java.io.InputStream is = new java.io.FileInputStream(f);    int offset = 0;    int n = 0;    while (offset < len && (n = is.read(this.content, offset, len - offset)) >= 0) {        offset += n;    }    if (offset < len) {                if (File.LOG.isWarnEnabled()) {            File.LOG.warn("not enough bytes read from file: " + f.getPath());        }    }    is.close();        headers.set(Response.CONTENT_LENGTH, Long.valueOf(size).toString());    headers.set(Response.LAST_MODIFIED, HttpDateFormat.toString(f.lastModified()));    String mimeType = tika.detect(f);    headers.set(Response.CONTENT_TYPE, mimeType != null ? mimeType : "");            this.code = 200;}
ba3d743b9a1646da317290fb42af2d3bdd694119af22a862b31c3b48b9685ff1
getDirAsHttpResponse
private void getDirAsHttpResponse(java.io.File f) throws IOException
{    String path = f.toString();    if (this.file.crawlParents)        this.content = list2html(f.listFiles(), path, "/".equals(path) ? false : true);    else        this.content = list2html(f.listFiles(), path, false);        headers.set(Response.CONTENT_LENGTH, Integer.valueOf(this.content.length).toString());    headers.set(Response.CONTENT_TYPE, "text/html");    headers.set(Response.LAST_MODIFIED, HttpDateFormat.toString(f.lastModified()));            this.code = 200;}
1a71ea1ccacde5617acfc0d509f8f865816d81250a2ad97ff21c0abe311d96ee
list2html
private byte[] list2html(java.io.File[] list, String path, boolean includeDotDot)
{    StringBuffer x = new StringBuffer("<html><head>");    x.append("<title>Index of " + path + "</title></head>\n");    x.append("<body><h1>Index of " + path + "</h1><pre>\n");    if (includeDotDot) {        x.append("<a href='../'>../</a>\t-\t-\t-\n");    }        java.io.File f;    for (int i = 0; i < list.length; i++) {        f = list[i];        String name = f.getName();        String time = HttpDateFormat.toString(f.lastModified());        if (f.isDirectory()) {                                                            x.append("<a href='" + name + "/" + "'>" + name + "/</a>\t");            x.append(time + "\t-\n");        } else if (f.isFile()) {            x.append("<a href='" + name + "'>" + name + "</a>\t");            x.append(time + "\t" + f.length() + "\n");        } else {                }    }    x.append("</pre></body></html>\n");    return new String(x).getBytes();}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    conf = NutchConfiguration.create();}
b24ccb3ed5b6cbb44e0e6b7b7438b475c376f00ef7e5f7098a09a6f3f67ac722
testSetContentType
public void testSetContentType() throws ProtocolException
{    for (String testTextFile : testTextFiles) {        setContentType(testTextFile);    }}
6d044384d81ec7a5ec8a16fab3874bb8de061cd1d13e631410536c1353e114e3
setContentType
public void setContentType(String testTextFile) throws ProtocolException
{    String urlString = "file:" + sampleDir + fileSeparator + testTextFile;    Assert.assertNotNull(urlString);    Protocol protocol = new ProtocolFactory(conf).getProtocol(urlString);    ProtocolOutput output = protocol.getProtocolOutput(new Text(urlString), datum);    Assert.assertNotNull(output);    Assert.assertEquals("Status code: [" + output.getStatus().getCode() + "], not equal to: [" + ProtocolStatus.SUCCESS + "]: args: [" + output.getStatus().getArgs() + "]", ProtocolStatus.SUCCESS, output.getStatus().getCode());    Assert.assertNotNull(output.getContent());    Assert.assertNotNull(output.getContent().getContentType());    Assert.assertEquals(expectedMimeType, output.getContent().getContentType());    Assert.assertNotNull(output.getContent().getMetadata());    Assert.assertEquals(expectedMimeType, output.getContent().getMetadata().get(Response.CONTENT_TYPE));}
cd28c637eae4c75a47cd81fc146a9d00692be3513cbdb1a783c53b4e5f2d1930
__initDefaults
private void __initDefaults()
{    __passiveHost = null;    __passivePort = -1;    __systemName = null;}
3745f7124d0e222347e1c2697e99ad4ff77dc0973a7e0265146c721ee70966e7
__parsePassiveModeReply
private void __parsePassiveModeReply(String reply) throws MalformedServerReplyException
{    int i, index, lastIndex;    String octet1, octet2;    StringBuffer host;    reply = reply.substring(reply.indexOf('(') + 1, reply.indexOf(')')).trim();    host = new StringBuffer(24);    lastIndex = 0;    index = reply.indexOf(',');    host.append(reply.substring(lastIndex, index));    for (i = 0; i < 3; i++) {        host.append('.');        lastIndex = index + 1;        index = reply.indexOf(',', lastIndex);        host.append(reply.substring(lastIndex, index));    }    lastIndex = index + 1;    index = reply.indexOf(',', lastIndex);    octet1 = reply.substring(lastIndex, index);    octet2 = reply.substring(index + 1);        try {        index = Integer.parseInt(octet1);        lastIndex = Integer.parseInt(octet2);    } catch (NumberFormatException e) {        throw new MalformedServerReplyException("Could not parse passive host information.\nServer Reply: " + reply);    }    index <<= 8;    index |= lastIndex;    __passiveHost = host.toString();    __passivePort = index;}
575566cf8fa3f801c83ece5683c2e661bfeeeb70fb35a4efa7d76c7b65de43b5
__openPassiveDataConnection
protected Socket __openPassiveDataConnection(int command, String arg) throws IOException, FtpExceptionCanNotHaveDataConnection
{    Socket socket;    if (pasv() != FTPReply.ENTERING_PASSIVE_MODE)        throw new FtpExceptionCanNotHaveDataConnection("pasv() failed. " + getReplyString());    try {        __parsePassiveModeReply(getReplyStrings()[0]);    } catch (MalformedServerReplyException e) {        throw new FtpExceptionCanNotHaveDataConnection(e.getMessage());    }                                                                                    socket = _socketFactory_.createSocket(__passiveHost, __passivePort);    if (!FTPReply.isPositivePreliminary(sendCommand(command, arg))) {        socket.close();        return null;    }    if (__remoteVerificationEnabled && !verifyRemote(socket)) {        InetAddress host1, host2;        host1 = socket.getInetAddress();        host2 = getRemoteAddress();        socket.close();                throw new FtpExceptionCanNotHaveDataConnection("Host attempting data connection " + host1.getHostAddress() + " is not same as server " + host2.getHostAddress() + " So we intentionally close it for security precaution.");    }    if (__dataTimeout >= 0)        socket.setSoTimeout(__dataTimeout);    return socket;}
060061ae27b0fe2a37299b7ffcb2844bf86759311f944eaea8c68b1d9df30c02
setDataTimeout
public void setDataTimeout(int timeout)
{    __dataTimeout = timeout;}
ad83df86878b89435dd0d09352a6dfd615244a996e6b34403f6d485c96147d19
disconnect
public void disconnect() throws IOException
{    __initDefaults();    super.disconnect();}
3db94b44a1decfa31151eb2aaf3f2e78cbddf7be7eb4151698e2a8cfeee8987d
setRemoteVerificationEnabled
public void setRemoteVerificationEnabled(boolean enable)
{    __remoteVerificationEnabled = enable;}
0827095272371caa37211afb7cf179616aaaff66fb6a0e150bef8507cf68f957
isRemoteVerificationEnabled
public boolean isRemoteVerificationEnabled()
{    return __remoteVerificationEnabled;}
ae689c8222bbe2b6d9aefe47c9e1d768973548fac6cf97b683cda15deeee38b8
login
public boolean login(String username, String password) throws IOException
{    user(username);    if (FTPReply.isPositiveCompletion(getReplyCode()))        return true;        if (!FTPReply.isPositiveIntermediate(getReplyCode()))        return false;    return FTPReply.isPositiveCompletion(pass(password));}
0d8591569bf0ff7c7a820e8424d45e57fa0529296ae9f3836ea2415e5ff13227
logout
public boolean logout() throws IOException
{    return FTPReply.isPositiveCompletion(quit());}
0206e1f4c0a19765545f82f7bb5692f24bdf26002b4e66e1e1d1da0213a9a3d6
retrieveList
public void retrieveList(String path, List<FTPFile> entries, int limit, FTPFileEntryParser parser) throws IOException, FtpExceptionCanNotHaveDataConnection, FtpExceptionUnknownForcedDataClose, FtpExceptionControlClosedByForcedDataClose
{    Socket socket = __openPassiveDataConnection(FTPCommand.LIST, path);    if (socket == null)        throw new FtpExceptionCanNotHaveDataConnection("LIST " + ((path == null) ? "" : path));    BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));                int count = 0;    String line = parser.readNextEntry(reader);    while (line != null) {        FTPFile ftpFile = parser.parseFTPEntry(line);                if (ftpFile == null) {            line = parser.readNextEntry(reader);            continue;        }        entries.add(ftpFile);        count += line.length();                if (limit >= 0 && count > limit) {                        break;        }        line = parser.readNextEntry(reader);    }                socket.close();    try {        int reply = getReply();        if (!_notBadReply(reply))            throw new FtpExceptionUnknownForcedDataClose(getReplyString());    } catch (FTPConnectionClosedException e) {                throw new FtpExceptionControlClosedByForcedDataClose(e.getMessage());    }}
4c862d31f806c2ac0e5f6970531eea77082cd457fc9cf5b7168ec5b212bcf497
retrieveFile
public void retrieveFile(String path, OutputStream os, int limit) throws IOException, FtpExceptionCanNotHaveDataConnection, FtpExceptionUnknownForcedDataClose, FtpExceptionControlClosedByForcedDataClose
{    Socket socket = __openPassiveDataConnection(FTPCommand.RETR, path);    if (socket == null)        throw new FtpExceptionCanNotHaveDataConnection("RETR " + ((path == null) ? "" : path));    InputStream input = socket.getInputStream();                                int len;    int count = 0;    byte[] buf = new byte[org.apache.commons.net.io.Util.DEFAULT_COPY_BUFFER_SIZE];    while ((len = input.read(buf, 0, buf.length)) != -1) {        count += len;                if (limit >= 0 && count > limit) {            os.write(buf, 0, len - (count - limit));                        break;        }        os.write(buf, 0, len);        os.flush();    }                socket.close();    try {        int reply = getReply();        if (!_notBadReply(reply))            throw new FtpExceptionUnknownForcedDataClose(getReplyString());    } catch (FTPConnectionClosedException e) {                throw new FtpExceptionControlClosedByForcedDataClose(e.getMessage());    }}
4554f611c46832bc15a6c105d273755edbee3a0a4de36c900152e48ea98f090b
_notBadReply
private boolean _notBadReply(int reply)
{    if (FTPReply.isPositiveCompletion(reply)) {        } else if (reply == 426) {                        } else if (reply == 450) {                        } else if (reply == 451) {                        } else {                return false;    }    return true;}
609e8b4a3af767fcc3744e16e5be079cdb49c94c52862f381989c1c024381814
setFileType
public boolean setFileType(int fileType) throws IOException
{    if (FTPReply.isPositiveCompletion(type(fileType))) {        /*       * __fileType = fileType; __fileFormat = FTP.NON_PRINT_TEXT_FORMAT;       */        return true;    }    return false;}
bfc2a99dd076fce868ff20a801c642623fce554c3d2dff9418cca76d7e103d46
getSystemName
public String getSystemName() throws IOException, FtpExceptionBadSystResponse
{        if (__systemName == null && FTPReply.isPositiveCompletion(syst())) {        __systemName = (getReplyStrings()[0]).substring(4);    } else {        throw new FtpExceptionBadSystResponse("Bad response of SYST: " + getReplyString());    }    return __systemName;}
3a5dcc20b774b2df69828d9a4b0367efab4da9242462698221d6dc43329aea77
sendNoOp
public boolean sendNoOp() throws IOException
{    return FTPReply.isPositiveCompletion(noop());}
e842fa3bb9a59331123c00f4351330f88a067e6a6f09b336b0170c09d6f06a04
setTimeout
public void setTimeout(int to)
{    timeout = to;}
6996bd79e877e68fc52018c6d3a2185b3884a8d4932798095c596264e2d24619
setMaxContentLength
public void setMaxContentLength(int length)
{    maxContentLength = length;}
e1aceba1aecb917d9500ae7aee5a0b5b7d7cb1bf51061e261e8e130ab7da5c59
setFollowTalk
public void setFollowTalk(boolean followTalk)
{    this.followTalk = followTalk;}
b540111f4d139940a84a666e98a3bd1ffc901fbd1532b2635936efc83d9eb86c
setKeepConnection
public void setKeepConnection(boolean keepConnection)
{    this.keepConnection = keepConnection;}
6d413a80163f4d7e678657d3c1ba04fedc25050e6e7590618feec8814211d7b3
getProtocolOutput
public ProtocolOutput getProtocolOutput(Text url, CrawlDatum datum)
{    String urlString = url.toString();    try {        URL u = new URL(urlString);        int redirects = 0;        while (true) {            FtpResponse response;                        response = new FtpResponse(u, datum, this, getConf());            int code = response.getCode();            datum.getMetaData().put(Nutch.PROTOCOL_STATUS_CODE_KEY, new Text(Integer.toString(code)));            if (code == 200) {                                return new ProtocolOutput(response.toContent());            } else if (code >= 300 && code < 400) {                                if (redirects == MAX_REDIRECTS)                    throw new FtpException("Too many redirects: " + url);                String loc = response.getHeader("Location");                try {                    u = new URL(u, loc);                } catch (MalformedURLException mue) {                    LOG.error("Could not create redirectURL for {} with {}", url, loc);                    return new ProtocolOutput(null, new ProtocolStatus(mue));                }                redirects++;                if (LOG.isTraceEnabled()) {                    LOG.trace("redirect to " + u);                }            } else {                                throw new FtpError(code);            }        }    } catch (Exception e) {        LOG.error("Could not get protocol output for {}: {}", url, e.getMessage());        return new ProtocolOutput(null, new ProtocolStatus(e));    }}
ddca7f5216d5fd02f05ebffa588d56405449be6591bd52591e9579a52c53e164
finalize
protected void finalize()
{    try {        if (this.client != null && this.client.isConnected()) {            this.client.logout();            this.client.disconnect();        }    } catch (IOException e) {        }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int timeout = Integer.MIN_VALUE;    int maxContentLength = Integer.MIN_VALUE;    @SuppressWarnings("unused")    String logLevel = "info";    boolean followTalk = false;    boolean keepConnection = false;    boolean dumpContent = false;    String urlString = null;    String usage = "Usage: Ftp [-logLevel level] [-followTalk] [-keepConnection] [-timeout N] [-maxContentLength L] [-dumpContent] url";    if (args.length == 0) {        System.err.println(usage);        System.exit(-1);    }    for (int i = 0; i < args.length; i++) {        if (args[i].equals("-logLevel")) {            logLevel = args[++i];        } else if (args[i].equals("-followTalk")) {            followTalk = true;        } else if (args[i].equals("-keepConnection")) {            keepConnection = true;        } else if (args[i].equals("-timeout")) {            timeout = Integer.parseInt(args[++i]) * 1000;        } else if (args[i].equals("-maxContentLength")) {            maxContentLength = Integer.parseInt(args[++i]);        } else if (args[i].equals("-dumpContent")) {            dumpContent = true;        } else if (i != args.length - 1) {            System.err.println(usage);            System.exit(-1);        } else {            urlString = args[i];        }    }    Ftp ftp = new Ftp();    ftp.setFollowTalk(followTalk);    ftp.setKeepConnection(keepConnection);    if (    timeout != Integer.MIN_VALUE)        ftp.setTimeout(timeout);    if (    maxContentLength != Integer.MIN_VALUE)        ftp.setMaxContentLength(maxContentLength);            Content content = ftp.getProtocolOutput(new Text(urlString), new CrawlDatum()).getContent();    System.err.println("Content-Type: " + content.getContentType());    System.err.println("Content-Length: " + content.getMetadata().get(Response.CONTENT_LENGTH));    System.err.println("Last-Modified: " + content.getMetadata().get(Response.LAST_MODIFIED));    if (dumpContent) {        System.out.print(new String(content.getContent()));    }    ftp = null;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    this.maxContentLength = conf.getInt("ftp.content.limit", 1024 * 1024);    this.timeout = conf.getInt("ftp.timeout", 10000);    this.userName = conf.get("ftp.username", "anonymous");    this.passWord = conf.get("ftp.password", "anonymous@example.com");    this.serverTimeout = conf.getInt("ftp.server.timeout", 60 * 1000);    this.keepConnection = conf.getBoolean("ftp.keep.connection", false);    this.followTalk = conf.getBoolean("ftp.follow.talk", false);    this.robots.setConf(conf);}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
7f90f3c3a9c578d789339dc31e965bfefda78f244aac7037bd5e441fb313996a
getRobotRules
public BaseRobotRules getRobotRules(Text url, CrawlDatum datum, List<Content> robotsTxtContent)
{    return robots.getRobotRulesSet(this, url, robotsTxtContent);}
2e6eda184436ee2e284ddcc9dbbe010f011ca3b9df271a0f8ee3fd2f7bf19efb
getBufferSize
public int getBufferSize()
{    return BUFFER_SIZE;}
588bb1045d27d19035e67221e7759e40d5b8bfce3810233bea4aa4da2c496e3b
getCode
public int getCode(int code)
{    return code;}
871172d34cf47bd1ccc8d8f81877fbf834289fcf345350e529b8b4e7a6708c5d
getCode
public int getCode()
{    return code;}
ce222e9e26ff92f109221120401e746a4137a63055fa3f4c459b71bc3b9a3f7b
getHeader
public String getHeader(String name)
{    return headers.get(name);}
a724d7d22eec9af58dc1baab31eb2f9394c370706fcded02b6d254fcd56fd2b9
getContent
public byte[] getContent()
{    return content;}
430dc8a1ef9bac50a171783411e4d4f8113c40f3fddb7ceccd77c44ed77b7a04
toContent
public Content toContent()
{    return new Content(orig, base, (content != null ? content : EMPTY_CONTENT), getHeader(Response.CONTENT_TYPE), headers, this.conf);}
bc6df300bee42b46a018de3fb4976dc3c0d7a3813e390003df6b54fe227729f7
getFileAsHttpResponse
private void getFileAsHttpResponse(String path, long lastModified) throws IOException
{    ByteArrayOutputStream os = null;    List<FTPFile> list = null;    try {                list = new LinkedList<FTPFile>();        ftp.client.retrieveList(path, list, ftp.maxContentLength, ftp.parser);        FTPFile ftpFile = (FTPFile) list.get(0);        this.headers.set(Response.CONTENT_LENGTH, Long.valueOf(ftpFile.getSize()).toString());        this.headers.set(Response.LAST_MODIFIED, HttpDateFormat.toString(ftpFile.getTimestamp()));                if (ftpFile.getTimestamp().getTimeInMillis() <= lastModified) {            code = 304;            return;        }        os = new ByteArrayOutputStream(ftp.getBufferSize());        ftp.client.retrieveFile(path, os, ftp.maxContentLength);        this.content = os.toByteArray();                                                        this.code = 200;    } catch (FtpExceptionControlClosedByForcedDataClose e) {                if ((ftp.followTalk) && (Ftp.LOG.isInfoEnabled())) {            Ftp.LOG.info("delete client because server cut off control channel: " + e);        }        ftp.client = null;                if (os == null) {                        if (Ftp.LOG.isWarnEnabled()) {                Ftp.LOG.warn("Please try larger maxContentLength for ftp.client.retrieveList(). " + e);            }                                    this.code = 400;            return;        }        FTPFile ftpFile = (FTPFile) list.get(0);        this.headers.set(Response.CONTENT_LENGTH, Long.valueOf(ftpFile.getSize()).toString());                this.headers.set(Response.LAST_MODIFIED, HttpDateFormat.toString(ftpFile.getTimestamp()));        this.content = os.toByteArray();        if (ftpFile.getTimestamp().getTimeInMillis() <= lastModified) {            code = 304;            return;        }                                                        this.code = 200;    } catch (FtpExceptionCanNotHaveDataConnection e) {        if (FTPReply.isPositiveCompletion(ftp.client.cwd(path))) {                        this.headers.set(Response.LOCATION, path + "/");                        this.code = 300;                } else {                                    this.code = 404;        }    } catch (FtpExceptionUnknownForcedDataClose e) {                if (Ftp.LOG.isWarnEnabled()) {            Ftp.LOG.warn("Unrecognized reply after forced close of data channel. " + "If this is acceptable, please modify Client.java accordingly. " + e);        }                this.code = 400;    }}
593d0efbdf7b7c9c1ccad9925139404c52c0e9c0e074b3c29514aebc3b7ad8e6
getDirAsHttpResponse
private void getDirAsHttpResponse(String path, long lastModified) throws IOException
{    List<FTPFile> list = new LinkedList<FTPFile>();    try {                if (!FTPReply.isPositiveCompletion(ftp.client.cwd(path))) {                        this.code = 404;            return;        }                ftp.client.retrieveList(null, list, ftp.maxContentLength, ftp.parser);        this.content = list2html(list, path, "/".equals(path) ? false : true);        this.headers.set(Response.CONTENT_LENGTH, Integer.valueOf(this.content.length).toString());        this.headers.set(Response.CONTENT_TYPE, "text/html");                                                                this.code = 200;    } catch (FtpExceptionControlClosedByForcedDataClose e) {                if ((ftp.followTalk) && (Ftp.LOG.isInfoEnabled())) {            Ftp.LOG.info("delete client because server cut off control channel: " + e);        }        ftp.client = null;        this.content = list2html(list, path, "/".equals(path) ? false : true);        this.headers.set(Response.CONTENT_LENGTH, Integer.valueOf(this.content.length).toString());        this.headers.set(Response.CONTENT_TYPE, "text/html");                                                                this.code = 200;    } catch (FtpExceptionUnknownForcedDataClose e) {                if (Ftp.LOG.isWarnEnabled()) {            Ftp.LOG.warn("Unrecognized reply after forced close of data channel. " + "If this is acceptable, please modify Client.java accordingly. " + e);        }                this.code = 400;    } catch (FtpExceptionCanNotHaveDataConnection e) {        if (Ftp.LOG.isWarnEnabled()) {            Ftp.LOG.warn("" + e);        }                this.code = 500;    }}
b03b008afea4ec8ecad95977a4490882e0a705164c4c79f093602355c7b2fff7
list2html
private byte[] list2html(List<FTPFile> list, String path, boolean includeDotDot)
{            StringBuffer x = new StringBuffer("<html><head>");    x.append("<title>Index of " + path + "</title></head>\n");    x.append("<body><h1>Index of " + path + "</h1><pre>\n");    if (includeDotDot) {        x.append("<a href='../'>../</a>\t-\t-\t-\n");    }    for (int i = 0; i < list.size(); i++) {        FTPFile f = (FTPFile) list.get(i);        String name = f.getName();        String time = HttpDateFormat.toString(f.getTimestamp());        if (f.isDirectory()) {                        if (name.equals(".") || name.equals(".."))                continue;            x.append("<a href='" + name + "/" + "'>" + name + "/</a>\t");            x.append(time + "\t-\n");        } else if (f.isFile()) {            x.append("<a href='" + name + "'>" + name + "</a>\t");            x.append(time + "\t" + f.getSize() + "\n");        } else {                        }    }    x.append("</pre></body></html>\n");    return new String(x).getBytes();}
484c381fc4cc9b8db446f6469b3c59712133582565c263d2de7d862a9904ae30
getRobotRulesSet
public BaseRobotRules getRobotRulesSet(Protocol ftp, URL url, List<Content> robotsTxtContent)
{        String protocol = url.getProtocol().toLowerCase();            String host = url.getHost().toLowerCase();    if (LOG.isTraceEnabled() && isWhiteListed(url)) {        LOG.trace("Ignoring robots.txt (host is whitelisted) for URL: {}", url);    }    BaseRobotRules robotRules = CACHE.get(protocol + ":" + host);    if (robotRules != null) {                return robotRules;    } else if (LOG.isTraceEnabled()) {        LOG.trace("cache miss " + url);    }    boolean cacheRule = true;    if (isWhiteListed(url)) {                        robotRules = EMPTY_RULES;        LOG.info("Whitelisted host found for: {}", url);        LOG.info("Ignoring robots.txt for all URLs from whitelisted host: {}", host);    } else {        try {            Text robotsUrl = new Text(new URL(url, "/robots.txt").toString());            ProtocolOutput output = ((Ftp) ftp).getProtocolOutput(robotsUrl, new CrawlDatum());            ProtocolStatus status = output.getStatus();            if (robotsTxtContent != null) {                robotsTxtContent.add(output.getContent());            }            if (status.getCode() == ProtocolStatus.SUCCESS) {                robotRules = parseRules(url.toString(), output.getContent().getContent(), CONTENT_TYPE, agentNames);            } else {                                robotRules = EMPTY_RULES;            }        } catch (Throwable t) {            if (LOG.isInfoEnabled()) {                LOG.info("Couldn't get robots.txt for " + url + ": " + t.toString());            }                        cacheRule = false;            robotRules = EMPTY_RULES;        }    }    if (cacheRule)                CACHE.put(protocol + ":" + host, robotRules);    return robotRules;}
482b0292a0d93deac0bffa2d113f853f9f3b106f6a63081693b8ca697c7916f5
protocolCommandSent
public void protocolCommandSent(ProtocolCommandEvent event)
{    try {        __logIt(event);    } catch (IOException e) {        if (__logger.isInfoEnabled()) {            __logger.info("PrintCommandListener.protocolCommandSent(): " + e);        }    }}
b0ec5e9b9649bf8188cf1fc3406d4aea517293f1f11b2f6046aafff0ea370154
protocolReplyReceived
public void protocolReplyReceived(ProtocolCommandEvent event)
{    try {        __logIt(event);    } catch (IOException e) {        if (__logger.isInfoEnabled()) {            __logger.info("PrintCommandListener.protocolReplyReceived(): " + e);        }    }}
ae3eeef247a8e17fff54ffcef83ff3fc795f7e6d3c43c04db4710f031459f07d
__logIt
private void __logIt(ProtocolCommandEvent event) throws IOException
{    if (!__logger.isInfoEnabled()) {        return;    }    BufferedReader br = new BufferedReader(new StringReader(event.getMessage()));    String line;    while ((line = br.readLine()) != null) {        __logger.info("ftp> " + line);    }}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    super.setConf(conf);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    Http http = new Http();    http.setConf(NutchConfiguration.create());    main(http, args);}
b35242aa38e575dfb481f69bc8621016588a0ae4d4549f6af2ad46cd6e35d66c
getResponse
protected Response getResponse(URL url, CrawlDatum datum, boolean redirect) throws ProtocolException, IOException
{    return new HttpResponse(this, url, datum);}
df2bf56d298a90d42d37e21b66baa5616d58f08e28d08ed47d7798ed099513ef
getUrl
public URL getUrl()
{    return url;}
871172d34cf47bd1ccc8d8f81877fbf834289fcf345350e529b8b4e7a6708c5d
getCode
public int getCode()
{    return code;}
ce222e9e26ff92f109221120401e746a4137a63055fa3f4c459b71bc3b9a3f7b
getHeader
public String getHeader(String name)
{    return headers.get(name);}
8b40d561b36a77010d6a82801e7a4dd0cd137133c937dae97d3f2dd0467b5798
getHeaders
public Metadata getHeaders()
{    return headers;}
a724d7d22eec9af58dc1baab31eb2f9394c370706fcded02b6d254fcd56fd2b9
getContent
public byte[] getContent()
{    return content;}
255a710315243e2d10afaf1488a3d1d0019683e3586c05cc6333b6519775eeff
readContentFromHtmlUnit
private void readContentFromHtmlUnit(URL url) throws IOException
{    String page = HtmlUnitWebDriver.getHtmlPage(url.toString(), conf);    content = page.getBytes("UTF-8");}
c9cc574390287150720e138ce766555f29672a2c40ec30b53f06f096eb8f3abb
readPlainContent
private void readPlainContent(InputStream in) throws HttpException, IOException
{        int contentLength = Integer.MAX_VALUE;    String contentLengthString = headers.get(Response.CONTENT_LENGTH);    if (contentLengthString != null) {        contentLengthString = contentLengthString.trim();        try {            if (!contentLengthString.isEmpty())                contentLength = Integer.parseInt(contentLengthString);        } catch (NumberFormatException e) {            throw new HttpException("bad content length: " + contentLengthString);        }    }    if (http.getMaxContent() >= 0 && contentLength > http.getMaxContent())                        contentLength = http.getMaxContent();    ByteArrayOutputStream out = new ByteArrayOutputStream(Http.BUFFER_SIZE);    byte[] bytes = new byte[Http.BUFFER_SIZE];    int length = 0;        if (contentLength == 0) {        content = new byte[0];        return;    }        int i = in.read(bytes);    while (i != -1) {        out.write(bytes, 0, i);        length += i;        if (length >= contentLength) {            break;        }        if ((length + Http.BUFFER_SIZE) > contentLength) {                                    i = in.read(bytes, 0, (contentLength - length));        } else {            i = in.read(bytes);        }    }    content = out.toByteArray();}
36908f965e0f82390469f86dc4377cd6416a02bfcdc25050198e3959202b3f9d
readChunkedContent
private void readChunkedContent(PushbackInputStream in, StringBuffer line) throws HttpException, IOException
{    boolean doneChunks = false;    int contentBytesRead = 0;    byte[] bytes = new byte[Http.BUFFER_SIZE];    ByteArrayOutputStream out = new ByteArrayOutputStream(Http.BUFFER_SIZE);    while (!doneChunks) {        if (Http.LOG.isTraceEnabled()) {            Http.LOG.trace("Http: starting chunk");        }        readLine(in, line, false);        String chunkLenStr;                        int pos = line.indexOf(";");        if (pos < 0) {            chunkLenStr = line.toString();        } else {            chunkLenStr = line.substring(0, pos);                        }        chunkLenStr = chunkLenStr.trim();        int chunkLen;        try {            chunkLen = Integer.parseInt(chunkLenStr, 16);        } catch (NumberFormatException e) {            throw new HttpException("bad chunk length: " + line.toString());        }        if (chunkLen == 0) {            doneChunks = true;            break;        }        if (http.getMaxContent() >= 0 && (contentBytesRead + chunkLen) > http.getMaxContent())            chunkLen = http.getMaxContent() - contentBytesRead;                int chunkBytesRead = 0;        while (chunkBytesRead < chunkLen) {            int toRead = (chunkLen - chunkBytesRead) < Http.BUFFER_SIZE ? (chunkLen - chunkBytesRead) : Http.BUFFER_SIZE;            int len = in.read(bytes, 0, toRead);            if (len == -1)                throw new HttpException("chunk eof after " + contentBytesRead + " bytes in successful chunks" + " and " + chunkBytesRead + " in current chunk");                                                            out.write(bytes, 0, len);            chunkBytesRead += len;        }        readLine(in, line, false);    }    if (!doneChunks) {        if (contentBytesRead != http.getMaxContent())            throw new HttpException("chunk eof: !doneChunk && didn't max out");        return;    }    content = out.toByteArray();    parseHeaders(in, line, null);}
3ce8640c95c70b477e400e1c17b71862a7e7b9a9f87e1d79fd1f3ffa92a04d10
parseStatusLine
private int parseStatusLine(PushbackInputStream in, StringBuffer line) throws IOException, HttpException
{    readLine(in, line, false);    int codeStart = line.indexOf(" ");    int codeEnd = line.indexOf(" ", codeStart + 1);        if (codeEnd == -1)        codeEnd = line.length();    int code;    try {        code = Integer.parseInt(line.substring(codeStart + 1, codeEnd));    } catch (NumberFormatException e) {        throw new HttpException("bad status line '" + line + "': " + e.getMessage(), e);    }    return code;}
86a618b2c2d0d7a7d3c22390452b5e531c550e370e4dd8742aadbdf5417b4f18
processHeaderLine
private void processHeaderLine(StringBuffer line) throws IOException, HttpException
{        int colonIndex = line.indexOf(":");    if (colonIndex == -1) {        int i;        for (i = 0; i < line.length(); i++) if (!Character.isWhitespace(line.charAt(i)))            break;        if (i == line.length())            return;        throw new HttpException("No colon in header:" + line);    }    String key = line.substring(0, colonIndex);        int valueStart = colonIndex + 1;    while (valueStart < line.length()) {        int c = line.charAt(valueStart);        if (c != ' ' && c != '\t')            break;        valueStart++;    }    String value = line.substring(valueStart);    headers.set(key, value);}
802c11379597b7241067d8fa7962d06b8676dc75a95dee263318388c78e77da5
parseHeaders
private void parseHeaders(PushbackInputStream in, StringBuffer line, StringBuffer httpHeaders) throws IOException, HttpException
{    while (readLine(in, line, true) != 0) {        if (httpHeaders != null)            httpHeaders.append(line).append("\n");                int pos;        if (((pos = line.indexOf("<!DOCTYPE")) != -1) || ((pos = line.indexOf("<HTML")) != -1) || ((pos = line.indexOf("<html")) != -1)) {            in.unread(line.substring(pos).getBytes("UTF-8"));            line.setLength(pos);            try {                                                                                                processHeaderLine(line);            } catch (Exception e) {                                Http.LOG.warn("Error: ", e);            }            return;        }        processHeaderLine(line);    }}
0870e5acde4a84220f2c7143dc5ba958973d75c86a409c1d6bbbb6c2f2e9f9a5
readLine
private static int readLine(PushbackInputStream in, StringBuffer line, boolean allowContinuedLine) throws IOException
{    line.setLength(0);    for (int c = in.read(); c != -1; c = in.read()) {        switch(c) {            case '\r':                if (peek(in) == '\n') {                    in.read();                }            case '\n':                if (line.length() > 0) {                                        if (allowContinuedLine)                        switch(peek(in)) {                            case ' ':                            case                             '\t':                                in.read();                                continue;                        }                }                                return line.length();            default:                line.append((char) c);        }    }    throw new EOFException();}
f40ae415133d16abf273b373afcf6737d1edbe6d4fe5565c6d453a7d720eed12
peek
private static int peek(PushbackInputStream in) throws IOException
{    int value = in.read();    in.unread(value);    return value;}
c7e0930264ee5c9811fbd0cf62a8b665e7746361bef6eefe34c59238b7d914ad
isClientTrusted
public boolean isClientTrusted(X509Certificate[] certificates)
{    return true;}
df2156156d96e464b386cf835464d69c34726e5de6ad0ab8a6bcd98c0e515f24
isServerTrusted
public boolean isServerTrusted(X509Certificate[] certificates)
{    return true;}
b516c58bc22bde695ccdef782f17985d051ddc0b89329e35483cf2a3a576c7fe
getAcceptedIssuers
public X509Certificate[] getAcceptedIssuers()
{    return this.standardTrustManager.getAcceptedIssuers();}
af2c4a17d57a9f82f9135d33a8e00fd4e77980384275527f6e96f7f9879193f7
checkClientTrusted
public void checkClientTrusted(X509Certificate[] arg0, String arg1) throws CertificateException
{}
768180d0b6748eb565603ec371a30eb020a3485b96b98bbd642499b348c22bed
checkServerTrusted
public void checkServerTrusted(X509Certificate[] arg0, String arg1) throws CertificateException
{}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    super.setConf(conf);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    Http http = new Http();    http.setConf(NutchConfiguration.create());    main(http, args);}
b35242aa38e575dfb481f69bc8621016588a0ae4d4549f6af2ad46cd6e35d66c
getResponse
protected Response getResponse(URL url, CrawlDatum datum, boolean redirect) throws ProtocolException, IOException
{    return new HttpResponse(this, url, datum);}
df2bf56d298a90d42d37e21b66baa5616d58f08e28d08ed47d7798ed099513ef
getUrl
public URL getUrl()
{    return url;}
871172d34cf47bd1ccc8d8f81877fbf834289fcf345350e529b8b4e7a6708c5d
getCode
public int getCode()
{    return code;}
ce222e9e26ff92f109221120401e746a4137a63055fa3f4c459b71bc3b9a3f7b
getHeader
public String getHeader(String name)
{    return headers.get(name);}
8b40d561b36a77010d6a82801e7a4dd0cd137133c937dae97d3f2dd0467b5798
getHeaders
public Metadata getHeaders()
{    return headers;}
a724d7d22eec9af58dc1baab31eb2f9394c370706fcded02b6d254fcd56fd2b9
getContent
public byte[] getContent()
{    return content;}
1190b9eabb4d069b0405f7dd368c38889057b2e08f7d181e75b1bd5c6c83e00d
getSSLSocket
private SSLSocket getSSLSocket(Socket socket, String sockHost, int sockPort) throws Exception
{    SSLSocketFactory factory;    if (http.isTlsCheckCertificates()) {        factory = (SSLSocketFactory) SSLSocketFactory.getDefault();    } else {        SSLContext sslContext = SSLContext.getInstance("TLS");        sslContext.init(null, new TrustManager[] { new DummyX509TrustManager(null) }, null);        factory = sslContext.getSocketFactory();    }    SSLSocket sslsocket = (SSLSocket) factory.createSocket(socket, sockHost, sockPort, true);    sslsocket.setUseClientMode(true);        Set<String> protocols = new HashSet<String>(Arrays.asList(sslsocket.getSupportedProtocols()));    Set<String> ciphers = new HashSet<String>(Arrays.asList(sslsocket.getSupportedCipherSuites()));        protocols.retainAll(http.getTlsPreferredProtocols());    ciphers.retainAll(http.getTlsPreferredCipherSuites());    sslsocket.setEnabledProtocols(protocols.toArray(new String[protocols.size()]));    sslsocket.setEnabledCipherSuites(ciphers.toArray(new String[ciphers.size()]));    return sslsocket;}
c9cc574390287150720e138ce766555f29672a2c40ec30b53f06f096eb8f3abb
readPlainContent
private void readPlainContent(InputStream in) throws HttpException, IOException
{        int contentLength = Integer.MAX_VALUE;    String contentLengthString = headers.get(Response.CONTENT_LENGTH);    if (contentLengthString != null) {        contentLengthString = contentLengthString.trim();        try {            if (!contentLengthString.isEmpty()) {                contentLength = Integer.parseInt(contentLengthString);            }        } catch (NumberFormatException e) {            Http.LOG.warn("bad content length: {}", contentLengthString);        }    }    if (http.getMaxContent() >= 0 && contentLength > http.getMaxContent()) {                contentLength = http.getMaxContent();    }    ByteArrayOutputStream out = new ByteArrayOutputStream(Http.BUFFER_SIZE);    byte[] bytes = new byte[Http.BUFFER_SIZE];    int length = 0;        if (contentLength == 0) {        content = new byte[0];        return;    }        int i = in.read(bytes);    while (i != -1) {        out.write(bytes, 0, i);        length += i;        if (length >= contentLength) {            break;        }        if ((length + Http.BUFFER_SIZE) > contentLength) {                                    i = in.read(bytes, 0, (contentLength - length));        } else {            i = in.read(bytes);        }    }    content = out.toByteArray();}
36908f965e0f82390469f86dc4377cd6416a02bfcdc25050198e3959202b3f9d
readChunkedContent
private void readChunkedContent(PushbackInputStream in, StringBuffer line) throws HttpException, IOException
{    boolean doneChunks = false;    int contentBytesRead = 0;    byte[] bytes = new byte[Http.BUFFER_SIZE];    ByteArrayOutputStream out = new ByteArrayOutputStream(Http.BUFFER_SIZE);    while (true) {        if (Http.LOG.isTraceEnabled()) {            Http.LOG.trace("Http: starting chunk");        }        readLine(in, line, false);        String chunkLenStr;                        int pos = line.indexOf(";");        if (pos < 0) {            chunkLenStr = line.toString();        } else {            chunkLenStr = line.substring(0, pos);                        }        chunkLenStr = chunkLenStr.trim();        int chunkLen;        try {            chunkLen = Integer.parseInt(chunkLenStr, 16);        } catch (NumberFormatException e) {            throw new HttpException("bad chunk length: " + line.toString());        }        if (chunkLen == 0) {            doneChunks = true;            break;        }        if (http.getMaxContent() >= 0 && (contentBytesRead + chunkLen) > http.getMaxContent()) {                        chunkLen = http.getMaxContent() - contentBytesRead;        }                int chunkBytesRead = 0;        while (chunkBytesRead < chunkLen) {            int toRead = (chunkLen - chunkBytesRead) < Http.BUFFER_SIZE ? (chunkLen - chunkBytesRead) : Http.BUFFER_SIZE;            int len = in.read(bytes, 0, toRead);            if (len == -1)                throw new HttpException("chunk eof after " + contentBytesRead + " bytes in successful chunks" + " and " + chunkBytesRead + " in current chunk");                                                            out.write(bytes, 0, len);            chunkBytesRead += len;        }        contentBytesRead += chunkBytesRead;        if (http.getMaxContent() >= 0 && contentBytesRead >= http.getMaxContent()) {            Http.LOG.trace("Http: content limit reached");            break;        }        readLine(in, line, false);    }    content = out.toByteArray();    if (!doneChunks) {                if (contentBytesRead != http.getMaxContent())            throw new HttpException("chunk eof: !doneChunk && didn't max out");        return;    }        parseHeaders(in, line, null);}
8d408d59ea9d704881060a86e283d1b58a323f3f4c6c15bfd130ceee8c7e8518
parseStatusLine
private int parseStatusLine(PushbackInputStream in, StringBuffer line, StringBuffer lineSeparator) throws IOException, HttpException
{    readLine(in, line, false, 2048, lineSeparator);    int codeStart = line.indexOf(" ");    int codeEnd;    int lineLength = line.length();        for (codeEnd = codeStart + 1; codeEnd < lineLength; codeEnd++) {        if (!Character.isDigit(line.charAt(codeEnd)))            break;            }    try {        return Integer.parseInt(line.substring(codeStart + 1, codeEnd));    } catch (NumberFormatException e) {        throw new HttpException("Bad status line, no HTTP response code: " + line, e);    }}
3c64f2a54239843d7016ee10178a9399190b65f3c1e96ced6887f6b96c1a3c7a
processHeaderLine
private void processHeaderLine(StringBuffer line)
{        int colonIndex = line.indexOf(":");    if (colonIndex == -1) {        Http.LOG.info("Ignoring a header line without a colon: '{}'", line);        return;    }    String key = line.substring(0, colonIndex);        int valueStart = colonIndex + 1;    while (valueStart < line.length()) {        int c = line.charAt(valueStart);        if (c != ' ' && c != '\t')            break;        valueStart++;    }    String value = line.substring(valueStart);    headers.set(key, value);}
802c11379597b7241067d8fa7962d06b8676dc75a95dee263318388c78e77da5
parseHeaders
private void parseHeaders(PushbackInputStream in, StringBuffer line, StringBuffer httpHeaders) throws IOException, HttpException
{    while (readLine(in, line, true) != 0) {        if (httpHeaders != null)            httpHeaders.append(line).append("\r\n");                int pos;        if (((pos = line.indexOf("<!DOCTYPE")) != -1) || ((pos = line.indexOf("<HTML")) != -1) || ((pos = line.indexOf("<html")) != -1)) {            in.unread(line.substring(pos).getBytes(StandardCharsets.ISO_8859_1));            line.setLength(pos);            try {                                                                                                processHeaderLine(line);            } catch (Exception e) {                                Http.LOG.warn("Error: ", e);            }            return;        }        processHeaderLine(line);    }}
0870e5acde4a84220f2c7143dc5ba958973d75c86a409c1d6bbbb6c2f2e9f9a5
readLine
private static int readLine(PushbackInputStream in, StringBuffer line, boolean allowContinuedLine) throws IOException
{    return readLine(in, line, allowContinuedLine, Http.BUFFER_SIZE, null);}
5b0bc144a5772f083d54d62e1d481d26aea78bf9b9f60202c5a041737405380c
readLine
private static int readLine(PushbackInputStream in, StringBuffer line, boolean allowContinuedLine, int maxBytes, StringBuffer lineSeparator) throws IOException
{    line.setLength(0);    int bytesRead = 0;    for (int c = in.read(); c != -1 && bytesRead < maxBytes; c = in.read(), bytesRead++) {        switch(c) {            case '\r':                if (lineSeparator != null) {                    lineSeparator.append((char) c);                }                if (peek(in) == '\n') {                    in.read();                    if (lineSeparator != null) {                        lineSeparator.append((char) c);                    }                }                        case '\n':                if (lineSeparator != null) {                    lineSeparator.append((char) c);                }                if (line.length() > 0) {                                        if (allowContinuedLine)                        switch(peek(in)) {                            case ' ':                            case                             '\t':                                in.read();                                if (lineSeparator != null) {                                    lineSeparator.replace(0, lineSeparator.length(), "");                                }                                continue;                        }                }                                return line.length();            default:                line.append((char) c);        }    }    if (bytesRead >= maxBytes) {        throw new IOException("Line exceeds max. buffer size: " + line.substring(0, Math.min(32, line.length())));    }    return line.length();}
f40ae415133d16abf273b373afcf6737d1edbe6d4fe5565c6d453a7d720eed12
peek
private static int peek(PushbackInputStream in) throws IOException
{    int value = in.read();    in.unread(value);    return value;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    conf = new Configuration();    conf.addResource("nutch-default.xml");    conf.addResource("nutch-site-test.xml");    conf.setBoolean("store.http.headers", true);    http = new Http();    http.setConf(conf);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    server.close();}
add4f91ef4a4e78c8cc7324404804e2959c54693110a1e2f65431b1ee8bc1c84
runServer
private void runServer(int port, String response) throws Exception
{    server = new ServerSocket();    server.bind(new InetSocketAddress("127.0.0.1", port));    Pattern requestPattern = Pattern.compile("(?i)^GET\\s+(\\S+)");    while (true) {        LOG.info("Listening on port {}", port);        Socket socket = server.accept();        LOG.info("Connection received");        try (BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8));            PrintWriter out = new PrintWriter(new OutputStreamWriter(socket.getOutputStream(), StandardCharsets.UTF_8), true)) {            String line;            while ((line = in.readLine()) != null) {                LOG.info("Request: {}", line);                if (line.trim().isEmpty()) {                    break;                }                Matcher m = requestPattern.matcher(line);                if (m.find()) {                    LOG.info("Requested {}", m.group(1));                    if (!m.group(1).startsWith("/")) {                        response = "HTTP/1.1 400 Bad request\r\n\r\n";                    }                }            }            LOG.info("Response: {}", response.substring(0, Math.min(1024, response.length())));            out.print(response);        } catch (Exception e) {            LOG.warn("Exception in test server:", e);        }    }}
458c12a767c1312414137a7b3165782ade012bd111529740d0532fbd8d65062c
launchServer
private void launchServer(String response) throws InterruptedException
{    Thread serverThread = new Thread(() -> {        try {            runServer(port, response);        } catch (Exception e) {            LOG.warn("Test server died:", e);        }    });    serverThread.start();    Thread.sleep(50);}
7507ccbc6f10541cbb10b361d75022525a8387d5dcf0e87523e031ac7f159e00
fetchPage
private Response fetchPage(String page, int expectedCode) throws Exception
{    URL url = new URL("http", "127.0.0.1", port, page);    LOG.info("Fetching {}", url);    CrawlDatum crawlDatum = new CrawlDatum();    Response response = http.getResponse(url, crawlDatum, true);    assertEquals("HTTP Status Code for " + url, expectedCode, response.getCode());    return response;}
d5584e90e8678683125d1fb28cdc3507ec3d874812c98990ce50f6efda100dc6
testBadHttpServer
public void testBadHttpServer() throws Exception
{    setUp();            launchServer(responseHeader + simpleContent);    fetchPage("/", 200);}
5af1c93259e8fc7590de2cc6e856bed5876aaecfa3cf6345d6f2b50c0bd34c31
testRequestNotStartingWithSlash
public void testRequestNotStartingWithSlash() throws Exception
{    setUp();    launchServer(responseHeader + simpleContent);    fetchPage("?171", 200);}
63767307e1827b5567f1eed8c7411a9be3df56019a0121baba834f667dffaff2
testContentLengthNotANumber
public void testContentLengthNotANumber() throws Exception
{    setUp();    launchServer(responseHeader + "Content-Length: thousand\r\n" + simpleContent);    fetchPage("/", 200);}
d42792c7686b3df74f7bdf102d9f0f74c38607f0522c671881e0a9c153903d7f
testHeaderWithColon
public void testHeaderWithColon() throws Exception
{    setUp();    launchServer("HTTP/1.1 200: OK\r\n" + simpleContent);    fetchPage("/", 200);}
e229aeeb01bde4e2b3f330146ed880a119112196d675f331c6bc2a2a2713457e
testHeaderSpellChecking
public void testHeaderSpellChecking() throws Exception
{    setUp();    launchServer(responseHeader + "Client-Transfer-Encoding: chunked\r\n" + simpleContent);    fetchPage("/", 200);}
3faeb5360fcf752375fcbc1777d71c88cbc9c1c51f002ad7c840545758ace63d
testIgnoreErrorInRedirectPayload
public void testIgnoreErrorInRedirectPayload() throws Exception
{    setUp();    launchServer("HTTP/1.1 302 Found\r\nLocation: http://example.com/\r\n" + "Transfer-Encoding: chunked\r\n\r\nNot a valid chunk.");    Response fetched = fetchPage("/", 302);    assertNotNull("No redirect Location.", fetched.getHeader("Location"));    assertEquals("Wrong redirect Location.", "http://example.com/", fetched.getHeader("Location"));}
876913c7e2f37fa1bb456a3961144792970ffe3b4ad1365044d1121f4681aed5
testNoStatusLine
public void testNoStatusLine() throws Exception
{    setUp();    String text = "This is a text containing non-ASCII characters: \u00e4\u00f6\u00fc\u00df";    launchServer(text);    Response fetched = fetchPage("/", 200);    assertEquals("Wrong text returned for response with no status line.", text, new String(fetched.getContent(), StandardCharsets.UTF_8));    server.close();    text = "<!DOCTYPE html>\n<html>\n<head>\n" + "<title>Testing no HTTP header </title>\n" + "<meta charset=\"utf-8\">\n" + "</head>\n<body>This is a text containing non-ASCII characters:" + "\u00e4\u00f6\u00fc\u00df</body>\n</html";    launchServer(text);    fetched = fetchPage("/", 200);    assertEquals("Wrong text returned for response with no status line.", text, new String(fetched.getContent(), StandardCharsets.UTF_8));}
4b0945080f03ab80ee206368de14a69dc199f777dcd3f464d3b4acd6a95988a4
testMultiLineHeader
public void testMultiLineHeader() throws Exception
{    setUp();    launchServer(responseHeader + "Set-Cookie: UserID=JohnDoe;\r\n  Max-Age=3600;\r\n  Version=1\r\n" + simpleContent);    Response fetched = fetchPage("/", 200);    LOG.info("Headers: {}", fetched.getHeaders());    assertNotNull("Failed to set multi-line \"Set-Cookie\" header.", fetched.getHeader("Set-Cookie"));    assertTrue("Failed to set multi-line \"Set-Cookie\" header.", fetched.getHeader("Set-Cookie").contains("Version=1"));}
eb95505658c242c5e574e8c95255632f8e33b557d7e4fd3cc69baf7e7e798c4b
testOverlongHeader
public void testOverlongHeader() throws Exception
{    setUp();    StringBuilder response = new StringBuilder();    response.append(responseHeader);    for (int i = 0; i < 80; i++) {        response.append("X-Custom-Header-");        for (int j = 0; j < 10000; j++) {            response.append('x');        }        response.append(": hello\r\n");    }    response.append("\r\n" + simpleContent);    launchServer(response.toString());        fetchPage("/", 200);}
ee10425b12e299793e81823f5bb864de10c552e4e44c120a5c1c90e0bca619bc
testChunkedContent
public void testChunkedContent() throws Exception
{    setUp();    StringBuilder response = new StringBuilder();    response.append(responseHeader);    response.append("Content-Type: text/html\r\n");    response.append("Transfer-Encoding: chunked\r\n");        for (int i = 0; i < 80; i++) {        response.append(String.format("\r\n400\r\n%02x\r\n", i));        for (int j = 0; j < 1012; j++) {            response.append('x');        }        response.append(String.format("\r\n%02x\r\n", i));        response.append("\r\n");    }    response.append("\r\n0\r\n\r\n");    launchServer(response.toString());    Response fetched = fetchPage("/", 200);    assertEquals("Chunked content not truncated according to http.content.limit", 65536, fetched.getContent().length);}
1ee0b82c097cdf4275eef0057ea8259c48e94adae1eebb4cf281e500a08ec863
setUp
public void setUp(boolean redirection) throws Exception
{    conf = new Configuration();    conf.addResource("nutch-default.xml");    conf.addResource("nutch-site-test.xml");    http = new Http();    http.setConf(conf);    server = new Server();    if (redirection) {        root = new Context(server, "/redirection", Context.SESSIONS);        root.setAttribute("newContextURL", "/redirect");    } else {        root = new Context(server, "/", Context.SESSIONS);    }    ServletHolder sh = new ServletHolder(org.apache.jasper.servlet.JspServlet.class);    root.addServlet(sh, "*.jsp");    root.setResourceBase(RES_DIR);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    server.stop();}
61fc96ab978515f78569442c9f92c2f2a5c8832dffc5e3201e89b3273cfb6f62
testStatusCode
public void testStatusCode() throws Exception
{    startServer(47504, false);    fetchPage("/basic-http.jsp", 200);    fetchPage("/redirect301.jsp", 301);    fetchPage("/redirect302.jsp", 302);    fetchPage("/nonexists.html", 404);    fetchPage("/brokenpage.jsp", 500);}
d69e81bc1b3c8bd7e2e4114bedb81a82a487f4410997314f0ae9e2c1074d99f8
testRedirectionJetty
public void testRedirectionJetty() throws Exception
{        startServer(47503, true);    fetchPage("/redirection", 302);}
110c7dcaf27495b42a37a80189b025ff968cd2988693b9f0a174e8c90a53e2e1
startServer
private void startServer(int portno, boolean redirection) throws Exception
{    port = portno;    setUp(redirection);    SelectChannelConnector connector = new SelectChannelConnector();    connector.setHost("127.0.0.1");    connector.setPort(port);    server.addConnector(connector);    server.start();}
912a628650a678f2d837edcc771fef893ec90b45488890c1ffae328cdd0167a8
fetchPage
private void fetchPage(String page, int expectedCode) throws Exception
{    URL url = new URL("http", "127.0.0.1", port, page);    CrawlDatum crawlDatum = new CrawlDatum();    Response response = http.getResponse(url, crawlDatum, true);    ProtocolOutput out = http.getProtocolOutput(new Text(url.toString()), crawlDatum);    Content content = out.getContent();    assertEquals("HTTP Status Code for " + url, expectedCode, response.getCode());    if (page.compareTo("/nonexists.html") != 0 && page.compareTo("/brokenpage.jsp") != 0 && page.compareTo("/redirection") != 0) {        assertEquals("ContentType " + url, "text/html", content.getContentType());    }}
f4be31e257394b8283284f3f55ade9ca542b53be210a2db83062ad1e6de5d2ab
createEasySSLContext
private static SSLContext createEasySSLContext()
{    try {        SSLContext context = SSLContext.getInstance("SSL");        context.init(null, new TrustManager[] { new DummyX509TrustManager(null) }, null);        return context;    } catch (Exception e) {        if (LOG.isErrorEnabled()) {            LOG.error(e.getMessage(), e);        }        throw new HttpClientError(e.toString());    }}
4ef4a5083cde6c159bfdaa8e224938cc32e7ceee4240e8376073b256a3ab0a57
getSSLContext
private SSLContext getSSLContext()
{    if (this.sslcontext == null) {        this.sslcontext = createEasySSLContext();    }    return this.sslcontext;}
f6957fa394c389c3a54a55fea27f42ea73693017dec3956fed4dcf0a5b8a044b
createSocket
public Socket createSocket(String host, int port, InetAddress clientHost, int clientPort) throws IOException, UnknownHostException
{    return getSSLContext().getSocketFactory().createSocket(host, port, clientHost, clientPort);}
9c1cbe7c8b5838f9fd73893b358effa347ba923a0ac0e87bd1605c475d4ee8f2
createSocket
public Socket createSocket(final String host, final int port, final InetAddress localAddress, final int localPort, final HttpConnectionParams params) throws IOException, UnknownHostException, ConnectTimeoutException
{    if (params == null) {        throw new IllegalArgumentException("Parameters may not be null");    }    int timeout = params.getConnectionTimeout();    if (timeout == 0) {        return createSocket(host, port, localAddress, localPort);    } else {                return ControllerThreadSocketFactory.createSocket(this, host, port, localAddress, localPort, timeout);    }}
eefcb104d9dbd65d7b8cf63c8374decb2edcf126f13c436ba6039e74fad0189d
createSocket
public Socket createSocket(String host, int port) throws IOException, UnknownHostException
{    return getSSLContext().getSocketFactory().createSocket(host, port);}
bd12960a5aa5d4046c641ee0d56b1eff14716b9e5bfd048abf6a68688fe45696
createSocket
public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException
{    return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    return ((obj != null) && obj.getClass().equals(DummySSLProtocolSocketFactory.class));}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return DummySSLProtocolSocketFactory.class.hashCode();}
c7e0930264ee5c9811fbd0cf62a8b665e7746361bef6eefe34c59238b7d914ad
isClientTrusted
public boolean isClientTrusted(X509Certificate[] certificates)
{    return true;}
df2156156d96e464b386cf835464d69c34726e5de6ad0ab8a6bcd98c0e515f24
isServerTrusted
public boolean isServerTrusted(X509Certificate[] certificates)
{    return true;}
b516c58bc22bde695ccdef782f17985d051ddc0b89329e35483cf2a3a576c7fe
getAcceptedIssuers
public X509Certificate[] getAcceptedIssuers()
{    return this.standardTrustManager.getAcceptedIssuers();}
af2c4a17d57a9f82f9135d33a8e00fd4e77980384275527f6e96f7f9879193f7
checkClientTrusted
public void checkClientTrusted(X509Certificate[] arg0, String arg1) throws CertificateException
{}
768180d0b6748eb565603ec371a30eb020a3485b96b98bbd642499b348c22bed
checkServerTrusted
public void checkServerTrusted(X509Certificate[] arg0, String arg1) throws CertificateException
{}
8ba412f1790f7ae589c7def4b084986d64c3e9eb0b21dca44f70dfe40475395d
getClient
 static synchronized HttpClient getClient()
{    return client;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    super.setConf(conf);    Http.conf = conf;    this.maxThreadsTotal = conf.getInt("fetcher.threads.fetch", 10);    this.proxyUsername = conf.get("http.proxy.username", "");    this.proxyPassword = conf.get("http.proxy.password", "");    this.proxyRealm = conf.get("http.proxy.realm", "");    agentHost = conf.get("http.agent.host", "");    authFile = conf.get("http.auth.file", "");    configureClient();    try {        setCredentials();    } catch (Exception ex) {        if (LOG.isErrorEnabled()) {            LOG.error("Http ", ex);            LOG.error("Could not read " + authFile + " : " + ex.getMessage());        }    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    Http http = new Http();    http.setConf(NutchConfiguration.create());    main(http, args);}
b35242aa38e575dfb481f69bc8621016588a0ae4d4549f6af2ad46cd6e35d66c
getResponse
protected Response getResponse(URL url, CrawlDatum datum, boolean redirect) throws ProtocolException, IOException
{    resolveCredentials(url);    return new HttpResponse(this, url, datum, redirect);}
c6ec315be5a1588c8e7b504741e5706caf53f8d2c24814c5d9a97df6a84535a7
configureClient
private void configureClient()
{        ProtocolSocketFactory factory;    if (tlsCheckCertificate) {        factory = new SSLProtocolSocketFactory();    } else {        factory = new DummySSLProtocolSocketFactory();    }    Protocol https = new Protocol("https", factory, 443);    Protocol.registerProtocol("https", https);    HttpConnectionManagerParams params = connectionManager.getParams();    params.setConnectionTimeout(timeout);    params.setSoTimeout(timeout);    params.setSendBufferSize(BUFFER_SIZE);    params.setReceiveBufferSize(BUFFER_SIZE);                    params.setMaxTotalConnections(conf.getInt("mapreduce.tasktracker.map.tasks.maximum", 5) * conf.getInt("fetcher.threads.fetch", maxThreadsTotal));                params.setDefaultMaxConnectionsPerHost(conf.getInt("fetcher.threads.fetch", maxThreadsTotal));                client.getParams().setConnectionManagerTimeout(timeout);    HostConfiguration hostConf = client.getHostConfiguration();    ArrayList<Header> headers = new ArrayList<Header>();        if (!acceptLanguage.isEmpty()) {        headers.add(new Header("Accept-Language", acceptLanguage));    }    if (!acceptCharset.isEmpty()) {        headers.add(new Header("Accept-Charset", acceptCharset));    }    if (!accept.isEmpty()) {        headers.add(new Header("Accept", accept));    }        headers.add(new Header("Accept-Encoding", "x-gzip, gzip, deflate"));    hostConf.getParams().setParameter("http.default-headers", headers);        if (useProxy) {        hostConf.setProxy(proxyHost, proxyPort);        if (proxyUsername.length() > 0) {            AuthScope proxyAuthScope = getAuthScope(this.proxyHost, this.proxyPort, this.proxyRealm);            NTCredentials proxyCredentials = new NTCredentials(this.proxyUsername, this.proxyPassword, Http.agentHost, this.proxyRealm);            client.getState().setProxyCredentials(proxyAuthScope, proxyCredentials);        }    }}
bb38beadc75fb0c116cd0bd436d8374f2766d03cd3cea5b918f857a5f515cc82
setCredentials
private static synchronized void setCredentials() throws ParserConfigurationException, SAXException, IOException
{    if (authRulesRead)        return;        authRulesRead = true;    InputStream is = conf.getConfResourceAsInputStream(authFile);    if (is != null) {        Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(is);        Element rootElement = doc.getDocumentElement();        if (!"auth-configuration".equals(rootElement.getTagName())) {            if (LOG.isWarnEnabled())                LOG.warn("Bad auth conf file: root element <" + rootElement.getTagName() + "> found in " + authFile + " - must be <auth-configuration>");        }                NodeList credList = rootElement.getChildNodes();        for (int i = 0; i < credList.getLength(); i++) {            Node credNode = credList.item(i);            if (!(credNode instanceof Element))                continue;            Element credElement = (Element) credNode;            if (!"credentials".equals(credElement.getTagName())) {                if (LOG.isWarnEnabled())                    LOG.warn("Bad auth conf file: Element <" + credElement.getTagName() + "> not recognized in " + authFile + " - expected <credentials>");                continue;            }            String authMethod = credElement.getAttribute("authMethod");                        if (StringUtils.isNotBlank(authMethod)) {                formConfigurer = readFormAuthConfigurer(credElement, authMethod);                continue;            }            String username = credElement.getAttribute("username");            String password = credElement.getAttribute("password");                        NodeList scopeList = credElement.getChildNodes();            for (int j = 0; j < scopeList.getLength(); j++) {                Node scopeNode = scopeList.item(j);                if (!(scopeNode instanceof Element))                    continue;                Element scopeElement = (Element) scopeNode;                if ("default".equals(scopeElement.getTagName())) {                                        String realm = scopeElement.getAttribute("realm");                    String scheme = scopeElement.getAttribute("scheme");                                        defaultUsername = username;                    defaultPassword = password;                    defaultRealm = realm;                    defaultScheme = scheme;                    if (LOG.isTraceEnabled()) {                        LOG.trace("Credentials - username: " + username + "; set as default" + " for realm: " + realm + "; scheme: " + scheme);                    }                } else if ("authscope".equals(scopeElement.getTagName())) {                                        String host = scopeElement.getAttribute("host");                                        int port = -1;                    try {                        port = Integer.parseInt(scopeElement.getAttribute("port"));                    } catch (Exception ex) {                                        }                    String realm = scopeElement.getAttribute("realm");                    String scheme = scopeElement.getAttribute("scheme");                                        AuthScope authScope = getAuthScope(host, port, realm, scheme);                    NTCredentials credentials = new NTCredentials(username, password, agentHost, realm);                    client.getState().setCredentials(authScope, credentials);                    if (LOG.isTraceEnabled()) {                        LOG.trace("Credentials - username: " + username + "; set for AuthScope - " + "host: " + host + "; port: " + port + "; realm: " + realm + "; scheme: " + scheme);                    }                } else {                    if (LOG.isWarnEnabled())                        LOG.warn("Bad auth conf file: Element <" + scopeElement.getTagName() + "> not recognized in " + authFile + " - expected <authscope>");                }            }            is.close();        }    }}
b7e58e09c5afa0b12bdaa590a41460e39c10d6b125082ac42932ab071905aa43
readFormAuthConfigurer
private static HttpFormAuthConfigurer readFormAuthConfigurer(Element credElement, String authMethod)
{    if ("formAuth".equals(authMethod)) {        HttpFormAuthConfigurer formConfigurer = new HttpFormAuthConfigurer();        String str = credElement.getAttribute("loginUrl");        if (StringUtils.isNotBlank(str)) {            formConfigurer.setLoginUrl(str.trim());        } else {            throw new IllegalArgumentException("Must set loginUrl.");        }        str = credElement.getAttribute("loginFormId");        if (StringUtils.isNotBlank(str)) {            formConfigurer.setLoginFormId(str.trim());        } else {            throw new IllegalArgumentException("Must set loginFormId.");        }        str = credElement.getAttribute("loginRedirect");        if (StringUtils.isNotBlank(str)) {            formConfigurer.setLoginRedirect(Boolean.parseBoolean(str));        }        NodeList nodeList = credElement.getChildNodes();        for (int j = 0; j < nodeList.getLength(); j++) {            Node node = nodeList.item(j);            if (!(node instanceof Element))                continue;            Element element = (Element) node;            if ("loginPostData".equals(element.getTagName())) {                Map<String, String> loginPostData = new HashMap<String, String>();                NodeList childNodes = element.getChildNodes();                for (int k = 0; k < childNodes.getLength(); k++) {                    Node fieldNode = childNodes.item(k);                    if (!(fieldNode instanceof Element))                        continue;                    Element fieldElement = (Element) fieldNode;                    String name = fieldElement.getAttribute("name");                    String value = fieldElement.getAttribute("value");                    loginPostData.put(name, value);                }                formConfigurer.setLoginPostData(loginPostData);            } else if ("additionalPostHeaders".equals(element.getTagName())) {                Map<String, String> additionalPostHeaders = new HashMap<String, String>();                NodeList childNodes = element.getChildNodes();                for (int k = 0; k < childNodes.getLength(); k++) {                    Node fieldNode = childNodes.item(k);                    if (!(fieldNode instanceof Element))                        continue;                    Element fieldElement = (Element) fieldNode;                    String name = fieldElement.getAttribute("name");                    String value = fieldElement.getAttribute("value");                    additionalPostHeaders.put(name, value);                }                formConfigurer.setAdditionalPostHeaders(additionalPostHeaders);            } else if ("removedFormFields".equals(element.getTagName())) {                Set<String> removedFormFields = new HashSet<String>();                NodeList childNodes = element.getChildNodes();                for (int k = 0; k < childNodes.getLength(); k++) {                    Node fieldNode = childNodes.item(k);                    if (!(fieldNode instanceof Element))                        continue;                    Element fieldElement = (Element) fieldNode;                    String name = fieldElement.getAttribute("name");                    removedFormFields.add(name);                }                formConfigurer.setRemovedFormFields(removedFormFields);            } else if ("loginCookie".equals(element.getTagName())) {                                LOG.debug("start loginCookie");                NodeList childNodes = element.getChildNodes();                for (int k = 0; k < childNodes.getLength(); k++) {                    Node fieldNode = childNodes.item(k);                    if (!(fieldNode instanceof Element))                        continue;                    Element fieldElement = (Element) fieldNode;                    if ("policy".equals(fieldElement.getTagName())) {                        String policy = fieldElement.getTextContent();                        formConfigurer.setCookiePolicy(policy);                        LOG.debug("cookie policy is " + policy);                    }                }            }        }        return formConfigurer;    } else {        throw new IllegalArgumentException("Unsupported authMethod: " + authMethod);    }}
15e6d6ace45265d842988db77289c54173962826f10c91534adc083364398e3d
resolveCredentials
private void resolveCredentials(URL url)
{    if (formConfigurer != null) {        HttpFormAuthentication formAuther = new HttpFormAuthentication(formConfigurer, client, this);        try {            formAuther.login();        } catch (Exception e) {            throw new RuntimeException(e);        }        return;    }    if (defaultUsername != null && defaultUsername.length() > 0) {        int port = url.getPort();        if (port == -1) {            if ("https".equals(url.getProtocol()))                port = 443;            else                port = 80;        }        AuthScope scope = new AuthScope(url.getHost(), port);        if (client.getState().getCredentials(scope) != null) {            if (LOG.isTraceEnabled())                LOG.trace("Pre-configured credentials with scope - host: " + url.getHost() + "; port: " + port + "; found for url: " + url);                        return;        }        if (LOG.isTraceEnabled())            LOG.trace("Pre-configured credentials with scope -  host: " + url.getHost() + "; port: " + port + "; not found for url: " + url);        AuthScope serverAuthScope = getAuthScope(url.getHost(), port, defaultRealm, defaultScheme);        NTCredentials serverCredentials = new NTCredentials(defaultUsername, defaultPassword, agentHost, defaultRealm);        client.getState().setCredentials(serverAuthScope, serverCredentials);    }}
8b9692f081a297e85e06b534dd36d8e524d3569443dbb95e64548ae42de04ada
getAuthScope
private static AuthScope getAuthScope(String host, int port, String realm, String scheme)
{    if (host.length() == 0)        host = null;    if (port < 0)        port = -1;    if (realm.length() == 0)        realm = null;    if (scheme.length() == 0)        scheme = null;    return new AuthScope(host, port, realm, scheme);}
62d56d1755becee46d4330e9b7e9b5ce77a134b9cb51e1685b44e99e037907e0
getAuthScope
private static AuthScope getAuthScope(String host, int port, String realm)
{    return getAuthScope(host, port, realm, "");}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
bd65ee4e827b17374827c07746c16de2dd95bc56ebeb21da09a6af0e02dff87a
findAuthentication
public HttpAuthentication findAuthentication(Metadata header)
{    if (header == null)        return null;    try {        Collection<String> challenge = new ArrayList<String>();        challenge.add(header.get(WWW_AUTHENTICATE));        for (String challengeString : challenge) {            if (challengeString.equals("NTLM"))                challengeString = "Basic realm=techweb";            if (LOG.isTraceEnabled())                LOG.trace("Checking challengeString=" + challengeString);            HttpAuthentication auth = HttpBasicAuthentication.getAuthentication(challengeString, conf);            if (auth != null)                return auth;                }    } catch (Exception e) {        LOG.error("Error: ", e);    }    return null;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
d6a5347c131aab514f992e4e3de842e7020c8b7dd2f98f751c0baa5afb7d47af
getCredentials
public List<String> getCredentials()
{    return credentials;}
f1c45a4c4f150639a8cd469fed7c91e49bb2bc490a1fc61a7036b915aae5e0b2
getRealm
public String getRealm()
{    return realm;}
5eb3c9eb94d2e9994e66731898c48f9e041ea9041680e9f2a14eecdabfd01705
getAuthentication
public static HttpBasicAuthentication getAuthentication(String challenge, Configuration conf)
{    if (challenge == null)        return null;    Matcher basicMatcher = basic.matcher(challenge);    if (basicMatcher.matches()) {        String realm = basicMatcher.group(1);        Object auth = authMap.get(realm);        if (auth == null) {            HttpBasicAuthentication newAuth = null;            try {                newAuth = new HttpBasicAuthentication(realm, conf);            } catch (HttpAuthenticationException hae) {                if (LOG.isTraceEnabled()) {                    LOG.trace("HttpBasicAuthentication failed for " + challenge);                }            }            authMap.put(realm, newAuth);            return newAuth;        } else {            return (HttpBasicAuthentication) auth;        }    }    return null;}
3df83629e5395abcee6c2efd659d2bedf9e284c940ae913d836fe5b4afd62479
getBasicPattern
public static final Pattern getBasicPattern()
{    return basic;}
cb0891b38e24fc37882bf570cfeff6bc166c3e5807343721685dec0e20913579
getLoginUrl
public String getLoginUrl()
{    return loginUrl;}
91f263b6c1b85800baa383daf9be86bb5585abcc1f5958a35c71c52a73adbed8
setLoginUrl
public HttpFormAuthConfigurer setLoginUrl(String loginUrl)
{    this.loginUrl = loginUrl;    return this;}
e85b706141ba7dea81d45a04503c0cff45c8689a771818d69383a0e3cf0373b9
getLoginFormId
public String getLoginFormId()
{    return loginFormId;}
fb53df6b3efac94af323f713c1bc6fbaf0932aafb7e1c3bde2c74f538f65c79b
setLoginFormId
public HttpFormAuthConfigurer setLoginFormId(String loginForm)
{    this.loginFormId = loginForm;    return this;}
1e0cae7a6a5a8336972e49eccf51689de5076a870e74038bb1b92950acd3b07d
getLoginPostData
public Map<String, String> getLoginPostData()
{    return loginPostData == null ? new HashMap<String, String>() : loginPostData;}
9f585b7b3df5ef053da577120e81719f9f398406cff5e50bd95d47fc975ae4c3
setLoginPostData
public HttpFormAuthConfigurer setLoginPostData(Map<String, String> loginPostData)
{    this.loginPostData = loginPostData;    return this;}
c205bbea66eb86c1e563e806a9697e5bf6722365d50fa94a1798b2ab7c57a0b2
getAdditionalPostHeaders
public Map<String, String> getAdditionalPostHeaders()
{    return additionalPostHeaders == null ? new HashMap<String, String>() : additionalPostHeaders;}
e5dbf190cbae33f6be18f501cfa726c8af6614417439a8a0776c13d5f9e493df
setAdditionalPostHeaders
public HttpFormAuthConfigurer setAdditionalPostHeaders(Map<String, String> additionalPostHeaders)
{    this.additionalPostHeaders = additionalPostHeaders;    return this;}
c0fe87487de95294a7077bb705ce72d9a54ecf7cac77c1059cbfdc46330ec533
isLoginRedirect
public boolean isLoginRedirect()
{    return loginRedirect;}
a8a074bd62cbc0806bd34a0078c49ab14aa1144deb7f9077dc14156c5dfbf686
setLoginRedirect
public HttpFormAuthConfigurer setLoginRedirect(boolean redirect)
{    this.loginRedirect = redirect;    return this;}
55e98627756b32915920e91670d25f35b9071bf6e70433eb6a007bc579ee463e
getRemovedFormFields
public Set<String> getRemovedFormFields()
{    return removedFormFields == null ? new HashSet<String>() : removedFormFields;}
3cc9162bd8082d278adb9ab1ca3ea03ca868ea6ddc85b1305ef0bfe02d5292a6
setRemovedFormFields
public HttpFormAuthConfigurer setRemovedFormFields(Set<String> removedFormFields)
{    this.removedFormFields = removedFormFields;    return this;}
cdd54cfd6ee1eadb4f60e13bf245f4b8a1ee832d81168ea84880989cbd729051
setCookiePolicy
public void setCookiePolicy(String policy)
{    this.cookiePolicy = policy;}
db8e7bdfeff101fd543d518c5dbfb585087d09f5cf462cf1d462bb5a58f5a8a4
getCookiePolicy
public String getCookiePolicy()
{    return this.cookiePolicy;}
ab6008a36cf6cf435fe4eecb4e13fe34476eabe4999f1603e4c22a560b9870b1
login
public void login() throws Exception
{        CookieHandler.setDefault(new CookieManager());    String pageContent = httpGetPageContent(authConfigurer.getLoginUrl());    List<NameValuePair> params = getLoginFormParams(pageContent);    sendPost(authConfigurer.getLoginUrl(), params);}
19df60ee695e5758bad66a4b79ad41e20868980050c5a1f508b1b879e33edcae
sendPost
private void sendPost(String url, List<NameValuePair> params) throws Exception
{    PostMethod post = null;    try {        if (authConfigurer.isLoginRedirect()) {            post = new PostMethod(url) {                @Override                public boolean getFollowRedirects() {                    return true;                }            };        } else {            post = new PostMethod(url);        }                                        setLoginHeader(post);                LOG.debug("FormAuth: set cookie policy");        this.setCookieParams(authConfigurer, post.getParams());        post.addParameters(params.toArray(new NameValuePair[0]));        int rspCode = client.executeMethod(post);        if (LOG.isDebugEnabled()) {            LOG.debug("rspCode: " + rspCode);            LOG.debug("\nSending 'POST' request to URL : " + url);            LOG.debug("Post parameters : " + params);            LOG.debug("Response Code : " + rspCode);            for (Header header : post.getRequestHeaders()) {                LOG.debug("Response headers : " + header);            }        }        String rst = IOUtils.toString(post.getResponseBodyAsStream());        LOG.debug("login post result: " + rst);    } finally {        if (post != null) {            post.releaseConnection();        }    }}
7c169ac1ec9ab97c9dad29bc66f292ef661f0b45c410e116bf55bb431ea7c589
getFollowRedirects
public boolean getFollowRedirects()
{    return true;}
b294aab2460f10b78d9bfc606c511bb94d52c4365e8615757a0b49eca0f08095
setCookieParams
private void setCookieParams(HttpFormAuthConfigurer formConfigurer, HttpMethodParams params) throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException
{        if (formConfigurer.getCookiePolicy() != null) {        String policy = formConfigurer.getCookiePolicy();        Object p = FieldUtils.readDeclaredStaticField(CookiePolicy.class, policy);        if (null != p) {            LOG.debug("reflection of cookie value: " + p.toString());            params.setParameter(HttpMethodParams.COOKIE_POLICY, p);        }    }}
9e7a000c4ede1e1dcbdafc2dc58012579ec84a7f23e673b9545c70ab66af3925
setLoginHeader
private void setLoginHeader(PostMethod post)
{    Map<String, String> headers = new HashMap<String, String>();    headers.putAll(defaultLoginHeaders);        headers.putAll(authConfigurer.getAdditionalPostHeaders());    for (Entry<String, String> entry : headers.entrySet()) {        post.addRequestHeader(entry.getKey(), entry.getValue());    }    post.addRequestHeader("Cookie", getCookies());}
0c8d00aae694c849d8be34c277834e32e5d0d4abccdf05fcbba8c9cc08407411
httpGetPageContent
private String httpGetPageContent(String url) throws IOException
{    GetMethod get = new GetMethod(url);    try {        for (Entry<String, String> entry : authConfigurer.getAdditionalPostHeaders().entrySet()) {            get.addRequestHeader(entry.getKey(), entry.getValue());        }        client.executeMethod(get);        Header cookieHeader = get.getResponseHeader("Set-Cookie");        if (cookieHeader != null) {            setCookies(cookieHeader.getValue());        }        String rst = IOUtils.toString(get.getResponseBodyAsStream());        return rst;    } finally {        get.releaseConnection();    }}
794f44e22b1fc64d217b523d612639bab05b15adfbe82156878619841d24a77e
getLoginFormParams
private List<NameValuePair> getLoginFormParams(String pageContent) throws UnsupportedEncodingException
{    List<NameValuePair> params = new ArrayList<NameValuePair>();    Document doc = Jsoup.parse(pageContent);    Element loginform = doc.getElementById(authConfigurer.getLoginFormId());    if (loginform == null) {        LOG.debug("No form element found with 'id' = {}, trying 'name'.", authConfigurer.getLoginFormId());        loginform = doc.select("form[name=" + authConfigurer.getLoginFormId() + "]").first();        if (loginform == null) {            LOG.debug("No form element found with 'name' = {}", authConfigurer.getLoginFormId());            throw new IllegalArgumentException("No form exists: " + authConfigurer.getLoginFormId());        }    }    Elements inputElements = loginform.getElementsByTag("input");        for (Element inputElement : inputElements) {        String key = inputElement.attr("name");        String value = inputElement.attr("value");        if (authConfigurer.getLoginPostData().containsKey(key) || authConfigurer.getRemovedFormFields().contains(key)) {                        continue;        }        params.add(new NameValuePair(key, value));    }        for (Entry<String, String> entry : authConfigurer.getLoginPostData().entrySet()) {        params.add(new NameValuePair(entry.getKey(), entry.getValue()));    }    return params;}
a5cd197428059792ba7e9ee57ef3d2b893d5c8ac42e820172cfd903ba95e398d
getCookies
public String getCookies()
{    return cookies;}
23eb17381dfc2bb905254b0a6ccd3e850af6bb8c41468a82637238628ee07429
setCookies
public void setCookies(String cookies)
{    this.cookies = cookies;}
235028ea8ddb2341c1042a1108f87e7ae256c2220fdd3fdcc5c1d74c2e32dbcf
isRedirect
public boolean isRedirect()
{    return authConfigurer.isLoginRedirect();}
2993113e80f691e1b0b1f4d6b67e661228622f5febe1f00284adecd76ea284e2
setRedirect
public void setRedirect(boolean redirect)
{    this.authConfigurer.setLoginRedirect(redirect);}
df2bf56d298a90d42d37e21b66baa5616d58f08e28d08ed47d7798ed099513ef
getUrl
public URL getUrl()
{    return url;}
871172d34cf47bd1ccc8d8f81877fbf834289fcf345350e529b8b4e7a6708c5d
getCode
public int getCode()
{    return code;}
ce222e9e26ff92f109221120401e746a4137a63055fa3f4c459b71bc3b9a3f7b
getHeader
public String getHeader(String name)
{    return headers.get(name);}
8b40d561b36a77010d6a82801e7a4dd0cd137133c937dae97d3f2dd0467b5798
getHeaders
public Metadata getHeaders()
{    return headers;}
a724d7d22eec9af58dc1baab31eb2f9394c370706fcded02b6d254fcd56fd2b9
getContent
public byte[] getContent()
{    return content;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    ContextHandler context = new ContextHandler();    context.setContextPath("/");    context.setResourceBase(RES_DIR);    ServletHandler sh = new ServletHandler();    sh.addServletWithMapping("org.apache.jasper.servlet.JspServlet", "*.jsp");    context.addHandler(sh);    context.addHandler(new SessionHandler());    server = new Server();    server.addHandler(context);    conf = new Configuration();    conf.addResource("nutch-default.xml");    conf.addResource("nutch-site-test.xml");    http = new Http();    http.setConf(conf);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    server.stop();    for (int i = 0; i < 5; i++) {        if (!server.isStopped()) {            Thread.sleep(1000);        }    }}
1072535679613521c4ec7416d0cf166f3ebf700730a32844e4a3f5344981be0b
testCookies
public void testCookies() throws Exception
{    startServer(47500);    fetchPage("/cookies.jsp", 200);    fetchPage("/cookies.jsp?cookie=yes", 200);}
b71ba84a2ecb318e5b93388c4788e351e3939da6796cc6efd85f3b6c85424b11
testNoPreemptiveAuth
public void testNoPreemptiveAuth() throws Exception
{    startServer(47500);    fetchPage("/noauth.jsp", 200);}
e77f75989668f34bad95f3a473baaea53c0312122174b691463b833093d63ef9
testDefaultCredentials
public void testDefaultCredentials() throws Exception
{    startServer(47502);    fetchPage("/basic.jsp", 200);}
a72009f3c95b9a84e1a7acd9c879dae75b0cb4ad2a036af19ea7f2a8cc207caa
testBasicAuth
public void testBasicAuth() throws Exception
{    startServer(47500);    fetchPage("/basic.jsp", 200);    fetchPage("/basic.jsp?case=1", 200);    fetchPage("/basic.jsp?case=2", 200);    server.start();}
e8b8b029dac419ddf190637a086dfebb5a32b51ad3e8097cdcbc135436e1aab3
testOtherRealmsNoAuth
public void testOtherRealmsNoAuth() throws Exception
{    startServer(47501);    fetchPage("/basic.jsp", 200);    fetchPage("/basic.jsp?case=1", 401);    fetchPage("/basic.jsp?case=2", 401);}
bfbc7fdfe3b94b81258cb97ca915d34c34ebadc92554a7585930aa20ae5ebe9c
testDigestAuth
public void testDigestAuth() throws Exception
{    startServer(47500);    fetchPage("/digest.jsp", 200);}
8c637a1feaeb9a9e78adefc9dfed32dfbaf26040befe7bf6d9c0195cb395997c
testNtlmAuth
public void testNtlmAuth() throws Exception
{    startServer(47501);    fetchPage("/ntlm.jsp", 200);}
9148a7aace362830c9e0f20b81eded00262cd007917e85d60f296815ef42cd77
startServer
private void startServer(int portno) throws Exception
{    SocketConnector listener = new SocketConnector();    listener.setHost("127.0.0.1");    server.addConnector(listener);    for (int p = portno; p < portno + 10; p++) {        port = portno;        listener.setPort(port);        try {            server.start();            break;        } catch (Exception e) {            if (p == portno + 9) {                throw e;            }        }    }}
912a628650a678f2d837edcc771fef893ec90b45488890c1ffae328cdd0167a8
fetchPage
private void fetchPage(String page, int expectedCode) throws Exception
{    URL url = new URL("http", "127.0.0.1", port, page);    Response response = null;    response = http.getResponse(url, new CrawlDatum(), true);    int code = response.getCode();    Assert.assertEquals("HTTP Status Code for " + url, expectedCode, code);}
b6d06c13a051fabdf9bab74d5ed66675558a16b0ec55eb4bf2c263ad7457376e
processDriver
public String processDriver(WebDriver driver)
{        String accumulatedData = "";    try {                JavascriptExecutor jsx = (JavascriptExecutor) driver;        jsx.executeScript("document.body.innerHTML=document.body.innerHTML " + accumulatedData + ";");    } catch (Exception e) {        LOG.info(StringUtils.stringifyException(e));    }    return accumulatedData;}
27598efb16a6ad0a03d9fe21ef693c67b3ee76b8a002bbc8acc715805c9509c1
shouldProcessURL
public boolean shouldProcessURL(String URL)
{    return true;}
b6d06c13a051fabdf9bab74d5ed66675558a16b0ec55eb4bf2c263ad7457376e
processDriver
public String processDriver(WebDriver driver)
{    String accumulatedData = "";    try {        driver.findElement(By.tagName("body")).getAttribute("innerHTML");        Configuration conf = NutchConfiguration.create();        new WebDriverWait(driver, conf.getLong("libselenium.page.load.delay", 3));        List<WebElement> atags = driver.findElements(By.tagName("a"));        int numberofajaxlinks = atags.size();        for (int i = 0; i < numberofajaxlinks; i++) {            if (atags.get(i).getAttribute("href") != null && atags.get(i).getAttribute("href").equals("javascript:void(null);")) {                atags.get(i).click();                if (i == numberofajaxlinks - 1) {                                        JavascriptExecutor jsx = (JavascriptExecutor) driver;                    jsx.executeScript("document.body.innerHTML=document.body.innerHTML " + accumulatedData + ";");                    continue;                }                accumulatedData += driver.findElement(By.tagName("body")).getAttribute("innerHTML");                                driver.navigate().refresh();                new WebDriverWait(driver, conf.getLong("libselenium.page.load.delay", 3));                atags = driver.findElements(By.tagName("a"));            }        }    } catch (Exception e) {        LOG.info(StringUtils.stringifyException(e));    }    return accumulatedData;}
27598efb16a6ad0a03d9fe21ef693c67b3ee76b8a002bbc8acc715805c9509c1
shouldProcessURL
public boolean shouldProcessURL(String URL)
{    return true;}
b6d06c13a051fabdf9bab74d5ed66675558a16b0ec55eb4bf2c263ad7457376e
processDriver
public String processDriver(WebDriver driver)
{    return null;}
7b390cf25cea9da5f16d9f7ed96d1fa8f068fe1732d8dcbe31d7c964c31680d1
shouldProcessURL
public boolean shouldProcessURL(String url)
{    return true;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    super.setConf(conf);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    Http http = new Http();    http.setConf(NutchConfiguration.create());    main(http, args);}
b35242aa38e575dfb481f69bc8621016588a0ae4d4549f6af2ad46cd6e35d66c
getResponse
protected Response getResponse(URL url, CrawlDatum datum, boolean redirect) throws ProtocolException, IOException
{    return new HttpResponse(this, url, datum);}
df2bf56d298a90d42d37e21b66baa5616d58f08e28d08ed47d7798ed099513ef
getUrl
public URL getUrl()
{    return url;}
871172d34cf47bd1ccc8d8f81877fbf834289fcf345350e529b8b4e7a6708c5d
getCode
public int getCode()
{    return code;}
ce222e9e26ff92f109221120401e746a4137a63055fa3f4c459b71bc3b9a3f7b
getHeader
public String getHeader(String name)
{    return headers.get(name);}
8b40d561b36a77010d6a82801e7a4dd0cd137133c937dae97d3f2dd0467b5798
getHeaders
public Metadata getHeaders()
{    return headers;}
a724d7d22eec9af58dc1baab31eb2f9394c370706fcded02b6d254fcd56fd2b9
getContent
public byte[] getContent()
{    return content;}
0bb4dbccb108e1db43a4b9c97ea453f6e15601af7d254b42526d211cdc199d1a
loadSeleniumHandlers
private void loadSeleniumHandlers()
{    if (handlers != null)        return;    String handlerConfig = this.conf.get("interactiveselenium.handlers", "DefaultHandler");    String[] handlerNames = handlerConfig.split(",");    handlers = new InteractiveSeleniumHandler[handlerNames.length];    for (int i = 0; i < handlerNames.length; i++) {        try {            String classToLoad = this.getClass().getPackage().getName() + ".handlers." + handlerNames[i];            try {                handlers[i] = InteractiveSeleniumHandler.class.cast(Class.forName(classToLoad).getConstructor().newInstance());            } catch (IllegalArgumentException | InvocationTargetException | NoSuchMethodException | SecurityException e) {                e.printStackTrace();            }            Http.LOG.info("Successfully loaded " + classToLoad);        } catch (ClassNotFoundException e) {            Http.LOG.info("Unable to load Handler class for: " + handlerNames[i]);        } catch (InstantiationException e) {            Http.LOG.info("Unable to instantiate Handler: " + handlerNames[i]);        } catch (IllegalAccessException e) {            Http.LOG.info("Illegal access with Handler: " + handlerNames[i]);        }    }}
9f980a4f07d5fc3a040ebbf33314bc609966cf5d29cd7394bfa6896eb39f04ef
readPlainContent
private void readPlainContent(URL url) throws IOException
{    if (handlers == null)        loadSeleniumHandlers();    String processedPage = "";    for (InteractiveSeleniumHandler handler : this.handlers) {        if (!handler.shouldProcessURL(url.toString())) {            continue;        }        WebDriver driver = HttpWebClient.getDriverForPage(url.toString(), conf);        processedPage += handler.processDriver(driver);        HttpWebClient.cleanUpDriver(driver);    }    content = processedPage.getBytes("UTF-8");}
3ce8640c95c70b477e400e1c17b71862a7e7b9a9f87e1d79fd1f3ffa92a04d10
parseStatusLine
private int parseStatusLine(PushbackInputStream in, StringBuffer line) throws IOException, HttpException
{    readLine(in, line, false);    int codeStart = line.indexOf(" ");    int codeEnd = line.indexOf(" ", codeStart + 1);        if (codeEnd == -1)        codeEnd = line.length();    int code;    try {        code = Integer.parseInt(line.substring(codeStart + 1, codeEnd));    } catch (NumberFormatException e) {        throw new HttpException("bad status line '" + line + "': " + e.getMessage(), e);    }    return code;}
86a618b2c2d0d7a7d3c22390452b5e531c550e370e4dd8742aadbdf5417b4f18
processHeaderLine
private void processHeaderLine(StringBuffer line) throws IOException, HttpException
{        int colonIndex = line.indexOf(":");    if (colonIndex == -1) {        int i;        for (i = 0; i < line.length(); i++) if (!Character.isWhitespace(line.charAt(i)))            break;        if (i == line.length())            return;        throw new HttpException("No colon in header:" + line);    }    String key = line.substring(0, colonIndex);        int valueStart = colonIndex + 1;    while (valueStart < line.length()) {        int c = line.charAt(valueStart);        if (c != ' ' && c != '\t')            break;        valueStart++;    }    String value = line.substring(valueStart);    headers.set(key, value);}
cca7571c9942c3389ca474f259151d4d703db571ed133effeca51b5f35f777fa
parseHeaders
private void parseHeaders(PushbackInputStream in, StringBuffer line) throws IOException, HttpException
{    while (readLine(in, line, true) != 0) {                int pos;        if (((pos = line.indexOf("<!DOCTYPE")) != -1) || ((pos = line.indexOf("<HTML")) != -1) || ((pos = line.indexOf("<html")) != -1)) {            in.unread(line.substring(pos).getBytes("UTF-8"));            line.setLength(pos);            try {                                                                                                processHeaderLine(line);            } catch (Exception e) {                                Http.LOG.warn("Error: ", e);            }            return;        }        processHeaderLine(line);    }}
0870e5acde4a84220f2c7143dc5ba958973d75c86a409c1d6bbbb6c2f2e9f9a5
readLine
private static int readLine(PushbackInputStream in, StringBuffer line, boolean allowContinuedLine) throws IOException
{    line.setLength(0);    for (int c = in.read(); c != -1; c = in.read()) {        switch(c) {            case '\r':                if (peek(in) == '\n') {                    in.read();                }            case '\n':                if (line.length() > 0) {                                        if (allowContinuedLine)                        switch(peek(in)) {                            case ' ':                            case                             '\t':                                in.read();                                continue;                        }                }                                return line.length();            default:                line.append((char) c);        }    }    throw new EOFException();}
f40ae415133d16abf273b373afcf6737d1edbe6d4fe5565c6d453a7d720eed12
peek
private static int peek(PushbackInputStream in) throws IOException
{    int value = in.read();    in.unread(value);    return value;}
2732b973de7ca4a8e7ac3dba7e97191df288588fb7b1461bd3c184f34cb7db95
checkClientTrusted
public void checkClientTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException
{}
5721b267c749a106333ca03cc9475106ca26290396fb3b4d53b460bc189b07d4
checkServerTrusted
public void checkServerTrusted(java.security.cert.X509Certificate[] chain, String authType) throws CertificateException
{}
a35f7a0798c73280978ccb8b2dbe5ee78ce3a0ff346555b49e87a5da2164e76c
getAcceptedIssuers
public java.security.cert.X509Certificate[] getAcceptedIssuers()
{    return new java.security.cert.X509Certificate[] {};}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    super.setConf(conf);        List<okhttp3.Protocol> protocols = new ArrayList<>();    if (useHttp2) {        protocols.add(okhttp3.Protocol.HTTP_2);    }    protocols.add(okhttp3.Protocol.HTTP_1_1);    okhttp3.OkHttpClient.Builder builder = new OkHttpClient.Builder().protocols(    protocols).retryOnConnectionFailure(    true).followRedirects(    false).connectTimeout(timeout, TimeUnit.MILLISECONDS).writeTimeout(timeout, TimeUnit.MILLISECONDS).readTimeout(timeout, TimeUnit.MILLISECONDS);    if (!tlsCheckCertificate) {        builder.sslSocketFactory(trustAllSslSocketFactory, (X509TrustManager) trustAllCerts[0]);        builder.hostnameVerifier(new HostnameVerifier() {            @Override            public boolean verify(String hostname, SSLSession session) {                return true;            }        });    }    if (!accept.isEmpty()) {        getCustomRequestHeaders().add(new String[] { "Accept", accept });    }    if (!acceptLanguage.isEmpty()) {        getCustomRequestHeaders().add(new String[] { "Accept-Language", acceptLanguage });    }    if (!acceptCharset.isEmpty()) {        getCustomRequestHeaders().add(new String[] { "Accept-Charset", acceptCharset });    }    if (useProxy) {        Proxy proxy = new Proxy(proxyType, new InetSocketAddress(proxyHost, proxyPort));        String proxyUsername = conf.get("http.proxy.username");        if (proxyUsername == null) {            ProxySelector selector = new ProxySelector() {                @SuppressWarnings("serial")                private final List<Proxy> noProxyList = new ArrayList<Proxy>() {                    {                        add(Proxy.NO_PROXY);                    }                };                @SuppressWarnings("serial")                private final List<Proxy> proxyList = new ArrayList<Proxy>() {                    {                        add(proxy);                    }                };                @Override                public List<Proxy> select(URI uri) {                    if (useProxy(uri)) {                        return proxyList;                    }                    return noProxyList;                }                @Override                public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {                    LOG.error("Connection to proxy failed for {}: {}", uri, ioe);                }            };            builder.proxySelector(selector);        } else {            /*         * NOTE: the proxy exceptions list does NOT work with proxy         * username/password because an okhttp3 bug         * (https://github.com/square/okhttp/issues/3995) when using the         * ProxySelector class with proxy auth. If a proxy username is present,         * the configured proxy will be used for ALL requests.         */            if (proxyException.size() > 0) {                LOG.warn("protocol-okhttp does not respect 'http.proxy.exception.list' setting when " + "'http.proxy.username' is set. This is a limitation of the current okhttp3 " + "implementation, see NUTCH-2636");            }            builder.proxy(proxy);            String proxyPassword = conf.get("http.proxy.password");            Authenticator proxyAuthenticator = new Authenticator() {                @Override                public Request authenticate(okhttp3.Route route, okhttp3.Response response) throws IOException {                    String credential = okhttp3.Credentials.basic(proxyUsername, proxyPassword);                    return response.request().newBuilder().header("Proxy-Authorization", credential).build();                }            };            builder.proxyAuthenticator(proxyAuthenticator);        }    }    if (storeIPAddress || storeHttpHeaders || storeHttpRequest) {        builder.addNetworkInterceptor(new HTTPHeadersInterceptor());    }    client = builder.build();}
7ecdfe98cb7bd25b1097720a3f8e6a90e27872837da934a865afa884d714f2b6
verify
public boolean verify(String hostname, SSLSession session)
{    return true;}
3b3c20d5d0cf10beb86f3a7f63350edb830151aeb00b20a60940a256d1a3f33b
select
public List<Proxy> select(URI uri)
{    if (useProxy(uri)) {        return proxyList;    }    return noProxyList;}
1dee4d37ba703e6691edffd03514ce31d2459da9e398bc81e93200dfb6498b02
connectFailed
public void connectFailed(URI uri, SocketAddress sa, IOException ioe)
{    LOG.error("Connection to proxy failed for {}: {}", uri, ioe);}
6755ecc3a210927a8a8b2a66e5b5c4fd979cf69fd9f532b5955bc5d18852d3ea
authenticate
public Request authenticate(okhttp3.Route route, okhttp3.Response response) throws IOException
{    String credential = okhttp3.Credentials.basic(proxyUsername, proxyPassword);    return response.request().newBuilder().header("Proxy-Authorization", credential).build();}
d383316bb29f09540091902f662dd49a6ea252ed9c0ab3a8461a889798cabb3a
intercept
public okhttp3.Response intercept(Interceptor.Chain chain) throws IOException
{    Connection connection = chain.connection();    String ipAddress = null;    if (storeIPAddress) {        InetAddress address = connection.socket().getInetAddress();        ipAddress = address.getHostAddress();    }    Request request = chain.request();    okhttp3.Response response = chain.proceed(request);    String httpProtocol = response.protocol().toString().toUpperCase(Locale.ROOT);    if (useHttp2 && "H2".equals(httpProtocol)) {                httpProtocol = "HTTP/2";    }    StringBuilder requestverbatim = null;    StringBuilder responseverbatim = null;    if (storeHttpRequest) {        requestverbatim = new StringBuilder();        requestverbatim.append(request.method()).append(' ');        requestverbatim.append(request.url().encodedPath());        String query = request.url().encodedQuery();        if (query != null) {            requestverbatim.append('?').append(query);        }        requestverbatim.append(' ').append(httpProtocol).append("\r\n");        Headers headers = request.headers();        for (int i = 0, size = headers.size(); i < size; i++) {            String key = headers.name(i);            String value = headers.value(i);            requestverbatim.append(key).append(": ").append(value).append("\r\n");        }        requestverbatim.append("\r\n");    }    if (storeHttpHeaders) {        responseverbatim = new StringBuilder();        responseverbatim.append(httpProtocol).append(' ').append(response.code());        if (!response.message().isEmpty()) {            responseverbatim.append(' ').append(response.message());        }        responseverbatim.append("\r\n");        Headers headers = response.headers();        for (int i = 0, size = headers.size(); i < size; i++) {            String key = headers.name(i);            String value = headers.value(i);            responseverbatim.append(key).append(": ").append(value).append("\r\n");        }        responseverbatim.append("\r\n");    }    okhttp3.Response.Builder builder = response.newBuilder();    if (ipAddress != null) {        builder = builder.header(Response.IP_ADDRESS, ipAddress);    }    if (requestverbatim != null) {        byte[] encodedBytesRequest = Base64.getEncoder().encode(requestverbatim.toString().getBytes());        builder = builder.header(Response.REQUEST, new String(encodedBytesRequest));    }    if (responseverbatim != null) {        byte[] encodedBytesResponse = Base64.getEncoder().encode(responseverbatim.toString().getBytes());        builder = builder.header(Response.RESPONSE_HEADERS, new String(encodedBytesResponse));    }        return builder.build();}
760a1c2ebb53c5fea838e5e8abc916b94f9ce552cc40288063635b7dad3536f4
getCustomRequestHeaders
protected List<String[]> getCustomRequestHeaders()
{    return customRequestHeaders;}
42b4b1a69e51d6992eb3e3a1971ac2f4dee428a47eab6087908b2efb51d97fcc
getClient
protected OkHttpClient getClient()
{    return client;}
b35242aa38e575dfb481f69bc8621016588a0ae4d4549f6af2ad46cd6e35d66c
getResponse
protected Response getResponse(URL url, CrawlDatum datum, boolean redirect) throws ProtocolException, IOException
{    return new OkHttpResponse(this, url, datum);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    OkHttp okhttp = new OkHttp();    okhttp.setConf(NutchConfiguration.create());    main(okhttp, args);}
52cb7a0877c557bd2ad76b64c5028ea37f9cd608858648b7206a0faa928192d7
setReason
public void setReason(TruncatedContentReason val)
{    value = val;}
f029b9e4e78a85cc753e0e331c927b8f2341689e4fce666f7bec523a5d9f355d
getReason
public TruncatedContentReason getReason()
{    return value;}
60b515716193588117d9438084ea06708c0bc820825117965c64c6940b7109e9
booleanValue
public boolean booleanValue()
{    return value != TruncatedContentReason.NOT_TRUNCATED;}
898145e01a3a7062aae27cff3df675bdba93ba7950081cb43c20fcc7de9b5891
toByteArray
private final byte[] toByteArray(final ResponseBody responseBody, TruncatedContent truncated, int maxContent, int maxDuration, boolean partialAsTruncated) throws IOException
{    if (responseBody == null) {        return new byte[] {};    }    long endDueFor = -1;    if (maxDuration != -1) {        endDueFor = System.currentTimeMillis() + (maxDuration * 1000);    }    int maxContentBytes = Integer.MAX_VALUE;    if (maxContent >= 0) {        maxContentBytes = Math.min(maxContentBytes, maxContent);    }    BufferedSource source = responseBody.source();    int bytesRequested = 0;    int bufferGrowStepBytes = 8192;    while (source.buffer().size() <= maxContentBytes) {        bytesRequested += Math.min(bufferGrowStepBytes, /*           * request one byte more than required to reliably detect truncated           * content, but beware of integer overflows           */        (maxContentBytes == Integer.MAX_VALUE ? maxContentBytes : (1 + maxContentBytes)) - bytesRequested);        boolean success = false;        try {            success = source.request(bytesRequested);        } catch (IOException e) {            if (partialAsTruncated && source.buffer().size() > 0) {                                truncated.setReason(TruncatedContentReason.DISCONNECT);                LOG.info("Truncated content for {}, partial fetch caused by:", url, e);            } else {                throw e;            }        }        if (LOG.isDebugEnabled()) {            LOG.debug("total bytes requested = {}, buffered = {}", bytesRequested, source.buffer().size());        }        if (!success) {            LOG.debug("source exhausted, no more data to read");            break;        }        if (endDueFor != -1 && endDueFor <= System.currentTimeMillis()) {            LOG.debug("max. fetch duration reached");            truncated.setReason(TruncatedContentReason.TIME);            break;        }        if (source.buffer().size() >= maxContentBytes) {            LOG.debug("content limit reached");        }                bytesRequested = (int) source.buffer().size();    }    int bytesBuffered = (int) source.buffer().size();    int bytesToCopy = bytesBuffered;    if (maxContent >= 0 && bytesToCopy > maxContent) {                truncated.setReason(TruncatedContentReason.LENGTH);        bytesToCopy = maxContentBytes;    }    byte[] arr = new byte[bytesToCopy];    source.buffer().readFully(arr);    if (LOG.isDebugEnabled()) {        LOG.debug("copied {} bytes out of {} buffered, remaining {} bytes in buffer", bytesToCopy, bytesBuffered, source.buffer().size());    }    return arr;}
df2bf56d298a90d42d37e21b66baa5616d58f08e28d08ed47d7798ed099513ef
getUrl
public URL getUrl()
{    return url;}
871172d34cf47bd1ccc8d8f81877fbf834289fcf345350e529b8b4e7a6708c5d
getCode
public int getCode()
{    return code;}
ce222e9e26ff92f109221120401e746a4137a63055fa3f4c459b71bc3b9a3f7b
getHeader
public String getHeader(String name)
{    return headers.get(name);}
8b40d561b36a77010d6a82801e7a4dd0cd137133c937dae97d3f2dd0467b5798
getHeaders
public Metadata getHeaders()
{    return headers;}
a724d7d22eec9af58dc1baab31eb2f9394c370706fcded02b6d254fcd56fd2b9
getContent
public byte[] getContent()
{    return content;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    conf = NutchConfiguration.create();    conf.addResource("nutch-default.xml");            conf.addResource("nutch-site-test.xml");    conf.setBoolean("store.http.headers", true);    http = new ProtocolFactory(conf).getProtocolById("org.apache.nutch.protocol.okhttp.OkHttp");}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    server.close();}
dfbb8a430cf7c44f71f5a8682e580e5d58cbfbd96c3b01dbc1e3ca50dbb666e1
getHeaders
public static String getHeaders(ProtocolOutput response)
{    return response.getContent().getMetadata().get(Response.RESPONSE_HEADERS);}
a2936a1c51a1db0c71cf3c3a0d93b259828dafa811417e1fb0175135eacf44c7
getHeader
public static String getHeader(ProtocolOutput response, String header)
{    for (String line : getHeaders(response).split("\r\n")) {        String[] parts = line.split(": ", 1);        if (parts[0].equals(header)) {            return parts[1];        }    }    return null;}
33fd32d9042a65ee250176bed1a1abbbfd6434915c2389d800803fba10738a2a
runServer
private void runServer(int port, byte[] response) throws Exception
{    server = new ServerSocket();    server.bind(new InetSocketAddress("127.0.0.1", port));    Pattern requestPattern = Pattern.compile("(?i)^GET\\s+(\\S+)");    while (true) {        LOG.info("Listening on port {}", port);        Socket socket = server.accept();        LOG.info("Connection received");        try (BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream(), StandardCharsets.UTF_8))) {            String line;            while ((line = in.readLine()) != null) {                LOG.info("Request: {}", line);                if (line.trim().isEmpty()) {                    break;                }                Matcher m = requestPattern.matcher(line);                if (m.find()) {                    LOG.info("Requested {}", m.group(1));                    if (!m.group(1).startsWith("/")) {                        response = "HTTP/1.1 400 Bad request\r\n\r\n".getBytes(StandardCharsets.UTF_8);                    }                }            }            socket.getOutputStream().write(response);        } catch (Exception e) {            LOG.warn("Exception in test server:", e);        }    }}
458c12a767c1312414137a7b3165782ade012bd111529740d0532fbd8d65062c
launchServer
private void launchServer(String response) throws InterruptedException
{    launchServer(response.getBytes(StandardCharsets.UTF_8));}
6e7b4598fbf1419c6a86c9ef66830faa0e1449a989864361f2c0e871354fe617
launchServer
private void launchServer(byte[] response) throws InterruptedException
{    Thread serverThread = new Thread(() -> {        try {            runServer(port, response);        } catch (Exception e) {            LOG.warn("Test server died:", e);        }    });    serverThread.start();    Thread.sleep(50);}
3b0a12ddf28c8f6e9c114d8ccdaf2f133e30a40532bd5bd823f67a8cf8c017a3
fetchPage
private ProtocolOutput fetchPage(String page, int expectedCode) throws MalformedURLException
{    URL url = new URL("http", "127.0.0.1", port, page);    LOG.info("Fetching {}", url);    CrawlDatum crawlDatum = new CrawlDatum();    ProtocolOutput out = http.getProtocolOutput(new Text(url.toString()), crawlDatum);    int httpStatusCode = -1;    if (crawlDatum.getMetaData().containsKey(Nutch.PROTOCOL_STATUS_CODE_KEY)) {        httpStatusCode = Integer.parseInt(crawlDatum.getMetaData().get(Nutch.PROTOCOL_STATUS_CODE_KEY).toString());    }    assertEquals("HTTP Status Code for " + url, expectedCode, httpStatusCode);    return out;}
d5584e90e8678683125d1fb28cdc3507ec3d874812c98990ce50f6efda100dc6
testBadHttpServer
public void testBadHttpServer() throws Exception
{    setUp();            launchServer(responseHeader + simpleContent);    fetchPage("/", 200);}
5af1c93259e8fc7590de2cc6e856bed5876aaecfa3cf6345d6f2b50c0bd34c31
testRequestNotStartingWithSlash
public void testRequestNotStartingWithSlash() throws Exception
{    setUp();    launchServer(responseHeader + simpleContent);    fetchPage("?171", 200);}
63767307e1827b5567f1eed8c7411a9be3df56019a0121baba834f667dffaff2
testContentLengthNotANumber
public void testContentLengthNotANumber() throws Exception
{    setUp();    launchServer(responseHeader + "Content-Length: thousand\r\n" + simpleContent);    fetchPage("/", 200);}
d42792c7686b3df74f7bdf102d9f0f74c38607f0522c671881e0a9c153903d7f
testHeaderWithColon
public void testHeaderWithColon() throws Exception
{    setUp();    launchServer("HTTP/1.1 200: OK\r\n" + simpleContent);    fetchPage("/", 200);}
e229aeeb01bde4e2b3f330146ed880a119112196d675f331c6bc2a2a2713457e
testHeaderSpellChecking
public void testHeaderSpellChecking() throws Exception
{    setUp();    launchServer(responseHeader + "Client-Transfer-Encoding: chunked\r\n" + simpleContent);    fetchPage("/", 200);}
3faeb5360fcf752375fcbc1777d71c88cbc9c1c51f002ad7c840545758ace63d
testIgnoreErrorInRedirectPayload
public void testIgnoreErrorInRedirectPayload() throws Exception
{    setUp();    launchServer("HTTP/1.1 302 Found\r\nLocation: http://example.com/\r\n" + "Transfer-Encoding: chunked\r\n\r\nNot a valid chunk.");    ProtocolOutput fetched = fetchPage("/", 302);    assertNotNull("No redirect Location.", getHeader(fetched, "Location"));    assertEquals("Wrong redirect Location.", "http://example.com/", getHeader(fetched, "Location"));}
876913c7e2f37fa1bb456a3961144792970ffe3b4ad1365044d1121f4681aed5
testNoStatusLine
public void testNoStatusLine() throws Exception
{    setUp();    String text = "This is a text containing non-ASCII characters: \u00e4\u00f6\u00fc\u00df";    launchServer(text);    ProtocolOutput fetched = fetchPage("/", 200);    assertEquals("Wrong text returned for response with no status line.", text, new String(fetched.getContent().getContent(), StandardCharsets.UTF_8));    server.close();    text = "<!DOCTYPE html>\n<html>\n<head>\n" + "<title>Testing no HTTP header </title>\n" + "<meta charset=\"utf-8\">\n" + "</head>\n<body>This is a text containing non-ASCII characters:" + "\u00e4\u00f6\u00fc\u00df</body>\n</html";    launchServer(text);    fetched = fetchPage("/", 200);    assertEquals("Wrong text returned for response with no status line.", text, new String(fetched.getContent().getContent(), StandardCharsets.UTF_8));}
4b0945080f03ab80ee206368de14a69dc199f777dcd3f464d3b4acd6a95988a4
testMultiLineHeader
public void testMultiLineHeader() throws Exception
{    setUp();    launchServer(responseHeader + "Set-Cookie: UserID=JohnDoe;\r\n  Max-Age=3600;\r\n  Version=1\r\n" + simpleContent);    ProtocolOutput fetched = fetchPage("/", 200);    LOG.info("Headers: {}", getHeaders(fetched));    assertNotNull("Failed to set multi-line \"Set-Cookie\" header.", getHeader(fetched, "Set-Cookie"));    assertTrue("Failed to set multi-line \"Set-Cookie\" header.", getHeader(fetched, "Set-Cookie").contains("Version=1"));}
eb95505658c242c5e574e8c95255632f8e33b557d7e4fd3cc69baf7e7e798c4b
testOverlongHeader
public void testOverlongHeader() throws Exception
{    setUp();    StringBuilder response = new StringBuilder();    response.append(responseHeader);    for (int i = 0; i < 80; i++) {        response.append("X-Custom-Header-");        for (int j = 0; j < 10000; j++) {            response.append('x');        }        response.append(": hello\r\n");    }    response.append("\r\n" + simpleContent);    launchServer(response.toString());        fetchPage("/", -1);}
ee10425b12e299793e81823f5bb864de10c552e4e44c120a5c1c90e0bca619bc
testChunkedContent
public void testChunkedContent() throws Exception
{    setUp();    StringBuilder response = new StringBuilder();    response.append(responseHeader);    response.append("Content-Type: text/html\r\n");    response.append("Transfer-Encoding: chunked\r\n");        for (int i = 0; i < 80; i++) {        response.append(String.format("\r\n400\r\n%02x\r\n", i));        for (int j = 0; j < 1012; j++) {            response.append('x');        }        response.append(String.format("\r\n%02x\r\n", i));        response.append("\r\n");    }    response.append("\r\n0\r\n\r\n");    launchServer(response.toString());    ProtocolOutput fetched = fetchPage("/", 200);    assertEquals("Chunked content not truncated according to http.content.limit", 65536, fetched.getContent().getContent().length);    assertNotNull("Content truncation not marked", fetched.getContent().getMetadata().get(Response.TRUNCATED_CONTENT));    assertEquals("Content truncation not marked", Response.TruncatedContentReason.LENGTH.toString().toLowerCase(), fetched.getContent().getMetadata().get(Response.TRUNCATED_CONTENT_REASON));}
25de0765aa3804db8c40f8a32cc8e0087e44c3dd737231ed78047fda4e1b0ce4
testTruncationMarking
public void testTruncationMarking() throws Exception
{    setUp();    int[] kBs = { 63, 64, 65 };    for (int kB : kBs) {        StringBuilder response = new StringBuilder();        response.append(responseHeader);        response.append("Content-Type: text/plain\r\nContent-Length: " + (kB * 1024) + "\r\n\r\n");        for (int i = 0; i < kB; i++) {            for (int j = 0; j < 16; j++) {                                response.append("abcdefghijklmnopqurstuvxyz0123456789-ABCDEFGHIJKLMNOPQURSTUVXYZ\n");            }        }        launchServer(response.toString());        ProtocolOutput fetched = fetchPage("/", 200);        assertEquals("Content not truncated according to http.content.limit", Math.min(kB * 1024, 65536), fetched.getContent().getContent().length);        if (kB * 1024 > 65536) {            assertNotNull("Content truncation not marked", fetched.getContent().getMetadata().get(Response.TRUNCATED_CONTENT));            assertEquals("Content truncation not marked", Response.TruncatedContentReason.LENGTH.toString().toLowerCase(), fetched.getContent().getMetadata().get(Response.TRUNCATED_CONTENT_REASON));        }                server.close();    }}
af5175adff883a63fbbd08bafa948f74211769751fb92333d9663a7bc4014155
testTruncationMarkingGzip
public void testTruncationMarkingGzip() throws Exception
{    setUp();    int[] kBs = { 63, 64, 65 };    for (int kB : kBs) {        StringBuilder payload = new StringBuilder();        for (int i = 0; i < kB; i++) {            for (int j = 0; j < 16; j++) {                                payload.append("abcdefghijklmnopqurstuvxyz0123456789-ABCDEFGHIJKLMNOPQURSTUVXYZ\n");            }        }        ByteArrayOutputStream bytes = new ByteArrayOutputStream();        GZIPOutputStream gzip = new GZIPOutputStream(bytes);        gzip.write(payload.toString().getBytes(StandardCharsets.UTF_8));        gzip.close();        StringBuilder responseHead = new StringBuilder();        responseHead.append(responseHeader);        responseHead.append("Content-Type: text/plain\r\nContent-Length: " + bytes.size() + "\r\nContent-Encoding: gzip\r\n\r\n");        ByteArrayOutputStream response = new ByteArrayOutputStream();        response.write(responseHead.toString().getBytes(StandardCharsets.UTF_8));        response.write(bytes.toByteArray());        launchServer(response.toByteArray());        ProtocolOutput fetched = fetchPage("/", 200);        assertEquals("Content not truncated according to http.content.limit", Math.min(kB * 1024, 65536), fetched.getContent().getContent().length);        if (kB * 1024 > 65536) {            assertNotNull("Content truncation not marked", fetched.getContent().getMetadata().get(Response.TRUNCATED_CONTENT));            assertEquals("Content truncation not marked", Response.TruncatedContentReason.LENGTH.toString().toLowerCase(), fetched.getContent().getMetadata().get(Response.TRUNCATED_CONTENT_REASON));        }                server.close();    }}
b76a01ad587856d1ec8561573558dec8c9227720e9cd05948f26cc5dd8505754
testPartialContentTruncated
public void testPartialContentTruncated() throws Exception
{    setUp();    conf.setBoolean("http.partial.truncated", true);    http.setConf(conf);    String testContent = "This is a text.";    launchServer(responseHeader + "Content-Length: 50000\r\n\r\n" + testContent);    ProtocolOutput fetched = fetchPage("/", 200);    assertEquals("Content not saved as truncated", testContent, new String(fetched.getContent().getContent(), StandardCharsets.UTF_8));    assertNotNull("Content truncation not marked", fetched.getContent().getMetadata().get(Response.TRUNCATED_CONTENT));}
e5d438f13d36992f5dd0fbbbe1297ed20aad4b2e0a9e9b88ab986aacc55f38f2
testNoContentLimit
public void testNoContentLimit() throws Exception
{    setUp();    conf.setInt("http.content.limit", -1);    http.setConf(conf);    StringBuilder response = new StringBuilder();    response.append(responseHeader);            int kB = 128;    response.append("Content-Type: text/plain\r\nContent-Length: " + (kB * 1024) + "\r\n\r\n");    for (int i = 0; i < kB; i++) {        for (int j = 0; j < 16; j++) {                        response.append("abcdefghijklmnopqurstuvxyz0123456789-ABCDEFGHIJKLMNOPQURSTUVXYZ\n");        }    }    launchServer(response.toString());    ProtocolOutput fetched = fetchPage("/", 200);    assertEquals("Content truncated although http.content.limit == -1", (kB * 1024), fetched.getContent().getContent().length);}
1ee0b82c097cdf4275eef0057ea8259c48e94adae1eebb4cf281e500a08ec863
setUp
public void setUp(boolean redirection) throws Exception
{    conf = NutchConfiguration.create();    conf.addResource("nutch-default.xml");            conf.addResource("nutch-site-test.xml");    http = new ProtocolFactory(conf).getProtocolById("org.apache.nutch.protocol.okhttp.OkHttp");    server = new Server();    if (redirection) {        root = new Context(server, "/redirection", Context.SESSIONS);        root.setAttribute("newContextURL", "/redirect");    } else {        root = new Context(server, "/", Context.SESSIONS);    }    ServletHolder sh = new ServletHolder(org.apache.jasper.servlet.JspServlet.class);    root.addServlet(sh, "*.jsp");    root.setResourceBase(RES_DIR);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    server.stop();}
61fc96ab978515f78569442c9f92c2f2a5c8832dffc5e3201e89b3273cfb6f62
testStatusCode
public void testStatusCode() throws Exception
{    startServer(47504, false);    fetchPage("/basic-http.jsp", 200);    fetchPage("/redirect301.jsp", 301);    fetchPage("/redirect302.jsp", 302);    fetchPage("/nonexists.html", 404);    fetchPage("/brokenpage.jsp", 500);}
d69e81bc1b3c8bd7e2e4114bedb81a82a487f4410997314f0ae9e2c1074d99f8
testRedirectionJetty
public void testRedirectionJetty() throws Exception
{        startServer(47503, true);    fetchPage("/redirection", 302);}
110c7dcaf27495b42a37a80189b025ff968cd2988693b9f0a174e8c90a53e2e1
startServer
private void startServer(int portno, boolean redirection) throws Exception
{    port = portno;    setUp(redirection);    SelectChannelConnector connector = new SelectChannelConnector();    connector.setHost("127.0.0.1");    connector.setPort(port);    server.addConnector(connector);    server.start();}
912a628650a678f2d837edcc771fef893ec90b45488890c1ffae328cdd0167a8
fetchPage
private void fetchPage(String page, int expectedCode) throws Exception
{    URL url = new URL("http", "127.0.0.1", port, page);    CrawlDatum crawlDatum = new CrawlDatum();    ProtocolOutput out = http.getProtocolOutput(new Text(url.toString()), crawlDatum);    int httpStatusCode = -1;    if (crawlDatum.getMetaData().containsKey(Nutch.PROTOCOL_STATUS_CODE_KEY)) {        httpStatusCode = Integer.parseInt(crawlDatum.getMetaData().get(Nutch.PROTOCOL_STATUS_CODE_KEY).toString());    }    Content content = out.getContent();    assertEquals("HTTP Status Code for " + url, expectedCode, httpStatusCode);    if (page.compareTo("/nonexists.html") != 0 && page.compareTo("/brokenpage.jsp") != 0 && page.compareTo("/redirection") != 0) {        assertEquals("ContentType " + url, "text/html", content.getContentType());    }}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    super.setConf(conf);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    Http http = new Http();    http.setConf(NutchConfiguration.create());    main(http, args);}
b35242aa38e575dfb481f69bc8621016588a0ae4d4549f6af2ad46cd6e35d66c
getResponse
protected Response getResponse(URL url, CrawlDatum datum, boolean redirect) throws ProtocolException, IOException
{    return new HttpResponse(this, url, datum);}
df2bf56d298a90d42d37e21b66baa5616d58f08e28d08ed47d7798ed099513ef
getUrl
public URL getUrl()
{    return url;}
871172d34cf47bd1ccc8d8f81877fbf834289fcf345350e529b8b4e7a6708c5d
getCode
public int getCode()
{    return code;}
ce222e9e26ff92f109221120401e746a4137a63055fa3f4c459b71bc3b9a3f7b
getHeader
public String getHeader(String name)
{    return headers.get(name);}
8b40d561b36a77010d6a82801e7a4dd0cd137133c937dae97d3f2dd0467b5798
getHeaders
public Metadata getHeaders()
{    return headers;}
a724d7d22eec9af58dc1baab31eb2f9394c370706fcded02b6d254fcd56fd2b9
getContent
public byte[] getContent()
{    return content;}
9f980a4f07d5fc3a040ebbf33314bc609966cf5d29cd7394bfa6896eb39f04ef
readPlainContent
private void readPlainContent(URL url) throws IOException
{    String page = HttpWebClient.getHtmlPage(url.toString(), conf);    content = page.getBytes("UTF-8");}
3ce8640c95c70b477e400e1c17b71862a7e7b9a9f87e1d79fd1f3ffa92a04d10
parseStatusLine
private int parseStatusLine(PushbackInputStream in, StringBuffer line) throws IOException, HttpException
{    readLine(in, line, false);    int codeStart = line.indexOf(" ");    int codeEnd = line.indexOf(" ", codeStart + 1);        if (codeEnd == -1)        codeEnd = line.length();    int code;    try {        code = Integer.parseInt(line.substring(codeStart + 1, codeEnd));    } catch (NumberFormatException e) {        throw new HttpException("bad status line '" + line + "': " + e.getMessage(), e);    }    return code;}
86a618b2c2d0d7a7d3c22390452b5e531c550e370e4dd8742aadbdf5417b4f18
processHeaderLine
private void processHeaderLine(StringBuffer line) throws IOException, HttpException
{        int colonIndex = line.indexOf(":");    if (colonIndex == -1) {        int i;        for (i = 0; i < line.length(); i++) if (!Character.isWhitespace(line.charAt(i)))            break;        if (i == line.length())            return;        throw new HttpException("No colon in header:" + line);    }    String key = line.substring(0, colonIndex);        int valueStart = colonIndex + 1;    while (valueStart < line.length()) {        int c = line.charAt(valueStart);        if (c != ' ' && c != '\t')            break;        valueStart++;    }    String value = line.substring(valueStart);    headers.set(key, value);}
cca7571c9942c3389ca474f259151d4d703db571ed133effeca51b5f35f777fa
parseHeaders
private void parseHeaders(PushbackInputStream in, StringBuffer line) throws IOException, HttpException
{    while (readLine(in, line, true) != 0) {                int pos;        if (((pos = line.indexOf("<!DOCTYPE")) != -1) || ((pos = line.indexOf("<HTML")) != -1) || ((pos = line.indexOf("<html")) != -1)) {            in.unread(line.substring(pos).getBytes("UTF-8"));            line.setLength(pos);            try {                                                                                                processHeaderLine(line);            } catch (Exception e) {                                Http.LOG.warn("Error: ", e);            }            return;        }        processHeaderLine(line);    }}
0870e5acde4a84220f2c7143dc5ba958973d75c86a409c1d6bbbb6c2f2e9f9a5
readLine
private static int readLine(PushbackInputStream in, StringBuffer line, boolean allowContinuedLine) throws IOException
{    line.setLength(0);    for (int c = in.read(); c != -1; c = in.read()) {        switch(c) {            case '\r':                if (peek(in) == '\n') {                    in.read();                }            case '\n':                if (line.length() > 0) {                                        if (allowContinuedLine)                        switch(peek(in)) {                            case ' ':                            case                             '\t':                                in.read();                                continue;                        }                }                                return line.length();            default:                line.append((char) c);        }    }    throw new EOFException();}
f40ae415133d16abf273b373afcf6737d1edbe6d4fe5565c6d453a7d720eed12
peek
private static int peek(PushbackInputStream in) throws IOException
{    int value = in.read();    in.unread(value);    return value;}
d881f05a8776e4de41efb99b77602c86852470eb1ef56eea5d14db34ce16fd97
setConfig
public boolean setConfig(Configuration conf)
{    try {        exchange = conf.get(RabbitMQConstants.EXCHANGE_NAME);        routingKey = conf.get(RabbitMQConstants.ROUTING_KEY);        headersStatic = conf.get(RabbitMQConstants.HEADERS_STATIC, "");        String uri = conf.get(RabbitMQConstants.SERVER_URI);        client = new RabbitMQClient(uri);        client.openChannel();        boolean binding = conf.getBoolean(RabbitMQConstants.BINDING, false);        if (binding) {            String queueName = conf.get(RabbitMQConstants.QUEUE_NAME);            String queueOptions = conf.get(RabbitMQConstants.QUEUE_OPTIONS);            String exchangeOptions = conf.get(RabbitMQConstants.EXCHANGE_OPTIONS);            String bindingArguments = conf.get(RabbitMQConstants.BINDING_ARGUMENTS, "");            client.bind(exchange, exchangeOptions, queueName, queueOptions, routingKey, bindingArguments);        }        LOG.info("Configured RabbitMQ publisher");        return true;    } catch (Exception e) {        LOG.error("Could not initialize RabbitMQ publisher - {}", StringUtils.stringifyException(e));        return false;    }}
115d539bd26423957d10ec55be21a6cbbc0ef2c60ccddad15c781f7b0ccd0cc0
publish
public void publish(Object event, Configuration conf)
{    try {        RabbitMQMessage message = new RabbitMQMessage();        message.setBody(getJSONString(event).getBytes());        message.setHeaders(headersStatic);        client.publish(exchange, routingKey, message);    } catch (Exception e) {        LOG.error("Error occured while publishing - {}", StringUtils.stringifyException(e));    }}
8a09761cf9166f62d9286e0aa79ef70a259396db135c2261777d4f7c4e3ca591
getJSONString
private String getJSONString(Object obj)
{    ObjectMapper mapper = new ObjectMapper();    try {        return mapper.writeValueAsString(obj);    } catch (JsonProcessingException e) {        LOG.error("Error converting event object to JSON String - {}", StringUtils.stringifyException(e));    }    return null;}
3289d9012415678ad1c3e3443add269fd37c2ec2f5df3aa1733dc466c75edc2d
setConf
public void setConf(Configuration arg0)
{}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return null;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    super.setConf(conf);    if (conf == null)        return;    defaultMaxDepth = conf.getInt("scoring.depth.max", DEFAULT_MAX_DEPTH);    if (defaultMaxDepth <= 0) {        defaultMaxDepth = DEFAULT_MAX_DEPTH;    }}
89fdd7122298e467ee01a9f463b423fa9405ab98df3d1247ebce0e733465af3f
distributeScoreToOutlinks
public CrawlDatum distributeScoreToOutlinks(Text fromUrl, ParseData parseData, Collection<Entry<Text, CrawlDatum>> targets, CrawlDatum adjust, int allCount) throws ScoringFilterException
{    if (targets.isEmpty()) {        return adjust;    }    String depthString = parseData.getMeta(DEPTH_KEY);    if (depthString == null) {        LOG.warn("Missing depth, removing all outlinks from url " + fromUrl);        targets.clear();        return adjust;    }    int curDepth = Integer.parseInt(depthString);    int curMaxDepth = defaultMaxDepth;    IntWritable customMaxDepth = null;        String maxDepthString = parseData.getMeta(MAX_DEPTH_KEY);    if (maxDepthString != null) {        curMaxDepth = Integer.parseInt(maxDepthString);        customMaxDepth = new IntWritable(curMaxDepth);    }    if (curDepth >= curMaxDepth) {                LOG.info("Depth limit (" + curMaxDepth + ") reached, ignoring outlinks for " + fromUrl);        targets.clear();        return adjust;    }    Iterator<Entry<Text, CrawlDatum>> it = targets.iterator();    while (it.hasNext()) {        Entry<Text, CrawlDatum> e = it.next();                e.getValue().getMetaData().put(DEPTH_KEY_W, new IntWritable(curDepth + 1));                if (customMaxDepth != null) {            e.getValue().getMetaData().put(MAX_DEPTH_KEY_W, customMaxDepth);        }    }    return adjust;}
c7d75ff32784416ea95ea0863f39cb7d0da44832579d23df72069418eb890bf5
generatorSortValue
public float generatorSortValue(Text url, CrawlDatum datum, float initSort) throws ScoringFilterException
{        int curDepth, curMaxDepth;    IntWritable maxDepth = (IntWritable) datum.getMetaData().get(MAX_DEPTH_KEY_W);    if (maxDepth != null) {        curMaxDepth = maxDepth.get();    } else {        curMaxDepth = defaultMaxDepth;    }    IntWritable depth = (IntWritable) datum.getMetaData().get(DEPTH_KEY_W);    if (depth == null) {                curDepth = curMaxDepth;    } else {        curDepth = depth.get();    }    int mul = curMaxDepth - curDepth;    return initSort * (1 + mul);}
d2a95754238ce8e7ee9557976c163d8b3860456f1815caeadede92b2c9ee04fa
indexerScore
public float indexerScore(Text url, NutchDocument doc, CrawlDatum dbDatum, CrawlDatum fetchDatum, Parse parse, Inlinks inlinks, float initScore) throws ScoringFilterException
{    return initScore;}
2dcbf82c99c2e2b740c6a208c3e1e729c537864ed30748e09cdb44bbfad01075
initialScore
public void initialScore(Text url, CrawlDatum datum) throws ScoringFilterException
{        if (datum.getMetaData().get(MAX_DEPTH_KEY_W) == null)        datum.getMetaData().put(MAX_DEPTH_KEY_W, new IntWritable(defaultMaxDepth));        if (datum.getMetaData().get(DEPTH_KEY_W) == null)        datum.getMetaData().put(DEPTH_KEY_W, new IntWritable(1));}
0b6feb77383ae8d81d2c30e18bf6315732aeabecd96f00250a9915d31f7fbc88
injectedScore
public void injectedScore(Text url, CrawlDatum datum) throws ScoringFilterException
{        if (datum.getMetaData().get(MAX_DEPTH_KEY_W) != null) {                String depthString = datum.getMetaData().get(MAX_DEPTH_KEY_W).toString();        datum.getMetaData().remove(MAX_DEPTH_KEY_W);        int depth = Integer.parseInt(depthString);        datum.getMetaData().put(MAX_DEPTH_KEY_W, new IntWritable(depth));    } else {                datum.getMetaData().put(MAX_DEPTH_KEY_W, new IntWritable(defaultMaxDepth));    }        datum.getMetaData().put(DEPTH_KEY_W, new IntWritable(1));}
b9e96bf8d75863926c418ca10c8e728ef083a9a13368adf5af855a1fa573c6c7
passScoreAfterParsing
public void passScoreAfterParsing(Text url, Content content, Parse parse) throws ScoringFilterException
{    String depth = content.getMetadata().get(DEPTH_KEY);    if (depth != null) {        parse.getData().getParseMeta().set(DEPTH_KEY, depth);    }    String maxdepth = content.getMetadata().get(MAX_DEPTH_KEY);    if (maxdepth != null) {        parse.getData().getParseMeta().set(MAX_DEPTH_KEY, maxdepth);    }}
53571795b495728e7ad1dc9749d44ee6378e3f595ad89330bb07ce03d5f44873
passScoreBeforeParsing
public void passScoreBeforeParsing(Text url, CrawlDatum datum, Content content) throws ScoringFilterException
{    IntWritable depth = (IntWritable) datum.getMetaData().get(DEPTH_KEY_W);    if (depth != null) {        content.getMetadata().set(DEPTH_KEY, depth.toString());    }    IntWritable maxdepth = (IntWritable) datum.getMetaData().get(MAX_DEPTH_KEY_W);    if (maxdepth != null) {        content.getMetadata().set(MAX_DEPTH_KEY, maxdepth.toString());    }}
021571540bd16053b37a45bee8e233da357044b2982932447da62f33fd6e6f2a
updateDbScore
public void updateDbScore(Text url, CrawlDatum old, CrawlDatum datum, List<CrawlDatum> inlinked) throws ScoringFilterException
{        int newDepth = DEFAULT_MAX_DEPTH;    if (old != null) {        IntWritable oldDepth = (IntWritable) old.getMetaData().get(DEPTH_KEY_W);        if (oldDepth != null) {            newDepth = oldDepth.get();        } else {                        initialScore(url, old);        }    }    for (CrawlDatum lnk : inlinked) {        IntWritable depth = (IntWritable) lnk.getMetaData().get(DEPTH_KEY_W);        if (depth != null && depth.get() < newDepth) {            newDepth = depth.get();        }    }    datum.getMetaData().put(DEPTH_KEY_W, new IntWritable(newDepth));}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    normalizedScore = conf.getFloat("link.analyze.normalize.score", 1.00f);}
89fdd7122298e467ee01a9f463b423fa9405ab98df3d1247ebce0e733465af3f
distributeScoreToOutlinks
public CrawlDatum distributeScoreToOutlinks(Text fromUrl, ParseData parseData, Collection<Entry<Text, CrawlDatum>> targets, CrawlDatum adjust, int allCount) throws ScoringFilterException
{    return adjust;}
c7d75ff32784416ea95ea0863f39cb7d0da44832579d23df72069418eb890bf5
generatorSortValue
public float generatorSortValue(Text url, CrawlDatum datum, float initSort) throws ScoringFilterException
{    return datum.getScore() * initSort;}
d2a95754238ce8e7ee9557976c163d8b3860456f1815caeadede92b2c9ee04fa
indexerScore
public float indexerScore(Text url, NutchDocument doc, CrawlDatum dbDatum, CrawlDatum fetchDatum, Parse parse, Inlinks inlinks, float initScore) throws ScoringFilterException
{    if (dbDatum == null) {        return initScore;    }    return (normalizedScore * dbDatum.getScore());}
2dcbf82c99c2e2b740c6a208c3e1e729c537864ed30748e09cdb44bbfad01075
initialScore
public void initialScore(Text url, CrawlDatum datum) throws ScoringFilterException
{    datum.setScore(initialScore);}
0b6feb77383ae8d81d2c30e18bf6315732aeabecd96f00250a9915d31f7fbc88
injectedScore
public void injectedScore(Text url, CrawlDatum datum) throws ScoringFilterException
{}
b9e96bf8d75863926c418ca10c8e728ef083a9a13368adf5af855a1fa573c6c7
passScoreAfterParsing
public void passScoreAfterParsing(Text url, Content content, Parse parse) throws ScoringFilterException
{    parse.getData().getContentMeta().set(Nutch.SCORE_KEY, content.getMetadata().get(Nutch.SCORE_KEY));}
53571795b495728e7ad1dc9749d44ee6378e3f595ad89330bb07ce03d5f44873
passScoreBeforeParsing
public void passScoreBeforeParsing(Text url, CrawlDatum datum, Content content) throws ScoringFilterException
{    content.getMetadata().set(Nutch.SCORE_KEY, "" + datum.getScore());}
021571540bd16053b37a45bee8e233da357044b2982932447da62f33fd6e6f2a
updateDbScore
public void updateDbScore(Text url, CrawlDatum old, CrawlDatum datum, List<CrawlDatum> inlinked) throws ScoringFilterException
{}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    scorePower = conf.getFloat("indexer.score.power", 0.5f);    internalScoreFactor = conf.getFloat("db.score.link.internal", 1.0f);    externalScoreFactor = conf.getFloat("db.score.link.external", 1.0f);    countFiltered = conf.getBoolean("db.score.count.filtered", false);}
0b6feb77383ae8d81d2c30e18bf6315732aeabecd96f00250a9915d31f7fbc88
injectedScore
public void injectedScore(Text url, CrawlDatum datum) throws ScoringFilterException
{}
2dcbf82c99c2e2b740c6a208c3e1e729c537864ed30748e09cdb44bbfad01075
initialScore
public void initialScore(Text url, CrawlDatum datum) throws ScoringFilterException
{    datum.setScore(0.0f);}
c7d75ff32784416ea95ea0863f39cb7d0da44832579d23df72069418eb890bf5
generatorSortValue
public float generatorSortValue(Text url, CrawlDatum datum, float initSort) throws ScoringFilterException
{    return datum.getScore() * initSort;}
021571540bd16053b37a45bee8e233da357044b2982932447da62f33fd6e6f2a
updateDbScore
public void updateDbScore(Text url, CrawlDatum old, CrawlDatum datum, List<CrawlDatum> inlinked) throws ScoringFilterException
{    float adjust = 0.0f;    for (int i = 0; i < inlinked.size(); i++) {        CrawlDatum linked = inlinked.get(i);        adjust += linked.getScore();    }    if (old == null)        old = datum;    datum.setScore(old.getScore() + adjust);}
3dfdf875d54a6f956cd76620352021c016ef8325d95a527b2a70efda06758b88
passScoreBeforeParsing
public void passScoreBeforeParsing(Text url, CrawlDatum datum, Content content)
{    content.getMetadata().set(Nutch.SCORE_KEY, "" + datum.getScore());}
2965a8191199b2ed7659416104c7a9fd72b5aa4a422bbba9acb46a9e7d7b576e
passScoreAfterParsing
public void passScoreAfterParsing(Text url, Content content, Parse parse)
{    parse.getData().getContentMeta().set(Nutch.SCORE_KEY, content.getMetadata().get(Nutch.SCORE_KEY));}
89fdd7122298e467ee01a9f463b423fa9405ab98df3d1247ebce0e733465af3f
distributeScoreToOutlinks
public CrawlDatum distributeScoreToOutlinks(Text fromUrl, ParseData parseData, Collection<Entry<Text, CrawlDatum>> targets, CrawlDatum adjust, int allCount) throws ScoringFilterException
{    float score = scoreInjected;    String scoreString = parseData.getContentMeta().get(Nutch.SCORE_KEY);    if (scoreString != null) {        try {            score = Float.parseFloat(scoreString);        } catch (Exception e) {            LOG.error("Error: ", e);        }    }    int validCount = targets.size();    if (countFiltered) {        score /= allCount;    } else {        if (validCount == 0) {                        return adjust;        }        score /= validCount;    }        float internalScore = score * internalScoreFactor;    float externalScore = score * externalScoreFactor;    for (Entry<Text, CrawlDatum> target : targets) {        try {            String toHost = new URL(target.getKey().toString()).getHost();            String fromHost = new URL(fromUrl.toString()).getHost();            if (toHost.equalsIgnoreCase(fromHost)) {                target.getValue().setScore(internalScore);            } else {                target.getValue().setScore(externalScore);            }        } catch (MalformedURLException e) {            LOG.error("Error: ", e);            target.getValue().setScore(externalScore);        }    }        return adjust;}
d2a95754238ce8e7ee9557976c163d8b3860456f1815caeadede92b2c9ee04fa
indexerScore
public float indexerScore(Text url, NutchDocument doc, CrawlDatum dbDatum, CrawlDatum fetchDatum, Parse parse, Inlinks inlinks, float initScore) throws ScoringFilterException
{    if (dbDatum == null) {        return initScore;    }    return (float) Math.pow(dbDatum.getScore(), scorePower) * initScore;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    markGoneAfter = conf.getInt("scoring.orphan.mark.gone.after", DEFAULT_GONE_TIME);    markOrphanAfter = conf.getInt("scoring.orphan.mark.orphan.after", DEFAULT_ORPHAN_TIME);    if (markGoneAfter > markOrphanAfter) {        LOG.warn("OrphanScoringFilter: the time span after which pages are marked" + " as gone is larger than that to mark pages as orphaned" + " (scoring.orphan.mark.gone.after > scoring.orphan.mark.orphan.after):" + " This disables marking pages as gone.");    }}
ceda63f98cdc79ca7efdcc5cb586bbbaa1f604c2195c1457d6727bbf54e3429a
updateDbScore
public void updateDbScore(Text url, CrawlDatum old, CrawlDatum datum, List<CrawlDatum> inlinks) throws ScoringFilterException
{    int now = (int) (System.currentTimeMillis() / 1000);        if (inlinks.size() > 0) {                datum.getMetaData().put(ORPHAN_KEY_WRITABLE, new IntWritable(now));    } else {        orphanedScore(url, datum);    }}
73a9a5a21eccae2ff8798bc71724fcb837c4fd43fe7d7521b97b9c9b985d7bc0
orphanedScore
public void orphanedScore(Text url, CrawlDatum datum)
{        if (datum.getMetaData().containsKey(ORPHAN_KEY_WRITABLE)) {                IntWritable writable = (IntWritable) datum.getMetaData().get(ORPHAN_KEY_WRITABLE);        int lastInlinkTime = writable.get();        int now = (int) (System.currentTimeMillis() / 1000);        int elapsedSinceLastInLinkTime = now - lastInlinkTime;        if (elapsedSinceLastInLinkTime > markOrphanAfter) {                        datum.setStatus(CrawlDatum.STATUS_DB_ORPHAN);        } else if (elapsedSinceLastInLinkTime > markGoneAfter) {                        datum.setStatus(CrawlDatum.STATUS_DB_GONE);        }    }}
c76939c9593fe08e7d50e0adb816b2c24adb068d2ca75addf963478c33b6c1a3
testOrphanScoringFilter
public void testOrphanScoringFilter() throws Exception
{    Configuration conf = NutchConfiguration.create();    conf.setInt("scoring.orphan.mark.gone.after", 5);    conf.setInt("scoring.orphan.mark.orphan.after", 10);    ScoringFilter filter = new OrphanScoringFilter();    filter.setConf(conf);    Text url = new Text("http://nutch.apache.org/");    CrawlDatum datum = new CrawlDatum();    datum.setStatus(CrawlDatum.STATUS_DB_NOTMODIFIED);    List<CrawlDatum> emptyListOfInlinks = new ArrayList<CrawlDatum>();    List<CrawlDatum> populatedListOfInlinks = new ArrayList<CrawlDatum>();    populatedListOfInlinks.add(datum);        filter.updateDbScore(url, null, datum, populatedListOfInlinks);    int firstOrphanTime = getTime(datum);    assertTrue(datum.getMetaData().containsKey(OrphanScoringFilter.ORPHAN_KEY_WRITABLE));        try {        Thread.sleep(1000);    } catch (Exception e) {    }        filter.updateDbScore(url, null, datum, populatedListOfInlinks);    int secondOrphanTime = getTime(datum);    assertTrue(secondOrphanTime > firstOrphanTime);            filter.updateDbScore(url, null, datum, emptyListOfInlinks);    int thirdOrphanTime = getTime(datum);    assertEquals(thirdOrphanTime, secondOrphanTime);    assertEquals("Expected status db_notmodified but got " + CrawlDatum.getStatusName(datum.getStatus()), CrawlDatum.STATUS_DB_NOTMODIFIED, datum.getStatus());        try {        Thread.sleep(1000);    } catch (Exception e) {    }            filter.updateDbScore(url, null, datum, emptyListOfInlinks);    assertEquals("Expected status db_notmodified but got " + CrawlDatum.getStatusName(datum.getStatus()), CrawlDatum.STATUS_DB_NOTMODIFIED, datum.getStatus());        try {        Thread.sleep(5000);    } catch (Exception e) {    }        filter.updateDbScore(url, null, datum, emptyListOfInlinks);    int fourthOrphanTime = getTime(datum);    assertEquals(fourthOrphanTime, thirdOrphanTime);    assertEquals("Expected status db_gone but got " + CrawlDatum.getStatusName(datum.getStatus()), CrawlDatum.STATUS_DB_GONE, datum.getStatus());        try {        Thread.sleep(5000);    } catch (Exception e) {    }        filter.updateDbScore(url, null, datum, emptyListOfInlinks);    assertEquals("Expected status db_orphan but got " + CrawlDatum.getStatusName(datum.getStatus()), CrawlDatum.STATUS_DB_ORPHAN, datum.getStatus());}
9bdf57770cdc9a50feb30ab4b3b88f77356a92063d75f63ffb426ebf878e6238
getTime
protected int getTime(CrawlDatum datum)
{    IntWritable writable = (IntWritable) datum.getMetaData().get(OrphanScoringFilter.ORPHAN_KEY_WRITABLE);    return writable.get();}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
4121f8ef8e5d6cefe01f5831ebfe928f191a71cf03bd40899c66746d86bea512
setURLScoreAfterParsing
public float setURLScoreAfterParsing(Text url, Content content, Parse parse)
{    float score = 1;    try {        if (!Model.isModelCreated) {            Model.createModel(conf);        }        String metatags = parse.getData().getParseMeta().get("metatag.keyword");        String metaDescription = parse.getData().getParseMeta().get("metatag.description");        int[] ngramArr = Model.retrieveNgrams(conf);        int mingram = ngramArr[0];        int maxgram = ngramArr[1];        DocVector docVector = Model.createDocVector(parse.getText() + metaDescription + metatags, mingram, maxgram);        if (docVector != null) {            score = Model.computeCosineSimilarity(docVector);            LOG.info("Setting score of {} to {}", url, score);        } else {            throw new Exception("Could not create DocVector from parsed text");        }    } catch (Exception e) {        LOG.error("Error creating Cosine Model, setting scores of urls to 1 : {}", StringUtils.stringifyException(e));    }    return score;}
172fa9b6431222f92222699c324fbdb979a65b984114dc34e1c69c1fd13594f5
distributeScoreToOutlinks
public CrawlDatum distributeScoreToOutlinks(Text fromUrl, ParseData parseData, Collection<Entry<Text, CrawlDatum>> targets, CrawlDatum adjust, int allCount)
{    float score = Float.parseFloat(parseData.getContentMeta().get(Nutch.SCORE_KEY));    for (Entry<Text, CrawlDatum> target : targets) {        target.getValue().setScore(score);    }    return adjust;}
d39a6115c09d15b33e25325c81a6a4b4740d4143851919914814e6adddd9ac1b
setTermFreqVector
public void setTermFreqVector(HashMap<String, Integer> termFreqVector)
{    this.termFreqVector = termFreqVector;}
f1db67432668f0587c9ff55aaa8692b96e9afc9e9a4bc503cb2396bcabf41944
setVectorEntry
public void setVectorEntry(int pos, long freq)
{    termVector.put(pos, freq);}
29add96ec1370379f8c06db3e35c1c4e2ca1a090af7cc35d49f554882e8b7ee6
dotProduct
public float dotProduct(DocVector docVector)
{    float product = 0;    for (Map.Entry<String, Integer> entry : termFreqVector.entrySet()) {        if (docVector.termFreqVector.containsKey(entry.getKey())) {            product += docVector.termFreqVector.get(entry.getKey()) * entry.getValue();        }    }    return product;}
d2d1c51386e995344b19db639a96c54db738f1cc6aa56c85d09c4449d9af1f5d
getL2Norm
public float getL2Norm()
{    float sum = 0;    for (Map.Entry<String, Integer> entry : termFreqVector.entrySet()) {        sum += entry.getValue() * entry.getValue();    }    return (float) Math.sqrt(sum);}
cb1d84c6e055cdcdaeb6ff7059d6b6d755ceaf7566146e241c59ceb1d510bd5d
createModel
public static synchronized void createModel(Configuration conf) throws IOException
{    if (isModelCreated) {        LOG.info("Model exists, skipping model creation");        return;    }    LOG.info("Creating Cosine model");    try {                if (!conf.get("scoring.similarity.stopword.file").equals("stopwords.txt.template")) {            stopWords = new ArrayList<String>();            String stopWord;            BufferedReader br = new BufferedReader(conf.getConfResourceAsReader((conf.get("scoring.similarity.stopword.file"))));            while ((stopWord = br.readLine()) != null) {                stopWords.add(stopWord);            }            LOG.info("Loaded custom stopwords from {}", conf.get("scoring.similarity.stopword.file"));        }        int[] ngramArr = retrieveNgrams(conf);        int mingram = ngramArr[0];        int maxgram = ngramArr[1];        LOG.info("Value of mingram: {} maxgram: {}", mingram, maxgram);                String line;        StringBuilder sb = new StringBuilder();        BufferedReader br = new BufferedReader(conf.getConfResourceAsReader((conf.get("cosine.goldstandard.file"))));        while ((line = br.readLine()) != null) {            sb.append(line);        }        DocVector goldStandard = createDocVector(sb.toString(), mingram, maxgram);        if (goldStandard != null)            docVectors.add(goldStandard);        else {            throw new Exception("Could not create DocVector for goldstandard");        }    } catch (Exception e) {        LOG.warn("Failed to add {} to model : {}", conf.get("cosine.goldstandard.file", "goldstandard.txt.template"), StringUtils.stringifyException(e));    }    if (docVectors.size() > 0) {        LOG.info("Cosine model creation complete");        isModelCreated = true;    } else        LOG.info("Cosine model creation failed");}
e35db57790d1ac76736058675bd98e9d35086f635802b6f69a0ecb110151789f
createDocVector
public static DocVector createDocVector(String content, int mingram, int maxgram)
{    LuceneTokenizer tokenizer;    if (mingram > 1 && maxgram > 1) {        LOG.info("Using Ngram Cosine Model, user specified mingram value : {} maxgram value : {}", mingram, maxgram);        tokenizer = new LuceneTokenizer(content, TokenizerType.STANDARD, StemFilterType.PORTERSTEM_FILTER, mingram, maxgram);    } else if (mingram > 1) {        maxgram = mingram;        LOG.info("Using Ngram Cosine Model, user specified mingram value : {} maxgram value : {}", mingram, maxgram);        tokenizer = new LuceneTokenizer(content, TokenizerType.STANDARD, StemFilterType.PORTERSTEM_FILTER, mingram, maxgram);    } else if (stopWords != null) {        tokenizer = new LuceneTokenizer(content, TokenizerType.STANDARD, stopWords, true, StemFilterType.PORTERSTEM_FILTER);    } else {        tokenizer = new LuceneTokenizer(content, TokenizerType.STANDARD, true, StemFilterType.PORTERSTEM_FILTER);    }    TokenStream tStream = tokenizer.getTokenStream();    HashMap<String, Integer> termVector = new HashMap<>();    try {        CharTermAttribute charTermAttribute = tStream.addAttribute(CharTermAttribute.class);        tStream.reset();        while (tStream.incrementToken()) {            String term = charTermAttribute.toString();            LOG.debug(term);            if (termVector.containsKey(term)) {                int count = termVector.get(term);                count++;                termVector.put(term, count);            } else {                termVector.put(term, 1);            }        }        DocVector docVector = new DocVector();        docVector.setTermFreqVector(termVector);        return docVector;    } catch (IOException e) {        LOG.error("Error creating DocVector : {}", StringUtils.stringifyException(e));    }    return null;}
cc8fdfa8530ae255bcc9058907362e4222710b93fc19a2a9d7e89c237b911919
computeCosineSimilarity
public static float computeCosineSimilarity(DocVector docVector)
{    float[] scores = new float[docVectors.size()];    int i = 0;    float maxScore = 0;    for (DocVector corpusDoc : docVectors) {        float numerator = docVector.dotProduct(corpusDoc);        float denominator = docVector.getL2Norm() * corpusDoc.getL2Norm();        float currentScore = numerator / denominator;        scores[i++] = currentScore;        maxScore = (currentScore > maxScore) ? currentScore : maxScore;    }        return maxScore;}
760456ee5cb27ec853b3ea887341630d0d2edbbb26382b9be0c0ef0d8ca8f3ae
retrieveNgrams
public static int[] retrieveNgrams(Configuration conf)
{    int[] ngramArr = new int[2];        String[] ngramStr = conf.getStrings("scoring.similarity.ngrams", "1,1");        ngramArr[0] = Integer.parseInt(ngramStr[0]);    if (ngramStr.length > 1) {                ngramArr[1] = Integer.parseInt(ngramStr[1]);    } else {                ngramArr[1] = ngramArr[0];    }    return ngramArr;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    switch(conf.get("scoring.similarity.model", "cosine")) {        case "cosine":            similarityModel = (SimilarityModel) new CosineSimilarity();            break;    }    similarityModel.setConf(conf);}
b9e96bf8d75863926c418ca10c8e728ef083a9a13368adf5af855a1fa573c6c7
passScoreAfterParsing
public void passScoreAfterParsing(Text url, Content content, Parse parse) throws ScoringFilterException
{    float score = similarityModel.setURLScoreAfterParsing(url, content, parse);    parse.getData().getContentMeta().set(Nutch.SCORE_KEY, score + "");}
89fdd7122298e467ee01a9f463b423fa9405ab98df3d1247ebce0e733465af3f
distributeScoreToOutlinks
public CrawlDatum distributeScoreToOutlinks(Text fromUrl, ParseData parseData, Collection<Entry<Text, CrawlDatum>> targets, CrawlDatum adjust, int allCount) throws ScoringFilterException
{    similarityModel.distributeScoreToOutlinks(fromUrl, parseData, targets, adjust, allCount);    return adjust;}
d408e3a2b49cab4e5c69f47aa07f760b0e824e598346c57f62e91cedf287ba9b
createComponents
protected TokenStreamComponents createComponents(String fieldName)
{    Tokenizer source = new ClassicTokenizer();    TokenStream filter = new LowerCaseFilter(source);    if (stopSet != null) {        filter = new StopFilter(filter, stopSet);    }    switch(stemFilterType) {        case PORTERSTEM_FILTER:            filter = new PorterStemFilter(filter);            break;        case ENGLISHMINIMALSTEM_FILTER:            filter = new EnglishMinimalStemFilter(filter);            break;        default:            break;    }    return new TokenStreamComponents(source, filter);}
38c3199239567f2954de6acf5d36f7db2112c596db36401f2f380bcde17129c3
getTokenStream
public TokenStream getTokenStream()
{    return tokenStream;}
350de98e05cabf1eb46f4dc564f5393801333fd4c729507c7066dfe484dcaa3c
createTokenStream
private TokenStream createTokenStream(String content)
{    tokenStream = generateTokenStreamFromText(content, tokenizer);    tokenStream = new LowerCaseFilter(tokenStream);    if (stopSet != null) {        tokenStream = applyStopFilter(stopSet);    }    tokenStream = applyStemmer(stemFilterType);    return tokenStream;}
96eaff9defbfdb13e57cff8bd85f8a463c543fac6668308ef6d8fa913a0cf25b
generateTokenStreamFromText
private TokenStream generateTokenStreamFromText(String content, TokenizerType tokenizerType)
{    Tokenizer tokenizer = null;    switch(tokenizerType) {        case CLASSIC:            tokenizer = new ClassicTokenizer();            break;        case STANDARD:        default:            tokenizer = new StandardTokenizer();    }    tokenizer.setReader(new StringReader(content));    tokenStream = tokenizer;    return tokenStream;}
709fb9863137ba0d5780c8e75f8bf7b9148184d7d6c911d4045d71f17537e0fe
createNGramTokenStream
private TokenStream createNGramTokenStream(String content, int mingram, int maxgram)
{    Tokenizer tokenizer = new StandardTokenizer();    tokenizer.setReader(new StringReader(content));    tokenStream = new LowerCaseFilter(tokenizer);    tokenStream = applyStemmer(stemFilterType);    ShingleFilter shingleFilter = new ShingleFilter(tokenStream, mingram, maxgram);    shingleFilter.setOutputUnigrams(false);    tokenStream = (TokenStream) shingleFilter;    return tokenStream;}
cf111e8d8a6d2ec4a7f9844d24b59931c2d2365b03576d6ea86f39a7accb2800
applyStopFilter
private TokenStream applyStopFilter(CharArraySet stopWords)
{    tokenStream = new StopFilter(tokenStream, stopWords);    return tokenStream;}
01387138e8c6d7fcdfe15215ffb68a28dbcd68347ae286eef5f789ff93480ce3
applyStemmer
private TokenStream applyStemmer(StemFilterType stemFilterType)
{    switch(stemFilterType) {        case ENGLISHMINIMALSTEM_FILTER:            tokenStream = new EnglishMinimalStemFilter(tokenStream);            break;        case PORTERSTEM_FILTER:            tokenStream = new PorterStemFilter(tokenStream);            break;        default:            break;    }    return tokenStream;}
d667ea730391cbc9bac99343e6e8c0d7b9052ef97a6279f28aab5e17b6f02ab5
init
protected void init()
{    try {        if (LOG.isInfoEnabled()) {            LOG.info("initializing CollectionManager");        }                configfile = getConf().getResource(getConf().get("subcollections.config", DEFAULT_FILE_NAME));        InputStream input = getConf().getConfResourceAsInputStream(getConf().get("subcollections.config", DEFAULT_FILE_NAME));        parse(input);    } catch (Exception e) {        if (LOG.isWarnEnabled()) {            LOG.warn("Error occured:" + e);        }    }}
93a50450be1347caa548b05fb738a770786a296c8198d311cc6bde71f6c0a3b4
parse
protected void parse(InputStream input)
{    Element collections = DomUtil.getDom(input);    if (collections != null) {        NodeList nodeList = collections.getElementsByTagName(Subcollection.TAG_COLLECTION);        if (LOG.isInfoEnabled()) {            LOG.info("file has " + nodeList.getLength() + " elements");        }        for (int i = 0; i < nodeList.getLength(); i++) {            Element scElem = (Element) nodeList.item(i);            Subcollection subCol = new Subcollection(getConf());            subCol.initialize(scElem);            collectionMap.put(subCol.name, subCol);        }    } else if (LOG.isInfoEnabled()) {        LOG.info("Cannot find collections");    }}
b213f00cfd6546063f1ab0e58cac8c842a81841a83c7f603b21df5055cd78987
getCollectionManager
public static CollectionManager getCollectionManager(Configuration conf)
{    String key = "collectionmanager";    ObjectCache objectCache = ObjectCache.get(conf);    CollectionManager impl = (CollectionManager) objectCache.getObject(key);    if (impl == null) {        try {            if (LOG.isInfoEnabled()) {                LOG.info("Instantiating CollectionManager");            }            impl = new CollectionManager(conf);            objectCache.setObject(key, impl);        } catch (Exception e) {            throw new RuntimeException("Couldn't create CollectionManager", e);        }    }    return impl;}
906f51b86d8a0dd01c8bca6b1a09b11150e2b14e78c28f23c8b081575ac1ac56
getSubColection
public Subcollection getSubColection(final String id)
{    return (Subcollection) collectionMap.get(id);}
ec74848211816e984aeaa8f19642a33c819aac0c22a7b39e7ce417869576dd7b
deleteSubCollection
public void deleteSubCollection(final String id) throws IOException
{    final Subcollection subCol = getSubColection(id);    if (subCol != null) {        collectionMap.remove(id);    }}
8ba0703d8d4806a3511ba6e24e79d4932a3e0f45767f5c3241f02b87990a7dbe
createSubCollection
public Subcollection createSubCollection(final String id, final String name)
{    Subcollection subCol = null;    if (!collectionMap.containsKey(id)) {        subCol = new Subcollection(id, name, getConf());        collectionMap.put(id, subCol);    }    return subCol;}
0506bae089cc757fc3f05323f22c75408bde7533b3d28c93f64fd461d1e1fe18
getSubCollections
public List<Subcollection> getSubCollections(final String url)
{    List<Subcollection> collections = new ArrayList<Subcollection>();    final Iterator iterator = collectionMap.values().iterator();    while (iterator.hasNext()) {        final Subcollection subCol = (Subcollection) iterator.next();        if (subCol.filter(url) != null) {            collections.add(subCol);        }    }    if (LOG.isTraceEnabled()) {        LOG.trace("subcollections:" + Arrays.toString(collections.toArray()));    }    return collections;}
9a23577e5b3643e9ef7e6fdc9a57cfc0334a7a93de61cab112f4fab255e8807b
getAll
public Collection getAll()
{    return collectionMap.values();}
cf9955e2f63206822eb88f2a2326b23edfff74f8b9f854df03c52b364f748f36
save
public void save() throws IOException
{    try {        final FileOutputStream fos = new FileOutputStream(new File(configfile.getFile()));        final Document doc = new DocumentImpl();        final Element collections = doc.createElement(Subcollection.TAG_COLLECTIONS);        final Iterator iterator = collectionMap.values().iterator();        while (iterator.hasNext()) {            final Subcollection subCol = (Subcollection) iterator.next();            final Element collection = doc.createElement(Subcollection.TAG_COLLECTION);            collections.appendChild(collection);            final Element name = doc.createElement(Subcollection.TAG_NAME);            name.setNodeValue(subCol.getName());            collection.appendChild(name);            final Element whiteList = doc.createElement(Subcollection.TAG_WHITELIST);            whiteList.setNodeValue(subCol.getWhiteListString());            collection.appendChild(whiteList);            final Element blackList = doc.createElement(Subcollection.TAG_BLACKLIST);            blackList.setNodeValue(subCol.getBlackListString());            collection.appendChild(blackList);        }        DomUtil.saveDom(fos, collections);        fos.flush();        fos.close();    } catch (FileNotFoundException e) {        throw new IOException(e.toString());    }}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
71dcee8caa732fdfbbc9042fbd951dc9dfd911ed9a4cabf0966856ac5de53dfc
getKey
public String getKey()
{    return key;}
09e8f13a9a603d31d64bb498b77d15572483824d843d0e82a570643192f62186
getId
public String getId()
{    return id;}
83af96b01a7f6da65089b9fd019e3eaa0bbb1b36f79a31e2b4d33959c2cfac20
getWhiteList
public List<String> getWhiteList()
{    return whiteList;}
6ec36843767d6516e5f62f50a37435eca0bb24a62d4666851ed8edca69676227
getWhiteListString
public String getWhiteListString()
{    return wlString;}
19dae79b3f2943f1405c814b53c06e58fdfad82a098753d3865be52f03e8eccb
getBlackListString
public String getBlackListString()
{    return blString;}
11388ca7119f8c7feecb56e7af5f875b7faf0578b0e1480e27b84b4f66e6cff6
setWhiteList
public void setWhiteList(ArrayList<String> whiteList)
{    this.whiteList = whiteList;}
0da3a5782baf480296c1da37a6af453893957766ce42877fca9c046ba2249cdc
filter
public String filter(String urlString)
{        Iterator<String> i = blackList.iterator();    while (i.hasNext()) {        String row = (String) i.next();        if (urlString.contains(row))            return null;    }        i = whiteList.iterator();    while (i.hasNext()) {        String row = (String) i.next();        if (urlString.contains(row))            return urlString;    }    return null;}
a4b685a210c170c81edff5d3ed30c6e7ee2038c512f5e98dca1f2a08c1bdae36
initialize
public void initialize(Element collection)
{    this.id = DOMUtil.getChildText(collection.getElementsByTagName(TAG_ID).item(0)).trim();    this.name = DOMUtil.getChildText(collection.getElementsByTagName(TAG_NAME).item(0)).trim();    this.wlString = DOMUtil.getChildText(collection.getElementsByTagName(TAG_WHITELIST).item(0)).trim();    parseList(this.whiteList, wlString);        NodeList nodeList = collection.getElementsByTagName(TAG_BLACKLIST);    if (nodeList.getLength() > 0) {        this.blString = DOMUtil.getChildText(nodeList.item(0)).trim();        parseList(this.blackList, blString);    }        nodeList = collection.getElementsByTagName(TAG_KEY);    if (nodeList.getLength() == 1) {        this.key = DOMUtil.getChildText(nodeList.item(0)).trim();    }}
50b051e4f3da50d1bc6af03d7b41f6331983736d49b81e63e530e2c001ff3736
parseList
protected void parseList(List<String> list, String text)
{    list.clear();    StringTokenizer st = new StringTokenizer(text, "\n\r");    while (st.hasMoreElements()) {        String line = (String) st.nextElement();        line = line.trim();        if (caseInsensitive) {            line = line.toLowerCase();        }        list.add(line);    }}
73aff960c13a193605bcc07d6c841d2c60890f4c4d2b69295ce87dac4b863e38
setBlackList
public void setBlackList(String list)
{    this.blString = list;    parseList(blackList, list);}
cc66cf9cf6a8e21aa091e5e5d6db5fe78b690978d9c5c0b816b110cc81b2c90c
setWhiteList
public void setWhiteList(String list)
{    this.wlString = list;    parseList(whiteList, list);}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    fieldName = conf.get("subcollection.default.fieldname", "subcollection");    metadataSource = conf.get("subcollection.metadata.source", "subcollection");    caseInsensitive = conf.getBoolean("subcollection.case.insensitive", false);}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
9d1bc276f58be5eebab2dcf11a7b56cdeda256d75822e1786486ee3cc7f5d2bf
addSubCollectionField
private void addSubCollectionField(NutchDocument doc, String url)
{    for (Subcollection coll : CollectionManager.getCollectionManager(getConf()).getSubCollections(url)) {        if (coll.getKey() == null) {            doc.add(fieldName, coll.getName());        } else {            doc.add(coll.getKey(), coll.getName());        }    }}
8fa98404280fecfd497ce9400c07196998fbeaf2ee8524779c09bd3c220d4ea9
filter
public NutchDocument filter(NutchDocument doc, Parse parse, Text url, CrawlDatum datum, Inlinks inlinks) throws IndexingException
{        String subcollection = parse.getData().getMeta(metadataSource);    if (subcollection != null) {        subcollection = subcollection.trim();        if (subcollection.length() > 0) {            doc.add(fieldName, subcollection);            return doc;        }    }    String sUrl = url.toString();    if (caseInsensitive) {        sUrl = sUrl.toLowerCase();    }    addSubCollectionField(doc, sUrl);    return doc;}
2562863be7d5edba0b97547b2b5cfe79575c750a1f2a5e641c828e0acb0202aa
testFilter
public void testFilter() throws Exception
{    Subcollection sc = new Subcollection(NutchConfiguration.create());    sc.setWhiteList("www.nutch.org\nwww.apache.org");    sc.setBlackList("jpg\nwww.apache.org/zecret/");        Assert.assertEquals("http://www.apache.org/index.html", sc.filter("http://www.apache.org/index.html"));        Assert.assertEquals(null, sc.filter("http://www.apache.org/zecret/index.html"));    Assert.assertEquals(null, sc.filter("http://www.apache.org/img/image.jpg"));        Assert.assertEquals(null, sc.filter("http://www.google.com/"));}
8071a4f14e5ca9968fbd67aa838abafcc85968da48c71108b891152ecc83220a
testInput
public void testInput()
{    StringBuffer xml = new StringBuffer();    xml.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");    xml.append("<!-- just a comment -->");    xml.append("<subcollections>");    xml.append("<subcollection>");    xml.append("<name>nutch collection</name>");    xml.append("<id>nutch</id>");    xml.append("<whitelist>");    xml.append("http://lucene.apache.org/nutch/\n");    xml.append("http://wiki.apache.org/nutch/\n");    xml.append("</whitelist>");    xml.append("<blacklist>");    xml.append("http://www.xxx.yyy\n");    xml.append("</blacklist>");    xml.append("</subcollection>");    xml.append("</subcollections>");    InputStream is = new ByteArrayInputStream(xml.toString().getBytes());    CollectionManager cm = new CollectionManager();    cm.parse(is);    Collection<?> c = cm.getAll();        Assert.assertEquals(1, c.size());    Subcollection collection = (Subcollection) c.toArray()[0];        Assert.assertEquals("nutch", collection.getId());        Assert.assertEquals("nutch collection", collection.getName());        Assert.assertEquals(2, collection.whiteList.size());    String wlUrl = (String) collection.whiteList.get(0);    Assert.assertEquals("http://lucene.apache.org/nutch/", wlUrl);    wlUrl = (String) collection.whiteList.get(1);    Assert.assertEquals("http://wiki.apache.org/nutch/", wlUrl);        Assert.assertEquals("http://lucene.apache.org/nutch/", collection.filter("http://lucene.apache.org/nutch/"));        Assert.assertEquals(1, collection.blackList.size());    String blUrl = (String) collection.blackList.get(0);    Assert.assertEquals("http://www.xxx.yyy", blUrl);        Assert.assertEquals(null, collection.filter("http://www.google.com/"));}
fbddf5b34cf92dbf8275343f9eed6f2a8f38be544d59beba2e03a07b5c4a608d
filter
public NutchDocument filter(NutchDocument doc, Parse parse, Text urlText, CrawlDatum datum, Inlinks inlinks) throws IndexingException
{    try {        URL url = new URL(urlText.toString());        DomainSuffix d = URLUtil.getDomainSuffix(url);        doc.add("tld", d.getDomain());    } catch (Exception ex) {        LOG.warn(ex.toString());    }    return doc;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
d2a95754238ce8e7ee9557976c163d8b3860456f1815caeadede92b2c9ee04fa
indexerScore
public float indexerScore(Text url, NutchDocument doc, CrawlDatum dbDatum, CrawlDatum fetchDatum, Parse parse, Inlinks inlinks, float initScore) throws ScoringFilterException
{    NutchField tlds = doc.getField("tld");    float boost = 1.0f;    if (tlds != null) {        for (Object tld : tlds.getValues()) {            DomainSuffix entry = tldEntries.get(tld.toString());            if (entry != null)                boost *= entry.getBoost();        }    }    return initScore * boost;}
6ea9ef1e2c6b87f183f5bfb0e553705d0ac4666fefbcf1c72303362f5a56d5d4
distributeScoreToOutlink
public CrawlDatum distributeScoreToOutlink(Text fromUrl, Text toUrl, ParseData parseData, CrawlDatum target, CrawlDatum adjust, int allCount, int validCount) throws ScoringFilterException
{    return adjust;}
c7d75ff32784416ea95ea0863f39cb7d0da44832579d23df72069418eb890bf5
generatorSortValue
public float generatorSortValue(Text url, CrawlDatum datum, float initSort) throws ScoringFilterException
{    return initSort;}
2dcbf82c99c2e2b740c6a208c3e1e729c537864ed30748e09cdb44bbfad01075
initialScore
public void initialScore(Text url, CrawlDatum datum) throws ScoringFilterException
{}
0b6feb77383ae8d81d2c30e18bf6315732aeabecd96f00250a9915d31f7fbc88
injectedScore
public void injectedScore(Text url, CrawlDatum datum) throws ScoringFilterException
{}
b9e96bf8d75863926c418ca10c8e728ef083a9a13368adf5af855a1fa573c6c7
passScoreAfterParsing
public void passScoreAfterParsing(Text url, Content content, Parse parse) throws ScoringFilterException
{}
53571795b495728e7ad1dc9749d44ee6378e3f595ad89330bb07ce03d5f44873
passScoreBeforeParsing
public void passScoreBeforeParsing(Text url, CrawlDatum datum, Content content) throws ScoringFilterException
{}
021571540bd16053b37a45bee8e233da357044b2982932447da62f33fd6e6f2a
updateDbScore
public void updateDbScore(Text url, CrawlDatum old, CrawlDatum datum, List<CrawlDatum> inlinked) throws ScoringFilterException
{}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
89fdd7122298e467ee01a9f463b423fa9405ab98df3d1247ebce0e733465af3f
distributeScoreToOutlinks
public CrawlDatum distributeScoreToOutlinks(Text fromUrl, ParseData parseData, Collection<Entry<Text, CrawlDatum>> targets, CrawlDatum adjust, int allCount) throws ScoringFilterException
{    return adjust;}
6183d6d778976ac871832651a0627630e66a4330fdc00b5d000e48b5a5f5b08c
getRulesReader
protected Reader getRulesReader(Configuration conf) throws IOException
{    String stringRules = conf.get(URLFILTER_AUTOMATON_RULES);    if (stringRules != null) {        return new StringReader(stringRules);    }    String fileRules = conf.get(URLFILTER_AUTOMATON_FILE);    return conf.getConfResourceAsReader(fileRules);}
d2dab1fc6858d6aad1aa4cc6e9430c6aec5fbf71d2c194833ee3f3f2bfc2587c
createRule
protected RegexRule createRule(boolean sign, String regex)
{    return new Rule(sign, regex);}
1fde9d6db9be0060515129b8af4f3d152d253c77d4fe707506309ed71dcc0ee1
createRule
protected RegexRule createRule(boolean sign, String regex, String hostOrDomain)
{    return new Rule(sign, regex, hostOrDomain);}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    main(new AutomatonURLFilter(), args);}
a361eb0ce924075bce4bd683c6e82cc1a4df56ccf5a73f48aeab4c43b7f7b189
match
protected boolean match(String url)
{    return automaton.run(url);}
abae7237136b1a95aa847983c284fa28e91aa00359e8391f4e492f709f9960bb
getURLFilter
protected URLFilter getURLFilter(Reader rules)
{    try {        return new AutomatonURLFilter(rules);    } catch (IOException e) {        Assert.fail(e.toString());        return null;    }}
a505a221a080c584c1896dbef1a0d5c74c6ef08b41d9b90521f8bad26d05354c
test
public void test()
{    test("WholeWebCrawling");    test("IntranetCrawling");    bench(50, "Benchmarks");    bench(100, "Benchmarks");    bench(200, "Benchmarks");    bench(400, "Benchmarks");    bench(800, "Benchmarks");}
42a1bc40d33c27e6dd6dc0660839657b3b7af4f6379832d5c9aaad2268891a5c
readConfiguration
private void readConfiguration(Reader configReader) throws IOException
{        BufferedReader reader = new BufferedReader(configReader);    String line = null;    while ((line = reader.readLine()) != null) {        if (StringUtils.isNotBlank(line) && !line.startsWith("#")) {                        domainSet.add(StringUtils.lowerCase(line.trim()));        }    }}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;        String pluginName = "urlfilter-domain";    Extension[] extensions = PluginRepository.get(conf).getExtensionPoint(URLFilter.class.getName()).getExtensions();    for (int i = 0; i < extensions.length; i++) {        Extension extension = extensions[i];        if (extension.getDescriptor().getPluginId().equals(pluginName)) {            attributeFile = extension.getAttribute("file");            break;        }    }        if (attributeFile != null && attributeFile.trim().equals("")) {        attributeFile = null;    }    if (attributeFile != null) {        if (LOG.isInfoEnabled()) {            LOG.info("Attribute \"file\" is defined for plugin " + pluginName + " as " + attributeFile);        }    } else {        if (LOG.isWarnEnabled()) {            LOG.warn("Attribute \"file\" is not defined in plugin.xml for plugin " + pluginName);        }    }        String file = conf.get("urlfilter.domain.file");    String stringRules = conf.get("urlfilter.domain.rules");    if (domainFile != null) {        file = domainFile;    } else if (attributeFile != null) {        file = attributeFile;    }    Reader reader = null;    if (stringRules != null) {                reader = new StringReader(stringRules);    } else {        reader = conf.getConfResourceAsReader(file);    }    try {        if (reader == null) {            reader = new FileReader(file);        }        readConfiguration(reader);    } catch (IOException e) {        LOG.error(org.apache.hadoop.util.StringUtils.stringifyException(e));    }}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
9391d90f04c089d100b5d360c687d3724caed389f84cf9a30c69d36ed624f185
filter
public String filter(String url)
{        if (domainSet.size() == 0)        return url;    try {                        String domain = URLUtil.getDomainName(url).toLowerCase().trim();        String host = URLUtil.getHost(url);        String suffix = null;        DomainSuffix domainSuffix = URLUtil.getDomainSuffix(url);        if (domainSuffix != null) {            suffix = domainSuffix.getDomain();        }        if (domainSet.contains(suffix) || domainSet.contains(domain) || domainSet.contains(host)) {            return url;        }                return null;    } catch (Exception e) {                LOG.error("Could not apply filter on url: " + url + "\n" + org.apache.hadoop.util.StringUtils.stringifyException(e));        return null;    }}
2562863be7d5edba0b97547b2b5cfe79575c750a1f2a5e641c828e0acb0202aa
testFilter
public void testFilter() throws Exception
{    String domainFile = SAMPLES + SEPARATOR + "hosts.txt";    Configuration conf = NutchConfiguration.create();    DomainURLFilter domainFilter = new DomainURLFilter(domainFile);    domainFilter.setConf(conf);    Assert.assertNotNull(domainFilter.filter("http://lucene.apache.org"));    Assert.assertNotNull(domainFilter.filter("http://hadoop.apache.org"));    Assert.assertNotNull(domainFilter.filter("http://www.apache.org"));    Assert.assertNull(domainFilter.filter("http://www.google.com"));    Assert.assertNull(domainFilter.filter("http://mail.yahoo.com"));    Assert.assertNotNull(domainFilter.filter("http://www.foobar.net"));    Assert.assertNotNull(domainFilter.filter("http://www.foobas.net"));    Assert.assertNotNull(domainFilter.filter("http://www.yahoo.com"));    Assert.assertNotNull(domainFilter.filter("http://www.foobar.be"));    Assert.assertNull(domainFilter.filter("http://www.adobe.com"));}
d26fb415c2b37c484db4dcee2717ff37792856005edbcbca1327e8fb2190deb3
testNoFilter
public void testNoFilter() throws Exception
{        String domainFile = SAMPLES + SEPARATOR + "this-file-does-not-exist.txt";    Configuration conf = NutchConfiguration.create();    DomainURLFilter domainFilter = new DomainURLFilter(domainFile);    domainFilter.setConf(conf);    Assert.assertNotNull(domainFilter.filter("http://lucene.apache.org"));    Assert.assertNotNull(domainFilter.filter("http://hadoop.apache.org"));    Assert.assertNotNull(domainFilter.filter("http://www.apache.org"));    Assert.assertNotNull(domainFilter.filter("http://www.google.com"));    Assert.assertNotNull(domainFilter.filter("http://mail.yahoo.com"));    Assert.assertNotNull(domainFilter.filter("http://www.foobar.net"));    Assert.assertNotNull(domainFilter.filter("http://www.foobas.net"));    Assert.assertNotNull(domainFilter.filter("http://www.yahoo.com"));    Assert.assertNotNull(domainFilter.filter("http://www.foobar.be"));    Assert.assertNotNull(domainFilter.filter("http://www.adobe.com"));}
42a1bc40d33c27e6dd6dc0660839657b3b7af4f6379832d5c9aaad2268891a5c
readConfiguration
private void readConfiguration(Reader configReader) throws IOException
{        BufferedReader reader = new BufferedReader(configReader);    String line = null;    while ((line = reader.readLine()) != null) {        if (StringUtils.isNotBlank(line) && !line.startsWith("#")) {                        domainSet.add(StringUtils.lowerCase(line.trim()));        }    }}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;        String pluginName = "urlfilter-domainblacklist";    Extension[] extensions = PluginRepository.get(conf).getExtensionPoint(URLFilter.class.getName()).getExtensions();    for (int i = 0; i < extensions.length; i++) {        Extension extension = extensions[i];        if (extension.getDescriptor().getPluginId().equals(pluginName)) {            attributeFile = extension.getAttribute("file");            break;        }    }        if (attributeFile != null && attributeFile.trim().equals("")) {        attributeFile = null;    }    if (attributeFile != null) {        if (LOG.isInfoEnabled()) {            LOG.info("Attribute \"file\" is defined for plugin " + pluginName + " as " + attributeFile);        }    } else {        if (LOG.isWarnEnabled()) {            LOG.warn("Attribute \"file\" is not defined in plugin.xml for plugin " + pluginName);        }    }        String file = conf.get("urlfilter.domainblacklist.file");    String stringRules = conf.get("urlfilter.domainblacklist.rules");    if (domainFile != null) {        file = domainFile;    } else if (attributeFile != null) {        file = attributeFile;    }    Reader reader = null;    if (stringRules != null) {                reader = new StringReader(stringRules);    } else {        reader = conf.getConfResourceAsReader(file);    }    try {        if (reader == null) {            reader = new FileReader(file);        }        readConfiguration(reader);    } catch (IOException e) {        LOG.error(org.apache.hadoop.util.StringUtils.stringifyException(e));    }}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
9391d90f04c089d100b5d360c687d3724caed389f84cf9a30c69d36ed624f185
filter
public String filter(String url)
{    try {                        String domain = URLUtil.getDomainName(url).toLowerCase().trim();        String host = URLUtil.getHost(url);        String suffix = null;        DomainSuffix domainSuffix = URLUtil.getDomainSuffix(url);        if (domainSuffix != null) {            suffix = domainSuffix.getDomain();        }        if (domainSet.contains(suffix) || domainSet.contains(domain) || domainSet.contains(host)) {                        return null;        }                return url;    } catch (Exception e) {                LOG.error("Could not apply filter on url: " + url + "\n" + org.apache.hadoop.util.StringUtils.stringifyException(e));        return null;    }}
2562863be7d5edba0b97547b2b5cfe79575c750a1f2a5e641c828e0acb0202aa
testFilter
public void testFilter() throws Exception
{    String domainBlacklistFile = SAMPLES + SEPARATOR + "hosts.txt";    Configuration conf = NutchConfiguration.create();    DomainBlacklistURLFilter domainBlacklistFilter = new DomainBlacklistURLFilter(domainBlacklistFile);    domainBlacklistFilter.setConf(conf);    Assert.assertNull(domainBlacklistFilter.filter("http://lucene.apache.org"));    Assert.assertNull(domainBlacklistFilter.filter("http://hadoop.apache.org"));    Assert.assertNull(domainBlacklistFilter.filter("http://www.apache.org"));    Assert.assertNotNull(domainBlacklistFilter.filter("http://www.google.com"));    Assert.assertNotNull(domainBlacklistFilter.filter("http://mail.yahoo.com"));    Assert.assertNull(domainBlacklistFilter.filter("http://www.foobar.net"));    Assert.assertNull(domainBlacklistFilter.filter("http://www.foobas.net"));    Assert.assertNull(domainBlacklistFilter.filter("http://www.yahoo.com"));    Assert.assertNull(domainBlacklistFilter.filter("http://www.foobar.be"));    Assert.assertNotNull(domainBlacklistFilter.filter("http://www.adobe.com"));}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    try {        reloadRules();    } catch (Exception e) {        LOG.error(e.getMessage());        throw new RuntimeException(e.getMessage(), e);    }}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
9391d90f04c089d100b5d360c687d3724caed389f84cf9a30c69d36ed624f185
filter
public String filter(String url)
{    URL u;    try {        u = new URL(url);    } catch (Exception e) {        LOG.debug("Rejected {} because failed to parse as URL: {}", url, e.getMessage());        return null;    }    String hostname = u.getHost();        for (Rule rule : hostRules.get(hostname)) {        if (rule.match(u)) {            return null;        }    }        for (Rule rule : domainRules.get(hostname)) {        if (rule.match(u)) {            return null;        }    }            int start = 0;    int pos;    while ((pos = hostname.indexOf('.', start)) != -1) {        start = pos + 1;        String domain = hostname.substring(start);        for (Rule rule : domainRules.get(domain)) {            if (rule.match(u)) {                return null;            }        }    }        for (Rule rule : domainRules.get(".")) {        if (rule.match(u)) {            return null;        }    }        return url;}
eff7ca1fa7f5b1094e01c41cfd3e2047cfd8295d68e0f3ebb85b13057a74fc98
reloadRules
public void reloadRules() throws IOException
{    String fileRules = conf.get(URLFILTER_FAST_FILE);    try (Reader reader = conf.getConfResourceAsReader(fileRules)) {        reloadRules(reader);    }}
23f264775875278a6bf3cc193d01c7ca8c5ed8e00d1c75aecd43c3a6ea99ec7d
reloadRules
private void reloadRules(Reader rules) throws IOException
{    domainRules.clear();    hostRules.clear();    BufferedReader reader = new BufferedReader(rules);    String current = null;    boolean host = false;    int lineno = 0;    String line;    try {        while ((line = reader.readLine()) != null) {            lineno++;            line = line.trim();            if (line.indexOf("#") != -1) {                                line = line.substring(0, line.indexOf("#")).trim();            }            if (StringUtils.isBlank(line)) {                continue;            }            if (line.startsWith("Host")) {                host = true;                current = line.split("\\s+")[1];            } else if (line.startsWith("Domain")) {                host = false;                current = line.split("\\s+")[1];            } else {                if (current == null) {                    continue;                }                Rule rule = null;                try {                    if (CATCH_ALL_RULE.matcher(line).matches()) {                        rule = DenyAllRule.getInstance();                    } else if (line.startsWith("DenyPathQuery")) {                        rule = new DenyPathQueryRule(line.split("\\s+")[1]);                    } else if (line.startsWith("DenyPath")) {                        rule = new DenyPathRule(line.split("\\s+")[1]);                    } else {                        LOG.warn("Problem reading rule on line {}: {}", lineno, line);                        continue;                    }                } catch (Exception e) {                    LOG.warn("Problem reading rule on line {}: {} - {}", lineno, line, e.getMessage());                    continue;                }                if (host) {                    LOG.trace("Adding host rule [{}] [{}]", current, rule);                    hostRules.put(current, rule);                } else {                    LOG.trace("Adding domain rule [{}] [{}]", current, rule);                    domainRules.put(current, rule);                }            }        }    } catch (IOException e) {        LOG.warn("Caught exception while reading rules file at line {}: {}", lineno, e.getMessage());        throw e;    }}
5bb16832d5acd2b4015c84e4042ba97328b386c612c4a32d6817b7e27142eae1
match
public boolean match(URL url)
{    return pattern.matcher(url.toString()).find();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return pattern.toString();}
5bb16832d5acd2b4015c84e4042ba97328b386c612c4a32d6817b7e27142eae1
match
public boolean match(URL url)
{    String haystack = url.getPath();    return pattern.matcher(haystack).find();}
30b78245ab42122eaa3158e30c304d7eda9f3e2d8c0b9584dcf8864562da4dbc
getInstance
public static Rule getInstance()
{    return instance;}
5bb16832d5acd2b4015c84e4042ba97328b386c612c4a32d6817b7e27142eae1
match
public boolean match(URL url)
{    return true;}
5bb16832d5acd2b4015c84e4042ba97328b386c612c4a32d6817b7e27142eae1
match
public boolean match(URL url)
{    String haystack = url.getFile();    return pattern.matcher(haystack).find();}
abae7237136b1a95aa847983c284fa28e91aa00359e8391f4e492f709f9960bb
getURLFilter
protected URLFilter getURLFilter(Reader rules)
{    try {        return new FastURLFilter(rules);    } catch (IOException e) {        Assert.fail(e.toString());        return null;    }}
a505a221a080c584c1896dbef1a0d5c74c6ef08b41d9b90521f8bad26d05354c
test
public void test()
{    test("fast-urlfilter-test.txt", "test.urls");    test("fast-urlfilter-benchmark.txt", "Benchmarks.urls");}
7d5b408ffb9726aa9542505210a3eb5a3417b92112e024aaf8ed05d3a89f02ce
benchmark
public void benchmark()
{    bench(50, "fast-urlfilter-benchmark.txt", "Benchmarks.urls");    bench(100, "fast-urlfilter-benchmark.txt", "Benchmarks.urls");    bench(200, "fast-urlfilter-benchmark.txt", "Benchmarks.urls");    bench(400, "fast-urlfilter-benchmark.txt", "Benchmarks.urls");    bench(800, "fast-urlfilter-benchmark.txt", "Benchmarks.urls");}
668ef7ad29871fa15f86cf5a4f979843fafc3f8eb93b6aab187beb244540cfe9
getExemptions
public List<Pattern> getExemptions()
{    return exemptions;}
8640d3fe562923baf1c561a97311fb2e633e379f003ab25a620504aaa32e0179
filter
public boolean filter(String fromUrl, String toUrl)
{        return this.filter(toUrl) != null;}
6183d6d778976ac871832651a0627630e66a4330fdc00b5d000e48b5a5f5b08c
getRulesReader
protected Reader getRulesReader(Configuration conf) throws IOException
{    String fileRules = conf.get(DB_IGNORE_EXTERNAL_EXEMPTIONS_FILE);    return conf.getConfResourceAsReader(fileRules);}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    if (args.length != 1) {        System.out.println("Error: Invalid Args");        System.out.println("Usage: " + ExemptionUrlFilter.class.getName() + " <url>");        return;    }    String url = args[0];    ExemptionUrlFilter instance = new ExemptionUrlFilter();    instance.setConf(NutchConfiguration.create());    System.out.println(instance.filter(null, url));}
9391d90f04c089d100b5d360c687d3724caed389f84cf9a30c69d36ed624f185
filter
public String filter(String url)
{    if (trie.shortestMatch(url) == null)        return null;    else        return url;}
048d3166f39af4575d583bd8710a5829da8ca271f2b1671d334ca015ccef6655
readConfiguration
private TrieStringMatcher readConfiguration(Reader reader) throws IOException
{    BufferedReader in = new BufferedReader(reader);    List<String> urlprefixes = new ArrayList<>();    String line;    while ((line = in.readLine()) != null) {        if (line.length() == 0)            continue;        char first = line.charAt(0);        switch(first) {            case ' ':            case '\n':            case             '#':                continue;            default:                urlprefixes.add(line);        }    }    return new PrefixStringMatcher(urlprefixes);}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    PrefixURLFilter filter;    if (args.length >= 1)        filter = new PrefixURLFilter(args[0]);    else        filter = new PrefixURLFilter();    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));    String line;    while ((line = in.readLine()) != null) {        String out = filter.filter(line);        if (out != null) {            System.out.println(out);        }    }}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    String pluginName = "urlfilter-prefix";    Extension[] extensions = PluginRepository.get(conf).getExtensionPoint(URLFilter.class.getName()).getExtensions();    for (int i = 0; i < extensions.length; i++) {        Extension extension = extensions[i];        if (extension.getDescriptor().getPluginId().equals(pluginName)) {            attributeFile = extension.getAttribute("file");            break;        }    }    if (attributeFile != null && attributeFile.trim().equals(""))        attributeFile = null;    if (attributeFile != null) {        if (LOG.isInfoEnabled()) {            LOG.info("Attribute \"file\" is defined for plugin " + pluginName + " as " + attributeFile);        }    } else {                    }    String file = conf.get("urlfilter.prefix.file");    String stringRules = conf.get("urlfilter.prefix.rules");        if (attributeFile != null)        file = attributeFile;    Reader reader = null;    if (stringRules != null) {                reader = new StringReader(stringRules);    } else {        reader = conf.getConfResourceAsReader(file);    }    if (reader == null) {        trie = new PrefixStringMatcher(new String[0]);    } else {        try {            trie = readConfiguration(reader);        } catch (IOException e) {            if (LOG.isErrorEnabled()) {                LOG.error(e.getMessage());            }                        throw new RuntimeException(e.getMessage(), e);        }    }}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
0726523a73bad537f74ac5912d840d3c7fe0c2e304fe52f26dedb3d2e7d7350f
suite
public static Test suite()
{    return new TestSuite(TestPrefixURLFilter.class);}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    TestRunner.run(suite());}
c536957a0359efaba4fa041a9429ed02027b66c9e6f5cc21d07eb308cc675a0d
setUp
public void setUp() throws IOException
{    filter = new PrefixURLFilter(prefixes);}
6888fea167bb8c29b6d6d46e57f39255a60ba534b2f8321dda5122b9e9f96165
testModeAccept
public void testModeAccept()
{    for (int i = 0; i < urls.length; i++) {        assertTrue(urlsModeAccept[i] == filter.filter(urls[i]));    }}
6183d6d778976ac871832651a0627630e66a4330fdc00b5d000e48b5a5f5b08c
getRulesReader
protected Reader getRulesReader(Configuration conf) throws IOException
{    String stringRules = conf.get(URLFILTER_REGEX_RULES);    if (stringRules != null) {        return new StringReader(stringRules);    }    String fileRules = conf.get(URLFILTER_REGEX_FILE);    return conf.getConfResourceAsReader(fileRules);}
d2dab1fc6858d6aad1aa4cc6e9430c6aec5fbf71d2c194833ee3f3f2bfc2587c
createRule
protected RegexRule createRule(boolean sign, String regex)
{    return new Rule(sign, regex);}
1fde9d6db9be0060515129b8af4f3d152d253c77d4fe707506309ed71dcc0ee1
createRule
protected RegexRule createRule(boolean sign, String regex, String hostOrDomain)
{    return new Rule(sign, regex, hostOrDomain);}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    RegexURLFilter filter = new RegexURLFilter();    filter.setConf(NutchConfiguration.create());    main(filter, args);}
a361eb0ce924075bce4bd683c6e82cc1a4df56ccf5a73f48aeab4c43b7f7b189
match
protected boolean match(String url)
{    return pattern.matcher(url).find();}
abae7237136b1a95aa847983c284fa28e91aa00359e8391f4e492f709f9960bb
getURLFilter
protected URLFilter getURLFilter(Reader rules)
{    try {        return new RegexURLFilter(rules);    } catch (IOException e) {        Assert.fail(e.toString());        return null;    }}
a505a221a080c584c1896dbef1a0d5c74c6ef08b41d9b90521f8bad26d05354c
test
public void test()
{    test("WholeWebCrawling");    test("IntranetCrawling");    bench(50, "Benchmarks");    bench(100, "Benchmarks");    bench(200, "Benchmarks");    bench(400, "Benchmarks");    bench(800, "Benchmarks");}
c3d7fae9d28dc1c85df84f27a5231a7f82a2a7aa0c8c6083414d5deb1da078a3
test1838
public void test1838()
{    test("nutch1838");}
9391d90f04c089d100b5d360c687d3724caed389f84cf9a30c69d36ed624f185
filter
public String filter(String url)
{    if (url == null)        return null;    String _url;    if (ignoreCase)        _url = url.toLowerCase();    else        _url = url;    if (filterFromPath) {        try {            URL pUrl = new URL(_url);            _url = pUrl.getPath();        } catch (MalformedURLException e) {                }    }    String a = suffixes.shortestMatch(_url);    if (a == null) {        if (modeAccept)            return url;        else            return null;    } else {        if (modeAccept)            return null;        else            return url;    }}
d53970f2b89e807ac7eb9d7549bade1a1bffa83e386f7364c95b0a15051506d1
readConfiguration
public void readConfiguration(Reader reader) throws IOException
{        if (reader == null) {        if (LOG.isWarnEnabled()) {            LOG.warn("Missing urlfilter.suffix.file, all URLs will be rejected!");        }        suffixes = new SuffixStringMatcher(new String[0]);        modeAccept = false;        ignoreCase = false;        return;    }    BufferedReader in = new BufferedReader(reader);    List<String> aSuffixes = new ArrayList<String>();    boolean allow = false;    boolean ignore = false;    String line;    while ((line = in.readLine()) != null) {        line = line.trim();        if (line.length() == 0)            continue;        char first = line.charAt(0);        switch(first) {            case ' ':            case '\n':            case             '#':                break;            case '-':                allow = false;                if (line.contains("P"))                    filterFromPath = true;                if (line.contains("I"))                    ignore = true;                break;            case '+':                allow = true;                if (line.contains("P"))                    filterFromPath = true;                if (line.contains("I"))                    ignore = true;                break;            default:                aSuffixes.add(line);        }    }    if (ignore) {        for (int i = 0; i < aSuffixes.size(); i++) {            aSuffixes.set(i, ((String) aSuffixes.get(i)).toLowerCase());        }    }    suffixes = new SuffixStringMatcher(aSuffixes);    modeAccept = allow;    ignoreCase = ignore;}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    SuffixURLFilter filter;    if (args.length >= 1)        filter = new SuffixURLFilter(new FileReader(args[0]));    else {        filter = new SuffixURLFilter();        filter.setConf(NutchConfiguration.create());    }    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));    String line;    while ((line = in.readLine()) != null) {        String out = filter.filter(line);        if (out != null) {            System.out.println("ACCEPTED " + out);        } else {            System.out.println("REJECTED " + out);        }    }}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    String pluginName = "urlfilter-suffix";    Extension[] extensions = PluginRepository.get(conf).getExtensionPoint(URLFilter.class.getName()).getExtensions();    for (int i = 0; i < extensions.length; i++) {        Extension extension = extensions[i];        if (extension.getDescriptor().getPluginId().equals(pluginName)) {            attributeFile = extension.getAttribute("file");            break;        }    }    if (attributeFile != null && attributeFile.trim().equals(""))        attributeFile = null;    if (attributeFile != null) {        if (LOG.isInfoEnabled()) {            LOG.info("Attribute \"file\" is defined for plugin " + pluginName + " as " + attributeFile);        }    } else {                    }    String file = conf.get("urlfilter.suffix.file");    String stringRules = conf.get("urlfilter.suffix.rules");        if (attributeFile != null)        file = attributeFile;    Reader reader = null;    if (stringRules != null) {                reader = new StringReader(stringRules);    } else {        reader = conf.getConfResourceAsReader(file);    }    try {        readConfiguration(reader);    } catch (IOException e) {        if (LOG.isErrorEnabled()) {            LOG.error(e.getMessage());        }        throw new RuntimeException(e.getMessage(), e);    }}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
c3388ef93478b02aace565e242f10fccbc6a6a5183567d51235d1ef037a65b1e
isModeAccept
public boolean isModeAccept()
{    return modeAccept;}
fcf0c94e844e52bf67c60e35eeedeb850c3f2447c40362dbece4fe2c75d37849
setModeAccept
public void setModeAccept(boolean modeAccept)
{    this.modeAccept = modeAccept;}
232f173e12e510a7e980da8e71bd88a1619b453e3b4d6b13d253c35fad600bd4
isIgnoreCase
public boolean isIgnoreCase()
{    return ignoreCase;}
769f5c957f762820d274013cdf2a57c633c2aea45185931367342269d1c1ed21
setIgnoreCase
public void setIgnoreCase(boolean ignoreCase)
{    this.ignoreCase = ignoreCase;}
6f54862ce898b696ed8904aa74bd00145f4622726186a6fcf24e12544d8cc77c
setFilterFromPath
public void setFilterFromPath(boolean filterFromPath)
{    this.filterFromPath = filterFromPath;}
c536957a0359efaba4fa041a9429ed02027b66c9e6f5cc21d07eb308cc675a0d
setUp
public void setUp() throws IOException
{    filter = new SuffixURLFilter(new StringReader(suffixes));}
6888fea167bb8c29b6d6d46e57f39255a60ba534b2f8321dda5122b9e9f96165
testModeAccept
public void testModeAccept()
{    filter.setIgnoreCase(false);    filter.setModeAccept(true);    for (int i = 0; i < urls.length; i++) {        Assert.assertTrue(urlsModeAccept[i] == filter.filter(urls[i]));    }}
c33edc248a12b57379bf56228d9feefdc482bf0367dc511d13ac54774539b9c5
testModeReject
public void testModeReject()
{    filter.setIgnoreCase(false);    filter.setModeAccept(false);    for (int i = 0; i < urls.length; i++) {        Assert.assertTrue(urlsModeReject[i] == filter.filter(urls[i]));    }}
702992a08fadedef02b386fb1966aec12d4d437a826d53bb60ad76c876e53aa7
testModeAcceptIgnoreCase
public void testModeAcceptIgnoreCase()
{    filter.setIgnoreCase(true);    filter.setModeAccept(true);    for (int i = 0; i < urls.length; i++) {        Assert.assertTrue(urlsModeAcceptIgnoreCase[i] == filter.filter(urls[i]));    }}
2876b3dd1e788c0630f453297e5765ec3a86fdb2532e7aeefe0761d9483ee038
testModeRejectIgnoreCase
public void testModeRejectIgnoreCase()
{    filter.setIgnoreCase(true);    filter.setModeAccept(false);    for (int i = 0; i < urls.length; i++) {        Assert.assertTrue(urlsModeRejectIgnoreCase[i] == filter.filter(urls[i]));    }}
5737dd404f1054f1c2b7e8457a77c2ed18cb4e6b6a45fcb2ecdb8b026c9bfbc2
testModeAcceptAndNonPathFilter
public void testModeAcceptAndNonPathFilter()
{    filter.setModeAccept(true);    filter.setFilterFromPath(false);    for (int i = 0; i < urls.length; i++) {        Assert.assertTrue(urlsModeAcceptAndNonPathFilter[i] == filter.filter(urls[i]));    }}
333a24615512ba45e1e07937a4bd0c67912313dd203d3054ef26a95dd1093da3
testModeAcceptAndPathFilter
public void testModeAcceptAndPathFilter()
{    filter.setModeAccept(true);    filter.setFilterFromPath(true);    for (int i = 0; i < urls.length; i++) {        Assert.assertTrue(urlsModeAcceptAndPathFilter[i] == filter.filter(urls[i]));    }}
0da3a5782baf480296c1da37a6af453893957766ce42877fca9c046ba2249cdc
filter
public String filter(String urlString)
{    return isValid(urlString) ? urlString : null;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
d177d27b7a60dc3d3f9534c56a2cedf829a9356ccb825ddc98e8b8e76681816b
isValid
private boolean isValid(String value)
{    if (value == null) {        return false;    }    Matcher matchUrlPat = URL_PATTERN.matcher(value);    if (!LEGAL_ASCII_PATTERN.matcher(value).matches()) {        return false;    }        if (!matchUrlPat.matches()) {        return false;    }    if (!isValidScheme(matchUrlPat.group(PARSE_URL_SCHEME))) {        return false;    }    if (!isValidAuthority(matchUrlPat.group(PARSE_URL_AUTHORITY))) {        return false;    }    if (!isValidPath(matchUrlPat.group(PARSE_URL_PATH))) {        return false;    }    if (!isValidQuery(matchUrlPat.group(PARSE_URL_QUERY))) {        return false;    }    return true;}
167e99ac8a1c5e6fc3313f0fc12b7f7f3f20366862f91ab5a002d1586a368e36
isValidScheme
private boolean isValidScheme(String scheme)
{    if (scheme == null) {        return false;    }    return SCHEME_PATTERN.matcher(scheme).matches();}
0e594a4231574aa89407daaf639b392fcaa578f78c988892bcb9023701d2a6f0
isValidAuthority
private boolean isValidAuthority(String authority)
{    if (authority == null) {        return false;    }    Matcher authorityMatcher = AUTHORITY_PATTERN.matcher(authority);    if (!authorityMatcher.matches()) {        return false;    }    boolean ipV4Address = false;    boolean hostname = false;        String hostIP = authorityMatcher.group(PARSE_AUTHORITY_HOST_IP);    Matcher matchIPV4Pat = IP_V4_DOMAIN_PATTERN.matcher(hostIP);    ipV4Address = matchIPV4Pat.matches();    if (ipV4Address) {                for (int i = 1; i <= 4; i++) {            String ipSegment = matchIPV4Pat.group(i);            if (ipSegment == null || ipSegment.length() <= 0) {                return false;            }            try {                if (Integer.parseInt(ipSegment) > 255) {                    return false;                }            } catch (NumberFormatException e) {                return false;            }        }    } else {                hostname = DOMAIN_PATTERN.matcher(hostIP).matches();    }        if (hostname) {                        char[] chars = hostIP.toCharArray();        int size = 1;        for (int i = 0; i < chars.length; i++) {            if (chars[i] == '.') {                size++;            }        }        String[] domainSegment = new String[size];        int segCount = 0;        int segLen = 0;        Matcher atomMatcher = ATOM_PATTERN.matcher(hostIP);        while (atomMatcher.find()) {            domainSegment[segCount] = atomMatcher.group();            segLen = domainSegment[segCount].length() + 1;            hostIP = (segLen >= hostIP.length()) ? "" : hostIP.substring(segLen);            segCount++;        }        String topLevel = domainSegment[segCount - 1];        if (topLevel.length() < 2) {            return false;        }                if (!ALPHA_PATTERN.matcher(topLevel.substring(0, 1)).matches()) {            return false;        }                if (segCount < 2) {            return false;        }    }    if (!hostname && !ipV4Address) {        return false;    }    String port = authorityMatcher.group(PARSE_AUTHORITY_PORT);    if (port != null) {        if (!PORT_PATTERN.matcher(port).matches()) {            return false;        }    }    String extra = authorityMatcher.group(PARSE_AUTHORITY_EXTRA);    return isBlankOrNull(extra);}
93c1dfdf343a9cf338400f0a2ea36c9e315d9ee99d377dcc913c2abd677eac3f
isBlankOrNull
private boolean isBlankOrNull(String value)
{    return ((value == null) || (value.trim().length() == 0));}
8b63a2204bb8b36133f287369e957f8c27c9b05252584982a67006d59a081def
isValidPath
private boolean isValidPath(String path)
{    if (path == null) {        return false;    }    if (!PATH_PATTERN.matcher(path).matches()) {        return false;    }    int slash2Count = countToken("//", path);    int slashCount = countToken("/", path);    int dot2Count = countToken("..", path);    return (dot2Count <= 0) || ((slashCount - slash2Count - 1) > dot2Count);}
56c06c76e01829e82bd0e92aecbd985692d21df5d38396e516a00ba4de822d75
isValidQuery
private boolean isValidQuery(String query)
{    if (query == null) {        return true;    }    return QUERY_PATTERN.matcher(query).matches();}
f0fc388de8e1c7cd1193460abb445137ef943f2f5219c0df149ea3c4de7d504b
countToken
private int countToken(String token, String target)
{    int tokenIndex = 0;    int count = 0;    while (tokenIndex != -1) {        tokenIndex = target.indexOf(token, tokenIndex);        if (tokenIndex > -1) {            tokenIndex++;            count++;        }    }    return count;}
51f2ec73199fee6869aa61086a71a364e7d3951a5551ca3229151e6b11a2c26e
testFilter
public void testFilter()
{    UrlValidator url_validator = new UrlValidator();    Assert.assertNotNull(url_validator);    Assert.assertNull("Filtering on a null object should return null", url_validator.filter(null));    Assert.assertNull("Invalid url: example.com/file[/].html", url_validator.filter("example.com/file[/].html"));    Assert.assertNull("Invalid url: http://www.example.com/space here.html", url_validator.filter("http://www.example.com/space here.html"));    Assert.assertNull("Invalid url: /main.html", url_validator.filter("/main.html"));    Assert.assertNull("Invalid url: www.example.com/main.html", url_validator.filter("www.example.com/main.html"));    Assert.assertNull("Invalid url: ftp:www.example.com/main.html", url_validator.filter("ftp:www.example.com/main.html"));    Assert.assertNull("Inalid url: http://999.000.456.32/nutch/trunk/README.txt", url_validator.filter("http://999.000.456.32/nutch/trunk/README.txt"));    Assert.assertNull("Invalid url: http://www.example.com/ma|in\\toc.html", url_validator.filter(" http://www.example.com/ma|in\\toc.html"));    Assert.assertNotNull("Valid url: https://issues.apache.org/jira/NUTCH-1127", url_validator.filter("https://issues.apache.org/jira/NUTCH-1127"));    Assert.assertNotNull("Valid url: http://domain.tld/function.cgi?url=http://fonzi.com/&amp;name=Fonzi&amp;mood=happy&amp;coat=leather", url_validator.filter("http://domain.tld/function.cgi?url=http://fonzi.com/&amp;name=Fonzi&amp;mood=happy&amp;coat=leather"));    Assert.assertNotNull("Valid url: http://validator.w3.org/feed/check.cgi?url=http%3A%2F%2Ffeeds.feedburner.com%2Fperishablepress", url_validator.filter("http://validator.w3.org/feed/check.cgi?url=http%3A%2F%2Ffeeds.feedburner.com%2Fperishablepress"));    Assert.assertNotNull("Valid url: ftp://alfa.bravo.pi/foo/bar/plan.pdf", url_validator.filter("ftp://alfa.bravo.pi/mike/check/plan.pdf"));}
8fa98404280fecfd497ce9400c07196998fbeaf2ee8524779c09bd3c220d4ea9
filter
public NutchDocument filter(NutchDocument doc, Parse parse, Text url, CrawlDatum datum, Inlinks inlinks) throws IndexingException
{    if (conf != null)        this.setConf(conf);    if (urlMetaTags == null || doc == null)        return doc;    for (String metatag : urlMetaTags) {        Text metadata = (Text) datum.getMetaData().get(new Text(metatag));        if (metadata != null)            doc.add(metatag, metadata.toString());    }    return doc;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    if (conf == null)        return;    urlMetaTags = conf.getStrings(CONF_PROPERTY);}
89fdd7122298e467ee01a9f463b423fa9405ab98df3d1247ebce0e733465af3f
distributeScoreToOutlinks
public CrawlDatum distributeScoreToOutlinks(Text fromUrl, ParseData parseData, Collection<Entry<Text, CrawlDatum>> targets, CrawlDatum adjust, int allCount) throws ScoringFilterException
{    if (urlMetaTags == null || targets == null || parseData == null)        return adjust;    Iterator<Entry<Text, CrawlDatum>> targetIterator = targets.iterator();    while (targetIterator.hasNext()) {        Entry<Text, CrawlDatum> nextTarget = targetIterator.next();        for (String metatag : urlMetaTags) {            String metaFromParse = parseData.getMeta(metatag);            if (metaFromParse == null)                continue;            nextTarget.getValue().getMetaData().put(new Text(metatag), new Text(metaFromParse));        }    }    return adjust;}
3dfdf875d54a6f956cd76620352021c016ef8325d95a527b2a70efda06758b88
passScoreBeforeParsing
public void passScoreBeforeParsing(Text url, CrawlDatum datum, Content content)
{    if (urlMetaTags == null || content == null || datum == null)        return;    for (String metatag : urlMetaTags) {        Text metaFromDatum = (Text) datum.getMetaData().get(new Text(metatag));        if (metaFromDatum == null)            continue;        content.getMetadata().set(metatag, metaFromDatum.toString());    }}
2965a8191199b2ed7659416104c7a9fd72b5aa4a422bbba9acb46a9e7d7b576e
passScoreAfterParsing
public void passScoreAfterParsing(Text url, Content content, Parse parse)
{    if (urlMetaTags == null || content == null || parse == null)        return;    for (String metatag : urlMetaTags) {        String metaFromContent = content.getMetadata().get(metatag);        if (metaFromContent == null)            continue;        parse.getData().getParseMeta().set(metatag, metaFromContent);    }}
c7d75ff32784416ea95ea0863f39cb7d0da44832579d23df72069418eb890bf5
generatorSortValue
public float generatorSortValue(Text url, CrawlDatum datum, float initSort) throws ScoringFilterException
{    return initSort;}
d2a95754238ce8e7ee9557976c163d8b3860456f1815caeadede92b2c9ee04fa
indexerScore
public float indexerScore(Text url, NutchDocument doc, CrawlDatum dbDatum, CrawlDatum fetchDatum, Parse parse, Inlinks inlinks, float initScore) throws ScoringFilterException
{    return initScore;}
2dcbf82c99c2e2b740c6a208c3e1e729c537864ed30748e09cdb44bbfad01075
initialScore
public void initialScore(Text url, CrawlDatum datum) throws ScoringFilterException
{    return;}
0b6feb77383ae8d81d2c30e18bf6315732aeabecd96f00250a9915d31f7fbc88
injectedScore
public void injectedScore(Text url, CrawlDatum datum) throws ScoringFilterException
{    return;}
021571540bd16053b37a45bee8e233da357044b2982932447da62f33fd6e6f2a
updateDbScore
public void updateDbScore(Text url, CrawlDatum old, CrawlDatum datum, List<CrawlDatum> inlinked) throws ScoringFilterException
{    return;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    super.setConf(conf);    if (conf == null)        return;    urlMetaTags = conf.getStrings(CONF_PROPERTY);}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
933429b87ed8d22931edb4275d568d806836113738610213929fc123acc40fff
normalizeHashedFragment
protected String normalizeHashedFragment(String urlString) throws MalformedURLException
{    URL u = new URL(urlString);    int pos = urlString.indexOf(AJAX_URL_PART);    StringBuilder sb = new StringBuilder(urlString.substring(0, pos));        String escapedFragment = escape(urlString.substring(pos + AJAX_URL_PART.length()));        if (u.getQuery() == null) {        sb.append("?");    } else {        sb.append("&");    }        sb.append(ESCAPED_URL_PART);    sb.append(escapedFragment);    return sb.toString();}
06af7333bad5b8b779d2014c087840146245bf6e33976c3a1a2801a72b809707
normalizeEscapedFragment
protected String normalizeEscapedFragment(String urlString) throws MalformedURLException
{    URL u = new URL(urlString);    StringBuilder sb = new StringBuilder();        sb.append(u.getProtocol());    sb.append("://");    sb.append(u.getHost());    if (u.getPort() != -1) {        sb.append(":");        sb.append(u.getPort());    }    sb.append(u.getPath());        String queryString = u.getQuery();        int ampPos = queryString.indexOf("&");    String keyValuePair = null;        if (ampPos == -1) {        keyValuePair = queryString;        queryString = "";    } else {                keyValuePair = queryString.substring(ampPos + 1);                queryString = queryString.replaceFirst("&" + keyValuePair, "");    }        keyValuePair = keyValuePair.replaceFirst(ESCAPED_URL_PART, "");        String unescapedFragment = unescape(keyValuePair);        if (queryString.length() > 0) {        sb.append("?");        sb.append(queryString);    }        sb.append("#!");    sb.append(unescapedFragment);    return sb.toString();}
6e277960ed130dc2555eebf53199c851797bef0a2c2689c644a356f96275cff2
unescape
protected String unescape(String fragmentPart)
{    try {        fragmentPart = URLDecoder.decode(fragmentPart, "UTF-8");    } catch (Exception e) {        }    return fragmentPart;}
0e5cc76b798fdff1d3eb28f7d333c8618dc089efe8037131a55c70cb561d9daa
escape
protected String escape(String fragmentPart)
{    String hex = null;    StringBuilder sb = new StringBuilder(fragmentPart.length());    for (byte b : fragmentPart.getBytes(utf8)) {        if (b < 33) {            sb.append('%');            hex = Integer.toHexString(b & 0xFF).toUpperCase();                        if (hex.length() % 2 != 0) {                sb.append('0');            }            sb.append(hex);        } else if (b == 35) {            sb.append("%23");        } else if (b == 37) {            sb.append("%25");        } else if (b == 38) {            sb.append("%26");        } else if (b == 43) {            sb.append("%2B");        } else {            sb.append((char) b);        }    }    return sb.toString();}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return this.conf;}
f0aef46dd3132d4b67525a5d5a35b68065bf3111006535b237416e42e191a9e5
testNormalizer
public void testNormalizer() throws Exception
{        normalizeTest("http://example.org/#!k=v", "http://example.org/?_escaped_fragment_=k=v");        normalizeTest("http://example.org/#!k=v&something=is wrong", "http://example.org/?_escaped_fragment_=k=v%26something=is%20wrong");        normalizeTest("http://example.org/path.html?queryparam=queryvalue#!key1=value1&key2=value2", "http://example.org/path.html?queryparam=queryvalue&_escaped_fragment_=key1=value1%26key2=value2");}
d67baff0e17378cbb508d568ffaec4d4981554dd8e5b425fe175a738b17d2991
testNormalizerWhenIndexing
public void testNormalizerWhenIndexing() throws Exception
{        normalizeTest("http://example.org/?_escaped_fragment_=key=value", "http://example.org/#!key=value", URLNormalizers.SCOPE_INDEXER);    normalizeTest("http://example.org/?key=value&_escaped_fragment_=key=value", "http://example.org/?key=value#!key=value", URLNormalizers.SCOPE_INDEXER);    normalizeTest("http://example.org/page.html?key=value&_escaped_fragment_=key=value%26something=is%20wrong", "http://example.org/page.html?key=value#!key=value&something=is wrong", URLNormalizers.SCOPE_INDEXER);}
1a91cd890e7c215e26566ac03fb452d4ad39b044a6462258e601bcb34fa63d03
normalizeTest
private void normalizeTest(String weird, String normal) throws Exception
{    assertEquals(normal, normalizer.normalize(weird, URLNormalizers.SCOPE_DEFAULT));}
dc8dab0042feecddf853f1a980ceb154b540aa239fe9fdae81ae3894a9f5fe67
normalizeTest
private void normalizeTest(String weird, String normal, String scope) throws Exception
{    assertEquals(normal, normalizer.normalize(weird, scope));}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    new TestAjaxURLNormalizer("test").testNormalizer();}
b5d3adeeed6bbca6b1d359f1d47f4fdb2dc07e0683c33d813cad126155085768
isAlphaNumeric
private static boolean isAlphaNumeric(int c)
{    return (0x41 <= c && c <= 0x5A) || (0x61 <= c && c <= 0x7A) || (0x30 <= c && c <= 0x39);}
21dd89a06fedf7011728b0b3485fa4150b70bbd7f3b9b4ebff17763544d89d74
isHexCharacter
private static boolean isHexCharacter(int c)
{    return (0x41 <= c && c <= 0x46) || (0x61 <= c && c <= 0x66) || (0x30 <= c && c <= 0x39);}
74abbdeba913940ca747a127baff7032aa47f6b1ce6e65185ebfcd9754faf4d1
normalize
public String normalize(String urlString, String scope) throws MalformedURLException
{    if (    "".equals(urlString))        return urlString;        urlString = urlString.trim();    URL url = new URL(urlString);    String protocol = url.getProtocol();    String host = url.getHost();    int port = url.getPort();    String file = url.getFile();    boolean changed = false;    boolean normalizePath = false;    if (    !urlString.startsWith(protocol))        changed = true;    if ("http".equals(protocol) || "https".equals(protocol) || "ftp".equals(protocol)) {        if (host != null && url.getAuthority() != null) {                        String newHost = host.toLowerCase(Locale.ROOT);            if (!host.equals(newHost)) {                host = newHost;                changed = true;            } else if (!url.getAuthority().equals(newHost)) {                                                changed = true;            }        } else {                        changed = true;        }        if (port == url.getDefaultPort()) {                                    port = -1;            changed = true;        }        normalizePath = true;        if (file == null || "".equals(file)) {            file = "/";            changed = true;                        normalizePath = false;        } else if (!file.startsWith("/")) {            file = "/" + file;            changed = true;                        normalizePath = false;        }        if (url.getRef() != null) {                        changed = true;        }    } else if (protocol.equals("file")) {        normalizePath = true;    }        String file2 = unescapePath(file);    file2 = escapePath(file2);    if (!file.equals(file2)) {        changed = true;        file = file2;    }    if (normalizePath) {                if (changed) {            url = new URL(protocol, host, port, file);        }        file2 = getFileWithNormalizedPath(url);        if (!file.equals(file2)) {            changed = true;            file = file2;        }    }    if (changed) {        url = new URL(protocol, host, port, file);        urlString = url.toString();    }    return urlString;}
1b270997589d916ac1eac08f66317b7d200d928e6bd5a191b913f318e5038d5a
getFileWithNormalizedPath
private String getFileWithNormalizedPath(URL url) throws MalformedURLException
{    String file;    if (hasNormalizablePathPattern.matcher(url.getPath()).find()) {                try {            file = url.toURI().normalize().toURL().getFile();                                    int start = 0;            while (file.startsWith("/..", start) && ((start + 3) == file.length() || file.charAt(3) == '/')) {                start += 3;            }            if (start > 0) {                file = file.substring(start);            }        } catch (URISyntaxException e) {            file = url.getFile();        }    } else {        file = url.getFile();    }        if (file.isEmpty()) {        file = "/";    } else if (!file.startsWith("/")) {        file = "/" + file;    }    return file;}
7abafd8f2f946be9ef142e508addcc6fe8e2af410ebd46c3b3fa2abdc608ede6
unescapePath
private String unescapePath(String path)
{    StringBuilder sb = new StringBuilder();    Matcher matcher = unescapeRulePattern.matcher(path);    int end = -1;    int letter;        while (matcher.find()) {                sb.append(path.substring(end + 1, matcher.start()));                letter = Integer.valueOf(matcher.group().substring(1), 16);        if (letter < 128 && unescapedCharacters[letter]) {                        sb.append(Character.valueOf((char) letter));        } else {                        sb.append(matcher.group().toUpperCase(Locale.ROOT));        }        end = matcher.start() + 2;    }    letter = path.length();        if (end <= letter - 1) {        sb.append(path.substring(end + 1, letter));    }        return sb.toString();}
a421f1cf68bea8ae010d7afd3c36bcdb82f222411d25ca4c38df16aef988e135
escapePath
private String escapePath(String path)
{    StringBuilder sb = new StringBuilder(path.length());        byte[] bytes = path.getBytes(utf8);    for (int i = 0; i < bytes.length; i++) {        byte b = bytes[i];                if (b < 0 || escapedCharacters[b]) {                        sb.append('%');                        String hex = Integer.toHexString(b & 0xFF).toUpperCase(Locale.ROOT);                        if (hex.length() % 2 != 0) {                sb.append('0');                sb.append(hex);            } else {                                sb.append(hex);            }        } else if (b == 0x25) {                        if ((i + 2) >= bytes.length) {                                sb.append("%25");            } else {                byte e1 = bytes[i + 1];                byte e2 = bytes[i + 2];                if (isHexCharacter(e1) && isHexCharacter(e2)) {                                        i += 2;                    sb.append((char) b);                    sb.append((char) e1);                    sb.append((char) e2);                } else {                    sb.append("%25");                }            }        } else {                        sb.append((char) b);        }    }    return sb.toString();}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    BasicURLNormalizer normalizer = new BasicURLNormalizer();    normalizer.setConf(NutchConfiguration.create());    String scope = URLNormalizers.SCOPE_DEFAULT;    if (args.length >= 1) {        scope = args[0];        System.out.println("Scope: " + scope);    }    String line, normUrl;    BufferedReader in = new BufferedReader(new InputStreamReader(System.in, utf8));    while ((line = in.readLine()) != null) {        try {            normUrl = normalizer.normalize(line, scope);            System.out.println(normUrl);        } catch (MalformedURLException e) {            System.out.println("failed: " + line);        }    }    System.exit(0);}
8c4096b3df6dc04fce59e73397b5034e88647832223faec47ab4b13ce5c1600d
testNUTCH1098
public void testNUTCH1098() throws Exception
{        normalizeTest("http://foo.com/%66oo.html", "http://foo.com/foo.html");        normalizeTest("http://foo.com/%66oo.htm%6c", "http://foo.com/foo.html");    normalizeTest("http://foo.com/%66oo.ht%6dl", "http://foo.com/foo.html");        normalizeTest("http://foo.com/%66oo.ht%6d%6c", "http://foo.com/foo.html");        normalizeTest("http://foo.com/%66oo.htm%C0", "http://foo.com/foo.htm%C0");        normalizeTest("http://foo.com/%66oo.htm%1A", "http://foo.com/foo.htm%1A");        normalizeTest("http://foo.com/%66oo.htm%c0", "http://foo.com/foo.htm%C0");        normalizeTest("http://foo.com/you%20too.html", "http://foo.com/you%20too.html");        normalizeTest("http://foo.com/you too.html", "http://foo.com/you%20too.html");        normalizeTest("http://foo.com/file.html%23cz", "http://foo.com/file.html%23cz");        normalizeTest("http://foo.com/fast/dir%2fcz", "http://foo.com/fast/dir%2Fcz");        normalizeTest("http://foo.com/\u001a!", "http://foo.com/%1A!");        normalizeTest("http://foo.com/\u0001!", "http://foo.com/%01!");        normalizeTest("http://mydomain.com/en Espa\u00F1ol.aspx", "http://mydomain.com/en%20Espa%C3%B1ol.aspx");}
16f9302c074291f22ec6cf67ee72a7c3558866b3deb2ee93c44553e91faac275
testNUTCH2064
public void testNUTCH2064() throws Exception
{        normalizeTest("http://x.com/s?q=a%26b&m=10", "http://x.com/s?q=a%26b&m=10");    normalizeTest("http://x.com/show?http%3A%2F%2Fx.com%2Fb", "http://x.com/show?http%3A%2F%2Fx.com%2Fb");    normalizeTest("http://google.com/search?q=c%2B%2B", "http://google.com/search?q=c%2B%2B");        normalizeTest("http://x.com/s?q=a+b", "http://x.com/s?q=a+b");                normalizeTest("http://b\u00fccher.de/", "http://b\u00fccher.de/");        normalizeTest("http://x.com/./a/../%66.html", "http://x.com/f.html");        normalizeTest("http://x.com/?x[y]=1", "http://x.com/?x%5By%5D=1");        normalizeTest("http://x.com/foo\u0080", "http://x.com/foo%C2%80");    normalizeTest("http://x.com/foo%c2%80", "http://x.com/foo%C2%80");}
f0aef46dd3132d4b67525a5d5a35b68065bf3111006535b237416e42e191a9e5
testNormalizer
public void testNormalizer() throws Exception
{        normalizeTest(" http://foo.com/ ", "http://foo.com/");        normalizeTest("HTTP://foo.com/", "http://foo.com/");        normalizeTest("http://Foo.Com/index.html", "http://foo.com/index.html");    normalizeTest("http://Foo.Com/index.html", "http://foo.com/index.html");        normalizeTest("http://foo.com:80/index.html", "http://foo.com/index.html");    normalizeTest("http://foo.com:81/", "http://foo.com:81/");        normalizeTest("http://example.com:/", "http://example.com/");    normalizeTest("https://example.com:/foobar.html", "https://example.com/foobar.html");        normalizeTest("http://foo.com", "http://foo.com/");        normalizeTest("http://foo.com/foo.html#ref", "http://foo.com/foo.html");                normalizeTest("http://foo.com/..", "http://foo.com/");    normalizeTest("http://foo.com/aa/./foo.html", "http://foo.com/aa/foo.html");    normalizeTest("http://foo.com/aa/../", "http://foo.com/");    normalizeTest("http://foo.com/aa/bb/../", "http://foo.com/aa/");    normalizeTest("http://foo.com/aa/..", "http://foo.com/");    normalizeTest("http://foo.com/aa/bb/cc/../../foo.html", "http://foo.com/aa/foo.html");    normalizeTest("http://foo.com/aa/bb/../cc/dd/../ee/foo.html", "http://foo.com/aa/cc/ee/foo.html");    normalizeTest("http://foo.com/../foo.html", "http://foo.com/foo.html");    normalizeTest("http://foo.com/../../foo.html", "http://foo.com/foo.html");    normalizeTest("http://foo.com/../aa/../foo.html", "http://foo.com/foo.html");    normalizeTest("http://foo.com/aa/../../foo.html", "http://foo.com/foo.html");    normalizeTest("http://foo.com/aa/../bb/../foo.html/../../", "http://foo.com/");    normalizeTest("http://foo.com/../aa/foo.html", "http://foo.com/aa/foo.html");    normalizeTest("http://foo.com/../aa/../foo.html", "http://foo.com/foo.html");    normalizeTest("http://foo.com/a..a/foo.html", "http://foo.com/a..a/foo.html");    normalizeTest("http://foo.com/a..a/../foo.html", "http://foo.com/foo.html");    normalizeTest("http://foo.com/foo.foo/../foo.html", "http://foo.com/foo.html");    normalizeTest("http://foo.com//aa/bb/foo.html", "http://foo.com/aa/bb/foo.html");    normalizeTest("http://foo.com/aa//bb/foo.html", "http://foo.com/aa/bb/foo.html");    normalizeTest("http://foo.com/aa/bb//foo.html", "http://foo.com/aa/bb/foo.html");    normalizeTest("http://foo.com//aa//bb//foo.html", "http://foo.com/aa/bb/foo.html");    normalizeTest("http://foo.com////aa////bb////foo.html", "http://foo.com/aa/bb/foo.html");    normalizeTest("http://foo.com/aa?referer=http://bar.com", "http://foo.com/aa?referer=http://bar.com");        normalizeTest("file:///foo/bar.txt", "file:///foo/bar.txt");    normalizeTest("ftp:/", "ftp:/");    normalizeTest("http:", "http:/");    normalizeTest("http:////", "http:/");    normalizeTest("http:///////", "http:/");        normalizeTest("http://example.com?a=1", "http://example.com/?a=1");        normalizeTest("http://www.example.com/a/c/../b/search?q=foobar|", "http://www.example.com/a/b/search?q=foobar%7C");    normalizeTest("http://www.example.com/a/c/../b/search?q=foobar%", "http://www.example.com/a/b/search?q=foobar%25");    normalizeTest("http://www.example.com/a/c/../b/search?q=foobar\"", "http://www.example.com/a/b/search?q=foobar%22");    normalizeTest("http://www.example.com/a/c/../b/search?q=foobar^", "http://www.example.com/a/b/search?q=foobar%5E");    normalizeTest("http://www.example.com/a/c/../b/search?q=foobar<", "http://www.example.com/a/b/search?q=foobar%3C");    normalizeTest("http://www.example.com/a/c/../b/search?q=foobar>", "http://www.example.com/a/b/search?q=foobar%3E");    normalizeTest("http://www.example.com/a/c/../b/search?q=foobar`", "http://www.example.com/a/b/search?q=foobar%60");        normalizeTest("http://www.example.com/p%zz%77%v", "http://www.example.com/p%25zzw%25v");        normalizeTest("http://www.example.com/search?q=foobar%", "http://www.example.com/search?q=foobar%25");    normalizeTest("http://www.example.com/search?q=foobar%2", "http://www.example.com/search?q=foobar%252");    normalizeTest("http://www.example.com/search?q=foobar%25", "http://www.example.com/search?q=foobar%25");    normalizeTest("http://www.example.com/search?q=foobar%252", "http://www.example.com/search?q=foobar%252");        normalizeTest("file:/var/www/html/foo/../bar/index.html", "file:/var/www/html/bar/index.html");    normalizeTest("file:/var/www/html/////./bar/index.html", "file:/var/www/html/bar/index.html");}
449d0fe6c6f6390fb9e4b5868691a23ecefd0c1336d3e445243a9dbbeec803e7
testCurlyBraces
public void testCurlyBraces() throws Exception
{        normalizeTest("http://foo.com/{{stuff}} ", "http://foo.com/%7B%7Bstuff%7D%7D");}
1a91cd890e7c215e26566ac03fb452d4ad39b044a6462258e601bcb34fa63d03
normalizeTest
private void normalizeTest(String weird, String normal) throws Exception
{    Assert.assertEquals("normalizing: " + weird, normal, normalizer.normalize(weird, URLNormalizers.SCOPE_DEFAULT));    try {        (new URL(normal)).toURI();    } catch (MalformedURLException | URISyntaxException e) {        Assert.fail("Output of normalization fails to validate as URL or URI: " + e.getMessage());    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    new TestBasicURLNormalizer().testNormalizer();}
8fd3b6a758013f17936e866b94a5d5896c63c1c327e621a2661e341abe4af837
readConfiguration
private synchronized void readConfiguration(Reader configReader) throws IOException
{    if (hostsMap.size() > 0) {        return;    }    BufferedReader reader = new BufferedReader(configReader);    String line, host, target;    int delimiterIndex;    while ((line = reader.readLine()) != null) {        if (StringUtils.isNotBlank(line) && !line.startsWith("#")) {            line = line.trim();            delimiterIndex = line.indexOf(" ");            host = line.substring(0, delimiterIndex);            target = line.substring(delimiterIndex + 1);            hostsMap.put(host, target);        }    }}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;        String pluginName = "urlnormalizer-host";    Extension[] extensions = PluginRepository.get(conf).getExtensionPoint(URLNormalizer.class.getName()).getExtensions();    for (int i = 0; i < extensions.length; i++) {        Extension extension = extensions[i];        if (extension.getDescriptor().getPluginId().equals(pluginName)) {            attributeFile = extension.getAttribute("file");            break;        }    }        if (attributeFile != null && attributeFile.trim().equals("")) {        attributeFile = null;    }    if (attributeFile != null) {        if (LOG.isInfoEnabled()) {            LOG.info("Attribute \"file\" is defined for plugin " + pluginName + " as " + attributeFile);        }    } else {        if (LOG.isWarnEnabled()) {            LOG.warn("Attribute \"file\" is not defined in plugin.xml for plugin " + pluginName);        }    }        String file = conf.get("urlnormalizer.hosts.file");    String stringRules = conf.get("urlnormalizer.hosts.rules");    if (hostsFile != null) {        file = hostsFile;    } else if (attributeFile != null) {        file = attributeFile;    }    Reader reader = null;    if (stringRules != null) {                reader = new StringReader(stringRules);    } else {        reader = conf.getConfResourceAsReader(file);    }    try {        if (reader == null) {            reader = new FileReader(file);        }        readConfiguration(reader);    } catch (IOException e) {        LOG.error(org.apache.hadoop.util.StringUtils.stringifyException(e));    }}
74abbdeba913940ca747a127baff7032aa47f6b1ce6e65185ebfcd9754faf4d1
normalize
public String normalize(String urlString, String scope) throws MalformedURLException
{    String host = new URL(urlString).getHost();        if (hostsMap.containsKey(host)) {        return replaceHost(urlString, host, hostsMap.get(host));    }        String[] hostParts = host.split("\\.");        StringBuilder hostBuffer = new StringBuilder();        String wildCardHost = new String();        hostBuffer.append(hostParts[hostParts.length - 1]);    for (int i = hostParts.length - 2; i > 0; i--) {                hostBuffer.insert(0, hostParts[i] + ".");                wildCardHost = "*." + hostBuffer.toString();                if (hostsMap.containsKey(wildCardHost)) {                        return replaceHost(urlString, host, hostsMap.get(wildCardHost));        }    }    return urlString;}
030264007950aa168b7e87fb2d877390cb25308af417c37202101d41a89155a4
replaceHost
protected String replaceHost(String urlString, String host, String target)
{    int hostIndex = urlString.indexOf(host);    StringBuilder buffer = new StringBuilder();    buffer.append(urlString.substring(0, hostIndex));    buffer.append(target);    buffer.append(urlString.substring(hostIndex + host.length()));    return buffer.toString();}
e0e26a7dbf95cae8d03c586356ec04ef24825007d4534cbd8df2a5e2dcdc34b7
testHostURLNormalizer
public void testHostURLNormalizer() throws Exception
{    Configuration conf = NutchConfiguration.create();    String hostsFile = SAMPLES + SEPARATOR + "hosts.txt";    HostURLNormalizer normalizer = new HostURLNormalizer(hostsFile);    normalizer.setConf(conf);        Assert.assertEquals("http://www.example.org/page.html", normalizer.normalize("http://example.org/page.html", URLNormalizers.SCOPE_DEFAULT));        Assert.assertEquals("http://example.net/path/to/something.html", normalizer.normalize("http://www.example.net/path/to/something.html", URLNormalizers.SCOPE_DEFAULT));        Assert.assertEquals("http://example.com/?does=it&still=work", normalizer.normalize("http://example.com/?does=it&still=work", URLNormalizers.SCOPE_DEFAULT));    Assert.assertEquals("http://example.com/buh", normalizer.normalize("http://http.www.example.com/buh", URLNormalizers.SCOPE_DEFAULT));    Assert.assertEquals("http://example.com/blaat", normalizer.normalize("http://whatever.example.com/blaat", URLNormalizers.SCOPE_DEFAULT));}
74abbdeba913940ca747a127baff7032aa47f6b1ce6e65185ebfcd9754faf4d1
normalize
public String normalize(String urlString, String scope) throws MalformedURLException
{    return urlString;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
0d45bb546a0137e69ac568f6508514754c2f4733654dd11bea7e8928944bf30f
testPassURLNormalizer
public void testPassURLNormalizer()
{    Configuration conf = NutchConfiguration.create();    PassURLNormalizer normalizer = new PassURLNormalizer();    normalizer.setConf(conf);    String url = "http://www.example.com/test/..//";    String result = null;    try {        result = normalizer.normalize(url, URLNormalizers.SCOPE_DEFAULT);    } catch (MalformedURLException mue) {        Assert.fail(mue.toString());    }    Assert.assertEquals(url, result);}
8fd3b6a758013f17936e866b94a5d5896c63c1c327e621a2661e341abe4af837
readConfiguration
private synchronized void readConfiguration(Reader configReader) throws IOException
{    if (protocolsMap.size() > 0) {        return;    }    BufferedReader reader = new BufferedReader(configReader);    String line, host;    String protocol;    int delimiterIndex;    while ((line = reader.readLine()) != null) {        if (StringUtils.isNotBlank(line) && !line.startsWith("#")) {            line = line.trim();            delimiterIndex = line.indexOf(" ");                        if (delimiterIndex == -1) {                delimiterIndex = line.indexOf("\t");            }            host = line.substring(0, delimiterIndex);            protocol = line.substring(delimiterIndex + 1).trim();            protocolsMap.put(host, protocol);        }    }}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;        String pluginName = "urlnormalizer-protocol";    Extension[] extensions = PluginRepository.get(conf).getExtensionPoint(URLNormalizer.class.getName()).getExtensions();    for (int i = 0; i < extensions.length; i++) {        Extension extension = extensions[i];        if (extension.getDescriptor().getPluginId().equals(pluginName)) {            attributeFile = extension.getAttribute("file");            break;        }    }        if (attributeFile != null && attributeFile.trim().equals("")) {        attributeFile = null;    }    if (attributeFile != null) {        if (LOG.isInfoEnabled()) {            LOG.info("Attribute \"file\" is defined for plugin " + pluginName + " as " + attributeFile);        }    } else {        if (LOG.isWarnEnabled()) {            LOG.warn("Attribute \"file\" is not defined in plugin.xml for plugin " + pluginName);        }    }        String file = conf.get("urlnormalizer.protocols.file");    String stringRules = conf.get("urlnormalizer.protocols.rules");    if (protocolsFile != null) {        file = protocolsFile;    } else if (attributeFile != null) {        file = attributeFile;    }    Reader reader = null;    if (stringRules != null) {                reader = new StringReader(stringRules);    } else {        reader = conf.getConfResourceAsReader(file);    }    try {        if (reader == null) {            reader = new FileReader(file);        }        readConfiguration(reader);    } catch (IOException e) {        LOG.error(org.apache.hadoop.util.StringUtils.stringifyException(e));    }}
7909ea2cf8dbe618deca1612b5878fbd72225d6deb22452d531ffc7be0223ef7
normalize
public String normalize(String url, String scope) throws MalformedURLException
{    return normalize(url, null, scope);}
db2b35e9b320d58e9f6609c99851079c4d4fea217414bbf44ea59c8f5e4fc66a
normalize
public String normalize(String url, CrawlDatum crawlDatum, String scope) throws MalformedURLException
{        URL u = new URL(url);        String host = u.getHost();        if (protocolsMap.containsKey(host)) {        String protocol = u.getProtocol();        String requiredProtocol = protocolsMap.get(host);                if (!protocol.equals(requiredProtocol)) {                        StringBuilder buffer = new StringBuilder(requiredProtocol);            buffer.append(PROTOCOL_DELIMITER);            buffer.append(host);            buffer.append(u.getPath());            String queryString = u.getQuery();            if (queryString != null) {                buffer.append(QUESTION_MARK);                buffer.append(queryString);            }            url = buffer.toString();        }    }    return url;}
f6cd8e801517838e5aaa91d0fd20032017411dae19dcfd7e63341f43d0f18624
testProtocolURLNormalizer
public void testProtocolURLNormalizer() throws Exception
{    Configuration conf = NutchConfiguration.create();    String protocolsFile = SAMPLES + SEPARATOR + "protocols.txt";    ProtocolURLNormalizer normalizer = new ProtocolURLNormalizer(protocolsFile);    normalizer.setConf(conf);        assertEquals("http://example.org/", normalizer.normalize("https://example.org/", URLNormalizers.SCOPE_DEFAULT));    assertEquals("http://example.net/", normalizer.normalize("https://example.net/", URLNormalizers.SCOPE_DEFAULT));        assertEquals("http://example.org/", normalizer.normalize("https://example.org/", URLNormalizers.SCOPE_DEFAULT));    assertEquals("http://example.net/", normalizer.normalize("https://example.net/", URLNormalizers.SCOPE_DEFAULT));        assertEquals("https://example.io/", normalizer.normalize("https://example.io/", URLNormalizers.SCOPE_DEFAULT));    assertEquals("https://example.nl/", normalizer.normalize("https://example.nl/", URLNormalizers.SCOPE_DEFAULT));        assertEquals("https://example.io/", normalizer.normalize("http://example.io/", URLNormalizers.SCOPE_DEFAULT));    assertEquals("https://example.nl/", normalizer.normalize("http://example.nl/", URLNormalizers.SCOPE_DEFAULT));}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
74abbdeba913940ca747a127baff7032aa47f6b1ce6e65185ebfcd9754faf4d1
normalize
public String normalize(String urlString, String scope) throws MalformedURLException
{    URL url = new URL(urlString);    String queryString = url.getQuery();    if (queryString == null) {        return urlString;    }    List<String> queryStringParts = Arrays.asList(queryString.split("&"));    Collections.sort(queryStringParts);    StringBuilder sb = new StringBuilder();    sb.append(url.getProtocol());    sb.append("://");    sb.append(url.getHost());    if (url.getPort() > -1) {        sb.append(":");        sb.append(url.getPort());    }    sb.append(url.getPath());    sb.append("?");    sb.append(StringUtils.join(queryStringParts, "&"));    if (url.getRef() != null) {        sb.append("#");        sb.append(url.getRef());    }    return sb.toString();}
9c93ac7a0ce990549ec8c511723a90e3ea20b217cb891aec3c4ff080fde7f79e
testQuerystringURLNormalizer
public void testQuerystringURLNormalizer() throws Exception
{    Configuration conf = NutchConfiguration.create();    QuerystringURLNormalizer normalizer = new QuerystringURLNormalizer();    normalizer.setConf(conf);    assertEquals("http://example.com/?a=b&c=d", normalizer.normalize("http://example.com/?c=d&a=b", URLNormalizers.SCOPE_DEFAULT));    assertEquals("http://example.com/a/b/c", normalizer.normalize("http://example.com/a/b/c", URLNormalizers.SCOPE_DEFAULT));    assertEquals("http://example.com:1234/a/b/c", normalizer.normalize("http://example.com:1234/a/b/c", URLNormalizers.SCOPE_DEFAULT));    assertEquals("http://example.com:1234/a/b/c#ref", normalizer.normalize("http://example.com:1234/a/b/c#ref", URLNormalizers.SCOPE_DEFAULT));    assertEquals("http://example.com:1234/a/b/c?a=b&c=d#ref", normalizer.normalize("http://example.com:1234/a/b/c?c=d&a=b#ref", URLNormalizers.SCOPE_DEFAULT));    assertEquals("http://example.com/?a=b&a=c&c=d", normalizer.normalize("http://example.com/?c=d&a=b&a=c", URLNormalizers.SCOPE_DEFAULT));}
78841785c84ea01d6e94f3e571419ac950c25bd48348fd0fb5cefcec5b36b733
initialValue
protected java.util.HashMap<String, java.util.List<Rule>> initialValue()
{    return new HashMap<String, List<Rule>>();}
e3cd85f54d9cc617f7cb65354ef21066fa1658ac26146cf798076931b2e34687
getScopedRules
public HashMap<String, List<Rule>> getScopedRules()
{    return scopedRulesThreadLocal.get();}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    super.setConf(conf);    if (conf == null)        return;        String filename = getConf().get("urlnormalizer.regex.file");    String stringRules = getConf().get("urlnormalizer.regex.rules");    Reader reader = null;    if (stringRules != null) {        reader = new StringReader(stringRules);    } else {        reader = getConf().getConfResourceAsReader(filename);    }    List<Rule> rules = null;    if (reader == null) {        LOG.warn("Can't load the default rules! ");        rules = EMPTY_RULES;    } else {        try {            rules = readConfiguration(reader);        } catch (Exception e) {            LOG.warn("Couldn't read default config: " + e);            rules = EMPTY_RULES;        }    }    defaultRules = rules;}
80da4baf4a3e643e458cae093e18d5240f2e363ef2d178b7ccc994c1ccf40e62
setConfiguration
 void setConfiguration(Reader reader, String scope)
{    List<Rule> rules = readConfiguration(reader);    getScopedRules().put(scope, rules);    LOG.debug("Set config for scope '" + scope + "': " + rules.size() + " rules.");}
943114e97cb1eacc30aa5e383abb08887b484c3b96f76a5bff2b7684f3e4f862
regexNormalize
public String regexNormalize(String urlString, String scope)
{    HashMap<String, List<Rule>> scopedRules = getScopedRules();    List<Rule> curRules = scopedRules.get(scope);    if (curRules == null) {                String configFile = getConf().get("urlnormalizer.regex.file." + scope);        if (configFile != null) {            LOG.debug("resource for scope '" + scope + "': " + configFile);            try {                Reader reader = getConf().getConfResourceAsReader(configFile);                curRules = readConfiguration(reader);                scopedRules.put(scope, curRules);            } catch (Exception e) {                LOG.warn("Couldn't load resource '" + configFile + "': " + e);            }        }        if (curRules == EMPTY_RULES || curRules == null) {            LOG.info("can't find rules for scope '" + scope + "', using default");            scopedRules.put(scope, EMPTY_RULES);        }    }    if (curRules == EMPTY_RULES || curRules == null) {        curRules = defaultRules;    }    Iterator<Rule> i = curRules.iterator();    while (i.hasNext()) {        Rule r = (Rule) i.next();        Matcher matcher = r.pattern.matcher(urlString);        urlString = matcher.replaceAll(r.substitution);    }    return urlString;}
74abbdeba913940ca747a127baff7032aa47f6b1ce6e65185ebfcd9754faf4d1
normalize
public String normalize(String urlString, String scope) throws MalformedURLException
{    return regexNormalize(urlString, scope);}
557934d644513b49b37f4081096ff82fcf1667ddc447ea8fff4496b03eeab8e0
readConfigurationFile
private List<Rule> readConfigurationFile(String filename)
{    if (LOG.isInfoEnabled()) {        LOG.info("loading " + filename);    }    try {        FileReader reader = new FileReader(filename);        return readConfiguration(reader);    } catch (Exception e) {        LOG.error("Error loading rules from '" + filename + "': " + e);        return EMPTY_RULES;    }}
3daec59b4d9d6f4cdb6e0bd41e7831a8727dbea0b6d1624e8d6c36de4554d33b
readConfiguration
private List<Rule> readConfiguration(Reader reader)
{    List<Rule> rules = new ArrayList<Rule>();    try {                Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(new InputSource(reader));        Element root = doc.getDocumentElement();        if ((!"regex-normalize".equals(root.getTagName())) && (LOG.isErrorEnabled())) {            LOG.error("bad conf file: top-level element not <regex-normalize>");        }        NodeList regexes = root.getChildNodes();        for (int i = 0; i < regexes.getLength(); i++) {            Node regexNode = regexes.item(i);            if (!(regexNode instanceof Element))                continue;            Element regex = (Element) regexNode;            if ((!"regex".equals(regex.getTagName())) && (LOG.isWarnEnabled())) {                LOG.warn("bad conf file: element not <regex>");            }            NodeList fields = regex.getChildNodes();            String patternValue = null;            String subValue = null;            for (int j = 0; j < fields.getLength(); j++) {                Node fieldNode = fields.item(j);                if (!(fieldNode instanceof Element))                    continue;                Element field = (Element) fieldNode;                if ("pattern".equals(field.getTagName()) && field.hasChildNodes())                    patternValue = ((Text) field.getFirstChild()).getData();                if ("substitution".equals(field.getTagName()) && field.hasChildNodes())                    subValue = ((Text) field.getFirstChild()).getData();                if (!field.hasChildNodes())                    subValue = "";            }            if (patternValue != null && subValue != null) {                Rule rule = new Rule();                try {                    rule.pattern = Pattern.compile(patternValue);                } catch (PatternSyntaxException e) {                    if (LOG.isErrorEnabled()) {                        LOG.error("skipped rule: " + patternValue + " -> " + subValue + " : invalid regular expression pattern: " + e);                    }                    continue;                }                rule.substitution = subValue;                rules.add(rule);            }        }    } catch (Exception e) {        if (LOG.isErrorEnabled()) {            LOG.error("error parsing conf file: " + e);        }        return EMPTY_RULES;    }    if (rules.size() == 0)        return EMPTY_RULES;    return rules;}
14935e297d5ec9b216184660bd4872c8caee728c8d9ce75978655ba8ef403adb
main
public static void main(String[] args) throws PatternSyntaxException, IOException
{    RegexURLNormalizer normalizer = new RegexURLNormalizer();    normalizer.setConf(NutchConfiguration.create());    HashMap<String, List<Rule>> scopedRules = normalizer.getScopedRules();    Iterator<Rule> i = normalizer.defaultRules.iterator();    System.out.println("* Rules for 'DEFAULT' scope:");    while (i.hasNext()) {        Rule r = i.next();        System.out.print("  " + r.pattern.pattern() + " -> ");        System.out.println(r.substitution);    }        if (args.length > 1) {        normalizer.normalize("http://test.com", args[1]);    }    if (scopedRules.size() > 1) {        Iterator<String> it = scopedRules.keySet().iterator();        while (it.hasNext()) {            String scope = it.next();            if (URLNormalizers.SCOPE_DEFAULT.equals(scope))                continue;            System.out.println("* Rules for '" + scope + "' scope:");            i = ((List<Rule>) scopedRules.get(scope)).iterator();            while (i.hasNext()) {                Rule r = (Rule) i.next();                System.out.print("  " + r.pattern.pattern() + " -> ");                System.out.println(r.substitution);            }        }    }    if (args.length > 0) {        System.out.println("\n---------- Normalizer test -----------");        String scope = URLNormalizers.SCOPE_DEFAULT;        if (args.length > 1)            scope = args[1];        System.out.println("Scope: " + scope);        System.out.println("Input url:  '" + args[0] + "'");        System.out.println("Output url: '" + normalizer.normalize(args[0], scope) + "'");    }    System.exit(0);}
3ddf4adf2e073ddb34da50750ea2111be644970e4e68cdd43b1513e259bba38b
accept
public boolean accept(File f)
{    if (f.getName().endsWith(".xml") && f.getName().startsWith("regex-normalize-"))        return true;    return false;}
0d81de93d3088b3b6a77fb7320a1b3fa3a200e7fe8b751b361470dd59d5f3535
testNormalizerDefault
public void testNormalizerDefault() throws Exception
{    normalizeTest((NormalizedURL[]) testData.get(URLNormalizers.SCOPE_DEFAULT), URLNormalizers.SCOPE_DEFAULT);}
edc450543de20edff90a18f4db235233db37ef3ee3116234efbe545b03bb17d2
testNormalizerScope
public void testNormalizerScope() throws Exception
{    Iterator<String> it = testData.keySet().iterator();    while (it.hasNext()) {        String scope = it.next();        normalizeTest((NormalizedURL[]) testData.get(scope), scope);    }}
9b00868fc25393bb829eed37e96758321bd001b6c42bdc9c554877b9d52bcf1a
normalizeTest
private void normalizeTest(NormalizedURL[] urls, String scope) throws Exception
{    for (int i = 0; i < urls.length; i++) {        String url = urls[i].url;        String normalized = normalizer.normalize(urls[i].url, scope);        String expected = urls[i].expectedURL;        LOG.info("scope: " + scope + " url: " + url + " | normalized: " + normalized + " | expected: " + expected);        Assert.assertEquals(urls[i].expectedURL, normalized);    }}
26ea06e1696df6377a3ca3d16a15434cb7e7c257c9377ea30f9384713f5613c5
bench
private void bench(int loops, String scope)
{    long start = System.currentTimeMillis();    try {        NormalizedURL[] expected = (NormalizedURL[]) testData.get(scope);        if (expected == null)            return;        for (int i = 0; i < loops; i++) {            normalizeTest(expected, scope);        }    } catch (Exception e) {        Assert.fail(e.toString());    }    LOG.info("bench time (" + loops + ") " + (System.currentTimeMillis() - start) + "ms");}
2bc8acb38dbd007a12d5b53ffb481f5430a6a77b1ddf1dd9e470dda13aace895
readTestFile
private NormalizedURL[] readTestFile(String scope) throws IOException
{    File f = new File(sampleDir, "regex-normalize-" + scope + ".test");    @SuppressWarnings("resource")    BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(f), "UTF-8"));    List<NormalizedURL> list = new ArrayList<NormalizedURL>();    String line;    while ((line = in.readLine()) != null) {        if (line.trim().length() == 0 || line.startsWith("#") || line.startsWith(" "))            continue;        list.add(new NormalizedURL(line));    }    return (NormalizedURL[]) list.toArray(new NormalizedURL[list.size()]);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    if (args.length == 0) {        System.err.println("TestRegexURLNormalizer [-bench <iter>] <scope>");        System.exit(-1);    }    boolean bench = false;    int iter = -1;    String scope = null;    for (int i = 0; i < args.length; i++) {        if (args[i].equals("-bench")) {            bench = true;            iter = Integer.parseInt(args[++i]);        } else            scope = args[i];    }    if (scope == null) {        System.err.println("Missing required scope name.");        System.exit(-1);    }    if (bench && iter < 0) {        System.err.println("Invalid number of iterations: " + iter);        System.exit(-1);    }    TestRegexURLNormalizer test = new TestRegexURLNormalizer();    NormalizedURL[] urls = (NormalizedURL[]) test.testData.get(scope);    if (urls == null) {        LOG.warn("Missing test data for scope '" + scope + "', using default scope.");        scope = URLNormalizers.SCOPE_DEFAULT;        urls = (NormalizedURL[]) test.testData.get(scope);    }    if (bench) {        test.bench(iter, scope);    } else {        test.normalizeTest(urls, scope);    }}
8fd3b6a758013f17936e866b94a5d5896c63c1c327e621a2661e341abe4af837
readConfiguration
private synchronized void readConfiguration(Reader configReader) throws IOException
{    if (slashesMap.size() > 0) {        return;    }    BufferedReader reader = new BufferedReader(configReader);    String line, host;    String rule;    int delimiterIndex;    while ((line = reader.readLine()) != null) {        if (StringUtils.isNotBlank(line) && !line.startsWith("#")) {            line = line.trim();            delimiterIndex = line.indexOf(" ");                        if (delimiterIndex == -1) {                delimiterIndex = line.indexOf("\t");            }            host = line.substring(0, delimiterIndex);            rule = line.substring(delimiterIndex + 1).trim();            if (rule.equals("+")) {                slashesMap.put(host, true);            } else {                slashesMap.put(host, false);            }        }    }}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;        String pluginName = "urlnormalizer-slash";    Extension[] extensions = PluginRepository.get(conf).getExtensionPoint(URLNormalizer.class.getName()).getExtensions();    for (int i = 0; i < extensions.length; i++) {        Extension extension = extensions[i];        if (extension.getDescriptor().getPluginId().equals(pluginName)) {            attributeFile = extension.getAttribute("file");            break;        }    }        if (attributeFile != null && attributeFile.trim().equals("")) {        attributeFile = null;    }    if (attributeFile != null) {        if (LOG.isInfoEnabled()) {            LOG.info("Attribute \"file\" is defined for plugin " + pluginName + " as " + attributeFile);        }    } else {        if (LOG.isWarnEnabled()) {            LOG.warn("Attribute \"file\" is not defined in plugin.xml for plugin " + pluginName);        }    }        String file = conf.get("urlnormalizer.slashes.file");    String stringRules = conf.get("urlnormalizer.slashes.rules");    if (slashesFile != null) {        file = slashesFile;    } else if (attributeFile != null) {        file = attributeFile;    }    Reader reader = null;    if (stringRules != null) {                reader = new StringReader(stringRules);    } else {        reader = conf.getConfResourceAsReader(file);    }    try {        if (reader == null) {            reader = new FileReader(file);        }        readConfiguration(reader);    } catch (IOException e) {        LOG.error(org.apache.hadoop.util.StringUtils.stringifyException(e));    }}
7909ea2cf8dbe618deca1612b5878fbd72225d6deb22452d531ffc7be0223ef7
normalize
public String normalize(String url, String scope) throws MalformedURLException
{    return normalize(url, null, scope);}
db2b35e9b320d58e9f6609c99851079c4d4fea217414bbf44ea59c8f5e4fc66a
normalize
public String normalize(String url, CrawlDatum crawlDatum, String scope) throws MalformedURLException
{        URL u = new URL(url);        String host = u.getHost();        if (slashesMap.containsKey(host)) {                String protocol = u.getProtocol();        String path = u.getPath();                if (path.length() > 1) {            String queryString = u.getQuery();                        boolean rule = slashesMap.get(host);                        int lastIndexOfSlash = path.lastIndexOf(SLASH);            boolean trailingSlash = (lastIndexOfSlash == path.length() - 1);                        if (!trailingSlash && rule) {                                int lastIndexOfDot = path.lastIndexOf(DOT);                if (path.length() < 6 || lastIndexOfDot == -1 || lastIndexOfDot < path.length() - 6) {                    StringBuilder buffer = new StringBuilder(protocol);                    buffer.append(PROTOCOL_DELIMITER);                    buffer.append(host);                    buffer.append(path);                    buffer.append(SLASH);                    if (queryString != null) {                        buffer.append(QUESTION_MARK);                        buffer.append(queryString);                    }                    url = buffer.toString();                }            } else             if (trailingSlash && !rule) {                StringBuilder buffer = new StringBuilder(protocol);                buffer.append(PROTOCOL_DELIMITER);                buffer.append(host);                buffer.append(path.substring(0, lastIndexOfSlash));                if (queryString != null) {                    buffer.append(QUESTION_MARK);                    buffer.append(queryString);                }                url = buffer.toString();            }        }    }    return url;}
9c0661c58afe414665d37e2517750eede5e9ec2089e13b2370f7b3d9d424231f
testSlashURLNormalizer
public void testSlashURLNormalizer() throws Exception
{    Configuration conf = NutchConfiguration.create();    String slashesFile = SAMPLES + SEPARATOR + "slashes.txt";    SlashURLNormalizer normalizer = new SlashURLNormalizer(slashesFile);    normalizer.setConf(conf);        assertEquals("http://example.org/", normalizer.normalize("http://example.org/", URLNormalizers.SCOPE_DEFAULT));    assertEquals("http://example.net/", normalizer.normalize("http://example.net/", URLNormalizers.SCOPE_DEFAULT));        assertEquals("http://example.org", normalizer.normalize("http://example.org", URLNormalizers.SCOPE_DEFAULT));    assertEquals("http://example.net", normalizer.normalize("http://example.net", URLNormalizers.SCOPE_DEFAULT));    assertEquals("http://example.org/", normalizer.normalize("http://example.org/", URLNormalizers.SCOPE_DEFAULT));    assertEquals("http://example.net/", normalizer.normalize("http://example.net/", URLNormalizers.SCOPE_DEFAULT));        assertEquals("http://www.example.org/page/", normalizer.normalize("http://www.example.org/page", URLNormalizers.SCOPE_DEFAULT));    assertEquals("http://www.example.net/path/to/something", normalizer.normalize("http://www.example.net/path/to/something/", URLNormalizers.SCOPE_DEFAULT));        assertEquals("http://example.org/buh/", normalizer.normalize("http://example.org/buh/", URLNormalizers.SCOPE_DEFAULT));    assertEquals("http://example.net/blaat", normalizer.normalize("http://example.net/blaat", URLNormalizers.SCOPE_DEFAULT));        assertEquals("http://example.nl/buh/", normalizer.normalize("http://example.nl/buh/", URLNormalizers.SCOPE_DEFAULT));    assertEquals("http://example.de/blaat", normalizer.normalize("http://example.de/blaat", URLNormalizers.SCOPE_DEFAULT));        assertEquals("http://www.example.org/page/?a=b&c=d", normalizer.normalize("http://www.example.org/page?a=b&c=d", URLNormalizers.SCOPE_DEFAULT));    assertEquals("http://www.example.net/path/to/something?a=b&c=d", normalizer.normalize("http://www.example.net/path/to/something/?a=b&c=d", URLNormalizers.SCOPE_DEFAULT));        assertEquals("http://www.example.org/noise.mp3", normalizer.normalize("http://www.example.org/noise.mp3", URLNormalizers.SCOPE_DEFAULT));    assertEquals("http://www.example.org/page.html", normalizer.normalize("http://www.example.org/page.html", URLNormalizers.SCOPE_DEFAULT));    assertEquals("http://www.example.org/page.shtml", normalizer.normalize("http://www.example.org/page.shtml", URLNormalizers.SCOPE_DEFAULT));        assertEquals("http://www.example.org/this.is.not.an_extension/", normalizer.normalize("http://www.example.org/this.is.not.an_extension", URLNormalizers.SCOPE_DEFAULT));}
69a2498b1aa878241d157cb825f8d64c7359335e50f1d4ef37f3f95809bd932c
setInterval
protected void setInterval(int seconds)
{    interval = seconds * 1000L;}
5d2ea53db10b73fa24d4e5c5db5eb990f9abe7106cfe94b6c5ddb42dfcfaaa58
setDuraction
protected void setDuraction(int seconds)
{    duration = seconds * 1000L;}
f167e2886cb553ef5c4224245b5366f24a38b3bbd9f13f3aabb61edfa95dca93
fetch
protected CrawlDatum fetch(CrawlDatum datum, long currentTime)
{    datum.setStatus(fetchStatus);    datum.setFetchTime(currentTime);    return datum;}
4017c2c9859b4b8876b41ce5a64e41868c226880b6b52cf24d8877d54ff0caf5
getSignature
protected byte[] getSignature()
{    return signatureImpl.calculate(content, null);}
13a3c790183926fb8bea45e217672182f94ae25c18e09e1b5da97568fb76da99
changeContent
protected void changeContent()
{    byte[] data = Arrays.copyOf(content.getContent(), content.getContent().length + 1);        data[content.getContent().length] = '2';    content.setContent(data);    LOG.info("document content changed");}
822b3374ca7517e4040b0df52ddd81a02a933ba54eefc4a4ff9e08206bf46fc8
parse
protected List<CrawlDatum> parse(CrawlDatum fetchDatum)
{    List<CrawlDatum> parseDatums = new ArrayList<CrawlDatum>(0);    if (fetchDatum.getStatus() == CrawlDatum.STATUS_FETCH_SUCCESS) {        CrawlDatum signatureDatum = new CrawlDatum(CrawlDatum.STATUS_SIGNATURE, 0);        signatureDatum.setSignature(getSignature());        parseDatums.add(signatureDatum);    }    return parseDatums;}
7afdea26fe0e3f250f99076002a88bd09e09574ea060a4a5cba320048e724140
check
protected boolean check(CrawlDatum datum)
{    if (datum.getStatus() != expectedDbStatus)        return false;    return true;}
4c4cc7c41fa6e6c0448b61a13949d9171498e127b3fb057fbdb1552cf8f0c9c4
run
protected boolean run(int maxErrors) throws IOException
{    long now = System.currentTimeMillis();    CrawlDbUpdateUtil<CrawlDbReducer> updateDb = new CrawlDbUpdateUtil<CrawlDbReducer>(new CrawlDbReducer(), context);    /* start with a db_unfetched */    CrawlDatum dbDatum = new CrawlDatum();    dbDatum.setStatus(CrawlDatum.STATUS_DB_UNFETCHED);        schedule.initializeSchedule(dummyURL, dbDatum);    dbDatum.setFetchTime(now);    LOG.info("Emulate a continuous crawl, launched every " + (interval / (FetchSchedule.SECONDS_PER_DAY * 1000)) + " day (" + (interval / 1000) + " seconds)");    long maxTime = (now + duration);    long nextTime = now;    long lastFetchTime = -1;        boolean ok = true;    CrawlDatum fetchDatum = new CrawlDatum();    /*     * Keep copies because CrawlDbReducer.reduce() and     * FetchSchedule.shouldFetch() may alter the references. Copies are used for     * verbose logging in case of an error.     */    CrawlDatum copyDbDatum = new CrawlDatum();    CrawlDatum copyFetchDatum = new CrawlDatum();    CrawlDatum afterShouldFetch = new CrawlDatum();    int errorCount = 0;    while (nextTime < maxTime) {        LOG.info("check: " + new Date(nextTime));        fetchDatum.set(dbDatum);        copyDbDatum.set(dbDatum);        if (schedule.shouldFetch(dummyURL, fetchDatum, nextTime)) {            LOG.info("... fetching now (" + new Date(nextTime) + ")");            if (lastFetchTime > -1) {                LOG.info("(last fetch: " + new Date(lastFetchTime) + " = " + TimingUtil.elapsedTime(lastFetchTime, nextTime) + " ago)");            }            lastFetchTime = nextTime;            afterShouldFetch.set(fetchDatum);            fetchDatum = fetch(fetchDatum, nextTime);            copyFetchDatum.set(fetchDatum);            List<CrawlDatum> values = new ArrayList<CrawlDatum>();            values.add(dbDatum);            values.add(fetchDatum);            values.addAll(parse(fetchDatum));            List<CrawlDatum> res = updateDb.update(values);            assertNotNull("null returned", res);            assertFalse("no CrawlDatum", 0 == res.size());            assertEquals("more than one CrawlDatum", 1, res.size());            if (!check(res.get(0))) {                LOG.info("previously in CrawlDb: " + copyDbDatum);                LOG.info("after shouldFetch(): " + afterShouldFetch);                LOG.info("fetch: " + fetchDatum);                LOG.warn("wrong result in CrawlDb: " + res.get(0));                if (++errorCount >= maxErrors) {                    if (maxErrors > 0) {                        LOG.error("Max. number of errors " + maxErrors + " reached. Stopping.");                    }                    return false;                } else {                                        ok = false;                }            }            /* use the returned CrawlDatum for the next fetch */            dbDatum = res.get(0);        }        nextTime += interval;    }    return ok;}
ea88f580d25e186ed44f61bb82136fda58000e0589b196e70a67dd005fc0adef
createCrawlDb
public static void createCrawlDb(Configuration conf, FileSystem fs, Path crawldb, List<URLCrawlDatum> init) throws Exception
{    LOG.trace("* creating crawldb: " + crawldb);    Path dir = new Path(crawldb, CrawlDb.CURRENT_NAME);    Option wKeyOpt = MapFile.Writer.keyClass(Text.class);    org.apache.hadoop.io.SequenceFile.Writer.Option wValueOpt = SequenceFile.Writer.valueClass(CrawlDatum.class);    MapFile.Writer writer = new MapFile.Writer(conf, new Path(dir, "part-r-00000"), wKeyOpt, wValueOpt);    Iterator<URLCrawlDatum> it = init.iterator();    while (it.hasNext()) {        URLCrawlDatum row = it.next();        LOG.info("adding:" + row.url.toString());        writer.append(new Text(row.url), row.datum);    }    writer.close();}
6595dcf1c35583005606ae23892af0bc711a68aaa618d1e43130b798b8bb64cf
write
public void write(Text key, CrawlDatum value) throws IOException, InterruptedException
{    values.add(value);}
070e9d0f4aa485463baac85cf0d7ea267b86012c1566e12332ee0d9b7eb5f9c0
getValues
public List<CrawlDatum> getValues()
{    return values;}
822287d83d4b2a0cb85dfe7367a1379f917d0da42858c8058991b8ed9b29802c
getCurrentValue
public CrawlDatum getCurrentValue() throws UnsupportedOperationException
{    throw new UnsupportedOperationException("Dummy context");}
541e27cbbaa25d1893ff9ab94e35566ca5ce16c5e91faaea8ce19bf21f843d7c
getCurrentKey
public Text getCurrentKey() throws UnsupportedOperationException
{    throw new UnsupportedOperationException("Dummy context with no keys");}
0aa07c49327a95be1224ed8083daf0f4a877dc6e09cdf3ba8a9c6246342a910f
progress
public void progress()
{}
3cb37c4b3c77fc05fed645dababa2e68ec4a17acb068a993a55863d241bf7c62
getCounter
public Counter getCounter(Enum<?> arg0)
{    return dummyCounters.getGroup("dummy").getCounterForName("dummy");}
fd7962a91496252a9d3d46146cead904dd82ea91b8826fafe8f6f5f502f9ffb7
getCounter
public Counter getCounter(String arg0, String arg1)
{    return dummyCounters.getGroup("dummy").getCounterForName("dummy");}
2409cf85d8443f96351b0c64eeab942f8df5009c3d4020399065190ca01047b4
setStatus
public void setStatus(String arg0) throws UnsupportedOperationException
{    throw new UnsupportedOperationException("Dummy context with no status");}
be26222e726a7b0cb4fb2ba36a32cef8b12202fe758f1b154bd105f4a1fbbcf8
getStatus
public String getStatus() throws UnsupportedOperationException
{    throw new UnsupportedOperationException("Dummy context with no status");}
e060dbfd6a3be1c0dc88e28d6f6317d6dff52708f9487eee73f51b4c1b3e85d1
getProgress
public float getProgress()
{    return 1f;}
71d0a62998501ad05f5536cd26d9059714ade2450b8b6a192003d0b43d103efe
getOutputCommitter
public OutputCommitter getOutputCommitter()
{    throw new UnsupportedOperationException("Dummy context without committer");}
cc104b1eccc8565a903563d4585a457a2779dfa2751ff71ce2ee7b80f06c5059
nextKey
public boolean nextKey()
{    return false;}
e54f90c585dcdd34f8c67cbc0dd7a90e094b3a7f9e889c8d1beeae2b9a8487ce
nextKeyValue
public boolean nextKeyValue()
{    return false;}
a48fcb7287aedb3b03fd1d5be0072e049d72d946869a8ed342101798561c2e4b
getTaskAttemptID
public TaskAttemptID getTaskAttemptID() throws UnsupportedOperationException
{    throw new UnsupportedOperationException("Dummy context without TaskAttemptID");}
e83783c407d1acb6f48251ba2f13264b406e066275b1f58e27e1b11144dee1ff
getArchiveClassPaths
public Path[] getArchiveClassPaths()
{    return null;}
77f8da983c81dd20bfe36fa64231cbe6f83587ff5436a4896560d3a198b614e6
getArchiveTimestamps
public String[] getArchiveTimestamps()
{    return null;}
4ab7a214c0834c12721688e253036990cd8292cf85c93e969f6ec0589339123b
getCacheArchives
public URI[] getCacheArchives() throws IOException
{    return null;}
18909883c1a8cbc594b57f1d8a736a026b8bb0bec064b48390ca80bb2c8e4889
getCacheFiles
public URI[] getCacheFiles() throws IOException
{    return null;}
6197d5518603d97eeb77bee64622ce8168e40da48baba8a3c8d0846cf1610c57
getCombinerClass
public Class<? extends Reducer<?, ?, ?, ?>> getCombinerClass() throws ClassNotFoundException
{    return null;}
91a429e1e5aad9b37609f230752defc53ac307f05e63f3e200e4e6018a931796
getCombinerKeyGroupingComparator
public RawComparator<?> getCombinerKeyGroupingComparator()
{    return null;}
4ab32fd1c0fc8b7e0975a577f547cc7a82d509b4844a391bcce9e94e9bd47854
getConfiguration
public Configuration getConfiguration()
{    return conf;}
498466ad57b236eeb61defe8f36d6fa31e6bacc1a81d0128bfbc0256aa4c2a33
getCredentials
public Credentials getCredentials()
{    return null;}
3cd8844625a58ca5caa5b267592e88d16b64b804f9441d09952a182cb2606b82
getFileClassPaths
public Path[] getFileClassPaths()
{    return null;}
a8982ec03e1428c58242a5f10e8d026b871e7a881940b8ffd2ca2e5a0c36ed4d
getFileTimestamps
public String[] getFileTimestamps()
{    return null;}
6abf2548bbf888f181f9855f0c3cff39e009a05d6028503908e756f911092db8
getGroupingComparator
public RawComparator<?> getGroupingComparator()
{    return null;}
2f5ba1595ca496120f3d0754bb481cd27d565a590833f936c6c4f2d33eccbf58
getInputFormatClass
public Class<? extends InputFormat<?, ?>> getInputFormatClass() throws ClassNotFoundException
{    return null;}
6878dfa4246357511c6d4e2c3ef4cf7d6028760a8e09e04584a9fd00676917c9
getJar
public String getJar()
{    return null;}
fb9b3789f0973cd517192ac83c1df4ea03cc0df1293a55fa40bec2896c8be2bf
getJobID
public JobID getJobID()
{    return null;}
d237d9e2274ef752e83f1ae525ba767f24291504b85aa3e2091fc58221dfa52a
getJobName
public String getJobName()
{    return null;}
848c6aa39c00f2ca611f54a94ac8e7a201ac5809d78d56940fc9cbf34aafb1f8
getJobSetupCleanupNeeded
public boolean getJobSetupCleanupNeeded()
{    return false;}
d0e4ad749f166f4208da13e3cfc05961fd86000c4f997b11dc0af851b09bbaf2
getLocalCacheArchives
public Path[] getLocalCacheArchives() throws IOException
{    return null;}
b74d5409762bca9c3bc66fac19186c16f7b82b8b5587c8d590762eb377984289
getLocalCacheFiles
public Path[] getLocalCacheFiles() throws IOException
{    return null;}
f58e7d2d36df9e2c8d7c6e514927c659e5d9ede5b5b0d39a4541c4c095bd73a0
getMapOutputKeyClass
public Class<?> getMapOutputKeyClass()
{    return null;}
be28f103aa4e6bba501ae08acf7f76137d4381f352b9df3316be9b839fe55041
getMapOutputValueClass
public Class<?> getMapOutputValueClass()
{    return null;}
041c735c4d3f831be5dad55aed97dfbbb794d23c7c0e59a29befd423664d082a
getMapperClass
public Class<? extends Mapper<?, ?, ?, ?>> getMapperClass() throws ClassNotFoundException
{    return null;}
419e8da17ffda7eb2cc0d7e823606db2ab5165996351469823cb5931681c8889
getMaxMapAttempts
public int getMaxMapAttempts()
{    return 0;}
d22114c7d0fbfe3ca729a908a46a0a6c3888b32b76e78c74fc0de5f90bc617b2
getMaxReduceAttempts
public int getMaxReduceAttempts()
{    return 0;}
2699f42c0098874d6b80738a53b6900a506048ecd7e4a6a4832cd64348e1a05e
getNumReduceTasks
public int getNumReduceTasks()
{    return 0;}
34c350df1600c20f9f794f5642bae37e5e5e0bfd52741ad44514f136a4ee4090
getOutputFormatClass
public Class<? extends OutputFormat<?, ?>> getOutputFormatClass() throws ClassNotFoundException
{    return null;}
7d08c508d5e56f3d81fbeb7e469623c6542fd550640e4c5cfc66e4d22b930a05
getOutputKeyClass
public Class<?> getOutputKeyClass()
{    return null;}
8f234d9238ef2be608459193772759389550595ba0cc4de79cefd6b1398a4a56
getOutputValueClass
public Class<?> getOutputValueClass()
{    return null;}
606e8b593cc37c8bba2017fde6b009d473668c0060306fdc37cd8c55b899cc16
getPartitionerClass
public Class<? extends Partitioner<?, ?>> getPartitionerClass() throws ClassNotFoundException
{    return null;}
d4608672d666977de34407dcdf27a199571b8e4acc2b39705a79100963390e98
getProfileEnabled
public boolean getProfileEnabled()
{    return false;}
89883f19bd0c1bff2bbd9ec58b6a16f403e846a67298856634787dcc6702413d
getProfileParams
public String getProfileParams()
{    return null;}
f4b374501d1f77f3ce6f8662d5a26255cb16a259afeedc53f9516a34b09b26ed
getProfileTaskRange
public IntegerRanges getProfileTaskRange(boolean arg0)
{    return null;}
fb5e35d36609e481ebb3b40a1ab82900b4c90a6f1ccc339da4f2dad87cd04d0e
getReducerClass
public Class<? extends Reducer<?, ?, ?, ?>> getReducerClass() throws ClassNotFoundException
{    return null;}
055816167774866804a86f5e8e7e5561bb6a59278cd08d677b23e6e1e2580c1b
getSortComparator
public RawComparator<?> getSortComparator()
{    return null;}
c432c8e6e4b288329ce65a18ac62d12dc0c3cbbd44f87ec86e921e67563c106c
getSymlink
public boolean getSymlink()
{    return false;}
4e58185e81a381284c273a0fa784b0ef470f1a99438be706ea940761c3f5e06e
getTaskCleanupNeeded
public boolean getTaskCleanupNeeded()
{    return false;}
ea2ce49a49536bc05bf348a94c50e41f56f9b22e202c8bf746539b1b96fe9ad5
getUser
public String getUser()
{    return null;}
96d28b333c71f6db6bce6ae7ffcd4b4ebfd24760d838524f3fbda9eb84fabf26
getWorkingDirectory
public Path getWorkingDirectory() throws IOException
{    return null;}
27cd126b62313b7f1fca75bbedc4ae31c853f815a418892d1fa0dca206517492
createContext
public static Reducer<Text, CrawlDatum, Text, CrawlDatum>.Context createContext()
{    DummyContext context = new DummyContext();    Configuration conf = context.getConfiguration();    conf.addResource("nutch-default.xml");    conf.addResource("crawl-tests.xml");    return (Reducer<Text, CrawlDatum, Text, CrawlDatum>.Context) context;}
e36239b77c5b28995be3561fde21907dac3018545b36881020a58692616c3dd3
generateSeedList
public static void generateSeedList(FileSystem fs, Path urlPath, List<String> urls) throws IOException
{    generateSeedList(fs, urlPath, urls, new ArrayList<String>());}
2e62766dfd000004d8728e810787a71913d25d9f642be0d5a1450acd5346139d
generateSeedList
public static void generateSeedList(FileSystem fs, Path urlPath, List<String> urls, List<String> metadata) throws IOException
{    FSDataOutputStream out;    Path file = new Path(urlPath, "urls.txt");    fs.mkdirs(urlPath);    out = fs.create(file);    Iterator<String> urls_i = urls.iterator();    Iterator<String> metadata_i = metadata.iterator();    String url;    String md;    while (urls_i.hasNext()) {        url = urls_i.next();        out.writeBytes(url);        if (metadata_i.hasNext()) {            md = metadata_i.next();            out.writeBytes(md);        }        out.writeBytes("\n");    }    out.flush();    out.close();}
bdda2d4a6d59c0e44ffda3e44eb78b7d60a5ba2e9c97b0a92ee5ba26f62c9ef5
getServer
public static Server getServer(int port, String staticContent) throws UnknownHostException
{    Server webServer = new org.mortbay.jetty.Server();    SocketConnector listener = new SocketConnector();    listener.setPort(port);    listener.setHost("127.0.0.1");    webServer.addConnector(listener);    ContextHandler staticContext = new ContextHandler();    staticContext.setContextPath("/");    staticContext.setResourceBase(staticContent);    staticContext.addHandler(new ResourceHandler());    webServer.addHandler(staticContext);    return webServer;}
d5f8da12aef15b0a97926cec3ac9eac584d09ff6a96c16386070fb5b948ebe52
update
public List<CrawlDatum> update(List<CrawlDatum> values)
{    List<CrawlDatum> result = new ArrayList<CrawlDatum>(0);    if (values == null || values.size() == 0) {        return result;    }        Collections.shuffle(values);    reduceDriver = ReduceDriver.newReduceDriver(reducer);    reduceDriver.getConfiguration().addResource(configuration);    reduceDriver.withInput(dummyURL, values);    List<Pair<Text, CrawlDatum>> reduceResult;    try {        reduceResult = reduceDriver.run();        for (Pair<Text, CrawlDatum> p : reduceResult) {            if (p.getFirst().equals(dummyURL)) {                result.add(p.getSecond());            }        }    } catch (IOException e) {        LOG.error(StringUtils.stringifyException(e));        return result;    }    return result;}
9bda38e28178e29b299b4fb4f60d28e26ef6c116c966367322bbaa00f5639436
update
public List<CrawlDatum> update(CrawlDatum dbDatum, CrawlDatum fetchDatum)
{    List<CrawlDatum> values = new ArrayList<CrawlDatum>();    if (dbDatum != null)        values.add(dbDatum);    if (fetchDatum != null)        values.add(fetchDatum);    return update(values);}
79ab65f6132f8165998bdf602a7b02e1081ae7ff4363bacc48be0435355773ed
update
public List<CrawlDatum> update(CrawlDatum... values)
{    return update(Arrays.asList(values));}
6595dcf1c35583005606ae23892af0bc711a68aaa618d1e43130b798b8bb64cf
write
public void write(Text key, CrawlDatum value) throws IOException, InterruptedException
{    values.add(value);}
070e9d0f4aa485463baac85cf0d7ea267b86012c1566e12332ee0d9b7eb5f9c0
getValues
public List<CrawlDatum> getValues()
{    return values;}
822287d83d4b2a0cb85dfe7367a1379f917d0da42858c8058991b8ed9b29802c
getCurrentValue
public CrawlDatum getCurrentValue() throws UnsupportedOperationException
{    throw new UnsupportedOperationException("Dummy context");}
541e27cbbaa25d1893ff9ab94e35566ca5ce16c5e91faaea8ce19bf21f843d7c
getCurrentKey
public Text getCurrentKey() throws UnsupportedOperationException
{    throw new UnsupportedOperationException("Dummy context with no keys");}
0aa07c49327a95be1224ed8083daf0f4a877dc6e09cdf3ba8a9c6246342a910f
progress
public void progress()
{}
3cb37c4b3c77fc05fed645dababa2e68ec4a17acb068a993a55863d241bf7c62
getCounter
public Counter getCounter(Enum<?> arg0)
{    return dummyCounters.getGroup("dummy").getCounterForName("dummy");}
fd7962a91496252a9d3d46146cead904dd82ea91b8826fafe8f6f5f502f9ffb7
getCounter
public Counter getCounter(String arg0, String arg1)
{    return dummyCounters.getGroup("dummy").getCounterForName("dummy");}
2409cf85d8443f96351b0c64eeab942f8df5009c3d4020399065190ca01047b4
setStatus
public void setStatus(String arg0) throws UnsupportedOperationException
{    throw new UnsupportedOperationException("Dummy context with no status");}
be26222e726a7b0cb4fb2ba36a32cef8b12202fe758f1b154bd105f4a1fbbcf8
getStatus
public String getStatus() throws UnsupportedOperationException
{    throw new UnsupportedOperationException("Dummy context with no status");}
e060dbfd6a3be1c0dc88e28d6f6317d6dff52708f9487eee73f51b4c1b3e85d1
getProgress
public float getProgress()
{    return 1f;}
71d0a62998501ad05f5536cd26d9059714ade2450b8b6a192003d0b43d103efe
getOutputCommitter
public OutputCommitter getOutputCommitter()
{    throw new UnsupportedOperationException("Dummy context without committer");}
cc104b1eccc8565a903563d4585a457a2779dfa2751ff71ce2ee7b80f06c5059
nextKey
public boolean nextKey()
{    return false;}
e54f90c585dcdd34f8c67cbc0dd7a90e094b3a7f9e889c8d1beeae2b9a8487ce
nextKeyValue
public boolean nextKeyValue()
{    return false;}
a48fcb7287aedb3b03fd1d5be0072e049d72d946869a8ed342101798561c2e4b
getTaskAttemptID
public TaskAttemptID getTaskAttemptID() throws UnsupportedOperationException
{    throw new UnsupportedOperationException("Dummy context without TaskAttemptID");}
e83783c407d1acb6f48251ba2f13264b406e066275b1f58e27e1b11144dee1ff
getArchiveClassPaths
public Path[] getArchiveClassPaths()
{    return null;}
77f8da983c81dd20bfe36fa64231cbe6f83587ff5436a4896560d3a198b614e6
getArchiveTimestamps
public String[] getArchiveTimestamps()
{    return null;}
4ab7a214c0834c12721688e253036990cd8292cf85c93e969f6ec0589339123b
getCacheArchives
public URI[] getCacheArchives() throws IOException
{    return null;}
18909883c1a8cbc594b57f1d8a736a026b8bb0bec064b48390ca80bb2c8e4889
getCacheFiles
public URI[] getCacheFiles() throws IOException
{    return null;}
6197d5518603d97eeb77bee64622ce8168e40da48baba8a3c8d0846cf1610c57
getCombinerClass
public Class<? extends Reducer<?, ?, ?, ?>> getCombinerClass() throws ClassNotFoundException
{    return null;}
91a429e1e5aad9b37609f230752defc53ac307f05e63f3e200e4e6018a931796
getCombinerKeyGroupingComparator
public RawComparator<?> getCombinerKeyGroupingComparator()
{    return null;}
4ab32fd1c0fc8b7e0975a577f547cc7a82d509b4844a391bcce9e94e9bd47854
getConfiguration
public Configuration getConfiguration()
{    return null;}
498466ad57b236eeb61defe8f36d6fa31e6bacc1a81d0128bfbc0256aa4c2a33
getCredentials
public Credentials getCredentials()
{    return null;}
3cd8844625a58ca5caa5b267592e88d16b64b804f9441d09952a182cb2606b82
getFileClassPaths
public Path[] getFileClassPaths()
{    return null;}
a8982ec03e1428c58242a5f10e8d026b871e7a881940b8ffd2ca2e5a0c36ed4d
getFileTimestamps
public String[] getFileTimestamps()
{    return null;}
6abf2548bbf888f181f9855f0c3cff39e009a05d6028503908e756f911092db8
getGroupingComparator
public RawComparator<?> getGroupingComparator()
{    return null;}
2f5ba1595ca496120f3d0754bb481cd27d565a590833f936c6c4f2d33eccbf58
getInputFormatClass
public Class<? extends InputFormat<?, ?>> getInputFormatClass() throws ClassNotFoundException
{    return null;}
6878dfa4246357511c6d4e2c3ef4cf7d6028760a8e09e04584a9fd00676917c9
getJar
public String getJar()
{    return null;}
fb9b3789f0973cd517192ac83c1df4ea03cc0df1293a55fa40bec2896c8be2bf
getJobID
public JobID getJobID()
{    return null;}
d237d9e2274ef752e83f1ae525ba767f24291504b85aa3e2091fc58221dfa52a
getJobName
public String getJobName()
{    return null;}
848c6aa39c00f2ca611f54a94ac8e7a201ac5809d78d56940fc9cbf34aafb1f8
getJobSetupCleanupNeeded
public boolean getJobSetupCleanupNeeded()
{    return false;}
d0e4ad749f166f4208da13e3cfc05961fd86000c4f997b11dc0af851b09bbaf2
getLocalCacheArchives
public Path[] getLocalCacheArchives() throws IOException
{    return null;}
b74d5409762bca9c3bc66fac19186c16f7b82b8b5587c8d590762eb377984289
getLocalCacheFiles
public Path[] getLocalCacheFiles() throws IOException
{    return null;}
f58e7d2d36df9e2c8d7c6e514927c659e5d9ede5b5b0d39a4541c4c095bd73a0
getMapOutputKeyClass
public Class<?> getMapOutputKeyClass()
{    return null;}
be28f103aa4e6bba501ae08acf7f76137d4381f352b9df3316be9b839fe55041
getMapOutputValueClass
public Class<?> getMapOutputValueClass()
{    return null;}
041c735c4d3f831be5dad55aed97dfbbb794d23c7c0e59a29befd423664d082a
getMapperClass
public Class<? extends Mapper<?, ?, ?, ?>> getMapperClass() throws ClassNotFoundException
{    return null;}
419e8da17ffda7eb2cc0d7e823606db2ab5165996351469823cb5931681c8889
getMaxMapAttempts
public int getMaxMapAttempts()
{    return 0;}
d22114c7d0fbfe3ca729a908a46a0a6c3888b32b76e78c74fc0de5f90bc617b2
getMaxReduceAttempts
public int getMaxReduceAttempts()
{    return 0;}
2699f42c0098874d6b80738a53b6900a506048ecd7e4a6a4832cd64348e1a05e
getNumReduceTasks
public int getNumReduceTasks()
{    return 0;}
34c350df1600c20f9f794f5642bae37e5e5e0bfd52741ad44514f136a4ee4090
getOutputFormatClass
public Class<? extends OutputFormat<?, ?>> getOutputFormatClass() throws ClassNotFoundException
{    return null;}
7d08c508d5e56f3d81fbeb7e469623c6542fd550640e4c5cfc66e4d22b930a05
getOutputKeyClass
public Class<?> getOutputKeyClass()
{    return null;}
8f234d9238ef2be608459193772759389550595ba0cc4de79cefd6b1398a4a56
getOutputValueClass
public Class<?> getOutputValueClass()
{    return null;}
606e8b593cc37c8bba2017fde6b009d473668c0060306fdc37cd8c55b899cc16
getPartitionerClass
public Class<? extends Partitioner<?, ?>> getPartitionerClass() throws ClassNotFoundException
{    return null;}
d4608672d666977de34407dcdf27a199571b8e4acc2b39705a79100963390e98
getProfileEnabled
public boolean getProfileEnabled()
{    return false;}
89883f19bd0c1bff2bbd9ec58b6a16f403e846a67298856634787dcc6702413d
getProfileParams
public String getProfileParams()
{    return null;}
f4b374501d1f77f3ce6f8662d5a26255cb16a259afeedc53f9516a34b09b26ed
getProfileTaskRange
public IntegerRanges getProfileTaskRange(boolean arg0)
{    return null;}
fb5e35d36609e481ebb3b40a1ab82900b4c90a6f1ccc339da4f2dad87cd04d0e
getReducerClass
public Class<? extends Reducer<?, ?, ?, ?>> getReducerClass() throws ClassNotFoundException
{    return null;}
055816167774866804a86f5e8e7e5561bb6a59278cd08d677b23e6e1e2580c1b
getSortComparator
public RawComparator<?> getSortComparator()
{    return null;}
c432c8e6e4b288329ce65a18ac62d12dc0c3cbbd44f87ec86e921e67563c106c
getSymlink
public boolean getSymlink()
{    return false;}
4e58185e81a381284c273a0fa784b0ef470f1a99438be706ea940761c3f5e06e
getTaskCleanupNeeded
public boolean getTaskCleanupNeeded()
{    return false;}
ea2ce49a49536bc05bf348a94c50e41f56f9b22e202c8bf746539b1b96fe9ad5
getUser
public String getUser()
{    return null;}
96d28b333c71f6db6bce6ae7ffcd4b4ebfd24760d838524f3fbda9eb84fabf26
getWorkingDirectory
public Path getWorkingDirectory() throws IOException
{    return null;}
d5f8da12aef15b0a97926cec3ac9eac584d09ff6a96c16386070fb5b948ebe52
update
public List<CrawlDatum> update(List<CrawlDatum> values)
{    if (values == null || values.size() == 0) {        return new ArrayList<CrawlDatum>(0);    }        Collections.shuffle(values);    DummyContext context = new DummyContext();    try {        Iterable<CrawlDatum> iterable_values = (Iterable) values;        reducer.reduce(dummyURL, iterable_values, (Reducer<Text, CrawlDatum, Text, CrawlDatum>.Context) context);    } catch (IOException e) {        LOG.error(StringUtils.stringifyException(e));    } catch (InterruptedException e) {        LOG.error(StringUtils.stringifyException(e));    }    return context.getValues();}
9bda38e28178e29b299b4fb4f60d28e26ef6c116c966367322bbaa00f5639436
update
public List<CrawlDatum> update(CrawlDatum dbDatum, CrawlDatum fetchDatum)
{    List<CrawlDatum> values = new ArrayList<CrawlDatum>();    if (dbDatum != null)        values.add(dbDatum);    if (fetchDatum != null)        values.add(fetchDatum);    return update(values);}
79ab65f6132f8165998bdf602a7b02e1081ae7ff4363bacc48be0435355773ed
update
public List<CrawlDatum> update(CrawlDatum... values)
{    return update(Arrays.asList(values));}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    conf = NutchConfiguration.create();    inc_rate = conf.getFloat("db.fetch.schedule.adaptive.inc_rate", 0.2f);    dec_rate = conf.getFloat("db.fetch.schedule.adaptive.dec_rate", 0.2f);    interval = 100;    lastModified = 0;}
d95897aceb328ca045fc16d5c54be1d11b781d8d6154d48f5a6dba14adb82929
testAdaptiveFetchSchedule
public void testAdaptiveFetchSchedule()
{    FetchSchedule fs = new AdaptiveFetchSchedule();    fs.setConf(conf);    CrawlDatum p = prepareCrawlDatum();    Text url = new Text("http://www.example.com");    changed = FetchSchedule.STATUS_UNKNOWN;    fs.setFetchSchedule(url, p, p.getFetchTime(), p.getModifiedTime(), curTime, lastModified, changed);    validateFetchInterval(changed, p.getFetchInterval());    changed = FetchSchedule.STATUS_MODIFIED;    fs.setFetchSchedule(url, p, p.getFetchTime(), p.getModifiedTime(), curTime, lastModified, changed);    validateFetchInterval(changed, p.getFetchInterval());    p.setFetchInterval(interval);    changed = FetchSchedule.STATUS_NOTMODIFIED;    fs.setFetchSchedule(url, p, p.getFetchTime(), p.getModifiedTime(), curTime, lastModified, changed);    validateFetchInterval(changed, p.getFetchInterval());}
16780b3c9f3c647fbef189f7d2b9d1d12c2935635adb5a9ab901695e05fea683
prepareCrawlDatum
public CrawlDatum prepareCrawlDatum()
{    CrawlDatum p = new CrawlDatum();    p.setStatus(CrawlDatum.STATUS_DB_UNFETCHED);    p.setFetchInterval(interval);    p.setScore(1.0f);    p.setFetchTime(0);    return p;}
8b6c8102557895479fe823f359d75c7abafaa7495a2591f5cb12c34a1b6910c8
validateFetchInterval
private void validateFetchInterval(int changed, int getInterval)
{    if (changed == FetchSchedule.STATUS_UNKNOWN) {        assertEquals(getInterval, interval);    } else if (changed == FetchSchedule.STATUS_MODIFIED) {        calculateInterval = (int) (interval - (interval * dec_rate));        assertEquals(getInterval, calculateInterval);    } else if (changed == FetchSchedule.STATUS_NOTMODIFIED) {        calculateInterval = (int) (interval + (interval * inc_rate));        assertEquals(getInterval, calculateInterval);    }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    conf = CrawlDBTestUtil.createContext().getConfiguration();    fs = FileSystem.get(conf);    fs.delete(testdir, true);}
39e5ba029cc67f6f1d45c6d20f0df595ec16bc61da20d7680fcbbdae4fe7f95b
tearDown
public void tearDown()
{    delete(testdir);}
15434c84b70eb9f45fa72983b31660864739157a9f59df38b7e92ca91a15b48f
delete
private void delete(Path p)
{    try {        fs.delete(p, true);    } catch (IOException e) {    }}
cf45c0a6eabccb320836c2576576aafa4ef3433d0efde106ab59113b67e902da
testUrl404Purging
public void testUrl404Purging() throws Exception
{        ArrayList<URLCrawlDatum> list = new ArrayList<URLCrawlDatum>();    list.add(new URLCrawlDatum(new Text("http://www.example.com"), new CrawlDatum(CrawlDatum.STATUS_DB_GONE, 0, 0.0f)));    list.add(new URLCrawlDatum(new Text("http://www.example1.com"), new CrawlDatum(CrawlDatum.STATUS_DB_FETCHED, 0, 0.0f)));    list.add(new URLCrawlDatum(new Text("http://www.example2.com"), new CrawlDatum(CrawlDatum.STATUS_DB_UNFETCHED, 0, 0.0f)));    dbDir = new Path(testdir, "crawldb");    newCrawlDb = new Path(testdir, "newcrawldb");        CrawlDBTestUtil.createCrawlDb(conf, fs, dbDir, list);        conf.setBoolean(CrawlDb.CRAWLDB_PURGE_404, true);    conf.setBoolean(CrawlDbFilter.URL_NORMALIZING, true);    conf.setBoolean(CrawlDbFilter.URL_FILTERING, false);    conf.setInt("urlnormalizer.loop.count", 2);    Job job = NutchJob.getInstance(conf);    job.setJobName("Test CrawlDbFilter");    Path current = new Path(dbDir, "current");    if (FileSystem.get(conf).exists(current)) {        FileInputFormat.addInputPath(job, current);    }    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setMapperClass(CrawlDbFilter.class);    job.setReducerClass(CrawlDbReducer.class);    FileOutputFormat.setOutputPath(job, newCrawlDb);    job.setOutputFormatClass(MapFileOutputFormat.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(CrawlDatum.class);    job.setJarByClass(CrawlDbFilter.class);    job.waitForCompletion(true);    Path fetchlist = new Path(new Path(newCrawlDb, "part-r-00000"), "data");    ArrayList<URLCrawlDatum> l = readContents(fetchlist);        Assert.assertEquals(2, l.size());}
8bf367cef0341b5bf8135a65be66c7e6212d6dd32393e4256ab7b81ec238aa95
readContents
private ArrayList<URLCrawlDatum> readContents(Path fetchlist) throws IOException
{        Option fFile = SequenceFile.Reader.file(fetchlist);    SequenceFile.Reader reader = new SequenceFile.Reader(conf, fFile);    ArrayList<URLCrawlDatum> l = new ArrayList<URLCrawlDatum>();    READ: do {        Text key = new Text();        CrawlDatum value = new CrawlDatum();        if (!reader.next(key, value)) {            break READ;        }        l.add(new URLCrawlDatum(key, value));    } while (true);    reader.close();    return l;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    init1.add(url10);    init1.add(url11);    init2.add(url20);    init2.add(url21);    long time = System.currentTimeMillis();    cd1 = new CrawlDatum();    cd1.setFetchInterval(1.0f);    cd1.setFetchTime(time);    cd1.getMetaData().put(new Text("name"), new Text("cd1"));    cd1.getMetaData().put(new Text("cd1"), new Text("cd1"));    cd2 = new CrawlDatum();    cd2.setFetchInterval(1.0f);    cd2.setFetchTime(time + 10000);    cd2.getMetaData().put(new Text("name"), new Text("cd2"));    cd3 = new CrawlDatum();    cd3.setFetchInterval(1.0f);    cd3.setFetchTime(time + 10000);    cd3.getMetaData().putAll(cd1.getMetaData());    cd3.getMetaData().putAll(cd2.getMetaData());    expected.put(url10, cd3);    expected.put(url11, cd1);    expected.put(url21, cd2);    conf = NutchConfiguration.create();    fs = FileSystem.get(conf);    testDir = new Path("test-crawldb-" + new java.util.Random().nextInt());    fs.mkdirs(testDir);}
39e5ba029cc67f6f1d45c6d20f0df595ec16bc61da20d7680fcbbdae4fe7f95b
tearDown
public void tearDown()
{    try {        if (fs.exists(testDir))            fs.delete(testDir, true);    } catch (Exception e) {    }    try {        reader.close();    } catch (Exception e) {    }}
e39016eeb9c72cf18333dd3199d59f606d2690887d5e45a40e52def873d1f3b3
testMerge
public void testMerge() throws Exception
{    Path crawldb1 = new Path(testDir, "crawldb1");    Path crawldb2 = new Path(testDir, "crawldb2");    Path output = new Path(testDir, "output");    createCrawlDb(conf, fs, crawldb1, init1, cd1);    createCrawlDb(conf, fs, crawldb2, init2, cd2);    CrawlDbMerger merger = new CrawlDbMerger(conf);    LOG.debug("* merging crawldbs to " + output);    merger.merge(output, new Path[] { crawldb1, crawldb2 }, false, false);    LOG.debug("* reading crawldb: " + output);    reader = new CrawlDbReader();    String crawlDb = output.toString();    Iterator<String> it = expected.keySet().iterator();    while (it.hasNext()) {        String url = it.next();        LOG.debug("url=" + url);        CrawlDatum cd = expected.get(url);        CrawlDatum res = reader.get(crawlDb, url, conf);        LOG.debug(" -> " + res);        System.out.println("url=" + url);        System.out.println(" cd " + cd);        System.out.println(" res " + res);                Assert.assertNotNull(res);        Assert.assertTrue(cd.equals(res));    }    reader.close();    fs.delete(testDir, true);}
0999fe7fb286c0360c5e86f678d6cac6d4e34e2a15da2a9b178f148f27a00d59
createCrawlDb
private void createCrawlDb(Configuration config, FileSystem fs, Path crawldb, TreeSet<String> init, CrawlDatum cd) throws Exception
{    LOG.debug("* creating crawldb: " + crawldb);    Path dir = new Path(crawldb, CrawlDb.CURRENT_NAME);    Option wKeyOpt = MapFile.Writer.keyClass(Text.class);    org.apache.hadoop.io.SequenceFile.Writer.Option wValueOpt = SequenceFile.Writer.valueClass(CrawlDatum.class);    MapFile.Writer writer = new MapFile.Writer(config, new Path(dir, "part-r-00000"), wKeyOpt, wValueOpt);    Iterator<String> it = init.iterator();    while (it.hasNext()) {        String key = it.next();        writer.append(new Text(key), cd);    }    writer.close();}
319cafc63446bf9729a2ec312ac7f15a2ea9813c91ba9805d5fe0f177f2477fb
testCrawlDbStateTransitionMatrix
public void testCrawlDbStateTransitionMatrix()
{    LOG.info("Test CrawlDatum state transitions");    Reducer<Text, CrawlDatum, Text, CrawlDatum>.Context context = CrawlDBTestUtil.createContext();    Configuration conf = context.getConfiguration();    CrawlDbUpdateUtil updateDb = null;    try {        updateDb = new CrawlDbUpdateUtil(new CrawlDbReducer(), context);    } catch (IOException e) {        e.printStackTrace();    }    int retryMax = conf.getInt("db.fetch.retry.max", 3);    for (String sched : schedules) {        LOG.info("Testing state transitions with " + sched);        conf.set("db.fetch.schedule.class", "org.apache.nutch.crawl." + sched);        FetchSchedule schedule = FetchScheduleFactory.getFetchSchedule(conf);        for (int i = 0; i < fetchDbStatusPairs.length; i++) {            byte fromDbStatus = fetchDbStatusPairs[i][1];            for (int j = 0; j < fetchDbStatusPairs.length; j++) {                byte fetchStatus = fetchDbStatusPairs[j][0];                CrawlDatum fromDb = null;                if (fromDbStatus == -1) {                                                } else {                    fromDb = new CrawlDatum();                    fromDb.setStatus(fromDbStatus);                                        schedule.initializeSchedule(CrawlDbUpdateUtil.dummyURL, fromDb);                }                                byte toDbStatus = fetchDbStatusPairs[j][1];                if (fetchStatus == -1) {                    if (fromDbStatus == -1) {                                                toDbStatus = STATUS_DB_UNFETCHED;                    } else {                                                toDbStatus = fromDbStatus;                    }                } else if (fetchStatus == STATUS_FETCH_RETRY) {                                        if (fromDb == null || fromDb.getRetriesSinceFetch() < retryMax) {                        toDbStatus = STATUS_DB_UNFETCHED;                    } else {                        toDbStatus = STATUS_DB_GONE;                    }                }                String fromDbStatusName = (fromDbStatus == -1 ? "<not in CrawlDb>" : getStatusName(fromDbStatus));                String fetchStatusName = (fetchStatus == -1 ? "<only inlinks>" : CrawlDatum.getStatusName(fetchStatus));                LOG.info(fromDbStatusName + " + " + fetchStatusName + " => " + getStatusName(toDbStatus));                List<CrawlDatum> values = new ArrayList<CrawlDatum>();                for (int l = 0; l <= 2; l++) {                                        CrawlDatum fetch = null;                    if (fetchStatus == -1) {                                                if (l == 0)                            continue;                    } else {                        fetch = new CrawlDatum();                        if (fromDb != null) {                            fetch.set(fromDb);                        } else {                                                        schedule.initializeSchedule(CrawlDbUpdateUtil.dummyURL, fetch);                        }                        fetch.setStatus(fetchStatus);                        fetch.setFetchTime(System.currentTimeMillis());                    }                    if (fromDb != null)                        values.add(fromDb);                    if (fetch != null)                        values.add(fetch);                    for (int n = 0; n < l; n++) {                        values.add(linked);                    }                    List<CrawlDatum> res = updateDb.update(values);                    if (res.size() != 1) {                        fail("CrawlDb update didn't result in one single CrawlDatum per URL");                        continue;                    }                    byte status = res.get(0).getStatus();                    if (status != toDbStatus) {                        fail("CrawlDb update for " + fromDbStatusName + " and " + fetchStatusName + " and " + l + " inlinks results in " + getStatusName(status) + " (expected: " + getStatusName(toDbStatus) + ")");                    }                    values.clear();                }            }        }    }}
b0948f6e5db16e95ef6aee68f8211216377a91c478648c99e8bbd7f306ec5b2c
testCrawlDbStatTransitionInject
public void testCrawlDbStatTransitionInject()
{    LOG.info("Test CrawlDatum states in Injector after inject");    Configuration conf = CrawlDBTestUtil.createContext().getConfiguration();    Injector.InjectReducer injector = new Injector.InjectReducer();    CrawlDbUpdateTestDriver<Injector.InjectReducer> injectDriver = new CrawlDbUpdateTestDriver<Injector.InjectReducer>(injector, conf);    ScoringFilters scfilters = new ScoringFilters(conf);    for (String sched : schedules) {        LOG.info("Testing inject with " + sched);        conf.set("db.fetch.schedule.class", "org.apache.nutch.crawl." + sched);        FetchSchedule schedule = FetchScheduleFactory.getFetchSchedule(conf);        List<CrawlDatum> values = new ArrayList<CrawlDatum>();        for (int i = 0; i < fetchDbStatusPairs.length; i++) {            byte fromDbStatus = fetchDbStatusPairs[i][1];            byte toDbStatus = fromDbStatus;            if (fromDbStatus == -1) {                toDbStatus = STATUS_DB_UNFETCHED;            } else {                CrawlDatum fromDb = new CrawlDatum();                fromDb.setStatus(fromDbStatus);                schedule.initializeSchedule(CrawlDbUpdateUtil.dummyURL, fromDb);                values.add(fromDb);            }            LOG.info("inject " + (fromDbStatus == -1 ? "<not in CrawlDb>" : CrawlDatum.getStatusName(fromDbStatus)) + " + " + getStatusName(STATUS_INJECTED) + " => " + getStatusName(toDbStatus));            CrawlDatum injected = new CrawlDatum(STATUS_INJECTED, conf.getInt("db.fetch.interval.default", 2592000), 0.1f);            schedule.initializeSchedule(CrawlDbUpdateUtil.dummyURL, injected);            try {                scfilters.injectedScore(CrawlDbUpdateUtil.dummyURL, injected);            } catch (ScoringFilterException e) {                LOG.error(StringUtils.stringifyException(e));            }            values.add(injected);            List<CrawlDatum> res = injectDriver.update(values);            if (res.size() != 1) {                fail("Inject didn't result in one single CrawlDatum per URL");                continue;            }            byte status = res.get(0).getStatus();            if (status != toDbStatus) {                fail("Inject for " + (fromDbStatus == -1 ? "" : getStatusName(fromDbStatus) + " and ") + getStatusName(STATUS_INJECTED) + " results in " + getStatusName(status) + " (expected: " + getStatusName(toDbStatus) + ")");            }            values.clear();        }    }}
fe7e57a2c77bd6c68ff2904ada37cf2fe5c59535133a0ea362d03ede96609f78
testCrawlDbReducerNotModified
public void testCrawlDbReducerNotModified()
{    LOG.info("Test state notmodified");    Context context = CrawlDBTestUtil.createContext();    Configuration conf = context.getConfiguration();    ;        for (String sched : schedules) {        String desc = "test notmodified by signature comparison + " + sched;        LOG.info(desc);        conf.set("db.fetch.schedule.class", "org.apache.nutch.crawl." + sched);        ContinuousCrawlTestUtil crawlUtil = new CrawlTestFetchNotModified(context);        try {            if (!crawlUtil.run(20)) {                fail("failed: " + desc);            }        } catch (IOException e) {            e.printStackTrace();        }    }        for (String sched : schedules) {        String desc = "test notmodified by HTTP 304 + " + sched;        LOG.info(desc);        conf.set("db.fetch.schedule.class", "org.apache.nutch.crawl." + sched);        ContinuousCrawlTestUtil crawlUtil = new CrawlTestFetchNotModifiedHttp304(context);        try {            if (!crawlUtil.run(20)) {                fail("failed: " + desc);            }        } catch (IOException e) {            e.printStackTrace();        }    }}
8cd8b9de09a47a621feaa98204750edd6b4d2c3b58edd97e8896433741ae11aa
check
protected boolean check(CrawlDatum result)
{    if (lastFetchTime > 0 && (currFetchTime - lastFetchTime) > maxFetchInterval) {        LOG.error("last effective fetch (HTTP 200, not HTTP 304), at " + new Date(lastFetchTime) + ", took place more than db.fetch.interval.max time, " + "segment containing fetched content may have been deleted");        return false;    }    switch(result.getStatus()) {        case STATUS_DB_NOTMODIFIED:                        if ((previousDbState == STATUS_DB_FETCHED || previousDbState == STATUS_DB_NOTMODIFIED)) {                if (lastSignature != null && result.getSignature() != null && SignatureComparator._compare(lastSignature, result.getSignature()) != 0) {                    LOG.error("document has changed (signature changed) but state is still " + getStatusName(STATUS_DB_NOTMODIFIED));                    return false;                }                LOG.info("ok: " + result);                return checkModifiedTime(result, firstFetchTime);            }            LOG.warn("notmodified without previous fetch");            break;        case STATUS_DB_FETCHED:            if (previousDbState == STATUS_DB_UNFETCHED) {                LOG.info("ok (first fetch): " + result);                return checkModifiedTime(result, firstFetchTime);            } else if (lastSignature != null && result.getSignature() != null && SignatureComparator._compare(lastSignature, result.getSignature()) != 0) {                LOG.info("ok (content changed): " + result);                                return checkModifiedTime(result, currFetchTime);            } else {                LOG.warn("document has not changed, db_notmodified expected");            }            break;        case STATUS_DB_UNFETCHED:            /**             * Status db_unfetched is possible with {@link AdaptiveFetchSchedule}             * because {@link CrawlDbReducer#reduce} calls             * {@link FetchSchedule#forceRefetch} to force a re-fetch if fetch             * interval grows too large.             */            if (schedule.getClass() == AdaptiveFetchSchedule.class) {                LOG.info("state set to unfetched by AdaptiveFetchSchedule");                if (result.getSignature() != null) {                    LOG.warn("must reset signature: " + result);                    return false;                }                LOG.info("ok: " + result);                firstFetchTime = 0;                return true;            }    }    LOG.warn("wrong result: " + result);    return false;}
7e2979c81030d650f5ebfe657baed7e7de6c61a064d3b7092d48cb40cb811b65
checkModifiedTime
private boolean checkModifiedTime(CrawlDatum result, long modifiedTime)
{    if (modifiedTime == result.getModifiedTime()) {        return true;    }    LOG.error("wrong modified time: " + new Date(result.getModifiedTime()) + " (expected " + new Date(modifiedTime) + ")");    return false;}
f167e2886cb553ef5c4224245b5366f24a38b3bbd9f13f3aabb61edfa95dca93
fetch
protected CrawlDatum fetch(CrawlDatum datum, long currentTime)
{    lastFetchTime = currFetchTime;    currFetchTime = currentTime;    if (lastFetchTime > 0)        elapsedDuration += (currFetchTime - lastFetchTime);    previousDbState = datum.getStatus();    lastSignature = datum.getSignature();    datum = super.fetch(datum, currentTime);    if (firstFetchTime == 0) {        firstFetchTime = currFetchTime;    } else if (elapsedDuration < (duration / 2)) {                changeContent();        firstFetchTime = currFetchTime;    }    return datum;}
f167e2886cb553ef5c4224245b5366f24a38b3bbd9f13f3aabb61edfa95dca93
fetch
protected CrawlDatum fetch(CrawlDatum datum, long currentTime)
{    lastFetchTime = currFetchTime;    currFetchTime = currentTime;    previousDbState = datum.getStatus();    lastSignature = datum.getSignature();    int httpCode;    /*       * document is "really" fetched (no HTTP 304) - if last-modified time or       * signature are unset (page has not been fetched before or fetch is       * forced) - for test purposes, we simulate a modified after "one year"       */    if (datum.getModifiedTime() == 0 && datum.getSignature() == null || (currFetchTime - firstFetchTime) > (duration / 2)) {        firstFetchTime = currFetchTime;        httpCode = 200;        datum.setStatus(STATUS_FETCH_SUCCESS);                changeContent();    } else {        httpCode = 304;        datum.setStatus(STATUS_FETCH_NOTMODIFIED);    }    LOG.info("fetched with HTTP " + httpCode + " => " + getStatusName(datum.getStatus()));    datum.setFetchTime(currentTime);    return datum;}
05b6ce0dfecf73a8892e8d6801c5dcd7646ef9ca55b496892cfa34137dfa6278
testCrawlDbReducerPageGoneSchedule1
public void testCrawlDbReducerPageGoneSchedule1()
{    LOG.info("NUTCH-1245: test long running continuous crawl");    ContinuousCrawlTestUtil crawlUtil = new ContinuousCrawlTestUtil(STATUS_FETCH_GONE, STATUS_DB_GONE);    try {        if (!crawlUtil.run(20)) {            fail("fetch_gone did not result in a db_gone (NUTCH-1245)");        }    } catch (IOException e) {        e.printStackTrace();    }}
c2cdf0ae3e09306bb7e1aea04767da99116392f94b579bbb9747e559b7661350
testCrawlDbReducerPageGoneSchedule2
public void testCrawlDbReducerPageGoneSchedule2()
{    LOG.info("NUTCH-1245 (misconfiguration): test with db.fetch.interval.default > (1.5 * db.fetch.interval.max)");    Context context = CrawlDBTestUtil.createContext();    Configuration conf = context.getConfiguration();    int fetchIntervalMax = conf.getInt("db.fetch.interval.max", 0);    conf.setInt("db.fetch.interval.default", 3 + (int) (fetchIntervalMax * 1.5));    ContinuousCrawlTestUtil crawlUtil = new ContinuousCrawlTestUtil(context, STATUS_FETCH_GONE, STATUS_DB_GONE);    try {        if (!crawlUtil.run(0)) {            fail("fetch_gone did not result in a db_gone (NUTCH-1245)");        }    } catch (IOException e) {        e.printStackTrace();    }}
f92cba2d858c9dc9d08d0084e4741430389e3a5cb873b9e3e0933e2d3a99cfba
testSignatureReset
public void testSignatureReset()
{    LOG.info("NUTCH-1422 must reset signature for redirects and similar states");    Context context = CrawlDBTestUtil.createContext();    Configuration conf = context.getConfiguration();    for (String sched : schedules) {        LOG.info("Testing reset signature with " + sched);        conf.set("db.fetch.schedule.class", "org.apache.nutch.crawl." + sched);        ContinuousCrawlTestUtil crawlUtil = new CrawlTestSignatureReset(context);        try {            if (!crawlUtil.run(20)) {                fail("failed: signature not reset");            }        } catch (IOException e) {            e.printStackTrace();        }    }}
f167e2886cb553ef5c4224245b5366f24a38b3bbd9f13f3aabb61edfa95dca93
fetch
protected CrawlDatum fetch(CrawlDatum datum, long currentTime)
{    datum = super.fetch(datum, currentTime);    counter++;        if (counter % 2 == 1) {        fetchState = STATUS_FETCH_SUCCESS;    } else {        fetchState = noContentStates[(counter % 6) / 2][0];    }    LOG.info("Step " + counter + ": fetched with " + getStatusName(fetchState));    datum.setStatus(fetchState);    return datum;}
8cd8b9de09a47a621feaa98204750edd6b4d2c3b58edd97e8896433741ae11aa
check
protected boolean check(CrawlDatum result)
{    if (result.getStatus() == STATUS_DB_NOTMODIFIED && !(fetchState == STATUS_FETCH_SUCCESS || fetchState == STATUS_FETCH_NOTMODIFIED)) {        LOG.error("Should never get into state " + getStatusName(STATUS_DB_NOTMODIFIED) + " from " + getStatusName(fetchState));        return false;    }    if (result.getSignature() != null && !(result.getStatus() == STATUS_DB_FETCHED || result.getStatus() == STATUS_DB_NOTMODIFIED)) {        LOG.error("Signature not reset in state " + getStatusName(result.getStatus()));            }    return true;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    conf = CrawlDBTestUtil.createContext().getConfiguration();    fs = FileSystem.get(conf);    fs.delete(testdir, true);}
39e5ba029cc67f6f1d45c6d20f0df595ec16bc61da20d7680fcbbdae4fe7f95b
tearDown
public void tearDown()
{    delete(testdir);}
15434c84b70eb9f45fa72983b31660864739157a9f59df38b7e92ca91a15b48f
delete
private void delete(Path p)
{    try {        fs.delete(p, true);    } catch (IOException e) {    }}
64dd70f85435834f57a2b85aa404f6dcd7448ae5abe74266afcf1c29e8beb18f
testGenerateHighest
public void testGenerateHighest() throws Exception
{    final int NUM_RESULTS = 2;    ArrayList<URLCrawlDatum> list = new ArrayList<URLCrawlDatum>();    for (int i = 0; i <= 100; i++) {        list.add(createURLCrawlDatum("http://aaa/" + pad(i), 1, i));    }    createCrawlDB(list);    Path generatedSegment = generateFetchlist(NUM_RESULTS, conf, false);    Path fetchlist = new Path(new Path(generatedSegment, CrawlDatum.GENERATE_DIR_NAME), "part-r-00000");    ArrayList<URLCrawlDatum> l = readContents(fetchlist);        Collections.sort(l, new ScoreComparator());        Assert.assertEquals(NUM_RESULTS, l.size());        Assert.assertEquals("http://aaa/100", (l.get(0).url.toString()));    Assert.assertEquals("http://aaa/099", (l.get(1).url.toString()));}
2aed082a48c4f258e0dc9d70be0d93cb80d8c0f833204a56ef5026542ace8de4
pad
private String pad(int i)
{    String s = Integer.toString(i);    while (s.length() < 3) {        s = "0" + s;    }    return s;}
e93e47c58d7a5392d8d5cfe44690ab1dc75067152759b098b906c1154cd48753
compare
public int compare(URLCrawlDatum tuple1, URLCrawlDatum tuple2)
{    if (tuple2.datum.getScore() - tuple1.datum.getScore() < 0) {        return -1;    }    if (tuple2.datum.getScore() - tuple1.datum.getScore() > 0) {        return 1;    }    return 0;}
07a3bbfa8ddb9f20567d49ff7e6aff57563130cd925e882b2d8220802feddbe5
testGenerateHostLimit
public void testGenerateHostLimit() throws Exception
{    ArrayList<URLCrawlDatum> list = new ArrayList<URLCrawlDatum>();    list.add(createURLCrawlDatum("http://www.example.com/index1.html", 1, 1));    list.add(createURLCrawlDatum("http://www.example.com/index2.html", 1, 1));    list.add(createURLCrawlDatum("http://www.example.com/index3.html", 1, 1));    createCrawlDB(list);    int maxPerHost = 1;    Configuration myConfiguration = new Configuration(conf);    myConfiguration.setInt(Generator.GENERATOR_MAX_COUNT, maxPerHost);    Path generatedSegment = generateFetchlist(Integer.MAX_VALUE, myConfiguration, false);    Path fetchlistPath = new Path(new Path(generatedSegment, CrawlDatum.GENERATE_DIR_NAME), "part-r-00000");    ArrayList<URLCrawlDatum> fetchList = readContents(fetchlistPath);        int expectedFetchListSize = Math.min(maxPerHost, list.size());    Assert.assertEquals("Failed to apply generate.max.count by host", expectedFetchListSize, fetchList.size());    maxPerHost = 2;    myConfiguration = new Configuration(conf);    myConfiguration.setInt(Generator.GENERATOR_MAX_COUNT, maxPerHost);    generatedSegment = generateFetchlist(Integer.MAX_VALUE, myConfiguration, false);    fetchlistPath = new Path(new Path(generatedSegment, CrawlDatum.GENERATE_DIR_NAME), "part-r-00000");    fetchList = readContents(fetchlistPath);        expectedFetchListSize = Math.min(maxPerHost, list.size());    Assert.assertEquals("Failed to apply generate.max.count by host", expectedFetchListSize, fetchList.size());    maxPerHost = 3;    myConfiguration = new Configuration(conf);    myConfiguration.setInt(Generator.GENERATOR_MAX_COUNT, maxPerHost);    generatedSegment = generateFetchlist(Integer.MAX_VALUE, myConfiguration, false);    fetchlistPath = new Path(new Path(generatedSegment, CrawlDatum.GENERATE_DIR_NAME), "part-r-00000");    fetchList = readContents(fetchlistPath);        expectedFetchListSize = Math.min(maxPerHost, list.size());    Assert.assertEquals("Failed to apply generate.max.count by host", expectedFetchListSize, fetchList.size());}
e64a14c6eb45e9f53f554253a56f302489393748262ab5b80e402123edfda757
testGenerateDomainLimit
public void testGenerateDomainLimit() throws Exception
{    ArrayList<URLCrawlDatum> list = new ArrayList<URLCrawlDatum>();    list.add(createURLCrawlDatum("http://a.example.com/index.html", 1, 1));    list.add(createURLCrawlDatum("http://b.example.com/index.html", 1, 1));    list.add(createURLCrawlDatum("http://c.example.com/index.html", 1, 1));    createCrawlDB(list);    int maxPerDomain = 1;    Configuration myConfiguration = new Configuration(conf);    myConfiguration.setInt(Generator.GENERATOR_MAX_COUNT, maxPerDomain);    myConfiguration.set(Generator.GENERATOR_COUNT_MODE, Generator.GENERATOR_COUNT_VALUE_DOMAIN);    Path generatedSegment = generateFetchlist(Integer.MAX_VALUE, myConfiguration, false);    Path fetchlistPath = new Path(new Path(generatedSegment, CrawlDatum.GENERATE_DIR_NAME), "part-r-00000");    ArrayList<URLCrawlDatum> fetchList = readContents(fetchlistPath);        int expectedFetchListSize = Math.min(maxPerDomain, list.size());    Assert.assertEquals("Failed to apply generate.max.count by domain", expectedFetchListSize, fetchList.size());    maxPerDomain = 2;    myConfiguration = new Configuration(myConfiguration);    myConfiguration.setInt(Generator.GENERATOR_MAX_COUNT, maxPerDomain);    generatedSegment = generateFetchlist(Integer.MAX_VALUE, myConfiguration, false);    fetchlistPath = new Path(new Path(generatedSegment, CrawlDatum.GENERATE_DIR_NAME), "part-r-00000");    fetchList = readContents(fetchlistPath);        expectedFetchListSize = Math.min(maxPerDomain, list.size());    Assert.assertEquals("Failed to apply generate.max.count by domain", expectedFetchListSize, fetchList.size());    maxPerDomain = 3;    myConfiguration = new Configuration(myConfiguration);    myConfiguration.setInt(Generator.GENERATOR_MAX_COUNT, maxPerDomain);    generatedSegment = generateFetchlist(Integer.MAX_VALUE, myConfiguration, false);    fetchlistPath = new Path(new Path(generatedSegment, CrawlDatum.GENERATE_DIR_NAME), "part-r-00000");    fetchList = readContents(fetchlistPath);        expectedFetchListSize = Math.min(maxPerDomain, list.size());    Assert.assertEquals("Failed to apply generate.max.count by domain", expectedFetchListSize, fetchList.size());}
6973a33d564b70aac49baa1940bdcc6c500c0ca0bfe1fd1289ba9d9c94594003
testFilter
public void testFilter() throws IOException, Exception
{    ArrayList<URLCrawlDatum> list = new ArrayList<URLCrawlDatum>();    list.add(createURLCrawlDatum("http://www.example.com/index.html", 1, 1));    list.add(createURLCrawlDatum("http://www.example.net/index.html", 1, 1));    list.add(createURLCrawlDatum("http://www.example.org/index.html", 1, 1));    createCrawlDB(list);    Configuration myConfiguration = new Configuration(conf);    myConfiguration.set("urlfilter.suffix.file", "filter-all.txt");    Path generatedSegment = generateFetchlist(Integer.MAX_VALUE, myConfiguration, true);    Assert.assertNull("should be null (0 entries)", generatedSegment);    generatedSegment = generateFetchlist(Integer.MAX_VALUE, myConfiguration, false);    Path fetchlistPath = new Path(new Path(generatedSegment, CrawlDatum.GENERATE_DIR_NAME), "part-r-00000");    ArrayList<URLCrawlDatum> fetchList = readContents(fetchlistPath);        Assert.assertEquals(list.size(), fetchList.size());}
8bf367cef0341b5bf8135a65be66c7e6212d6dd32393e4256ab7b81ec238aa95
readContents
private ArrayList<URLCrawlDatum> readContents(Path fetchlist) throws IOException
{        Option rFile = SequenceFile.Reader.file(fetchlist);    SequenceFile.Reader reader = new SequenceFile.Reader(conf, rFile);    ArrayList<URLCrawlDatum> l = new ArrayList<URLCrawlDatum>();    READ: do {        Text key = new Text();        CrawlDatum value = new CrawlDatum();        if (!reader.next(key, value)) {            break READ;        }        l.add(new URLCrawlDatum(key, value));    } while (true);    reader.close();    return l;}
c5e59f96334a776da6af6c75a81c8c08846bef5fd2a372c4d5d53fd018883aa2
generateFetchlist
private Path generateFetchlist(int numResults, Configuration config, boolean filter) throws IOException, ClassNotFoundException, InterruptedException
{        Generator g = new Generator(config);    Path[] generatedSegment = g.generate(dbDir, segmentsDir, -1, numResults, Long.MAX_VALUE, filter, false);    if (generatedSegment == null)        return null;    return generatedSegment[0];}
5d95e29797b606e26d0de06863f810eeba4e9fb5c4225d61f4bf765d33b0db95
createCrawlDB
private void createCrawlDB(ArrayList<URLCrawlDatum> list) throws IOException, Exception
{    dbDir = new Path(testdir, "crawldb");    segmentsDir = new Path(testdir, "segments");    fs.mkdirs(dbDir);    fs.mkdirs(segmentsDir);        CrawlDBTestUtil.createCrawlDb(conf, fs, dbDir, list);}
061da4f60d0de2ec5d940ee90905a11eaac3e8b74737b14228cdb3ce7bea25dd
createURLCrawlDatum
private URLCrawlDatum createURLCrawlDatum(final String url, final int fetchInterval, final float score)
{    return new CrawlDBTestUtil.URLCrawlDatum(new Text(url), new CrawlDatum(CrawlDatum.STATUS_DB_UNFETCHED, fetchInterval, score));}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    conf = CrawlDBTestUtil.createContext().getConfiguration();    urlPath = new Path(testdir, "urls");    crawldbPath = new Path(testdir, "crawldb");    fs = FileSystem.get(conf);    if (fs.exists(urlPath))        fs.delete(urlPath, false);    if (fs.exists(crawldbPath))        fs.delete(crawldbPath, true);}
b15ec24534831cd8187de4c70ba4518879af91358fd307c4f306a42afcccad2c
tearDown
public void tearDown() throws IOException
{    fs.delete(testdir, true);}
ae6b32a9adc2587f761c4399d29dd87d250e15d313d8c9524c5c6717adfb6e0e
testInject
public void testInject() throws IOException, ClassNotFoundException, InterruptedException
{    ArrayList<String> urls = new ArrayList<String>();            ArrayList<String> metadata = new ArrayList<String>();    for (int i = 0; i < 100; i++) {        urls.add("http://zzz.com/" + i + ".html");        metadata.add("\tnutch.score=2." + i + "\tnutch.fetchInterval=171717\tkey=value");    }    CrawlDBTestUtil.generateSeedList(fs, urlPath, urls, metadata);    Injector injector = new Injector(conf);    injector.inject(crawldbPath, urlPath);        List<String> read = readCrawldb();    Collections.sort(read);    Collections.sort(urls);    Assert.assertEquals(urls.size(), read.size());    Assert.assertTrue(read.containsAll(urls));    Assert.assertTrue(urls.containsAll(read));        ArrayList<String> urls2 = new ArrayList<String>();    for (int i = 0; i < 100; i++) {        urls2.add("http://xxx.com/" + i + ".html");                        urls2.add("http://zzz.com/" + i + ".html");    }    CrawlDBTestUtil.generateSeedList(fs, urlPath, urls2);    injector = new Injector(conf);    conf.setBoolean("db.injector.update", true);    injector.inject(crawldbPath, urlPath);    urls.addAll(urls2);        read = readCrawldb();    Collections.sort(read);    Collections.sort(urls);        Assert.assertEquals(urls.size() - 100, read.size());    Assert.assertTrue(read.containsAll(urls));    Assert.assertTrue(urls.containsAll(read));        Map<String, CrawlDatum> records = readCrawldbRecords();            Text writableKey = new Text("key");    Text writableValue = new Text("value");    for (String url : urls) {        if (url.indexOf("http://zzz") == 0) {                        Assert.assertTrue(records.get(url).getFetchInterval() == 171717);                        Assert.assertTrue(records.get(url).getScore() != 1.0);                        Assert.assertEquals(writableValue, records.get(url).getMetaData().get(writableKey));        }    }}
1a6f5a6bc18a3767382c6ba6217c85bbbab1d8f56bfd6e0c0c58e658b5b60aba
readCrawldb
private List<String> readCrawldb() throws IOException
{    Path dbfile = new Path(crawldbPath, CrawlDb.CURRENT_NAME + "/part-r-00000/data");    System.out.println("reading:" + dbfile);    Option rFile = SequenceFile.Reader.file(dbfile);    @SuppressWarnings("resource")    SequenceFile.Reader reader = new SequenceFile.Reader(conf, rFile);    ArrayList<String> read = new ArrayList<String>();    READ: do {        Text key = new Text();        CrawlDatum value = new CrawlDatum();        if (!reader.next(key, value))            break READ;        read.add(key.toString());    } while (true);    return read;}
d43d90f550bc57ff47e23481de5465fd040c3ee79a6306632763c1d51a86b776
readCrawldbRecords
private HashMap<String, CrawlDatum> readCrawldbRecords() throws IOException
{    Path dbfile = new Path(crawldbPath, CrawlDb.CURRENT_NAME + "/part-r-00000/data");    System.out.println("reading:" + dbfile);    Option rFile = SequenceFile.Reader.file(dbfile);    @SuppressWarnings("resource")    SequenceFile.Reader reader = new SequenceFile.Reader(conf, rFile);    HashMap<String, CrawlDatum> read = new HashMap<String, CrawlDatum>();    READ: do {        Text key = new Text();        CrawlDatum value = new CrawlDatum();        if (!reader.next(key, value))            break READ;        read.put(key.toString(), value);    } while (true);    return read;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    init1.put(url10, urls10);    init1.put(url11, urls11);    init2.put(url20, urls20);    init2.put(url21, urls21);    expected.put(url10, urls10_expected);    expected.put(url11, urls11_expected);    expected.put(url20, urls20_expected);    expected.put(url21, urls21_expected);    conf = NutchConfiguration.create();    fs = FileSystem.get(conf);    testDir = new Path("build/test/test-linkdb-" + new java.util.Random().nextInt());    fs.mkdirs(testDir);}
39e5ba029cc67f6f1d45c6d20f0df595ec16bc61da20d7680fcbbdae4fe7f95b
tearDown
public void tearDown()
{    try {        if (fs.exists(testDir))            fs.delete(testDir, true);    } catch (Exception e) {    }    try {        reader.close();    } catch (Exception e) {    }}
e39016eeb9c72cf18333dd3199d59f606d2690887d5e45a40e52def873d1f3b3
testMerge
public void testMerge() throws Exception
{    Configuration conf = NutchConfiguration.create();    FileSystem fs = FileSystem.get(conf);    fs.mkdirs(testDir);    Path linkdb1 = new Path(testDir, "linkdb1");    Path linkdb2 = new Path(testDir, "linkdb2");    Path output = new Path(testDir, "output");    createLinkDb(conf, fs, linkdb1, init1);    createLinkDb(conf, fs, linkdb2, init2);    LinkDbMerger merger = new LinkDbMerger(conf);    LOG.debug("* merging linkdbs to " + output);    merger.merge(output, new Path[] { linkdb1, linkdb2 }, false, false);    LOG.debug("* reading linkdb: " + output);    reader = new LinkDbReader(conf, output);    Iterator<String> it = expected.keySet().iterator();    while (it.hasNext()) {        String url = it.next();        LOG.debug("url=" + url);        String[] vals = expected.get(url);        Inlinks inlinks = reader.getInlinks(new Text(url));                Assert.assertNotNull(inlinks);        ArrayList<String> links = new ArrayList<String>();        Iterator<?> it2 = inlinks.iterator();        while (it2.hasNext()) {            Inlink in = (Inlink) it2.next();            links.add(in.getFromUrl());        }        for (int i = 0; i < vals.length; i++) {            LOG.debug(" -> " + vals[i]);            Assert.assertTrue(links.contains(vals[i]));        }    }    reader.close();    fs.delete(testDir, true);}
4bfbae1e3b8060745b190186c05abfd7157406f6f5e37a95b716fe2fde3cc8ca
createLinkDb
private void createLinkDb(Configuration config, FileSystem fs, Path linkdb, TreeMap<String, String[]> init) throws Exception
{    LOG.debug("* creating linkdb: " + linkdb);    Path dir = new Path(linkdb, LinkDb.CURRENT_NAME);    Option wKeyOpt = MapFile.Writer.keyClass(Text.class);    org.apache.hadoop.io.SequenceFile.Writer.Option wValueOpt = SequenceFile.Writer.valueClass(Inlinks.class);    MapFile.Writer writer = new MapFile.Writer(config, new Path(dir, "part-00000"), wKeyOpt, wValueOpt);    Iterator<String> it = init.keySet().iterator();    while (it.hasNext()) {        String key = it.next();        Inlinks inlinks = new Inlinks();        String[] vals = init.get(key);        for (int i = 0; i < vals.length; i++) {            Inlink in = new Inlink(vals[i], vals[i]);            inlinks.add(in);        }        writer.append(new Text(key), inlinks);    }    writer.close();}
22cb65a2fbac69ea5c74ee5b696995187fc9969812b62b340d95f87e1013c0c1
testGetSignature
public void testGetSignature()
{    Configuration conf = NutchConfiguration.create();    Signature signature1 = SignatureFactory.getSignature(conf);    Signature signature2 = SignatureFactory.getSignature(conf);    Assert.assertNotNull(signature1);    Assert.assertNotNull(signature2);    Assert.assertEquals(signature1, signature2);}
22cb65a2fbac69ea5c74ee5b696995187fc9969812b62b340d95f87e1013c0c1
testGetSignature
public void testGetSignature()
{    Configuration conf = NutchConfiguration.create();    Signature textProf = new TextProfileSignature();    textProf.setConf(conf);    String text = "Hello World The Quick Brown Fox Jumped Over the Lazy Fox";    ParseData pd = new ParseData(ParseStatus.STATUS_SUCCESS, "Hello World", new Outlink[0], new Metadata());    byte[] signature1 = textProf.calculate(new Content(), new ParseImpl(text, pd));    Assert.assertNotNull(signature1);    List<String> words = Arrays.asList(text.split("\\s"));    Collections.shuffle(words);    String text2 = String.join(" ", words);    byte[] signature2 = textProf.calculate(new Content(), new ParseImpl(text2, pd));    Assert.assertNotNull(signature2);    Assert.assertEquals(StringUtil.toHexString(signature1), StringUtil.toHexString(signature2));}
27f0a7b5c573322a876b0ca4b3432895423ff355d95a1cdd6180b6cea44811b6
testCrawlDbReducerPageRetrySchedule
public void testCrawlDbReducerPageRetrySchedule()
{    LOG.info("NUTCH-578: test long running continuous crawl with fetch_retry");    ContinuousCrawlTestUtil crawlUtil = new ContinuousCrawlTestFetchRetry();        try {        if (!crawlUtil.run(150)) {            fail("fetch_retry did not result in a db_gone if retry counter > maxRetries (NUTCH-578)");        }    } catch (IOException e) {        e.printStackTrace();    }}
f167e2886cb553ef5c4224245b5366f24a38b3bbd9f13f3aabb61edfa95dca93
fetch
protected CrawlDatum fetch(CrawlDatum datum, long currentTime)
{    datum.setStatus(fetchStatus);    datum.setFetchTime(currentTime);    totalRetries++;    return datum;}
8cd8b9de09a47a621feaa98204750edd6b4d2c3b58edd97e8896433741ae11aa
check
protected boolean check(CrawlDatum result)
{    if (result.getRetriesSinceFetch() > retryMax) {        LOG.warn("Retry counter > db.fetch.retry.max: " + result);    } else if (result.getRetriesSinceFetch() == Byte.MAX_VALUE) {        LOG.warn("Retry counter max. value reached (overflow imminent): " + result);    } else if (result.getRetriesSinceFetch() < 0) {        LOG.error("Retry counter overflow: " + result);        return false;    }        if (totalRetries < retryMax) {        if (result.getStatus() == STATUS_DB_UNFETCHED) {            LOG.info("ok: " + result);            result.getRetriesSinceFetch();            return true;        }    } else {        if (result.getStatus() == STATUS_DB_GONE) {            LOG.info("ok: " + result);            return true;        }    }    LOG.warn("wrong: " + result);    return false;}
6b00c190ed802a55f81c901f85eb2fab87d54a413e4e8a77354bca69564c9d6a
testAdaptiveFetchScheduleSyncDelta
public void testAdaptiveFetchScheduleSyncDelta()
{    LOG.info("NUTCH-1564 test SYNC_DELTA calculation of AdaptiveFetchSchedule");    Context context = CrawlDBTestUtil.createContext();    Configuration conf = context.getConfiguration();        conf.setLong("db.fetch.interval.default", 172800);        conf.setLong("db.fetch.schedule.adaptive.min_interval", 86400);        conf.setLong("db.fetch.schedule.adaptive.max_interval", 604800);        conf.setLong("db.fetch.interval.max", 604800);    conf.set("db.fetch.schedule.class", "org.apache.nutch.crawl.AdaptiveFetchSchedule");    ContinuousCrawlTestUtil crawlUtil = new CrawlTestFetchScheduleNotModifiedFetchTime(context);    crawlUtil.setInterval(FetchSchedule.SECONDS_PER_DAY / 3);    try {        if (!crawlUtil.run(100)) {            fail("failed: sync_delta calculation with AdaptiveFetchSchedule");        }    } catch (IOException e) {        e.printStackTrace();    }}
f167e2886cb553ef5c4224245b5366f24a38b3bbd9f13f3aabb61edfa95dca93
fetch
protected CrawlDatum fetch(CrawlDatum datum, long currentTime)
{        fetchTime = currentTime;    return super.fetch(datum, currentTime);}
8cd8b9de09a47a621feaa98204750edd6b4d2c3b58edd97e8896433741ae11aa
check
protected boolean check(CrawlDatum result)
{    if (result.getStatus() == STATUS_DB_NOTMODIFIED) {                long secondsUntilNextFetch = (result.getFetchTime() - fetchTime) / 1000L;        if (secondsUntilNextFetch < -1) {                        LOG.error("Next fetch time is in the past: " + result);            return false;        }        if (secondsUntilNextFetch < 60) {                                    LOG.error("Less then one minute until next fetch: " + result);        }                if (secondsUntilNextFetch + 60 < minInterval || secondsUntilNextFetch - 60 > maxInterval) {            LOG.error("Interval until next fetch time (" + TimingUtil.elapsedTime(fetchTime, result.getFetchTime()) + ") is not within min. and max. interval: " + result);                }    }    return true;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    conf = CrawlDBTestUtil.createContext().getConfiguration();    fs = FileSystem.get(conf);    fs.delete(testdir, true);    urlPath = new Path(testdir, "urls");    crawldbPath = new Path(testdir, "crawldb");    segmentsPath = new Path(testdir, "segments");    server = CrawlDBTestUtil.getServer(conf.getInt("content.server.port", 50000), "build/test/data/fetch-test-site");    server.start();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    server.stop();    for (int i = 0; i < 5; i++) {        if (!server.isStopped()) {            Thread.sleep(1000);        }    }    fs.delete(testdir, true);}
f743ffdd0f12e5fbd46d93d00dc00904fd42868ea8cab96a6e90a57fd9b383ef
testFetch
public void testFetch() throws IOException, ClassNotFoundException, InterruptedException
{        ArrayList<String> urls = new ArrayList<String>();    addUrl(urls, "index.html");    addUrl(urls, "pagea.html");    addUrl(urls, "pageb.html");    addUrl(urls, "dup_of_pagea.html");    addUrl(urls, "nested_spider_trap.html");    addUrl(urls, "exception.html");    CrawlDBTestUtil.generateSeedList(fs, urlPath, urls);        Injector injector = new Injector(conf);    injector.inject(crawldbPath, urlPath);        Generator g = new Generator(conf);    Path[] generatedSegment = g.generate(crawldbPath, segmentsPath, 1, Long.MAX_VALUE, Long.MAX_VALUE, false, false);    long time = System.currentTimeMillis();        Fetcher fetcher = new Fetcher(conf);        conf.setBoolean("fetcher.parse", true);    fetcher.fetch(generatedSegment[0], 1);    time = System.currentTimeMillis() - time;        int minimumTime = (int) ((urls.size() + 1) * 1000 * conf.getFloat("fetcher.server.delay", 5));    Assert.assertTrue(time > minimumTime);        Path content = new Path(new Path(generatedSegment[0], Content.DIR_NAME), "part-r-00000/data");    @SuppressWarnings("resource")    SequenceFile.Reader reader = new SequenceFile.Reader(conf, SequenceFile.Reader.file(content));    ArrayList<String> handledurls = new ArrayList<String>();    READ_CONTENT: do {        Text key = new Text();        Content value = new Content();        if (!reader.next(key, value))            break READ_CONTENT;        String contentString = new String(value.getContent());        if (contentString.indexOf("Nutch fetcher test page") != -1) {            handledurls.add(key.toString());        }    } while (true);    reader.close();    Collections.sort(urls);    Collections.sort(handledurls);        Assert.assertEquals(urls.size(), handledurls.size());        Assert.assertTrue(handledurls.containsAll(urls));    Assert.assertTrue(urls.containsAll(handledurls));    handledurls.clear();        Path parseData = new Path(new Path(generatedSegment[0], ParseData.DIR_NAME), "part-r-00000/data");    reader = new SequenceFile.Reader(conf, SequenceFile.Reader.file(parseData));    READ_PARSE_DATA: do {        Text key = new Text();        ParseData value = new ParseData();        if (!reader.next(key, value))            break READ_PARSE_DATA;                                Metadata contentMeta = value.getContentMeta();        if (contentMeta.get(Nutch.SEGMENT_NAME_KEY) != null && contentMeta.get(Nutch.SIGNATURE_KEY) != null) {            handledurls.add(key.toString());        }    } while (true);    Collections.sort(handledurls);    Assert.assertEquals(urls.size(), handledurls.size());    Assert.assertTrue(handledurls.containsAll(urls));    Assert.assertTrue(urls.containsAll(handledurls));}
73d25e489bf192c4d2526f7cf4ed396fc899b44e9505f3f50441c9db928ad070
addUrl
private void addUrl(ArrayList<String> urls, String page)
{    urls.add("http://127.0.0.1:" + server.getConnectors()[0].getPort() + "/" + page);}
25edadbc47207362c7759318e5e057647ee1e28ec1492f4b60d26bb4627c19fe
testAgentNameCheck
public void testAgentNameCheck()
{    boolean failedNoAgentName = false;    conf.set("http.agent.name", "");    try {        conf.setBoolean("fetcher.parse", false);        Fetcher fetcher = new Fetcher(conf);        fetcher.fetch(null, 1);    } catch (IllegalArgumentException iae) {        String message = iae.getMessage();        failedNoAgentName = message.equals("Fetcher: No agents listed in " + "'http.agent.name' property.");    } catch (Exception e) {    }    Assert.assertTrue(failedNoAgentName);}
14f71205b6ac95d1f029eae87521f6f0a3fc1032bec976b64aa0fc59feca775d
testBinaryContentBase64
public void testBinaryContentBase64()
{    configuration = NutchConfiguration.create();    configuration.setBoolean(IndexerMapReduce.INDEXER_BINARY_AS_BASE64, true);    Charset[] testCharsets = { StandardCharsets.UTF_8, Charset.forName("iso-8859-1"), Charset.forName("iso-8859-2") };    for (Charset charset : testCharsets) {        LOG.info("Testing indexing binary content as base64 for charset {}", charset.name());        String htmlDoc = testHtmlDoc;        if (charset != StandardCharsets.UTF_8) {            htmlDoc = htmlDoc.replaceAll("utf-8", charset.name());            if (charset.name().equalsIgnoreCase("iso-8859-1")) {                                htmlDoc = htmlDoc.replaceAll("\\s*<[^>]+\\slang=\"cs\".+?\\n", "");            } else if (charset.name().equalsIgnoreCase("iso-8859-2")) {                                htmlDoc = htmlDoc.replaceAll("\\s*<[^>]+\\slang=\"fr\".+?\\n", "");            }        }        Content content = new Content(testUrl, testUrl, htmlDoc.getBytes(charset), htmlContentType, htmlMeta, configuration);        NutchDocument doc = runIndexer(crawlDatumDbFetched, crawlDatumFetchSuccess, parseText, parseData, content);        assertNotNull("No NutchDocument indexed", doc);        String binaryContentBase64 = (String) doc.getField("binaryContent").getValues().get(0);        LOG.info("binary content (base64): {}", binaryContentBase64);        String binaryContent = new String(Base64.decodeBase64(binaryContentBase64), charset);        LOG.info("binary content (decoded): {}", binaryContent);        assertEquals("Binary content (" + charset + ") not correctly saved as base64", htmlDoc, binaryContent);    }}
5c26a4f0df0802b3febaeb5ffca72920b5eef672c8fc41a5b742c1d2148eeefb
runIndexer
public NutchDocument runIndexer(CrawlDatum dbDatum, CrawlDatum fetchDatum, ParseText parseText, ParseData parseData, Content content)
{    List<NutchWritable> values = new ArrayList<NutchWritable>();    values.add(new NutchWritable(dbDatum));    values.add(new NutchWritable(fetchDatum));    values.add(new NutchWritable(parseText));    values.add(new NutchWritable(parseData));    values.add(new NutchWritable(content));    reduceDriver = ReduceDriver.newReduceDriver(reducer);    reduceDriver.getConfiguration().addResource(configuration);    reduceDriver.withInput(testUrlText, values);    List<Pair<Text, NutchIndexAction>> reduceResult;    NutchDocument doc = null;    try {        reduceResult = reduceDriver.run();        for (Pair<Text, NutchIndexAction> p : reduceResult) {            if (p.getSecond().action != NutchIndexAction.DELETE) {                doc = p.getSecond().doc;            }        }    } catch (IOException e) {        LOG.error(StringUtils.stringifyException(e));    }    return doc;}
89cdada1279b1a75f2d1fe56f473dbf4941a0c9fc5c8f265e4dc9856ab9b7829
testNonExistingIndexingFilter
public void testNonExistingIndexingFilter() throws IndexingException
{    Configuration conf = NutchConfiguration.create();    conf.addResource("nutch-default.xml");    conf.addResource("crawl-tests.xml");    String class1 = "NonExistingFilter";    String class2 = "org.apache.nutch.indexer.basic.BasicIndexingFilter";    conf.set(IndexingFilters.INDEXINGFILTER_ORDER, class1 + " " + class2);    IndexingFilters filters = new IndexingFilters(conf);    filters.filter(new NutchDocument(), new ParseImpl("text", new ParseData(new ParseStatus(), "title", new Outlink[0], new Metadata())), new Text("http://www.example.com/"), new CrawlDatum(), new Inlinks());}
f7a578fd89d3e4f23a65afa2071b60c787f63678a4f04459767d15e185d1f7d6
testNutchDocumentNullIndexingFilter
public void testNutchDocumentNullIndexingFilter() throws IndexingException
{    Configuration conf = NutchConfiguration.create();    conf.addResource("nutch-default.xml");    conf.addResource("crawl-tests.xml");    IndexingFilters filters = new IndexingFilters(conf);    NutchDocument doc = filters.filter(null, new ParseImpl("text", new ParseData(new ParseStatus(), "title", new Outlink[0], new Metadata())), new Text("http://www.example.com/"), new CrawlDatum(), new Inlinks());    Assert.assertNull(doc);}
dfc87d70d1b49343eedec343a0bc3f34052e221ef2f3c167e8d6450804410e34
testFilterCacheIndexingFilter
public void testFilterCacheIndexingFilter() throws IndexingException
{    Configuration conf = NutchConfiguration.create();    conf.addResource("nutch-default.xml");    conf.addResource("crawl-tests.xml");    String class1 = "org.apache.nutch.indexer.basic.BasicIndexingFilter";    conf.set(IndexingFilters.INDEXINGFILTER_ORDER, class1);    IndexingFilters filters1 = new IndexingFilters(conf);    NutchDocument fdoc1 = filters1.filter(new NutchDocument(), new ParseImpl("text", new ParseData(new ParseStatus(), "title", new Outlink[0], new Metadata())), new Text("http://www.example.com/"), new CrawlDatum(), new Inlinks());        String class2 = "org.apache.nutch.indexer.metadata.MetadataIndexer";        Metadata md = new Metadata();    md.add("example", "data");        conf.set("index.content.md", "example");        conf.set(IndexingFilters.INDEXINGFILTER_ORDER, class1 + " " + class2);    IndexingFilters filters2 = new IndexingFilters(conf);    NutchDocument fdoc2 = filters2.filter(new NutchDocument(), new ParseImpl("text", new ParseData(new ParseStatus(), "title", new Outlink[0], md)), new Text("http://www.example.com/"), new CrawlDatum(), new Inlinks());    Assert.assertEquals(fdoc1.getFieldNames().size(), fdoc2.getFieldNames().size());}
947548b872c0a62a3a6fe6cf350efc984b87aa5c3b0e500fa3d20fede8513d24
testWriteNonNull
public void testWriteNonNull()
{    Metadata met = new Metadata();    met.add(CONTENTTYPE, null);    met.add(CONTENTTYPE, "text/bogus");    met.add(CONTENTTYPE, "text/bogus2");    met = writeRead(met);    Assert.assertNotNull(met);    Assert.assertEquals(met.size(), 1);    boolean hasBogus = false, hasBogus2 = false;    String[] values = met.getValues(CONTENTTYPE);    Assert.assertNotNull(values);    Assert.assertEquals(values.length, 2);    for (int i = 0; i < values.length; i++) {        if (values[i].equals("text/bogus")) {            hasBogus = true;        }        if (values[i].equals("text/bogus2")) {            hasBogus2 = true;        }    }    Assert.assertTrue(hasBogus && hasBogus2);}
bcf1d07217a83c8fe4f4ee28780bb564d4c8c0b59bce39694ab4d5fe330b89d0
testAdd
public void testAdd()
{    String[] values = null;    Metadata meta = new Metadata();    values = meta.getValues(CONTENTTYPE);    Assert.assertEquals(0, values.length);    meta.add(CONTENTTYPE, "value1");    values = meta.getValues(CONTENTTYPE);    Assert.assertEquals(1, values.length);    Assert.assertEquals("value1", values[0]);    meta.add(CONTENTTYPE, "value2");    values = meta.getValues(CONTENTTYPE);    Assert.assertEquals(2, values.length);    Assert.assertEquals("value1", values[0]);    Assert.assertEquals("value2", values[1]);            meta.add(CONTENTTYPE, "value1");    values = meta.getValues(CONTENTTYPE);    Assert.assertEquals(3, values.length);    Assert.assertEquals("value1", values[0]);    Assert.assertEquals("value2", values[1]);    Assert.assertEquals("value1", values[2]);}
ccc71e78604747a6c2ff387c36191673e2e448a9e206301aa6f8960c681f52d9
testSet
public void testSet()
{    String[] values = null;    Metadata meta = new Metadata();    values = meta.getValues(CONTENTTYPE);    Assert.assertEquals(0, values.length);    meta.set(CONTENTTYPE, "value1");    values = meta.getValues(CONTENTTYPE);    Assert.assertEquals(1, values.length);    Assert.assertEquals("value1", values[0]);    meta.set(CONTENTTYPE, "value2");    values = meta.getValues(CONTENTTYPE);    Assert.assertEquals(1, values.length);    Assert.assertEquals("value2", values[0]);    meta.set(CONTENTTYPE, "new value 1");    meta.add("contenttype", "new value 2");    values = meta.getValues(CONTENTTYPE);    Assert.assertEquals(2, values.length);    Assert.assertEquals("new value 1", values[0]);    Assert.assertEquals("new value 2", values[1]);}
9cec994a5317b599beebf7865ae44109f4497076b24b9aa4fd16a0528bfe1e89
testSetProperties
public void testSetProperties()
{    String[] values = null;    Metadata meta = new Metadata();    Properties props = new Properties();    meta.setAll(props);    Assert.assertEquals(0, meta.size());    props.setProperty("name-one", "value1.1");    meta.setAll(props);    Assert.assertEquals(1, meta.size());    values = meta.getValues("name-one");    Assert.assertEquals(1, values.length);    Assert.assertEquals("value1.1", values[0]);    props.setProperty("name-two", "value2.1");    meta.setAll(props);    Assert.assertEquals(2, meta.size());    values = meta.getValues("name-one");    Assert.assertEquals(1, values.length);    Assert.assertEquals("value1.1", values[0]);    values = meta.getValues("name-two");    Assert.assertEquals(1, values.length);    Assert.assertEquals("value2.1", values[0]);}
eaa5dd587a1051f25f65fe1808fe232d587180e61c71e00071a4b765af52ae7a
testGet
public void testGet()
{    Metadata meta = new Metadata();    Assert.assertNull(meta.get("a-name"));    meta.add("a-name", "value-1");    Assert.assertEquals("value-1", meta.get("a-name"));    meta.add("a-name", "value-2");    Assert.assertEquals("value-1", meta.get("a-name"));}
fe1f25598a3aed39c8f0f40bcb5bfadca13c4b15d31354f7065de6d82324bae1
testIsMultiValued
public void testIsMultiValued()
{    Metadata meta = new Metadata();    Assert.assertFalse(meta.isMultiValued("key"));    meta.add("key", "value1");    Assert.assertFalse(meta.isMultiValued("key"));    meta.add("key", "value2");    Assert.assertTrue(meta.isMultiValued("key"));}
14e6f5f6ed7a7edfaa3fa989d5ccc69b90bcedace0ec78ee064d632d0550c936
testNames
public void testNames()
{    String[] names = null;    Metadata meta = new Metadata();    names = meta.names();    Assert.assertEquals(0, names.length);    meta.add("name-one", "value");    names = meta.names();    Assert.assertEquals(1, names.length);    Assert.assertEquals("name-one", names[0]);    meta.add("name-two", "value");    names = meta.names();    Assert.assertEquals(2, names.length);}
1fb42763547253cf7ffda7bc5ce98fdf5b96f7ca09e3b84b3ad86b00938441dc
testRemove
public void testRemove()
{    Metadata meta = new Metadata();    meta.remove("name-one");    Assert.assertEquals(0, meta.size());    meta.add("name-one", "value-1.1");    meta.add("name-one", "value-1.2");    meta.add("name-two", "value-2.2");    Assert.assertEquals(2, meta.size());    Assert.assertNotNull(meta.get("name-one"));    Assert.assertNotNull(meta.get("name-two"));    meta.remove("name-one");    Assert.assertEquals(1, meta.size());    Assert.assertNull(meta.get("name-one"));    Assert.assertNotNull(meta.get("name-two"));    meta.remove("name-two");    Assert.assertEquals(0, meta.size());    Assert.assertNull(meta.get("name-one"));    Assert.assertNull(meta.get("name-two"));}
f09af8c37f852345843c0549e697dbdbb2de98494784d2f611dd275553796a2d
testObject
public void testObject()
{    Metadata meta1 = new Metadata();    Metadata meta2 = new Metadata();    Assert.assertFalse(meta1.equals(null));    Assert.assertFalse(meta1.equals("String"));    Assert.assertTrue(meta1.equals(meta2));    meta1.add("name-one", "value-1.1");    Assert.assertFalse(meta1.equals(meta2));    meta2.add("name-one", "value-1.1");    Assert.assertTrue(meta1.equals(meta2));    meta1.add("name-one", "value-1.2");    Assert.assertFalse(meta1.equals(meta2));    meta2.add("name-one", "value-1.2");    Assert.assertTrue(meta1.equals(meta2));    meta1.add("name-two", "value-2.1");    Assert.assertFalse(meta1.equals(meta2));    meta2.add("name-two", "value-2.1");    Assert.assertTrue(meta1.equals(meta2));    meta1.add("name-two", "value-2.2");    Assert.assertFalse(meta1.equals(meta2));    meta2.add("name-two", "value-2.x");    Assert.assertFalse(meta1.equals(meta2));}
1d074dc135a69437427ab1725521ed8787e5036cba9cbc1a24cd07b7f3fb1db4
testWritable
public void testWritable()
{    Metadata result = null;    Metadata meta = new Metadata();    result = writeRead(meta);    Assert.assertEquals(0, result.size());    meta.add("name-one", "value-1.1");    result = writeRead(meta);    Assert.assertEquals(1, result.size());    Assert.assertEquals(1, result.getValues("name-one").length);    Assert.assertEquals("value-1.1", result.get("name-one"));    meta.add("name-two", "value-2.1");    meta.add("name-two", "value-2.2");    result = writeRead(meta);    Assert.assertEquals(2, result.size());    Assert.assertEquals(1, result.getValues("name-one").length);    Assert.assertEquals("value-1.1", result.getValues("name-one")[0]);    Assert.assertEquals(2, result.getValues("name-two").length);    Assert.assertEquals("value-2.1", result.getValues("name-two")[0]);    Assert.assertEquals("value-2.2", result.getValues("name-two")[1]);}
b030ed837425bbe491231221387e0f6a3fc004680f6bb6d6ab1b6ef2635f68ee
writeRead
private Metadata writeRead(Metadata meta)
{    Metadata readed = new Metadata();    try {        ByteArrayOutputStream out = new ByteArrayOutputStream();        meta.write(new DataOutputStream(out));        readed.readFields(new DataInputStream(new ByteArrayInputStream(out.toByteArray())));    } catch (IOException ioe) {        Assert.fail(ioe.toString());    }    return readed;}
f5eb0951492d24db7d3088f21593422952b63bdae4ac33ff287ce94e8e4b6434
testGetNormalizedName
public void testGetNormalizedName()
{    Assert.assertEquals("Content-Type", SpellCheckedMetadata.getNormalizedName("Content-Type"));    Assert.assertEquals("Content-Type", SpellCheckedMetadata.getNormalizedName("ContentType"));    Assert.assertEquals("Content-Type", SpellCheckedMetadata.getNormalizedName("Content-type"));    Assert.assertEquals("Content-Type", SpellCheckedMetadata.getNormalizedName("contenttype"));    Assert.assertEquals("Content-Type", SpellCheckedMetadata.getNormalizedName("contentype"));    Assert.assertEquals("Content-Type", SpellCheckedMetadata.getNormalizedName("contntype"));}
bcf1d07217a83c8fe4f4ee28780bb564d4c8c0b59bce39694ab4d5fe330b89d0
testAdd
public void testAdd()
{    String[] values = null;    SpellCheckedMetadata meta = new SpellCheckedMetadata();    values = meta.getValues("contentype");    Assert.assertEquals(0, values.length);    meta.add("contentype", "value1");    values = meta.getValues("contentype");    Assert.assertEquals(1, values.length);    Assert.assertEquals("value1", values[0]);    meta.add("Content-Type", "value2");    values = meta.getValues("contentype");    Assert.assertEquals(2, values.length);    Assert.assertEquals("value1", values[0]);    Assert.assertEquals("value2", values[1]);            meta.add("ContentType", "value1");    values = meta.getValues("Content-Type");    Assert.assertEquals(3, values.length);    Assert.assertEquals("value1", values[0]);    Assert.assertEquals("value2", values[1]);    Assert.assertEquals("value1", values[2]);}
ccc71e78604747a6c2ff387c36191673e2e448a9e206301aa6f8960c681f52d9
testSet
public void testSet()
{    String[] values = null;    SpellCheckedMetadata meta = new SpellCheckedMetadata();    values = meta.getValues("contentype");    Assert.assertEquals(0, values.length);    meta.set("contentype", "value1");    values = meta.getValues("contentype");    Assert.assertEquals(1, values.length);    Assert.assertEquals("value1", values[0]);    meta.set("Content-Type", "value2");    values = meta.getValues("contentype");    Assert.assertEquals(1, values.length);    Assert.assertEquals("value2", values[0]);    meta.set("contenttype", "new value 1");    meta.add("contenttype", "new value 2");    values = meta.getValues("contentype");    Assert.assertEquals(2, values.length);    Assert.assertEquals("new value 1", values[0]);    Assert.assertEquals("new value 2", values[1]);}
9cec994a5317b599beebf7865ae44109f4497076b24b9aa4fd16a0528bfe1e89
testSetProperties
public void testSetProperties()
{    String[] values = null;    SpellCheckedMetadata meta = new SpellCheckedMetadata();    Properties props = new Properties();    meta.setAll(props);    Assert.assertEquals(0, meta.size());    props.setProperty("name-one", "value1.1");    meta.setAll(props);    Assert.assertEquals(1, meta.size());    values = meta.getValues("name-one");    Assert.assertEquals(1, values.length);    Assert.assertEquals("value1.1", values[0]);    props.setProperty("name-two", "value2.1");    meta.setAll(props);    Assert.assertEquals(2, meta.size());    values = meta.getValues("name-one");    Assert.assertEquals(1, values.length);    Assert.assertEquals("value1.1", values[0]);    values = meta.getValues("name-two");    Assert.assertEquals(1, values.length);    Assert.assertEquals("value2.1", values[0]);}
eaa5dd587a1051f25f65fe1808fe232d587180e61c71e00071a4b765af52ae7a
testGet
public void testGet()
{    SpellCheckedMetadata meta = new SpellCheckedMetadata();    Assert.assertNull(meta.get("a-name"));    meta.add("a-name", "value-1");    Assert.assertEquals("value-1", meta.get("a-name"));    meta.add("a-name", "value-2");    Assert.assertEquals("value-1", meta.get("a-name"));}
fe1f25598a3aed39c8f0f40bcb5bfadca13c4b15d31354f7065de6d82324bae1
testIsMultiValued
public void testIsMultiValued()
{    SpellCheckedMetadata meta = new SpellCheckedMetadata();    Assert.assertFalse(meta.isMultiValued("key"));    meta.add("key", "value1");    Assert.assertFalse(meta.isMultiValued("key"));    meta.add("key", "value2");    Assert.assertTrue(meta.isMultiValued("key"));}
14e6f5f6ed7a7edfaa3fa989d5ccc69b90bcedace0ec78ee064d632d0550c936
testNames
public void testNames()
{    String[] names = null;    SpellCheckedMetadata meta = new SpellCheckedMetadata();    names = meta.names();    Assert.assertEquals(0, names.length);    meta.add("name-one", "value");    names = meta.names();    Assert.assertEquals(1, names.length);    Assert.assertEquals("name-one", names[0]);    meta.add("name-two", "value");    names = meta.names();    Assert.assertEquals(2, names.length);}
1fb42763547253cf7ffda7bc5ce98fdf5b96f7ca09e3b84b3ad86b00938441dc
testRemove
public void testRemove()
{    SpellCheckedMetadata meta = new SpellCheckedMetadata();    meta.remove("name-one");    Assert.assertEquals(0, meta.size());    meta.add("name-one", "value-1.1");    meta.add("name-one", "value-1.2");    meta.add("name-two", "value-2.2");    Assert.assertEquals(2, meta.size());    Assert.assertNotNull(meta.get("name-one"));    Assert.assertNotNull(meta.get("name-two"));    meta.remove("name-one");    Assert.assertEquals(1, meta.size());    Assert.assertNull(meta.get("name-one"));    Assert.assertNotNull(meta.get("name-two"));    meta.remove("name-two");    Assert.assertEquals(0, meta.size());    Assert.assertNull(meta.get("name-one"));    Assert.assertNull(meta.get("name-two"));}
f09af8c37f852345843c0549e697dbdbb2de98494784d2f611dd275553796a2d
testObject
public void testObject()
{    SpellCheckedMetadata meta1 = new SpellCheckedMetadata();    SpellCheckedMetadata meta2 = new SpellCheckedMetadata();    Assert.assertFalse(meta1.equals(null));    Assert.assertFalse(meta1.equals("String"));    Assert.assertTrue(meta1.equals(meta2));    meta1.add("name-one", "value-1.1");    Assert.assertFalse(meta1.equals(meta2));    meta2.add("name-one", "value-1.1");    Assert.assertTrue(meta1.equals(meta2));    meta1.add("name-one", "value-1.2");    Assert.assertFalse(meta1.equals(meta2));    meta2.add("name-one", "value-1.2");    Assert.assertTrue(meta1.equals(meta2));    meta1.add("name-two", "value-2.1");    Assert.assertFalse(meta1.equals(meta2));    meta2.add("name-two", "value-2.1");    Assert.assertTrue(meta1.equals(meta2));    meta1.add("name-two", "value-2.2");    Assert.assertFalse(meta1.equals(meta2));    meta2.add("name-two", "value-2.x");    Assert.assertFalse(meta1.equals(meta2));}
1d074dc135a69437427ab1725521ed8787e5036cba9cbc1a24cd07b7f3fb1db4
testWritable
public void testWritable()
{    SpellCheckedMetadata result = null;    SpellCheckedMetadata meta = new SpellCheckedMetadata();    result = writeRead(meta);    Assert.assertEquals(0, result.size());    meta.add("name-one", "value-1.1");    result = writeRead(meta);    meta.add("Contenttype", "text/html");    Assert.assertEquals(1, result.size());    Assert.assertEquals(1, result.getValues("name-one").length);    Assert.assertEquals("value-1.1", result.get("name-one"));    meta.add("name-two", "value-2.1");    meta.add("name-two", "value-2.2");    result = writeRead(meta);    Assert.assertEquals(3, result.size());    Assert.assertEquals(1, result.getValues("name-one").length);    Assert.assertEquals("value-1.1", result.getValues("name-one")[0]);    Assert.assertEquals(2, result.getValues("name-two").length);    Assert.assertEquals("value-2.1", result.getValues("name-two")[0]);    Assert.assertEquals("value-2.2", result.getValues("name-two")[1]);    Assert.assertEquals("text/html", result.get(Metadata.CONTENT_TYPE));}
2f3bb1b6b7f17e55e5688b017d0e220ede4685b9e61b7b672bab3a579d08cb85
testHandlingSpeed
public final void testHandlingSpeed()
{    @SuppressWarnings("unused")    SpellCheckedMetadata result;    long start = System.currentTimeMillis();    for (int i = 0; i < NUM_ITERATIONS; i++) {        SpellCheckedMetadata scmd = constructSpellCheckedMetadata();        result = writeRead(scmd);    }    System.out.println(NUM_ITERATIONS + " spellchecked metadata I/O time:" + (System.currentTimeMillis() - start) + "ms.");}
a9f95e84cec501e339e7cafafc380554d4db4760553a30f0aac4886f020bb01e
writeRead
private SpellCheckedMetadata writeRead(SpellCheckedMetadata meta)
{    SpellCheckedMetadata readed = new SpellCheckedMetadata();    try {        ByteArrayOutputStream out = new ByteArrayOutputStream();        meta.write(new DataOutputStream(out));        readed.readFields(new DataInputStream(new ByteArrayInputStream(out.toByteArray())));    } catch (IOException ioe) {        Assert.fail(ioe.toString());    }    return readed;}
66996ac8aef7e39a8e5bfc39e6e5fa23646ef0bb1d9979199d57e947bbe6ea6f
constructSpellCheckedMetadata
public static final SpellCheckedMetadata constructSpellCheckedMetadata()
{    SpellCheckedMetadata scmd = new SpellCheckedMetadata();    scmd.add("Content-type", "foo/bar");    scmd.add("Connection", "close");    scmd.add("Last-Modified", "Sat, 09 Dec 2006 15:09:57 GMT");    scmd.add("Server", "Foobar");    scmd.add("Date", "Sat, 09 Dec 2006 18:07:20 GMT");    scmd.add("Accept-Ranges", "bytes");    scmd.add("ETag", "\"1234567-89-01234567\"");    scmd.add("Content-Length", "123");    scmd.add(Nutch.SEGMENT_NAME_KEY, "segmentzzz");    scmd.add(Nutch.SIGNATURE_KEY, "123");    return scmd;}
1066f44a4a7f52102cc8561f69ab79305a9c24cf776768f4af05f896fe6c995f
testNonExistingUrlFilter
public void testNonExistingUrlFilter() throws URLFilterException
{    Configuration conf = NutchConfiguration.create();    String class1 = "NonExistingFilter";    String class2 = "org.apache.nutch.urlfilter.prefix.PrefixURLFilter";    conf.set(URLFilters.URLFILTER_ORDER, class1 + " " + class2);    URLFilters normalizers = new URLFilters(conf);    normalizers.filter("http://someurl/");}
ca2b2b0a5c676dd19ff138b999473d90b7d3b5f2534a08f80ee5bb9621963c8f
testURLNormalizers
public void testURLNormalizers()
{    Configuration conf = NutchConfiguration.create();    String clazz1 = "org.apache.nutch.net.urlnormalizer.regex.RegexURLNormalizer";    String clazz2 = "org.apache.nutch.net.urlnormalizer.basic.BasicURLNormalizer";    conf.set("urlnormalizer.order", clazz1 + " " + clazz2);    URLNormalizers normalizers = new URLNormalizers(conf, URLNormalizers.SCOPE_DEFAULT);    Assert.assertNotNull(normalizers);    try {        normalizers.normalize("http://www.example.com/", URLNormalizers.SCOPE_DEFAULT);    } catch (MalformedURLException mue) {        Assert.fail(mue.toString());    }        try {        String normalizedSlashes = normalizers.normalize("http://www.example.com//path/to//somewhere.html", URLNormalizers.SCOPE_DEFAULT);        Assert.assertEquals(normalizedSlashes, "http://www.example.com/path/to/somewhere.html");    } catch (MalformedURLException mue) {        Assert.fail(mue.toString());    }        try {        String normalizedHost = normalizers.normalize("http://www.example.org//path/to//somewhere.html", URLNormalizers.SCOPE_DEFAULT);        Assert.assertEquals(normalizedHost, "http://www.example.org/path/to/somewhere.html");    } catch (MalformedURLException mue) {        Assert.fail(mue.toString());    }        int pos1 = -1, pos2 = -1;    URLNormalizer[] impls = normalizers.getURLNormalizers(URLNormalizers.SCOPE_DEFAULT);    for (int i = 0; i < impls.length; i++) {        if (impls[i].getClass().getName().equals(clazz1))            pos1 = i;        if (impls[i].getClass().getName().equals(clazz2))            pos2 = i;    }    if (pos1 != -1 && pos2 != -1) {        Assert.assertTrue("RegexURLNormalizer before BasicURLNormalizer", pos1 < pos2);    }}
80f3f6f4542690670348347880a3b132f29996ebaaab5a9358c6556bfc634c81
testGetNoOutlinks
public void testGetNoOutlinks()
{    Outlink[] outlinks = null;    outlinks = OutlinkExtractor.getOutlinks(null, conf);    Assert.assertNotNull(outlinks);    Assert.assertEquals(0, outlinks.length);    outlinks = OutlinkExtractor.getOutlinks("", conf);    Assert.assertNotNull(outlinks);    Assert.assertEquals(0, outlinks.length);}
ec07999356622a5af7822ce38ed5196ddaa39b765a788cdffa25ad56dac79ce3
testGetOutlinksHttp
public void testGetOutlinksHttp()
{    Outlink[] outlinks = OutlinkExtractor.getOutlinks("Test with http://www.nutch.org/index.html is it found? " + "What about www.google.com at http://www.google.de " + "A longer URL could be http://www.sybit.com/solutions/portals.html", conf);    Assert.assertTrue("Url not found!", outlinks.length == 3);    Assert.assertEquals("Wrong URL", "http://www.nutch.org/index.html", outlinks[0].getToUrl());    Assert.assertEquals("Wrong URL", "http://www.google.de", outlinks[1].getToUrl());    Assert.assertEquals("Wrong URL", "http://www.sybit.com/solutions/portals.html", outlinks[2].getToUrl());}
c0160379e1b7062247cc0ffe0edb9911794c46f8a4c96008b3acc73bb4c1fb74
testGetOutlinksHttp2
public void testGetOutlinksHttp2()
{    Outlink[] outlinks = OutlinkExtractor.getOutlinks("Test with http://www.nutch.org/index.html is it found? " + "What about www.google.com at http://www.google.de " + "A longer URL could be http://www.sybit.com/solutions/portals.html", "http://www.sybit.de", conf);    Assert.assertTrue("Url not found!", outlinks.length == 3);    Assert.assertEquals("Wrong URL", "http://www.nutch.org/index.html", outlinks[0].getToUrl());    Assert.assertEquals("Wrong URL", "http://www.google.de", outlinks[1].getToUrl());    Assert.assertEquals("Wrong URL", "http://www.sybit.com/solutions/portals.html", outlinks[2].getToUrl());}
d90885df4e0caa76464c6dcbf702472f2e15010d3b19cceafab08212c7c7c95d
testGetOutlinksFtp
public void testGetOutlinksFtp()
{    Outlink[] outlinks = OutlinkExtractor.getOutlinks("Test with ftp://www.nutch.org is it found? " + "What about www.google.com at ftp://www.google.de", conf);    Assert.assertTrue("Url not found!", outlinks.length > 1);    Assert.assertEquals("Wrong URL", "ftp://www.nutch.org", outlinks[0].getToUrl());    Assert.assertEquals("Wrong URL", "ftp://www.google.de", outlinks[1].getToUrl());}
73b3bad1e584c957c3f8f22745c0c4833681338c1e0cdb5bee7ac0e5f8265293
testAddSameObject
public void testAddSameObject() throws Exception
{    Set<Outlink> set = new HashSet<>();    Outlink o = new Outlink("http://www.example.com", "Example");    set.add(o);    set.add(o);    assertEquals("Adding the same Outlink twice", 1, set.size());}
17281c7033ec84e400837326b72e0045048863694b0f444949176fb199d720dc
testAddOtherObjectWithSameData
public void testAddOtherObjectWithSameData() throws Exception
{    Set<Outlink> set = new HashSet<>();    Outlink o = new Outlink("http://www.example.com", "Example");    Outlink o1 = new Outlink("http://www.example.com", "Example");    assertTrue("The two Outlink objects are the same", o.equals(o1));    set.add(o);    set.add(o1);    assertEquals("The set should contain only 1 Outlink", 1, set.size());}
eb1e2848739e2102756654418007c0dd677ed3568113e58ee8b7bb0e9c7d72e4
testParseData
public void testParseData() throws Exception
{    String title = "The Foo Page";    Outlink[] outlinks = new Outlink[] { new Outlink("http://foo.com/", "Foo"), new Outlink("http://bar.com/", "Bar") };    Metadata metaData = new Metadata();    metaData.add("Language", "en/us");    metaData.add("Charset", "UTF-8");    ParseData r = new ParseData(ParseStatus.STATUS_SUCCESS, title, outlinks, metaData);    WritableTestUtils.testWritable(r, null);}
194eb5f39e44d8c33ccdd574dab630d8ee40293762e8e1bc36f4489ade061d23
testMaxOutlinks
public void testMaxOutlinks() throws Exception
{    Outlink[] outlinks = new Outlink[128];    for (int i = 0; i < outlinks.length; i++) {        outlinks[i] = new Outlink("http://outlink.com/" + i, "Outlink" + i);    }    ParseData original = new ParseData(ParseStatus.STATUS_SUCCESS, "Max Outlinks Title", outlinks, new Metadata());    ParseData data = (ParseData) WritableTestUtils.writeRead(original, null);    Assert.assertEquals(outlinks.length, data.getOutlinks().length);}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    conf = NutchConfiguration.create();    conf.set("plugin.includes", ".*");    conf.set("parse.plugin.file", "org/apache/nutch/parse/parse-plugin-test.xml");    parserFactory = new ParserFactory(conf);}
9c31e1d83e542e4818f97d7dd3d7459fd7d04b0f5a8f59178a8a36361b6f24fb
testGetExtensions
public void testGetExtensions() throws Exception
{    Extension ext = parserFactory.getExtensions("text/html").get(0);    Assert.assertEquals("parse-tika", ext.getDescriptor().getPluginId());    ext = parserFactory.getExtensions("text/html; charset=ISO-8859-1").get(0);    Assert.assertEquals("parse-tika", ext.getDescriptor().getPluginId());    ext = parserFactory.getExtensions("foo/bar").get(0);    Assert.assertEquals("parse-tika", ext.getDescriptor().getPluginId());}
be70bd02b1f48d710925c4a7bbedba7dfa71097ab0238a8413758964b73dec62
testGetParsers
public void testGetParsers() throws Exception
{    Parser[] parsers = parserFactory.getParsers("text/html", "http://foo.com");    Assert.assertNotNull(parsers);    Assert.assertEquals(1, parsers.length);    Assert.assertEquals("org.apache.nutch.parse.tika.TikaParser", parsers[0].getClass().getName());    parsers = parserFactory.getParsers("text/html; charset=ISO-8859-1", "http://foo.com");    Assert.assertNotNull(parsers);    Assert.assertEquals(1, parsers.length);    Assert.assertEquals("org.apache.nutch.parse.tika.TikaParser", parsers[0].getClass().getName());    parsers = parserFactory.getParsers("application/x-javascript", "http://foo.com");    Assert.assertNotNull(parsers);    Assert.assertEquals(1, parsers.length);    Assert.assertEquals("org.apache.nutch.parse.js.JSParseFilter", parsers[0].getClass().getName());    parsers = parserFactory.getParsers("text/plain", "http://foo.com");    Assert.assertNotNull(parsers);    Assert.assertEquals(1, parsers.length);    Assert.assertEquals("org.apache.nutch.parse.tika.TikaParser", parsers[0].getClass().getName());    Parser parser1 = parserFactory.getParsers("text/plain", "http://foo.com")[0];    Parser parser2 = parserFactory.getParsers("*", "http://foo.com")[0];    Assert.assertEquals("Different instances!", parser1.hashCode(), parser2.hashCode());                parsers = parserFactory.getParsers("text/rss", "http://foo.com");    Assert.assertNotNull(parsers);    Assert.assertEquals(1, parsers.length);    Assert.assertEquals("org.apache.nutch.parse.tika.TikaParser", parsers[0].getClass().getName());}
c957085c92f1a161eb6a853cbb4092aa9ca7cc481a77d986698af178e7a14939
testParseText
public void testParseText() throws Exception
{    String page = "Hello World The Quick Brown Fox Jumped Over the Lazy Fox";    ParseText s = new ParseText(page);    WritableTestUtils.testWritable(s);}
af9b4a3524cfb0c89adadc402f14398ee14717599c3d6266a271bd76fe2a8537
testGetExtension
public String testGetExtension(String hello)
{    return hello + " World";}
d449fb5b3a7bef4aa1423b66ccbb1a205468f666362fa693e493df2f7eac899d
startUp
public void startUp() throws PluginRuntimeException
{    System.err.println("start up Plugin: " + getDescriptor().getPluginId());}
d3246b79916b4cc62dc403ec16c3a5d9bf041c4911faad78791d4214c838d9e5
shutDown
public void shutDown() throws PluginRuntimeException
{    System.err.println("shutdown Plugin: " + getDescriptor().getPluginId());}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    this.conf = NutchConfiguration.create();    conf.set("plugin.includes", ".*");            fPluginCount = 5;    createDummyPlugins(fPluginCount);    this.repository = PluginRepository.get(conf);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    for (int i = 0; i < fFolders.size(); i++) {        File folder = fFolders.get(i);        delete(folder);        folder.delete();    }}
8aca2655cdd3ea83fb373dc9ec9105e80531332ecfb65c1b3b399e7f32e8d1e9
testPluginConfiguration
public void testPluginConfiguration()
{    String string = getPluginFolder();    File file = new File(string);    if (!file.exists()) {        file.mkdir();    }    Assert.assertTrue(file.exists());}
b393082b1a90cd119d76ab7b42c355b28ffb918040bddf61c2c53c36a1a32bc8
testLoadPlugins
public void testLoadPlugins()
{    PluginDescriptor[] descriptors = repository.getPluginDescriptors();    int k = descriptors.length;    Assert.assertTrue(fPluginCount <= k);    for (int i = 0; i < descriptors.length; i++) {        PluginDescriptor descriptor = descriptors[i];        if (!descriptor.getPluginId().startsWith("getPluginFolder()")) {            continue;        }        Assert.assertEquals(1, descriptor.getExportedLibUrls().length);        Assert.assertEquals(1, descriptor.getNotExportedLibUrls().length);    }}
be5bc77efe44e5fc69160ab9f68e7f85f73d851a7f38c878c306fd53f44ff444
testRepositoryCache
public void testRepositoryCache() throws IOException
{    Configuration config = NutchConfiguration.create();    PluginRepository repo = PluginRepository.get(config);    Job job = NutchJob.getInstance(config);    config = job.getConfiguration();    PluginRepository repo1 = PluginRepository.get(config);    Assert.assertTrue(repo == repo1);        config = new Configuration();    config.addResource("nutch-default.xml");    config.addResource("nutch-site.xml");    repo = PluginRepository.get(config);    job = NutchJob.getInstance(config);    config = job.getConfiguration();    repo1 = PluginRepository.get(config);    Assert.assertTrue(repo1 != repo);}
c95ca94e3a00e0df46a75036b18833e410882465b02c950a07d6783967a45618
testGetExtensionAndAttributes
public void testGetExtensionAndAttributes()
{    String xpId = " sdsdsd";    ExtensionPoint extensionPoint = repository.getExtensionPoint(xpId);    Assert.assertEquals(extensionPoint, null);    Extension[] extension1 = repository.getExtensionPoint(getGetExtensionId()).getExtensions();    Assert.assertEquals(extension1.length, fPluginCount);    for (int i = 0; i < extension1.length; i++) {        Extension extension2 = extension1[i];        String string = extension2.getAttribute(getGetConfigElementName());        Assert.assertEquals(string, getParameterValue());    }}
fc933ce03d6c0c5904d15b36edd80f75cc688269653bd9e31f53efacfb274ab3
testGetExtensionInstances
public void testGetExtensionInstances() throws PluginRuntimeException
{    Extension[] extensions = repository.getExtensionPoint(getGetExtensionId()).getExtensions();    Assert.assertEquals(extensions.length, fPluginCount);    for (int i = 0; i < extensions.length; i++) {        Extension extension = extensions[i];        Object object = extension.getExtensionInstance();        if (!(object instanceof HelloWorldExtension))            Assert.fail(" object is not a instance of HelloWorldExtension");        ((ITestExtension) object).testGetExtension("Bla ");        String string = ((ITestExtension) object).testGetExtension("Hello");        Assert.assertEquals("Hello World", string);    }}
21874b62150149a85a33bd80b185eeee2fd2f09f5217b295e08e2687fecb6231
testGetClassLoader
public void testGetClassLoader()
{    PluginDescriptor[] descriptors = repository.getPluginDescriptors();    for (int i = 0; i < descriptors.length; i++) {        PluginDescriptor descriptor = descriptors[i];        Assert.assertNotNull(descriptor.getClassLoader());    }}
71984563584e5740a0e24b24a7010ea81ea7a54d57e01c0b4e58c5ab0a806786
testGetResources
public void testGetResources() throws IOException
{    PluginDescriptor[] descriptors = repository.getPluginDescriptors();    for (int i = 0; i < descriptors.length; i++) {        PluginDescriptor descriptor = descriptors[i];        if (!descriptor.getPluginId().startsWith("getPluginFolder()")) {            continue;        }        String value = descriptor.getResourceString("key", Locale.UK);        Assert.assertEquals("value", value);        value = descriptor.getResourceString("key", Locale.TRADITIONAL_CHINESE);        Assert.assertEquals("value", value);    }}
1662c53df7fc3196213aa5b9f2c73d46c35b5a597047442271029c6ec489fa64
getPluginFolder
private String getPluginFolder()
{    String[] strings = conf.getStrings("plugin.folders");    if (strings == null || strings.length == 0)        Assert.fail("no plugin directory setuped..");    String name = strings[0];    return new PluginManifestParser(conf, this.repository).getPluginFolder(name).toString();}
ea989abdde494f7ad5e25fd7237516ccc39e1db8bdc8226e1ee88e6a4192ce51
createDummyPlugins
private void createDummyPlugins(int pCount)
{    String string = getPluginFolder();    try {        File folder = new File(string);        folder.mkdir();        for (int i = 0; i < pCount; i++) {            String pluginFolder = string + File.separator + "DummyPlugin" + i;            File file = new File(pluginFolder);            file.mkdir();            fFolders.add(file);            createPluginManifest(i, file.getAbsolutePath());            createResourceFile(file.getAbsolutePath());        }    } catch (IOException e) {        e.printStackTrace();    }}
b80a38fa4fe64daf70550b3d6bf2cd0e5f74dd648d70b39eb334fbd8622b1fff
createResourceFile
private void createResourceFile(String pFolderPath) throws FileNotFoundException, IOException
{    Properties properties = new Properties();    properties.setProperty("key", "value");    properties.store(new FileOutputStream(pFolderPath + File.separator + "messages" + ".properties"), "");}
0028fe16b62a7c876e45a01293c79fec7fb452309f84aa1a613ef0e405ea9151
delete
private void delete(File path) throws IOException
{    File[] files = path.listFiles();    for (int i = 0; i < files.length; ++i) {        if (files[i].isDirectory())            delete(files[i]);        files[i].delete();    }}
8111ae5bb173b4cb21638bacf7504a01b841e198c6b711409d8c40f73fd04f07
createPluginManifest
private void createPluginManifest(int i, String pFolderPath) throws IOException
{    FileWriter out = new FileWriter(pFolderPath + File.separator + "plugin.xml");    String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + "<!--this is just a simple plugin for testing issues.-->" + "<plugin id=\"org.apache.nutch.plugin." + i + "\" name=\"" + i + "\" version=\"1.0\" provider-name=\"joa23\" " + "class=\"org.apache.nutch.plugin.SimpleTestPlugin\">" + "<extension-point id=\"aExtensioID\" " + "name=\"simple Parser Extension\" " + "schema=\"schema/testExtensionPoint.exsd\"/>" + "<runtime><library name=\"libs/exported.jar\"><extport/></library>" + "<library name=\"libs/not_exported.jar\"/></runtime>" + "<extension point=\"aExtensioID\">" + "<implementation name=\"simple Parser Extension\" " + "id=\"aExtensionId.\" class=\"org.apache.nutch.plugin.HelloWorldExtension\">" + "<parameter name=\"dummy-name\" value=\"a simple param value\"/>" + "</implementation></extension></plugin>";    out.write(xml);    out.flush();    out.close();}
f6f4beecc013888b625def2b9ade1093b7235183353be2e5ba246a6256b7eaa6
getParameterValue
private String getParameterValue()
{    return "a simple param value";}
215535fae9a6799e8228a521d07d33b119d31cd30392255aee74f258f5a85872
getGetExtensionId
private static String getGetExtensionId()
{    return "aExtensioID";}
d4e6ef0fc96bdfd8f11a6521b56197b1f66b661cfd50a700bae79c596f98f0c2
getGetConfigElementName
private static String getGetConfigElementName()
{    return "dummy-name";}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    new TestPluginSystem().createPluginManifest(1, "/");}
c1612453e9c22b4e44421e18ecbf5a37bb837cad68b09a0a59bed1b463e8b725
testContent
public void testContent() throws Exception
{    String page = "<HTML><BODY><H1>Hello World</H1><P>The Quick Brown Fox Jumped Over the Lazy Fox.</BODY></HTML>";    String url = "http://www.foo.com/";    SpellCheckedMetadata metaData = new SpellCheckedMetadata();    metaData.add("Host", "www.foo.com");    metaData.add("Content-Type", "text/html");    Content r = new Content(url, url, page.getBytes("UTF8"), "text/html", metaData, conf);    WritableTestUtils.testWritable(r);    Assert.assertEquals("text/html", r.getMetadata().get("Content-Type"));    Assert.assertEquals("text/html", r.getMetadata().get("content-type"));    Assert.assertEquals("text/html", r.getMetadata().get("CONTENTYPE"));}
2410accc0c447c2be93cb841d89fb1e7b738b2dac89c733a8ac2dd12d7ddc08e
testGetContentType
public void testGetContentType() throws Exception
{    Content c = null;    Metadata p = new Metadata();    c = new Content("http://www.foo.com/", "http://www.foo.com/", "".getBytes("UTF8"), "text/html; charset=UTF-8", p, conf);    Assert.assertEquals("text/html", c.getContentType());    c = new Content("http://www.foo.com/foo.html", "http://www.foo.com/", "".getBytes("UTF8"), "", p, conf);    Assert.assertEquals("text/html", c.getContentType());    c = new Content("http://www.foo.com/foo.html", "http://www.foo.com/", "".getBytes("UTF8"), null, p, conf);    Assert.assertEquals("text/html", c.getContentType());    c = new Content("http://www.foo.com/", "http://www.foo.com/", "<html></html>".getBytes("UTF8"), "", p, conf);    Assert.assertEquals("text/html", c.getContentType());    c = new Content("http://www.foo.com/foo.html", "http://www.foo.com/", "<html></html>".getBytes("UTF8"), "text/plain", p, conf);    Assert.assertEquals("text/html", c.getContentType());    c = new Content("http://www.foo.com/foo.png", "http://www.foo.com/", "<html></html>".getBytes("UTF8"), "text/plain", p, conf);    Assert.assertEquals("text/html", c.getContentType());    c = new Content("http://www.foo.com/", "http://www.foo.com/", "".getBytes("UTF8"), "", p, conf);    Assert.assertEquals(MimeTypes.OCTET_STREAM, c.getContentType());    c = new Content("http://www.foo.com/", "http://www.foo.com/", "".getBytes("UTF8"), null, p, conf);    Assert.assertNotNull(c.getContentType());}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    conf = NutchConfiguration.create();    conf.set("plugin.includes", ".*");    conf.set("http.agent.name", "test-bot");    factory = new ProtocolFactory(conf);}
5d725047af9e4f3f87ff7c9fbafafdbb8d58a3b5cb3a140caf3c24f79c8f1e8b
testGetProtocol
public void testGetProtocol()
{        try {        factory.getProtocol("xyzxyz://somehost");        Assert.fail("Must throw ProtocolNotFound");    } catch (ProtocolNotFound e) {        } catch (Exception ex) {        Assert.fail("Must not throw any other exception");    }    Protocol httpProtocol = null;        try {        httpProtocol = factory.getProtocol("http://somehost");        Assert.assertNotNull(httpProtocol);    } catch (Exception ex) {        Assert.fail("Must not throw any other exception");    }        try {        Assert.assertTrue(httpProtocol == factory.getProtocol("http://somehost"));    } catch (ProtocolNotFound e) {        Assert.fail("Must not throw any exception");    }}
20dca437609259dae56179515bfdf74b7660d55fbe1edebe9678de269e6eb2fa
testContains
public void testContains()
{    Assert.assertTrue(factory.contains("http", "http"));    Assert.assertTrue(factory.contains("http", "http,ftp"));    Assert.assertTrue(factory.contains("http", "   http ,   ftp"));    Assert.assertTrue(factory.contains("smb", "ftp,smb,http"));    Assert.assertFalse(factory.contains("smb", "smbb"));}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    conf = NutchConfiguration.create();    fs = FileSystem.get(conf);    testDir = new Path(conf.get("hadoop.tmp.dir"), "merge-" + System.currentTimeMillis());    seg1 = new Path(testDir, "seg1");    seg2 = new Path(testDir, "seg2");    out = new Path(testDir, "out");        System.err.println("Creating large segment 1...");    DecimalFormat df = new DecimalFormat("0000000");    Text k = new Text();    Path ptPath = new Path(new Path(seg1, ParseText.DIR_NAME), "part-00000");    Option kOpt = MapFile.Writer.keyClass(Text.class);    org.apache.hadoop.io.SequenceFile.Writer.Option vOpt = SequenceFile.Writer.valueClass(ParseText.class);    MapFile.Writer w = new MapFile.Writer(conf, ptPath, kOpt, vOpt);    long curSize = 0;    countSeg1 = 0;    FileStatus fileStatus = fs.getFileStatus(ptPath);    long blkSize = fileStatus.getBlockSize();    while (curSize < blkSize * 2) {        k.set("seg1-" + df.format(countSeg1));        w.append(k, new ParseText("seg1 text " + countSeg1));        countSeg1++;                curSize += 40;    }    w.close();    System.err.println(" - done: " + countSeg1 + " records.");    System.err.println("Creating large segment 2...");    ptPath = new Path(new Path(seg2, ParseText.DIR_NAME), "part-00000");    Option wKeyOpt = MapFile.Writer.keyClass(Text.class);    org.apache.hadoop.io.SequenceFile.Writer.Option wValueOpt = SequenceFile.Writer.valueClass(ParseText.class);    w = new MapFile.Writer(conf, ptPath, wKeyOpt, wValueOpt);    curSize = 0;    countSeg2 = 0;    while (curSize < blkSize * 2) {        k.set("seg2-" + df.format(countSeg2));        w.append(k, new ParseText("seg2 text " + countSeg2));        countSeg2++;                curSize += 40;    }    w.close();    System.err.println(" - done: " + countSeg2 + " records.");}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    fs.delete(testDir, true);}
847982496d71af6945deef95b19bb27d0dff71e46eb14f767756916146691ed8
testLargeMerge
public void testLargeMerge() throws Exception
{    SegmentMerger merger = new SegmentMerger(conf);    merger.merge(out, new Path[] { seg1, seg2 }, false, false, -1);        FileStatus[] stats = fs.listStatus(out);        Assert.assertEquals(1, stats.length);    Path outSeg = stats[0].getPath();    Text k = new Text();    ParseText v = new ParseText();    MapFile.Reader[] readers = MapFileOutputFormat.getReaders(new Path(outSeg, ParseText.DIR_NAME), conf);    int cnt1 = 0, cnt2 = 0;    for (MapFile.Reader r : readers) {        while (r.next(k, v)) {            String ks = k.toString();            String vs = v.getText();            if (ks.startsWith("seg1-")) {                cnt1++;                Assert.assertTrue(vs.startsWith("seg1 "));            } else if (ks.startsWith("seg2-")) {                cnt2++;                Assert.assertTrue(vs.startsWith("seg2 "));            }        }        r.close();    }    Assert.assertEquals(countSeg1, cnt1);    Assert.assertEquals(countSeg2, cnt2);}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    conf = NutchConfiguration.create();    fs = FileSystem.get(conf);    rnd = new Random();}
3693b9a5dd5eacc5d30c1ebffc20d1d5d467c96cc85d1656dc8a63135118bdbb
testSingleRandomSequence
public void testSingleRandomSequence() throws Exception
{    Assert.assertEquals(Byte.valueOf(CrawlDatum.STATUS_FETCH_SUCCESS), Byte.valueOf(executeSequence(CrawlDatum.STATUS_FETCH_GONE, CrawlDatum.STATUS_FETCH_SUCCESS, 256, false)));}
6f777e4d1a1e368c1905197bfe8c80cb8135a56d8c988054e2ca04c0df67f112
testMostlyRedirects
public void testMostlyRedirects() throws Exception
{        Path testDir = new Path(conf.get("hadoop.tmp.dir"), "merge-" + System.currentTimeMillis());    Path segment1 = new Path(testDir, "20140110114943");    Path segment2 = new Path(testDir, "20140110114832");    Path segment3 = new Path(testDir, "20140110114558");    Path segment4 = new Path(testDir, "20140110114930");    Path segment5 = new Path(testDir, "20140110114545");    Path segment6 = new Path(testDir, "20140110114507");    Path segment7 = new Path(testDir, "20140110114903");    Path segment8 = new Path(testDir, "20140110114724");    createSegment(segment1, CrawlDatum.STATUS_FETCH_SUCCESS, true);    createSegment(segment2, CrawlDatum.STATUS_FETCH_SUCCESS, true);    createSegment(segment3, CrawlDatum.STATUS_FETCH_SUCCESS, true);    createSegment(segment4, CrawlDatum.STATUS_FETCH_SUCCESS, true);    createSegment(segment5, CrawlDatum.STATUS_FETCH_SUCCESS, true);    createSegment(segment6, CrawlDatum.STATUS_FETCH_SUCCESS, false);    createSegment(segment7, CrawlDatum.STATUS_FETCH_SUCCESS, true);    createSegment(segment8, CrawlDatum.STATUS_FETCH_SUCCESS, true);        Path mergedSegment = merge(testDir, new Path[] { segment1, segment2, segment3, segment4, segment5, segment6, segment7, segment8 });    Byte status = Byte.valueOf(status = checkMergedSegment(testDir, mergedSegment));    Assert.assertEquals(Byte.valueOf(CrawlDatum.STATUS_FETCH_SUCCESS), status);}
110edfda6408fad5f5821eca5478f25ce956e69fb83ccd370896839455fbbc9c
testRandomizedSequences
public void testRandomizedSequences() throws Exception
{    for (int i = 0; i < rnd.nextInt(16) + 16; i++) {        byte expectedStatus = (byte) (rnd.nextInt(6) + 0x21);        while (expectedStatus == CrawlDatum.STATUS_FETCH_RETRY || expectedStatus == CrawlDatum.STATUS_FETCH_NOTMODIFIED) {                        expectedStatus = (byte) (rnd.nextInt(6) + 0x21);        }        byte randomStatus = (byte) (rnd.nextInt(6) + 0x21);        int rounds = rnd.nextInt(16) + 32;        boolean withRedirects = rnd.nextBoolean();        byte resultStatus = executeSequence(randomStatus, expectedStatus, rounds, withRedirects);        Assert.assertEquals("Expected status = " + CrawlDatum.getStatusName(expectedStatus) + ", but got " + CrawlDatum.getStatusName(resultStatus) + " when merging " + rounds + " segments" + (withRedirects ? " with redirects" : ""), expectedStatus, resultStatus);    }}
7da060724da50a12bf8e1b5f754ca53c4938606d0f695550018e2559d2927d45
testRandomTestSequenceWithRedirects
public void testRandomTestSequenceWithRedirects() throws Exception
{    Assert.assertEquals(Byte.valueOf(CrawlDatum.STATUS_FETCH_SUCCESS), Byte.valueOf(executeSequence(CrawlDatum.STATUS_FETCH_GONE, CrawlDatum.STATUS_FETCH_SUCCESS, 128, true)));}
5211eb5f8661541b490b9cb54e6f0ea012dc7731f19040f861bb607f48b7a57e
testFixedSequence
public void testFixedSequence() throws Exception
{        Path testDir = new Path(conf.get("hadoop.tmp.dir"), "merge-" + System.currentTimeMillis());    Path segment1 = new Path(testDir, "00001");    Path segment2 = new Path(testDir, "00002");    Path segment3 = new Path(testDir, "00003");    createSegment(segment1, CrawlDatum.STATUS_FETCH_GONE, false);    createSegment(segment2, CrawlDatum.STATUS_FETCH_GONE, true);    createSegment(segment3, CrawlDatum.STATUS_FETCH_SUCCESS, false);        Path mergedSegment = merge(testDir, new Path[] { segment1, segment2, segment3 });    Byte status = Byte.valueOf(status = checkMergedSegment(testDir, mergedSegment));    Assert.assertEquals(Byte.valueOf(CrawlDatum.STATUS_FETCH_SUCCESS), status);}
1ef2dc6bebcf7f85ce293b4407861d93b08ddfd03a8b3b3e175da050d0086952
testRedirFetchInOneSegment
public void testRedirFetchInOneSegment() throws Exception
{        Path testDir = new Path(conf.get("hadoop.tmp.dir"), "merge-" + System.currentTimeMillis());    Path segment = new Path(testDir, "00001");    createSegment(segment, CrawlDatum.STATUS_FETCH_SUCCESS, true, true);        Path mergedSegment = merge(testDir, new Path[] { segment });    Byte status = Byte.valueOf(status = checkMergedSegment(testDir, mergedSegment));    Assert.assertEquals(Byte.valueOf(CrawlDatum.STATUS_FETCH_SUCCESS), status);}
94473f132dc519b76b907997d6ebfb91a7a71ffef36976cdd50539a7cae72171
testEndsWithRedirect
public void testEndsWithRedirect() throws Exception
{        Path testDir = new Path(conf.get("hadoop.tmp.dir"), "merge-" + System.currentTimeMillis());    Path segment1 = new Path(testDir, "00001");    Path segment2 = new Path(testDir, "00002");    createSegment(segment1, CrawlDatum.STATUS_FETCH_SUCCESS, false);    createSegment(segment2, CrawlDatum.STATUS_FETCH_SUCCESS, true);        Path mergedSegment = merge(testDir, new Path[] { segment1, segment2 });    Byte status = Byte.valueOf(status = checkMergedSegment(testDir, mergedSegment));    Assert.assertEquals(Byte.valueOf(CrawlDatum.STATUS_FETCH_SUCCESS), status);}
c26131cd294e338b079c0e0fd5b942be3ef5440c84a4cb70ea12de0aad53ad73
executeSequence
protected byte executeSequence(byte firstStatus, byte lastStatus, int rounds, boolean redirect) throws Exception
{        Path testDir = new Path(conf.get("hadoop.tmp.dir"), "merge-" + System.currentTimeMillis());        DecimalFormat df = new DecimalFormat("0000000");        Path[] segmentPaths = new Path[rounds];    for (int i = 0; i < rounds; i++) {        String segmentName = df.format(i);        segmentPaths[i] = new Path(testDir, segmentName);    }        createSegment(segmentPaths[0], firstStatus, false);        for (int i = 1; i < rounds - 1; i++) {                byte status = (byte) (rnd.nextInt(6) + 0x21);                boolean addRedirect = redirect ? rnd.nextBoolean() : false;                        boolean addFetch = addRedirect ? rnd.nextBoolean() : true;        createSegment(segmentPaths[i], status, addFetch, addRedirect);    }            createSegment(segmentPaths[rounds - 1], lastStatus, true, redirect ? rnd.nextBoolean() : false);        Path mergedSegment = merge(testDir, segmentPaths);        return checkMergedSegment(testDir, mergedSegment);}
fc93115fbd50294f8d7deed9492af8754a3ceaf88f86e8f1299885d5cc5e42ad
checkMergedSegment
protected byte checkMergedSegment(Path testDir, Path mergedSegment) throws Exception
{        MapFile.Reader[] readers = MapFileOutputFormat.getReaders(new Path(mergedSegment, CrawlDatum.FETCH_DIR_NAME), conf);    Text key = new Text();    CrawlDatum value = new CrawlDatum();    byte finalStatus = 0x0;    for (MapFile.Reader reader : readers) {        while (reader.next(key, value)) {            LOG.info("Reading status for: " + key.toString() + " > " + CrawlDatum.getStatusName(value.getStatus()));                        if (CrawlDatum.hasFetchStatus(value) && key.toString().equals("http://nutch.apache.org/")) {                finalStatus = value.getStatus();            }        }                reader.close();    }        fs.delete(testDir, true);    LOG.info("Final fetch status for: http://nutch.apache.org/ > " + CrawlDatum.getStatusName(finalStatus));        return finalStatus;}
c3a6ad25ccb2cb7920162f9ffe02baf26835af6d30e41bfbe2e9989bf4db0d8d
merge
protected Path merge(Path testDir, Path[] segments) throws Exception
{        Path out = new Path(testDir, "out");        SegmentMerger merger = new SegmentMerger(conf);    merger.merge(out, segments, false, false, -1);    FileStatus[] stats = fs.listStatus(out);    Assert.assertEquals(1, stats.length);    return stats[0].getPath();}
90ae1c7304f52051bb23056d10d0bb1e6c245cdaa865876dcf8be4b36b559f32
createSegment
protected void createSegment(Path segment, byte status, boolean redirect) throws Exception
{    if (redirect) {        createSegment(segment, status, false, true);    } else {        createSegment(segment, status, true, false);    }}
a62939eea9da54338843f383313bd54afece42fa2e2263b4533dbc668ec41a3a
createSegment
protected void createSegment(Path segment, byte status, boolean fetch, boolean redirect) throws Exception
{    LOG.info("\nSegment: " + segment.toString());        String url = "http://nutch.apache.org/";        String redirectUrl = "http://nutch.apache.org/i_redirect_to_the_root/";        CrawlDatum value = new CrawlDatum();        Path crawlFetchPath = new Path(new Path(segment, CrawlDatum.FETCH_DIR_NAME), "part-00000");        Option wKeyOpt = MapFile.Writer.keyClass(Text.class);    org.apache.hadoop.io.SequenceFile.Writer.Option wValueOpt = SequenceFile.Writer.valueClass(CrawlDatum.class);    MapFile.Writer writer = new MapFile.Writer(conf, crawlFetchPath, wKeyOpt, wValueOpt);        if (redirect) {                LOG.info(url + " > " + CrawlDatum.getStatusName(CrawlDatum.STATUS_LINKED));        value = new CrawlDatum();        value.setStatus(CrawlDatum.STATUS_LINKED);        writer.append(new Text(url), value);    }        if (fetch) {        LOG.info(url + " > " + CrawlDatum.getStatusName(status));                value.setStatus(status);                writer.append(new Text(url), value);    }        if (redirect) {                LOG.info(redirectUrl + " > " + CrawlDatum.getStatusName(CrawlDatum.STATUS_FETCH_REDIR_TEMP));        value.setStatus(CrawlDatum.STATUS_FETCH_REDIR_TEMP);        writer.append(new Text(redirectUrl), value);    }        writer.close();}
65339e5c865f4b35c4dd4deabb92894660e90990d8e1db209eb4e57db9cc3aa9
testNutchServerStartup
public void testNutchServerStartup()
{    boolean isRunning = false;    for (int i = 0; i < port.length; i++) {        try {            startServer(port[i]);            isRunning = true;            break;        } catch (Exception e) {            LOG.info("Could not start server on port: {}. Tries remaining {}", port[i], port.length - i);        }    }    if (!isRunning) {        LOG.info("Could not start server, all ports in use");    } else {        LOG.info("Testing admin endpoint");        WebClient client = WebClient.create(ENDPOINT_ADDRESS + server.getPort());        @SuppressWarnings("unused")        Response response = client.path("admin").get();                response = client.path("stop").get();        }}
829c8c2b1e9c47fe4953971a124eb7c9f6b6816f46f88c74dc948cb046ec2718
startServer
private void startServer(int port) throws Exception
{    NutchServer.setPort(port);    NutchServer.startServer();}
bf52601de8ce53cf51a58fb6b933c852531776ee1654ad5a3f4200b13d315ed3
handle
public void handle(String target, HttpServletRequest req, HttpServletResponse res, int dispatch) throws IOException, ServletException
{    Request base_request = (req instanceof Request) ? (Request) req : HttpConnection.getCurrentConnection().getRequest();    res.addHeader("X-TestbedHandlers", this.getClass().getSimpleName());    handle(base_request, res, target, dispatch);}
72c868a48dd53158db91ed084d1b8ef6eade6d75c8a2b22b3a067bff3dde4b56
addMyHeader
public void addMyHeader(HttpServletResponse res, String name, String value)
{    name = "X-" + this.getClass().getSimpleName() + "-" + name;    res.addHeader(name, value);}
c61430954935b04afb3972cd815d89888d22367b303f8fe4cebef63899518af6
handle
public void handle(Request req, HttpServletResponse res, String target, int dispatch) throws IOException, ServletException
{    try {        int del = random ? r.nextInt(delay) : delay;        Thread.sleep(del);        addMyHeader(res, "Delay", String.valueOf(del));    } catch (Exception e) {    }}
c61430954935b04afb3972cd815d89888d22367b303f8fe4cebef63899518af6
handle
public void handle(Request req, HttpServletResponse res, String target, int dispatch) throws IOException, ServletException
{    HttpURI u = req.getUri();    String uri = u.toString();        addMyHeader(res, "URI", uri);        req.setHandled(true);    res.addHeader("X-Handled-By", getClass().getSimpleName());    if (uri.endsWith("/robots.txt")) {        return;    }    res.setContentType("text/html");    try {        OutputStream os = res.getOutputStream();        byte[] bytes = testA.getBytes("UTF-8");        os.write(bytes);                String p = "<p>URI: " + uri + "</p>\r\n";        os.write(p.getBytes());                String base;        if (u.getPath().length() > 5) {            base = u.getPath().substring(0, u.getPath().length() - 5);        } else {            base = u.getPath();        }        String prefix = u.getScheme() + "://" + u.getHost();        if (u.getPort() != 80 && u.getPort() != -1)            base += ":" + u.getPort();        if (!base.startsWith("/"))            prefix += "/";        prefix = prefix + base;        for (int i = 0; i < 10; i++) {            String link = "<p><a href='" + prefix;            if (!prefix.endsWith("/")) {                link += "/";            }            link += i + ".html'>outlink " + i + "</a></p>\r\n";            os.write(link.getBytes());        }                for (int i = 0; i < 5; i++) {                        int h = r.nextInt(1000000);            String link = "<p><a href='http://www.fake-" + h + ".com/'>fake host " + h + "</a></p>\r\n";            os.write(link.getBytes());        }                String link = "<p><a href='" + u.getScheme() + "://" + u.getHost();        if (u.getPort() != 80 && u.getPort() != -1)            link += ":" + u.getPort();        link += "/'>site " + u.getHost() + "</a></p>\r\n";        os.write(link.getBytes());        os.write(testB.getBytes());        res.flushBuffer();    } catch (IOException ioe) {    }}
c61430954935b04afb3972cd815d89888d22367b303f8fe4cebef63899518af6
handle
public void handle(Request req, HttpServletResponse res, String target, int dispatch) throws IOException, ServletException
{    LOG.info("-- " + req.getMethod() + " " + req.getUri().toString() + "\n" + req.getConnection().getRequestFields());}
19692ec2cdfc3768e39f2f63049f6f76586547f741ec3bd9cd08202bd35a903e
doFilter
public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException
{    ((HttpServletResponse) res).addHeader("X-Handled-By", "AsyncProxyHandler");    ((HttpServletResponse) res).addHeader("X-TestbedHandlers", "AsyncProxyHandler");    try {        chain.doFilter(req, res);    } catch (Throwable e) {        ((HttpServletResponse) res).sendError(HttpServletResponse.SC_BAD_REQUEST, e.toString());    }}
f989759145ce03a120821e2193e15112013025f38cba0aa162b1133f0013e369
init
public void init(FilterConfig arg0) throws ServletException
{}
c61430954935b04afb3972cd815d89888d22367b303f8fe4cebef63899518af6
handle
public void handle(Request req, HttpServletResponse res, String target, int dispatch) throws IOException, ServletException
{        req.setHandled(true);    res.addHeader("X-Handled-By", getClass().getSimpleName());    addMyHeader(res, "URI", req.getUri().toString());    res.sendError(HttpServletResponse.SC_NOT_FOUND, "Not found: " + req.getUri().toString());}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    if (args.length == 0) {        System.err.println("TestbedProxy [-seg <segment_name> | -segdir <segments>] [-port <nnn>] [-forward] [-fake] [-delay nnn] [-debug]");        System.err.println("-seg <segment_name>\tpath to a single segment (can be specified multiple times)");        System.err.println("-segdir <segments>\tpath to a parent directory of multiple segments (as above)");        System.err.println("-port <nnn>\trun the proxy on port <nnn> (special permissions may be needed for ports < 1024)");        System.err.println("-forward\tif specified, requests to all unknown urls will be passed to");        System.err.println("\t\toriginal servers. If false (default) unknown urls generate 404 Not Found.");        System.err.println("-delay\tdelay every response by nnn seconds. If delay is negative use a random value up to nnn");        System.err.println("-fake\tif specified, requests to all unknown urls will succeed with fake content");        System.exit(-1);    }    Configuration conf = NutchConfiguration.create();    int port = conf.getInt("segment.proxy.port", 8181);    boolean forward = false;    boolean fake = false;    boolean delay = false;    boolean debug = false;    int delayVal = 0;    HashSet<Path> segs = new HashSet<Path>();    for (int i = 0; i < args.length; i++) {        if (args[i].equals("-segdir")) {            FileSystem fs = FileSystem.get(conf);            FileStatus[] fstats = fs.listStatus(new Path(args[++i]));            Path[] paths = HadoopFSUtil.getPaths(fstats);            segs.addAll(Arrays.asList(paths));        } else if (args[i].equals("-port")) {            port = Integer.parseInt(args[++i]);        } else if (args[i].equals("-forward")) {            forward = true;        } else if (args[i].equals("-delay")) {            delay = true;            delayVal = Integer.parseInt(args[++i]);        } else if (args[i].equals("-fake")) {            fake = true;        } else if (args[i].equals("-debug")) {            debug = true;        } else if (args[i].equals("-seg")) {            segs.add(new Path(args[++i]));        } else {            LOG.error("Unknown argument: " + args[i]);            System.exit(-1);        }    }        Server server = new Server();    SocketConnector connector = new SocketConnector();    connector.setPort(port);    connector.setResolveNames(false);    server.addConnector(connector);        HandlerList list = new HandlerList();    server.addHandler(list);    if (debug) {        LOG.info("* Added debug handler.");        list.addHandler(new LogDebugHandler());    }    if (delay) {        LOG.info("* Added delay handler: " + (delayVal < 0 ? "random delay up to " + (-delayVal) : "constant delay of " + delayVal));        list.addHandler(new DelayHandler(delayVal));    }                Iterator<Path> it = segs.iterator();    while (it.hasNext()) {        Path p = it.next();        try {            SegmentHandler segment = new SegmentHandler(conf, p);            list.addHandler(segment);            LOG.info("* Added segment handler for: " + p);        } catch (Exception e) {            LOG.warn("Skipping segment '" + p + "': " + StringUtils.stringifyException(e));        }    }    if (forward) {        LOG.info("* Adding forwarding proxy for all unknown urls ...");        ServletHandler servlets = new ServletHandler();        servlets.addServletWithMapping(AsyncProxyServlet.class, "/*");        servlets.addFilterWithMapping(LogDebugHandler.class, "/*", Handler.ALL);        list.addHandler(servlets);    }    if (fake) {        LOG.info("* Added fake handler for remaining URLs.");        list.addHandler(new FakeHandler());    }    list.addHandler(new NotFoundHandler());        server.start();    server.join();}
c94aa625c3916f72280a7b0e313c3a037e072f791e4847551ba71c8a420468c3
accept
public boolean accept(Path p)
{    return p.getName().startsWith("part-");}
3e6281cdbf1a5f9d927bca1807121b18c9457296a1cff928b9f0852f1c51c1aa
getCrawlDatum
public CrawlDatum getCrawlDatum(Text url) throws IOException
{    synchronized (crawlLock) {        if (crawl == null)            crawl = getReaders(CrawlDatum.FETCH_DIR_NAME);    }    return (CrawlDatum) getEntry(crawl, url, new CrawlDatum());}
5aa5bb528b18106737d8ce52c4381e41122758fdb6bde5b15919101ade2ecab0
getContent
public Content getContent(Text url) throws IOException
{    synchronized (cLock) {        if (content == null)            content = getReaders(Content.DIR_NAME);    }    return (Content) getEntry(content, url, new Content());}
a746b43410704e195fc7ac5aea7c789b0ed2b9c09b167288e0637a24f3b474cb
getReaders
private MapFile.Reader[] getReaders(String subDir) throws IOException
{    Path dir = new Path(segmentDir, subDir);    FileSystem fs = dir.getFileSystem(conf);    Path[] names = FileUtil.stat2Paths(fs.listStatus(dir, SegmentPathFilter.INSTANCE));        Arrays.sort(names);    MapFile.Reader[] parts = new MapFile.Reader[names.length];    for (int i = 0; i < names.length; i++) {        parts[i] = new MapFile.Reader(names[i], conf);    }    return parts;}
9a0b48ef5409ee39cdaf5da2429a11d5cabc1c35d10562311efc1068332c726e
getEntry
private Writable getEntry(MapFile.Reader[] readers, Text url, Writable entry) throws IOException
{    return MapFileOutputFormat.getEntry(readers, PARTITIONER, url, entry);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    if (content != null) {        closeReaders(content);    }    if (parseText != null) {        closeReaders(parseText);    }    if (parseData != null) {        closeReaders(parseData);    }    if (crawl != null) {        closeReaders(crawl);    }}
8a42f2651e34ee18d86646068ade33822d032bc059154847711d671441147947
closeReaders
private void closeReaders(MapFile.Reader[] readers) throws IOException
{    for (int i = 0; i < readers.length; i++) {        readers[i].close();    }}
c61430954935b04afb3972cd815d89888d22367b303f8fe4cebef63899518af6
handle
public void handle(Request req, HttpServletResponse res, String target, int dispatch) throws IOException, ServletException
{    try {        String uri = req.getUri().toString();        LOG.info("URI: " + uri);        addMyHeader(res, "URI", uri);        Text url = new Text(uri.toString());        CrawlDatum cd = seg.getCrawlDatum(url);        if (cd != null) {            addMyHeader(res, "Res", "found");            LOG.info("-got " + cd.toString());            ProtocolStatus ps = (ProtocolStatus) cd.getMetaData().get(Nutch.WRITABLE_PROTO_STATUS_KEY);            if (ps != null) {                Integer TrCode = protoCodes.get(ps.getCode());                if (TrCode != null) {                    res.setStatus(TrCode.intValue());                } else {                    res.setStatus(HttpServletResponse.SC_OK);                }                addMyHeader(res, "ProtocolStatus", ps.toString());            } else {                res.setStatus(HttpServletResponse.SC_OK);            }            Content c = seg.getContent(url);            if (c == null) {                                req.setHandled(true);                res.addHeader("X-Handled-By", getClass().getSimpleName());                return;            }            byte[] data = c.getContent();            LOG.debug("-data len=" + data.length);            Metadata meta = c.getMetadata();            String[] names = meta.names();            LOG.debug("- " + names.length + " meta");            for (int i = 0; i < names.length; i++) {                boolean my = true;                char ch = names[i].charAt(0);                if (Character.isLetter(ch) && Character.isUpperCase(ch)) {                                        my = false;                }                String[] values = meta.getValues(names[i]);                for (int k = 0; k < values.length; k++) {                    if (my) {                        addMyHeader(res, names[i], values[k]);                    } else {                        res.addHeader(names[i], values[k]);                    }                }            }            req.setHandled(true);            res.addHeader("X-Handled-By", getClass().getSimpleName());            res.setContentType(meta.get(Metadata.CONTENT_TYPE));            res.setContentLength(data.length);            OutputStream os = res.getOutputStream();            os.write(data, 0, data.length);            res.flushBuffer();        } else {            addMyHeader(res, "Res", "not found");            LOG.info(" -not found " + url);        }    } catch (Exception e) {        e.printStackTrace();        LOG.warn(StringUtils.stringifyException(e));        addMyHeader(res, "Res", "Exception: " + StringUtils.stringifyException(e));    }}
6f0a4ab8d2d6509a620516cb4a5650505f4366ed6a45ea1903c6a43de25ec26a
testDump
public void testDump() throws Exception
{    File sampleSegmentDir = new File(System.getProperty("test.build.data", "."), "test-segments");    File tempDir = Files.createTempDirectory("temp").toFile();    String[] crawledFiles = { "c463a4381eb837f9f5d45978cfbde79e_.html", "a974b8d74f7779ab6c6f90b9b279467e_.html", "6bc6497314656a3129732efd708e9f96_.html", "6e88c40abe26cad0a726102997aed048_.html", "5cafdd88f4e9cf3f0cd4c298c6873358_apachecon-europe.html", "932dc10a76e894a2baa8ea4086ad72a8_apachecon-north-america.html", "8540187d75b9cd405b8fa97d665f9f90_.html", "e501bc976c8693b4d28a55b79c390a32_.html", "6add662f9f5758b7d75eec5cfa1f340b_.html", "d4f20df3c37033dc516067ee1f424e4e_.html", "d7b8fa9a02cdc95546030d04be4a98f3_solr.html", "3cbe876e3a8e7a397811de3bb6a945cd_.html", "5b987dde0da79d7f2e3f22b46437f514_bot.html", "3d742820d9a701a1f02e10d5bf5ae633_credits.html", "693673f3c73d04a26276effdea69b7ee_downloads.html", "4f7e3469dafabb4c3b87b00531f81aa4_index.html", "15c5330675be8a69995aab18ff9859e0_javadoc.html", "bc624e1b49e29870ef095819bb0e977a_mailing_lists.html", "a7d66b68754c3665c66e62225255e3fd_version_control.html", "32fb7fe362e1a0d8a1b15addf2a00bdc_1.9-rel", "54ab3db10fe7b26415a04e21045125a8_1zE.html", "1012a41c08092c40340598bd8ee0bfa6_PGa.html", "c830cfc5c28bed10e69d5b83e9c1bcdc_nutch_2.3", "687d915dc264a77f35c61ba841936730_oHY.html", "2bf1afb650010128b4cf4afe677db3c5_1pav9xl.html", "550cab79e14110bbee61c36c61c830b0_1pbE15n.html", "664ff07b46520cc1414494ae49da91f6_.html", "04223714e648a6a43d7c8af8b095f733_.html", "3c8ccb865cd72cca06635d74c7f2f3c4_.html", "90fe47b28716a2230c5122c83f0b8562_Becoming_A_Nutch_Developer.html", "ac0fefe70007d40644e2b8bd5da3c305_FAQ.html", "bc9bc7f11c1262e8924032ab1c7ce112_NutchPropertiesCompleteList.html", "78d04611985e7375b441e478fa36f610_.html", "64adaebadd44e487a8b58894e979dc70_CHANGES.txt", "a48e9c2659b703fdea3ad332877708d8_.html", "159d66d679dd4442d2d8ffe6a83b2912_sponsorship.html", "66f1ce6872c9195c665fc8bdde95f6dc_thanks.html", "ef7ee7e929a048c4a119af78492095b3_.html", "e4251896a982c2b2b68678b5c9c57f4d_.html", "5384764a16fab767ebcbc17d87758a24_.html", "a6ba75a218ef2a09d189cb7dffcecc0f_.html", "f2fa63bd7a3aca63841eed4cd10fb519_SolrCloud.html", "f8de0fbda874e1a140f1b07dcebab374_NUTCH-1047.html", "9c120e94f52d690e9cfd044c34134649_NUTCH-1591.html", "7dd70378379aa452279ce9200d0a5fed_NUTCH-841.html", "ddf78b1fe5c268d59fd62bc745815b92_.html", "401c9f04887dbbf8d29ad52841b8bdb3_ApacheNutch.html", "8f984e2d3c2ba68d1695288f1738deaf_Nutch.html", "c2ef09a95a956207cea073a515172be2_FrontPage.html", "90d9b76e8eabdab1cbcc29bea437c7ae_NutchRESTAPI.html" };    CommonCrawlDataDumper dumper = new CommonCrawlDataDumper(new CommonCrawlConfig());    dumper.dump(tempDir, sampleSegmentDir, null, false, null, false, "", false);    Collection<File> tempFiles = FileUtils.listFiles(tempDir, FileFilterUtils.fileFileFilter(), FileFilterUtils.directoryFileFilter());    for (String expectedFileName : crawledFiles) {        assertTrue("Missed file " + expectedFileName + " in dump", hasFile(expectedFileName, tempFiles));    }}
8bb92f7737d0e0614dce4836e5568797213bf808e0d1c71d75bdf384d0bc96ea
hasFile
private boolean hasFile(String fileName, Collection<File> files)
{    for (File f : files) {        if (f.getName().equals(fileName)) {            return true;        }    }    return false;}
65bda238e39d37b61b24dff8b855003bf8ddf2f876677559d5d12351f386e45e
testGetUrlMD5
public void testGetUrlMD5() throws Exception
{    String testUrl = "http://apache.org";    String result = DumpFileUtil.getUrlMD5(testUrl);    assertEquals("991e599262e04ea2ec76b6c5aed499a7", result);}
0c3957ce87e0925a28edaf94bebec69782ffe5ac64bfe3c8654eb7e801251f18
testCreateTwoLevelsDirectory
public void testCreateTwoLevelsDirectory() throws Exception
{    String testUrl = "http://apache.org";    String basePath = "/tmp";    String fullDir = DumpFileUtil.createTwoLevelsDirectory(basePath, DumpFileUtil.getUrlMD5(testUrl));    assertEquals("/tmp/96/ea", fullDir);    String basePath2 = "/this/path/is/not/existed/just/for/testing";    String fullDir2 = DumpFileUtil.createTwoLevelsDirectory(basePath2, DumpFileUtil.getUrlMD5(testUrl));    assertNull(fullDir2);}
d7a489619052deee3785264e33cb735a822fa0a164661d6ba686930b09e04481
testCreateFileName
public void testCreateFileName() throws Exception
{    String testUrl = "http://apache.org";    String baseName = "test";    String extension = "html";    String fullDir = DumpFileUtil.createFileName(DumpFileUtil.getUrlMD5(testUrl), baseName, extension);    assertEquals("991e599262e04ea2ec76b6c5aed499a7_test.html", fullDir);    String tooLongBaseName = "testtesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttest";    String fullDir2 = DumpFileUtil.createFileName(DumpFileUtil.getUrlMD5(testUrl), tooLongBaseName, extension);    assertEquals("991e599262e04ea2ec76b6c5aed499a7_testtesttesttesttesttesttesttest.html", fullDir2);    String tooLongExtension = "testtesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttest";    String fullDir3 = DumpFileUtil.createFileName(DumpFileUtil.getUrlMD5(testUrl), baseName, tooLongExtension);    assertEquals("991e599262e04ea2ec76b6c5aed499a7_test.testt", fullDir3);}
e72df880db8642f8661adf47a4daa63a429d203915c86f821dc2ed18b6945e8b
testGuessing
public void testGuessing()
{        conf.setInt(EncodingDetector.MIN_CONFIDENCE_KEY, -1);    Metadata metadata = new Metadata();    EncodingDetector detector;    Content content;    String encoding;    content = new Content("http://www.example.com", "http://www.example.com/", contentInOctets, "text/plain", metadata, conf);    detector = new EncodingDetector(conf);    detector.autoDetectClues(content, true);    encoding = detector.guessEncoding(content, "windows-1252");        Assert.assertEquals("windows-1252", encoding.toLowerCase());    metadata.clear();    metadata.set(Response.CONTENT_TYPE, "text/plain; charset=UTF-16");    content = new Content("http://www.example.com", "http://www.example.com/", contentInOctets, "text/plain", metadata, conf);    detector = new EncodingDetector(conf);    detector.autoDetectClues(content, true);    encoding = detector.guessEncoding(content, "windows-1252");    Assert.assertEquals("utf-16", encoding.toLowerCase());    metadata.clear();    content = new Content("http://www.example.com", "http://www.example.com/", contentInOctets, "text/plain", metadata, conf);    detector = new EncodingDetector(conf);    detector.autoDetectClues(content, true);    detector.addClue("windows-1254", "sniffed");    encoding = detector.guessEncoding(content, "windows-1252");    Assert.assertEquals("windows-1254", encoding.toLowerCase());        conf.setInt(EncodingDetector.MIN_CONFIDENCE_KEY, 50);    metadata.clear();    metadata.set(Response.CONTENT_TYPE, "text/plain; charset=UTF-16");    content = new Content("http://www.example.com", "http://www.example.com/", contentInOctets, "text/plain", metadata, conf);    detector = new EncodingDetector(conf);    detector.autoDetectClues(content, true);    detector.addClue("utf-32", "sniffed");    encoding = detector.guessEncoding(content, "windows-1252");    Assert.assertEquals("utf-8", encoding.toLowerCase());}
52e5dce2ecd28821f63a3e4ffe3549274e110b119abe0c216c04d9c878942db0
testZipUnzip
public void testZipUnzip()
{    byte[] testBytes = SHORT_TEST_STRING.getBytes();    testZipUnzip(testBytes);    testBytes = LONGER_TEST_STRING.getBytes();    testZipUnzip(testBytes);    testBytes = WEBPAGE.getBytes();    testZipUnzip(testBytes);}
53a2046c27cc7125c114592e5e705d31a552f2bc66b77350a7aab2e12c7438f1
testZipUnzipBestEffort
public void testZipUnzipBestEffort()
{    byte[] testBytes = SHORT_TEST_STRING.getBytes();    testZipUnzipBestEffort(testBytes);    testBytes = LONGER_TEST_STRING.getBytes();    testZipUnzipBestEffort(testBytes);    testBytes = WEBPAGE.getBytes();    testZipUnzipBestEffort(testBytes);}
133b91ad9e92864d145c1f40d5bfe437c03fad03929e4802a2377089926de2f9
testTruncation
public void testTruncation()
{    byte[] testBytes = SHORT_TEST_STRING.getBytes();    testTruncation(testBytes);    testBytes = LONGER_TEST_STRING.getBytes();    testTruncation(testBytes);    testBytes = WEBPAGE.getBytes();    testTruncation(testBytes);}
24584a793c8190385f5ab8d287d1973cefcc9abd2592da7fba7c46e24efcec30
testLimit
public void testLimit()
{    byte[] testBytes = SHORT_TEST_STRING.getBytes();    testLimit(testBytes);    testBytes = LONGER_TEST_STRING.getBytes();    testLimit(testBytes);    testBytes = WEBPAGE.getBytes();    testLimit(testBytes);}
f192d7179259021c76603e7ebe05dacb2ed5d01a89b61f96be36d8228c058c70
testZipUnzip
public void testZipUnzip(byte[] origBytes)
{    byte[] compressedBytes = GZIPUtils.zip(origBytes);    Assert.assertTrue("compressed array is not smaller!", compressedBytes.length < origBytes.length);    byte[] uncompressedBytes = null;    try {        uncompressedBytes = GZIPUtils.unzip(compressedBytes);    } catch (IOException e) {        e.printStackTrace();        Assert.assertTrue("caught exception '" + e + "' during unzip()", false);    }    Assert.assertTrue("uncompressedBytes is wrong size", uncompressedBytes.length == origBytes.length);    for (int i = 0; i < origBytes.length; i++) if (origBytes[i] != uncompressedBytes[i])        Assert.assertTrue("uncompressedBytes does not match origBytes", false);}
68960aacb8099036ab0025fa74bd50016c277813a806b01f692eb21af586fc2a
testZipUnzipBestEffort
public void testZipUnzipBestEffort(byte[] origBytes)
{    byte[] compressedBytes = GZIPUtils.zip(origBytes);    Assert.assertTrue("compressed array is not smaller!", compressedBytes.length < origBytes.length);    byte[] uncompressedBytes = GZIPUtils.unzipBestEffort(compressedBytes);    Assert.assertTrue("uncompressedBytes is wrong size", uncompressedBytes.length == origBytes.length);    for (int i = 0; i < origBytes.length; i++) if (origBytes[i] != uncompressedBytes[i])        Assert.assertTrue("uncompressedBytes does not match origBytes", false);}
8dc9924fc28df041755ece0c8bce86cefd26cb86a3cf2fc52f11279295b18565
testTruncation
public void testTruncation(byte[] origBytes)
{    byte[] compressedBytes = GZIPUtils.zip(origBytes);    System.out.println("original data has len " + origBytes.length);    System.out.println("compressed data has len " + compressedBytes.length);    for (int i = compressedBytes.length; i >= 0; i--) {        byte[] truncCompressed = new byte[i];        for (int j = 0; j < i; j++) truncCompressed[j] = compressedBytes[j];        byte[] trunc = GZIPUtils.unzipBestEffort(truncCompressed);        if (trunc == null) {            System.out.println("truncated to len " + i + ", trunc is null");        } else {            System.out.println("truncated to len " + i + ", trunc.length=  " + trunc.length);            for (int j = 0; j < trunc.length; j++) if (trunc[j] != origBytes[j])                Assert.assertTrue("truncated/uncompressed array differs at pos " + j + " (compressed data had been truncated to len " + i + ")", false);        }    }}
e55e816b7b2950ccf7ddbbd0c32b60cb0d6ca6bf044f651c6dcb3e1956e3fc9a
testLimit
public void testLimit(byte[] origBytes)
{    byte[] compressedBytes = GZIPUtils.zip(origBytes);    Assert.assertTrue("compressed array is not smaller!", compressedBytes.length < origBytes.length);    for (int i = 0; i < origBytes.length; i++) {        byte[] uncompressedBytes = GZIPUtils.unzipBestEffort(compressedBytes, i);        Assert.assertTrue("uncompressedBytes is wrong size", uncompressedBytes.length == i);        for (int j = 0; j < i; j++) if (origBytes[j] != uncompressedBytes[j])            Assert.assertTrue("uncompressedBytes does not match origBytes", false);    }}
fcc4acb8dc577efa40302960cbe4220f07abe3af658276b47f754054b7aee261
getMimeType
private String getMimeType(String url, File file, String contentType, boolean useMagic) throws IOException
{    return getMimeType(url, Files.toByteArray(file), contentType, useMagic);}
a315a4dc49513f3e0ab475681e628d32d487783349cd6dd7f9ed8cc4f71db03e
getMimeType
private String getMimeType(String url, byte[] bytes, String contentType, boolean useMagic)
{    Configuration conf = NutchConfiguration.create();    conf.setBoolean("mime.type.magic", useMagic);    MimeUtil mimeUtil = new MimeUtil(conf);    return mimeUtil.autoResolveContentType(contentType, url, bytes);}
99fb871576f2ae871e5f91545518eeba5f5dc6196ae0e6bce7e81bd5abd764e0
testWithMimeMagic
public void testWithMimeMagic()
{    for (String[] testPage : textBasedFormats) {        String mimeType = getMimeType(urlPrefix, testPage[3].getBytes(defaultCharset), testPage[2], true);        assertEquals("", testPage[0], mimeType);    }}
da137aab8653c55b1596a1a3d1ea347e6f8825e691bf63e659e139b8aa3beb05
testWithoutMimeMagic
public void testWithoutMimeMagic()
{    for (String[] testPage : textBasedFormats) {        if (testPage.length > 4 && "requires-mime-magic".equals(testPage[4])) {            continue;        }        String mimeType = getMimeType(urlPrefix + testPage[1], testPage[3].getBytes(defaultCharset), testPage[2], false);        assertEquals("", testPage[0], mimeType);    }}
63f9d73f36d7d8c487d732eea44d9a9c5348400a28742d5126b037499306123c
testOnlyMimeMagic
public void testOnlyMimeMagic()
{    for (String[] testPage : textBasedFormats) {        String mimeType = getMimeType(urlPrefix, testPage[3].getBytes(defaultCharset), "", true);        assertEquals("", testPage[0], mimeType);    }}
b460710d4ba26bf5737e60902f9d5c74e5457466b70cdf9cd21ea46cde87a17d
testBinaryFiles
public void testBinaryFiles() throws IOException
{    for (String[] testPage : binaryFiles) {        File dataFile = new File(sampleDir, testPage[1]);        String mimeType = getMimeType(urlPrefix + testPage[1], dataFile, testPage[2], false);        assertEquals("", testPage[0], mimeType);    }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    ULCONTENT[0] = "crawl several billion pages per month";    ULCONTENT[1] = "maintain an index of these pages";    ULCONTENT[2] = "search that index up to 1000 times per second";    ULCONTENT[3] = "operate at minimal cost";}
2d2765b3e2d8a8b7a311b2e711c7edd56fad3edc589fbb4450c4aff823f65609
testSkipChildren
public void testSkipChildren()
{    DOMParser parser = new DOMParser();    try {        parser.setFeature("http://xml.org/sax/features/validation", false);        parser.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);        parser.parse(new InputSource(new ByteArrayInputStream(WEBPAGE.getBytes())));    } catch (Exception e) {        e.printStackTrace();    }    StringBuffer sb = new StringBuffer();    NodeWalker walker = new NodeWalker(parser.getDocument());    while (walker.hasNext()) {        Node currentNode = walker.nextNode();        short nodeType = currentNode.getNodeType();        if (nodeType == Node.TEXT_NODE) {            String text = currentNode.getNodeValue();            text = text.replaceAll("\\s+", " ");            sb.append(text);        }    }    Assert.assertTrue("UL Content can NOT be found in the node", findSomeUlContent(sb.toString()));    StringBuffer sbSkip = new StringBuffer();    NodeWalker walkerSkip = new NodeWalker(parser.getDocument());    while (walkerSkip.hasNext()) {        Node currentNode = walkerSkip.nextNode();        String nodeName = currentNode.getNodeName();        short nodeType = currentNode.getNodeType();        if ("ul".equalsIgnoreCase(nodeName)) {            walkerSkip.skipChildren();        }        if (nodeType == Node.TEXT_NODE) {            String text = currentNode.getNodeValue();            text = text.replaceAll("\\s+", " ");            sbSkip.append(text);        }    }    Assert.assertFalse("UL Content can be found in the node", findSomeUlContent(sbSkip.toString()));}
cc9d2d3b2ec85d5eaa1824177edb65574a5efc0e195f8242a0a20964369149a3
findSomeUlContent
public boolean findSomeUlContent(String str)
{    for (int i = 0; i < ULCONTENT.length; i++) {        if (str.contains(ULCONTENT[i]))            return true;    }    return false;}
c84245278d24a0691b43807a8a5bf1e4ecb6dc177009eb7aed5e6528bcbdb5bb
makeRandString
private String makeRandString(int minLen, int maxLen)
{    int len = minLen + (int) (Math.random() * (maxLen - minLen));    char[] chars = new char[len];    for (int pos = 0; pos < len; pos++) {        chars[pos] = alphabet[(int) (Math.random() * alphabet.length)];    }    return new String(chars);}
5546a81d079a3f1b796317b3b09a362dae4bb1428ac7925cc0177804411ddb27
testPrefixMatcher
public void testPrefixMatcher()
{    int numMatches = 0;    int numInputsTested = 0;    for (int round = 0; round < NUM_TEST_ROUNDS; round++) {                int numPrefixes = (int) (Math.random() * MAX_TEST_PREFIXES);        String[] prefixes = new String[numPrefixes];        for (int i = 0; i < numPrefixes; i++) {            prefixes[i] = makeRandString(0, MAX_PREFIX_LEN);        }        PrefixStringMatcher prematcher = new PrefixStringMatcher(prefixes);                for (int i = 0; i < NUM_TEST_INPUTS_PER_ROUND; i++) {            String input = makeRandString(0, MAX_INPUT_LEN);            boolean matches = false;            int longestMatch = -1;            int shortestMatch = -1;            for (int j = 0; j < prefixes.length; j++) {                if ((prefixes[j].length() > 0) && input.startsWith(prefixes[j])) {                    matches = true;                    int matchSize = prefixes[j].length();                    if (matchSize > longestMatch)                        longestMatch = matchSize;                    if ((matchSize < shortestMatch) || (shortestMatch == -1))                        shortestMatch = matchSize;                }            }            if (matches)                numMatches++;            numInputsTested++;            Assert.assertTrue("'" + input + "' should " + (matches ? "" : "not ") + "match!", matches == prematcher.matches(input));            if (matches) {                Assert.assertTrue(shortestMatch == prematcher.shortestMatch(input).length());                Assert.assertTrue(input.substring(0, shortestMatch).equals(prematcher.shortestMatch(input)));                Assert.assertTrue(longestMatch == prematcher.longestMatch(input).length());                Assert.assertTrue(input.substring(0, longestMatch).equals(prematcher.longestMatch(input)));            }        }    }    System.out.println("got " + numMatches + " matches out of " + numInputsTested + " tests");}
7f69ef7f913f1b311b258e89b858f7b7ed676cf405a4c22e81b583b580660b70
testRightPad
public void testRightPad()
{    String s = "my string";    String ps = StringUtil.rightPad(s, 0);    Assert.assertTrue(s.equals(ps));    ps = StringUtil.rightPad(s, 9);    Assert.assertTrue(s.equals(ps));    ps = StringUtil.rightPad(s, 10);    Assert.assertTrue((s + " ").equals(ps));    ps = StringUtil.rightPad(s, 15);    Assert.assertTrue((s + "      ").equals(ps));}
5aee04d0ee01783536d1e4eea1459e67cb749856d9fb7113d7a14f65c9eb45e7
testLeftPad
public void testLeftPad()
{    String s = "my string";    String ps = StringUtil.leftPad(s, 0);    Assert.assertTrue(s.equals(ps));    ps = StringUtil.leftPad(s, 9);    Assert.assertTrue(s.equals(ps));    ps = StringUtil.leftPad(s, 10);    Assert.assertTrue((" " + s).equals(ps));    ps = StringUtil.leftPad(s, 15);    Assert.assertTrue(("      " + s).equals(ps));}
c84245278d24a0691b43807a8a5bf1e4ecb6dc177009eb7aed5e6528bcbdb5bb
makeRandString
private String makeRandString(int minLen, int maxLen)
{    int len = minLen + (int) (Math.random() * (maxLen - minLen));    char[] chars = new char[len];    for (int pos = 0; pos < len; pos++) {        chars[pos] = alphabet[(int) (Math.random() * alphabet.length)];    }    return new String(chars);}
1f36ddd65273e9d95ee6b28cde58633117540577388b179feace5b3928769017
testSuffixMatcher
public void testSuffixMatcher()
{    int numMatches = 0;    int numInputsTested = 0;    for (int round = 0; round < NUM_TEST_ROUNDS; round++) {                int numSuffixes = (int) (Math.random() * MAX_TEST_SUFFIXES);        String[] suffixes = new String[numSuffixes];        for (int i = 0; i < numSuffixes; i++) {            suffixes[i] = makeRandString(0, MAX_SUFFIX_LEN);        }        SuffixStringMatcher sufmatcher = new SuffixStringMatcher(suffixes);                for (int i = 0; i < NUM_TEST_INPUTS_PER_ROUND; i++) {            String input = makeRandString(0, MAX_INPUT_LEN);            boolean matches = false;            int longestMatch = -1;            int shortestMatch = -1;            for (int j = 0; j < suffixes.length; j++) {                if ((suffixes[j].length() > 0) && input.endsWith(suffixes[j])) {                    matches = true;                    int matchSize = suffixes[j].length();                    if (matchSize > longestMatch)                        longestMatch = matchSize;                    if ((matchSize < shortestMatch) || (shortestMatch == -1))                        shortestMatch = matchSize;                }            }            if (matches)                numMatches++;            numInputsTested++;            Assert.assertTrue("'" + input + "' should " + (matches ? "" : "not ") + "match!", matches == sufmatcher.matches(input));            if (matches) {                Assert.assertTrue(shortestMatch == sufmatcher.shortestMatch(input).length());                Assert.assertTrue(input.substring(input.length() - shortestMatch).equals(sufmatcher.shortestMatch(input)));                Assert.assertTrue(longestMatch == sufmatcher.longestMatch(input).length());                Assert.assertTrue(input.substring(input.length() - longestMatch).equals(sufmatcher.longestMatch(input)));            }        }    }    System.out.println("got " + numMatches + " matches out of " + numInputsTested + " tests");}
41eefbd62513624ee21e4b6a4c94343868be4d5ef7c469dc4dafc0309342053c
testReverseUrl
public void testReverseUrl() throws Exception
{    assertReverse(urlString1, reversedUrlString1);    assertReverse(urlString2, reversedUrlString2);    assertReverse(urlString3, reversedUrlString3);    assertReverse(urlString4, reversedUrlString4);    assertReverse(urlString5, reversedUrlString5);    assertReverse(urlString5, reversedUrlString5);    assertReverse(urlString6, reversedUrlString6);    assertReverse(urlString7, reversedUrlString7);}
6d2b63086418543891c9c28f58e8d0abbf3544ca37059c9f7238e1e242deb7e0
testUnreverseUrl
public void testUnreverseUrl() throws Exception
{    assertUnreverse(reversedUrlString1, urlString1);    assertUnreverse(reversedUrlString2, urlString2);    assertUnreverse(reversedUrlString3, urlString3);    assertUnreverse(reversedUrlString4, urlString4);    assertUnreverse(reversedUrlString5, urlString5rev);    assertUnreverse(reversedUrlString6, urlString6);    assertUnreverse(reversedUrlString7, urlString7);}
d16bfcea5b76c885572f604ab00ff5480f15bdd9fc49ebca9114feada7e054c6
assertReverse
private static void assertReverse(String url, String expectedReversedUrl) throws Exception
{    String reversed = TableUtil.reverseUrl(url);    assertEquals(expectedReversedUrl, reversed);}
e36aac452a077087840e2824e2af36a60422e9e06ba594601e911c48cc903546
assertUnreverse
private static void assertUnreverse(String reversedUrl, String expectedUrl)
{    String unreversed = TableUtil.unreverseUrl(reversedUrl);    assertEquals(expectedUrl, unreversed);}
b557fe530120ae5a4902c3013dc280dff15783421cbd8f4dde3f6cb01d22066f
testGetDomainName
public void testGetDomainName() throws Exception
{    URL url = null;    url = new URL("http://lucene.apache.org/nutch");    Assert.assertEquals("apache.org", URLUtil.getDomainName(url));    url = new URL("http://en.wikipedia.org/wiki/Java_coffee");    Assert.assertEquals("wikipedia.org", URLUtil.getDomainName(url));    url = new URL("http://140.211.11.130/foundation/contributing.html");    Assert.assertEquals("140.211.11.130", URLUtil.getDomainName(url));    url = new URL("http://www.example.co.uk:8080/index.html");    Assert.assertEquals("example.co.uk", URLUtil.getDomainName(url));    url = new URL("http://com");    Assert.assertEquals("com", URLUtil.getDomainName(url));    url = new URL("http://www.example.co.uk.com");    Assert.assertEquals("uk.com", URLUtil.getDomainName(url));        url = new URL("http://example.com.nn");    Assert.assertEquals("nn", URLUtil.getDomainName(url));    url = new URL("http://");    Assert.assertEquals("", URLUtil.getDomainName(url));    url = new URL("http://www.edu.tr.xyz");    Assert.assertEquals("xyz", URLUtil.getDomainName(url));    url = new URL("http://www.example.c.se");    Assert.assertEquals("example.c.se", URLUtil.getDomainName(url));        url = new URL("http://www.example.plc.co.im");    Assert.assertEquals("example.plc.co.im", URLUtil.getDomainName(url));        url = new URL("http://www.example.2000.hu");    Assert.assertEquals("example.2000.hu", URLUtil.getDomainName(url));        url = new URL("http://www.example..tw");    Assert.assertEquals("example..tw", URLUtil.getDomainName(url));}
a5621dea012b474e3478ea1af72da015eb1ba49f8ac2dfd059abcbdfe64c9bab
testGetDomainSuffix
public void testGetDomainSuffix() throws Exception
{    URL url = null;    url = new URL("http://lucene.apache.org/nutch");    Assert.assertEquals("org", URLUtil.getDomainSuffix(url).getDomain());    url = new URL("http://140.211.11.130/foundation/contributing.html");    Assert.assertNull(URLUtil.getDomainSuffix(url));    url = new URL("http://www.example.co.uk:8080/index.html");    Assert.assertEquals("co.uk", URLUtil.getDomainSuffix(url).getDomain());    url = new URL("http://com");    Assert.assertEquals("com", URLUtil.getDomainSuffix(url).getDomain());    url = new URL("http://www.example.co.uk.com");    Assert.assertEquals("com", URLUtil.getDomainSuffix(url).getDomain());        url = new URL("http://example.com.nn");    Assert.assertNull(URLUtil.getDomainSuffix(url));    url = new URL("http://");    Assert.assertNull(URLUtil.getDomainSuffix(url));    url = new URL("http://www.edu.tr.xyz");    Assert.assertNull(URLUtil.getDomainSuffix(url));    url = new URL("http://subdomain.example.edu.tr");    Assert.assertEquals("edu.tr", URLUtil.getDomainSuffix(url).getDomain());    url = new URL("http://subdomain.example.presse.fr");    Assert.assertEquals("presse.fr", URLUtil.getDomainSuffix(url).getDomain());    url = new URL("http://subdomain.example.presse.tr");    Assert.assertEquals("tr", URLUtil.getDomainSuffix(url).getDomain());        url = new URL("http://www.example.plc.co.im");    Assert.assertEquals("plc.co.im", URLUtil.getDomainSuffix(url).getDomain());        url = new URL("http://www.example.2000.hu");    Assert.assertEquals("2000.hu", URLUtil.getDomainSuffix(url).getDomain());        url = new URL("http://www.example..tw");    Assert.assertEquals(".tw", URLUtil.getDomainSuffix(url).getDomain());}
e26bcb0b7b5db1e8378237221897473e3e7aa23ea74493877736405a6fdb47da
testGetHostSegments
public void testGetHostSegments() throws Exception
{    URL url;    String[] segments;    url = new URL("http://subdomain.example.edu.tr");    segments = URLUtil.getHostSegments(url);    Assert.assertEquals("subdomain", segments[0]);    Assert.assertEquals("example", segments[1]);    Assert.assertEquals("edu", segments[2]);    Assert.assertEquals("tr", segments[3]);    url = new URL("http://");    segments = URLUtil.getHostSegments(url);    Assert.assertEquals(1, segments.length);    Assert.assertEquals("", segments[0]);    url = new URL("http://140.211.11.130/foundation/contributing.html");    segments = URLUtil.getHostSegments(url);    Assert.assertEquals(1, segments.length);    Assert.assertEquals("140.211.11.130", segments[0]);        url = new URL("http://www.example..tw");    segments = URLUtil.getHostSegments(url);    Assert.assertEquals("www", segments[0]);    Assert.assertEquals("example", segments[1]);    Assert.assertEquals("", segments[2]);    Assert.assertEquals("tw", segments[3]);}
caa5f99133f71dc141d8bcf2f8337c9d949d033cd4d3f50e28dab9a1c5ecf1ef
testChooseRepr
public void testChooseRepr() throws Exception
{    String aDotCom = "http://www.a.com";    String bDotCom = "http://www.b.com";    String aSubDotCom = "http://www.news.a.com";    String aQStr = "http://www.a.com?y=1";    String aPath = "http://www.a.com/xyz/index.html";    String aPath2 = "http://www.a.com/abc/page.html";    String aPath3 = "http://www.news.a.com/abc/page.html";            Assert.assertEquals(bDotCom, URLUtil.chooseRepr(aDotCom, bDotCom, true));    Assert.assertEquals(bDotCom, URLUtil.chooseRepr(aDotCom, bDotCom, false));            Assert.assertEquals(aDotCom, URLUtil.chooseRepr(aDotCom, aQStr, false));    Assert.assertEquals(aDotCom, URLUtil.chooseRepr(aDotCom, aPath, false));            Assert.assertEquals(aDotCom, URLUtil.chooseRepr(aPath, aDotCom, false));            Assert.assertEquals(aPath2, URLUtil.chooseRepr(aPath, aPath2, false));            Assert.assertEquals(aDotCom, URLUtil.chooseRepr(aDotCom, aPath, true));            Assert.assertEquals(aDotCom, URLUtil.chooseRepr(aPath, aDotCom, true));                    Assert.assertEquals(aPath2, URLUtil.chooseRepr(aPath, aPath2, true));    Assert.assertEquals(aPath, URLUtil.chooseRepr(aPath, aPath3, true));            Assert.assertEquals(aDotCom, URLUtil.chooseRepr(aDotCom, aSubDotCom, true));}
6a41b44873a9628b46bae8c4823d53f4d442dafef1cefac906b7fbc8cf3471a9
testResolveURL
public void testResolveURL() throws Exception
{        URL u436 = new URL("http://a/b/c/d;p?q#f");    Assert.assertEquals("http://a/b/c/d;p?q#f", u436.toString());    URL abs = URLUtil.resolveURL(u436, "?y");    Assert.assertEquals("http://a/b/c/d;p?y", abs.toString());        URL u566 = new URL("http://www.fleurie.org/entreprise.asp");    abs = URLUtil.resolveURL(u566, "?id_entrep=111");    Assert.assertEquals("http://www.fleurie.org/entreprise.asp?id_entrep=111", abs.toString());    URL base = new URL(baseString);    Assert.assertEquals("base url parsing", baseString, base.toString());    for (int i = 0; i < targets.length; i++) {        URL u = URLUtil.resolveURL(base, targets[i][0]);        Assert.assertEquals(targets[i][1], targets[i][1], u.toString());    }}
2b26cf7362c47baa222a5fe7ca551c5e89d53026ff81df3c782193db393d2f5e
testToUNICODE
public void testToUNICODE() throws Exception
{    Assert.assertEquals("http://www.evir.com", URLUtil.toUNICODE("http://www.xn--evir-zoa.com"));    Assert.assertEquals("http://uni-tbingen.de/", URLUtil.toUNICODE("http://xn--uni-tbingen-xhb.de/"));    Assert.assertEquals("http://www.medizin.uni-tbingen.de:8080/search.php?q=abc#p1", URLUtil.toUNICODE("http://www.medizin.xn--uni-tbingen-xhb.de:8080/search.php?q=abc#p1"));}
12cb970d7b0ede75ab554cc951e3f5cc56d0427117f7ec3cfc8f842dc1534287
testToASCII
public void testToASCII() throws Exception
{    Assert.assertEquals("http://www.xn--evir-zoa.com", URLUtil.toASCII("http://www.evir.com"));    Assert.assertEquals("http://xn--uni-tbingen-xhb.de/", URLUtil.toASCII("http://uni-tbingen.de/"));    Assert.assertEquals("http://www.medizin.xn--uni-tbingen-xhb.de:8080/search.php?q=abc#p1", URLUtil.toASCII("http://www.medizin.uni-tbingen.de:8080/search.php?q=abc#p1"));}
bc385f1f0554f535adc17a8c98a9c9b1d74247e1270480778abee02f3583aa52
testFileProtocol
public void testFileProtocol() throws Exception
{        Assert.assertEquals("file:/path/file.html", URLUtil.toASCII("file:/path/file.html"));    Assert.assertEquals("file:/path/file.html", URLUtil.toUNICODE("file:/path/file.html"));}
ebab7f17ecaa5535f41b2b3eb06526906f936918e974c27f8d560b38dbacaad2
testWritable
public static void testWritable(Writable before) throws Exception
{    testWritable(before, null);}
aa7667d2da365a4986ce9b25d651aa2d992de73f280e51ef5510cc09793c51c7
testWritable
public static void testWritable(Writable before, Configuration conf) throws Exception
{    Assert.assertEquals(before, writeRead(before, conf));}
d0a62e28c186b7b29a0631467b5d2b0c3b1a9cf76b6e51933d3a3b94a7b03e7e
writeRead
public static Writable writeRead(Writable before, Configuration conf) throws Exception
{    DataOutputBuffer dob = new DataOutputBuffer();    before.write(dob);    DataInputBuffer dib = new DataInputBuffer();    dib.reset(dob.getData(), dob.getLength());    Writable after = (Writable) before.getClass().getConstructor().newInstance();    if (conf != null) {        ((Configurable) after).setConf(conf);    }    after.readFields(dib);    return after;}
